{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"OpenSCvx","text":"<p>Welcome to OpenSCvx.</p>"},{"location":"citation/","title":"Citation","text":"<p>If you use OpenSCvx in your research, please cite the following works:</p>"},{"location":"citation/#primary-citation","title":"Primary Citation","text":"<pre><code>@ARTICLE{hayner2025los,\n        author={Hayner, Christopher R. and Carson III, John M. and A\u00e7\u0131kme\u015fe, Beh\u00e7et and Leung, Karen},\n        journal={IEEE Robotics and Automation Letters}, \n        title={Continuous-Time Line-of-Sight Constrained Trajectory Planning for 6-Degree of Freedom Systems}, \n        year={2025},\n        volume={},\n        number={},\n        pages={1-8},\n        keywords={Robot sensing systems;Vectors;Vehicle dynamics;Line-of-sight propagation;Trajectory planning;Trajectory optimization;Quadrotors;Nonlinear dynamical systems;Heuristic algorithms;Convergence;Constrained Motion Planning;Optimization and Optimal Control;Aerial Systems: Perception and Autonomy},\n        doi={10.1109/LRA.2025.3545299}}\n</code></pre>"},{"location":"citation/#methodological-foundation","title":"Methodological Foundation","text":"<pre><code>@misc{elango2024ctscvx,\n      title={Successive Convexification for Trajectory Optimization with Continuous-Time Constraint Satisfaction}, \n      author={Purnanand Elango and Dayou Luo and Abhinav G. Kamath and Samet Uzun and Taewan Kim and Beh\u00e7et A\u00e7\u0131kme\u015fe},\n      year={2024},\n      eprint={2404.16826},\n      archivePrefix={arXiv},\n      primaryClass={math.OC},\n      url={https://arxiv.org/abs/2404.16826}, \n}\n</code></pre>"},{"location":"citation/#solver-technology","title":"Solver Technology","text":"<pre><code>@misc{chari2025qoco,\n  title = {QOCO: A Quadratic Objective Conic Optimizer with Custom Solver Generation},\n  author = {Chari, Govind M and A{\\c{c}}{\\i}kme{\\c{s}}e, Beh{\\c{c}}et},\n  year = {2025},\n  eprint = {2503.12658},\n  archiveprefix = {arXiv},\n  primaryclass = {math.OC},\n}\n</code></pre>"},{"location":"citation/#acknowledgments","title":"Acknowledgments","text":"<p>This work was supported by a NASA Space Technology Graduate Research Opportunity and the Office of Naval Research under grant N00014-17-1-2433. The authors would like to acknowledge Natalia Pavlasek, Samuel Buckner, Abhi Kamath, Govind Chari, and Purnanand Elango as well as the other Autonomous Controls Laboratory members, for their many helpful discussions and support throughout this work. </p>"},{"location":"examples/","title":"Examples","text":"<p>OpenSCvx comes with a comprehensive set of examples demonstrating various trajectory optimization problems. These examples are located in the <code>examples/</code> folder and cover different applications and complexity levels.</p>"},{"location":"examples/#running-examples","title":"Running Examples","text":"<p>See <code>examples/params/</code> folder for several example trajectory optimization problems. To run a problem simply run any of the examples directly, for example:</p> <pre><code>python3 examples/params/brachistochrone.py\n</code></pre> <p>and adjust the plotting as needed.</p>"},{"location":"examples/#example-categories","title":"Example Categories","text":""},{"location":"examples/#abstract-problems","title":"Abstract Problems","text":"<ul> <li>Brachistochrone: Classic minimum-time problem with gravity</li> <li>3DoF Rocket Landing: Rocket landing with fuel optimization</li> </ul>"},{"location":"examples/#drone-applications","title":"Drone Applications","text":"<ul> <li>Obstacle Avoidance: 6DoF drone navigating around obstacles</li> <li>Line-of-Sight Guidance: Drone maintaining line-of-sight to keypoints while passing through gates</li> <li>Cinema View Planning: Camera drone planning for cinematic shots</li> <li>Drone Racing: High-speed racing through gates</li> </ul>"},{"location":"examples/#ground-vehicle-applications","title":"Ground Vehicle Applications","text":"<ul> <li>Dubins Car: Simple 2D vehicle with turning constraints</li> <li>Dubins Car with Waypoints: Navigation through multiple waypoints</li> </ul>"},{"location":"examples/#real-time-applications","title":"Real-time Applications","text":"<ul> <li>Real-time Drone Racing: Live optimization during flight</li> <li>Real-time Obstacle Avoidance: Dynamic obstacle avoidance</li> </ul>"},{"location":"examples/#creating-your-own-problems","title":"Creating Your Own Problems","text":"<p>Check out the problem definitions inside <code>examples/params</code> to see how to define your own problems. Each example demonstrates:</p> <ul> <li>State and control variable definition</li> <li>Dynamics specification</li> <li>Constraint formulation</li> <li>Problem instantiation and solving</li> <li>Results visualization</li> </ul>"},{"location":"examples/#example-structure","title":"Example Structure","text":"<p>Most examples follow this structure:</p> <ol> <li>Imports: Import necessary OpenSCvx modules</li> <li>Problem Setup: Define parameters, state, and control variables</li> <li>Dynamics: Specify the system dynamics</li> <li>Constraints: Define path and boundary constraints</li> <li>Problem Instantiation: Create and configure the Problem</li> <li>Solving: Run the optimization</li> <li>Visualization: Plot and analyze results</li> </ol>"},{"location":"examples/#interactive-examples","title":"Interactive Examples","text":"<p>For interactive 3D visualization, many examples include GUI plotting functions:</p> <pre><code>from examples.plotting import plot_animation_pyqtgraph\n\n# After solving the problem\nplot_animation_pyqtgraph(results).show()\n</code></pre>"},{"location":"examples/#performance-tips","title":"Performance Tips","text":"<ul> <li>Start with simpler examples to understand the workflow</li> <li>Use the provided initial guesses as starting points</li> <li>Adjust SCP weights based on your specific problem</li> <li>Consider using CVXPYGen for faster performance on smaller problems </li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>OpenSCvx is a JAX-based Python library for trajectory optimization using Successive Convexification (SCvx). It provides a simple interface for formulating and solving trajectory optimization problems with continuous-time constraint satisfaction.</p> <p>Important</p> <p>The library is currently in beta testing. Please report any issues on the GitHub repository.</p>"},{"location":"getting-started/#key-features","title":"Key Features","text":"<ul> <li>JAX-based: Automatic differentiation, vectorization, and compilation</li> <li>Continuous-time constraints: Support for path constraints that must be satisfied at all times</li> <li>Successive Convexification: Robust optimization algorithm for non-convex problems</li> <li>Multiple constraint types: Continuous-time, nodal, and boundary constraints</li> <li>Interactive visualization: 3D plotting and real-time optimization visualization</li> <li>Code generation: Automatic C++ code generation for optimization problems</li> <li>Faster solver performance through compiled code for smaller problems</li> <li>Support for customized solver backends like QOCOGen</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>You can install OpenSCvx using pip or uv. For the most common use case, which includes support for interactive plotting and code generation, you can install the library with the <code>gui</code> and <code>cvxpygen</code> extras:</p> <pre><code>pip install openscvx[gui,cvxpygen]\n# or with uv\nuv pip install openscvx[gui,cvxpygen]\n</code></pre> <p>If you only need the core library without the optional features, you can run:</p> <pre><code>pip install openscvx\n# or with uv\nuv pip install openscvx\n</code></pre>"},{"location":"getting-started/#development-version-nightly","title":"Development Version (Nightly)","text":"<p>To install the latest development version (nightly) from PyPI:</p> <pre><code>pip install --pre openscvx[gui,cvxpygen]\n# or with uv\nuv pip install --pre openscvx[gui,cvxpygen]\n</code></pre> <p>Or for just the core library:</p> <pre><code>pip install --pre openscvx\n# or with uv\nuv pip install --pre openscvx\n</code></pre> <p>Pre-release Versions</p> <p>The <code>--pre</code> flag tells pip/uv to install pre-release versions (e.g., <code>1.2.4.dev3</code>). These nightly builds contain the latest features and bug fixes but may be less stable than official releases.</p>"},{"location":"getting-started/#local-development","title":"Local Development","text":"<p>For local development, you can clone the repository and install it in editable mode:</p> <pre><code># Clone the repo\ngit clone https://github.com/haynec/OpenSCvx.git\ncd OpenSCvx\n\n# Install in editable mode with all optional dependencies\npip install -e \".[gui,cvxpygen]\"\n# or with uv\nuv pip install -e \".[gui,cvxpygen]\"\n</code></pre>"},{"location":"getting-started/#dependencies","title":"Dependencies","text":"<p>OpenSCvx has a few optional dependency groups:</p> <p>The core dependencies are installed automatically with <code>openscvx</code>:</p> <ul> <li><code>cvxpy</code> - for convex optimization</li> <li><code>jax</code> - for fast linear algebra, automatic differentiation, and vectorization</li> <li><code>numpy</code> - for numerical operations</li> <li><code>diffrax</code> - for automatic differentiation</li> <li><code>termcolor</code> - for colored terminal output</li> <li> <p><code>plotly</code> - for basic interactive 3D plotting</p> </li> <li> <p><code>gui</code>: For interactive 3D plotting and real-time visualization. This includes:</p> <ul> <li><code>pyqtgraph</code> - for realtime 3D plotting</li> <li><code>PyQt5</code> - for GUI</li> <li><code>scipy</code> - for spatial operations</li> <li><code>PyOpenGL</code> - for 3D plotting</li> <li><code>PyOpenGL_accelerate</code> (optional, for speed) - for 3D plotting</li> </ul> </li> <li> <p><code>cvxpygen</code>: For C++ code generation, enabling faster solver performance on smaller problems. This includes:</p> <ul> <li><code>cvxpygen</code> - for C++ code generation</li> <li><code>qocogen</code> - fast SOCP solver</li> </ul> </li> </ul>"},{"location":"getting-started/#local-development_1","title":"Local Development","text":"<p>For setting up a local development environment, we recommend using Conda to manage environments.</p> Via Conda  1.  Clone the repository:     <pre><code>git clone https://github.com/haynec/OpenSCvx.git\ncd OpenSCvx\n</code></pre> 2.  Create and activate a conda environment with Python:     <pre><code>conda create -n openscvx python&gt;=3.9\nconda activate openscvx\n</code></pre> 3.  Install the package in editable mode with all optional dependencies:     <pre><code>pip install -e \".[gui,cvxpygen]\"\n</code></pre> Via uv  1.  Prerequisites: Install [uv](https://docs.astral.sh/uv/getting-started/installation/) 2.  Clone the repository:     <pre><code>git clone https://github.com/haynec/OpenSCvx.git\ncd OpenSCvx\n</code></pre> 3.  Create and activate a virtual environment:     <pre><code>uv venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n</code></pre> 4.  Install the package in editable mode with all optional dependencies:     <pre><code>uv pip install -e \".[gui,cvxpygen]\"\n</code></pre> Via pip and venv  1.  Clone the repository:     <pre><code>git clone https://github.com/haynec/OpenSCvx.git\ncd OpenSCvx\n</code></pre> 2.  Create and activate a virtual environment:     <pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre> 3.  Install the package in editable mode with all optional dependencies:     <pre><code>pip install -e \".[gui,cvxpygen]\"\n</code></pre>"},{"location":"getting-started/#quick-example","title":"Quick Example","text":"<p>Here's a simple example to get you started with OpenSCvx. This demonstrates a minimum-time problem where a vehicle moves from the origin to a target position:</p> <pre><code>import numpy as np\nimport openscvx as ox\nfrom openscvx import Problem\n\n# Define state variables\nposition = ox.State(\"position\", shape=(2,))  # 2D position [x, y]\nposition.min = np.array([-10.0, -10.0])\nposition.max = np.array([10.0, 10.0])\nposition.initial = np.array([0.0, 0.0])\nposition.final = np.array([5.0, 5.0])\n\n# Define control variables\nvelocity = ox.Control(\"velocity\", shape=(2,))  # Velocity [vx, vy]\nvelocity.min = np.array([-2.0, -2.0])\nvelocity.max = np.array([2.0, 2.0])\n\n# Set initial guesses\nposition.guess = np.linspace(position.initial, position.final, 20)\nvelocity.guess = np.repeat(\n    np.expand_dims(np.array([1.0, 1.0]), axis=0), 20, axis=0\n)\n\n# Collect states and controls\nstates = [position]\ncontrols = [velocity]\n\n# Define dynamics using symbolic expressions\ndynamics = {\n    \"position\": velocity,  # position derivative is velocity\n}\n\n# Define time (minimize final time)\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", 5.0),  # Minimize final time with initial guess of 5.0\n    min=0.0,\n    max=10.0,\n)\n\n# Create the problem\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=[],\n    N=20,\n)\n\n# Solve the problem\nproblem.initialize()\nresult = problem.solve()\nresult = problem.post_process(result)\n\n# Access results\nprint(f\"Converged: {result.converged}\")\nprint(f\"Optimal time: {result.t_final:.3f}\")\nprint(f\"Final position: {result.trajectory['position'][-1]}\")\nprint(f\"Total cost: {result.cost:.3f}\")\n</code></pre> <p>Note</p> <p>This is a basic example. For more complex problems, see the Examples section.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Examples: Explore the comprehensive set of example problems</li> <li>Basic Problem Setup: Learn how to set up your first optimization problem</li> <li>Advanced Problem Setup: Learn how to set up a more complex optimization problem</li> <li>API Reference: Detailed documentation of all classes and functions</li> <li>Citation: Information for citing OpenSCvx in your research</li> </ul>"},{"location":"Overview/constraint_reformulation/","title":"Isoperimetric Constraint Reformulation","text":"<p>Warning</p> <p>This page is still under development .</p> <p> </p>"},{"location":"Overview/control_parameterization/","title":"Control Parameterization","text":"<p>Warning</p> <p>This page is still under development .</p>"},{"location":"Overview/discretization/","title":"Exact Discretization","text":"<p>Warning</p> <p>This page is still under development .</p> dVdt.py<pre><code>def dVdt(self,\n             tau: float,\n             V: jnp.ndarray,\n             u_cur: np.ndarray,\n             u_next: np.ndarray\n             ) -&gt; jnp.ndarray:\n        \"\"\"\n        Computes the time derivative of the augmented state vector for the system for a sequence of states.\n\n        Parameters:\n        tau (float): Current time.\n        V (np.ndarray): Sequence of augmented state vectors.\n        u_cur (np.ndarray): Sequence of current control inputs.\n        u_next (np.ndarray): Sequence of next control inputs.\n        A: Function that computes the Jacobian of the system dynamics with respect to the state.\n        B: Function that computes the Jacobian of the system dynamics with respect to the control input.\n        obstacles: List of obstacles in the environment.\n        params (dict): Parameters of the system.\n\n        Returns:\n        np.ndarray: Time derivatives of the augmented state vectors.\n        \"\"\"\n\n        # Extract the number of states and controls from the parameters\n        n_x = self.params.sim.n_states\n        n_u = self.params.sim.n_controls\n\n        # Unflatten V\n        V = V.reshape(-1, self.i5)\n\n        # Compute the interpolation factor based on the discretization type\n        if self.params.dis.dis_type == 'ZOH':\n            beta = 0.\n        elif self.params.dis.dis_type == 'FOH':\n            beta = (tau) * self.params.scp.n\n        alpha = 1 - beta\n\n        # Interpolate the control input\n        u = u_cur + beta * (u_next - u_cur)\n        s = u[:,-1]\n\n        # Initialize the augmented Jacobians\n        dfdx = jnp.zeros((V.shape[0], n_x, n_x))\n        dfdu = jnp.zeros((V.shape[0], n_x, n_u))\n\n        # Ensure x_seq and u have the same batch size\n        x = V[:,:self.params.sim.n_states]\n        u = u[:x.shape[0]]\n\n        # Compute the nonlinear propagation term\n        f = self.params.dyn.state_dot(x, u[:,:-1])\n        F = s[:, None] * f\n\n        # Evaluate the State Jacobian\n        dfdx = self.params.dyn.A(x, u[:,:-1])\n        sdfdx = s[:, None, None] * dfdx\n\n        # Evaluate the Control Jacobian\n        dfdu_veh = self.params.dyn.B(x, u[:,:-1])\n        dfdu = dfdu.at[:, :, :-1].set(s[:, None, None] * dfdu_veh)\n        dfdu = dfdu.at[:, :, -1].set(f)\n\n        # Compute the defect\n        z = F - jnp.einsum('ijk,ik-&gt;ij', sdfdx, x) - jnp.einsum('ijk,ik-&gt;ij', dfdu, u)\n\n        # Stack up the results into the augmented state vector\n        dVdt = jnp.zeros_like(V)\n        dVdt = dVdt.at[:, self.i0:self.i1].set(F)\n        dVdt = dVdt.at[:, self.i1:self.i2].set(jnp.matmul(sdfdx, V[:, self.i1:self.i2].reshape(-1, n_x, n_x)).reshape(-1, n_x * n_x))\n        dVdt = dVdt.at[:, self.i2:self.i3].set((jnp.matmul(sdfdx, V[:, self.i2:self.i3].reshape(-1, n_x, n_u)) + dfdu * alpha).reshape(-1, n_x * n_u))\n        dVdt = dVdt.at[:, self.i3:self.i4].set((jnp.matmul(sdfdx, V[:, self.i3:self.i4].reshape(-1, n_x, n_u)) + dfdu * beta).reshape(-1, n_x * n_u))\n        dVdt = dVdt.at[:, self.i4:self.i5].set((jnp.matmul(sdfdx, V[:, self.i4:self.i5].reshape(-1, n_x)[..., None]).squeeze(-1) + z).reshape(-1, n_x))\n        return dVdt.flatten()\n</code></pre>"},{"location":"Overview/ocp/","title":"Optimal Control Problem","text":"<p>Warning</p> <p>This page is still under development .</p> <p>The underlying convex subproblem is posed in the following general form. </p> <p><pre><code>def OptimalControlProblem(params: Config):\n</code></pre> The problem is defined as a function that takes in a <code>Config</code> object, which contains all the necessary parameters for the problem. The function returns a <code>cvxpy.Problem</code> object that can be solved using various solvers.</p>"},{"location":"Overview/ocp/#variable-and-parameter-definition","title":"Variable and Parameter Definition","text":"<p>The state, constrol and additional parameters are defined as follows:</p> <pre><code>w_tr = cp.Parameter(nonneg = True, name='w_tr')       # Weight on the Trust Region\nlam_cost = cp.Parameter(nonneg=True, name='lam_cost') # Weight on the Nonlinear Cost\n\nx = cp.Variable((params.scp.n, params.sim.n_states), name='x')   # State\ndx = cp.Variable((params.scp.n, params.sim.n_states), name='dx') # State Trust Region\nx_bar = cp.Parameter((params.scp.n, params.sim.n_states), name='x_bar') # Previous SCP State\n\n\nu = cp.Variable((params.scp.n, params.sim.n_controls), name='u')   # Control\ndu = cp.Variable((params.scp.n, params.sim.n_controls), name='du') # Control Trust Region\nu_bar = cp.Parameter((params.scp.n, params.sim.n_controls), name='u_bar') # Previous SCP Control\n</code></pre>"},{"location":"Overview/ocp/#scaling-definitions","title":"Scaling Definitions","text":"<p>The state and control are scaled using the following affine transformations:</p> \\[ \\begin{align*} \\tilde{x} &amp;= S_x x + c_x, \\\\ \\tilde{u} &amp;= S_u u + c_u, \\end{align*} \\] <p>where \\(\\tilde{x}\\) and \\(\\tilde{u}\\) are the unscaled state and control. The diagonal scalaing matrices, \\(S_x\\) and \\(S_u\\), are given by:</p> \\[ \\begin{align*} S_\\Box &amp;= \\mathrm{diag}\\left(\\mathrm{max}\\left(1, \\frac{\\mathrm{abs}(\\Box_\\min - \\Box_\\max)}{2}\\right)\\right) \\\\ c_\\Box &amp;= \\frac{\\Box_\\max + \\Box_\\min}{2} \\end{align*} \\] <p>These are instantiated in the optimal control problem as follows:</p> <pre><code># Affine Scaling for State\nS_x = params.sim.S_x\ninv_S_x = params.sim.inv_S_x\nc_x = params.sim.c_x\n</code></pre>"},{"location":"Overview/ocp/#discretized-dynamic-parameters","title":"Discretized Dynamic Parameters","text":"<p>The discretized dynamics matrices are defined as follows:</p> <pre><code># Discretized Augmented Dynamics Constraints\nA_d = cp.Parameter((params.scp.n - 1, params.sim.n_states, params.sim.n_states)), name='A_d')\nB_d = cp.Parameter((params.scp.n - 1, params.sim.n_states, params.sim.n_controls), name='B_d')\nC_d = cp.Parameter((params.scp.n - 1, params.sim.n_states, params.sim.n_controls), name='C_d')\nz_d = cp.Parameter((params.scp.n - 1, params.sim.n_states), name='z_d') # Nonlinear Propagation Defect\nnu  = cp.Variable((params.scp.n - 1, params.sim.n_states), name='nu')  # Virtual Control Slack Variable\n</code></pre>"},{"location":"Overview/ocp/#nodal-constraints","title":"Nodal Constraints","text":"<p>The nonconvex nodal parameters and variables are instantiated using the following code:</p> <pre><code># Linearized Nonconvex Nodal Constraints\n    if params.sim.constraints_nodal:\n        g = []\n        grad_g_x = []\n        grad_g_u = []\n        nu_vb = []\n        for idx_ncvx, constraint in enumerate(params.sim.constraints_nodal):\n            if not constraint.convex:\n                g.append(cp.Parameter(params.scp.n, name = 'g_' + str(idx_ncvx)))\n                grad_g_x.append(cp.Parameter((params.scp.n, params.sim.n_states), name='grad_g_x_' + str(idx_ncvx)))\n                grad_g_u.append(cp.Parameter((params.scp.n, params.sim.n_controls), name='grad_g_u_' + str(idx_ncvx)))\n                nu_vb.append(cp.Variable(params.scp.n, name='nu_vb_' + str(idx_ncvx))) # Virtual Control for VB\n</code></pre> <pre><code>def OptimalControlProblem(params: Config):\n    ########################\n    # VARIABLES &amp; PARAMETERS\n    ########################\n\n    # Parameters\n    w_tr = cp.Parameter(nonneg = True, name='w_tr')\n    lam_cost = cp.Parameter(nonneg=True, name='lam_cost')\n\n    # State\n    x = cp.Variable((params.scp.n, params.sim.n_states), name='x') \n    dx = cp.Variable((params.scp.n, params.sim.n_states), name='dx') # State Trust Region\n    x_bar = cp.Parameter((params.scp.n, params.sim.n_states), name='x_bar') # Previous SCP State\n\n    # Affine Scaling for State\n    S_x = params.sim.S_x\n    inv_S_x = params.sim.inv_S_x\n    c_x = params.sim.c_x\n\n    # Control\n    u = cp.Variable((params.scp.n, params.sim.n_controls), name='u') \n    du = cp.Variable((params.scp.n, params.sim.n_controls), name='du') # Control Trust Region\n    u_bar = cp.Parameter((params.scp.n, params.sim.n_controls), name='u_bar') # Previous SCP Control\n\n    # Affine Scaling for Control\n    S_u = params.sim.S_u\n    inv_S_u = params.sim.inv_S_u\n    c_u = params.sim.c_u\n\n    # Discretized Augmented Dynamics Constraints\n    A_d = cp.Parameter((params.scp.n - 1, params.sim.n_states, params.sim.n_states), name='A_d')\n    B_d = cp.Parameter((params.scp.n - 1, params.sim.n_states, params.sim.n_controls), name='B_d')\n    C_d = cp.Parameter((params.scp.n - 1, params.sim.n_states, params.sim.n_controls), name='C_d')\n    z_d = cp.Parameter((params.scp.n - 1, params.sim.n_states), name='z_d')\n    nu  = cp.Variable((params.scp.n - 1, params.sim.n_states), name='nu') # Virtual Control\n\n    # Linearized Nonconvex Nodal Constraints\n    if params.sim.constraints_nodal:\n        g = []\n        grad_g_x = []\n        grad_g_u = []\n        nu_vb = []\n        for idx_ncvx, constraint in enumerate(params.sim.constraints_nodal):\n            if not constraint.convex:\n                g.append(cp.Parameter(params.scp.n, name = 'g_' + str(idx_ncvx)))\n                grad_g_x.append(cp.Parameter((params.scp.n, params.sim.n_states), name='grad_g_x_' + str(idx_ncvx)))\n                grad_g_u.append(cp.Parameter((params.scp.n, params.sim.n_controls), name='grad_g_u_' + str(idx_ncvx)))\n                nu_vb.append(cp.Variable(params.scp.n, name='nu_vb_' + str(idx_ncvx))) # Virtual Control for VB\n\n    # Applying the affine scaling to state and control\n    x_nonscaled = []\n    u_nonscaled = []\n    for k in range(params.scp.n):\n        x_nonscaled.append(S_x @ x[k] + c_x)\n        u_nonscaled.append(S_u @ u[k] + c_u)\n\n    constr = []\n    cost = lam_cost * 0\n\n    #############\n    # CONSTRAINTS\n    #############\n    idx_ncvx = 0\n    if params.sim.constraints_nodal:\n        for constraint in params.sim.constraints_nodal:\n            if constraint.nodes is None:\n                nodes = range(params.scp.n)\n            else:\n                nodes = constraint.nodes\n\n            if constraint.convex:\n                constr += [constraint(x_nonscaled[node], u_nonscaled[node]) for node in nodes]\n\n            elif not constraint.convex:\n                constr += [((g[idx_ncvx][node] + grad_g_x[idx_ncvx][node] @ dx[node] + grad_g_u[idx_ncvx][node] @ du[node])) == nu_vb[idx_ncvx][node] for node in nodes]\n                idx_ncvx += 1\n\n    for i in range(params.sim.idx_x_true.start, params.sim.idx_x_true.stop):\n        if params.sim.initial_state.type[i] == 'Fix':\n            constr += [x_nonscaled[0][i] == params.sim.initial_state.value[i]]  # Initial Boundary Conditions\n        if params.sim.final_state.type[i] == 'Fix':\n            constr += [x_nonscaled[-1][i] == params.sim.final_state.value[i]]   # Final Boundary Conditions\n        if params.sim.initial_state.type[i] == 'Minimize':\n            cost += lam_cost * x_nonscaled[0][i]\n        if params.sim.final_state.type[i] == 'Minimize':\n            cost += lam_cost * x_nonscaled[-1][i]\n        if params.sim.initial_state.type[i] == 'Maximize':\n            cost += lam_cost * x_nonscaled[0][i]\n        if params.sim.final_state.type[i] == 'Maximize':\n            cost += lam_cost * x_nonscaled[-1][i]\n\n    if params.scp.uniform_time_grid:\n        constr += [x_nonscaled[i][params.sim.idx_t] - x_nonscaled[i-1][params.sim.idx_t] == x_nonscaled[i-1][params.sim.idx_t] - x_nonscaled[i-2][params.sim.idx_t] for i in range(2, params.scp.n)] # Uniform Time Step\n\n    constr += [0 == la.inv(S_x) @ (x_nonscaled[i] - x_bar[i] - dx[i]) for i in range(params.scp.n)] # State Error\n    constr += [0 == la.inv(S_u) @ (u_nonscaled[i] - u_bar[i] - du[i]) for i in range(params.scp.n)] # Control Error\n\n    constr += [x_nonscaled[i] == \\\n                      A_d[i-1] @ x_nonscaled[i-1] \\\n                    + B_d[i-1] @ u_nonscaled[i-1] \\\n                    + C_d[i-1] @ u_nonscaled[i] \\\n                    + z_d[i-1] \\\n                    + nu[i-1] for i in range(1, params.scp.n)] # Dynamics Constraint\n\n    constr += [u_nonscaled[i] &lt;= params.sim.max_control for i in range(params.scp.n)]\n    constr += [u_nonscaled[i] &gt;= params.sim.min_control for i in range(params.scp.n)] # Control Constraints\n\n    constr += [x_nonscaled[i][params.sim.idx_x_true] &lt;= params.sim.max_state[params.sim.idx_x_true] for i in range(params.scp.n)]\n    constr += [x_nonscaled[i][params.sim.idx_x_true] &gt;= params.sim.min_state[params.sim.idx_x_true] for i in range(params.scp.n)] # State Constraints (Also implemented in CTCS but included for numerical stability)\n\n    ########\n    # COSTS\n    ########\n\n    inv = block([[inv_S_x, np.zeros((S_x.shape[0], S_u.shape[1]))], [np.zeros((S_u.shape[0], S_x.shape[1])), inv_S_u]])\n    cost += sum(w_tr * cp.sum_squares(inv @ cp.hstack((dx[i], du[i]))) for i in range(params.scp.n))  # Trust Region Cost\n    cost += sum(params.scp.lam_vc * cp.sum(cp.abs(nu[i-1])) for i in range(1, params.scp.n)) # Virtual Control Slack\n\n    idx_ncvx = 0\n    if params.sim.constraints_nodal:\n        for constraint in params.sim.constraints_nodal:\n            if not constraint.convex:\n                cost += params.scp.lam_vb * cp.sum(cp.pos(nu_vb[idx_ncvx]))\n                idx_ncvx += 1\n\n    for idx, nodes in zip(np.arange(params.sim.idx_y.start, params.sim.idx_y.stop), params.sim.ctcs_node_intervals):  \n        if nodes[0] == 0:\n            start_idx = 1\n        else:\n            start_idx = nodes[0]\n        constr += [cp.abs(x_nonscaled[i][idx] - x_nonscaled[i-1][idx]) &lt;= params.sim.max_state[idx] for i in range(start_idx, nodes[1])]\n        constr += [x_nonscaled[0][idx] == 0]\n\n\n    #########\n    # PROBLEM\n    #########\n    prob = cp.Problem(cp.Minimize(cost), constr)\n    if params.cvx.cvxpygen:\n        # Check to see if solver directory exists\n        if not os.path.exists('solver'):\n            cpg.generate_code(prob, solver = params.cvx.solver, code_dir='solver', wrapper = True)\n        else:\n            # Prompt the use to indicate if they wish to overwrite the solver directory or use the existing compiled solver\n            overwrite = input(\"Solver directory already exists. Overwrite? (y/n): \")\n            if overwrite.lower() == 'y':\n                cpg.generate_code(prob, solver = params.cvx.solver, code_dir='solver', wrapper = True)\n            else:\n                pass\n    return prob\n</code></pre>"},{"location":"Overview/scvx/","title":"What is Succesive Convexification?","text":"<p>Warning</p> <p>This page is still under development .</p> <p>Successive Convexification is an approach to solve infinite dimensional nonconvex trajectory optimization problems. It works by successively convexifying or linearizing a problem and solving the convex subproblem. The solution to the convex subproblem is then used to update the original problem, and the process is repeated until convergence.</p> <p> </p>"},{"location":"Overview/scvx/#problem-formulation","title":"Problem Formulation","text":"<p>In this repository, the user will likely find it most useful specify there problem in the Mayer Form order to take full advantage of the features of this repo, but not worry this is quite easy.</p> \\[ \\begin{align} \\min_{x,u}\\ &amp;L_{f}(x(t_f)), \\\\ \\mathrm{s.t.}\\ &amp;\\dot{x}(t) = f(t, x(t),u(t)) &amp; \\forall t\\in[t_i, t_f], \\\\ &amp; g(t,x(t),u(t)) \\leq 0_{n_g} &amp; \\forall t\\in[t_i, t_f],\\\\ &amp; h(t,x(t),u(t)) = 0_{n_h} &amp; \\forall t\\in[t_i, t_f],\\\\ &amp; P(t_i, x(t_i), t_f, x(t_f)) = 0_{n_P} , \\\\ &amp; Q(t_i, x(t_i), t_f, x(t_f)) = 0_{n_Q} , \\\\ \\end{align} \\] <p>Lets break down whats happening here. The first line, \\(L_{f}(x(t_f))\\), is specifying a terminal cost as a function of state. The second is describing the nonlinear dynamics of the system, \\(\\dot{x}(t) = f(t, x(t),u(t))\\) where \\(x\\) and \\(u\\) are the system state and control respectively. The third and fourth lines are describing the inequality, \\(g(t,x(t),u(t)) \\leq 0_{n_g}\\),  and equality, \\(h(t,x(t),u(t)) = 0_{n_h}\\), constraints on the system respectively. Finally, the initial and terminal inequality and equality constraints are specified by \\(P(t_i, x(t_i), t_f, x(t_f)) = 0_{n_P}\\) and \\(Q(t_i, x(t_i), t_f, x(t_f)) = 0_{n_Q}\\) respectively.</p>"},{"location":"Overview/time_dilation/","title":"Time Dilation","text":"<p>Warning</p> <p>This page is still under development .</p>"},{"location":"UnderTheHood/lowering_architecture/","title":"Lowering Architecture","text":"<p>This document explains how OpenSCvx converts symbolic problem definitions into executable code for optimization.</p>"},{"location":"UnderTheHood/lowering_architecture/#the-big-picture","title":"The Big Picture","text":"<p>OpenSCvx separates trajectory optimization into four phases:</p> <ol> <li>Preprocessing \u2014 Validate inputs, augment dynamics, categorize constraints</li> <li>Lowering \u2014 Convert symbolic expressions to JAX/CVXPy code</li> <li>Solving \u2014 Run the SCP (Sequential Convex Programming) loop</li> <li>Post-processing \u2014 Propagate results, compute metrics</li> </ol> <p>This document focuses on Phase 2: Lowering.</p>"},{"location":"UnderTheHood/lowering_architecture/#why-lowering","title":"Why Lowering?","text":"<p>When you define a problem in OpenSCvx, you write symbolic expressions:</p> <pre><code>position = ox.State(\"pos\", shape=(3,))\nvelocity = ox.State(\"vel\", shape=(3,))\nthrust = ox.Control(\"thrust\", shape=(3,))\n\ndynamics = {\"pos\": velocity, \"vel\": thrust / mass - gravity}\nconstraints = [ox.Norm(thrust) &lt;= max_thrust]\n</code></pre> <p>These symbolic expressions form an AST (Abstract Syntax Tree). The lowering phase walks this AST and generates:</p> <ul> <li>JAX functions for dynamics and non-convex constraints (with automatic differentiation for Jacobians)</li> <li>CVXPy expressions for convex constraints (used directly in the convex subproblem)</li> </ul>"},{"location":"UnderTheHood/lowering_architecture/#pipeline-overview","title":"Pipeline Overview","text":"<pre><code>SymbolicProblem                         LoweredProblem\n(AST representation)                    (executable code)\n        \u2502                                      \u2502\n        \u2502     lower_symbolic_problem()         \u2502\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2502                                      \u2502\n   dynamics  \u2500\u2500\u2500\u2500\u2500\u2500\u25ba  JAX: f(x,u) \u2192 dx/dt      \u2502\n   (symbolic)         JAX: A = df/dx           \u2502\n                      JAX: B = df/du           \u2502\n        \u2502                                      \u2502\n   non-convex  \u2500\u2500\u2500\u2500\u25ba  JAX: g(x,u) \u2192 residual   \u2502\n   constraints        JAX: \u2207g_x, \u2207g_u          \u2502\n        \u2502                                      \u2502\n   convex      \u2500\u2500\u2500\u2500\u25ba  CVXPy constraint objects \u2502\n   constraints        (added directly to OCP)  \u2502\n        \u2502                                      \u2502\n   states,     \u2500\u2500\u2500\u2500\u25ba  UnifiedState/Control     \u2502\n   controls           (aggregated vectors)     \u2502\n        \u2502                                      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"UnderTheHood/lowering_architecture/#key-data-structures","title":"Key Data Structures","text":""},{"location":"UnderTheHood/lowering_architecture/#input-symbolicproblem","title":"Input: <code>SymbolicProblem</code>","text":"<p>After preprocessing, all symbolic definitions are collected into a <code>SymbolicProblem</code>:</p> <pre><code>@dataclass\nclass SymbolicProblem:\n    dynamics: Expr              # Symbolic dx/dt = f(x, u)\n    states: List[State]         # All state variables (including augmented)\n    controls: List[Control]     # All control variables (including virtual)\n    constraints: ConstraintSet  # Categorized constraints\n    parameters: dict            # User-defined parameters\n    N: int                      # Discretization nodes\n    # ... plus propagation variants\n</code></pre>"},{"location":"UnderTheHood/lowering_architecture/#output-loweredproblem","title":"Output: <code>LoweredProblem</code>","text":"<p>Lowering produces a <code>LoweredProblem</code> containing everything needed for optimization:</p> <pre><code>@dataclass\nclass LoweredProblem:\n    # JAX dynamics (callable functions with Jacobians)\n    dynamics: Dynamics           # f, A=df/dx, B=df/du\n    dynamics_prop: Dynamics      # For forward propagation\n\n    # Lowered constraints (by backend)\n    jax_constraints: LoweredJaxConstraints\n    cvxpy_constraints: LoweredCvxpyConstraints\n\n    # Unified state/control interfaces\n    x_unified: UnifiedState      # Aggregates all states into one vector\n    u_unified: UnifiedControl    # Aggregates all controls into one vector\n\n    # CVXPy optimization variables\n    ocp_vars: OCPVariables       # x, u, dx, du, nu, etc.\n    cvxpy_params: dict           # User parameters as cp.Parameter\n</code></pre>"},{"location":"UnderTheHood/lowering_architecture/#constraint-routing","title":"Constraint Routing","text":"<p>Constraints take different paths based on convexity:</p> Constraint Type Backend How It's Used in SCP Non-convex nodal JAX Linearized at each iteration: <code>g(x\u0304) + \u2207g\u00b7\u03b4x \u2264 0</code> Non-convex cross-node JAX Same, but references multiple trajectory nodes Convex nodal CVXPy Added directly to QP subproblem Convex cross-node CVXPy Same, with <code>NodeReference</code> indexing CTCS JAX Continuous-time via augmented dynamics"},{"location":"UnderTheHood/lowering_architecture/#jax-lowered-constraints","title":"JAX-Lowered Constraints","text":"<p>Non-convex constraints become JAX functions with gradients:</p> <pre><code>@dataclass\nclass LoweredJaxConstraints:\n    nodal: List[LoweredNodalConstraint]      # func, grad_g_x, grad_g_u\n    cross_node: List[LoweredCrossNodeConstraint]  # func, grad_g_X, grad_g_U\n    ctcs: List[CTCS]                         # Handled via dynamics augmentation\n</code></pre>"},{"location":"UnderTheHood/lowering_architecture/#cvxpy-lowered-constraints","title":"CVXPy-Lowered Constraints","text":"<p>Convex constraints become CVXPy constraint objects:</p> <pre><code>@dataclass\nclass LoweredCvxpyConstraints:\n    constraints: List[cp.Constraint]  # Added directly to OCP\n</code></pre>"},{"location":"UnderTheHood/lowering_architecture/#design-principles","title":"Design Principles","text":""},{"location":"UnderTheHood/lowering_architecture/#immutability","title":"Immutability","text":"<p>Lowering never mutates inputs. The original <code>SymbolicProblem</code> remains unchanged; a new <code>LoweredProblem</code> is returned. This enables:</p> <ul> <li>Inspecting symbolic expressions after lowering</li> <li>Reusing the same symbolic problem for multiple configurations</li> <li>Easier debugging and testing</li> </ul>"},{"location":"UnderTheHood/lowering_architecture/#type-separation","title":"Type Separation","text":"<p>Symbolic and lowered representations use distinct types:</p> <ul> <li><code>NodalConstraint</code> (symbolic) vs <code>LoweredNodalConstraint</code> (JAX functions)</li> <li><code>ConstraintSet</code> (symbolic) vs <code>LoweredJaxConstraints</code> / <code>LoweredCvxpyConstraints</code></li> </ul> <p>This prevents accidentally mixing AST nodes with executable code.</p>"},{"location":"UnderTheHood/lowering_architecture/#backend-independence","title":"Backend Independence","text":"<p>JAX lowering has no dependency on: - <code>N</code> (number of nodes) - Scaling matrices - CVXPy</p> <p>This means JAX-lowered dynamics and constraints could be used with alternative solvers.</p>"},{"location":"UnderTheHood/lowering_architecture/#further-reading","title":"Further Reading","text":"<ul> <li><code>openscvx/symbolic/lower.py</code> \u2014 Main lowering implementation</li> <li><code>openscvx/lowered/</code> \u2014 Dataclass definitions</li> <li><code>openscvx/symbolic/lowerers/jax.py</code> \u2014 JAX visitor implementation</li> <li><code>openscvx/symbolic/lowerers/cvxpy.py</code> \u2014 CVXPy visitor implementation</li> </ul>"},{"location":"UnderTheHood/vectorization_and_vmapping/","title":"Vectorization and Vmapping Across Decision Nodes","text":"<p>This page explains how OpenSCvx internally processes symbolic problem definitions into vectorized JAX computations. After symbolic preprocessing and augmentation (which you've likely seen in basic usage), the library creates unified state/control vectors and applies JAX's <code>vmap</code> to evaluate dynamics and non-convex constraints across decision nodes in parallel.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#processing-pipeline","title":"Processing Pipeline","text":"<p>The transformation from symbolic expressions to vectorized execution happens in several stages:</p> <ol> <li>Symbolic Preprocessing: Augmentation with time state, CTCS states, and time dilation (covered in basic usage)</li> <li>Unification: Individual State/Control objects combined into monolithic vectors</li> <li>JAX Lowering: Symbolic expressions compiled to executable JAX functions (dynamics and non-convex constraints)</li> <li>Vectorization: <code>vmap</code> applied to batch dynamics and constraint computations across decision nodes</li> </ol> <p>Understanding this pipeline is useful for performance optimization, debugging shape mismatches, and extending the library.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#stage-1-symbolic-problem-definition","title":"Stage 1: Symbolic Problem Definition","text":"<p>Starting from a typical problem definition with individual states and controls:</p> <pre><code>import openscvx as ox\nimport numpy as np\n\n# Individual state components\nposition = ox.State(\"position\", shape=(2,))\nvelocity = ox.State(\"velocity\", shape=(1,))\n\n# Control\ntheta = ox.Control(\"theta\", shape=(1,))\n\n# Dynamics per state\ndynamics = {\n    \"position\": ox.Concat(velocity[0] * ox.Sin(theta[0]), -velocity[0] * ox.Cos(theta[0])),\n    \"velocity\": 9.81 * ox.Cos(theta[0]),\n}\n</code></pre> <p>At this stage, each state/control is independent with its own shape, and dynamics are symbolic expressions without any notion of batching or decision nodes.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#stage-2-symbolic-preprocessing-and-augmentation","title":"Stage 2: Symbolic Preprocessing and Augmentation","text":"<p>During <code>Problem</code> construction (in <code>preprocess_symbolic_problem</code>), the symbolic problem is augmented:</p> <pre><code>problem = Problem(\n    dynamics=dynamics,\n    states=[position, velocity],\n    controls=[theta],\n    N=10,\n    time=ox.Time(initial=0.0, final=2.0),\n)\n</code></pre> <p>Internally, additional states and controls are added: - Time state (if not user-provided) - CTCS augmented states for path constraints - Time dilation control for time-optimal problems</p> <p>After augmentation: <code>states_aug = [position, velocity, time, ...]</code> and <code>controls_aug = [theta, _time_dilation]</code>, with corresponding dynamics for all augmented states.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#stage-3-unification","title":"Stage 3: Unification","text":"<p>The augmented states and controls are combined into unified vectors (in <code>lower_symbolic_expressions</code>):</p> <pre><code>x_unified: UnifiedState = unify_states(states_aug)\nu_unified: UnifiedControl = unify_controls(controls_aug)\n</code></pre> <p>The unification process (in <code>openscvx/symbolic/unified.py</code>) sorts variables (user-defined first, then augmented), concatenates properties (bounds, guesses, etc.), and assigns each State/Control a slice for indexing into the unified vector.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#unified-vector-shapes","title":"Unified Vector Shapes","text":"<p>For a problem with <code>N</code> decision nodes:</p> <pre><code>x_unified.shape = (n_x,)          # Sum of all state dimensions\nu_unified.shape = (n_u,)          # Sum of all control dimensions\nx_unified.guess.shape = (N, n_x)  # State trajectory\nu_unified.guess.shape = (N, n_u)  # Control trajectory\n</code></pre> <p>Concrete example (brachistochrone with N=10, no CTCS constraints): <pre><code>x_unified.shape = (4,)        # position(2) + velocity(1) + time(1)\nu_unified.shape = (2,)        # theta(1) + _time_dilation(1)\nx_unified.guess.shape = (10, 4)\nu_unified.guess.shape = (10, 2)\n</code></pre></p> <p>Each original State/Control retains a slice for extraction: <pre><code>position._slice = slice(0, 2)\nvelocity._slice = slice(2, 3)\ntime._slice = slice(3, 4)\n\n# Extract during evaluation:\nposition_value = x_unified[position._slice]  # (2,)\n</code></pre></p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#stage-4-jax-lowering","title":"Stage 4: JAX Lowering","text":"<p>Symbolic expressions for dynamics and non-convex constraints are converted to executable JAX functions (in <code>openscvx/symbolic/lower.py</code>). Convex constraints are lowered to CVXPy separately.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#dynamics-lowering","title":"Dynamics Lowering","text":"<pre><code># Convert symbolic dynamics to JAX function\ndyn_fn = lower_to_jax(dynamics_aug)\n\n# Create Dynamics object with Jacobians\ndynamics_augmented = Dynamics(\n    f=dyn_fn,                      # State derivative function\n    A=jacfwd(dyn_fn, argnums=0),   # Jacobian df/dx\n    B=jacfwd(dyn_fn, argnums=1),   # Jacobian df/du\n)\n</code></pre> <p>Dynamics Function Signature (Before Vmap):</p> <pre><code>def f(x: Array, u: Array, node: int, params: dict) -&gt; Array:\n    \"\"\"Compute state derivative at a single decision node.\n\n    Args:\n        x: State vector at this node, shape (n_x,)\n        u: Control vector at this node, shape (n_u,)\n        node: Node index (0 to N-1), used for time-varying behavior\n        params: Dictionary of problem parameters\n\n    Returns:\n        State derivative dx/dt, shape (n_x,)\n    \"\"\"\n    ...\n</code></pre> <p>Jacobians have similar signatures:</p> <pre><code>A(x, u, node, params) -&gt; Array[n_x, n_x]  # df/dx\nB(x, u, node, params) -&gt; Array[n_x, n_u]  # df/du\n</code></pre>"},{"location":"UnderTheHood/vectorization_and_vmapping/#non-convex-constraint-lowering","title":"Non-Convex Constraint Lowering","text":"<p>Non-convex nodal constraints that are to be lowered to JAX follow the same pattern:</p> <pre><code># Convert symbolic constraint expressions to JAX functions\nconstraints_nodal_fns = lower_to_jax(constraints_nodal)\n\n# Create LoweredNodalConstraint objects with Jacobians\nfor i, fn in enumerate(constraints_nodal_fns):\n    constraint = LoweredNodalConstraint(\n        func=fn,                          # Constraint function\n        grad_g_x=jacfwd(fn, argnums=0),  # Jacobian dg/dx\n        grad_g_u=jacfwd(fn, argnums=1),  # Jacobian dg/du\n        nodes=constraints_nodal[i].nodes, # Node indices where constraint applies\n    )\n</code></pre> <p>Constraint Function Signature (Before Vmap):</p> <pre><code>def g(x: Array, u: Array, node: int, params: dict) -&gt; float:\n    \"\"\"Evaluate constraint at a single decision node.\n\n    Args:\n        x: State vector at this node, shape (n_x,)\n        u: Control vector at this node, shape (n_u,)\n        node: Node index, used for time-varying constraints\n        params: Dictionary of problem parameters\n\n    Returns:\n        Constraint value (scalar)\n    \"\"\"\n    ...\n</code></pre> <p>Constraint Jacobians:</p> <pre><code>grad_g_x(x, u, node, params) -&gt; Array[n_x]  # dg/dx\ngrad_g_u(x, u, node, params) -&gt; Array[n_u]  # dg/du\n</code></pre>"},{"location":"UnderTheHood/vectorization_and_vmapping/#cross-node-constraint-lowering","title":"Cross-Node Constraint Lowering","text":"<p>Cross-node constraints couple variables across multiple trajectory nodes. Unlike regular nodal constraints that evaluate at single nodes, cross-node constraints require access to the full trajectory.</p> <p>Key Signature Difference:</p> Constraint Type Signature Vectorization Regular Nodal <code>(x, u, node, params) \u2192 scalar</code> vmapped across nodes Cross-Node <code>(X, U, params) \u2192 scalar</code> operates on full trajectory <p>Cross-node constraints are represented by the <code>CrossNodeConstraint</code> expression type and lowered via a dedicated visitor (<code>JaxLowerer._visit_cross_node_constraint</code> in <code>openscvx/symbolic/lowerers/jax.py</code>). The visitor wraps the inner constraint to provide the trajectory-level signature.</p> <p>Cross-Node Constraint Function Signature:</p> <pre><code>def g_cross(X: Array, U: Array, params: dict) -&gt; scalar:\n    \"\"\"Evaluate single cross-node constraint.\n\n    Args:\n        X: Full state trajectory, shape (N, n_x)\n        U: Full control trajectory, shape (N, n_u)\n        params: Dictionary of problem parameters\n\n    Returns:\n        Scalar constraint residual\n    \"\"\"\n    ...\n</code></pre> <p>Cross-Node Constraint Jacobians:</p> <pre><code>grad_g_X(X, U, params) -&gt; Array[N, n_x]  # dg/dX - Jacobian wrt all states\ngrad_g_U(X, U, params) -&gt; Array[N, n_u]  # dg/dU - Jacobian wrt all controls\n</code></pre> <p>Jacobian Sparsity: These Jacobians are stored as dense <code>(N, n_x)</code> and <code>(N, n_u)</code> arrays but are typically very sparse. A constraint coupling nodes <code>k</code> and <code>k-1</code> only has non-zero derivatives at rows <code>k</code> and <code>k-1</code>; all other rows are zero.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#stage-5-vectorization-with-vmap","title":"Stage 5: Vectorization with Vmap","text":"<p>Finally, both dynamics and constraints are vectorized to operate on decision nodes simultaneously. This enables efficient parallel evaluation on GPU/TPU hardware.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#dynamics-vectorization","title":"Dynamics Vectorization","text":"<p>Dynamics functions are vmapped to process all intervals in parallel (in <code>Problem.initialize</code>):</p> <pre><code># Vectorize dynamics functions across decision nodes\nself.dynamics_augmented.f = jax.vmap(\n    self.dynamics_augmented.f,\n    in_axes=(0, 0, 0, None)\n)\nself.dynamics_augmented.A = jax.vmap(\n    self.dynamics_augmented.A,\n    in_axes=(0, 0, 0, None)\n)\nself.dynamics_augmented.B = jax.vmap(\n    self.dynamics_augmented.B,\n    in_axes=(0, 0, 0, None)\n)\n</code></pre> <p>Dynamics Vmap Configuration: <code>in_axes=(0, 0, 0, None)</code></p> <p>This means: - Axis 0 of x: Batch over states at different intervals - Axis 0 of u: Batch over controls at different intervals - Axis 0 of node: Batch over node indices - None for params: Shared parameters (not batched)</p> <p>Dynamics Signature (After Vmap):</p> <pre><code>def f_vmapped(x_batch: Array, u_batch: Array, nodes: Array, params: dict) -&gt; Array:\n    \"\"\"Compute state derivatives at all intervals simultaneously.\n\n    Args:\n        x_batch: States at interval starts, shape (N-1, n_x)\n        u_batch: Controls at interval starts, shape (N-1, n_u)\n        nodes: Node indices, shape (N-1,) - typically jnp.arange(0, N-1)\n        params: Dictionary of problem parameters (shared across all nodes)\n\n    Returns:\n        State derivatives at all intervals, shape (N-1, n_x)\n    \"\"\"\n    ...\n</code></pre> <p>Jacobians after vmap:</p> <pre><code>A_vmapped(x_batch, u_batch, nodes, params) -&gt; Array[N-1, n_x, n_x]\nB_vmapped(x_batch, u_batch, nodes, params) -&gt; Array[N-1, n_x, n_u]\n</code></pre> <p>Why N-1 instead of N?</p> <p>Trajectory discretization operates on intervals between consecutive decision nodes: - N decision nodes: Including initial and final states (e.g., nodes 0, 1, 2, ..., 9 for N=10) - N-1 intervals: Between consecutive nodes (e.g., intervals [0\u21921], [1\u21922], ..., [8\u21929] for N=10) - Dynamics evaluation: At the start of each interval, giving N-1 evaluations</p> <p>This is why vmapped dynamics process batches of size <code>(N-1, ...)</code> rather than <code>(N, ...)</code>.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#constraint-vectorization","title":"Constraint Vectorization","text":"<p>Non-convex nodal constraints are also vectorized, but with a key difference (in <code>lower_symbolic_expressions</code>):</p> <pre><code># Vectorize constraint functions (during JAX lowering)\nconstraint = LoweredNodalConstraint(\n    func=jax.vmap(fn, in_axes=(0, 0, None, None)),\n    grad_g_x=jax.vmap(jacfwd(fn, argnums=0), in_axes=(0, 0, None, None)),\n    grad_g_u=jax.vmap(jacfwd(fn, argnums=1), in_axes=(0, 0, None, None)),\n    nodes=constraint.nodes,  # List of specific node indices where constraint applies\n)\n</code></pre> <p>Constraint Vmap Configuration: <code>in_axes=(0, 0, None, None)</code></p> <p>Note the key difference from dynamics: - Axis 0 of x: Batch over states - Axis 0 of u: Batch over controls - None for node: Node index is not batched (same value for all evaluations in a batch) - None for params: Shared parameters (not batched)</p> <p>Why the difference? Constraints are only evaluated at specific nodes (e.g., a collision avoidance constraint might only apply at nodes [2, 5, 7]). The constraint is vmapped to handle multiple constraint evaluations in parallel, but each evaluation receives the same <code>node</code> value since it's evaluating the same logical constraint at potentially different states/controls.</p> <p>Constraint Signature (After Vmap):</p> <pre><code>def g_vmapped(x_batch: Array, u_batch: Array, node: int, params: dict) -&gt; Array:\n    \"\"\"Evaluate constraint at multiple state/control pairs simultaneously.\n\n    Args:\n        x_batch: State vectors, shape (batch_size, n_x)\n        u_batch: Control vectors, shape (batch_size, n_u)\n        node: Single node index (broadcast to all evaluations)\n        params: Dictionary of problem parameters (shared across all evaluations)\n\n    Returns:\n        Constraint values, shape (batch_size,)\n    \"\"\"\n    ...\n</code></pre> <p>Constraint Jacobians after vmap:</p> <pre><code>grad_g_x_vmapped(x_batch, u_batch, node, params) -&gt; Array[batch_size, n_x]\ngrad_g_u_vmapped(x_batch, u_batch, node, params) -&gt; Array[batch_size, n_u]\n</code></pre> <p>When constraints are evaluated in practice:</p> <pre><code># Extract states/controls at nodes where constraint applies\nx_batch = x[constraint.nodes]  # Shape: (len(nodes), n_x)\nu_batch = u[constraint.nodes]  # Shape: (len(nodes), n_u)\n\n# Evaluate constraint at all specified nodes\ng_values = constraint.func(x_batch, u_batch, node_idx, params)  # Shape: (len(nodes),)\n</code></pre>"},{"location":"UnderTheHood/vectorization_and_vmapping/#cross-node-constraint-vectorization","title":"Cross-Node Constraint Vectorization","text":"<p>Cross-node constraints are not vmapped because they already operate on full trajectory arrays. Each <code>CrossNodeConstraint</code> is a single constraint with fixed node indices baked into the expression via <code>NodeReference</code> nodes.</p> <p>Key Difference from Regular Constraints:</p> Aspect Regular Nodal Constraints Cross-Node Constraints Input Shape Single-node vectors <code>(n_x,)</code>, <code>(n_u,)</code> Full trajectories <code>(N, n_x)</code>, <code>(N, n_u)</code> Vectorization <code>jax.vmap</code> with <code>in_axes=(0, 0, None, None)</code> No vmap (already trajectory-level) Output Scalar per evaluation Scalar per constraint Jacobian Shape <code>(n_x,)</code>, <code>(n_u,)</code> per node <code>(N, n_x)</code>, <code>(N, n_u)</code> per constraint <p>Evaluation: During SCP iterations, each cross-node constraint receives the full trajectory arrays and returns a scalar residual:</p> <pre><code># Each LoweredCrossNodeConstraint operates on full trajectories\nresidual = constraint.func(X, U, params)      # scalar\ngrad_X = constraint.grad_g_X(X, U, params)    # (N, n_x) - sparse, mostly zeros\ngrad_U = constraint.grad_g_U(X, U, params)    # (N, n_u) - sparse, mostly zeros\n</code></pre> <p>The Jacobians are dense arrays but exhibit sparsity patterns determined by which nodes the constraint couples.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#usage-in-discretization","title":"Usage in Discretization","text":"<p>The vmapped dynamics functions are called during discretization (in <code>calculate_discretization</code>):</p> <pre><code># Setup batch inputs\nx = V[:, :n_x]                          # Shape: (N-1, n_x) - States at interval starts\nu = u[: x.shape[0]]                     # Shape: (N-1, n_u) - Controls (includes time dilation)\nnodes = jnp.arange(0, N-1)              # Shape: (N-1,) - Node indices\n\n# Extract time dilation (last control dimension)\ns = u[:, -1]                            # Shape: (N-1,) - Time dilation values\n\n# Call vmapped dynamics - evaluates all intervals in parallel\n# Note: dynamics receive u[:, :-1] (vehicle controls only, excluding time dilation)\nf = state_dot(x, u[:, :-1], nodes, params)  # Shape: (N-1, n_x)\ndfdx = A(x, u[:, :-1], nodes, params)       # Shape: (N-1, n_x, n_x)\ndfdu_veh = B(x, u[:, :-1], nodes, params)   # Shape: (N-1, n_x, n_u-1)\n\n# Build full control Jacobian including time dilation\ndfdu = jnp.zeros((x.shape[0], n_x, n_u))\ndfdu = dfdu.at[:, :, :-1].set(s[:, None, None] * dfdu_veh)  # Vehicle control derivatives\ndfdu = dfdu.at[:, :, -1].set(f)                              # Time dilation derivative = f\n</code></pre> <p>Why exclude time dilation from dynamics? Time dilation is a meta-control that scales the entire dynamics (used for time-optimal problems). The actual vehicle dynamics are defined without it, and time dilation is applied as a scaling factor during discretization. This is why <code>n_u-1</code> appears in the vehicle dynamics Jacobians.</p> <p>Example with N=10: This single call evaluates dynamics at all 9 intervals simultaneously, leveraging JAX's efficient vectorization on GPU/TPU.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#shape-summary-table","title":"Shape Summary Table","text":"<p>Here's a complete reference for shapes at each stage, shown with symbolic dimensions (<code>N</code>, <code>n_x</code>, <code>n_u</code>) and a concrete example:</p> Stage Variable Symbolic Shape Concrete Example (N=10, n_x=4, n_u=2) User Definition <code>position</code> <code>(2,)</code> <code>(2,)</code> - Single 2D position vector <code>velocity</code> <code>(1,)</code> <code>(1,)</code> - Single scalar velocity <code>theta</code> <code>(1,)</code> <code>(1,)</code> - Single scalar control After Augmentation <code>states_aug</code> List of States [position, velocity, time] (3 states) <code>controls_aug</code> List of Controls [theta, _time_dilation] (2 controls) After Unification <code>x_unified.shape</code> <code>(n_x,)</code> <code>(4,)</code> - position(2) + velocity(1) + time(1) <code>u_unified.shape</code> <code>(n_u,)</code> <code>(2,)</code> - theta(1) + _time_dilation(1) <code>x_unified.guess</code> <code>(N, n_x)</code> <code>(10, 4)</code> - States at 10 nodes <code>u_unified.guess</code> <code>(N, n_u)</code> <code>(10, 2)</code> - Controls at 10 nodes <code>position._slice</code> <code>slice(0, 2)</code> <code>slice(0, 2)</code> - Extract position <code>velocity._slice</code> <code>slice(2, 3)</code> <code>slice(2, 3)</code> - Extract velocity <code>time._slice</code> <code>slice(3, 4)</code> <code>slice(3, 4)</code> - Extract time JAX Functions (Pre-Vmap) Dynamics: <code>f(x, u, node, params)</code> Input: <code>(n_x,), (n_u,), scalar, dict</code> Input: <code>(4,), (2,), scalar, dict</code> Output: <code>(n_x,)</code> Output: <code>(4,)</code> - Single state derivative <code>A(x, u, node, params)</code> Output: <code>(n_x, n_x)</code> Output: <code>(4, 4)</code> - Jacobian df/dx <code>B(x, u, node, params)</code> Output: <code>(n_x, n_u)</code> Output: <code>(4, 2)</code> - Jacobian df/du Constraints: <code>g(x, u, node, params)</code> Input: <code>(n_x,), (n_u,), scalar, dict</code> Input: <code>(4,), (2,), scalar, dict</code> Output: <code>scalar</code> Output: <code>scalar</code> - Single constraint value <code>grad_g_x(x, u, node, params)</code> Output: <code>(n_x,)</code> Output: <code>(4,)</code> - Gradient dg/dx <code>grad_g_u(x, u, node, params)</code> Output: <code>(n_u,)</code> Output: <code>(2,)</code> - Gradient dg/du JAX Functions (Post-Vmap) Dynamics: <code>f(x, u, nodes, params)</code> Input: <code>(N-1, n_x), (N-1, n_u), (N-1,), dict</code> Input: <code>(9, 4), (9, 2), (9,), dict</code> Output: <code>(N-1, n_x)</code> Output: <code>(9, 4)</code> - Derivatives at 9 intervals <code>A(x, u, nodes, params)</code> Output: <code>(N-1, n_x, n_x)</code> Output: <code>(9, 4, 4)</code> - Jacobians at 9 intervals <code>B(x, u, nodes, params)</code> Output: <code>(N-1, n_x, n_u)</code> Output: <code>(9, 4, 2)</code> - Jacobians at 9 intervals Constraints: <code>g(x, u, node, params)</code> Input: <code>(M, n_x), (M, n_u), scalar, dict</code> Input: <code>(3, 4), (3, 2), scalar, dict</code> Output: <code>(M,)</code> Output: <code>(3,)</code> - M=3 constraint evaluations <code>grad_g_x(x, u, node, params)</code> Output: <code>(M, n_x)</code> Output: <code>(3, 4)</code> - Gradients at M nodes <code>grad_g_u(x, u, node, params)</code> Output: <code>(M, n_u)</code> Output: <code>(3, 2)</code> - Gradients at M nodes Cross-Node Constraints: <code>g_cross(X, U, params)</code> Input: <code>(N, n_x), (N, n_u), dict</code> Input: <code>(10, 4), (10, 2), dict</code> Output: <code>scalar</code> Output: <code>scalar</code> - Single constraint <code>grad_g_X(X, U, params)</code> Output: <code>(N, n_x)</code> Output: <code>(10, 4)</code> - Trajectory Jacobian <code>grad_g_U(X, U, params)</code> Output: <code>(N, n_u)</code> Output: <code>(10, 2)</code> - Trajectory Jacobian Note: Jacobians are dense but sparse Sparsity: Typically only 2-3 rows non-zero"},{"location":"UnderTheHood/vectorization_and_vmapping/#performance-implications","title":"Performance Implications","text":"<p>Why This Architecture?</p> <ol> <li>GPU/TPU Acceleration: Vmapping enables SIMD parallelism across nodes for both dynamics and constraints</li> <li>JIT Compilation: JAX compiles vmapped functions once, not per-node</li> <li>Automatic Differentiation: Jacobians and gradients computed automatically via <code>jacfwd</code></li> <li>Reduced Python Overhead: Single JAX call instead of Python loops for evaluation</li> </ol>"},{"location":"UnderTheHood/vectorization_and_vmapping/#implementation-files-reference","title":"Implementation Files Reference","text":"File Function/Class Purpose <code>openscvx/problem.py</code> <code>Problem.__init__</code> Orchestrates preprocessing pipeline <code>openscvx/symbolic/builder.py</code> <code>preprocess_symbolic_problem</code> Augments states/controls/dynamics <code>openscvx/symbolic/lower.py</code> <code>lower_symbolic_expressions</code> Unification and JAX lowering for dynamics/constraints <code>openscvx/symbolic/unified.py</code> <code>unify_states</code>, <code>unify_controls</code> Combines individual variables into unified vectors <code>openscvx/problem.py</code> <code>initialize</code> Applies vmap to dynamics <code>openscvx/discretization.py</code> <code>dVdt</code>, <code>calculate_discretization</code> Uses vmapped dynamics <code>openscvx/constraints/lowered.py</code> <code>LoweredNodalConstraint</code> Container for vmapped nodal constraints <code>openscvx/constraints/cross_node.py</code> <code>LoweredCrossNodeConstraint</code> Container for trajectory-level cross-node constraints <code>openscvx/symbolic/expr/constraint.py</code> <code>CrossNodeConstraint</code> Expression type for cross-node constraints <code>openscvx/symbolic/expr/expr.py</code> <code>NodeReference</code> Expression for referencing specific trajectory nodes <code>openscvx/symbolic/lowerers/jax.py</code> <code>JaxLowerer._visit_cross_node_constraint</code> Lowers CrossNodeConstraint to trajectory-level function <code>openscvx/symbolic/lowerers/jax.py</code> <code>JaxLowerer._visit_node_reference</code> Lowers NodeReference to JAX array indexing <code>openscvx/ocp.py</code> <code>create_cvxpy_variables</code> Creates CVXPy variables including cross-node parameters <code>openscvx/ptr.py</code> <code>PTR_subproblem</code> Updates constraint parameters during SCP iterations"},{"location":"UnderTheHood/vectorization_and_vmapping/#advanced-accessing-unified-vectors","title":"Advanced: Accessing Unified Vectors","text":"<p>During problem setup, you can access the unified objects:</p> <pre><code>problem = Problem(...)\nproblem.initialize()\n\n# Access unified state/control objects\nx_unified = problem.x_unified\nu_unified = problem.u_unified\n\nprint(f\"Total state dimension: {x_unified.shape[0]}\")\nprint(f\"Total control dimension: {u_unified.shape[0]}\")\n\n# Access individual state slices\nfor state in problem.states:\n    print(f\"{state.name}: slice {state._slice}\")\n</code></pre>"},{"location":"UnderTheHood/vectorization_and_vmapping/#common-developer-pitfalls","title":"Common Developer Pitfalls","text":"<ol> <li>Confusing nodes vs intervals: Discretization operates on N-1 intervals between N nodes, so vmapped dynamics have batch size <code>(N-1, ...)</code>, while constraints evaluate at specific nodes (batch size M where M = number of nodes where constraint applies)</li> <li>Forgetting augmented dimensions: <code>n_x</code> and <code>n_u</code> include auto-added states/controls (time, CTCS augmented states, time dilation)</li> <li>Parameter mutability: The <code>params</code> dict is shared across all evaluations - don't modify it during dynamics or constraint evaluation</li> <li>Node index usage: The <code>node</code> parameter enables time-varying behavior (e.g., time-dependent constraints), not for indexing into trajectory arrays</li> <li>Constraint vs dynamics vmap axes: Constraints use <code>in_axes=(0, 0, None, None)</code> (node not batched), while dynamics use <code>in_axes=(0, 0, 0, None)</code> (node batched across intervals)</li> <li>Cross-node constraint signature: Regular nodal constraints use <code>(x, u, node, params)</code> while cross-node constraints use <code>(X, U, params)</code> with full trajectory inputs</li> <li>Cross-node Jacobian memory: Cross-node Jacobians have shape <code>(N, n_x)</code> stored densely but are typically very sparse (most rows are zero). Be aware of memory usage for large N</li> </ol>"},{"location":"UnderTheHood/vectorization_and_vmapping/#see-also","title":"See Also","text":"<ul> <li>Basic Problem Setup - How to define problems</li> <li>API: State - State class documentation</li> <li>API: Control - Control class documentation</li> <li>API: Problem - Main problem class</li> <li>Discretization - How discretization works in OpenSCvx</li> </ul>"},{"location":"Usage/advanced_problem_setup/","title":"Advanced Problem Setup","text":""},{"location":"Usage/advanced_problem_setup/#using-parameters-in-dynamics-and-constraints","title":"Using Parameters in Dynamics and Constraints","text":"<p>OpenSCvx allows you to define symbolic parameters that can be used in both dynamics and constraints. Parameters enable flexible, reusable problem definitions and can be updated at runtime without recompiling.</p>"},{"location":"Usage/advanced_problem_setup/#example-3dof-rocket-landing-with-parameters","title":"Example: 3DoF Rocket Landing with Parameters","text":"<pre><code>import numpy as np\nimport openscvx as ox\n\n# Define parameters for physical constants\ng_e = 9.807  # Gravitational acceleration on Earth (m/s^2)\n\n# Create symbolic parameters\nI_sp = ox.Parameter(\"I_sp\", value=225.0)\ng = ox.Parameter(\"g\", value=3.7114)\ntheta = ox.Parameter(\"theta\", value=27 * np.pi / 180)\n\n# Define states\nposition = ox.State(\"position\", shape=(3,))\nvelocity = ox.State(\"velocity\", shape=(3,))\nmass = ox.State(\"mass\", shape=(1,))\n\n# Define control\nthrust = ox.Control(\"thrust\", shape=(3,))\n\n# Use parameters in dynamics\ng_vec = np.array([0, 0, 1], dtype=np.float64) * g\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": thrust / mass[0] - g_vec,\n    \"mass\": -ox.linalg.Norm(thrust) / (I_sp * g_e * ox.Cos(theta)),\n}\n</code></pre> <p>Parameters are automatically detected and handled by the problem - no need to manually collect or pass them.</p>"},{"location":"Usage/advanced_problem_setup/#using-parameters-in-constraints","title":"Using Parameters in Constraints","text":"<p>Parameters can be used in constraints just like in dynamics:</p> <pre><code># Define obstacle parameters\nobs_center = ox.Parameter(\"obs_center\", shape=(3,), value=np.array([100, 100, 50]))\nobs_radius = ox.Parameter(\"obs_radius\", value=50.0)\n\n# Use in continuous constraint\ndiff = position - obs_center\nconstraints.append(\n    ox.ctcs(diff.T @ diff &gt;= obs_radius**2)\n)\n\n# Use in discrete constraint\nconstraints.append(\n    (ox.linalg.Norm(position - obs_center) &gt;= obs_radius).at([10])\n)\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#updating-parameters-at-runtime","title":"Updating Parameters at Runtime","text":"<p>Parameters can be updated between solves without recompiling:</p> <pre><code># Initial solve\nproblem.initialize()\nresults = problem.solve()\n\n# Update parameter values\nproblem.parameters[\"obs_center\"] = np.array([150, 150, 60])\nproblem.parameters[\"obs_radius\"] = 60.0\n\n# Resolve with new parameter values (no recompilation needed)\nresults = problem.solve()\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#ctcs-constraints-advanced-options","title":"CTCS Constraints: Advanced Options","text":"<p>CTCS (Continuous-Time Constraint Satisfaction) constraints are enforced over continuous intervals using penalty functions.</p>"},{"location":"Usage/advanced_problem_setup/#penalty-function","title":"Penalty Function","text":"<p>You can specify a penalty function using the <code>penalty</code> argument. Built-in options include:</p> <ul> <li><code>squared_relu</code> (default) - \\(\\max(0, g)^2\\)</li> <li><code>huber</code> - \\(\\begin{cases} \\frac{1}{2} g^2 &amp; \\text{if } |g| \\leq \\delta \\\\ \\delta (|g| - \\frac{1}{2}\\delta) &amp; \\text{otherwise} \\end{cases}\\)</li> <li><code>smooth_relu</code> - \\(\\|\\max(0, g)+c\\|-c\\)</li> </ul> <p>Example:</p> <pre><code>constraints.append(\n    ox.ctcs(ox.linalg.Norm(position[:2]) &lt;= 10.0, penalty=\"huber\")\n)\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#node-specific-regions","title":"Node-Specific Regions","text":"<p>To enforce a constraint only over a portion of the trajectory, use the <code>.over()</code> method:</p> <pre><code># Enforce constraint between nodes 3 and 8\nconstraint = (ox.linalg.Norm(position[:2]) &lt;= 10.0).over(\n    interval=(3, 8),\n    penalty=\"squared_relu\"\n)\nconstraints.append(constraint)\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#multiple-augmented-states","title":"Multiple Augmented States","text":"<p>To associate different constraints with different augmented states, use the <code>idx</code> argument:</p> <pre><code># Box constraints use augmented state 0\nconstraints.extend([\n    ox.ctcs(position &lt;= position.max, idx=0),\n    ox.ctcs(position.min &lt;= position, idx=0),\n])\n\n# Thrust magnitude constraints use augmented state 1\nconstraints.extend([\n    ox.ctcs(rho_min &lt;= ox.linalg.Norm(thrust), idx=1),\n    ox.ctcs(ox.linalg.Norm(thrust) &lt;= rho_max, idx=1),\n])\n\n# Thrust pointing constraint uses augmented state 2\nconstraints.append(\n    ox.ctcs(np.cos(theta_max) &lt;= thrust[2] / ox.linalg.Norm(thrust), idx=2)\n)\n</code></pre> <p>This allows different constraints to use separate virtual control and augmented state variables, which can improve convergence.</p>"},{"location":"Usage/advanced_problem_setup/#nodal-constraints-advanced-options","title":"Nodal Constraints: Advanced Options","text":"<p>Nodal constraints are enforced at specific discrete nodes in the trajectory.</p>"},{"location":"Usage/advanced_problem_setup/#convex-and-nonconvex-constraints","title":"Convex and Nonconvex Constraints","text":"<p>For convex constraints, use the <code>.convex()</code> method:</p> <pre><code># Convex constraint - waypoint at node 10\ntarget = np.array([100, 100, 50])\nconstraints.append(\n    (ox.linalg.Norm(position - target, ord=\"inf\") &lt;= 1.0).convex().at([10])\n)\n\n# Convex constraint - altitude limit at node 15\nconstraints.append(\n    (position[2] &gt;= 10.0).convex().at([15])\n)\n</code></pre> <p>For nonconvex constraints, simply use the constraint without <code>.convex()</code>:</p> <pre><code># Nonconvex constraint\nconstraints.append(\n    (velocity.T @ velocity &lt;= v_max**2).at([5, 10, 15])\n)\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#node-specification","title":"Node Specification","text":"<p>Use the <code>.at()</code> method to specify which nodes enforce the constraint:</p> <pre><code># Single node\nconstraints.append((position[2] &gt;= 0).at([0]))\n\n# Multiple nodes\nconstraints.append((ox.linalg.Norm(velocity) &lt;= v_max).at([5, 10, 15, 20]))\n\n# Final node\nconstraints.append((velocity == np.array([0, 0, 0])).at([n-1]))\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#combining-with-ctcs","title":"Combining with CTCS","text":"<p>You can enforce a constraint both continuously and at specific nodes:</p> <pre><code># Enforce continuously with CTCS\nconstraint = ox.linalg.Norm(position - target) &gt;= safe_distance\n\n# Also check nodally (optional, for verification)\nconstraints.append(\n    constraint.over(interval=(0, n-1), check_nodally=True)\n)\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#solver-settings","title":"Solver Settings","text":"<p>OpenSCvx provides extensive configuration options for tuning solver behavior.</p>"},{"location":"Usage/advanced_problem_setup/#scp-algorithm-settings","title":"SCP Algorithm Settings","text":"<pre><code># Trust region settings\nproblem.settings.scp.w_tr = 2e0                  # Trust region weight\nproblem.settings.scp.w_tr_adapt = 1.04           # Trust region adaptation factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e2  # Maximum trust region scaling\n\n# Cost and virtual control weights\nproblem.settings.scp.lam_cost = 2.5e-1           # Weight on the cost objective\nproblem.settings.scp.lam_vc = 1.2e0              # Weight on virtual control\nproblem.settings.scp.lam_vb = 1e0                # Virtual buffer weight (for nonconvex nodal constraints)\n\n# Convergence tolerances\nproblem.settings.scp.ep_tr = 1e-3                # Trust region tolerance\nproblem.settings.scp.ep_vc = 1e-8                # Virtual control tolerance\n\n# Cost relaxation\nproblem.settings.scp.cost_drop = 10              # Iteration to start relaxing cost\nproblem.settings.scp.cost_relax = 0.8            # Cost relaxation factor\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#convex-solver-settings","title":"Convex Solver Settings","text":"<pre><code># Choose convex solver\nproblem.settings.cvx.solver = \"CLARABEL\"  # Options: \"CLARABEL\", \"ECOS\", \"SCS\", \"MOSEK\"\n\n# Solver-specific arguments\nproblem.settings.cvx.solver_args = {\n    \"enforce_dpp\": True,  # Data Parallel Processing for CLARABEL\n}\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#integration-settings","title":"Integration Settings","text":"<pre><code># Propagation time step\nproblem.settings.prp.dt = 0.01\n\n# Integration method\nproblem.settings.dis.solver = \"Dopri8\"  # Options: \"Dopri5\", \"Dopri8\", \"Tsit5\", etc.\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#compilation-and-caching","title":"Compilation and Caching","text":"<pre><code># Save compiled JAX functions for faster subsequent runs\nproblem.settings.sim.save_compiled = True\n</code></pre>"},{"location":"Usage/api/","title":"API","text":"<p>Warning</p> <p>This page is still under development .</p>"},{"location":"Usage/api/#constraints","title":"Constraints","text":"<p>Constraints in openscvx are created using symbolic expressions with comparison operators (<code>==</code>, <code>&lt;=</code>, <code>&gt;=</code>). By default, constraints are enforced at discrete nodes along the trajectory (nodal constraints). The symbolic expression system provides two specialized constraint wrappers for precise control over when and how constraints are enforced.</p>"},{"location":"Usage/api/#basic-constraints","title":"Basic Constraints","text":"<p>All basic constraints are automatically enforced at all discrete nodes unless wrapped with <code>.at()</code> or <code>.over()</code>.</p>"},{"location":"Usage/api/#equality","title":"Equality","text":""},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.Equality","title":"<code>openscvx.symbolic.expr.constraint.Equality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Equality constraint for optimization problems.</p> <p>Represents an equality constraint: lhs == rhs. Can be created using the == operator on Expr objects.</p> Example <p>Define an Equality constraint:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = x == 0  # Creates Equality(x, Constant(0))\n</code></pre>"},{"location":"Usage/api/#inequality","title":"Inequality","text":""},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.Inequality","title":"<code>openscvx.symbolic.expr.constraint.Inequality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Inequality constraint for optimization problems.</p> <p>Represents an inequality constraint: lhs &lt;= rhs. Can be created using the &lt;= operator on Expr objects.</p> Example <p>Define an Inequality constraint:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = x &lt;= 10  # Creates Inequality(x, Constant(10))\n</code></pre>"},{"location":"Usage/api/#specialized-constraint-wrappers","title":"Specialized Constraint Wrappers","text":""},{"location":"Usage/api/#nodalconstraint","title":"NodalConstraint","text":"<p>NodalConstraint allows selective enforcement of constraints at specific time points (nodes) in a discretized trajectory. Created using the <code>.at()</code> method on constraints. Note: Bare constraints without <code>.at()</code> or <code>.over()</code> are automatically converted to NodalConstraints applied at all nodes.</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint","title":"<code>openscvx.symbolic.expr.constraint.NodalConstraint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Wrapper for constraints enforced only at specific discrete trajectory nodes.</p> <p>NodalConstraint allows selective enforcement of constraints at specific time points (nodes) in a discretized trajectory, rather than enforcing them at every node. This is useful for:</p> <ul> <li>Specifying waypoint constraints (e.g., pass through point X at node 10)</li> <li>Boundary conditions at non-standard locations</li> <li>Reducing computational cost by checking constraints less frequently</li> <li>Enforcing periodic constraints (e.g., every 5th node)</li> </ul> <p>The wrapper maintains clean separation between the constraint's mathematical definition and the specification of where it should be applied during optimization.</p> Note <p>Bare Constraint objects (without .at() or .over()) are automatically converted to NodalConstraints applied at all nodes during preprocessing.</p> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (Equality or Inequality) to enforce</p> <code>nodes</code> <p>List of integer node indices where the constraint is enforced</p> Example <p>Enforce position constraint only at nodes 0, 10, and 20:</p> <pre><code>x = State(\"x\", shape=(3,))\ntarget = [10, 5, 0]\nconstraint = (x == target).at([0, 10, 20])\n</code></pre> <p>Equivalent using NodalConstraint directly:</p> <pre><code>constraint = NodalConstraint(x == target, nodes=[0, 10, 20])\n</code></pre> <p>Periodic constraint enforcement (every 10th node):</p> <pre><code>velocity_limit = (vel &lt;= 100).at(list(range(0, 100, 10)))\n</code></pre> <p>Bare constraints are automatically applied at all nodes. These are equivalent:</p> <pre><code>constraint1 = vel &lt;= 100  # Auto-converted to all nodes\nconstraint2 = (vel &lt;= 100).at(list(range(n_nodes)))\n</code></pre>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash NodalConstraint including its node list.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the wrapped constraint while preserving node specification.</p> <p>Returns:</p> Name Type Description <code>NodalConstraint</code> <code>Expr</code> <p>A new NodalConstraint with canonicalized inner constraint</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the wrapped constraint's shape.</p> <p>NodalConstraint wraps a constraint without changing its computational meaning, only specifying where it should be applied. Like all constraints, it produces a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint.convex","title":"<code>convex() -&gt; NodalConstraint</code>","text":"<p>Mark the underlying constraint as convex for CVXPy lowering.</p> <p>Returns:</p> Type Description <code>NodalConstraint</code> <p>Self with underlying constraint's convex flag set to True (enables method chaining)</p> Example <p>Mark a constraint as convex:     constraint = (x &lt;= 10).at([0, 5, 10]).convex()</p>"},{"location":"Usage/api/#ctcs-continuous-time-constraint-satisfaction","title":"CTCS (Continuous-Time Constraint Satisfaction)","text":"<p>CTCS guarantees strict constraint satisfaction throughout the entire continuous trajectory, not just at discrete nodes. It works by augmenting the state vector with additional states whose dynamics integrate constraint violation penalties. Created using the <code>.over()</code> method on constraints.</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS","title":"<code>openscvx.symbolic.expr.constraint.CTCS</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Continuous-Time Constraint Satisfaction using augmented state dynamics.</p> <p>CTCS enables strict continuous-time constraint enforcement in discretized trajectory optimization by augmenting the state vector with additional states whose dynamics are the constraint violation penalties. By constraining these augmented states to remain at zero throughout the trajectory, the original constraints are guaranteed to be satisfied continuously, not just at discrete nodes.</p> <p>How it works:</p> <ol> <li>Each constraint (in canonical form: lhs &lt;= 0) is wrapped in a penalty function</li> <li>Augmented states s_aug_i are added with dynamics: ds_aug_i/dt = sum(penalty_j(lhs_j))    for all CTCS constraints j in group i</li> <li>Each augmented state is constrained: s_aug_i(t) = 0 for all t (strictly enforced)</li> <li>Since s_aug_i integrates the penalties, s_aug_i = 0 implies all penalties in the    group are zero, which means all constraints in the group are satisfied continuously</li> </ol> <p>Grouping and augmented states:</p> <ul> <li>CTCS constraints with the same node interval are grouped into a single augmented   state by default (their penalties are summed)</li> <li>CTCS constraints with different node intervals create separate augmented states</li> <li>Using the <code>idx</code> parameter explicitly assigns constraints to specific augmented states,   allowing manual control over grouping</li> <li>Each unique group creates one augmented state named <code>_ctcs_aug_0</code>, <code>_ctcs_aug_1</code>, etc.</li> </ul> <p>This is particularly useful for:</p> <ul> <li>Path constraints that must hold throughout the entire trajectory (not just at nodes)</li> <li>Obstacle avoidance where constraint violation between nodes could be catastrophic</li> <li>State limits that should be respected continuously (e.g., altitude &gt; 0 for aircraft)</li> <li>Ensuring smooth, feasible trajectories between discretization points</li> </ul> <p>Penalty functions (applied to constraint violations):</p> <ul> <li>squared_relu: Square(PositivePart(lhs)) - smooth, differentiable (default)</li> <li>huber: Huber(PositivePart(lhs)) - less sensitive to outliers than squared</li> <li>smooth_relu: SmoothReLU(lhs) - smooth approximation of ReLU</li> </ul> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (typically Inequality) to enforce continuously</p> <code>penalty</code> <p>Penalty function type ('squared_relu', 'huber', or 'smooth_relu')</p> <code>nodes</code> <p>Optional (start, end) tuple specifying the interval for enforcement, or None to enforce over the entire trajectory</p> <code>idx</code> <p>Optional grouping index for managing multiple augmented states. CTCS constraints with the same idx and nodes are grouped together, sharing an augmented state. If None, auto-assigned based on node intervals.</p> <code>check_nodally</code> <p>Whether to also enforce the constraint at discrete nodes for additional numerical robustness (creates both continuous and nodal constraints)</p> Example <p>Single augmented state (default behavior - same node interval):</p> <pre><code>altitude = State(\"alt\", shape=(1,))\nconstraints = [\n    (altitude &gt;= 10).over((0, 10)),  # Both constraints share\n    (altitude &lt;= 1000).over((0, 10))  # one augmented state\n]\n</code></pre> <p>Multiple augmented states (different node intervals):</p> <pre><code>constraints = [\n    (altitude &gt;= 10).over((0, 5)),  # Creates _ctcs_aug_0\n    (altitude &gt;= 20).over((5, 10))  # Creates _ctcs_aug_1\n]\n</code></pre> <p>Manual grouping with idx parameter:</p> <pre><code>constraints = [\n    (altitude &gt;= 10).over((0, 10), idx=0),    # Group 0\n    (velocity &lt;= 100).over((0, 10), idx=1),   # Group 1 (separate state)\n    (altitude &lt;= 1000).over((0, 10), idx=0)   # Also group 0\n]\n</code></pre>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash CTCS including all its parameters.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the inner constraint while preserving CTCS parameters.</p> <p>Returns:</p> Name Type Description <code>CTCS</code> <code>Expr</code> <p>A new CTCS with canonicalized inner constraint and same parameters</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the constraint and penalty expression shapes.</p> <p>CTCS transforms the wrapped constraint into a penalty expression that is summed (integrated) over the trajectory, always producing a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the wrapped constraint has invalid shape</p> <code>ValueError</code> <p>If the generated penalty expression is not scalar</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS.over","title":"<code>over(interval: tuple[int, int]) -&gt; CTCS</code>","text":"<p>Set or update the continuous interval for this CTCS constraint.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>tuple[int, int]</code> <p>Tuple of (start, end) node indices defining the enforcement interval</p> required <p>Returns:</p> Name Type Description <code>CTCS</code> <code>CTCS</code> <p>New CTCS constraint with the specified interval</p> Example <p>Define constraint over range:</p> <pre><code>constraint = (altitude &gt;= 10).over((0, 50))\n</code></pre> <p>Update interval to cover different range:</p> <pre><code>constraint_updated = constraint.over((50, 100))\n</code></pre>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS.penalty_expr","title":"<code>penalty_expr() -&gt; Expr</code>","text":"<p>Build the penalty expression for this CTCS constraint.</p> <p>Transforms the constraint's left-hand side (in canonical form: lhs &lt;= 0) into a penalty expression using the specified penalty function. The penalty is zero when the constraint is satisfied and positive when violated.</p> <p>This penalty expression becomes part of the dynamics of an augmented state. Multiple CTCS constraints in the same group (same idx) have their penalties summed: ds_aug_i/dt = sum(penalty_j) for all j in group i. By constraining s_aug_i(t) = 0 for all t, we ensure all penalties in the group are zero, which strictly enforces all constraints in the group continuously.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Sum of the penalty function applied to the constraint violation</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown penalty type is specified</p> Note <p>This method is used internally during problem compilation to create augmented state dynamics. Multiple penalty expressions with the same idx are summed together before being added to the dynamics vector via Concat.</p>"},{"location":"Usage/api/#integrators","title":"Integrators","text":""},{"location":"Usage/api/#rk45integrator","title":"RK45Integrator","text":""},{"location":"Usage/api/#openscvx.integrators.solve_ivp_rk45","title":"<code>openscvx.integrators.solve_ivp_rk45(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, is_not_compiled: bool = False)</code>","text":"<p>Solve an initial-value ODE problem using fixed-step RK45 integration.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code>.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of output time points. Defaults to 50.</p> <code>50</code> <code>is_not_compiled</code> <code>bool</code> <p>If True, use Python loop instead of JAX <code>lax.fori_loop</code>. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Array of shape (num_substeps, state_dim) with solution at each time.</p>"},{"location":"Usage/api/#openscvx.integrators.rk45_step","title":"<code>openscvx.integrators.rk45_step(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], t: jnp.ndarray, y: jnp.ndarray, h: float, *args) -&gt; jnp.ndarray</code>","text":"<p>Perform a single RK45 (Runge-Kutta-Fehlberg) integration step.</p> <p>This implements the classic Dorman-Prince coefficients for an explicit 4(5) method, returning the fourth-order estimate.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>t</code> <code>ndarray</code> <p>Current time.</p> required <code>y</code> <code>ndarray</code> <p>Current state vector.</p> required <code>h</code> <code>float</code> <p>Step size.</p> required <code>*args</code> <p>Additional arguments passed to <code>f</code>.</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: Next state estimate at t + h.</p>"},{"location":"Usage/api/#diffrax-integrators","title":"Diffrax Integrators","text":""},{"location":"Usage/api/#openscvx.integrators.solve_ivp_diffrax","title":"<code>openscvx.integrators.solve_ivp_diffrax(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; f(t, y, *args).</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>solver_name</code> is not in SOLVER_MAP.</p>"},{"location":"Usage/api/#openscvx.integrators.solve_ivp_diffrax_prop","title":"<code>openscvx.integrators.solve_ivp_diffrax_prop(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None, save_time: jnp.ndarray = None, mask: jnp.ndarray = None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver. This function is specifically designed for use in the context of trajectory optimization and handles the nonlinear single-shot propagation of state variables in undilated time.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <code>save_time</code> <code>ndarray</code> <p>Time points at which to evaluate the solution. Must be provided for export compatibility.</p> <code>None</code> <code>mask</code> <code>ndarray</code> <p>Boolean mask for the save_time points.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:     ValueError: If <code>solver_name</code> is not in SOLVER_MAP or if save_time is not provided.</p>"},{"location":"Usage/api/#problem","title":"Problem","text":""},{"location":"Usage/api/#openscvx.problem.Problem.__init__","title":"<code>openscvx.problem.Problem.__init__(dynamics: dict, constraints: List[Union[Constraint, CTCS]], states: List[State], controls: List[Control], N: int, time: Time, dynamics_prop: Optional[dict] = None, states_prop: Optional[List[State]] = None, licq_min=0.0, licq_max=0.0001, time_dilation_factor_min=0.3, time_dilation_factor_max=3.0)</code>","text":"<p>The primary class in charge of compiling and exporting the solvers</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>dict</code> <p>Dictionary mapping state names to their dynamics expressions. Each key should be a state name, and each value should be an Expr representing the derivative of that state.</p> required <code>constraints</code> <code>List[Union[CTCSConstraint, NodalConstraint]]</code> <p>List of constraints decorated with @ctcs or @nodal</p> required <code>states</code> <code>List[State]</code> <p>List of State objects representing the state variables. May optionally include a State named \"time\" (see time parameter below).</p> required <code>controls</code> <code>List[Control]</code> <p>List of Control objects representing the control variables</p> required <code>N</code> <code>int</code> <p>Number of segments in the trajectory</p> required <code>time</code> <code>Time</code> <p>Time configuration object with initial, final, min, max. Required. If including a \"time\" state in states, the Time object will be ignored and time properties should be set on the time State object instead.</p> required <code>dynamics_prop</code> <code>dict</code> <p>Dictionary mapping EXTRA state names to their dynamics expressions for propagation. Only specify additional states beyond optimization states (e.g., {\"distance\": speed}). Do NOT duplicate optimization state dynamics here.</p> <code>None</code> <code>states_prop</code> <code>List[State]</code> <p>List of EXTRA State objects for propagation only. Only specify additional states beyond optimization states. Used with dynamics_prop.</p> <code>None</code> <code>licq_min</code> <p>Minimum LICQ constraint value</p> <code>0.0</code> <code>licq_max</code> <p>Maximum LICQ constraint value</p> <code>0.0001</code> <code>time_dilation_factor_min</code> <p>Minimum time dilation factor</p> <code>0.3</code> <code>time_dilation_factor_max</code> <p>Maximum time dilation factor</p> <code>3.0</code> <p>Returns:</p> Type Description <p>None</p> Note <p>There are two approaches for handling time: 1. Auto-create (simple): Don't include \"time\" in states, provide Time object 2. User-provided (for time-dependent constraints): Include \"time\" State in states and    in dynamics dict, don't provide Time object</p>"},{"location":"Usage/api/#scpconfig","title":"ScpConfig","text":""},{"location":"Usage/api/#openscvx.config.ScpConfig.__init__","title":"<code>openscvx.config.ScpConfig.__init__(n: Optional[int] = None, k_max: int = 200, w_tr: float = 1.0, lam_vc: float = 1.0, ep_tr: float = 0.0001, ep_vb: float = 0.0001, ep_vc: float = 1e-08, lam_cost: float = 0.0, lam_vb: float = 0.0, uniform_time_grid: bool = False, cost_drop: int = -1, cost_relax: float = 1.0, w_tr_adapt: float = 1.0, w_tr_max: Optional[float] = None, w_tr_max_scaling_factor: Optional[float] = None)</code>","text":"<p>Configuration class for Sequential Convex Programming (SCP).</p> <p>This class defines the parameters used to configure the SCP solver. You will very likely need to modify the weights for your problem. Please refer to my guide here for more information.</p> <p>Attributes:</p> Name Type Description <code>n</code> <code>int</code> <p>The number of discretization nodes. Defaults to <code>None</code>.</p> <code>k_max</code> <code>int</code> <p>The maximum number of SCP iterations. Defaults to 200.</p> <code>w_tr</code> <code>float</code> <p>The trust region weight. Defaults to 1.0.</p> <code>lam_vc</code> <code>float</code> <p>The penalty weight for virtual control. Defaults to 1.0.</p> <code>ep_tr</code> <code>float</code> <p>The trust region convergence tolerance. Defaults to 1e-4.</p> <code>ep_vb</code> <code>float</code> <p>The boundary constraint convergence tolerance. Defaults to 1e-4.</p> <code>ep_vc</code> <code>float</code> <p>The virtual constraint convergence tolerance. Defaults to 1e-8.</p> <code>lam_cost</code> <code>float</code> <p>The weight for original cost. Defaults to 0.0.</p> <code>lam_vb</code> <code>float</code> <p>The weight for virtual buffer. This is only used if there are nonconvex nodal constraints present. Defaults to 0.0.</p> <code>uniform_time_grid</code> <code>bool</code> <p>Whether to use a uniform time grid. Defaults to <code>False</code>.</p> <code>cost_drop</code> <code>int</code> <p>The number of iterations to allow for cost stagnation before termination. Defaults to -1 (disabled).</p> <code>cost_relax</code> <code>float</code> <p>The relaxation factor for cost reduction. Defaults to 1.0.</p> <code>w_tr_adapt</code> <code>float</code> <p>The adaptation factor for the trust region weight. Defaults to 1.0.</p> <code>w_tr_max</code> <code>float</code> <p>The maximum allowable trust region weight. Defaults to <code>None</code>.</p> <code>w_tr_max_scaling_factor</code> <code>float</code> <p>The scaling factor for the maximum trust region weight. Defaults to <code>None</code>.</p>"},{"location":"Usage/api/#discretizationconfig","title":"DiscretizationConfig","text":""},{"location":"Usage/api/#openscvx.config.DiscretizationConfig.__init__","title":"<code>openscvx.config.DiscretizationConfig.__init__(dis_type: str = 'FOH', custom_integrator: bool = False, solver: str = 'Tsit5', args: Optional[dict] = None, atol: float = 0.001, rtol: float = 1e-06)</code>","text":"<p>Configuration class for discretization settings.</p> <p>This class defines the parameters required for discretizing system dynamics.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>dis_type</code> <code>str</code> <p>The type of discretization to use (e.g., \"FOH\" for First-Order Hold). Defaults to \"FOH\".</p> <code>'FOH'</code> <code>custom_integrator</code> <code>bool</code> <p>This enables our custom fixed-step RK45 algorithm. This tends to be faster than Diffrax but unless you're going for speed, it's recommended to stick with Diffrax for robustness and other solver options. Defaults to False.</p> <code>False</code> <code>solver</code> <code>str</code> <p>Not used if custom_integrator is enabled. Any choice of solver in Diffrax is valid, please refer here, How to Choose a Solver. Defaults to \"Tsit5\".</p> <code>'Tsit5'</code> <p>Other arguments: These arguments are less frequently used, and for most purposes you shouldn't need to understand these.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Dict</code> <p>Additional arguments to pass to the solver which can be found here. Defaults to an empty dictionary.</p> <code>None</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for the solver. Defaults to 1e-3.</p> <code>0.001</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for the solver. Defaults to 1e-6.</p> <code>1e-06</code>"},{"location":"Usage/api/#propagationconfig","title":"PropagationConfig","text":""},{"location":"Usage/api/#openscvx.config.PropagationConfig.__init__","title":"<code>openscvx.config.PropagationConfig.__init__(inter_sample: int = 30, dt: float = 0.01, solver: str = 'Dopri8', max_tau_len: int = 1000, args: Optional[dict] = None, atol: float = 0.001, rtol: float = 1e-06)</code>","text":"<p>Configuration class for propagation settings.</p> <p>This class defines the parameters required for propagating the nonlinear system dynamics using the optimal control sequence.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Other arguments: The solver should likely not be changed as it is a high accuracy 8th-order Runge-Kutta method.</p> <p>Parameters:</p> Name Type Description Default <code>inter_sample</code> <code>int</code> <p>How dense the propagation within multishot discretization should be. Defaults to 30.</p> <code>30</code> <code>dt</code> <code>float</code> <p>The time step for propagation. Defaults to 0.1.</p> <code>0.01</code> <code>solver</code> <code>str</code> <p>The numerical solver to use for propagation (e.g., \"Dopri8\"). Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>max_tau_len</code> <code>int</code> <p>The maximum length of the time vector for propagation. Defaults to 1000.</p> <code>1000</code> <code>args</code> <code>Dict</code> <p>Additional arguments to pass to the solver. Defaults to an empty dictionary.</p> <code>None</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for the solver. Defaults to 1e-3.</p> <code>0.001</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for the solver. Defaults to 1e-6.</p> <code>1e-06</code>"},{"location":"Usage/api/#simconfig","title":"SimConfig","text":""},{"location":"Usage/api/#openscvx.config.SimConfig.__init__","title":"<code>openscvx.config.SimConfig.__init__(x: UnifiedState, x_prop: UnifiedState, u: UnifiedControl, total_time: float, save_compiled: bool = False, ctcs_node_intervals: Optional[list] = None, n_states: Optional[int] = None, n_states_prop: Optional[int] = None, n_controls: Optional[int] = None)</code>","text":"<p>Configuration class for simulation settings.</p> <p>This class defines the parameters required for simulating a trajectory optimization problem.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>State</code> <p>State object, must have .min and .max attributes for bounds.</p> required <code>x_prop</code> <code>State</code> <p>Propagation state object, must have .min and .max attributes for bounds.</p> required <code>u</code> <code>Control</code> <p>Control object, must have .min and .max attributes for bounds.</p> required <code>total_time</code> <code>float</code> <p>The total simulation time.</p> required <code>idx_x_true</code> <code>slice</code> <p>Slice for true state indices.</p> required <code>idx_x_true_prop</code> <code>slice</code> <p>Slice for true propagation state indices.</p> required <code>idx_u_true</code> <code>slice</code> <p>Slice for true control indices.</p> required <code>idx_t</code> <code>slice</code> <p>Slice for time index.</p> required <code>idx_y</code> <code>slice</code> <p>Slice for constraint violation indices.</p> required <code>idx_y_prop</code> <code>slice</code> <p>Slice for propagation constraint violation indices.</p> required <code>idx_s</code> <code>slice</code> <p>Slice for time dilation index.</p> required <code>save_compiled</code> <code>bool</code> <p>If True, save and reuse compiled solver functions. Defaults to False.</p> <code>False</code> <code>ctcs_node_intervals</code> <code>list</code> <p>Node intervals for CTCS constraints.</p> <code>None</code> <code>n_states</code> <code>int</code> <p>The number of state variables. Defaults to <code>None</code> (inferred from x.max).</p> <code>None</code> <code>n_states_prop</code> <code>int</code> <p>The number of propagation state variables. Defaults to <code>None</code> (inferred from x_prop.max).</p> <code>None</code> <code>n_controls</code> <code>int</code> <p>The number of control variables. Defaults to <code>None</code> (inferred from u.max).</p> <code>None</code> Note <p>You can specify custom scaling for specific states/controls using the <code>scaling_min</code> and <code>scaling_max</code> attributes on State, Control, and Time objects. If not set, the default min/max bounds will be used for scaling.</p>"},{"location":"Usage/api/#convexsolverconfig","title":"ConvexSolverConfig","text":""},{"location":"Usage/api/#openscvx.config.ConvexSolverConfig.__init__","title":"<code>openscvx.config.ConvexSolverConfig.__init__(solver: str = 'QOCO', solver_args: Optional[dict] = None, cvxpygen: bool = False, cvxpygen_override: bool = False)</code>","text":"<p>Configuration class for convex solver settings.</p> <p>This class defines the parameters required for configuring a convex solver.</p> <p>These are the arguments most commonly used day-to-day. Generally I have found QOCO to be the most performant of the CVXPY solvers for these types of problems (I do have a bias as the author is from my group) and can handle up to SOCP's. CLARABEL is also a great option with feasibility checking and can handle a few more problem types. CVXPYGen is also great if your problem isn't too large. I have found qocogen to be the most performant of the CVXPYGen solvers.</p> <p>Parameters:</p> Name Type Description Default <code>solver</code> <code>str</code> <p>The name of the CVXPY solver to use. A list of options can be found here. Defaults to \"QOCO\".</p> <code>'QOCO'</code> <code>solver_args</code> <code>dict</code> <p>Ensure you are using the correct arguments for your solver as they are not all common. Additional arguments to configure the solver, such as tolerances. Defaults to {\"abstol\": 1e-6, \"reltol\": 1e-9}.</p> <code>None</code> <code>cvxpygen</code> <code>bool</code> <p>Whether to enable CVXPY code generation for the solver. Defaults to False.</p> <code>False</code>"},{"location":"Usage/api/#devconfig","title":"DevConfig","text":""},{"location":"Usage/api/#openscvx.config.DevConfig.__init__","title":"<code>openscvx.config.DevConfig.__init__(profiling: bool = False, debug: bool = False, printing: bool = True)</code>","text":"<p>Configuration class for development settings.</p> <p>This class defines the parameters used for development and debugging purposes.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>profiling</code> <code>bool</code> <p>Whether to enable profiling for performance analysis. Defaults to False.</p> <code>False</code> <code>debug</code> <code>bool</code> <p>Disables all precompilation so you can place breakpoints and inspect values. Defaults to False.</p> <code>False</code> <code>printing</code> <code>bool</code> <p>Whether to enable printing during development. Defaults to True.</p> <code>True</code>"},{"location":"Usage/api_constraints/","title":"Constraints","text":"<p>Constraints in openscvx are created using symbolic expressions with comparison operators (<code>==</code>, <code>&lt;=</code>, <code>&gt;=</code>). By default, constraints are enforced at discrete nodes along the trajectory (nodal constraints). The symbolic expression system provides two specialized constraint wrappers for precise control over when and how constraints are enforced.</p>"},{"location":"Usage/api_constraints/#basic-constraints","title":"Basic Constraints","text":"<p>All basic constraints are automatically enforced at all discrete nodes unless wrapped with <code>.at()</code> or <code>.over()</code>.</p>"},{"location":"Usage/api_constraints/#equality","title":"Equality","text":""},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.Equality","title":"<code>openscvx.symbolic.expr.constraint.Equality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Equality constraint for optimization problems.</p> <p>Represents an equality constraint: lhs == rhs. Can be created using the == operator on Expr objects.</p> Example <p>Define an Equality constraint:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = x == 0  # Creates Equality(x, Constant(0))\n</code></pre>"},{"location":"Usage/api_constraints/#inequality","title":"Inequality","text":""},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.Inequality","title":"<code>openscvx.symbolic.expr.constraint.Inequality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Inequality constraint for optimization problems.</p> <p>Represents an inequality constraint: lhs &lt;= rhs. Can be created using the &lt;= operator on Expr objects.</p> Example <p>Define an Inequality constraint:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = x &lt;= 10  # Creates Inequality(x, Constant(10))\n</code></pre>"},{"location":"Usage/api_constraints/#specialized-constraint-wrappers","title":"Specialized Constraint Wrappers","text":""},{"location":"Usage/api_constraints/#nodalconstraint","title":"NodalConstraint","text":"<p>NodalConstraint allows selective enforcement of constraints at specific time points (nodes) in a discretized trajectory. Created using the <code>.at()</code> method on constraints. Note: Bare constraints without <code>.at()</code> or <code>.over()</code> are automatically converted to NodalConstraints applied at all nodes.</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint","title":"<code>openscvx.symbolic.expr.constraint.NodalConstraint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Wrapper for constraints enforced only at specific discrete trajectory nodes.</p> <p>NodalConstraint allows selective enforcement of constraints at specific time points (nodes) in a discretized trajectory, rather than enforcing them at every node. This is useful for:</p> <ul> <li>Specifying waypoint constraints (e.g., pass through point X at node 10)</li> <li>Boundary conditions at non-standard locations</li> <li>Reducing computational cost by checking constraints less frequently</li> <li>Enforcing periodic constraints (e.g., every 5th node)</li> </ul> <p>The wrapper maintains clean separation between the constraint's mathematical definition and the specification of where it should be applied during optimization.</p> Note <p>Bare Constraint objects (without .at() or .over()) are automatically converted to NodalConstraints applied at all nodes during preprocessing.</p> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (Equality or Inequality) to enforce</p> <code>nodes</code> <p>List of integer node indices where the constraint is enforced</p> Example <p>Enforce position constraint only at nodes 0, 10, and 20:</p> <pre><code>x = State(\"x\", shape=(3,))\ntarget = [10, 5, 0]\nconstraint = (x == target).at([0, 10, 20])\n</code></pre> <p>Equivalent using NodalConstraint directly:</p> <pre><code>constraint = NodalConstraint(x == target, nodes=[0, 10, 20])\n</code></pre> <p>Periodic constraint enforcement (every 10th node):</p> <pre><code>velocity_limit = (vel &lt;= 100).at(list(range(0, 100, 10)))\n</code></pre> <p>Bare constraints are automatically applied at all nodes. These are equivalent:</p> <pre><code>constraint1 = vel &lt;= 100  # Auto-converted to all nodes\nconstraint2 = (vel &lt;= 100).at(list(range(n_nodes)))\n</code></pre>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash NodalConstraint including its node list.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the wrapped constraint while preserving node specification.</p> <p>Returns:</p> Name Type Description <code>NodalConstraint</code> <code>Expr</code> <p>A new NodalConstraint with canonicalized inner constraint</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the wrapped constraint's shape.</p> <p>NodalConstraint wraps a constraint without changing its computational meaning, only specifying where it should be applied. Like all constraints, it produces a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint.convex","title":"<code>convex() -&gt; NodalConstraint</code>","text":"<p>Mark the underlying constraint as convex for CVXPy lowering.</p> <p>Returns:</p> Type Description <code>NodalConstraint</code> <p>Self with underlying constraint's convex flag set to True (enables method chaining)</p> Example <p>Mark a constraint as convex:     constraint = (x &lt;= 10).at([0, 5, 10]).convex()</p>"},{"location":"Usage/api_constraints/#ctcs-continuous-time-constraint-satisfaction","title":"CTCS (Continuous-Time Constraint Satisfaction)","text":"<p>CTCS guarantees strict constraint satisfaction throughout the entire continuous trajectory, not just at discrete nodes. It works by augmenting the state vector with additional states whose dynamics integrate constraint violation penalties. Created using the <code>.over()</code> method on constraints.</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS","title":"<code>openscvx.symbolic.expr.constraint.CTCS</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Continuous-Time Constraint Satisfaction using augmented state dynamics.</p> <p>CTCS enables strict continuous-time constraint enforcement in discretized trajectory optimization by augmenting the state vector with additional states whose dynamics are the constraint violation penalties. By constraining these augmented states to remain at zero throughout the trajectory, the original constraints are guaranteed to be satisfied continuously, not just at discrete nodes.</p> <p>How it works:</p> <ol> <li>Each constraint (in canonical form: lhs &lt;= 0) is wrapped in a penalty function</li> <li>Augmented states s_aug_i are added with dynamics: ds_aug_i/dt = sum(penalty_j(lhs_j))    for all CTCS constraints j in group i</li> <li>Each augmented state is constrained: s_aug_i(t) = 0 for all t (strictly enforced)</li> <li>Since s_aug_i integrates the penalties, s_aug_i = 0 implies all penalties in the    group are zero, which means all constraints in the group are satisfied continuously</li> </ol> <p>Grouping and augmented states:</p> <ul> <li>CTCS constraints with the same node interval are grouped into a single augmented   state by default (their penalties are summed)</li> <li>CTCS constraints with different node intervals create separate augmented states</li> <li>Using the <code>idx</code> parameter explicitly assigns constraints to specific augmented states,   allowing manual control over grouping</li> <li>Each unique group creates one augmented state named <code>_ctcs_aug_0</code>, <code>_ctcs_aug_1</code>, etc.</li> </ul> <p>This is particularly useful for:</p> <ul> <li>Path constraints that must hold throughout the entire trajectory (not just at nodes)</li> <li>Obstacle avoidance where constraint violation between nodes could be catastrophic</li> <li>State limits that should be respected continuously (e.g., altitude &gt; 0 for aircraft)</li> <li>Ensuring smooth, feasible trajectories between discretization points</li> </ul> <p>Penalty functions (applied to constraint violations):</p> <ul> <li>squared_relu: Square(PositivePart(lhs)) - smooth, differentiable (default)</li> <li>huber: Huber(PositivePart(lhs)) - less sensitive to outliers than squared</li> <li>smooth_relu: SmoothReLU(lhs) - smooth approximation of ReLU</li> </ul> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (typically Inequality) to enforce continuously</p> <code>penalty</code> <p>Penalty function type ('squared_relu', 'huber', or 'smooth_relu')</p> <code>nodes</code> <p>Optional (start, end) tuple specifying the interval for enforcement, or None to enforce over the entire trajectory</p> <code>idx</code> <p>Optional grouping index for managing multiple augmented states. CTCS constraints with the same idx and nodes are grouped together, sharing an augmented state. If None, auto-assigned based on node intervals.</p> <code>check_nodally</code> <p>Whether to also enforce the constraint at discrete nodes for additional numerical robustness (creates both continuous and nodal constraints)</p> Example <p>Single augmented state (default behavior - same node interval):</p> <pre><code>altitude = State(\"alt\", shape=(1,))\nconstraints = [\n    (altitude &gt;= 10).over((0, 10)),  # Both constraints share\n    (altitude &lt;= 1000).over((0, 10))  # one augmented state\n]\n</code></pre> <p>Multiple augmented states (different node intervals):</p> <pre><code>constraints = [\n    (altitude &gt;= 10).over((0, 5)),  # Creates _ctcs_aug_0\n    (altitude &gt;= 20).over((5, 10))  # Creates _ctcs_aug_1\n]\n</code></pre> <p>Manual grouping with idx parameter:</p> <pre><code>constraints = [\n    (altitude &gt;= 10).over((0, 10), idx=0),    # Group 0\n    (velocity &lt;= 100).over((0, 10), idx=1),   # Group 1 (separate state)\n    (altitude &lt;= 1000).over((0, 10), idx=0)   # Also group 0\n]\n</code></pre>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash CTCS including all its parameters.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the inner constraint while preserving CTCS parameters.</p> <p>Returns:</p> Name Type Description <code>CTCS</code> <code>Expr</code> <p>A new CTCS with canonicalized inner constraint and same parameters</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the constraint and penalty expression shapes.</p> <p>CTCS transforms the wrapped constraint into a penalty expression that is summed (integrated) over the trajectory, always producing a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the wrapped constraint has invalid shape</p> <code>ValueError</code> <p>If the generated penalty expression is not scalar</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS.over","title":"<code>over(interval: tuple[int, int]) -&gt; CTCS</code>","text":"<p>Set or update the continuous interval for this CTCS constraint.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>tuple[int, int]</code> <p>Tuple of (start, end) node indices defining the enforcement interval</p> required <p>Returns:</p> Name Type Description <code>CTCS</code> <code>CTCS</code> <p>New CTCS constraint with the specified interval</p> Example <p>Define constraint over range:</p> <pre><code>constraint = (altitude &gt;= 10).over((0, 50))\n</code></pre> <p>Update interval to cover different range:</p> <pre><code>constraint_updated = constraint.over((50, 100))\n</code></pre>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS.penalty_expr","title":"<code>penalty_expr() -&gt; Expr</code>","text":"<p>Build the penalty expression for this CTCS constraint.</p> <p>Transforms the constraint's left-hand side (in canonical form: lhs &lt;= 0) into a penalty expression using the specified penalty function. The penalty is zero when the constraint is satisfied and positive when violated.</p> <p>This penalty expression becomes part of the dynamics of an augmented state. Multiple CTCS constraints in the same group (same idx) have their penalties summed: ds_aug_i/dt = sum(penalty_j) for all j in group i. By constraining s_aug_i(t) = 0 for all t, we ensure all penalties in the group are zero, which strictly enforces all constraints in the group continuously.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Sum of the penalty function applied to the constraint violation</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown penalty type is specified</p> Note <p>This method is used internally during problem compilation to create augmented state dynamics. Multiple penalty expressions with the same idx are summed together before being added to the dynamics vector via Concat.</p>"},{"location":"Usage/api_control/","title":"Control","text":"<p>Control represents control input variables (actuator commands) in a trajectory optimization problem. Unlike State variables which evolve according to dynamics, Controls are direct decision variables that the optimizer can freely adjust (within specified bounds) at each time step to influence the system dynamics.</p> <p>Controls support min/max bounds to enforce actuator limits and initial trajectory guesses to help the optimizer converge.</p>"},{"location":"Usage/api_control/#openscvx.symbolic.expr.control.Control","title":"<code>openscvx.symbolic.expr.control.Control</code>","text":"<p>               Bases: <code>Variable</code></p> <p>Control input variable for trajectory optimization problems.</p> <p>Control represents control input variables (actuator commands) in a trajectory optimization problem. Unlike State variables which evolve according to dynamics, Controls are direct decision variables that the optimizer can freely adjust (within specified bounds) at each time step to influence the system dynamics.</p> <p>Controls are conceptually similar to State variables but simpler - they don't have boundary conditions (initial/final specifications) since controls are typically not constrained at the endpoints. Like States, Controls support:</p> <ul> <li>Min/max bounds to enforce actuator limits</li> <li>Initial trajectory guesses to help the optimizer converge</li> </ul> <p>Common examples of control inputs include:</p> <ul> <li>Thrust magnitude and direction for spacecraft/rockets</li> <li>Throttle settings for engines</li> <li>Steering angles for vehicles</li> <li>Torques for robotic manipulators</li> <li>Force/acceleration commands</li> </ul> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name identifier for this control variable</p> <code>_shape</code> <code>tuple[int, ...]</code> <p>Shape of the control vector (typically 1D like (3,) for 3D thrust)</p> <code>_slice</code> <code>slice | None</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <code>ndarray | None</code> <p>Minimum bounds for each element of the control</p> <code>_max</code> <code>ndarray | None</code> <p>Maximum bounds for each element of the control</p> <code>_guess</code> <code>ndarray | None</code> <p>Initial guess for the control trajectory (n_points, n_controls)</p> Example <p>Scalar throttle control bounded [0, 1]:</p> <pre><code>throttle = Control(\"throttle\", shape=(1,))\nthrottle.min = [0.0]\nthrottle.max = [1.0]\nthrottle.guess = np.full((50, 1), 0.5)  # Start at 50% throttle\n</code></pre> <p>3D thrust vector for spacecraft:</p> <pre><code>thrust = Control(\"thrust\", shape=(3,))\nthrust.min = [-10, -10, 0]    # No downward thrust\nthrust.max = [10, 10, 50]     # Limited thrust\nthrust.guess = np.zeros((50, 3))  # Initialize with zero thrust\n</code></pre> <p>2D steering control (left/right, forward/backward):</p> <pre><code>steer = Control(\"steer\", shape=(2,))\nsteer.min = [-1, -1]\nsteer.max = [1, 1]\nsteer.guess = np.linspace([0, 0], [0, 1], 50)  # Gradual acceleration\n</code></pre>"},{"location":"Usage/api_control/#openscvx.symbolic.expr.control.Control.scaling_max","title":"<code>scaling_max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling maximum bounds for the control variables.</p> <p>Returns:</p> Type Description <p>Array of scaling maximum values for each control variable element, or None if not set.</p>"},{"location":"Usage/api_control/#openscvx.symbolic.expr.control.Control.scaling_min","title":"<code>scaling_min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling minimum bounds for the control variables.</p> <p>Returns:</p> Type Description <p>Array of scaling minimum values for each control variable element, or None if not set.</p>"},{"location":"Usage/api_integrators/","title":"Integrators","text":""},{"location":"Usage/api_integrators/#rk45integrator","title":"RK45Integrator","text":""},{"location":"Usage/api_integrators/#openscvx.integrators.solve_ivp_rk45","title":"<code>openscvx.integrators.solve_ivp_rk45(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, is_not_compiled: bool = False)</code>","text":"<p>Solve an initial-value ODE problem using fixed-step RK45 integration.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code>.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of output time points. Defaults to 50.</p> <code>50</code> <code>is_not_compiled</code> <code>bool</code> <p>If True, use Python loop instead of JAX <code>lax.fori_loop</code>. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Array of shape (num_substeps, state_dim) with solution at each time.</p>"},{"location":"Usage/api_integrators/#openscvx.integrators.rk45_step","title":"<code>openscvx.integrators.rk45_step(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], t: jnp.ndarray, y: jnp.ndarray, h: float, *args) -&gt; jnp.ndarray</code>","text":"<p>Perform a single RK45 (Runge-Kutta-Fehlberg) integration step.</p> <p>This implements the classic Dorman-Prince coefficients for an explicit 4(5) method, returning the fourth-order estimate.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>t</code> <code>ndarray</code> <p>Current time.</p> required <code>y</code> <code>ndarray</code> <p>Current state vector.</p> required <code>h</code> <code>float</code> <p>Step size.</p> required <code>*args</code> <p>Additional arguments passed to <code>f</code>.</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: Next state estimate at t + h.</p>"},{"location":"Usage/api_integrators/#diffrax-integrators","title":"Diffrax Integrators","text":""},{"location":"Usage/api_integrators/#openscvx.integrators.solve_ivp_diffrax","title":"<code>openscvx.integrators.solve_ivp_diffrax(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; f(t, y, *args).</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>solver_name</code> is not in SOLVER_MAP.</p>"},{"location":"Usage/api_integrators/#openscvx.integrators.solve_ivp_diffrax_prop","title":"<code>openscvx.integrators.solve_ivp_diffrax_prop(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None, save_time: jnp.ndarray = None, mask: jnp.ndarray = None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver. This function is specifically designed for use in the context of trajectory optimization and handles the nonlinear single-shot propagation of state variables in undilated time.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <code>save_time</code> <code>ndarray</code> <p>Time points at which to evaluate the solution. Must be provided for export compatibility.</p> <code>None</code> <code>mask</code> <code>ndarray</code> <p>Boolean mask for the save_time points.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:     ValueError: If <code>solver_name</code> is not in SOLVER_MAP or if save_time is not provided.</p>"},{"location":"Usage/api_state/","title":"State","text":"<p>State represents a dynamic state variable in a trajectory optimization problem. Unlike control inputs, states evolve according to dynamics constraints and can have boundary conditions specified at the initial and final time points. Like all Variables, States also support min/max bounds and initial trajectory guesses to help guide the optimization solver toward good solutions.</p>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State","title":"<code>openscvx.symbolic.expr.state.State</code>","text":"<p>               Bases: <code>Variable</code></p> <p>State variable with boundary conditions for trajectory optimization.</p> <p>State represents a dynamic state variable in a trajectory optimization problem. Unlike control inputs, states evolve according to dynamics constraints and can have boundary conditions specified at the initial and final time points. Like all Variables, States also support min/max bounds and initial trajectory guesses to help guide the optimization solver toward good solutions.</p> <p>States support four types of boundary conditions:</p> <ul> <li>fixed: State value is constrained to a specific value</li> <li>free: State value is optimized within the specified bounds</li> <li>minimize: Adds a term to the objective function to minimize the state value</li> <li>maximize: Adds a term to the objective function to maximize the state value</li> </ul> <p>Each element of a multi-dimensional state can have different boundary condition types, allowing for fine-grained control over the optimization.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name identifier for this state variable</p> <code>_shape</code> <code>tuple[int, ...]</code> <p>Shape of the state vector (typically 1D like (3,) for 3D position)</p> <code>_slice</code> <code>slice | None</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <code>ndarray | None</code> <p>Minimum bounds for state variables</p> <code>_max</code> <code>ndarray | None</code> <p>Maximum bounds for state variables</p> <code>_guess</code> <code>ndarray | None</code> <p>Initial trajectory guess</p> <code>_initial</code> <code>ndarray | None</code> <p>Initial state values with boundary condition types</p> <code>initial_type</code> <code>ndarray | None</code> <p>Array of boundary condition types for initial state</p> <code>_final</code> <code>ndarray | None</code> <p>Final state values with boundary condition types</p> <code>final_type</code> <code>ndarray | None</code> <p>Array of boundary condition types for final state</p> Example <p>Scalar time state with fixed initial time, minimize final time:</p> <pre><code>time = State(\"time\", (1,))\ntime.min = [0.0]\ntime.max = [10.0]\ntime.initial = [(\"fixed\", 0.0)]\ntime.final = [(\"minimize\", 5.0)]\n</code></pre> <p>3D position state with mixed boundary conditions:</p> <pre><code>pos = State(\"pos\", (3,))\npos.min = [0, 0, 10]\npos.max = [10, 10, 200]\npos.initial = [0, (\"free\", 1), 50]  # x fixed, y free, z fixed\npos.final = [10, (\"free\", 5), (\"maximize\", 150)]  # Maximize final altitude\n</code></pre>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State.final","title":"<code>final</code>  <code>property</code> <code>writable</code>","text":"<p>Get the final state boundary condition values.</p> <p>Returns:</p> Type Description <p>Array of final state values (regardless of boundary condition type),</p> <p>or None if not set.</p> Note <p>Use <code>final_type</code> to see the boundary condition types for each element.</p> Example <p>Get final state boundary conditions:</p> <pre><code>x = State(\"x\", (2,))\nx.final = [10, (\"minimize\", 0)]\nprint(x.final)  # [10. 0.]\nprint(x.final_type)  # ['Fix' 'Minimize']\n</code></pre>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State.initial","title":"<code>initial</code>  <code>property</code> <code>writable</code>","text":"<p>Get the initial state boundary condition values.</p> <p>Returns:</p> Type Description <p>Array of initial state values (regardless of boundary condition type),</p> <p>or None if not set.</p> Note <p>Use <code>initial_type</code> to see the boundary condition types for each element.</p> Example <p>Get initial state boundary conditions:</p> <pre><code>x = State(\"x\", (2,))\nx.initial = [0, (\"free\", 1)]\nprint(x.initial)  # [0. 1.]\nprint(x.initial_type)  # ['Fix' 'Free']\n</code></pre>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State.max","title":"<code>max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the maximum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of maximum values for each state variable element.</p> Example <p>Get upper bounds:</p> <pre><code>vel = State(\"vel\", (3,))\nvel.max = [10, 10, 5]\nprint(vel.max)  # [10. 10. 5.]\n</code></pre>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State.min","title":"<code>min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the minimum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of minimum values for each state variable element.</p> Example <p>Get lower bounds:</p> <pre><code>pos = State(\"pos\", (3,))\npos.min = [0, 0, 10]\nprint(pos.min)  # [0. 0. 10.]\n</code></pre>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State.scaling_max","title":"<code>scaling_max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling maximum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of scaling maximum values for each state variable element, or None if not set.</p>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State.scaling_min","title":"<code>scaling_min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling minimum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of scaling minimum values for each state variable element, or None if not set.</p>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State._check_bounds_against_initial_final","title":"<code>_check_bounds_against_initial_final()</code>","text":"<p>Validate that fixed boundary conditions respect min/max bounds.</p> <p>This internal method is automatically called when bounds or boundary conditions are set to ensure consistency.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any fixed initial or final value violates the min/max bounds</p>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash State including boundary condition types.</p> <p>Extends Variable._hash_into to include the structural metadata that affects the compiled problem: boundary condition types (fixed, free, minimize, maximize). Values are not hashed as they are runtime parameters.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required"},{"location":"Usage/api_state/#boundary-conditions","title":"Boundary Conditions","text":"<p>States support four types of boundary conditions at initial and final time points. Each element of a multi-dimensional state can have different boundary condition types. Boundary conditions are specified using either a simple number (defaults to \"fixed\") or a tuple of (type, value).</p>"},{"location":"Usage/api_state/#boundarytype-enum","title":"BoundaryType Enum","text":""},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.BoundaryType","title":"<code>openscvx.symbolic.expr.state.BoundaryType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of boundary condition types for state variables.</p> <p>This enum allows users to specify boundary conditions using plain strings while maintaining type safety internally. Boundary conditions control how the optimizer handles initial and final state values.</p> <p>Attributes:</p> Name Type Description <code>FIXED</code> <code>str</code> <p>State value is fixed to a specific value</p> <code>FREE</code> <code>str</code> <p>State value is free to be optimized within bounds</p> <code>MINIMIZE</code> <code>str</code> <p>Objective term to minimize the state value</p> <code>MAXIMIZE</code> <code>str</code> <p>Objective term to maximize the state value</p> Example <p>Can use either enum or string:</p> <pre><code>BoundaryType.FIXED\n\"fixed\"  # Equivalent\n</code></pre>"},{"location":"Usage/api_state/#boundary-condition-types","title":"Boundary Condition Types","text":"<ul> <li>fixed: State value is constrained to a specific value (use plain number or tuple <code>(\"fixed\", value)</code>)</li> <li>free: State value is optimized within bounds, initialized at the given value (use tuple <code>(\"free\", value)</code>)</li> <li>minimize: Adds objective term to minimize the state value (use tuple <code>(\"minimize\", value)</code>)</li> <li>maximize: Adds objective term to maximize the state value (use tuple <code>(\"maximize\", value)</code>)</li> </ul>"},{"location":"Usage/api_trajoptproblem/","title":"Problem","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.problem.Problem.__init__","title":"<code>openscvx.problem.Problem.__init__(dynamics: dict, constraints: List[Union[Constraint, CTCS]], states: List[State], controls: List[Control], N: int, time: Time, dynamics_prop: Optional[dict] = None, states_prop: Optional[List[State]] = None, licq_min=0.0, licq_max=0.0001, time_dilation_factor_min=0.3, time_dilation_factor_max=3.0)</code>","text":"<p>The primary class in charge of compiling and exporting the solvers</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>dict</code> <p>Dictionary mapping state names to their dynamics expressions. Each key should be a state name, and each value should be an Expr representing the derivative of that state.</p> required <code>constraints</code> <code>List[Union[CTCSConstraint, NodalConstraint]]</code> <p>List of constraints decorated with @ctcs or @nodal</p> required <code>states</code> <code>List[State]</code> <p>List of State objects representing the state variables. May optionally include a State named \"time\" (see time parameter below).</p> required <code>controls</code> <code>List[Control]</code> <p>List of Control objects representing the control variables</p> required <code>N</code> <code>int</code> <p>Number of segments in the trajectory</p> required <code>time</code> <code>Time</code> <p>Time configuration object with initial, final, min, max. Required. If including a \"time\" state in states, the Time object will be ignored and time properties should be set on the time State object instead.</p> required <code>dynamics_prop</code> <code>dict</code> <p>Dictionary mapping EXTRA state names to their dynamics expressions for propagation. Only specify additional states beyond optimization states (e.g., {\"distance\": speed}). Do NOT duplicate optimization state dynamics here.</p> <code>None</code> <code>states_prop</code> <code>List[State]</code> <p>List of EXTRA State objects for propagation only. Only specify additional states beyond optimization states. Used with dynamics_prop.</p> <code>None</code> <code>licq_min</code> <p>Minimum LICQ constraint value</p> <code>0.0</code> <code>licq_max</code> <p>Maximum LICQ constraint value</p> <code>0.0001</code> <code>time_dilation_factor_min</code> <p>Minimum time dilation factor</p> <code>0.3</code> <code>time_dilation_factor_max</code> <p>Maximum time dilation factor</p> <code>3.0</code> <p>Returns:</p> Type Description <p>None</p> Note <p>There are two approaches for handling time: 1. Auto-create (simple): Don't include \"time\" in states, provide Time object 2. User-provided (for time-dependent constraints): Include \"time\" State in states and    in dynamics dict, don't provide Time object</p>"},{"location":"Usage/api_trajoptproblem/#scpconfig","title":"ScpConfig","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.config.ScpConfig.__init__","title":"<code>openscvx.config.ScpConfig.__init__(n: Optional[int] = None, k_max: int = 200, w_tr: float = 1.0, lam_vc: float = 1.0, ep_tr: float = 0.0001, ep_vb: float = 0.0001, ep_vc: float = 1e-08, lam_cost: float = 0.0, lam_vb: float = 0.0, uniform_time_grid: bool = False, cost_drop: int = -1, cost_relax: float = 1.0, w_tr_adapt: float = 1.0, w_tr_max: Optional[float] = None, w_tr_max_scaling_factor: Optional[float] = None)</code>","text":"<p>Configuration class for Sequential Convex Programming (SCP).</p> <p>This class defines the parameters used to configure the SCP solver. You will very likely need to modify the weights for your problem. Please refer to my guide here for more information.</p> <p>Attributes:</p> Name Type Description <code>n</code> <code>int</code> <p>The number of discretization nodes. Defaults to <code>None</code>.</p> <code>k_max</code> <code>int</code> <p>The maximum number of SCP iterations. Defaults to 200.</p> <code>w_tr</code> <code>float</code> <p>The trust region weight. Defaults to 1.0.</p> <code>lam_vc</code> <code>float</code> <p>The penalty weight for virtual control. Defaults to 1.0.</p> <code>ep_tr</code> <code>float</code> <p>The trust region convergence tolerance. Defaults to 1e-4.</p> <code>ep_vb</code> <code>float</code> <p>The boundary constraint convergence tolerance. Defaults to 1e-4.</p> <code>ep_vc</code> <code>float</code> <p>The virtual constraint convergence tolerance. Defaults to 1e-8.</p> <code>lam_cost</code> <code>float</code> <p>The weight for original cost. Defaults to 0.0.</p> <code>lam_vb</code> <code>float</code> <p>The weight for virtual buffer. This is only used if there are nonconvex nodal constraints present. Defaults to 0.0.</p> <code>uniform_time_grid</code> <code>bool</code> <p>Whether to use a uniform time grid. Defaults to <code>False</code>.</p> <code>cost_drop</code> <code>int</code> <p>The number of iterations to allow for cost stagnation before termination. Defaults to -1 (disabled).</p> <code>cost_relax</code> <code>float</code> <p>The relaxation factor for cost reduction. Defaults to 1.0.</p> <code>w_tr_adapt</code> <code>float</code> <p>The adaptation factor for the trust region weight. Defaults to 1.0.</p> <code>w_tr_max</code> <code>float</code> <p>The maximum allowable trust region weight. Defaults to <code>None</code>.</p> <code>w_tr_max_scaling_factor</code> <code>float</code> <p>The scaling factor for the maximum trust region weight. Defaults to <code>None</code>.</p>"},{"location":"Usage/api_trajoptproblem/#discretizationconfig","title":"DiscretizationConfig","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.config.DiscretizationConfig.__init__","title":"<code>openscvx.config.DiscretizationConfig.__init__(dis_type: str = 'FOH', custom_integrator: bool = False, solver: str = 'Tsit5', args: Optional[dict] = None, atol: float = 0.001, rtol: float = 1e-06)</code>","text":"<p>Configuration class for discretization settings.</p> <p>This class defines the parameters required for discretizing system dynamics.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>dis_type</code> <code>str</code> <p>The type of discretization to use (e.g., \"FOH\" for First-Order Hold). Defaults to \"FOH\".</p> <code>'FOH'</code> <code>custom_integrator</code> <code>bool</code> <p>This enables our custom fixed-step RK45 algorithm. This tends to be faster than Diffrax but unless you're going for speed, it's recommended to stick with Diffrax for robustness and other solver options. Defaults to False.</p> <code>False</code> <code>solver</code> <code>str</code> <p>Not used if custom_integrator is enabled. Any choice of solver in Diffrax is valid, please refer here, How to Choose a Solver. Defaults to \"Tsit5\".</p> <code>'Tsit5'</code> <p>Other arguments: These arguments are less frequently used, and for most purposes you shouldn't need to understand these.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Dict</code> <p>Additional arguments to pass to the solver which can be found here. Defaults to an empty dictionary.</p> <code>None</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for the solver. Defaults to 1e-3.</p> <code>0.001</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for the solver. Defaults to 1e-6.</p> <code>1e-06</code>"},{"location":"Usage/api_trajoptproblem/#propagationconfig","title":"PropagationConfig","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.config.PropagationConfig.__init__","title":"<code>openscvx.config.PropagationConfig.__init__(inter_sample: int = 30, dt: float = 0.01, solver: str = 'Dopri8', max_tau_len: int = 1000, args: Optional[dict] = None, atol: float = 0.001, rtol: float = 1e-06)</code>","text":"<p>Configuration class for propagation settings.</p> <p>This class defines the parameters required for propagating the nonlinear system dynamics using the optimal control sequence.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Other arguments: The solver should likely not be changed as it is a high accuracy 8th-order Runge-Kutta method.</p> <p>Parameters:</p> Name Type Description Default <code>inter_sample</code> <code>int</code> <p>How dense the propagation within multishot discretization should be. Defaults to 30.</p> <code>30</code> <code>dt</code> <code>float</code> <p>The time step for propagation. Defaults to 0.1.</p> <code>0.01</code> <code>solver</code> <code>str</code> <p>The numerical solver to use for propagation (e.g., \"Dopri8\"). Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>max_tau_len</code> <code>int</code> <p>The maximum length of the time vector for propagation. Defaults to 1000.</p> <code>1000</code> <code>args</code> <code>Dict</code> <p>Additional arguments to pass to the solver. Defaults to an empty dictionary.</p> <code>None</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for the solver. Defaults to 1e-3.</p> <code>0.001</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for the solver. Defaults to 1e-6.</p> <code>1e-06</code>"},{"location":"Usage/api_trajoptproblem/#simconfig","title":"SimConfig","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.config.SimConfig.__init__","title":"<code>openscvx.config.SimConfig.__init__(x: UnifiedState, x_prop: UnifiedState, u: UnifiedControl, total_time: float, save_compiled: bool = False, ctcs_node_intervals: Optional[list] = None, n_states: Optional[int] = None, n_states_prop: Optional[int] = None, n_controls: Optional[int] = None)</code>","text":"<p>Configuration class for simulation settings.</p> <p>This class defines the parameters required for simulating a trajectory optimization problem.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>State</code> <p>State object, must have .min and .max attributes for bounds.</p> required <code>x_prop</code> <code>State</code> <p>Propagation state object, must have .min and .max attributes for bounds.</p> required <code>u</code> <code>Control</code> <p>Control object, must have .min and .max attributes for bounds.</p> required <code>total_time</code> <code>float</code> <p>The total simulation time.</p> required <code>idx_x_true</code> <code>slice</code> <p>Slice for true state indices.</p> required <code>idx_x_true_prop</code> <code>slice</code> <p>Slice for true propagation state indices.</p> required <code>idx_u_true</code> <code>slice</code> <p>Slice for true control indices.</p> required <code>idx_t</code> <code>slice</code> <p>Slice for time index.</p> required <code>idx_y</code> <code>slice</code> <p>Slice for constraint violation indices.</p> required <code>idx_y_prop</code> <code>slice</code> <p>Slice for propagation constraint violation indices.</p> required <code>idx_s</code> <code>slice</code> <p>Slice for time dilation index.</p> required <code>save_compiled</code> <code>bool</code> <p>If True, save and reuse compiled solver functions. Defaults to False.</p> <code>False</code> <code>ctcs_node_intervals</code> <code>list</code> <p>Node intervals for CTCS constraints.</p> <code>None</code> <code>n_states</code> <code>int</code> <p>The number of state variables. Defaults to <code>None</code> (inferred from x.max).</p> <code>None</code> <code>n_states_prop</code> <code>int</code> <p>The number of propagation state variables. Defaults to <code>None</code> (inferred from x_prop.max).</p> <code>None</code> <code>n_controls</code> <code>int</code> <p>The number of control variables. Defaults to <code>None</code> (inferred from u.max).</p> <code>None</code> Note <p>You can specify custom scaling for specific states/controls using the <code>scaling_min</code> and <code>scaling_max</code> attributes on State, Control, and Time objects. If not set, the default min/max bounds will be used for scaling.</p>"},{"location":"Usage/api_trajoptproblem/#convexsolverconfig","title":"ConvexSolverConfig","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.config.ConvexSolverConfig.__init__","title":"<code>openscvx.config.ConvexSolverConfig.__init__(solver: str = 'QOCO', solver_args: Optional[dict] = None, cvxpygen: bool = False, cvxpygen_override: bool = False)</code>","text":"<p>Configuration class for convex solver settings.</p> <p>This class defines the parameters required for configuring a convex solver.</p> <p>These are the arguments most commonly used day-to-day. Generally I have found QOCO to be the most performant of the CVXPY solvers for these types of problems (I do have a bias as the author is from my group) and can handle up to SOCP's. CLARABEL is also a great option with feasibility checking and can handle a few more problem types. CVXPYGen is also great if your problem isn't too large. I have found qocogen to be the most performant of the CVXPYGen solvers.</p> <p>Parameters:</p> Name Type Description Default <code>solver</code> <code>str</code> <p>The name of the CVXPY solver to use. A list of options can be found here. Defaults to \"QOCO\".</p> <code>'QOCO'</code> <code>solver_args</code> <code>dict</code> <p>Ensure you are using the correct arguments for your solver as they are not all common. Additional arguments to configure the solver, such as tolerances. Defaults to {\"abstol\": 1e-6, \"reltol\": 1e-9}.</p> <code>None</code> <code>cvxpygen</code> <code>bool</code> <p>Whether to enable CVXPY code generation for the solver. Defaults to False.</p> <code>False</code>"},{"location":"Usage/api_trajoptproblem/#devconfig","title":"DevConfig","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.config.DevConfig.__init__","title":"<code>openscvx.config.DevConfig.__init__(profiling: bool = False, debug: bool = False, printing: bool = True)</code>","text":"<p>Configuration class for development settings.</p> <p>This class defines the parameters used for development and debugging purposes.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>profiling</code> <code>bool</code> <p>Whether to enable profiling for performance analysis. Defaults to False.</p> <code>False</code> <code>debug</code> <code>bool</code> <p>Disables all precompilation so you can place breakpoints and inspect values. Defaults to False.</p> <code>False</code> <code>printing</code> <code>bool</code> <p>Whether to enable printing during development. Defaults to True.</p> <code>True</code>"},{"location":"Usage/api_variable/","title":"Variable","text":""},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable","title":"<code>openscvx.symbolic.expr.variable.Variable</code>","text":"<p>               Bases: <code>Leaf</code></p> <p>Base class for decision variables in optimization problems.</p> <p>Variable represents decision variables (free parameters) in an optimization problem. These are values that the optimizer can adjust to minimize the objective function while satisfying constraints. Variables can have bounds (min/max) and initial guesses to guide the optimization process.</p> <p>Unlike Parameters (which are fixed values that can be changed between solves), Variables are optimized by the solver. In trajectory optimization, Variables typically represent discretized state or control trajectories.</p> Note <p>Variable is typically not instantiated directly. Instead, use the specialized subclasses State (for state variables with boundary conditions) or Control (for control inputs). These provide additional functionality specific to trajectory optimization.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the variable</p> <code>_shape</code> <code>tuple[int, ...]</code> <p>Shape of the variable as a tuple (typically 1D)</p> <code>_slice</code> <code>slice | None</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <code>ndarray | None</code> <p>Minimum bounds for each element of the variable</p> <code>_max</code> <code>ndarray | None</code> <p>Maximum bounds for each element of the variable</p> <code>_guess</code> <code>ndarray | None</code> <p>Initial guess for the variable trajectory (n_points, n_vars)</p> Example"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable--typically-use-state-or-control-instead-of-variable-directly","title":"Typically, use State or Control instead of Variable directly:","text":"<p>pos = openscvx.State(\"pos\", shape=(3,)) u = openscvx.Control(\"u\", shape=(2,))</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.guess","title":"<code>guess</code>  <code>property</code> <code>writable</code>","text":"<p>Get the initial guess for the variable trajectory.</p> <p>The guess provides a starting point for the optimizer. A good initial guess can significantly improve convergence speed and help avoid local minima.</p> <p>Returns:</p> Type Description <p>2D array of shape (n_points, n_vars) representing the variable trajectory</p> <p>over time, or None if no guess is provided.</p> Example <p>x = Variable(\"x\", shape=(2,))</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.guess--linear-interpolation-from-00-to-1010-over-50-points","title":"Linear interpolation from [0,0] to [10,10] over 50 points","text":"<p>x.guess = np.linspace([0, 0], [10, 10], 50) print(x.guess.shape)  # (50, 2)</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.max","title":"<code>max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the maximum bounds (upper bounds) for the variable.</p> <p>Returns:</p> Type Description <p>Array of maximum values for each element of the variable, or None if unbounded.</p> Example <p>vel = Variable(\"vel\", shape=(3,)) vel.max = [10, 10, 5] print(vel.max)  # [10., 10., 5.]</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.min","title":"<code>min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the minimum bounds (lower bounds) for the variable.</p> <p>Returns:</p> Type Description <p>Array of minimum values for each element of the variable, or None if unbounded.</p> Example <p>pos = Variable(\"pos\", shape=(3,)) pos.min = [-10, -10, 0] print(pos.min)  # [-10., -10., 0.]</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash Variable using its slice (canonical position, name-invariant).</p> <p>Instead of hashing the variable name, we hash the _slice attribute which represents the variable's canonical position in the unified state/control vector. This ensures that two problems with the same structure but different variable names produce the same hash.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.append","title":"<code>append(other=None, *, min=-np.inf, max=np.inf, guess=0.0)</code>","text":"<p>Append a new dimension to this variable or merge with another variable.</p> <p>This method extends the variable's dimension by either: 1. Appending another Variable object (concatenating their dimensions) 2. Adding a single new scalar dimension with specified bounds and guess</p> <p>The bounds and guesses of both variables are concatenated appropriately.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>Another Variable object to append. If None, adds a single scalar dimension with the specified min/max/guess values.</p> <code>None</code> <code>min</code> <p>Minimum bound for the new dimension (only used if other is None). Defaults to -np.inf (unbounded below).</p> <code>-inf</code> <code>max</code> <p>Maximum bound for the new dimension (only used if other is None). Defaults to np.inf (unbounded above).</p> <code>inf</code> <code>guess</code> <p>Initial guess value for the new dimension (only used if other is None). Defaults to 0.0.</p> <code>0.0</code> Example <p>Create a 2D variable and extend it to 3D:</p> <pre><code>pos_xy = Variable(\"pos\", shape=(2,))\npos_xy.min = [-10, -10]\npos_xy.max = [10, 10]\npos_xy.append(min=0, max=100)  # Add z dimension\nprint(pos_xy.shape)  # (3,)\nprint(pos_xy.min)  # [-10., -10., 0.]\nprint(pos_xy.max)  # [10., 10., 100.]\n</code></pre> <p>Merge two variables:</p> <pre><code>pos = Variable(\"pos\", shape=(3,))\nvel = Variable(\"vel\", shape=(3,))\npos.append(vel)  # Now pos has shape (6,)\n</code></pre>"},{"location":"Usage/basic_problem_setup/","title":"Basic Problem Setup","text":"<p>Here we will cover all the necessary elements to setup your problem along with some tips and best practices to get the most out of the package.</p>"},{"location":"Usage/basic_problem_setup/#imports","title":"Imports","text":"<p>First, import OpenSCvx:</p> <pre><code>import numpy as np\nimport jax.numpy as jnp\nimport openscvx as ox\nfrom openscvx import Problem\n</code></pre>"},{"location":"Usage/basic_problem_setup/#state-specification","title":"State Specification","text":"<p>States are defined as individual symbolic variables. Each state component gets its own <code>ox.State</code> object:</p> <pre><code># Create state variables\nposition = ox.State(\"position\", shape=(3,))\nvelocity = ox.State(\"velocity\", shape=(3,))\n\n# Set bounds for each state\nposition.min = np.array([-10, -10, 0])\nposition.max = np.array([10, 10, 20])\n\nvelocity.min = np.array([-5, -5, -5])\nvelocity.max = np.array([5, 5, 5])\n\n# Set initial conditions\nposition.initial = np.array([0, 0, 1])\nvelocity.initial = np.array([0, 0, 0])\n\n# Set final conditions (can use tuples for free/minimize/maximize)\nposition.final = np.array([5, 5, 1])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Set initial guess for SCP (shape: (n_nodes, state_shape))\nposition.guess = np.linspace(position.initial, position.final, n_nodes)\nvelocity.guess = np.zeros((n_nodes, 3))\n\n# Collect all states into a list\nstates = [position, velocity]\n</code></pre> <p>The boundary condition options use tuple syntax:</p> <ul> <li>Fixed value: <code>value</code> or <code>(\"fixed\", value)</code></li> <li>Free variable: <code>(\"free\", guess)</code> - Can be optimized within bounds</li> <li>Minimize: <code>(\"minimize\", guess)</code> - Variable to be minimized</li> <li>Maximize: <code>(\"maximize\", guess)</code> - Variable to be maximized</li> </ul>"},{"location":"Usage/basic_problem_setup/#control-specification","title":"Control Specification","text":"<p>Controls are also defined as individual symbolic variables:</p> <pre><code># Create control variables\nthrust = ox.Control(\"thrust\", shape=(3,))\n\n# Set bounds\nthrust.min = np.array([0, 0, 0])\nthrust.max = np.array([10, 10, 10])\n\n# Set initial guess for SCP (shape: (n_nodes, control_shape))\nthrust.guess = np.repeat(\n    np.expand_dims(np.array([0, 0, 5]), axis=0),\n    n_nodes, axis=0\n)\n\n# Collect all controls into a list\ncontrols = [thrust]\n</code></pre>"},{"location":"Usage/basic_problem_setup/#dynamics","title":"Dynamics","text":"<p>Dynamics are defined as a dictionary mapping state names to their time derivatives using symbolic expressions:</p> <pre><code># Physical parameters\nm = 1.0  # Mass\ng = -9.81  # Gravity\n\n# Define dynamics using symbolic expressions\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": thrust / m + np.array([0, 0, g]),\n}\n</code></pre> <p>The symbolic expressions support standard Python operators: - Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code> - Matrix multiplication: <code>@</code> - Comparisons: <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code> - Indexing: <code>[...]</code> - Transpose: <code>.T</code></p> <p>Common symbolic functions include: - <code>ox.linalg.Norm()</code>: Vector/matrix norms - <code>ox.linalg.Diag()</code>: Diagonal matrices - <code>ox.spatial.QDCM()</code>: Quaternion to DCM - <code>ox.spatial.SSM()</code>: Skew-symmetric matrix - <code>ox.spatial.SSMP()</code>: Skew-symmetric matrix product</p> <p>Note</p> <p>Under the hood, symbolic expressions are compiled using JAX, so use <code>jax.numpy</code> for numerical constants and functions when needed.</p>"},{"location":"Usage/basic_problem_setup/#time-definition","title":"Time Definition","text":"<p>Define a <code>Time</code> object:</p> <pre><code># Fixed time horizon\ntime = ox.Time(\n    initial=0.0,\n    final=10.0,\n    min=0.0,\n    max=10.0,\n)\n\n# Minimum time problem\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", 10.0),  # Minimize final time with initial guess of 10.0\n    min=0.0,\n    max=20.0,\n)\n</code></pre>"},{"location":"Usage/basic_problem_setup/#costs","title":"Costs","text":"<p>You can choose states to minimize or maximize using the tuple syntax in boundary conditions:</p> <pre><code># Minimize a state component at the final time\nenergy = ox.State(\"energy\", shape=())\nenergy.final = (\"minimize\", 0.0)\n\n# Maximize a state component\nreward = ox.State(\"reward\", shape=())\nreward.final = (\"maximize\", 100.0)\n</code></pre>"},{"location":"Usage/basic_problem_setup/#constraints","title":"Constraints","text":"<p>Constraints are created using symbolic expressions with comparison operators.</p>"},{"location":"Usage/basic_problem_setup/#continuous-constraints","title":"Continuous Constraints","text":"<p>Continuous constraints are enforced over time intervals using <code>ox.ctcs()</code>:</p> <pre><code># Box constraints on states\nconstraints = []\nfor state in states:\n    constraints.extend([\n        ox.ctcs(state &lt;= state.max),\n        ox.ctcs(state.min &lt;= state)\n    ])\n\n# Custom path constraints\nmax_speed = 10.0\nconstraints.append(ox.ctcs(ox.linalg.Norm(velocity) &lt;= max_speed))\n\n# Obstacle avoidance (distance &gt;= safe_distance)\nobstacle_center = ox.Parameter(\"obs_center\", shape=(3,), value=np.array([5, 5, 5]))\nsafe_distance = 2.0\ndiff = position - obstacle_center\nconstraints.append(ox.ctcs(diff.T @ diff &gt;= safe_distance**2))\n</code></pre>"},{"location":"Usage/basic_problem_setup/#discrete-constraints","title":"Discrete Constraints","text":"<p>Discrete constraints are enforced at specific nodes using the <code>.at()</code> method:</p> <pre><code># Waypoint constraint at node 10\ntarget = np.array([5, 5, 5])\nconstraints.append(\n    (position == target).at([10])\n)\n\n# Constraint at multiple nodes\nconstraints.append(\n    (ox.linalg.Norm(velocity) &lt;= 1.0).at([0, 5, 10])\n)\n\n# Convex constraints can be marked for better performance\nconstraints.append(\n    (position[2] &gt;= 0).convex().at([15])\n)\n</code></pre>"},{"location":"Usage/basic_problem_setup/#parameters","title":"Parameters","text":"<p>Parameters allow values to be updated at runtime without recompiling:</p> <pre><code># Create parameters\nobs_center = ox.Parameter(\"obs_center\", shape=(3,), value=np.array([1.0, 2.0, 3.0]))\nobs_radius = ox.Parameter(\"obs_radius\", shape=(), value=0.5)\n\n# Use in constraints\ndiff = position - obs_center\nconstraints.append(\n    ox.ctcs(diff.T @ diff &gt;= obs_radius**2)\n)\n\n# Update parameter values later\n# problem.parameters[\"obs_center\"] = new_center_value\n</code></pre>"},{"location":"Usage/basic_problem_setup/#initial-guess","title":"Initial Guess","text":"<p>While not strictly necessary for the initial guess to be dynamically feasible or satisfy constraints, a good guess helps the solver converge faster and avoid local minima.</p> <p>For state trajectories, linear interpolation is a good starting point:</p> <pre><code>position.guess = np.linspace(position.initial, position.final, n_nodes)\nvelocity.guess = np.zeros((n_nodes, 3))\n</code></pre> <p>For control trajectories, use constant values:</p> <pre><code>thrust.guess = np.repeat(\n    np.expand_dims(np.array([0, 0, 5]), axis=0),\n    n_nodes, axis=0\n)\n</code></pre>"},{"location":"Usage/basic_problem_setup/#problem-instantiation","title":"Problem Instantiation","text":"<p>Instantiate the problem with all components:</p> <pre><code>problem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n_nodes,\n)\n</code></pre>"},{"location":"Usage/basic_problem_setup/#configure-scp-weights","title":"Configure SCP Weights","text":"<p>The weights are used to scale the cost, trust region, and dynamic feasibility. A good place to start is to set <code>lam_cost = 0</code>, <code>lam_vc = 1E1</code> and <code>w_tr = 1E0</code>. Then you can slowly increase the cost weight and decrease the trust region weight until you find a good balance.</p> <pre><code>problem.settings.scp.w_tr = 1E0      # Weight on the Trust Region\nproblem.settings.scp.lam_cost = 0E0  # Weight on the Cost\nproblem.settings.scp.lam_vc = 1E1    # Weight on the Virtual Control Objective\n</code></pre> <p>If you have nonconvex nodal constraints then you will also need to include <code>problem.settings.scp.lam_vb = 1E0</code>.</p>"},{"location":"Usage/basic_problem_setup/#running-the-problem","title":"Running the Problem","text":"<p>To solve the trajectory optimization problem:</p> <ol> <li> <p>Initialize the problem:    <pre><code>problem.initialize()\n</code></pre></p> </li> <li> <p>Solve the problem:    <pre><code>results = problem.solve()\n</code></pre></p> </li> <li> <p>Post-process the solution:    <pre><code>results = problem.post_process(results)\n</code></pre></p> </li> <li> <p>Access the solution:    <pre><code># Extract state and control trajectories\nposition_trajectory = results[\"position\"]\nvelocity_trajectory = results[\"velocity\"]\nthrust_trajectory = results[\"thrust\"]\ntime_vector = results[\"time\"]\n</code></pre></p> </li> </ol>"},{"location":"Usage/tutorial_6dof_los_guidance/","title":"6DoF Line-of-Sight Guidance","text":"<p>Awesome! Now that we have a basic understanding of how to use OpenSCvx, let's solve a more complex problem. In this example we will be solving a 6DoF line-of-sight guidance problem. This example comes from a RA-L paper of mine which you can find here. The problem is more complex than the previous example, but demonstrates the power of OpenSCvx's symbolic expression layer.</p> <p>In this problem, it is still a minimum time problem, but now there are 10 gates in which the drone must pass through in a predefined sequence while maintaining a line-of-sight to several key points throughout the entire trajectory. The problem can be expressed as follows:</p> \\[ \\begin{align} \\min_{x,u, t}\\ &amp;t_f, \\\\ \\mathrm{s.t.}\\ &amp;\\dot{x}(t) = f(t, x(t),u(t)) &amp; \\forall t\\in[t_i, t_f], \\\\ &amp; \\lVert A_{\\mathrm{cone}} C(q_{\\mathcal{S}\\to\\mathcal{B}})C(q_{\\mathcal{B}\\to\\mathcal{I}}(t))(r^{\\mathrm{kp},i}_{\\mathcal{I}} - r_{\\mathcal{I}}(t))\\rVert_\\rho - c^\\top C(q_{\\mathcal{S}\\to\\mathcal{B}})C(q_{\\mathcal{B}\\to\\mathcal{I}}(t))(r^{\\mathrm{kp}, i}_{\\mathcal{I}} - r_{\\mathcal{I}}(t)) \\leq 0 &amp; \\forall i \\in [0, N_\\mathrm{kp}], \\forall t\\in[t_i, t_f],\\\\ &amp; \\lVert A_{\\mathrm{gate}} (r(t_i) - r^{i}_{\\mathrm{gate}})\\rVert_\\infty \\leq 1 &amp; \\forall i\\in[0, N_\\mathrm{gates}],\\\\ &amp; x(t) \\leq x_{\\mathrm{max}}, x(t) \\geq x_{\\mathrm{min}} &amp; \\forall t\\in[t_i, t_f],\\\\ &amp; u(t) \\leq u_{\\mathrm{max}}, u(t) \\geq u_{\\mathrm{min}} &amp; \\forall t\\in[t_i, t_f],\\\\ &amp; x(0) = x_\\mathrm{init}, \\\\ &amp; p(t_f) = p_\\mathrm{terminal}, \\\\ \\end{align} \\] <p>where the state vector is the same as before, \\(x = \\begin{bmatrix} p^\\top &amp; v^\\top &amp; q^\\top &amp; w^\\top \\end{bmatrix}^\\top\\). The control vector is also quite famaliar, \\(u = \\begin{bmatrix}f^\\top &amp; \\tau^\\top \\end{bmatrix}^\\top\\). The function \\(f(t, x(t),u(t))\\) describes the dynamics of the drone. </p>"},{"location":"Usage/tutorial_6dof_los_guidance/#los-contraint-formulation","title":"LoS Contraint Formulation","text":"<p>The constraints are where things get a little more interesting. First we have the line of sight (LoS) constraint. I find it easiest to internally break it down into the following two components,</p> <ol> <li> <p>A transformation component which take the location of a keypoint in the inertial frame, \\(r^{\\mathrm{kp},i}_{\\mathcal{I}}\\), and expresses it in the sensor frame, \\(r^{\\mathrm{kp},i}_{\\mathcal{S}}\\), as follows,</p> \\[ r^{\\mathrm{kp},i}_{\\mathcal{S}} = C(q_{\\mathcal{S}\\to\\mathcal{B}})C(q_{\\mathcal{B}\\to\\mathcal{I}}(t))(r^{\\mathrm{kp},i}_{\\mathcal{I}} - r_{\\mathcal{I}}(t))\\] </li> <li> <p>A norm cone component expressed as follows,</p> \\[\\lVert A_{\\mathrm{C}} r^{\\mathrm{kp},i}_{\\mathcal{S}}\\rVert_\\rho \\leq c^\\top r^{\\mathrm{kp},i}_{\\mathcal{S}}\\] </li> </ol> <p>The long expression for the LoS constraint is obtained by simply plugging the first expression into the second. </p>"},{"location":"Usage/tutorial_6dof_los_guidance/#gate-constraint-formulation","title":"Gate Constraint Formulation","text":"<p>The gate constraints are a little more straightforward and are notably convex.</p> \\[\\lVert A_{\\mathrm{gate}} (r(t_i) - r^{i}_{\\mathrm{gate}})\\rVert_\\infty \\leq 1\\] <p>The gate itself is assumed to be square, hence the \\(\\infty\\)-norm but the user could certinaly choose a different norm. The only complication is that they are not path constraints, meaning I only want to enforce them at one single time instant as opposed to the entire trajecory and to make matters worse, the time instant is not known a priori. One could fix this but that would very likely lead to non-optimal solutions with respect to minimum time. </p>"},{"location":"Usage/tutorial_6dof_los_guidance/#imports","title":"Imports","text":"<p>You'll need to import a few libraries to get started. The following code will import the necessary libraries for the example:</p> <pre><code>import numpy as np\nimport numpy.linalg as la\nimport jax.numpy as jnp\n\nimport openscvx as ox\nfrom openscvx import Problem\nfrom openscvx.utils import rot, gen_vertices\n</code></pre> <p>Note how we import <code>openscvx as ox</code> - this gives us access to the symbolic expression system including <code>ox.State</code>, <code>ox.Control</code>, <code>ox.Parameter</code>, and symbolic operations.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#problem-definition","title":"Problem Definition","text":"<p>Lets first define the number of discretization nodes and an initial guess for ToF.</p> <pre><code>n = 33            # Number of discretization nodes\ntotal_time = 40.0 # Initial ToF Guess for the simulation\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#state-definition","title":"State Definition","text":"<p>With the new symbolic expression layer, we define each state component separately as a symbolic variable. Each state can have bounds, initial conditions, and final conditions specified as attributes.</p> <pre><code># Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 100, 50])\nposition.min = np.array([-200.0, -100, 15])\nposition.initial = np.array([10.0, 0, 20])\nposition.final = [10.0, 0, 20]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Collect all states into a list\nstates = [position, velocity, attitude, angular_velocity]\n</code></pre> <p>The <code>(\"free\", value)</code> tuple syntax indicates that a boundary condition is not fixed - the optimizer is free to choose the value, with <code>value</code> serving as an initial guess.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#control-definition","title":"Control Definition","text":"<p>Similar to states, we define control components as symbolic variables:</p> <pre><code># Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\nthrust_force.guess = np.repeat(np.array([[0.0, 0, 10]]), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n# Collect all controls into a list\ncontrols = [thrust_force, torque]\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#problem-parameters","title":"Problem Parameters","text":"<p>We will need to define a few parameters to describe the gates, sensor and keypoints for the problem.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#sensor-paramters","title":"Sensor Paramters","text":"<p>Here we define the parameters we'll use to model the sensor with as follows,</p> <pre><code>alpha_x = 6.0                                        # Angle for the x-axis of Sensor Cone\nalpha_y = 6.0                                        # Angle for the y-axis of Sensor Cone\nA_cone = np.diag([1 / np.tan(np.pi / alpha_x),\n                  1 / np.tan(np.pi / alpha_y),\n                  0,])                               # Conic Matrix in Sensor Frame\nc = jnp.array([0, 0, 1])                             # Boresight Vector in Sensor Frame\nnorm_type = 2                                        # Norm Type\nR_sb = jnp.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])  # Rotation Matrix from Sensor to Body Frame\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#gate-parameters","title":"Gate Parameters","text":"<p>Here we define the parameters we'll use to model the gates with as follows,</p> <pre><code>def gen_vertices(center, radii):\n    \"\"\"\n    Obtains the vertices of the gate.\n    \"\"\"\n    vertices = []\n    vertices.append(center + rot @ [radii[0], 0, radii[2]])\n    vertices.append(center + rot @ [-radii[0], 0, radii[2]])\n    vertices.append(center + rot @ [-radii[0], 0, -radii[2]])\n    vertices.append(center + rot @ [radii[0], 0, -radii[2]])\n    return vertices\n\n\nn_gates = 10                              # Number of gates\ngate_centers = [                          # Center of the gates\n    np.array([ 59.436,  0.0000, 20.0000]),\n    np.array([ 92.964, -23.750, 25.5240]),\n    np.array([ 92.964, -29.274, 20.0000]),\n    np.array([ 92.964, -23.750, 20.0000]),\n    np.array([130.150, -23.750, 20.0000]),\n    np.array([152.400, -73.152, 20.0000]),\n    np.array([ 92.964, -75.080, 20.0000]),\n    np.array([ 92.964, -68.556, 20.0000]),\n    np.array([ 59.436, -81.358, 20.0000]),\n    np.array([ 22.250, -42.672, 20.0000]),\n]\n\nradii = np.array([2.5, 1e-4, 2.5])                 # Radii of the gates\nA_gate = rot @ np.diag(1 / radii) @ rot.T\nA_gate_cen = []\nfor center in gate_centers:\n    center[0] = center[0] + 2.5\n    center[2] = center[2] + 2.5\n    A_gate_cen.append(A_gate @ center)             # Premultiplying A_gate @ center to ensure OCP is DPP compliant\nn_per_gate = 3                                     # Number of nodes between each gate\ngate_nodes = np.arange(n_per_gate, n, n_per_gate)  # Which node to enforce the gate constraint\nvertices = []\nfor center in gate_centers:\n    vertices.append(gen_vertices(center, radii))\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#keypoint-parameters","title":"Keypoint Parameters","text":"<p>We can randomly generate some keypoints for the drone to observe. The keypoints are assumed to be in the inertial frame and can be generated as follows,</p> <pre><code>n_subs = 10                          # Number of keypoints\ninit_poses = []\nnp.random.seed(0)\nfor i in range(n_subs):\n    init_pose = np.array([100.0, -60.0, 20.0])\n    init_pose[:2] = init_pose[:2] + np.random.random(2) * 20.0\n    init_poses.append(init_pose)\n\ninit_poses = init_poses\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#dynamics","title":"Dynamics","text":"<p>With the symbolic expression layer, we can define dynamics using natural mathematical notation. The dynamics are expressed as a dictionary mapping state names to their time derivatives as symbolic expressions:</p> <pre><code># Physical parameters\nm = 1.0  # Mass of the drone\ng_const = -9.18  # Gravity constant\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of inertia\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n                + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv) @ (\n        torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity\n    ),\n}\n</code></pre> <p>The symbolic expressions use: - <code>ox.linalg.Norm()</code>: Compute vector norms - <code>ox.linalg.Diag()</code>: Create diagonal matrices - <code>ox.spatial.QDCM()</code>: Quaternion to direction cosine matrix - <code>ox.spatial.SSMP()</code>: Skew-symmetric matrix product - <code>ox.spatial.SSM()</code>: Skew-symmetric matrix - Standard operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>@</code> (matrix multiplication) </p>"},{"location":"Usage/tutorial_6dof_los_guidance/#constraints","title":"Constraints","text":"<p>In this problem, we have both continuous constraints (enforced over intervals) and discrete constraints (enforced at specific nodes). The symbolic expression layer makes constraint definition intuitive and readable.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#continuous-constraints","title":"Continuous Constraints","text":"<p>First, we define a symbolic function for the line-of-sight (LoS) constraint:</p> <pre><code>def g_vp(p_s_I, x_pos, x_quat):\n    \"\"\"Symbolic sensor visibility constraint function.\"\"\"\n    p_s_s = R_sb @ ox.spatial.QDCM(x_quat).T @ (p_s_I - x_pos)\n    return ox.linalg.Norm(A_cone @ p_s_s, ord=norm_type) - (c.T @ p_s_s)\n</code></pre> <p>Now we can create constraints using symbolic expressions and the convenient <code>ox.ctcs()</code> wrapper:</p> <pre><code>constraints = []\n\n# Add box constraints for all states\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add visibility constraints using symbolic expressions\nfor pose in init_poses:\n    constraints.append(ox.ctcs(g_vp(pose, position, attitude) &lt;= 0.0))\n</code></pre> <p>The <code>ox.ctcs()</code> function wraps a symbolic constraint expression and applies Continuous-Time Constraint Satisfaction (CTCS), which handles path constraints that must be satisfied over continuous intervals.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#discrete-constraints","title":"Discrete Constraints","text":"<p>Gate constraints are only enforced at specific nodes in the trajectory. We use the <code>.at()</code> method to specify which nodes:</p> <pre><code># Add gate constraints using symbolic expressions\nfor node, cen in zip(gate_nodes, A_gate_cen):\n    A_gate_const = A_gate\n    cen_const = cen\n\n    # Gate constraint: ||A @ pos - c||_inf &lt;= 1\n    gate_constraint = (\n        (ox.linalg.Norm(A_gate_const @ position - cen_const, ord=\"inf\") &lt;= 1.0)\n        .convex()\n        .at([node])\n    )\n    constraints.append(gate_constraint)\n</code></pre> <p>The <code>.convex()</code> method marks the constraint as convex for the solver, and <code>.at([node])</code> specifies that this constraint is only enforced at a specific discrete node.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#initial-guess","title":"Initial Guess","text":"<p>For complex problems, we need a sophisticated initial guess. We interpolate positions through each gate and compute attitudes to point the sensor at the keypoints:</p> <pre><code># Initialize position guess - linear interpolation through gates\nposition_bar = np.linspace(position.initial, position.final, n)\ni = 0\norigins = [position.initial]\nends = []\nfor center in gate_centers:\n    origins.append(center)\n    ends.append(center)\nends.append(position.final)\ngate_idx = 0\nfor _ in range(n_gates + 1):\n    for k in range(n // (n_gates + 1)):\n        position_bar[i] = origins[gate_idx] + (k / (n // (n_gates + 1))) * (\n            ends[gate_idx] - origins[gate_idx]\n        )\n        i += 1\n    gate_idx += 1\n\n# Modify attitude to point sensor at targets\nR_sb = jnp.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\nb = R_sb @ np.array([0, 1, 0])\nattitude_bar = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\n\nfor k in range(n):\n    # Average keypoint positions\n    kp = np.mean(init_poses, axis=0)\n    a = kp - position_bar[k]\n\n    # Compute quaternion to align sensor with relative position vector\n    q_xyz = np.cross(b, a)\n    q_w = np.sqrt(la.norm(a) ** 2 + la.norm(b) ** 2) + np.dot(a, b)\n    q_no_norm = np.hstack((q_w, q_xyz))\n    q = q_no_norm / la.norm(q_no_norm)\n    attitude_bar[k] = q\n\n# Set all guesses\nposition.guess = position_bar\nvelocity.guess = np.zeros((n, 3))\nattitude.guess = attitude_bar\nangular_velocity.guess = np.zeros((n, 3))\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#time-definition","title":"Time Definition","text":"<p>For minimum-time problems, we define a <code>Time</code> object:</p> <pre><code>time = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),  # Minimize final time with initial guess\n    min=0.0,\n    max=total_time,\n)\n</code></pre> <p>The <code>(\"minimize\", total_time)</code> tuple indicates that final time is a decision variable to be minimized, with <code>total_time</code> as the initial guess.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#problem-instantiation","title":"Problem Instantiation","text":"<p>Now we instantiate the <code>Problem</code> with our symbolic expressions:</p> <pre><code>problem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#additional-parameters","title":"Additional Parameters","text":"<p>We can define the PTR weights and other parameters as follows.</p> <p>Tip</p> <p>Tuning is probably one of the hardest things to do when working with these type of algorithms. There are some approaches to automate this process (which will soon be included in OpenSCvx once they are published). A good place to start is to set <code>lam_cost = 0</code>, <code>lam_vc = 1E1</code> and <code>w_tr = 1E0</code>. Then you can slowly increase the cost weight and decrease the trust region weight until you find a good balance.</p> <pre><code>problem.settings.scp.w_tr = 2e0                     # Weight on the Trust Reigon\nproblem.settings.scp.lam_cost = 1e-1                # Weight on the Cost\nproblem.settings.scp.lam_vc = 1e1                   # Weight on the Virtual Control\nproblem.settings.scp.ep_tr = 1e-3                   # Trust Region Tolerance\nproblem.settings.scp.ep_vc = 1e-8                   # Virtual Control Tolerance\nproblem.settings.scp.cost_drop = 10                 # SCP iteration to relax cost weight\nproblem.settings.scp.cost_relax = 0.8               # Minimal Time Relaxation Factor\nproblem.settings.scp.w_tr_adapt = 1.4               # Trust Region Adaptation Factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e2  # Maximum Trust Region Weight\n</code></pre> <p>Let's also set some propagation parameters:</p> <pre><code>problem.settings.prp.dt = 0.1  # Time step of the nonlinear propagation\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#plotting","title":"Plotting","text":"<p>We generally leave plotting up to users as it's application-specific. Here we package relevant information into a dictionary for later visualization:</p> <pre><code>plotting_dict = {\n    \"vertices\": vertices,\n    \"n_subs\": n_subs,\n    \"alpha_x\": alpha_x,\n    \"alpha_y\": alpha_y,\n    \"R_sb\": R_sb,\n    \"init_poses\": init_poses,\n    \"norm_type\": norm_type,\n}\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#running-the-simulation","title":"Running the Simulation","text":"<p>To run the simulation, follow these steps:</p> <ol> <li> <p>Initialize the problem:    <pre><code>problem.initialize()\n</code></pre></p> </li> <li> <p>Solve the problem:    <pre><code>results = problem.solve()\n</code></pre></p> </li> <li> <p>Post-process the solution for verification and plotting:    <pre><code>results = problem.post_process(results)\nresults.update(plotting_dict)\n</code></pre></p> </li> <li> <p>Visualize the results:    <pre><code>from examples.plotting import plot_animation\nplot_animation(results, problem.settings).show()\n</code></pre></p> </li> </ol>"},{"location":"Usage/tutorial_6dof_los_guidance/#key-takeaways","title":"Key Takeaways","text":"<p>This example demonstrates the power of OpenSCvx's symbolic expression layer:</p> <ol> <li> <p>Declarative Problem Definition: States, controls, and dynamics are defined using natural mathematical notation with symbolic expressions.</p> </li> <li> <p>Operator Overloading: Standard Python operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>@</code>, <code>&lt;=</code>, <code>==</code>) work directly on symbolic expressions, making code readable and intuitive.</p> </li> <li> <p>Automatic Differentiation: The symbolic layer automatically handles differentiation during compilation to solver-specific formats.</p> </li> <li> <p>Flexible Constraint Specification: Continuous constraints use <code>ox.ctcs()</code>, while discrete constraints use <code>.at([nodes])</code> - both work seamlessly with symbolic expressions.</p> </li> <li> <p>Shape Safety: The expression system validates tensor dimensions before optimization, catching errors early.</p> </li> </ol>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/","title":"6DoF Obstacle Avoidance","text":"<p>This example demonstrates how to use OpenSCvx to solve a trajectory optimization problem in which a drone will navigate around obstacles to fly from point A to point B in minimum time. We will solve this problem in 6DoF, meaning there is 6 degrees of freedom in the problem, mainly 3 translational and 3 rotational degrees. Mathematically we can express this problem as the following,</p> \\[ \\begin{align} \\min_{x,u, t}\\ &amp;t_f, \\\\ \\mathrm{s.t.}\\ &amp;\\dot{x}(t) = f(t, x(t),u(t)) &amp; \\forall t\\in[t_i, t_f], \\\\ &amp; 1- (p(t) - p^i_{\\mathrm{obs}})^\\top A^i_\\mathrm{obs} (r(t) - r^i_{\\mathrm{obs}}) \\leq 0  &amp; \\forall t\\in[t_i, t_f], \\forall i\\in[0, N_\\mathrm{obs}],\\\\ &amp; x(t) \\leq x_{\\mathrm{max}}, x(t) \\geq x_{\\mathrm{min}} &amp; \\forall t\\in[t_i, t_f],\\\\ &amp; u(t) \\leq u_{\\mathrm{max}}, u(t) \\geq u_{\\mathrm{min}} &amp; \\forall t\\in[t_i, t_f],\\\\ &amp; x(0) = x_\\mathrm{init}, \\\\ &amp; p(t_f) = p_\\mathrm{terminal}, \\\\ \\end{align} \\] <p>where the state vector \\(x\\) is expressed as  \\(x = \\begin{bmatrix} r^\\top &amp; v^\\top &amp; q^\\top &amp; w^\\top \\end{bmatrix}^\\top\\). \\(p\\) denotes the position of the drone, \\(v\\) is the velocity, \\(q\\) is the quaternion, \\(w\\) is the angular velocity. The control vector \\(u\\) is expressed as \\(u = \\begin{bmatrix}f^\\top &amp; \\tau^\\top \\end{bmatrix}^\\top\\). Here \\(f\\) is the force in the body frame and \\(\\tau\\) is the torque of the body frame relative to the inertial frame. The function \\(f(t, x(t),u(t))\\) describes the dynamics of the drone. The term \\(1- (r(t) - r^i_{\\mathrm{obs}})^\\top A^i_\\mathrm{obs} (r(t) - r^i_{\\mathrm{obs}})\\) describes the obstacle avoidance constraints for \\(N_\\mathrm{obs}\\) number of obstacles, where \\(A_\\mathrm{obs}\\) is a positive definite matrix that describes the shape of the obstacle.</p>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#imports","title":"Imports","text":"<p>You'll need to import a few libraries to get started:</p> <pre><code>import numpy as np\nimport jax.numpy as jnp\n\nimport openscvx as ox\nfrom openscvx import Problem\nfrom openscvx.utils import generate_orthogonal_unit_vectors\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#problem-definition","title":"Problem Definition","text":"<p>Lets first define the number of discretization nodes and an initial guess for ToF.</p> <pre><code>n = 6             # Number of discretization nodes\ntotal_time = 4.0  # Initial ToF Guess for the simulation\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#state-definition","title":"State Definition","text":"<p>We define each state component separately as a symbolic variable:</p> <pre><code># Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 10, 20])\nposition.min = np.array([-200.0, -100, 0])\nposition.initial = np.array([10.0, 0, 2])\nposition.final = [-10.0, 0, 2]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Collect all states into a list\nstates = [position, velocity, attitude, angular_velocity]\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#control-definition","title":"Control Definition","text":"<p>Similarly, we define control components as symbolic variables:</p> <pre><code># Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\ninitial_control = np.array([0.0, 0.0, thrust_force.max[2]])\nthrust_force.guess = np.repeat(np.expand_dims(initial_control, axis=0), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n# Collect all controls into a list\ncontrols = [thrust_force, torque]\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#dynamics","title":"Dynamics","text":"<p>To describe the dynamics of the drone, lets first introduce some notation to describe in what frame quantities are being represented in. A quantity expressed in the frame \\(\\mathcal{A}\\) is denoted by the subscript \\(\\Box_{\\mathcal{A}}\\). To parameterize the attitude of frame \\(\\mathcal{B}\\) with respect to frame \\(\\mathcal{A}\\), the unit quaternion, \\(q_{\\mathcal{A} \\to \\mathcal{B}} \\in \\mathcal{S}^3\\) where \\(\\mathcal{S}^3\\subset\\mathbb{R}^4\\) is the unit 3-sphere, is used. Here the inertial and body frames are denoted by \\(\\mathcal{I}\\) and \\(\\mathcal{B}\\) respectively. The dynamics of the drone can be expressed as follows:</p> \\[ \\begin{align*}     % \\label{eq:6dof_def}     &amp; \\dot{r}_\\mathcal{I}(t) = v_\\mathcal{I}(t),\\\\     &amp; \\dot{v}_\\mathcal{I}(t) = \\frac{1}{m}\\left(C(q_{\\mathcal{B \\to I}}(t)) f_{ \\mathcal{B}}(t)\\right) + g_{\\mathcal{I}},\\\\     &amp; \\dot{q}_{\\mathcal{I}\\to \\mathcal{B}} = \\frac{1}{2} \\Omega(\\omega_\\mathcal{B}(t))  q_{\\mathcal{I \\to B}}(t),\\\\     &amp; \\dot{\\omega}_\\mathcal{B}(t) =  J_{\\mathcal{B}}^{-1} \\left(M_{\\mathcal{B}}(t) - \\left[\\omega_\\mathcal{B}(t)\\times\\right]J_{\\mathcal{B}} \\omega_\\mathcal{B}(t) \\right), \\end{align*}  \\] <p>where the operator \\(C:\\mathcal{S}^3\\mapsto SO(3)\\) represents the direction cosine matrix (DCM), where \\(SO(3)\\) denotes the special orthogonal group.</p> <p>For a vector \\(\\xi \\in \\mathbb{R}^3\\), the skew-symmetric operators \\(\\Omega(\\xi)\\) and \\([\\xi \\times]\\) are defined as follows:</p> \\[ \\begin{align} [\\xi \\times] = \\begin{bmatrix} 0 &amp; -\\xi_3 &amp; \\xi_2 \\\\ \\xi_2 &amp; 0 &amp; -\\xi_1 \\\\ -\\xi_2 &amp; \\xi_1 &amp; 0 \\end{bmatrix}, \\ \\Omega(\\xi) = \\begin{bmatrix} 0 &amp; -\\xi_1 &amp; \\xi_2 &amp; \\xi_3 \\\\ \\xi_1 &amp; 0 &amp; \\xi_3 &amp; -\\xi_2 \\\\ \\xi_2 &amp; -\\xi_3 &amp; 0 &amp; \\xi_1 \\\\ \\xi_3 &amp; \\xi_2 &amp; -\\xi_1 &amp; 0 \\end{bmatrix} \\end{align} \\] <p>OpenSCvx provides symbolic functions for these operations. We can express the dynamics as a dictionary mapping state names to their derivatives:</p> <pre><code># Physical parameters\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of inertia\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n                + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv) @ (\n        torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity\n    ),\n}\n</code></pre> <p>The symbolic functions used here are: - <code>ox.linalg.Norm()</code>: Compute vector norms - <code>ox.linalg.Diag()</code>: Create diagonal matrices - <code>ox.spatial.QDCM()</code>: Quaternion to direction cosine matrix (DCM) - <code>ox.spatial.SSMP()</code>: Skew-symmetric matrix product \\(\\Omega(\\xi)\\) - <code>ox.spatial.SSM()</code>: Skew-symmetric matrix \\([\\xi \\times]\\)</p>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#constraints","title":"Constraints","text":"<p>First, let's define the obstacle parameters. We'll use ellipsoidal obstacles parameterized by positive definite matrices:</p> <pre><code>A_obs = []\nradius = []\naxes = []\n\n# Default values for the obstacle centers\nobstacle_center_positions = [\n    np.array([-5.1, 0.1, 2]),\n    np.array([0.1, 0.1, 2]),\n    np.array([5.1, 0.1, 2]),\n]\n\n# Define obstacle centers as parameters for runtime updates\nobstacle_centers = [\n    ox.Parameter(\"obstacle_center_1\", shape=(3,), value=obstacle_center_positions[0]),\n    ox.Parameter(\"obstacle_center_2\", shape=(3,), value=obstacle_center_positions[1]),\n    ox.Parameter(\"obstacle_center_3\", shape=(3,), value=obstacle_center_positions[2]),\n]\n\n# Randomly generate obstacle shapes\nnp.random.seed(0)\nfor _ in obstacle_center_positions:\n    ax = generate_orthogonal_unit_vectors()\n    axes.append(generate_orthogonal_unit_vectors())\n    rad = np.random.rand(3) + 0.1 * np.ones(3)\n    radius.append(rad)\n    A_obs.append(ax @ np.diag(rad**2) @ ax.T)\n</code></pre> <p>Now we can create constraints using symbolic expressions:</p> <pre><code># Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add obstacle constraints using symbolic expressions\nfor center, A in zip(obstacle_centers, A_obs):\n    A_const = A\n\n    # Obstacle constraint: (pos - center)^T @ A @ (pos - center) &gt;= 1\n    diff = position - center\n    obstacle_constraint = ox.ctcs(1.0 &lt;= diff.T @ A_const @ diff)\n    constraints.append(obstacle_constraint)\n</code></pre> <p>The <code>ox.ctcs()</code> function applies Continuous-Time Constraint Satisfaction, ensuring the constraints are satisfied over continuous intervals, not just at discrete nodes. Note that <code>ox.Parameter()</code> allows obstacle centers to be updated at runtime without recompiling the problem.</p>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#initial-guess","title":"Initial Guess","text":"<p>We set initial guesses for the state and control trajectories:</p> <pre><code># Set initial guesses\nposition.guess = np.linspace(position.initial, position.final, n)\nvelocity.guess = np.linspace(velocity.initial, [0, 0, 0], n)\nattitude.guess = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\nangular_velocity.guess = np.zeros((n, 3))\n</code></pre> <p>Tip</p> <p>The Penalized Trust Region method does not require the initial guess to be dynamically feasible or satisfy constraints. However, a guess close to the solution reduces iterations and improves numerical stability. Linear interpolation for states and constant values for controls are good starting points.</p>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#time-definition","title":"Time Definition","text":"<p>For minimum-time problems, we define a <code>Time</code> object:</p> <pre><code>time = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#problem-instantiation","title":"Problem Instantiation","text":"<p>Now we instantiate the <code>Problem</code>:</p> <pre><code>problem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#additional-parameters","title":"Additional Parameters","text":"<p>We can configure solver parameters for better performance:</p> <pre><code>problem.settings.prp.dt = 0.01                   # Time step of the nonlinear propagation\nproblem.settings.scp.lam_vb = 1e0                # Virtual buffer weight\nproblem.settings.scp.w_tr_adapt = 1.8            # Trust region adaptation factor\nproblem.settings.scp.w_tr = 1e1                  # Trust region weight\nproblem.settings.scp.lam_cost = 1e1              # Weight on the cost\nproblem.settings.scp.lam_vc = 1e2                # Weight on virtual control\nproblem.settings.scp.cost_drop = 4               # SCP iteration to relax cost\nproblem.settings.scp.cost_relax = 0.5            # Cost relaxation factor\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#plotting","title":"Plotting","text":"<p>We package relevant information for visualization:</p> <pre><code>plotting_dict = {\n    \"obstacles_centers\": obstacle_center_positions,\n    \"obstacles_axes\": axes,\n    \"obstacles_radii\": radius,\n}\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#running-the-simulation","title":"Running the Simulation","text":"<p>To run the simulation, follow these steps:</p> <ol> <li> <p>Initialize the problem:    <pre><code>problem.initialize()\n</code></pre></p> </li> <li> <p>Solve the problem:    <pre><code>results = problem.solve()\n</code></pre></p> </li> <li> <p>Post-process the solution for verification and plotting:    <pre><code>results = problem.post_process(results)\nresults.update(plotting_dict)\n</code></pre></p> </li> <li> <p>Visualize the results:    <pre><code>from examples.plotting import plot_animation\nplot_animation(results, problem.settings).show()\n</code></pre></p> </li> </ol>"},{"location":"Usage/tutorials/","title":"Tutorials","text":"<p>This section provides step-by-step tutorials for using OpenSCvx to solve trajectory optimization problems. Each tutorial includes a Google Colab notebook for interactive learning.</p>"},{"location":"Usage/tutorials/#getting-started","title":"Getting Started","text":"<p>If you're new to OpenSCvx, we recommend:</p> <ol> <li>Start with the Basic Problem Setup guide</li> <li>Work through the 6DoF Obstacle Avoidance tutorial</li> <li>Progress to the Line-of-Sight Guidance tutorial for advanced concepts</li> <li>Explore the Examples section for additional problems</li> </ol>"},{"location":"Usage/tutorials/#available-tutorials","title":"Available Tutorials","text":""},{"location":"Usage/tutorials/#6dof-obstacle-avoidance","title":"6DoF Obstacle Avoidance","text":"<p>Learn how to solve a minimum-time trajectory optimization problem for a 6-degree-of-freedom drone navigating around obstacles. This tutorial covers:</p> <ul> <li>State and control variable definition</li> <li>6DoF dynamics with quaternions</li> <li>Obstacle avoidance constraints</li> <li>Continuous-time constraint satisfaction</li> <li>Problem instantiation and solving</li> </ul>"},{"location":"Usage/tutorials/#6dof-line-of-sight-guidance","title":"6DoF Line-of-Sight Guidance","text":"<p>Solve a complex trajectory optimization problem involving gate navigation and line-of-sight constraints. This advanced tutorial demonstrates:</p> <ul> <li>Multi-gate navigation with sequence constraints</li> <li>Line-of-sight guidance constraints</li> <li>Mixed continuous and discrete constraints</li> <li>Advanced initial guess generation</li> <li>SCP parameter tuning</li> </ul>"},{"location":"Usage/tutorials/#interactive-learning","title":"Interactive Learning","text":"<p>Each tutorial includes a Google Colab notebook that you can run interactively without setting up a local environment. The notebooks contain the complete code examples and allow you to experiment with parameters and see results in real-time.</p>"},{"location":"examples/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Abstract<ul> <li>3DoF Pdg</li> <li>Brachistochrone</li> </ul> </li> <li>Car<ul> <li>Dubins Car</li> <li>Dubins Car Disjoint</li> <li>Dubins Car Stljax</li> </ul> </li> <li>Drone<ul> <li>Cinema Vp</li> <li>Cinema Vp Realtime Base</li> <li>Dr Double Integrator</li> <li>Dr Vp</li> <li>Dr Vp Nodal</li> <li>Dr Vp Polytope</li> <li>Drone Racing</li> <li>Obstacle Avoidance</li> <li>Obstacle Avoidance Nodal</li> <li>Obstacle Avoidance Realtime Base</li> </ul> </li> <li>Realtime<ul> <li>Cinema Vp Realtime</li> <li>Drone Racing Realtime</li> <li>Dubins Car Realtime</li> <li>Obstacle Avoidance Realtime</li> </ul> </li> </ul>"},{"location":"examples/abstract/3DoF_pdg/","title":"3DoF Pdg","text":"<p>3-DOF Powered Descent Guidance (PDG) for planetary landing.</p> <p>This example demonstrates optimal trajectory generation for a rocket performing powered descent guidance, similar to SpaceX Falcon 9 or Blue Origin landings. The problem includes:</p> <ul> <li>3D position and velocity dynamics</li> <li>Fuel-optimal mass minimization</li> <li>Thrust magnitude and pointing constraints</li> <li>Glideslope constraint for safe landing approach</li> </ul> <p>File: <code>examples/abstract/3DoF_pdg.py</code></p> <pre><code>import numpy as np\n\nimport openscvx as ox\nfrom examples.plotting import plot_control_norm, plot_xy_xz_yz\nfrom openscvx import Problem\n\nn = 10\ntotal_time = 95.0  # Total simulation time\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nv_max = 500 * 1e3 / 3600  # Maximum velocity in m/s (800 km/h converted to m/s)\nposition.max = np.array([3000, 3000, 3000])\nposition.min = np.array([-3000, -3000, 0])\nposition.initial = np.array([2000, 0, 1500])\nposition.final = np.array([0, 0, 0])\nposition.guess = np.linspace(position.initial, position.final, n)\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([v_max, v_max, v_max])\nvelocity.min = np.array([-v_max, -v_max, -v_max])\nvelocity.initial = np.array([80, 30, -75])\nvelocity.final = np.array([0, 0, 0])\nvelocity.guess = np.linspace(velocity.initial, velocity.final, n)\n\nmass = ox.State(\"mass\", shape=(1,))  # Vehicle mass\nmass.max = np.array([1905])\nmass.min = np.array([1505])\nmass.initial = np.array([1905])\nmass.final = [(\"maximize\", 1690)]\nmass.scaling_min = np.array([1690])\n# mass.scaling_max = np.array([1700])\nmass.guess = np.linspace(mass.initial, 1690, n).reshape(-1, 1)\n\n# Define control\nthrust = ox.Control(\"thrust\", shape=(3,))  # Thrust force vector [Tx, Ty, Tz]\n\nT_bar = 3.1 * 1e3\nT1 = 0.3 * T_bar\nT2 = 0.8 * T_bar\nn_eng = 6\n\n# Set bounds on control\nthrust.min = n_eng * np.array([-T_bar, -T_bar, -T_bar])\nthrust.max = n_eng * np.array([T_bar, T_bar, T_bar])\n\n# Set initial control guess\nthrust.guess = np.repeat(np.expand_dims(np.array([0, 0, n_eng * (T2) / 2]), axis=0), n, axis=0)\n\n# Define list of all states and controls\nstates = [position, velocity, mass]\ncontrols = [thrust]\n\n\n# Define Parameters for physical constants\ng_e = 9.807  # Gravitational acceleration on Earth in m/s^2\n\n# Create parameters for the problem\nI_sp = ox.Parameter(\"I_sp\", value=225.0)\ng = ox.Parameter(\"g\", value=3.7114)\ntheta = ox.Parameter(\"theta\", value=27 * np.pi / 180)\n\n# These will be computed symbolically in constraints\nrho_min = n_eng * T1 * np.cos(theta.value)  # Minimum thrust-to-weight ratio\nrho_max = n_eng * T2 * np.cos(theta.value)  # Maximum thrust-to-weight ratio\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend(\n        [\n            ox.ctcs(state &lt;= state.max, idx=0),\n            ox.ctcs(state.min &lt;= state, idx=0),\n        ]\n    )\n\n# Thrust magnitude constraints\nconstraints.extend(\n    [\n        ox.ctcs(rho_min &lt;= ox.linalg.Norm(thrust), idx=1),\n        ox.ctcs(ox.linalg.Norm(thrust) &lt;= rho_max, idx=1),\n    ]\n)\n\n# Thrust pointing constraint (thrust cant angle)\nconstraints.append(\n    ox.ctcs(np.cos((180 - 40 * np.pi / 180)) &lt;= thrust[2] / ox.linalg.Norm(thrust), idx=2)\n)\n\n# Glideslope constraint\nconstraints.append(\n    ox.ctcs(ox.linalg.Norm(position[:2]) &lt;= np.tan(86 * np.pi / 180) * position[2], idx=3)\n)\n\n\n# Define dynamics as dictionary mapping state names to their derivatives\ng_vec = np.array([0, 0, 1], dtype=np.float64) * g  # Gravitational acceleration vector\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": thrust / mass[0] - g_vec,\n    \"mass\": -ox.linalg.Norm(thrust) / (I_sp * g_e * ox.Cos(theta)),\n}\n\n# Build the problem\ntime = ox.Time(\n    initial=0.0,\n    final=(\"free\", total_time),\n    min=0.0,\n    max=1e2,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n\n# Set solver parameters\nproblem.settings.scp.k_max = 500\nproblem.settings.scp.w_tr_adapt = 1.04\nproblem.settings.scp.w_tr = 6e-1\nproblem.settings.scp.lam_cost = 4e-1\nproblem.settings.scp.lam_vc = 1.5e0\n\n# problem.settings.scp.uniform_time_grid = True\n\nproblem.settings.dis.dis_type = \"ZOH\"\n\nproblem.settings.dis.solver = \"Dopri8\"\n\nproblem.settings.cvx.solver = \"CLARABEL\"\nproblem.settings.cvx.solver_args = {\"enforce_dpp\": True}\n\n\nplotting_dict = {\n    \"rho_min\": rho_min,\n    \"rho_max\": rho_max,\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n    results.update(plotting_dict)\n\n    # plot_animation_3DoF_rocket(results, problem.settings).show()\n    # plot_scp_animation(results, problem.settings).show()\n    # plot_state(results, problem.settings).show()\n    # plot_control(results, problem.settings).show()\n    plot_control_norm(results, problem.settings).show()\n    plot_xy_xz_yz(results, problem.settings).show()\n\n    # If installed with extras, you can use the following to plot with pyqtgraph\n    # plot_animation_pyqtgraph(results, problem.settings)\n</code></pre>"},{"location":"examples/abstract/brachistochrone/","title":"Brachistochrone","text":"<p>Brachistochrone problem: finding the fastest descent path.</p> <p>This classic calculus of variations problem finds the curve of fastest descent between two points under gravity. The solution demonstrates time-optimal trajectory generation with:</p> <ul> <li>2D position dynamics</li> <li>Speed dynamics under gravitational acceleration</li> <li>Angle control subject to bounds</li> <li>Minimal time objective</li> </ul> <p>File: <code>examples/abstract/brachistochrone.py</code></p> <pre><code>import jax.numpy as jnp\nimport numpy as np\n\nimport openscvx as ox\nfrom examples.plotting import (\n    plot_brachistochrone_position,\n    plot_brachistochrone_velocity,\n)\nfrom openscvx import Problem\n\nn = 2\ntotal_time = 2.0\ng = 9.81\n\n# Define state components\nposition = ox.State(\"position\", shape=(2,))  # 2D position [x, y]\nposition.max = np.array([10.0, 10.0])\nposition.min = np.array([0.0, 0.0])\nposition.initial = np.array([0.0, 10.0])\nposition.final = [10.0, 5.0]\nposition.guess = np.linspace(position.initial, position.final, n)\n\nvelocity = ox.State(\"velocity\", shape=(1,))  # Scalar speed\nvelocity.max = np.array([10.0])\nvelocity.min = np.array([0.0])\nvelocity.initial = np.array([0.0])\nvelocity.final = [(\"free\", 10.0)]\nvelocity.guess = np.linspace(0.0, 10.0, n).reshape(-1, 1)\n\n# Define control\ntheta = ox.Control(\"theta\", shape=(1,))  # Angle from vertical\ntheta.max = np.array([100.5 * jnp.pi / 180])\ntheta.min = np.array([0.0])\ntheta.guess = np.linspace(5 * jnp.pi / 180, 100.5 * jnp.pi / 180, n).reshape(-1, 1)\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity]\ncontrols = [theta]\n\n# Define dynamics as dictionary mapping state names to their derivatives\ndynamics = {\n    \"position\": ox.Concat(\n        velocity[0] * ox.Sin(theta[0]),  # x_dot\n        -velocity[0] * ox.Cos(theta[0]),  # y_dot\n    ),\n    \"velocity\": g * ox.Cos(theta[0]),\n}\n\n# Generate box constraints for all states\nconstraint_exprs = []\nfor state in states:\n    constraint_exprs.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraint_exprs,\n    N=n,\n    licq_max=1e-8,\n)\n\nproblem.settings.prp.dt = 0.01\n\n# problem.settings.cvx.solver = \"qocogen\"\n# problem.settings.cvx.cvxpygen = True\nproblem.settings.cvx.solver_args = {\"abstol\": 1e-6, \"reltol\": 1e-9}\n\nproblem.settings.scp.w_tr = 1e1  # Weight on the Trust Reigon\nproblem.settings.scp.lam_cost = 1e0  # Weight on the Minimal Time Objective\nproblem.settings.scp.lam_vc = 1e1  # Weight on the Virtual Control Objective\nproblem.settings.scp.uniform_time_grid = True\n\nproblem.settings.sim.save_compiled = False\n\nplotting_dict = {}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update(plotting_dict)\n\n    plot_brachistochrone_position(results).show()\n    plot_brachistochrone_velocity(results).show()\n</code></pre>"},{"location":"examples/car/dubins_car/","title":"Dubins Car","text":"<p>Dubins car path planning with obstacle avoidance.</p> <p>This example demonstrates minimum-time path planning for a Dubins car (car-like vehicle with minimum turning radius) navigating around a circular obstacle. The problem includes:</p> <ul> <li>2D position and heading dynamics</li> <li>Speed and angular rate control inputs</li> <li>Circular obstacle avoidance constraint</li> <li>Minimal time objective with free final heading</li> <li>Parameter updates for multiple scenarios</li> </ul> <p>File: <code>examples/car/dubins_car.py</code></p> <pre><code>import jax.numpy as jnp\nimport numpy as np\n\nimport openscvx as ox\nfrom examples.plotting import plot_dubins_car\nfrom openscvx import Problem\n\nn = 8\ntotal_time = 1.2  # Total simulation time\n\n# Define state components\nposition = ox.State(\"position\", shape=(2,))  # 2D position [x, y]\nposition.min = np.array([-5.0, -5.0])\nposition.max = np.array([5.0, 5.0])\nposition.initial = np.array([0, -2])\nposition.final = np.array([0, 2])\nposition.guess = np.linspace(position.initial, position.final, n)\n\ntheta = ox.State(\"theta\", shape=(1,))  # Heading angle\ntheta.min = np.array([-2 * jnp.pi])\ntheta.max = np.array([2 * jnp.pi])\ntheta.initial = np.array([0])\ntheta.final = [ox.Free(0)]\ntheta.guess = np.zeros((n, 1))\n\n# Define control components\nspeed = ox.Control(\"speed\", shape=(1,))  # Forward speed\nspeed.min = np.array([0])\nspeed.max = np.array([10])\nspeed.guess = np.zeros((n, 1))\n\nangular_rate = ox.Control(\"angular_rate\", shape=(1,))  # Angular velocity\nangular_rate.min = np.array([-5])\nangular_rate.max = np.array([5])\nangular_rate.guess = np.zeros((n, 1))\n\n# Define list of all states and controls\nstates = [position, theta]\ncontrols = [speed, angular_rate]\n\n# Define Parameters with initial values for obstacle radius and center\nobs_center = ox.Parameter(\"obs_center\", shape=(2,), value=np.array([-2.01, 0.0]))\nobs_radius = ox.Parameter(\"obs_radius\", shape=(), value=1.0)\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add obstacle avoidance constraint\nconstraints.append(ox.ctcs(obs_radius &lt;= ox.linalg.Norm(position - obs_center)))\n\n\n# Define dynamics as dictionary mapping state names to their derivatives\ndynamics = {\n    \"position\": ox.Concat(\n        speed[0] * ox.Sin(theta[0]),  # x_dot\n        speed[0] * ox.Cos(theta[0]),  # y_dot\n    ),\n    \"theta\": angular_rate[0],\n}\n\n\n# Build the problem (parameters auto-collected from Parameter objects)\ntime = ox.Time(\n    initial=0.0,\n    final=ox.Minimize(total_time),\n    min=0.0,\n    max=20,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n    licq_max=1e-8,\n    time_dilation_factor_min=0.02,\n)\n\n# Set solver parameters\nproblem.settings.prp.dt = 0.01\n# problem.settings.scp.w_tr_adapt = 1.3\nproblem.settings.scp.w_tr = 1e0\nproblem.settings.scp.lam_cost = 4e1\nproblem.settings.scp.lam_vc = 1e3\nproblem.settings.scp.uniform_time_grid = True\n\n# Enable CLI printing for optimization iterations\nproblem.settings.dev.printing = True\n\n# problem.settings.cvx.cvxpygen = True\n# problem.settings.cvx.solver = \"qocogen\"\nproblem.settings.cvx.solver_args = {}\n# problem.settings.cvx.cvxpygen_override = True\n\n\nplotting_dict = {\n    \"obs_radius\": problem.parameters[\"obs_radius\"],\n    \"obs_center\": problem.parameters[\"obs_center\"],\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n    results.update(plotting_dict)\n\n    plot_dubins_car(results, problem.settings).show()\n\n    # Second run with different parameters\n    problem.parameters[\"obs_center\"] = np.array([0.5, 0.0])\n    total_time = 0.7  # Adjust total time for second run\n    problem.settings.scp.lam_cost = 1e-1  # Disable minimal time objective for second run\n    problem.settings.scp.w_tr = 1e0\n    problem.settings.scp.lam_vc = 1e2  # Adjust virtual control weight\n    position.guess = np.linspace([0, -2], [0, 2], n)\n    theta.guess = np.zeros((n, 1))\n    speed.guess = np.zeros((n, 1))\n    angular_rate.guess = np.zeros((n, 1))\n\n    plotting_dict[\"obs_center\"] = np.array([0.5, 0.0])\n\n    results = problem.solve()\n    results = problem.post_process()\n    results.update(plotting_dict)\n    plot_dubins_car(results, problem.settings).show()\n</code></pre>"},{"location":"examples/car/dubins_car_disjoint/","title":"Dubins Car Disjoint","text":"<p>Dubins car with disjoint waypoint visiting constraints.</p> <p>This example demonstrates a Dubins car that must visit one of two waypoints using a smooth max approximation for the disjoint constraint. The problem includes:</p> <ul> <li>2D position and heading dynamics</li> <li>Disjoint waypoint visiting requirement (visit wp1 OR wp2)</li> <li>Smooth max approximation for non-convex OR constraint</li> <li>Loop closure constraint requiring similar start/end positions</li> <li>Minimal time objective</li> </ul> <p>File: <code>examples/car/dubins_car_disjoint.py</code></p> <pre><code>import jax.numpy as jnp\nimport numpy as np\n\nimport openscvx as ox\nfrom examples.plotting import plot_dubins_car_disjoint\nfrom openscvx import Problem\n\nn = 8\ntotal_time = 6.0  # Total simulation time\n\n# Define state components\nposition = ox.State(\"position\", shape=(2,))  # 2D position [x, y]\nposition.min = np.array([-5.0, -5.0])\nposition.max = np.array([5.0, 5.0])\nposition.initial = np.array([0, -2])\nposition.final = [ox.Free(0), ox.Free(-1.5)]\nposition.guess = np.linspace(position.initial, [0, 2], n)\n\ntheta = ox.State(\"theta\", shape=(1,))  # Heading angle\ntheta.min = np.array([-2 * jnp.pi])\ntheta.max = np.array([2 * jnp.pi])\ntheta.initial = np.array([0])\ntheta.final = [(\"free\", 0)]\ntheta.guess = np.zeros((n, 1))\n\n# Define control components\nspeed = ox.Control(\"speed\", shape=(1,))  # Forward speed\nspeed.min = np.array([0])\nspeed.max = np.array([10])\nspeed.guess = np.zeros((n, 1))\n\nangular_rate = ox.Control(\"angular_rate\", shape=(1,))  # Angular velocity\nangular_rate.min = np.array([-5])\nangular_rate.max = np.array([5])\nangular_rate.guess = np.zeros((n, 1))\n\n# Define list of all states and controls\nstates = [position, theta]\ncontrols = [speed, angular_rate]\n# Define Parameters for wp radius and center\nwp1_center = ox.Parameter(\"wp1_center\", shape=(2,), value=np.array([-2.1, 0.0]))\nwp1_radius = ox.Parameter(\"wp1_radius\", shape=(), value=0.5)\nwp2_center = ox.Parameter(\"wp2_center\", shape=(2,), value=np.array([1.9, 0.0]))\nwp2_radius = ox.Parameter(\"wp2_radius\", shape=(), value=0.5)\n\n# Define dynamics as dictionary mapping state names to their derivatives\ndynamics = {\n    \"position\": ox.Concat(\n        speed[0] * ox.Sin(theta[0]),  # x_dot\n        speed[0] * ox.Cos(theta[0]),  # y_dot\n    ),\n    \"theta\": angular_rate[0],\n}\n\n\n# Create symbolic visit waypoint OR constraint\ndef create_visit_wp_OR_expr():\n    # Visit wp1 or wp2 using smooth max\n    d1 = ox.linalg.Norm(position - wp1_center)\n    d2 = ox.linalg.Norm(position - wp2_center)\n    v1 = wp1_radius - d1\n    v2 = wp2_radius - d2\n    alpha = 10.0  # smoothing parameter; higher = closer to max\n    smooth_max = (1.0 / alpha) * ox.Log(ox.Exp(alpha * v1) + ox.Exp(alpha * v2))\n    return -smooth_max\n\n\nvisit_wp_expr = create_visit_wp_OR_expr()\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Visit waypoint constraints using smooth max\nconstraints.append(ox.ctcs(visit_wp_expr &lt;= 0.0).over((3, 5)))\n\nconstraints.append((ox.linalg.Norm(position.at(0) - position.at(-1)) &lt;= 1.0).convex())\n\n# Build the problem\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=20,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n# Set solver parameters\nproblem.settings.prp.dt = 0.01\nproblem.settings.scp.w_tr_adapt = 1.1\nproblem.settings.scp.w_tr = 1e0\nproblem.settings.scp.lam_cost = 1e-1\nproblem.settings.scp.lam_vc = 6e2\nproblem.settings.scp.uniform_time_grid = True\nplotting_dict = {\n    \"wp1_radius\": problem.parameters[\"wp1_radius\"],\n    \"wp1_center\": problem.parameters[\"wp1_center\"],\n    \"wp2_radius\": problem.parameters[\"wp2_radius\"],\n    \"wp2_center\": problem.parameters[\"wp2_center\"],\n}\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n    results.update(plotting_dict)\n    plot_dubins_car_disjoint(results, problem.settings).show()\n</code></pre>"},{"location":"examples/car/dubins_car_stljax/","title":"Dubins Car Stljax","text":"<p>Dubins car with Signal Temporal Logic (STL) constraints using stljax.</p> <p>This example demonstrates a Dubins car with temporal logic specifications using the stljax library for STL constraint formulation. The problem includes:</p> <ul> <li>2D position and heading dynamics with time state</li> <li>STL specification for waypoint visiting (visit wp1 OR wp2)</li> <li>Temporal constraints on when waypoints must be visited</li> <li>Integration with stljax library for formal specifications</li> <li>Requires: pip install stljax</li> </ul> <p>File: <code>examples/car/dubins_car_stljax.py</code></p> <pre><code>import jax.numpy as jnp\nimport numpy as np\n\nimport openscvx as ox\nfrom examples.plotting import plot_dubins_car_disjoint\nfrom openscvx import Problem\n\n# NOTE: This example requires the 'stljax' package.\n# You can install it via pip:\n#     pip install stljax\nn = 8\ntotal_time = 6.0  # Total simulation time\n\n# Define state components\nposition = ox.State(\"position\", shape=(2,))  # 2D position [x, y]\nposition.min = np.array([-5.0, -5.0])\nposition.max = np.array([5.0, 5.0])\nposition.initial = np.array([0, -2])\nposition.final = np.array([0, 2])\nposition.guess = np.linspace(position.initial, position.final, n)\n\ntheta = ox.State(\"theta\", shape=(1,))  # Heading angle\ntheta.min = np.array([-2 * jnp.pi])\ntheta.max = np.array([2 * jnp.pi])\ntheta.initial = np.array([0])\ntheta.final = [(\"free\", 0)]\ntheta.guess = np.zeros((n, 1))\n\n# Define control components\nspeed = ox.Control(\"speed\", shape=(1,))  # Forward speed\nspeed.min = np.array([0])\nspeed.max = np.array([10])\nspeed.guess = np.zeros((n, 1))\n\nangular_rate = ox.Control(\"angular_rate\", shape=(1,))  # Angular velocity\nangular_rate.min = np.array([-5])\nangular_rate.max = np.array([5])\nangular_rate.guess = np.zeros((n, 1))\n\n# Define time state (needed for time-dependent constraints)\ntime = ox.State(\"time\", shape=(1,))\ntime.max = np.array([10])\ntime.min = np.array([0.0])\ntime.initial = np.array([0.0])\ntime.final = [ox.Minimize(total_time)]\ntime.guess = np.linspace(0.0, total_time, n).reshape(-1, 1)\n\n\n# Define list of all states and controls\nstates = [position, theta, time]\ncontrols = [speed, angular_rate]\n# Define Parameters for wp radius and center\nwp1_center = ox.Parameter(\"wp1_center\", shape=(2,), value=np.array([-2.1, 0.0]))\nwp1_radius = ox.Parameter(\"wp1_radius\", shape=(), value=0.5)\nwp2_center = ox.Parameter(\"wp2_center\", shape=(2,), value=np.array([2.09999, 0.0]))\nwp2_radius = ox.Parameter(\"wp2_radius\", shape=(), value=0.5)\n\n\n# Define dynamics as dictionary mapping state names to their derivatives\ndynamics = {\n    \"position\": ox.Concat(\n        speed[0] * ox.Sin(theta[0]),  # x_dot\n        speed[0] * ox.Cos(theta[0]),  # y_dot\n    ),\n    \"theta\": angular_rate[0],\n    \"time\": 1.0,\n}\n\n# Create symbolic expressions for waypoint predicates\nwp1_pred = wp1_radius - ox.linalg.Norm(position - wp1_center)\nwp2_pred = wp2_radius - ox.linalg.Norm(position - wp2_center)\n\n# Create symbolic OR expression using the new Or node\nvisit_wp_or_expr = ox.stl.Or(wp1_pred, wp2_pred)\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Visit waypoint constraints using symbolic Or\nconstraints.append(ox.ctcs(-visit_wp_or_expr &lt;= 0.0).over((3, 5)))\n\n# Build the problem\ntime_config = ox.Time(\n    initial=0.0,\n    final=total_time,\n    min=0.0,\n    max=10,\n)\n\nconstraints.append((time.at(5) - time.at(3) == 1.23).convex())\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time_config,\n    constraints=constraints,\n    N=n,\n)\n# Set solver parameters\nproblem.settings.prp.dt = 0.01\nproblem.settings.scp.w_tr_adapt = 1.1\nproblem.settings.scp.w_tr = 1e0\nproblem.settings.scp.lam_cost = 1e-1\nproblem.settings.scp.lam_vc = 6e2\nproblem.settings.scp.uniform_time_grid = True\n# Extract parameter values from problem.parameters (not Parameter objects)\nplotting_dict = {\n    \"wp1_center\": problem.parameters.get(\"wp1_center\", None),\n    \"wp1_radius\": problem.parameters.get(\"wp1_radius\", None),\n    \"wp2_center\": problem.parameters.get(\"wp2_center\", None),\n    \"wp2_radius\": problem.parameters.get(\"wp2_radius\", None),\n}\n\n# Only add waypoints that are actually defined\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n    results.update(plotting_dict)\n    plot_dubins_car_disjoint(results, problem.settings).show()\n</code></pre>"},{"location":"examples/drone/cinema_vp/","title":"Cinema Vp","text":"<p>Cinematic viewpoint planning for aerial filming.</p> <p>This example demonstrates optimal trajectory planning for a quadrotor performing aerial cinematography with viewpoint constraints. The problem includes:</p> <ul> <li>6-DOF dynamics with fuel consumption tracking</li> <li>Continuous field-of-view (FOV) constraints to keep moving target in view</li> <li>Sensor pointing constraints using camera cone geometry</li> <li>Fuel-optimal trajectory generation</li> <li>Attitude planning to maintain visual coverage</li> </ul> <p>File: <code>examples/drone/cinema_vp.py</code></p> <pre><code>import jax.numpy as jnp\nimport numpy as np\nimport numpy.linalg as la\n\nimport openscvx as ox\nfrom examples.plotting import plot_animation\nfrom openscvx import Problem\nfrom openscvx.utils import get_kp_pose\n\nn = 12  # Number of Nodes\ntotal_time = 40.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 100, 50])\nposition.min = np.array([-100.0, -100, -10])\nposition.initial = np.array([8.0, -0.2, 2.2])\nposition.final = [(\"free\", -10.0), (\"free\", 0), (\"free\", 2)]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nfuel = ox.State(\"fuel\", shape=(1,))  # Fuel consumption\nfuel.max = np.array([2000])\nfuel.min = np.array([0])\nfuel.initial = np.array([0])\nfuel.final = [(\"minimize\", 0)]\n\n# Define time state (needed for time-dependent constraints)\ntime = ox.State(\"time\", shape=(1,))\ntime.max = np.array([total_time])\ntime.min = np.array([0.0])\ntime.initial = np.array([0.0])\ntime.final = np.array([total_time])\ntime.guess = np.linspace(0.0, total_time, n).reshape(-1, 1)\n\n# Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\nthrust_force.guess = np.repeat(np.array([[0.0, 0, 10]]), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\ninit_pose = np.array([13.0, 0.0, 2.0])\nmin_range = 4.0\nmax_range = 16.0\n\n### View Planning Params ###\nn_subs = 1  # Number of Subjects\nalpha_x = 6.0  # Angle for the x-axis of Sensor Cone\nalpha_y = 8.0  # Angle for the y-axis of Sensor Cone\nA_cone = np.diag(\n    [\n        1 / np.tan(np.pi / alpha_x),\n        1 / np.tan(np.pi / alpha_y),\n        0,\n    ]\n)  # Conic Matrix in Sensor Frame\nc = jnp.array([0, 0, 1])  # Boresight Vector in Sensor Frame\nnorm_type = \"inf\"\nR_sb = jnp.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\n\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity, attitude, angular_velocity, fuel, time]\ncontrols = [thrust_force, torque]\n\n\n# Create symbolic dynamics\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\n# Concatenate all controls for fuel calculation\nall_controls = ox.Concat(thrust_force, torque)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n    + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv)\n    @ (torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity),\n    \"fuel\": ox.linalg.Norm(all_controls),\n    \"time\": 1.0,  # Real time derivative\n}\n\n\n# Symbolic implementation of get_kp_pose function\ndef get_kp_pose_symbolic(t_expr, init_pose):\n    loop_time = 40.0\n    loop_radius = 20.0\n\n    # Convert the trajectory parameters to symbolic constants\n    loop_time_const = loop_time\n    loop_radius_const = loop_radius\n    two_pi_const = 2 * np.pi\n    init_pose_const = init_pose\n    half_const = 0.5\n\n    # Compute symbolic trajectory: t_angle = t / loop_time * (2 * pi)\n    t_angle = t_expr / loop_time_const * two_pi_const\n\n    # x = loop_radius * sin(t_angle)\n    x_pos = loop_radius_const * ox.Sin(t_angle)\n\n    # y = x * cos(t_angle)\n    y_pos = x_pos * ox.Cos(t_angle)\n\n    # z = 0.5 * x * sin(t_angle)\n    z_pos = half_const * x_pos * ox.Sin(t_angle)\n\n    # Stack into position vector and add initial pose\n    kp_trajectory = ox.Concat(x_pos, y_pos, z_pos) + init_pose_const\n    return kp_trajectory\n\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Get the symbolic keypoint pose based on time\nkp_pose_symbolic = get_kp_pose_symbolic(time[0], init_pose)\n\n# View planning constraint using symbolic keypoint pose\np_s_s = R_sb @ ox.spatial.QDCM(attitude).T @ (kp_pose_symbolic - position)\nvp_constraint = np.sqrt(2e1) * (ox.linalg.Norm(A_cone @ p_s_s, ord=norm_type) - (c.T @ p_s_s))\n\n# Range constraints using symbolic keypoint pose\nmin_range_constraint = min_range - ox.linalg.Norm(kp_pose_symbolic - position)\nmax_range_constraint = ox.linalg.Norm(kp_pose_symbolic - position) - max_range\n\nconstraints.extend(\n    [\n        ox.ctcs(vp_constraint &lt;= 0.0),\n        ox.ctcs(min_range_constraint &lt;= 0.0),\n        ox.ctcs(max_range_constraint &lt;= 0.0),\n    ]\n)\n\n\n# Initialize initial guess (will be modified by symbolic trajectory)\n# Extract final values from tuples (position.final has free values, use their default guesses)\nposition_final_values = np.array(\n    [\n        position.final[0][1] if isinstance(position.final[0], tuple) else position.final[0],\n        position.final[1][1] if isinstance(position.final[1], tuple) else position.final[1],\n        position.final[2][1] if isinstance(position.final[2], tuple) else position.final[2],\n    ]\n)\nposition_bar = np.linspace(position.initial, position_final_values, n)\nvelocity_bar = np.zeros((n, 3))  # Velocity is free at final, start with zeros\nattitude_bar = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\nangular_velocity_bar = np.zeros((n, 3))\nfuel_bar = np.zeros((n, 1))  # Fuel starts at 0 and is minimized\n\n# Time guess for trajectory computation\ntime_bar = np.linspace(0, total_time, n)\n\n# Modify position to follow offset from keypoint trajectory\nposition_bar = get_kp_pose(time_bar, init_pose) + np.array([-5, 0.2, 0.2])\n\n# Modify attitude to point sensor at targets\nb = R_sb @ np.array([0, 1, 0])\nfor k in range(n):\n    kp = get_kp_pose(time_bar[k], init_pose)\n    a = kp - position_bar[k]\n    # Determine the direction cosine matrix that aligns the z-axis of the sensor frame with the\n    # relative position vector\n    q_xyz = np.cross(b, a)\n    q_w = np.sqrt(la.norm(a) ** 2 + la.norm(b) ** 2) + np.dot(a, b)\n    q_no_norm = np.hstack((q_w, q_xyz))\n    q = q_no_norm / la.norm(q_no_norm)\n    attitude_bar[k] = q\n\n# Set all guesses\nposition.guess = position_bar\nvelocity.guess = velocity_bar\nattitude.guess = attitude_bar\nangular_velocity.guess = angular_velocity_bar\nfuel.guess = fuel_bar\n\ntime_config = ox.Time(\n    initial=0.0,\n    final=total_time,\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time_config,\n    constraints=constraints,\n    N=n,\n    licq_max=1e-8,\n)\n\n\nproblem.settings.scp.w_tr = 4e0  # Weight on the Trust Reigon\nproblem.settings.scp.lam_cost = 1e-2  # Weight on the Minimal Fuel Objective\nproblem.settings.scp.lam_vc = 1e1  # Weight on the Virtual Control Objective\n\nproblem.settings.scp.ep_tr = 1e-6  # Trust Region Tolerance\nproblem.settings.scp.ep_vb = 1e-4  # Virtual Control Tolerance\nproblem.settings.scp.ep_vc = 1e-8  # Virtual Control Tolerance for CTCS\nproblem.settings.scp.w_tr_adapt = 1.3  # Trust Region Adaptation Factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e3  # Maximum Trust Region Weight\n\nplotting_dict = {\n    \"n_subs\": n_subs,\n    \"alpha_x\": alpha_x,\n    \"alpha_y\": alpha_y,\n    \"R_sb\": R_sb,\n    \"init_poses\": init_pose,\n    \"norm_type\": norm_type,\n    \"min_range\": min_range,\n    \"max_range\": max_range,\n    \"moving_subject\": True,\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update(plotting_dict)\n\n    plot_animation(results, problem.settings).show()\n</code></pre>"},{"location":"examples/drone/cinema_vp_realtime_base/","title":"Cinema Vp Realtime Base","text":"<p>Base problem setup for real-time cinematic viewpoint planning.</p> <p>This module defines the base optimization problem for real-time aerial cinematography, designed to be imported by interactive visualization examples. The problem includes:</p> <ul> <li>6-DOF dynamics with parametric target positions</li> <li>Field-of-view constraints for visual tracking</li> <li>Sensor cone constraints for camera pointing</li> <li>Configured for real-time re-optimization with moving targets</li> </ul> <p>File: <code>examples/drone/cinema_vp_realtime_base.py</code></p> <pre><code>import jax.numpy as jnp\nimport numpy as np\nimport numpy.linalg as la\n\nimport openscvx as ox\nfrom examples.plotting import plot_animation\nfrom openscvx import Problem\n\nn = 12  # Number of Nodes\ntotal_time = 40.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 100, 50])\nposition.min = np.array([-100.0, -100, -10])\nposition.initial = np.array([8.0, -0.2, 2.2])\nposition.final = [(\"free\", -10.0), (\"free\", 0), (\"free\", 2)]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nfuel = ox.State(\"fuel\", shape=(1,))  # Fuel consumption\nfuel.max = np.array([2000])\nfuel.min = np.array([0])\nfuel.initial = np.array([0])\nfuel.final = [(\"minimize\", 0)]\n\n# Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\nthrust_force.guess = np.repeat(np.array([[0.0, 0, 10]]), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n# Initial keypoint position (will be controlled by user in realtime)\ninitial_kp_pose = np.array([13.0, 0.0, 2.0])\nmin_range = 4.0\nmax_range = 16.0\n\n### View Planning Params ###\nn_subs = 1  # Number of Subjects\nalpha_x = 6.0  # Angle for the x-axis of Sensor Cone\nalpha_y = 8.0  # Angle for the y-axis of Sensor Cone\nA_cone = np.diag(\n    [\n        1 / np.tan(np.pi / alpha_x),\n        1 / np.tan(np.pi / alpha_y),\n        0,\n    ]\n)  # Conic Matrix in Sensor Frame\nc = jnp.array([0, 0, 1])  # Boresight Vector in Sensor Frame\nnorm_type = \"inf\"\nR_sb = jnp.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\n\n# Define keypoint position as a parameter (can be updated in realtime)\nkp_pose = ox.Parameter(\"kp_pose\", shape=(3,), value=initial_kp_pose)\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity, attitude, angular_velocity, fuel]\ncontrols = [thrust_force, torque]\n\n# Create symbolic dynamics\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\n# Concatenate all controls for fuel calculation\nall_controls = ox.Concat(thrust_force, torque)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n    + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv)\n    @ (torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity),\n    \"fuel\": ox.linalg.Norm(all_controls),\n}\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# View planning constraint using parameter keypoint pose\np_s_s = R_sb @ ox.spatial.QDCM(attitude).T @ (kp_pose - position)\nvp_constraint = np.sqrt(2e1) * (ox.linalg.Norm(A_cone @ p_s_s, ord=norm_type) - (c.T @ p_s_s))\n\n# Range constraints using parameter keypoint pose\nmin_range_constraint = min_range - ox.linalg.Norm(kp_pose - position)\nmax_range_constraint = ox.linalg.Norm(kp_pose - position) - max_range\n\nconstraints.extend(\n    [\n        ox.ctcs(vp_constraint &lt;= 0.0),\n        ox.ctcs(min_range_constraint &lt;= 0.0),\n        ox.ctcs(max_range_constraint &lt;= 0.0),\n    ]\n)\n\n# Initialize initial guess\nposition_final_values = np.array(\n    [\n        position.final[0][1] if isinstance(position.final[0], tuple) else position.final[0],\n        position.final[1][1] if isinstance(position.final[1], tuple) else position.final[1],\n        position.final[2][1] if isinstance(position.final[2], tuple) else position.final[2],\n    ]\n)\nposition_bar = np.linspace(position.initial, position_final_values, n)\nvelocity_bar = np.zeros((n, 3))\nattitude_bar = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\nangular_velocity_bar = np.zeros((n, 3))\nfuel_bar = np.zeros((n, 1))\n\n# Modify position to follow offset from keypoint\n# Create array of positions, all offset from keypoint\noffset = np.array([-5, 0.2, 0.2])\nposition_bar = np.tile(initial_kp_pose + offset, (n, 1))\n\n# Modify attitude to point sensor at keypoint\nb = R_sb @ np.array([0, 1, 0])\nfor k in range(n):\n    a = initial_kp_pose - position_bar[k]\n    # Determine the direction cosine matrix that aligns the z-axis of the sensor frame with the\n    # relative position vector\n    q_xyz = np.cross(b, a)\n    q_w = np.sqrt(la.norm(a) ** 2 + la.norm(b) ** 2) + np.dot(a, b)\n    q_no_norm = np.hstack((q_w, q_xyz))\n    q = q_no_norm / la.norm(q_no_norm)\n    attitude_bar[k] = q\n\n# Set all guesses\nposition.guess = position_bar\nvelocity.guess = velocity_bar\nattitude.guess = attitude_bar\nangular_velocity.guess = angular_velocity_bar\nfuel.guess = fuel_bar\n\ntime_config = ox.Time(\n    initial=0.0,\n    final=total_time,\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time_config,\n    constraints=constraints,\n    N=n,\n    licq_max=1e-8,\n)\n\nproblem.settings.scp.w_tr = 4e0  # Weight on the Trust Region\nproblem.settings.scp.lam_cost = 1e-2  # Weight on the Minimal Fuel Objective\nproblem.settings.scp.lam_vc = 1e1  # Weight on the Virtual Control Objective\n\nproblem.settings.scp.ep_tr = 1e-6  # Trust Region Tolerance\nproblem.settings.scp.ep_vb = 1e-4  # Virtual Control Tolerance\nproblem.settings.scp.ep_vc = 1e-8  # Virtual Control Tolerance for CTCS\nproblem.settings.scp.w_tr_adapt = 1.3  # Trust Region Adaptation Factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e3  # Maximum Trust Region Weight\n\nplotting_dict = {\n    \"n_subs\": n_subs,\n    \"alpha_x\": alpha_x,\n    \"alpha_y\": alpha_y,\n    \"R_sb\": R_sb,\n    \"init_poses\": initial_kp_pose,\n    \"norm_type\": norm_type,\n    \"min_range\": min_range,\n    \"max_range\": max_range,\n    \"moving_subject\": False,  # Not moving in realtime version\n    \"kp_pose\": kp_pose,\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update(plotting_dict)\n\n    plot_animation(results, problem.settings).show()\n</code></pre>"},{"location":"examples/drone/dr_double_integrator/","title":"Dr Double Integrator","text":"<p>Simplified drone racing using double integrator dynamics.</p> <p>This example demonstrates time-optimal racing through gates using simplified double integrator (point mass) dynamics instead of full 6-DOF dynamics. The problem includes:</p> <ul> <li>3-DOF point mass dynamics (position and velocity only)</li> <li>Direct force control inputs (no attitude dynamics)</li> <li>Sequential gate passage constraints</li> <li>Minimal time objective</li> <li>Loop closure constraint</li> </ul> <p>File: <code>examples/drone/dr_double_integrator.py</code></p> <pre><code>import jax.numpy as jnp\nimport numpy as np\n\nimport openscvx as ox\nfrom examples.plotting import plot_animation_double_integrator\nfrom openscvx import Problem\nfrom openscvx.utils import gen_vertices, rot\n\nn = 22  # Number of Nodes\ntotal_time = 24.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 100, 50])\nposition.min = np.array([-200.0, -100, 15])\nposition.initial = np.array([10.0, 0, 20])\nposition.final = [10.0, 0, 20]\nposition.guess = np.linspace(position.initial, position.final, n)\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nvelocity.guess = np.linspace(velocity.initial, [0, 0, 0], n)\n\n# Define control\nforce = ox.Control(\"force\", shape=(3,))  # Control forces [fx, fy, fz]\nf_max = 4.179446268 * 9.81\nforce.max = np.array([f_max, f_max, f_max])\nforce.min = np.array([-f_max, -f_max, -f_max])\ninitial_control = np.array([0.0, 0, 10])\nforce.guess = np.repeat(initial_control[np.newaxis, :], n, axis=0)\n\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n\n### Gate Parameters ###\nn_gates = 10\ngate_centers = [\n    np.array([59.436, 0.000, 20.0000]),\n    np.array([92.964, -23.750, 25.5240]),\n    np.array([92.964, -29.274, 20.0000]),\n    np.array([92.964, -23.750, 20.0000]),\n    np.array([130.150, -23.750, 20.0000]),\n    np.array([152.400, -73.152, 20.0000]),\n    np.array([92.964, -75.080, 20.0000]),\n    np.array([92.964, -68.556, 20.0000]),\n    np.array([59.436, -81.358, 20.0000]),\n    np.array([22.250, -42.672, 20.0000]),\n]\n\nradii = np.array([2.5, 1e-4, 2.5])\nA_gate = rot @ np.diag(1 / radii) @ rot.T\nA_gate_cen = []\nfor center in gate_centers:\n    center[0] = center[0] + 2.5\n    center[2] = center[2] + 2.5\n    A_gate_cen.append(A_gate @ center)\nnodes_per_gate = 2\ngate_nodes = np.arange(nodes_per_gate, n, nodes_per_gate)\nvertices = []\nfor center in gate_centers:\n    vertices.append(gen_vertices(center, radii))\n### End Gate Parameters ###\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity]\ncontrols = [force]\n\n# Generate box constraints for all states\nconstraint_exprs = []\nfor state in states:\n    constraint_exprs.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add gate constraints\nfor node, cen in zip(gate_nodes, A_gate_cen):\n    A_gate_const = A_gate\n    c_const = cen\n    gate_constraint = (\n        (ox.linalg.Norm(A_gate_const @ position - c_const, ord=\"inf\") &lt;= np.array([1.0]))\n        .convex()\n        .at([node])\n    )\n    constraint_exprs.append(gate_constraint)\n\n\n# Define dynamics as dictionary mapping state names to their derivatives\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1 / m) * force + np.array([0, 0, g_const], dtype=np.float64),\n}\n\n\nposition_bar = np.linspace(position.initial, position.final, n)\n\ni = 0\norigins = [position.initial]\nends = []\nfor center in gate_centers:\n    origins.append(center)\n    ends.append(center)\nends.append(position.final)\ngate_idx = 0\nfor _ in range(n_gates + 1):\n    for k in range(n // (n_gates + 1)):\n        position_bar[i] = origins[gate_idx] + (k / (n // (n_gates + 1))) * (\n            ends[gate_idx] - origins[gate_idx]\n        )\n        i += 1\n    gate_idx += 1\n\nposition.guess = position_bar\n\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraint_exprs,\n    N=n,\n)\n\nproblem.settings.prp.dt = 0.01\nproblem.settings.dis.custom_integrator = True\n\nproblem.settings.scp.w_tr = 2e0  # Weight on the Trust Reigon\nproblem.settings.scp.lam_cost = 1e-1  # 0e-1,  # Weight on the Minimal Time Objective\nproblem.settings.scp.lam_vc = (\n    1e1  # 1e1,  # Weight on the Virtual Control Objective (not including CTCS Augmentation)\n)\nproblem.settings.scp.ep_tr = 1e-3  # Trust Region Tolerance\nproblem.settings.scp.ep_vb = 1e-4  # Virtual Control Tolerance\nproblem.settings.scp.ep_vc = 1e-8  # Virtual Control Tolerance for CTCS\nproblem.settings.scp.cost_drop = 10  # SCP iteration to relax minimal final time objective\nproblem.settings.scp.cost_relax = 0.8  # Minimal Time Relaxation Factor\nproblem.settings.scp.w_tr_adapt = 1.4  # Trust Region Adaptation Factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e2  # Maximum Trust Region Weight\n\nplotting_dict = {\"vertices\": vertices}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update(plotting_dict)\n\n    plot_animation_double_integrator(results, problem.settings).show()\n</code></pre>"},{"location":"examples/drone/dr_vp/","title":"Dr Vp","text":"<p>Drone racing with continuous viewpoint constraints.</p> <p>This example combines drone racing through gates with camera viewpoint constraints to maintain visual contact with reference targets. The problem includes:</p> <ul> <li>6-DOF rigid body dynamics (position, velocity, attitude quaternion, angular velocity)</li> <li>Sequential gate passage constraints</li> <li>Attitude planning for simultaneous gate navigation and visual tracking</li> <li>Continuous sensor visibility constraints to keep targets in FOV</li> <li>Minimal time objective</li> </ul> <p>File: <code>examples/drone/dr_vp.py</code></p> <pre><code>import jax.numpy as jnp\nimport numpy as np\nimport numpy.linalg as la\n\nimport openscvx as ox\nfrom examples.plotting import plot_animation\nfrom openscvx import Problem\nfrom openscvx.utils import gen_vertices, rot\n\nn = 33  # Number of Nodes\ntotal_time = 40.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 100, 50])\nposition.min = np.array([-200.0, -100, 15])\nposition.initial = np.array([10.0, 0, 20])\nposition.final = [10.0, 0, 20]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\nthrust_force.guess = np.repeat(np.array([[0.0, 0, 10]]), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n\n### Sensor Params ###\nalpha_x = 6.0  # Angle for the x-axis of Sensor Cone\nalpha_y = 6.0  # Angle for the y-axis of Sensor Cone\nA_cone = np.diag(\n    [\n        1 / np.tan(np.pi / alpha_x),\n        1 / np.tan(np.pi / alpha_y),\n        0,\n    ]\n)  # Conic Matrix in Sensor Frame\nc = jnp.array([0, 0, 1])  # Boresight Vector in Sensor Frame\nnorm_type = 2  # Norm Type\nR_sb = jnp.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\n### End Sensor Params ###\n\n\n### Gate Parameters ###\nn_gates = 10\ngate_centers = [\n    np.array([59.436, 0.0000, 20.0000]),\n    np.array([92.964, -23.750, 25.5240]),\n    np.array([92.964, -29.274, 20.0000]),\n    np.array([92.964, -23.750, 20.0000]),\n    np.array([130.150, -23.750, 20.0000]),\n    np.array([152.400, -73.152, 20.0000]),\n    np.array([92.964, -75.080, 20.0000]),\n    np.array([92.964, -68.556, 20.0000]),\n    np.array([59.436, -81.358, 20.0000]),\n    np.array([22.250, -42.672, 20.0000]),\n]\n\nradii = np.array([2.5, 1e-4, 2.5])\nA_gate = rot @ np.diag(1 / radii) @ rot.T\nA_gate_cen = []\nfor center in gate_centers:\n    center[0] = center[0] + 2.5\n    center[2] = center[2] + 2.5\n    A_gate_cen.append(A_gate @ center)\nnodes_per_gate = 3\ngate_nodes = np.arange(nodes_per_gate, n, nodes_per_gate)\nvertices = []\nfor center in gate_centers:\n    vertices.append(gen_vertices(center, radii))\n### End Gate Parameters ###\n\nn_subs = 10\ninit_poses = []\nnp.random.seed(0)\nfor i in range(n_subs):\n    init_pose = np.array([100.0, -60.0, 20.0])\n    init_pose[:2] = init_pose[:2] + np.random.random(2) * 20.0\n    init_poses.append(init_pose)\n\ninit_poses = init_poses\n\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity, attitude, angular_velocity]\ncontrols = [thrust_force, torque]\n\n\n# Symbolic sensor visibility constraint function\ndef g_vp(p_s_I, x_pos, x_quat):\n    p_s_s = R_sb @ ox.spatial.QDCM(x_quat).T @ (p_s_I - x_pos)\n    return ox.linalg.Norm(A_cone @ p_s_s, ord=norm_type) - (c.T @ p_s_s)\n\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add visibility constraints using symbolic expressions\nfor pose in init_poses:\n    constraints.append(ox.ctcs(g_vp(pose, position, attitude) &lt;= 0.0))\n\n# Add gate constraints using symbolic expressions\nfor node, cen in zip(gate_nodes, A_gate_cen):\n    A_gate_const = A_gate\n    cen_const = cen\n\n    # Gate constraint: ||A @ pos - c||_inf &lt;= 1\n    gate_constraint = (\n        (ox.linalg.Norm(A_gate_const @ position - cen_const, ord=\"inf\") &lt;= 1.0).convex().at([node])\n    )\n    constraints.append(gate_constraint)\n\n\n# Create symbolic dynamics\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n    + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv)\n    @ (torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity),\n}\n\n\n# Initialize initial guess (will be modified by gate logic)\nposition_bar = np.linspace(position.initial, position.final, n)\nvelocity_bar = np.zeros((n, 3))\nattitude_bar = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\nangular_velocity_bar = np.zeros((n, 3))\n\n# Modify position to go through gates\ni = 0\norigins = [position.initial]\nends = []\nfor center in gate_centers:\n    origins.append(center)\n    ends.append(center)\nends.append(position.final)\ngate_idx = 0\nfor _ in range(n_gates + 1):\n    for k in range(n // (n_gates + 1)):\n        position_bar[i] = origins[gate_idx] + (k / (n // (n_gates + 1))) * (\n            ends[gate_idx] - origins[gate_idx]\n        )\n        i += 1\n    gate_idx += 1\n\n# Modify attitude to point sensor at targets\nR_sb = R_sb  # Sensor to body frame\nb = R_sb @ np.array([0, 1, 0])\nfor k in range(n):\n    kp = []\n    for pose in init_poses:\n        kp.append(pose)\n    kp = np.mean(kp, axis=0)\n    a = kp - position_bar[k]\n    # Determine the direction cosine matrix that aligns the z-axis of the sensor frame with the\n    # relative position vector\n    q_xyz = np.cross(b, a)\n    q_w = np.sqrt(la.norm(a) ** 2 + la.norm(b) ** 2) + np.dot(a, b)\n    q_no_norm = np.hstack((q_w, q_xyz))\n    q = q_no_norm / la.norm(q_no_norm)\n    attitude_bar[k] = q\n\n# Set all guesses\nposition.guess = position_bar\nvelocity.guess = velocity_bar\nattitude.guess = attitude_bar\nangular_velocity.guess = angular_velocity_bar\n\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n\nproblem.settings.prp.dt = 0.1\n\n\nproblem.settings.scp.w_tr = 2e0  # Weight on the Trust Reigon\nproblem.settings.scp.lam_cost = 1e-1  # 0e-1,  # Weight on the Minimal Time Objective\nproblem.settings.scp.lam_vc = (\n    1e2  # 1e1,  # Weight on the Virtual Control Objective (not including CTCS Augmentation)\n)\nproblem.settings.scp.ep_tr = 1e-3  # Trust Region Tolerance\nproblem.settings.scp.ep_vb = 1e-4  # Virtual Control Tolerance\nproblem.settings.scp.ep_vc = 1e-8  # Virtual Control Tolerance\nproblem.settings.scp.cost_drop = 10  # SCP iteration to relax minimal final time objective\nproblem.settings.scp.cost_relax = 0.8  # Minimal Time Relaxation Factor\nproblem.settings.scp.w_tr_adapt = 1.4  # Trust Region Adaptation Factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e2  # Maximum Trust Region Weight\n\nplotting_dict = {\n    \"vertices\": vertices,\n    \"n_subs\": n_subs,\n    \"alpha_x\": alpha_x,\n    \"alpha_y\": alpha_y,\n    \"R_sb\": R_sb,\n    \"init_poses\": init_poses,\n    \"norm_type\": norm_type,\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update(plotting_dict)\n\n    plot_animation(results, problem.settings).show()\n    # plot_animation_pyqtgraph(results, problem.settings)\n</code></pre>"},{"location":"examples/drone/dr_vp_nodal/","title":"Dr Vp Nodal","text":"<p>Drone racing with nodal viewpoint constraints.</p> <p>This example demonstrates drone racing through gates with sensor visibility constraints applied at all nodes. The problem includes:</p> <ul> <li>6-DOF rigid-body dynamics (position, velocity, attitude quaternion, angular velocity)</li> <li>Sequential gate passage constraints</li> <li>Attitude planning for simultaneous gate navigation and visual tracking</li> <li>Nodal sensor visibility constraints throughout trajectory</li> <li>Minimal time objective</li> </ul> <p>File: <code>examples/drone/dr_vp_nodal.py</code></p> <pre><code>import jax.numpy as jnp\nimport numpy as np\nimport numpy.linalg as la\n\nimport openscvx as ox\nfrom examples.plotting import plot_animation\nfrom openscvx import Problem\nfrom openscvx.utils import gen_vertices, rot\n\nn = 33  # Number of Nodes\ntotal_time = 30.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 100, 50])\nposition.min = np.array([-200.0, -100, 15])\nposition.initial = np.array([10.0, 0, 20])\nposition.final = [10.0, 0, 20]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\nthrust_force.guess = np.repeat(np.array([[0.0, 0, 10]]), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n\n### Sensor Params ###\nalpha_x = 4.0  # Angle for the x-axis of Sensor Cone\nalpha_y = 4.0  # Angle for the y-axis of Sensor Cone\nA_cone = np.diag(\n    [\n        1 / np.tan(np.pi / alpha_x),\n        1 / np.tan(np.pi / alpha_y),\n        0,\n    ]\n)  # Conic Matrix in Sensor Frame\nc = jnp.array([0, 0, 1])  # Boresight Vector in Sensor Frame\nnorm_type = 2  # Norm Type\nR_sb = jnp.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\n### End Sensor Params ###\n\n\n### Gate Parameters ###\nn_gates = 10\ngate_centers = [\n    np.array([59.436, 0.0000, 20.0000]),\n    np.array([92.964, -23.750, 25.5240]),\n    np.array([92.964, -29.274, 20.0000]),\n    np.array([92.964, -23.750, 20.0000]),\n    np.array([130.150, -23.750, 20.0000]),\n    np.array([152.400, -73.152, 20.0000]),\n    np.array([92.964, -75.080, 20.0000]),\n    np.array([92.964, -68.556, 20.0000]),\n    np.array([59.436, -81.358, 20.0000]),\n    np.array([22.250, -42.672, 20.0000]),\n]\n\nradii = np.array([2.5, 1e-4, 2.5])\nA_gate = rot @ np.diag(1 / radii) @ rot.T\nA_gate_cen = []\nfor center in gate_centers:\n    center[0] = center[0] + 2.5\n    center[2] = center[2] + 2.5\n    A_gate_cen.append(A_gate @ center)\nnodes_per_gate = 3\ngate_nodes = np.arange(nodes_per_gate, n, nodes_per_gate)\nvertices = []\nfor center in gate_centers:\n    vertices.append(gen_vertices(center, radii))\n### End Gate Parameters ###\n\nn_subs = 10\ninit_poses = []\nnp.random.seed(5)\nfor i in range(n_subs):\n    init_pose = np.array([100.0, -70.0, 20.0])\n    init_pose[:2] = init_pose[:2] + np.random.random(2) * 20.0\n    init_poses.append(init_pose)\n\ninit_poses = init_poses\n\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity, attitude, angular_velocity]\ncontrols = [thrust_force, torque]\n\n\n# Symbolic sensor visibility constraint function\ndef g_vp(p_s_I, x_pos, x_quat):\n    p_s_s = R_sb @ ox.spatial.QDCM(x_quat).T @ (p_s_I - x_pos)\n    return ox.linalg.Norm(A_cone @ p_s_s, ord=norm_type) - (c.T @ p_s_s)\n\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add visibility constraints using symbolic expressions\nfor pose in init_poses:\n    constraints.append((g_vp(pose, position, attitude) &lt;= 0.0))\n\n# Add gate constraints using symbolic expressions\nfor node, cen in zip(gate_nodes, A_gate_cen):\n    A_gate_const = A_gate\n    cen_const = cen\n\n    # Gate constraint: ||A @ pos - c||_inf &lt;= 1\n    gate_constraint = (\n        (ox.linalg.Norm(A_gate_const @ position - cen_const, ord=\"inf\") &lt;= 1.0).convex().at([node])\n    )\n    constraints.append(gate_constraint)\n\n\n# Define dynamics\nm = 1.0  # Mass of the drone\ng_const = -9.81\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n    + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv)\n    @ (torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity),\n}\n\n\n# Initialize initial guess (will be modified by gate logic)\nposition_bar = np.linspace(position.initial, position.final, n)\nvelocity_bar = np.zeros((n, 3))\nattitude_bar = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\nangular_velocity_bar = np.zeros((n, 3))\n\n# Modify position to go through gates\ni = 0\norigins = [position.initial]\nends = []\nfor center in gate_centers:\n    origins.append(center)\n    ends.append(center)\nends.append(position.final)\ngate_idx = 0\nfor _ in range(n_gates + 1):\n    for k in range(n // (n_gates + 1)):\n        position_bar[i] = origins[gate_idx] + (k / (n // (n_gates + 1))) * (\n            ends[gate_idx] - origins[gate_idx]\n        )\n        i += 1\n    gate_idx += 1\n\n# Modify attitude to point sensor at targets\nR_sb = R_sb  # Sensor to body frame\nb = R_sb @ np.array([0, 1, 0])\nfor k in range(n):\n    kp = []\n    for pose in init_poses:\n        kp.append(pose)\n    kp = np.mean(kp, axis=0)\n    a = kp - position_bar[k]\n    # Determine the direction cosine matrix that aligns the z-axis of the sensor frame with the\n    # relative position vector\n    q_xyz = np.cross(b, a)\n    q_w = np.sqrt(la.norm(a) ** 2 + la.norm(b) ** 2) + np.dot(a, b)\n    q_no_norm = np.hstack((q_w, q_xyz))\n    q = q_no_norm / la.norm(q_no_norm)\n    attitude_bar[k] = q\n\n# Set all guesses\nposition.guess = position_bar\nvelocity.guess = velocity_bar\nattitude.guess = attitude_bar\nangular_velocity.guess = angular_velocity_bar\n\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n\nproblem.settings.prp.dt = 0.1\n\nproblem.settings.scp.w_tr = 8e1  # Weight on the Trust Reigon\nproblem.settings.scp.lam_cost = 2e1  # Weight on the Minimal Time Objective\nproblem.settings.scp.lam_vc = (\n    1e2  # Weight on the Virtual Control Objective (not including CTCS Augmentation)\n)\nproblem.settings.scp.lam_vb = (\n    4e0  # Weight on the Virtual Control Objective (not including CTCS Augmentation)\n)\nproblem.settings.scp.ep_tr = 1e-3  # Trust Region Tolerance\nproblem.settings.scp.ep_vb = 1e-4  # Virtual Control Tolerance\nproblem.settings.scp.ep_vc = 1e-8  # Virtual Control Tolerance\nproblem.settings.scp.cost_drop = 10  # SCP iteration to relax minimal final time objective\nproblem.settings.scp.cost_relax = 0.8  # Minimal Time Relaxation Factor\nproblem.settings.scp.w_tr_adapt = 1.05  # Trust Region Adaptation Factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e2  # Maximum Trust Region Weight\n\nplotting_dict = {\n    \"vertices\": vertices,\n    \"n_subs\": n_subs,\n    \"alpha_x\": alpha_x,\n    \"alpha_y\": alpha_y,\n    \"R_sb\": R_sb,\n    \"init_poses\": init_poses,\n    \"norm_type\": norm_type,\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update_plotting_data(**plotting_dict)\n\n    plot_animation(results, problem.settings).show()\n</code></pre>"},{"location":"examples/drone/dr_vp_polytope/","title":"Dr Vp Polytope","text":"<p>Drone racing with continuous viewpoint constraints using polytope target arrangement.</p> <p>This example demonstrates drone racing through polytope (polyhedron-shaped) gates with sensor visibility constraints. The problem includes:</p> <ul> <li>6-DOF rigid body dynamics (position, velocity, attitude quaternion, angular velocity)</li> <li>Sequential gate passage constraints</li> <li>Attitude planning for simultaneous gate navigation and visual tracking</li> <li>Continuous sensor visibility constraints to keep targets in FOV</li> <li>Viewplanning targets are arranged in a polytope</li> <li>Minimal time objective</li> </ul> <p>File: <code>examples/drone/dr_vp_polytope.py</code></p> <pre><code>import jax.numpy as jnp\nimport numpy as np\nimport numpy.linalg as la\n\nimport openscvx as ox\nfrom examples.plotting import plot_animation\nfrom openscvx import Problem\nfrom openscvx.utils import gen_vertices, rot\n\nn = 33  # Number of Nodes\ntotal_time = 30.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 100, 50])\nposition.min = np.array([-200.0, -100, 15])\nposition.initial = np.array([10.0, 0, 20])\nposition.final = [10.0, 0, 20]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\nthrust_force.guess = np.repeat(np.array([[0.0, 0, 10]]), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n\n### Sensor Params ###\nalpha_x = 6.0  # Angle for the x-axis of Sensor Cone\nalpha_y = 6.0  # Angle for the y-axis of Sensor Cone\nA_cone = np.diag(\n    [\n        1 / np.tan(np.pi / alpha_x),\n        1 / np.tan(np.pi / alpha_y),\n        0,\n    ]\n)  # Conic Matrix in Sensor Frame\nc = jnp.array([0, 0, 1])  # Boresight Vector in Sensor Frame\nnorm_type = 2  # Norm Type\nR_sb = jnp.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\n### End Sensor Params ###\n\nn_subs = 10\npolytope_point = np.array(\n    [\n        [95.38, -54.62, 15.38],\n        [95.38, -54.62, 24.62],\n        [95.38, -45.38, 15.38],\n        [95.38, -45.38, 24.62],\n        [104.62, -54.62, 15.38],\n        [104.62, -54.62, 24.62],\n        [104.62, -45.38, 15.38],\n        [104.62, -45.38, 24.62],\n        [100.00, -52.85, 12.53],\n        [100.00, -52.85, 27.47],\n        [100.00, -47.15, 12.53],\n        [100.00, -47.15, 27.47],\n        [97.15, -57.47, 20.00],\n        [97.15, -42.53, 20.00],\n        [102.85, -57.47, 20.00],\n        [102.85, -42.53, 20.00],\n        [92.53, -50.00, 17.15],\n        [92.53, -50.00, 22.85],\n        [107.47, -50.00, 17.15],\n        [107.47, -50.00, 22.85],\n    ]\n)\ninit_poses = []\nfor point in polytope_point:\n    init_poses.append(point)\ninit_poses = init_poses\n### Gate Parameters ###\nn_gates = 10\ngate_centers = [\n    np.array([59.436, 0.0000, 20.0000]),\n    np.array([92.964, -23.750, 25.5240]),\n    np.array([92.964, -29.274, 20.0000]),\n    np.array([92.964, -23.750, 20.0000]),\n    np.array([130.150, -23.750, 20.0000]),\n    np.array([152.400, -73.152, 20.0000]),\n    np.array([92.964, -75.080, 20.0000]),\n    np.array([92.964, -68.556, 20.0000]),\n    np.array([59.436, -81.358, 20.0000]),\n    np.array([22.250, -42.672, 20.0000]),\n]\nradii = np.array([2.5, 1e-4, 2.5])\nA_gate = rot @ np.diag(1 / radii) @ rot.T\nA_gate_cen = []\nfor center in gate_centers:\n    center[0] = center[0] + 2.5\n    center[2] = center[2] + 2.5\n    A_gate_cen.append(A_gate @ center)\nnodes_per_gate = 3\ngate_nodes = np.arange(nodes_per_gate, n, nodes_per_gate)\nvertices = []\nfor center in gate_centers:\n    vertices.append(gen_vertices(center, radii))\n\n\n### End Gate Parameters ###\n\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity, attitude, angular_velocity]\ncontrols = [thrust_force, torque]\n\n\n# Symbolic sensor visibility constraint function\ndef g_vp(p_s_I, x_pos, x_quat):\n    p_s_s = R_sb @ ox.spatial.QDCM(x_quat).T @ (p_s_I - x_pos)\n    return ox.linalg.Norm(A_cone @ p_s_s, ord=norm_type) - (c.T @ p_s_s)\n\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add visibility constraints for polytope points using symbolic expressions\nfor pose in init_poses:\n    constraints.append(ox.ctcs(g_vp(pose, position, attitude) &lt;= 0.0))\n\n# Add gate constraints using symbolic expressions\nfor node, cen in zip(gate_nodes, A_gate_cen):\n    A_gate_const = A_gate\n    cen_const = cen\n\n    # Gate constraint: ||A @ pos - c||_inf &lt;= 1\n    gate_constraint = (\n        (ox.linalg.Norm(A_gate_const @ position - cen_const, ord=\"inf\") &lt;= 1.0).convex().at([node])\n    )\n    constraints.append(gate_constraint)\n\n\n# Create symbolic dynamics\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n    + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv)\n    @ (torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity),\n}\n\n\n# Initialize initial guess (will be modified by gate logic)\nposition_bar = np.linspace(position.initial, position.final, n)\nvelocity_bar = np.zeros((n, 3))\nattitude_bar = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\nangular_velocity_bar = np.zeros((n, 3))\n\n# Modify position to go through gates\ni = 0\norigins = [position.initial]\nends = []\nfor center in gate_centers:\n    origins.append(center)\n    ends.append(center)\nends.append(position.final)\ngate_idx = 0\nfor _ in range(n_gates + 1):\n    for k in range(n // (n_gates + 1)):\n        position_bar[i] = origins[gate_idx] + (k / (n // (n_gates + 1))) * (\n            ends[gate_idx] - origins[gate_idx]\n        )\n        i += 1\n    gate_idx += 1\n\n# Modify attitude to point sensor at targets\nR_sb = R_sb  # Sensor to body frame\nb = R_sb @ np.array([0, 1, 0])\nfor k in range(n):\n    kp = []\n    for pose in init_poses:\n        kp.append(pose)\n    kp = np.mean(kp, axis=0)\n    a = kp - position_bar[k]\n    # Determine the direction cosine matrix that aligns the z-axis of the sensor frame with the\n    # relative position vector\n    q_xyz = np.cross(b, a)\n    q_w = np.sqrt(la.norm(a) ** 2 + la.norm(b) ** 2) + np.dot(a, b)\n    q_no_norm = np.hstack((q_w, q_xyz))\n    q = q_no_norm / la.norm(q_no_norm)\n    attitude_bar[k] = q\n\n# Set all guesses\nposition.guess = position_bar\nvelocity.guess = velocity_bar\nattitude.guess = attitude_bar\nangular_velocity.guess = angular_velocity_bar\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n\nproblem.settings.prp.dt = 0.01\n\nproblem.settings.scp.k_max = 50\nproblem.settings.scp.w_tr = 2e0  # 2e0,  # Weight on the Trust Reigon\nproblem.settings.scp.lam_cost = 2e-1  # 0e-1,  # Weight on the Minimal Time Objective\nproblem.settings.scp.lam_vc = (\n    1e1  # 1e1,  # Weight on the Virtual Control Objective (not including CTCS Augmentation)\n)\nproblem.settings.scp.ep_tr = 1e-5  # Trust Region Tolerance\nproblem.settings.scp.ep_vb = 1e-4  # Virtual Control Tolerance\nproblem.settings.scp.ep_vc = 1e-8  # Virtual Control Tolerance for CTCS\nproblem.settings.scp.cost_drop = 10  # SCP iteration to relax minimal final time objective\nproblem.settings.scp.cost_relax = 0.8  # Minimal Time Relaxation Factor\nproblem.settings.scp.w_tr_adapt = 1.2  # Trust Region Adaptation Factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e2  # Maximum Trust Region Weight\nplotting_dict = {\n    \"vertices\": vertices,\n    \"n_subs\": n_subs,\n    \"alpha_x\": alpha_x,\n    \"alpha_y\": alpha_y,\n    \"R_sb\": R_sb,\n    \"init_poses\": init_poses,\n    \"norm_type\": norm_type,\n}\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n    results.update(plotting_dict)\n    plot_animation(results, problem.settings).show()\n</code></pre>"},{"location":"examples/drone/drone_racing/","title":"Drone Racing","text":"<p>6-DOF quadrotor racing through sequential gates.</p> <p>This example demonstrates time-optimal trajectory planning for a quadrotor racing through a series of gates in a specified order. The problem includes:</p> <ul> <li>6-DOF rigid body dynamics (position, velocity, attitude quaternion, angular velocity)</li> <li>Nodal constraints enforcing gate traversal at sequential nodes</li> <li>Minimal time objective</li> <li>Loop closure (start equals end position)</li> </ul> <p>File: <code>examples/drone/drone_racing.py</code></p> <pre><code>import jax.numpy as jnp\nimport numpy as np\n\nimport openscvx as ox\nfrom examples.plotting import plot_animation\nfrom openscvx import Problem\nfrom openscvx.utils import gen_vertices, rot\n\nn = 22  # Number of Nodes\ntotal_time = 24.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 100, 200])\nposition.min = np.array([-200.0, -100, 15])\nposition.initial = np.array([10.0, 0, 20])\nposition.final = [10.0, 0, 20]\nposition.guess = np.linspace(position.initial, position.final, n)\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nvelocity.guess = np.linspace(velocity.initial, [0, 0, 0], n)\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.guess = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.guess = np.zeros((n, 3))\n\n# Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\nthrust_force.guess = np.repeat(np.array([[0.0, 0, 10]]), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n\n### Gate Parameters ###\nn_gates = 10\n\n# Initialize gate centers\ninitial_gate_centers = [\n    np.array([59.436, 0.000, 20.0000]),\n    np.array([92.964, -23.750, 25.5240]),\n    np.array([92.964, -29.274, 20.0000]),\n    np.array([92.964, -23.750, 20.0000]),\n    np.array([130.150, -23.750, 20.0000]),\n    np.array([152.400, -73.152, 20.0000]),\n    np.array([92.964, -75.080, 20.0000]),\n    np.array([92.964, -68.556, 20.0000]),\n    np.array([59.436, -81.358, 20.0000]),\n    np.array([22.250, -42.672, 20.0000]),\n]\n\n# Set initial values for gate center parameters and A_gate_c_params\nradii = np.array([2.5, 1e-4, 2.5])\nA_gate = rot @ np.diag(1 / radii) @ rot.T\n\n# Create modified centers (matching original behavior exactly)\nmodified_centers = []\nfor center in initial_gate_centers:\n    modified_center = center.copy()\n    modified_center[0] = modified_center[0] + 2.5\n    modified_center[2] = modified_center[2] + 2.5\n    modified_centers.append(modified_center)\n\n# Create symbolic parameters for each gate center with initial values\nA_gate_const = A_gate\ngate_center_params = []\nfor i, modified_center in enumerate(modified_centers):\n    # Create a Parameter with initial value\n    param = ox.Parameter(f\"gate_{i}_center\", shape=(3,), value=modified_center)\n    gate_center_params.append(param)\n\nnodes_per_gate = 2\ngate_nodes = np.arange(nodes_per_gate, n, nodes_per_gate)\nvertices = []\nfor modified_center in modified_centers:  # Use modified centers for vertices\n    vertices.append(gen_vertices(modified_center, radii))\n### End Gate Parameters ###\n\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity, attitude, angular_velocity]\ncontrols = [thrust_force, torque]\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add gate constraints\nfor node, gate_center_param in zip(gate_nodes, gate_center_params):\n    # Symbolically compute A_gate @ position - A_gate @ gate_center\n    gate_constraint = (\n        (\n            ox.linalg.Norm(A_gate_const @ position - A_gate_const @ gate_center_param, ord=\"inf\")\n            &lt;= 1.0\n        )\n        .convex()\n        .at([node])\n    )\n    constraints.append(gate_constraint)\n\n\n# Define symbolic utility functions\ndef symbolic_qdcm(q):\n    \"\"\"Quaternion to Direction Cosine Matrix conversion using symbolic expressions\"\"\"\n    # Normalize quaternion\n    q_norm = ox.Sqrt(ox.Sum(q * q))\n    q_normalized = q / q_norm\n\n    w, x, y, z = q_normalized[0], q_normalized[1], q_normalized[2], q_normalized[3]\n\n    # Create DCM elements\n    r11 = 1.0 - 2.0 * (y * y + z * z)\n    r12 = 2.0 * (x * y - z * w)\n    r13 = 2.0 * (x * z + y * w)\n\n    r21 = 2.0 * (x * y + z * w)\n    r22 = 1.0 - 2.0 * (x * x + z * z)\n    r23 = 2.0 * (y * z - x * w)\n\n    r31 = 2.0 * (x * z - y * w)\n    r32 = 2.0 * (y * z + x * w)\n    r33 = 1.0 - 2.0 * (x * x + y * y)\n\n    # Stack into 3x3 matrix\n    row1 = ox.Concat(r11, r12, r13)\n    row2 = ox.Concat(r21, r22, r23)\n    row3 = ox.Concat(r31, r32, r33)\n\n    return ox.Stack([row1, row2, row3])\n\n\ndef symbolic_ssmp(w):\n    \"\"\"Angular rate to 4x4 skew symmetric matrix for quaternion dynamics\"\"\"\n    x, y, z = w[0], w[1], w[2]\n    zero = 0.0\n\n    # Create SSMP matrix\n    row1 = ox.Concat(zero, -x, -y, -z)\n    row2 = ox.Concat(x, zero, z, -y)\n    row3 = ox.Concat(y, -z, zero, x)\n    row4 = ox.Concat(z, y, -x, zero)\n\n    return ox.Stack([row1, row2, row3, row4])\n\n\ndef symbolic_ssm(w):\n    \"\"\"Angular rate to 3x3 skew symmetric matrix\"\"\"\n    x, y, z = w[0], w[1], w[2]\n    zero = 0.0\n\n    # Create SSM matrix\n    row1 = ox.Concat(zero, -z, y)\n    row2 = ox.Concat(z, zero, -x)\n    row3 = ox.Concat(-y, x, zero)\n\n    return ox.Stack([row1, row2, row3])\n\n\ndef symbolic_diag(v):\n    \"\"\"Create diagonal matrix from vector\"\"\"\n    if len(v) == 3:\n        zero = 0.0\n        row1 = ox.Concat(v[0], zero, zero)\n        row2 = ox.Concat(zero, v[1], zero)\n        row3 = ox.Concat(zero, zero, v[2])\n        return ox.Stack([row1, row2, row3])\n    else:\n        raise NotImplementedError(\"Only 3x3 diagonal matrices supported\")\n\n\n# Create symbolic dynamics\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Option 1: Full symbolic dynamics (more flexible but potentially slower)\n# r_dot = velocity\n# v_dot = (Constant(1.0 / m)) * symbolic_qdcm(attitude) @ thrust_force + Constant(\n#     np.array([0, 0, g_const], dtype=np.float64)\n# )\n# q_dot = Constant(0.5) * symbolic_ssmp(angular_velocity) @ attitude\n# J_b_inv = Constant(1.0 / J_b)\n# J_b_diag = symbolic_diag([Constant(J_b[0]), Constant(J_b[1]), Constant(J_b[2])])\n# w_dot = symbolic_diag([J_b_inv[0], J_b_inv[1], J_b_inv[2]]) @ (\n#     torque - symbolic_ssm(angular_velocity) @ J_b_diag @ angular_velocity\n# )\n\n# Option 2: Efficient dynamics using direct JAX lowering (better performance)\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n    + ox.Constant(np.array([0, 0, g_const], dtype=np.float64)),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv)\n    @ (torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity),\n}\n\n\n# Generate initial guess for position trajectory through gates\nposition_bar = np.linspace(position.initial, position.final, n)\n\ni = 0\norigins = [position.initial]\nends = []\nfor center in modified_centers:  # Use modified centers for initial guess\n    origins.append(center)\n    ends.append(center)\nends.append(position.final)\ngate_idx = 0\nfor _ in range(n_gates + 1):\n    for k in range(n // (n_gates + 1)):\n        position_bar[i] = origins[gate_idx] + (k / (n // (n_gates + 1))) * (\n            ends[gate_idx] - origins[gate_idx]\n        )\n        i += 1\n    gate_idx += 1\n\nposition.guess = position_bar\n\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n    # licq_max=1E-8\n)\n\nproblem.settings.prp.dt = 0.01\n\nproblem.settings.scp.w_tr = 2e0  # Weight on the Trust Reigon\nproblem.settings.scp.lam_cost = 1e-1  # 0e-1,  # Weight on the Minimal Time Objective\nproblem.settings.scp.lam_vc = (\n    1e1  # 1e1,  # Weight on the Virtual Control Objective (not including CTCS Augmentation)\n)\nproblem.settings.scp.ep_tr = 1e-3  # Trust Region Tolerance\nproblem.settings.scp.ep_vb = 1e-4  # Virtual Control Tolerance\nproblem.settings.scp.ep_vc = 1e-8  # Virtual Control Tolerance for CTCS\n# problem.settings.scp.cost_drop = 10  # SCP iteration to relax minimal final time objective\n# problem.settings.scp.cost_relax = 0.8  # Minimal Time Relaxation Factor\nproblem.settings.scp.w_tr_adapt = 1.4  # Trust Region Adaptation Factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e2  # Maximum Trust Region Weight\n\nplotting_dict = {\n    \"vertices\": vertices,\n    \"gate_centers\": modified_centers,\n    \"A_gate\": A_gate_const,\n    \"A_gate_c_params\": [A_gate @ center for center in modified_centers],\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update(plotting_dict)\n\n    plot_animation(results, problem.settings).show()\n</code></pre>"},{"location":"examples/drone/obstacle_avoidance/","title":"Obstacle Avoidance","text":"<p>6-DOF quadrotor obstacle avoidance with ellipsoidal obstacles.</p> <p>This example demonstrates optimal trajectory planning for a quadrotor navigating through multiple ellipsoidal obstacles which are enforced in continuous time. The problem includes:</p> <ul> <li>6-DOF rigid body dynamics (position, velocity, attitude quaternion, angular velocity)</li> <li>Thrust force and torque control inputs</li> <li>Continuous ellipsoidal obstacle avoidance constraints</li> <li>Minimal time objective</li> </ul> <p>File: <code>examples/drone/obstacle_avoidance.py</code></p> <pre><code>import jax.numpy as jnp\nimport numpy as np\n\nimport openscvx as ox\nfrom examples.plotting import plot_animation\nfrom openscvx import Problem\nfrom openscvx.utils import generate_orthogonal_unit_vectors\n\nn = 6\ntotal_time = 4.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 10, 20])\nposition.min = np.array([-200.0, -100, 0])\nposition.initial = np.array([10.0, 0, 2])\nposition.final = [-10.0, 0, 2]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\ninitial_control = np.array([0.0, 0.0, thrust_force.max[2]])\nthrust_force.guess = np.repeat(np.expand_dims(initial_control, axis=0), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity, attitude, angular_velocity]\ncontrols = [thrust_force, torque]\n\n\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n    + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv)\n    @ (torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity),\n}\n\n\nA_obs = []\nradius = []\naxes = []\n\n# Default values for the obstacle centers\nobstacle_center_positions = [\n    np.array([-5.1, 0.1, 2]),\n    np.array([0.1, 0.1, 2]),\n    np.array([5.1, 0.1, 2]),\n]\n\n# Define obstacle centers as parameters for runtime updates\nobstacle_centers = [\n    ox.Parameter(\"obstacle_center_1\", shape=(3,), value=obstacle_center_positions[0]),\n    ox.Parameter(\"obstacle_center_2\", shape=(3,), value=obstacle_center_positions[1]),\n    ox.Parameter(\"obstacle_center_3\", shape=(3,), value=obstacle_center_positions[2]),\n]\n\nnp.random.seed(0)\nfor _ in obstacle_center_positions:\n    ax = generate_orthogonal_unit_vectors()\n    axes.append(generate_orthogonal_unit_vectors())\n    rad = np.random.rand(3) + 0.1 * np.ones(3)\n    radius.append(rad)\n    A_obs.append(ax @ np.diag(rad**2) @ ax.T)\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add obstacle constraints using symbolic expressions\nfor center, A in zip(obstacle_centers, A_obs):\n    A_const = A\n\n    # Obstacle constraint: (pos - center)^T @ A @ (pos - center) &gt;= 1\n    diff = position - center\n    obstacle_constraint = ox.ctcs(1.0 &lt;= diff.T @ A_const @ diff)\n    constraints.append(obstacle_constraint)\n\n# Set initial guesses\nposition.guess = np.linspace(position.initial, position.final, n)\nvelocity.guess = np.linspace(velocity.initial, [0, 0, 0], n)\nattitude.guess = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\nangular_velocity.guess = np.zeros((n, 3))\n\n\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n\nproblem.settings.prp.dt = 0.01\nproblem.settings.scp.lam_vb = 1e0\nproblem.settings.scp.w_tr_adapt = 1.8\nproblem.settings.scp.w_tr = 1e1\nproblem.settings.scp.lam_cost = 1e1  # Weight on the Nonlinear Cost\nproblem.settings.scp.lam_vc = 1e2  # Weight on the Virtual Control Objective\nproblem.settings.scp.cost_drop = 4  # SCP iteration to relax minimal final time objective\nproblem.settings.scp.cost_relax = 0.5  # Minimal Time Relaxation Factor\n\nplotting_dict = {\n    \"obstacles_centers\": obstacle_center_positions,\n    \"obstacles_axes\": axes,\n    \"obstacles_radii\": radius,\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update(plotting_dict)\n\n    plot_animation(results, problem.settings).show()\n</code></pre>"},{"location":"examples/drone/obstacle_avoidance_nodal/","title":"Obstacle Avoidance Nodal","text":"<p>6-DOF quadrotor obstacle avoidance with nodal constraints.</p> <p>This example demonstrates optimal trajectory planning for a quadrotor with obstacle avoidance constraints applied at specific nodes. The problem includes:</p> <ul> <li>6-DOF rigid body dynamics (position, velocity, attitude quaternion, angular velocity)</li> <li>Thrust force and torque control inputs</li> <li>Nodal obstacle avoidance constraints at specific trajectory points</li> <li>Minimal time objective</li> </ul> <p>File: <code>examples/drone/obstacle_avoidance_nodal.py</code></p> <pre><code>import jax.numpy as jnp\nimport numpy as np\n\nimport openscvx as ox\nfrom examples.plotting import plot_animation\nfrom openscvx import Problem\nfrom openscvx.utils import generate_orthogonal_unit_vectors\n\nn = 6\ntotal_time = 4.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 10, 20])\nposition.min = np.array([-200.0, -100, 0])\nposition.initial = np.array([10.0, 0, 2])\nposition.final = [-10.0, 0, 2]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\ninitial_control = np.array([0.0, 0.0, 50.0])\nthrust_force.guess = np.repeat(np.expand_dims(initial_control, axis=0), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity, attitude, angular_velocity]\ncontrols = [thrust_force, torque]\n\n\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n    + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv)\n    @ (torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity),\n}\n\n\nA_obs = []\nradius = []\naxes = []\n\n# Default values for the obstacle centers\nobstacle_center_positions = [\n    np.array([-5.1, 0.1, 2]),\n    np.array([0.1, 0.1, 2]),\n    np.array([5.1, 0.1, 2]),\n]\n\n# Define obstacle centers as parameters for runtime updates\nobstacle_centers = [\n    ox.Parameter(\"obstacle_center_1\", shape=(3,), value=obstacle_center_positions[0]),\n    ox.Parameter(\"obstacle_center_2\", shape=(3,), value=obstacle_center_positions[1]),\n    ox.Parameter(\"obstacle_center_3\", shape=(3,), value=obstacle_center_positions[2]),\n]\n\nnp.random.seed(0)\nfor _ in obstacle_center_positions:\n    ax = generate_orthogonal_unit_vectors()\n    axes.append(generate_orthogonal_unit_vectors())\n    rad = np.random.rand(3) + 0.1 * np.ones(3)\n    radius.append(rad)\n    A_obs.append(ax @ np.diag(rad**2) @ ax.T)\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add obstacle constraints using symbolic expressions (as nodal constraints)\nfor center, A in zip(obstacle_centers, A_obs):\n    A_const = A\n\n    # Obstacle constraint: (pos - center)^T @ A @ (pos - center) &gt;= 1\n    diff = position - center\n    obstacle_constraint = 1.0 &lt;= diff.T @ A_const @ diff\n    constraints.append(obstacle_constraint)\n\n# Set initial guesses\nposition.guess = np.linspace(position.initial, position.final, n)\nvelocity.guess = np.linspace(velocity.initial, [0, 0, 0], n)\nattitude.guess = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\nangular_velocity.guess = np.zeros((n, 3))\n\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n\nproblem.settings.prp.dt = 0.01\nproblem.settings.scp.lam_vb = 1e0\nproblem.settings.scp.cost_drop = 4  # SCP iteration to relax minimal final time objective\nproblem.settings.scp.cost_relax = 0.5  # Minimal Time Relaxation Factor\n\nplotting_dict = {\n    \"obstacles_centers\": obstacle_center_positions,\n    \"obstacles_axes\": axes,\n    \"obstacles_radii\": radius,\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update(plotting_dict)\n\n    plot_animation(results, problem.settings).show()\n</code></pre>"},{"location":"examples/drone/obstacle_avoidance_realtime_base/","title":"Obstacle Avoidance Realtime Base","text":"<p>Base problem setup for real-time 6-DOF obstacle avoidance.</p> <p>This module defines the base optimization problem for real-time quadrotor obstacle avoidance, designed to be imported by interactive visualization examples. The problem includes:</p> <ul> <li>6-DOF dynamics (position, velocity, attitude quaternion, angular velocity)</li> <li>Parametric obstacle positions for runtime updates</li> <li>Ellipsoidal obstacle avoidance constraints</li> <li>Configured for real-time re-optimization</li> </ul> <p>File: <code>examples/drone/obstacle_avoidance_realtime_base.py</code></p> <pre><code>import jax.numpy as jnp\nimport numpy as np\n\nimport openscvx as ox\nfrom examples.plotting import plot_animation\nfrom openscvx import Problem\nfrom openscvx.utils import generate_orthogonal_unit_vectors\n\nn = 6\ntotal_time = 4.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 10, 20])\nposition.min = np.array([-200.0, -100, 0])\nposition.initial = np.array([10.0, 0, 2])\nposition.final = np.array([-10.0, 0, 2])\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\ninitial_control = np.array([0.0, 0.0, thrust_force.max[2]])\nthrust_force.guess = np.repeat(np.expand_dims(initial_control, axis=0), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity, attitude, angular_velocity]\ncontrols = [thrust_force, torque]\n\n\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n    + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv)\n    @ (torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity),\n}\n\n\nA_obs = []\nradius = []\naxes = []\n\n# Default values for the obstacle centers\nobstacle_center_positions = [\n    np.array([-5.1, 0.1, 2]),\n    np.array([0.1, 0.1, 2]),\n    np.array([5.1, 0.1, 2]),\n]\n\n# Define obstacle centers as parameters for runtime updates\nobstacle_centers = [\n    ox.Parameter(\"obstacle_center_1\", shape=(3,), value=obstacle_center_positions[0]),\n    ox.Parameter(\"obstacle_center_2\", shape=(3,), value=obstacle_center_positions[1]),\n    ox.Parameter(\"obstacle_center_3\", shape=(3,), value=obstacle_center_positions[2]),\n]\n\nnp.random.seed(0)\nfor _ in obstacle_center_positions:\n    ax = generate_orthogonal_unit_vectors()\n    axes.append(generate_orthogonal_unit_vectors())\n    rad = np.random.rand(3) + 0.1 * np.ones(3)\n    radius.append(rad)\n    A_obs.append(ax @ np.diag(rad**2) @ ax.T)\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add obstacle constraints using symbolic expressions\nfor center, A in zip(obstacle_centers, A_obs):\n    A_const = A\n\n    # Obstacle constraint: (pos - center)^T @ A @ (pos - center) &gt;= 1\n    diff = position - center\n    obstacle_constraint = ox.ctcs(1.0 &lt;= diff.T @ A_const @ diff)\n    constraints.append(obstacle_constraint)\n\n# Set initial guesses\nposition.guess = np.linspace(position.initial, position.final, n)\nvelocity.guess = np.linspace(velocity.initial, [0, 0, 0], n)\nattitude.guess = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\nangular_velocity.guess = np.zeros((n, 3))\n\n\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n    time_dilation_factor_min=0.2,\n)\n\nproblem.settings.scp.w_tr_adapt = 1\nproblem.settings.scp.w_tr = 4e0\nproblem.settings.scp.lam_cost = 4e-2  # Weight on the Nonlinear Cost\nproblem.settings.scp.lam_vc = 1e2  # Weight on the Virtual Control Objective\nproblem.settings.prp.dt = 0.01\n\nplotting_dict = {\n    \"obstacles_centers\": obstacle_center_positions,\n    \"obstacles_axes\": axes,\n    \"obstacles_radii\": radius,\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update(plotting_dict)\n\n    plot_animation(results, problem.settings).show()\n</code></pre>"},{"location":"examples/realtime/cinema_vp_realtime/","title":"Cinema Vp Realtime","text":"<p>Interactive real-time visualization for cinematic viewpoint planning.</p> <p>This module provides a PyQt5-based GUI for interactively solving and visualizing the cinematic viewpoint planning trajectory optimization problem in real-time.</p> <p>File: <code>examples/realtime/cinema_vp_realtime.py</code></p> <pre><code>import os\nimport sys\nimport threading\nimport time\n\nimport numpy as np\nfrom PyQt5.QtCore import Qt, QTimer\nfrom PyQt5.QtWidgets import (\n    QApplication,\n    QGroupBox,\n    QHBoxLayout,\n    QLabel,\n    QLineEdit,\n    QPushButton,\n    QSlider,\n    QVBoxLayout,\n    QWidget,\n)\n\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nfrom examples.drone.cinema_vp_realtime_base import (\n    kp_pose,\n    plotting_dict,\n    problem,\n)\n\n# Import PyQtGraph OpenGL modules\ntry:\n    from pyqtgraph.opengl import (\n        GLGridItem,\n        GLLinePlotItem,\n        GLMeshItem,\n        GLScatterPlotItem,\n        GLViewWidget,\n        MeshData,\n    )\n\n    HAS_OPENGL = True\nexcept ImportError:\n    print(\"PyQtGraph OpenGL not available, falling back to 2D\")\n    HAS_OPENGL = False\n\n# Import scipy Rotation for quaternion to rotation matrix conversion\n# (matching plot_animation_pyqtgraph)\nfrom scipy.spatial.transform import Rotation as R\n\nrunning = {\"stop\": False}\nreset_requested = {\"reset\": False}\nlatest_results = {\"results\": None}\nnew_result_event = threading.Event()\n\n\nclass CinemaVPPlotWidget(QWidget):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        layout = QVBoxLayout()\n        self.setLayout(layout)\n        if HAS_OPENGL:\n            # Create 3D view\n            self.view = GLViewWidget()\n            self.view.setCameraPosition(distance=30)\n            # Add grid\n            grid = GLGridItem()\n            self.view.addItem(grid)\n            # Add trajectory scatter plot\n            self.traj_scatter = GLScatterPlotItem(pos=np.zeros((1, 3)), color=(0, 0, 1, 1), size=5)\n            self.view.addItem(self.traj_scatter)\n            # Add keypoint scatter plot\n            self.kp_scatter = GLScatterPlotItem(pos=np.zeros((1, 3)), color=(1, 0, 0, 1), size=10)\n            self.view.addItem(self.kp_scatter)\n            # Add line-of-sight visualization (line from drone to keypoint)\n            self.los_line = GLLinePlotItem(color=(1, 1, 0, 0.5), width=2)\n            self.view.addItem(self.los_line)\n            # Add drone axes visualization (x=red, y=green, z=blue)\n            self.axis_lines = []\n            axis_colors = [(1, 0, 0, 1), (0, 1, 0, 1), (0, 0, 1, 1)]  # Red, Green, Blue\n            for color in axis_colors:\n                axis_line = GLLinePlotItem(color=color, width=3)\n                self.view.addItem(axis_line)\n                self.axis_lines.append(axis_line)\n            # Add view cone mesh\n            self.viewcone_mesh = None\n            self.cone_meshdata = None  # Store cone mesh data for reuse\n            # Create main layout with view and control panel\n            main_layout = QHBoxLayout()\n            # Create control panel\n            self.create_control_panel()\n            # Add widgets to main layout\n            main_layout.addWidget(self.view, stretch=3)\n            main_layout.addWidget(self.control_panel, stretch=1)\n            layout.addLayout(main_layout)\n        else:\n            # Fallback to 2D\n            label = QLabel(\"3D OpenGL not available\")\n            layout.addWidget(label)\n\n    def create_control_panel(self):\n        \"\"\"Create the control panel with sliders for keypoint position\"\"\"\n        self.control_panel = QWidget()\n        control_layout = QVBoxLayout()\n        self.control_panel.setLayout(control_layout)\n        # Title\n        title = QLabel(\"Cinema View Planning Control\")\n        title.setStyleSheet(\"font-weight: bold; font-size: 14px;\")\n        control_layout.addWidget(title)\n        # Optimization Metrics Display\n        metrics_group = QGroupBox(\"Optimization Metrics\")\n        metrics_layout = QVBoxLayout()\n        metrics_group.setLayout(metrics_layout)\n        # Create labels for each metric\n        self.iter_label = QLabel(\"Iteration: 0\")\n        self.j_tr_label = QLabel(\"J_tr: 0.00e+00\")\n        self.j_vb_label = QLabel(\"J_vb: 0.00e+00\")\n        self.j_vc_label = QLabel(\"J_vc: 0.00e+00\")\n        self.objective_label = QLabel(\"Objective: 0.00e+00\")\n        self.lam_cost_display_label = QLabel(f\"\u03bb_cost: {problem.settings.scp.lam_cost:.2E}\")\n        self.dis_time_label = QLabel(\"Dis Time: 0.0ms\")\n        self.solve_time_label = QLabel(\"Solve Time: 0.0ms\")\n        self.status_label = QLabel(\"Status: --\")\n        # Style the labels\n        for label in [\n            self.iter_label,\n            self.j_tr_label,\n            self.j_vb_label,\n            self.j_vc_label,\n            self.objective_label,\n            self.lam_cost_display_label,\n            self.dis_time_label,\n            self.solve_time_label,\n            self.status_label,\n        ]:\n            label.setStyleSheet(\"font-family: monospace; font-size: 11px; padding: 2px;\")\n            metrics_layout.addWidget(label)\n        control_layout.addWidget(metrics_group)\n        # Optimization Weights\n        weights_group = QGroupBox(\"Optimization Weights\")\n        weights_layout = QVBoxLayout()\n        weights_group.setLayout(weights_layout)\n        # Lambda cost input - Input on left, label on right\n        lam_cost_layout = QHBoxLayout()\n        lam_cost_input = QLineEdit()\n        lam_cost_input.setText(f\"{problem.settings.scp.lam_cost:.2E}\")\n        lam_cost_input.setFixedWidth(80)\n        lam_cost_input.returnPressed.connect(lambda: on_lam_cost_changed(lam_cost_input))\n        lam_cost_label = QLabel(\"\u03bb_cost:\")\n        lam_cost_label.setAlignment(Qt.AlignLeft)\n        lam_cost_layout.addWidget(lam_cost_input)\n        lam_cost_layout.addWidget(lam_cost_label)\n        lam_cost_layout.addStretch()  # Push everything to the left\n        weights_layout.addLayout(lam_cost_layout)\n        # Lambda trust region input - Input on left, label on right\n        lam_tr_layout = QHBoxLayout()\n        lam_tr_input = QLineEdit()\n        lam_tr_input.setText(f\"{problem.settings.scp.w_tr:.2E}\")\n        lam_tr_input.setFixedWidth(80)\n        lam_tr_input.returnPressed.connect(lambda: on_lam_tr_changed(lam_tr_input))\n        lam_tr_label = QLabel(\"\u03bb_tr:\")\n        lam_tr_label.setAlignment(Qt.AlignLeft)\n        lam_tr_layout.addWidget(lam_tr_input)\n        lam_tr_layout.addWidget(lam_tr_label)\n        lam_tr_layout.addStretch()  # Push everything to the left\n        weights_layout.addLayout(lam_tr_layout)\n        control_layout.addWidget(weights_group)\n        # Reset Button\n        reset_group = QGroupBox(\"Problem Control\")\n        reset_layout = QVBoxLayout()\n        reset_group.setLayout(reset_layout)\n        reset_button = QPushButton(\"Reset Problem\")\n        reset_button.clicked.connect(self.on_reset_clicked)\n        reset_layout.addWidget(reset_button)\n        control_layout.addWidget(reset_group)\n        # Keypoint Position Controls\n        kp_group = QGroupBox(\"Keypoint Position (Line-of-Sight Target)\")\n        kp_layout = QVBoxLayout()\n        kp_group.setLayout(kp_layout)\n        # X, Y, Z sliders\n        self.kp_sliders = []\n        for j, coord in enumerate([\"X\", \"Y\", \"Z\"]):\n            slider_layout = QHBoxLayout()\n            label = QLabel(f\"{coord}:\")\n            slider = QSlider(Qt.Horizontal)\n            # Set range based on position bounds (scaled for slider)\n            slider.setRange(-200, 200)\n            # Set initial value based on current keypoint position\n            initial_value = int(kp_pose.value[j] * 10)  # Scale by 10 for precision\n            slider.setValue(initial_value)\n            value_label = QLabel(f\"{kp_pose.value[j]:.2f}\")\n            # Connect slider to update function\n            slider.valueChanged.connect(\n                lambda val, axis=j, label=value_label: self.on_slider_changed(val, axis, label)\n            )\n            slider_layout.addWidget(label)\n            slider_layout.addWidget(slider)\n            slider_layout.addWidget(value_label)\n            kp_layout.addLayout(slider_layout)\n            self.kp_sliders.append((slider, value_label))\n        # Text inputs for precise control\n        text_inputs_layout = QHBoxLayout()\n        self.kp_x_input = QLineEdit()\n        self.kp_x_input.setText(f\"{kp_pose.value[0]:.2f}\")\n        self.kp_x_input.setFixedWidth(60)\n        self.kp_x_input.returnPressed.connect(\n            lambda: self.on_text_input_changed(0, self.kp_x_input)\n        )\n        self.kp_y_input = QLineEdit()\n        self.kp_y_input.setText(f\"{kp_pose.value[1]:.2f}\")\n        self.kp_y_input.setFixedWidth(60)\n        self.kp_y_input.returnPressed.connect(\n            lambda: self.on_text_input_changed(1, self.kp_y_input)\n        )\n        self.kp_z_input = QLineEdit()\n        self.kp_z_input.setText(f\"{kp_pose.value[2]:.2f}\")\n        self.kp_z_input.setFixedWidth(60)\n        self.kp_z_input.returnPressed.connect(\n            lambda: self.on_text_input_changed(2, self.kp_z_input)\n        )\n        text_inputs_layout.addWidget(QLabel(\"Precise:\"))\n        text_inputs_layout.addWidget(self.kp_x_input)\n        text_inputs_layout.addWidget(self.kp_y_input)\n        text_inputs_layout.addWidget(self.kp_z_input)\n        kp_layout.addLayout(text_inputs_layout)\n        control_layout.addWidget(kp_group)\n        control_layout.addStretch()\n        # Create labels dictionary for metrics update\n        self.labels_dict = {\n            \"iter_label\": self.iter_label,\n            \"j_tr_label\": self.j_tr_label,\n            \"j_vb_label\": self.j_vb_label,\n            \"j_vc_label\": self.j_vc_label,\n            \"objective_label\": self.objective_label,\n            \"lam_cost_display_label\": self.lam_cost_display_label,\n            \"dis_time_label\": self.dis_time_label,\n            \"solve_time_label\": self.solve_time_label,\n            \"status_label\": self.status_label,\n        }\n\n    def on_slider_changed(self, value, axis, label):\n        \"\"\"Handle slider value changes\"\"\"\n        # Convert slider value (-200 to 200) to world coordinates (-20 to 20)\n        world_value = value * 0.1\n        # Update the parameter\n        new_kp_pose = kp_pose.value.copy()\n        new_kp_pose[axis] = world_value\n        # Update both the Parameter object's value and problem.parameters\n        kp_pose.value = new_kp_pose\n        problem.parameters[\"kp_pose\"] = new_kp_pose\n        # Update label\n        label.setText(f\"{world_value:.2f}\")\n        # Update text input\n        if axis == 0:\n            self.kp_x_input.setText(f\"{world_value:.2f}\")\n        elif axis == 1:\n            self.kp_y_input.setText(f\"{world_value:.2f}\")\n        elif axis == 2:\n            self.kp_z_input.setText(f\"{world_value:.2f}\")\n\n    def on_text_input_changed(self, axis, input_widget):\n        \"\"\"Handle text input changes\"\"\"\n        try:\n            value = float(input_widget.text())\n            # Update the parameter\n            new_kp_pose = kp_pose.value.copy()\n            new_kp_pose[axis] = value\n            # Update both the Parameter object's value and problem.parameters\n            kp_pose.value = new_kp_pose\n            problem.parameters[\"kp_pose\"] = new_kp_pose\n            # Update slider\n            slider, label = self.kp_sliders[axis]\n            slider_value = int(value * 10)  # Scale by 10 for slider\n            slider.setValue(slider_value)\n            label.setText(f\"{value:.2f}\")\n        except ValueError:\n            print(f\"Invalid input for axis {axis}\")\n\n    def on_reset_clicked(self):\n        \"\"\"Handle reset button click\"\"\"\n        reset_requested[\"reset\"] = True\n        print(\"Reset requested - problem will reset on next iteration\")\n\n    def keyPressEvent(self, event):\n        \"\"\"Handle keyboard shortcuts\"\"\"\n        if event.key() == Qt.Key_Escape:\n            self.close()\n        else:\n            super().keyPressEvent(event)\n\n\ndef on_lam_cost_changed(input_widget):\n    \"\"\"Handle lambda cost input changes\"\"\"\n    new_value = input_widget.text()\n    try:\n        lam_cost_value = float(new_value)\n        problem.settings.scp.lam_cost = lam_cost_value\n        input_widget.setText(f\"{lam_cost_value:.2E}\")\n    except ValueError:\n        print(\"Invalid input. Please enter a valid number.\")\n\n\ndef on_lam_tr_changed(input_widget):\n    \"\"\"Handle lambda trust region input changes\"\"\"\n    new_value = input_widget.text()\n    try:\n        lam_tr_value = float(new_value)\n        problem.settings.scp.w_tr = lam_tr_value\n        input_widget.setText(f\"{lam_tr_value:.2E}\")\n    except ValueError:\n        print(\"Invalid input. Please enter a valid number.\")\n\n\ndef update_optimization_metrics(results, labels_dict):\n    \"\"\"Update the optimization metrics display\"\"\"\n    if results is None:\n        return\n    # Extract metrics from results\n    iter_num = results.get(\"iter\", 0)\n    j_tr = results.get(\"J_tr\", 0.0)\n    j_vb = results.get(\"J_vb\", 0.0)\n    j_vc = results.get(\"J_vc\", 0.0)\n    cost = results.get(\"cost\", 0.0)\n    status = results.get(\"prob_stat\", \"--\")\n    # Get timing information\n    dis_time = results.get(\"dis_time\", 0.0)\n    solve_time = results.get(\"solve_time\", 0.0)\n    # Update labels\n    labels_dict[\"iter_label\"].setText(f\"Iteration: {iter_num}\")\n    labels_dict[\"j_tr_label\"].setText(f\"J_tr: {j_tr:.2E}\")\n    labels_dict[\"j_vb_label\"].setText(f\"J_vb: {j_vb:.2E}\")\n    labels_dict[\"j_vc_label\"].setText(f\"J_vc: {j_vc:.2E}\")\n    labels_dict[\"objective_label\"].setText(f\"Objective: {cost:.2E}\")\n    labels_dict[\"lam_cost_display_label\"].setText(f\"\u03bb_cost: {problem.settings.scp.lam_cost:.2E}\")\n    labels_dict[\"dis_time_label\"].setText(f\"Dis Time: {dis_time:.1f}ms\")\n    labels_dict[\"solve_time_label\"].setText(f\"Solve Time: {solve_time:.1f}ms\")\n    labels_dict[\"status_label\"].setText(f\"Status: {status}\")\n\n\ndef update_viewcone(plot_widget, drone_pos, att, plotting_dict, pos_range=None):\n    \"\"\"Create or update the view cone mesh visualization\"\"\"\n    if not HAS_OPENGL:\n        return\n\n    # Get view cone parameters from plotting_dict\n    alpha_x = plotting_dict.get(\"alpha_x\", 6.0)\n    alpha_y = plotting_dict.get(\"alpha_y\", 8.0)\n    R_sb = plotting_dict.get(\"R_sb\", np.eye(3))\n    norm_type = plotting_dict.get(\"norm_type\", \"inf\")\n\n    # Create cone mesh data if it doesn't exist\n    if not hasattr(plot_widget, \"cone_meshdata\") or plot_widget.cone_meshdata is None:\n        n_cone = 40\n        theta = np.linspace(0, 2 * np.pi, n_cone)\n        A = np.diag([1 / np.tan(np.pi / alpha_x), 1 / np.tan(np.pi / alpha_y)])\n\n        # Calculate cone length based on trajectory range (similar to plot_animation_pyqtgraph)\n        if pos_range is not None:\n            cone_length = max(pos_range) * 0.3  # 30% of trajectory range\n            cone_length = max(cone_length, 10.0)  # Minimum 10 units\n            cone_length = min(cone_length, 50.0)  # Maximum 50 units\n        else:\n            cone_length = 15.0  # Default length\n\n        # Create circle in sensor frame\n        circle = np.stack([np.cos(theta), np.sin(theta)])\n\n        # Calculate z values based on norm type\n        if norm_type == \"inf\" or norm_type == np.inf:\n            z = np.linalg.norm(A @ circle, axis=0, ord=np.inf)\n        else:\n            z = np.linalg.norm(A @ circle, axis=0, ord=norm_type)\n\n        # Create cone base points\n        X = circle[0] / z\n        Y = circle[1] / z\n        Z = np.ones_like(X)\n        base_points = np.stack([X, Y, Z], axis=1) * cone_length\n\n        # Create cone mesh (apex at origin, base at cone_length)\n        apex = np.array([[0, 0, 0]])\n        vertices = np.vstack([apex, base_points])\n\n        # Create faces\n        faces = []\n        for i in range(1, n_cone):\n            faces.append([0, i, i + 1])\n        faces.append([0, n_cone, 1])\n        faces = np.array(faces)\n\n        # Store the mesh data for reuse\n        plot_widget.cone_meshdata = MeshData(vertexes=vertices, faces=faces)\n\n    # Transform cone from sensor frame to body frame to inertial frame\n    # Use scipy Rotation for quaternion conversion (matching plot_animation_pyqtgraph)\n    # Quaternion format: [qw, qx, qy, qz] -&gt; scipy expects [qx, qy, qz, qw]\n    r = R.from_quat([att[1], att[2], att[3], att[0]])\n    rotmat = r.as_matrix()\n\n    # Get original vertices and transform them\n    verts = plot_widget.cone_meshdata.vertexes()\n    verts_tf = (rotmat @ R_sb.T @ verts.T).T + drone_pos\n\n    # Create or update mesh\n    if plot_widget.viewcone_mesh is None:\n        plot_widget.viewcone_mesh = GLMeshItem(\n            meshdata=MeshData(vertexes=verts_tf, faces=plot_widget.cone_meshdata.faces()),\n            smooth=True,\n            color=(1, 1, 0, 0.5),  # Yellow, semi-transparent (matching plot_animation_pyqtgraph)\n            shader=\"shaded\",\n            drawEdges=False,\n            glOptions=\"additive\",  # Use additive blending like plot_animation_pyqtgraph\n        )\n        plot_widget.view.addItem(plot_widget.viewcone_mesh)\n    else:\n        # Update existing mesh\n        plot_widget.viewcone_mesh.setMeshData(\n            vertexes=verts_tf, faces=plot_widget.cone_meshdata.faces()\n        )\n        # Remove and re-add cone to ensure it is drawn last (matching plot_animation_pyqtgraph)\n        if plot_widget.viewcone_mesh in plot_widget.view.items:\n            plot_widget.view.removeItem(plot_widget.viewcone_mesh)\n        plot_widget.view.addItem(plot_widget.viewcone_mesh)\n\n\ndef optimization_loop():\n    problem.initialize()\n    try:\n        while not running[\"stop\"]:\n            # Check if reset was requested\n            if reset_requested[\"reset\"]:\n                problem.reset()\n                reset_requested[\"reset\"] = False\n                print(\"Problem reset to initial conditions\")\n\n            # Perform a single SCP step (automatically warm-starts from previous iteration)\n            step_result = problem.step()\n\n            # Build results dict for visualization\n            results = {\n                \"iter\": step_result[\"scp_k\"] - 1,  # Display iteration (0-indexed)\n                \"J_tr\": step_result[\"scp_J_tr\"],\n                \"J_vb\": step_result[\"scp_J_vb\"],\n                \"J_vc\": step_result[\"scp_J_vc\"],\n                \"converged\": step_result[\"converged\"],\n                \"V_multi_shoot\": problem.state.V_history[-1] if problem.state.V_history else [],\n                \"x\": problem.state.x,  # Current state trajectory\n                \"u\": problem.state.u,  # Current control trajectory\n            }\n\n            # Get timing from the print queue (emitted data)\n            try:\n                if hasattr(problem, \"print_queue\") and not problem.print_queue.empty():\n                    # Get the latest emitted data\n                    emitted_data = problem.print_queue.get_nowait()\n                    results[\"dis_time\"] = emitted_data.get(\"dis_time\", 0.0)\n                    results[\"solve_time\"] = emitted_data.get(\"subprop_time\", 0.0)\n                    results[\"prob_stat\"] = emitted_data.get(\"prob_stat\", \"--\")\n                    results[\"cost\"] = emitted_data.get(\"cost\", 0.0)\n                else:\n                    results[\"dis_time\"] = 0.0\n                    results[\"solve_time\"] = 0.0\n                    results[\"prob_stat\"] = \"--\"\n                    results[\"cost\"] = 0.0\n            except Exception:\n                results[\"dis_time\"] = 0.0\n                results[\"solve_time\"] = 0.0\n                results[\"prob_stat\"] = \"--\"\n                results[\"cost\"] = 0.0\n\n            results.update(plotting_dict)\n            latest_results[\"results\"] = results\n            new_result_event.set()\n    except KeyboardInterrupt:\n        running[\"stop\"] = True\n        print(\"Stopped by user.\")\n\n\ndef plot_thread_func():\n    # Initialize PyQtGraph\n    app = QApplication.instance()\n    if app is None:\n        app = QApplication([])\n    print(f\"Creating plot window... OpenGL available: {HAS_OPENGL}\")\n    # Create 3D plot window\n    plot_widget = CinemaVPPlotWidget()\n    plot_widget.setWindowTitle(\"Cinema View Planning Real-time Trajectory\")\n    plot_widget.resize(1200, 800)\n    plot_widget.show()\n    print(\"Plot window created and shown\")\n    # Force the window to be visible\n    plot_widget.raise_()\n    plot_widget.activateWindow()\n    # Small delay to ensure window appears\n    time.sleep(0.1)\n    # Update timer\n    timer = QTimer()\n\n    def update_plot():\n        if latest_results[\"results\"] is not None:\n            try:\n                V_multi_shoot = np.array(latest_results[\"results\"][\"V_multi_shoot\"])\n                # Extract 3D position data (first 3 elements of state)\n                n_x = problem.settings.sim.n_states\n                n_u = problem.settings.sim.n_controls\n                i1 = n_x\n                i2 = i1 + n_x * n_x\n                i3 = i2 + n_x * n_u\n                i4 = i3 + n_x * n_u\n                all_pos_segments = []\n                for i_node in range(V_multi_shoot.shape[1]):\n                    node_data = V_multi_shoot[:, i_node]\n                    segments_for_node = node_data.reshape(-1, i4)\n                    pos_segments = segments_for_node[:, :3]  # 3D positions\n                    all_pos_segments.append(pos_segments)\n                if all_pos_segments:\n                    full_traj = np.vstack(all_pos_segments)\n                    if HAS_OPENGL:\n                        plot_widget.traj_scatter.setData(pos=full_traj)\n                        # Update keypoint position\n                        current_kp = problem.parameters[\"kp_pose\"]\n                        plot_widget.kp_scatter.setData(pos=current_kp.reshape(1, 3))\n                        # Update line-of-sight line (from last position to keypoint)\n                        if len(full_traj) &gt; 0:\n                            los_points = np.vstack([full_traj[-1], current_kp])\n                            plot_widget.los_line.setData(pos=los_points)\n                            # Extract attitude from last node and draw axes\n                            # State order: position[0:3], velocity[3:6], attitude[6:10], ...\n                            if \"x\" in latest_results[\"results\"]:\n                                x_traj = latest_results[\"results\"][\"x\"]  # Now a numpy array\n                                if len(x_traj) &gt; 0 and x_traj.shape[1] &gt;= 10:\n                                    # Get attitude quaternion [qw, qx, qy, qz] at last node\n                                    att = x_traj[-1, 6:10]\n                                    # Convert quaternion to rotation matrix using scipy\n                                    # (matching plot_animation_pyqtgraph)\n                                    r = R.from_quat([att[1], att[2], att[3], att[0]])\n                                    rotmat = r.as_matrix()\n                                    # Draw axes (x=red, y=green, z=blue)\n                                    axes_length = 2.0\n                                    axes = axes_length * np.eye(3)\n                                    axes_rot = rotmat @ axes\n                                    current_pos = full_traj[-1]\n                                    for k in range(3):\n                                        axis_pts = np.vstack(\n                                            [current_pos, current_pos + axes_rot[:, k]]\n                                        )\n                                        plot_widget.axis_lines[k].setData(pos=axis_pts)\n                                    # Update view cone\n                                    # Calculate position range for cone length\n                                    if len(full_traj) &gt; 1:\n                                        pos_range = np.max(full_traj, axis=0) - np.min(\n                                            full_traj, axis=0\n                                        )\n                                    else:\n                                        pos_range = None\n                                    update_viewcone(\n                                        plot_widget,\n                                        current_pos,\n                                        att,\n                                        plotting_dict,\n                                        pos_range=pos_range,\n                                    )\n                    else:\n                        # 2D fallback\n                        pass\n                # Update optimization metrics display\n                update_optimization_metrics(latest_results[\"results\"], plot_widget.labels_dict)\n            except Exception as e:\n                print(f\"Plot update error: {e}\")\n                if \"x\" in latest_results[\"results\"]:\n                    x_traj = latest_results[\"results\"][\"x\"]  # Now a numpy array\n                    if HAS_OPENGL:\n                        plot_widget.traj_scatter.setData(pos=x_traj[:, :3])\n                        # Update keypoint position\n                        current_kp = problem.parameters[\"kp_pose\"]\n                        plot_widget.kp_scatter.setData(pos=current_kp.reshape(1, 3))\n                        # Update line-of-sight line\n                        if len(x_traj) &gt; 0:\n                            los_points = np.vstack([x_traj[-1, :3], current_kp])\n                            plot_widget.los_line.setData(pos=los_points)\n                            # Draw axes at last position\n                            if x_traj.shape[1] &gt;= 10:\n                                att = x_traj[-1, 6:10]\n                                # Convert quaternion to rotation matrix using scipy\n                                # (matching plot_animation_pyqtgraph)\n                                r = R.from_quat([att[1], att[2], att[3], att[0]])\n                                rotmat = r.as_matrix()\n                                axes_length = 2.0\n                                axes = axes_length * np.eye(3)\n                                axes_rot = rotmat @ axes\n                                current_pos = x_traj[-1, :3]\n                                for k in range(3):\n                                    axis_pts = np.vstack(\n                                        [current_pos, current_pos + axes_rot[:, k]]\n                                    )\n                                    plot_widget.axis_lines[k].setData(pos=axis_pts)\n                                # Update view cone\n                                # Calculate position range for cone length\n                                if len(x_traj) &gt; 1:\n                                    pos_range = np.max(x_traj[:, :3], axis=0) - np.min(\n                                        x_traj[:, :3], axis=0\n                                    )\n                                else:\n                                    pos_range = None\n                                update_viewcone(\n                                    plot_widget,\n                                    current_pos,\n                                    att,\n                                    plotting_dict,\n                                    pos_range=pos_range,\n                                )\n\n    timer.timeout.connect(update_plot)\n    timer.start(50)  # Update every 50ms\n    print(\"Starting Qt event loop...\")\n    # Start the Qt event loop\n    app.exec_()\n\n\nif __name__ == \"__main__\":\n    # Start optimization thread\n    opt_thread = threading.Thread(target=optimization_loop)\n    opt_thread.daemon = True\n    opt_thread.start()\n    # Start plotting in main thread (this will block and run the Qt event loop)\n    plot_thread_func()\n</code></pre>"},{"location":"examples/realtime/drone_racing_realtime/","title":"Drone Racing Realtime","text":"<p>Interactive real-time visualization for drone racing.</p> <p>This module provides a PyQt5-based GUI for interactively solving and visualizing the drone racing trajectory optimization problem in real-time.</p> <p>File: <code>examples/realtime/drone_racing_realtime.py</code></p> <pre><code>import os\nimport sys\nimport threading\nimport time\n\nimport numpy as np\nimport pyqtgraph.opengl as gl\nfrom PyQt5.QtCore import QObject, Qt, QTimer, pyqtSignal\nfrom PyQt5.QtWidgets import (\n    QApplication,\n    QCheckBox,\n    QGridLayout,\n    QGroupBox,\n    QHBoxLayout,\n    QLabel,\n    QLineEdit,\n    QMainWindow,\n    QPushButton,\n    QScrollArea,\n    QVBoxLayout,\n    QWidget,\n)\nfrom pyqtgraph import Vector\nfrom pyqtgraph.opengl import GLViewWidget\n\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nfrom examples.drone.drone_racing import (\n    gate_center_params,\n    gen_vertices,\n    initial_gate_centers,\n    problem,\n)\n\n# Add the OpenSCvx path\n# Import the drone racing problem and parameters\nproblem.initialize()\n\n\nclass OptimizationWorker(QObject):\n    finished = pyqtSignal()\n    results_ready = pyqtSignal(dict)\n    metrics_updated = pyqtSignal(dict)\n\n    def __init__(self):\n        super().__init__()\n        self.running = False\n        self.reset_requested = False\n        self.problem = problem\n        self.gate_center_params = gate_center_params\n\n    def update_gate_position(self, gate_idx, x, y, z):\n        if 0 &lt;= gate_idx &lt; len(self.gate_center_params):\n            # User input now represents the actual center position (no offset needed)\n            new_center = np.array([x, y, z])\n            # Update gate center parameter value\n            self.gate_center_params[gate_idx].value = new_center\n            # Sync the parameter to the problem's parameter dictionary\n            param_name = self.gate_center_params[gate_idx].name\n            self.problem.parameters[param_name] = new_center\n\n    def run_optimization(self):\n        self.running = True\n        iteration = 0\n        while self.running:\n            try:\n                # Check if reset was requested\n                if self.reset_requested:\n                    self.problem.reset()\n                    self.reset_requested = False\n                    iteration = 0\n                    print(\"Problem reset to initial conditions\")\n\n                start_time = time.time()\n                step_result = self.problem.step()\n                solve_time = time.time() - start_time\n\n                # Build results dict for visualization\n                results = {\n                    \"iter\": step_result[\"scp_k\"] - 1,  # Display iteration (0-indexed)\n                    \"J_tr\": step_result[\"scp_J_tr\"],\n                    \"J_vb\": step_result[\"scp_J_vb\"],\n                    \"J_vc\": step_result[\"scp_J_vc\"],\n                    \"converged\": step_result[\"converged\"],\n                    \"solve_time\": solve_time * 1000,  # Convert to milliseconds\n                    \"V_multi_shoot\": self.problem.state.V_history[-1]\n                    if self.problem.state.V_history\n                    else [],\n                    \"x\": self.problem.state.x,  # Current state trajectory\n                    \"u\": self.problem.state.u,  # Current control trajectory\n                }\n\n                # Get timing from the print queue (emitted data) if available\n                try:\n                    if (\n                        hasattr(self.problem, \"print_queue\")\n                        and not self.problem.print_queue.empty()\n                    ):\n                        # Get the latest emitted data\n                        emitted_data = self.problem.print_queue.get_nowait()\n                        results[\"dis_time\"] = emitted_data.get(\"dis_time\", 0.0)\n                        results[\"prob_stat\"] = emitted_data.get(\"prob_stat\", \"--\")\n                        results[\"cost\"] = emitted_data.get(\"cost\", 0.0)\n                    else:\n                        results[\"dis_time\"] = 0.0\n                        results[\"prob_stat\"] = \"--\"\n                        results[\"cost\"] = 0.0\n                except Exception:\n                    results[\"dis_time\"] = 0.0\n                    results[\"prob_stat\"] = \"--\"\n                    results[\"cost\"] = 0.0\n                # Update vertices for visualization\n                radii = np.array([2.5, 1e-4, 2.5])\n                vertices = []\n                for center_param in self.gate_center_params:\n                    center = center_param.value\n                    if center is not None:\n                        vertices.append(gen_vertices(center, radii))\n                    else:\n                        vertices.append([])\n                results.update(\n                    {\n                        \"vertices\": vertices,\n                        \"gate_center_params\": self.gate_center_params,\n                    }\n                )\n                self.results_ready.emit(results)\n                # Emit metrics for compatibility\n                metrics = {\n                    \"iteration\": iteration,\n                    \"objective\": results.get(\"cost\", 0.0),\n                    \"solve_time\": solve_time,\n                    \"status\": results.get(\"prob_stat\", \"Unknown\"),\n                }\n                self.metrics_updated.emit(metrics)\n                iteration += 1\n                time.sleep(0.1)\n            except Exception as e:\n                print(f\"Optimization error: {e}\")\n                time.sleep(1.0)\n        self.finished.emit()\n\n\nclass DraggableGLViewWidget(GLViewWidget):\n    \"\"\"Custom GLViewWidget that supports manual camera interaction\"\"\"\n\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.manual_camera_interaction = False\n        self.camera_interaction_timer = None\n\n    def mousePressEvent(self, event):\n        # User is interacting with camera - disable auto-adjustment temporarily\n        self.manual_camera_interaction = True\n        if self.camera_interaction_timer:\n            self.camera_interaction_timer.stop()\n        self.camera_interaction_timer = QTimer()\n        self.camera_interaction_timer.timeout.connect(self.re_enable_auto_camera)\n        self.camera_interaction_timer.start(2000)  # Re-enable after 2 seconds\n        # Update status label\n        if hasattr(self.parent(), \"camera_status_label\"):\n            self.parent().camera_status_label.setText(\"Camera: Manual control (2s)\")\n            self.parent().camera_status_label.setStyleSheet(\"font-size: 10px; color: #ff6600;\")\n        super().mousePressEvent(event)\n\n    def re_enable_auto_camera(self):\n        \"\"\"Re-enable auto camera adjustment after manual interaction\"\"\"\n        self.manual_camera_interaction = False\n        if self.camera_interaction_timer:\n            self.camera_interaction_timer.stop()\n        # Update status label\n        if hasattr(self.parent(), \"camera_status_label\"):\n            self.parent().camera_status_label.setText(\"Camera: Auto-adjust enabled\")\n            self.parent().camera_status_label.setStyleSheet(\"font-size: 10px; color: #666;\")\n\n    def mouseMoveEvent(self, event):\n        # Only handle camera interaction, no gate dragging\n        super().mouseMoveEvent(event)\n\n    def mouseReleaseEvent(self, event):\n        super().mouseReleaseEvent(event)\n\n    def wheelEvent(self, event):\n        # Disable auto-camera during zoom\n        self.manual_camera_interaction = True\n        if self.camera_interaction_timer:\n            self.camera_interaction_timer.stop()\n        self.camera_interaction_timer = QTimer()\n        self.camera_interaction_timer.timeout.connect(self.re_enable_auto_camera)\n        self.camera_interaction_timer.start(2000)\n        # Update status label\n        if hasattr(self.parent(), \"camera_status_label\"):\n            self.parent().camera_status_label.setText(\"Camera: Manual control (2s)\")\n            self.parent().camera_status_label.setStyleSheet(\"font-size: 10px; color: #ff6600;\")\n        super().wheelEvent(event)\n\n\nclass DroneRacingGUI(QMainWindow):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle(\"Drone Racing Real-time Optimization\")\n        self.setGeometry(100, 100, 1400, 900)\n        # Setup the worker\n        self.worker = OptimizationWorker()\n        self.worker_thread = threading.Thread(target=self.worker.run_optimization)\n        self.worker.results_ready.connect(self.update_visualization)\n        self.worker.metrics_updated.connect(self.update_metrics)\n        # Setup GUI\n        self.setup_gui()\n        # Setup the problem and start optimization\n        # self.worker.setup_problem()\n        self.worker_thread.start()\n\n    def setup_gui(self):\n        \"\"\"Set up the GUI layout\"\"\"\n        central_widget = QWidget()\n        self.setCentralWidget(central_widget)\n        layout = QHBoxLayout(central_widget)\n        # Left panel for controls\n        left_panel = QWidget()\n        left_layout = QVBoxLayout()\n        # Title\n        title = QLabel(\"Drone Racing Control\")\n        title.setStyleSheet(\"font-weight: bold; font-size: 14px;\")\n        left_layout.addWidget(title)\n        # Optimization Metrics Display\n        metrics_group = QGroupBox(\"Optimization Metrics\")\n        metrics_layout = QVBoxLayout()\n        metrics_group.setLayout(metrics_layout)\n        # Create labels for each metric\n        self.iter_label = QLabel(\"Iteration: 0\")\n        self.j_tr_label = QLabel(\"J_tr: 0.00E+00\")\n        self.j_vb_label = QLabel(\"J_vb: 0.00E+00\")\n        self.j_vc_label = QLabel(\"J_vc: 0.00E+00\")\n        self.objective_label = QLabel(\"Objective: 0.00E+00\")\n        self.lam_cost_display_label = QLabel(\n            f\"\u03bb_cost: {self.worker.problem.settings.scp.lam_cost:.2E}\"\n        )\n        self.dis_time_label = QLabel(\"Dis Time: 0.0ms\")\n        self.solve_time_label = QLabel(\"Solve Time: 0.0ms\")\n        self.status_label = QLabel(\"Status: --\")\n        # Style the labels\n        for label in [\n            self.iter_label,\n            self.j_tr_label,\n            self.j_vb_label,\n            self.j_vc_label,\n            self.objective_label,\n            self.lam_cost_display_label,\n            self.dis_time_label,\n            self.solve_time_label,\n            self.status_label,\n        ]:\n            label.setStyleSheet(\"font-family: monospace; font-size: 11px; padding: 2px;\")\n            metrics_layout.addWidget(label)\n        left_layout.addWidget(metrics_group)\n        # Optimization Weights\n        weights_group = QGroupBox(\"Optimization Weights\")\n        weights_layout = QVBoxLayout()\n        weights_group.setLayout(weights_layout)\n        # Lambda cost input - Input on left, label on right\n        lam_cost_layout = QHBoxLayout()\n        self.lam_cost_input = QLineEdit()\n        self.lam_cost_input.setText(f\"{self.worker.problem.settings.scp.lam_cost:.2E}\")\n        self.lam_cost_input.setFixedWidth(80)\n        self.lam_cost_input.returnPressed.connect(\n            lambda: self.on_lam_cost_changed(self.lam_cost_input)\n        )\n        lam_cost_label = QLabel(\"\u03bb_cost:\")\n        lam_cost_label.setAlignment(Qt.AlignLeft)\n        lam_cost_layout.addWidget(self.lam_cost_input)\n        lam_cost_layout.addWidget(lam_cost_label)\n        lam_cost_layout.addStretch()  # Push everything to the left\n        weights_layout.addLayout(lam_cost_layout)\n        # Lambda trust region input - Input on left, label on right\n        lam_tr_layout = QHBoxLayout()\n        self.lam_tr_input = QLineEdit()\n        self.lam_tr_input.setText(f\"{self.worker.problem.settings.scp.w_tr:.2E}\")\n        self.lam_tr_input.setFixedWidth(80)\n        self.lam_tr_input.returnPressed.connect(lambda: self.on_lam_tr_changed(self.lam_tr_input))\n        lam_tr_label = QLabel(\"\u03bb_tr:\")\n        lam_tr_label.setAlignment(Qt.AlignLeft)\n        lam_tr_layout.addWidget(self.lam_tr_input)\n        lam_tr_layout.addWidget(lam_tr_label)\n        lam_tr_layout.addStretch()  # Push everything to the left\n        weights_layout.addLayout(lam_tr_layout)\n        left_layout.addWidget(weights_group)\n        # Camera Controls\n        camera_group = QGroupBox(\"Camera Controls\")\n        camera_layout = QVBoxLayout()\n        camera_group.setLayout(camera_layout)\n        camera_reset_button = QPushButton(\"Reset Camera View\")\n        camera_reset_button.clicked.connect(self.reset_camera_view)\n        camera_layout.addWidget(camera_reset_button)\n        # Add auto-camera checkbox\n        self.auto_camera_checkbox = QCheckBox(\"Auto-adjust camera to trajectory\")\n        self.auto_camera_checkbox.setChecked(True)\n        camera_layout.addWidget(self.auto_camera_checkbox)\n        # Add status indicator for manual camera interaction\n        self.camera_status_label = QLabel(\"Camera: Auto-adjust enabled\")\n        self.camera_status_label.setStyleSheet(\"font-size: 10px; color: #666;\")\n        camera_layout.addWidget(self.camera_status_label)\n        left_layout.addWidget(camera_group)\n        # Problem Control\n        problem_control_group = QGroupBox(\"Problem Control\")\n        problem_control_layout = QVBoxLayout()\n        problem_control_group.setLayout(problem_control_layout)\n        reset_problem_button = QPushButton(\"Reset Problem\")\n        reset_problem_button.clicked.connect(self.reset_problem)\n        problem_control_layout.addWidget(reset_problem_button)\n        left_layout.addWidget(problem_control_group)\n        # Gate Controls\n        gate_group = QGroupBox(\"Gate Positions\")\n        gate_layout = QVBoxLayout()\n        gate_group.setLayout(gate_layout)\n        # Reset button for gates\n        reset_gates_button = QPushButton(\"Reset Gate Positions\")\n        reset_gates_button.clicked.connect(self.reset_gate_positions)\n        gate_layout.addWidget(reset_gates_button)\n        # Scrollable area for gate controls\n        scroll_area = QScrollArea()\n        scroll_area.setWidgetResizable(True)\n        scroll_area.setMaximumHeight(300)\n        scroll_content = QWidget()\n        scroll_layout = QVBoxLayout()\n        self.gate_controls = []\n        for i in range(10):  # 10 gates\n            gate_control_group = QWidget()\n            gate_control_layout = QGridLayout(gate_control_group)\n            gate_label = QLabel(f\"Gate {i + 1}\")\n            gate_control_layout.addWidget(gate_label, 0, 0, 1, 3)\n            # X, Y, Z text inputs\n            x_input = QLineEdit()\n            x_input.setFixedWidth(60)\n            # Show actual center position (with offset) to user\n            actual_center = self.worker.gate_center_params[i].value\n            x_input.setText(str(actual_center[0]))\n            x_input.editingFinished.connect(\n                lambda gate_idx=i, field=x_input: self.update_gate_x_text(gate_idx, field)\n            )\n            y_input = QLineEdit()\n            y_input.setFixedWidth(60)\n            y_input.setText(str(actual_center[1]))\n            y_input.editingFinished.connect(\n                lambda gate_idx=i, field=y_input: self.update_gate_y_text(gate_idx, field)\n            )\n            z_input = QLineEdit()\n            z_input.setFixedWidth(60)\n            z_input.setText(str(actual_center[2]))\n            z_input.editingFinished.connect(\n                lambda gate_idx=i, field=z_input: self.update_gate_z_text(gate_idx, field)\n            )\n            gate_control_layout.addWidget(QLabel(\"X:\"), 1, 0)\n            gate_control_layout.addWidget(x_input, 1, 1)\n            gate_control_layout.addWidget(QLabel(\"Y:\"), 2, 0)\n            gate_control_layout.addWidget(y_input, 2, 1)\n            gate_control_layout.addWidget(QLabel(\"Z:\"), 3, 0)\n            gate_control_layout.addWidget(z_input, 3, 1)\n            self.gate_controls.append((x_input, y_input, z_input))\n            scroll_layout.addWidget(gate_control_group)\n        scroll_layout.addStretch()\n        scroll_content.setLayout(scroll_layout)\n        scroll_area.setWidget(scroll_content)\n        gate_layout.addWidget(scroll_area)\n        left_layout.addWidget(gate_group)\n        left_layout.addStretch()\n        left_panel.setLayout(left_layout)\n        layout.addWidget(left_panel, 1)\n        # 3D visualization\n        self.gl_widget = DraggableGLViewWidget()\n        self.gl_widget.setCameraPosition(distance=150, elevation=30, azimuth=45)\n        # Set the camera center separately\n        self.gl_widget.opts[\"center\"] = Vector(100, -50, 20)\n        # Add grid\n        grid = gl.GLGridItem()\n        grid.setSize(200, 100)  # Match the fixed bounds: x (0,200), y (-100,0)\n        grid.setSpacing(20, 20)\n        self.gl_widget.addItem(grid)\n        self.grid_item = grid  # Store reference for updates\n        # Initialize visualization objects\n        self.trajectory_plot = gl.GLScatterPlotItem(color=(1, 1, 0, 1), size=5)\n        self.gl_widget.addItem(self.trajectory_plot)\n        self.gate_plots = []\n        for i in range(10):\n            gate_plot = gl.GLLinePlotItem(color=(0, 1, 0, 1), width=3)\n            self.gl_widget.addItem(gate_plot)\n            self.gate_plots.append(gate_plot)\n        layout.addWidget(self.gl_widget, 3)\n\n    def update_gate_x_text(self, gate_idx, field):\n        try:\n            value = float(field.text())\n            current_pos = self.worker.gate_center_params[gate_idx].value\n            self.worker.update_gate_position(gate_idx, value, current_pos[1], current_pos[2])\n        except Exception as e:\n            print(f\"Invalid X input for gate {gate_idx}: {e}\")\n\n    def update_gate_y_text(self, gate_idx, field):\n        try:\n            value = float(field.text())\n            current_pos = self.worker.gate_center_params[gate_idx].value\n            self.worker.update_gate_position(gate_idx, current_pos[0], value, current_pos[2])\n        except Exception as e:\n            print(f\"Invalid Y input for gate {gate_idx}: {e}\")\n\n    def update_gate_z_text(self, gate_idx, field):\n        try:\n            value = float(field.text())\n            current_pos = self.worker.gate_center_params[gate_idx].value\n            self.worker.update_gate_position(gate_idx, current_pos[0], current_pos[1], value)\n        except Exception as e:\n            print(f\"Invalid Z input for gate {gate_idx}: {e}\")\n\n    def update_visualization(self, results):\n        \"\"\"Update the 3D visualization with new results\"\"\"\n        try:\n            # Update optimization metrics display\n            self.update_optimization_metrics(results)\n            # Trajectory extraction\n            if \"V_multi_shoot\" in results:\n                try:\n                    V_multi_shoot = np.array(results[\"V_multi_shoot\"])\n                    n_x = self.worker.problem.settings.sim.n_states\n                    n_u = self.worker.problem.settings.sim.n_controls\n                    i1 = n_x\n                    i2 = i1 + n_x * n_x\n                    i3 = i2 + n_x * n_u\n                    i4 = i3 + n_x * n_u\n                    all_pos_segments = []\n                    for i_node in range(V_multi_shoot.shape[1]):\n                        node_data = V_multi_shoot[:, i_node]\n                        segments_for_node = node_data.reshape(-1, i4)\n                        pos_segments = segments_for_node[:, :3]\n                        all_pos_segments.append(pos_segments)\n                    if all_pos_segments:\n                        full_traj = np.vstack(all_pos_segments)\n                        self.trajectory_plot.setData(pos=full_traj)\n                        # Auto-adjust camera to fit trajectory bounds\n                        if self.auto_camera_checkbox.isChecked():\n                            self.adjust_camera_to_trajectory(full_traj)\n                except Exception as e:\n                    print(f\"Trajectory extraction error: {e}\")\n            # Gate plotting (always runs)\n            if \"vertices\" in results:\n                for i, vertices in enumerate(results[\"vertices\"]):\n                    if i &lt; len(self.gate_plots) and vertices is not None and len(vertices) &gt;= 4:\n                        try:\n                            # Plot a line through the vertices of the gate\n                            closed_vertices = np.vstack([vertices, vertices[0]])\n                            self.gate_plots[i].setData(pos=closed_vertices)\n                        except Exception as e:\n                            print(f\"Gate plotting error for gate {i}: {e}\")\n                    elif i &lt; len(self.gate_plots):\n                        self.gate_plots[i].setData(pos=np.zeros((0, 3)))\n        except Exception as e:\n            print(f\"Error in update_visualization: {e}\")\n\n    def adjust_camera_to_trajectory(self, trajectory):\n        \"\"\"Automatically adjust camera to fit trajectory bounds with fixed x,y bounds\"\"\"\n        try:\n            # Skip auto-adjustment if user is manually interacting with camera\n            if (\n                hasattr(self.gl_widget, \"manual_camera_interaction\")\n                and self.gl_widget.manual_camera_interaction\n            ):\n                return\n            if trajectory is None or len(trajectory) == 0:\n                return\n            # Use fixed bounds for x and y, calculate z from trajectory\n            min_x, max_x = 0, 200\n            min_y, max_y = -100, 0\n            # Calculate z bounds from trajectory\n            min_z = np.min(trajectory[:, 2])\n            max_z = np.max(trajectory[:, 2])\n            # Add padding to z bounds\n            padding_z = 10.0\n            min_z -= padding_z\n            max_z += padding_z\n            # Calculate center and size\n            center = np.array([(min_x + max_x) / 2, (min_y + max_y) / 2, (min_z + max_z) / 2])\n            size_x = max_x - min_x\n            size_y = max_y - min_y\n            size_z = max_z - min_z\n            max_size = max(size_x, size_y, size_z)\n            # Set camera distance based on the largest dimension\n            distance = max_size * 1.2\n            # Update camera position\n            self.gl_widget.setCameraPosition(distance=distance, elevation=30, azimuth=45)\n            # Set the camera center separately\n            self.gl_widget.opts[\"center\"] = Vector(center[0], center[1], center[2])\n            # Update grid size to match the fixed bounds\n            grid_size_x = size_x\n            grid_size_y = size_y\n            grid_spacing = 20  # Fixed spacing for better readability\n            # Update the grid\n            if hasattr(self, \"grid_item\"):\n                self.grid_item.setSize(grid_size_x, grid_size_y)\n                self.grid_item.setSpacing(grid_spacing, grid_spacing)\n        except Exception as e:\n            print(f\"Error adjusting camera: {e}\")\n\n    def on_lam_cost_changed(self, input_widget):\n        \"\"\"Handle lambda cost input changes\"\"\"\n        # Extract the new value from the input widget\n        new_value = input_widget.text()\n        try:\n            # Convert the new value to a float\n            lam_cost_value = float(new_value)\n            self.worker.problem.settings.scp.lam_cost = lam_cost_value\n            # Update the display with scientific notation\n            input_widget.setText(f\"{lam_cost_value:.2E}\")\n        except ValueError:\n            print(\"Invalid input. Please enter a valid number.\")\n\n    def on_lam_tr_changed(self, input_widget):\n        \"\"\"Handle lambda trust region input changes\"\"\"\n        # Extract the new value from the input widget\n        new_value = input_widget.text()\n        try:\n            # Convert the new value to a float\n            lam_tr_value = float(new_value)\n            self.worker.problem.settings.scp.w_tr = lam_tr_value\n            # Update the display with scientific notation\n            input_widget.setText(f\"{lam_tr_value:.2E}\")\n        except ValueError:\n            print(\"Invalid input. Please enter a valid number.\")\n\n    def update_optimization_metrics(self, results):\n        \"\"\"Update the optimization metrics display\"\"\"\n        if results is None:\n            return\n        # Extract metrics from results\n        iter_num = results.get(\"iter\", 0)\n        j_tr = results.get(\"J_tr\", 0.0)\n        j_vb = results.get(\"J_vb\", 0.0)\n        j_vc = results.get(\"J_vc\", 0.0)\n        cost = results.get(\"cost\", 0.0)\n        status = results.get(\"prob_stat\", \"--\")\n        # Get timing information\n        dis_time = results.get(\"dis_time\", 0.0)\n        solve_time = results.get(\"solve_time\", 0.0)\n        # Update labels\n        self.iter_label.setText(f\"Iteration: {iter_num}\")\n        self.j_tr_label.setText(f\"J_tr: {j_tr:.2E}\")\n        self.j_vb_label.setText(f\"J_vb: {j_vb:.2E}\")\n        self.j_vc_label.setText(f\"J_vc: {j_vc:.2E}\")\n        self.objective_label.setText(f\"Objective: {cost:.2E}\")\n        self.lam_cost_display_label.setText(\n            f\"\u03bb_cost: {self.worker.problem.settings.scp.lam_cost:.2E}\"\n        )\n        self.dis_time_label.setText(f\"Dis Time: {dis_time:.1f}ms\")\n        self.solve_time_label.setText(f\"Solve Time: {solve_time:.1f}ms\")\n        self.status_label.setText(f\"Status: {status}\")\n\n    def update_metrics(self, metrics):\n        \"\"\"Update the metrics display - kept for compatibility\"\"\"\n        # This method is kept for compatibility but the main update is done\n        # in update_optimization_metrics\n        pass\n\n    def reset_problem(self):\n        \"\"\"Reset the optimization problem\"\"\"\n        self.worker.reset_requested = True\n        print(\"Problem reset requested\")\n\n    def reset_gate_positions(self):\n        \"\"\"Reset gate positions to their original values\"\"\"\n        for i in range(10):\n            original_center = initial_gate_centers[i]\n            self.worker.update_gate_position(\n                i, original_center[0], original_center[1], original_center[2]\n            )\n            # Update text inputs\n            if i &lt; len(self.gate_controls):\n                x_input, y_input, z_input = self.gate_controls[i]\n                x_input.setText(f\"{original_center[0]:.2f}\")\n                y_input.setText(f\"{original_center[1]:.2f}\")\n                z_input.setText(f\"{original_center[2]:.2f}\")\n\n    def reset_camera_view(self):\n        \"\"\"Reset the camera view to default\"\"\"\n        self.gl_widget.setCameraPosition(distance=150, elevation=30, azimuth=45)\n\n    def closeEvent(self, event):\n        \"\"\"Clean up when closing the window\"\"\"\n        self.worker.running = False\n        if self.worker_thread.is_alive():\n            self.worker_thread.join()\n        event.accept()\n\n\nif __name__ == \"__main__\":\n    app = QApplication(sys.argv)\n    window = DroneRacingGUI()\n    window.show()\n    sys.exit(app.exec_())\n</code></pre>"},{"location":"examples/realtime/dubins_car_realtime/","title":"Dubins Car Realtime","text":"<p>Interactive real-time visualization for Dubins car path planning.</p> <p>This module provides a PyQt5-based GUI for interactively solving and visualizing the Dubins car trajectory optimization problem in real-time.</p> <p>File: <code>examples/realtime/dubins_car_realtime.py</code></p> <pre><code>import os\nimport sys\nimport threading\n\nimport numpy as np\nimport pyqtgraph as pg\nfrom PyQt5.QtCore import Qt, QTimer\nfrom PyQt5.QtWidgets import (\n    QApplication,\n    QGraphicsEllipseItem,\n    QGroupBox,\n    QHBoxLayout,\n    QLabel,\n    QLineEdit,\n    QPushButton,\n    QVBoxLayout,\n    QWidget,\n)\n\nsys.path.append(os.path.join(os.path.dirname(__file__), \"..\"))\n\nfrom car.dubins_car import (\n    # --- Import your problem setup ---\n    plotting_dict,\n    problem,\n)\n\n# --- Shared state for plotting ---\nrunning = {\"stop\": False}\nreset_requested = {\"reset\": False}\nlatest_results = {\"results\": None}\nnew_result_event = threading.Event()\n\n\n# --- Key press handler for obstacle movement ---\ndef on_key(event):\n    step = 0.1\n    if event.key == \"up\":\n        problem.parameters[\"obs_center\"][1] += step\n    elif event.key == \"down\":\n        problem.parameters[\"obs_center\"][1] -= step\n    elif event.key == \"left\":\n        problem.parameters[\"obs_center\"][0] -= step\n    elif event.key == \"right\":\n        problem.parameters[\"obs_center\"][0] += step\n    elif event.key == \"escape\":\n        running[\"stop\"] = True\n\n\n# --- Optimization loop to run in background thread ---\ndef optimization_loop():\n    problem.initialize()\n    print(\"Optimization loop started...\")\n    iteration = 0\n    try:\n        while not running[\"stop\"]:\n            # Check if reset was requested\n            if reset_requested[\"reset\"]:\n                problem.reset()\n                reset_requested[\"reset\"] = False\n                iteration = 0\n                print(\"Problem reset to initial conditions\")\n\n            # Perform a single SCP step (automatically warm-starts from previous iteration)\n            print(f\"Starting iteration {iteration}...\")\n            step_result = problem.step()\n            iteration += 1\n\n            # Build results dict for visualization\n            results = {\n                \"iter\": step_result[\"scp_k\"] - 1,  # Display iteration (0-indexed)\n                \"J_tr\": step_result[\"scp_J_tr\"],\n                \"J_vb\": step_result[\"scp_J_vb\"],\n                \"J_vc\": step_result[\"scp_J_vc\"],\n                \"converged\": step_result[\"converged\"],\n                \"V_multi_shoot\": problem.state.V_history[-1] if problem.state.V_history else [],\n                \"x\": problem.state.x,  # Current state trajectory\n                \"u\": problem.state.u,  # Current control trajectory\n            }\n\n            # Get timing from the print queue (emitted data)\n            try:\n                if hasattr(problem, \"print_queue\") and not problem.print_queue.empty():\n                    # Get the latest emitted data\n                    emitted_data = problem.print_queue.get_nowait()\n                    results[\"dis_time\"] = emitted_data.get(\"dis_time\", 0.0)\n                    results[\"solve_time\"] = emitted_data.get(\"subprop_time\", 0.0)\n                    results[\"prob_stat\"] = emitted_data.get(\"prob_stat\", \"--\")\n                    results[\"cost\"] = emitted_data.get(\"cost\", 0.0)\n                else:\n                    results[\"dis_time\"] = 0.0\n                    results[\"solve_time\"] = 0.0\n                    results[\"prob_stat\"] = \"--\"\n                    results[\"cost\"] = 0.0\n            except Exception:\n                results[\"dis_time\"] = 0.0\n                results[\"solve_time\"] = 0.0\n                results[\"prob_stat\"] = \"--\"\n                results[\"cost\"] = 0.0\n\n            # Print iteration info to CLI\n            print(\n                f\"Iteration {iteration}: J_tr={results['J_tr']:.2e}, J_vb={results['J_vb']:.2e}, \"\n                f\"J_vc={results['J_vc']:.2e}, Cost={results['cost']:.2e}, \"\n                f\"Status={results['prob_stat']}\"\n            )\n\n            results.update(plotting_dict)\n            latest_results[\"results\"] = results\n            new_result_event.set()\n            # Check for convergence to optionally stop\n            # if results['converged']:\n            #     print(\"Converged!\")\n            #     # maybe sleep or stop here\n    except KeyboardInterrupt:\n        running[\"stop\"] = True\n        print(\"Stopped by user.\")\n    except Exception as e:\n        print(f\"Error in optimization loop: {e}\")\n        import traceback\n\n        traceback.print_exc()\n        running[\"stop\"] = True\n\n\nclass ObstaclePlotWidget(pg.PlotWidget):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.dragging = False\n\n    def keyPressEvent(self, event):\n        step = 0.1\n        if event.key() == Qt.Key_Up:\n            problem.parameters[\"obs_center\"][1] += step\n        elif event.key() == Qt.Key_Down:\n            problem.parameters[\"obs_center\"][1] -= step\n        elif event.key() == Qt.Key_Left:\n            problem.parameters[\"obs_center\"][0] -= step\n        elif event.key() == Qt.Key_Right:\n            problem.parameters[\"obs_center\"][0] += step\n        elif event.key() == Qt.Key_Escape:\n            running[\"stop\"] = True\n        super().keyPressEvent(event)\n\n    def mousePressEvent(self, event):\n        pos = self.plotItem.vb.mapSceneToView(event.pos())\n        mouse_x, mouse_y = pos.x(), pos.y()\n        dx = mouse_x - problem.parameters[\"obs_center\"][0]\n        dy = mouse_y - problem.parameters[\"obs_center\"][1]\n        if dx**2 + dy**2 &lt;= problem.parameters[\"obs_radius\"] ** 2:\n            self.dragging = True\n            # Do NOT call super() if starting drag (prevents plot pan)\n        else:\n            super().mousePressEvent(event)\n\n    def mouseMoveEvent(self, event):\n        if self.dragging:\n            pos = self.plotItem.vb.mapSceneToView(event.pos())\n            problem.parameters[\"obs_center\"][0] = pos.x()\n            problem.parameters[\"obs_center\"][1] = pos.y()\n            # Do NOT call super() if dragging (prevents plot pan)\n        else:\n            super().mouseMoveEvent(event)\n\n    def mouseReleaseEvent(self, event):\n        if self.dragging:\n            self.dragging = False\n            # Do NOT call super() if ending drag (prevents plot pan)\n        else:\n            super().mouseReleaseEvent(event)\n\n\ndef on_lam_cost_changed(input_widget):\n    \"\"\"Handle lambda cost input changes\"\"\"\n    # Extract the new value from the input widget\n    new_value = input_widget.text()\n    try:\n        # Convert the new value to a float\n        lam_cost_value = float(new_value)\n        problem.settings.scp.lam_cost = lam_cost_value\n        # Update the display with scientific notation\n        input_widget.setText(f\"{lam_cost_value:.2E}\")\n    except ValueError:\n        print(\"Invalid input. Please enter a valid number.\")\n\n\ndef on_lam_tr_changed(input_widget):\n    \"\"\"Handle lambda trust region input changes\"\"\"\n    # Extract the new value from the input widget\n    new_value = input_widget.text()\n    try:\n        # Convert the new value to a float\n        lam_tr_value = float(new_value)\n        problem.settings.scp.w_tr = lam_tr_value\n        # Update the display with scientific notation\n        input_widget.setText(f\"{lam_tr_value:.2E}\")\n    except ValueError:\n        print(\"Invalid input. Please enter a valid number.\")\n\n\ndef on_reset_clicked():\n    \"\"\"Handle reset button click\"\"\"\n    reset_requested[\"reset\"] = True\n    print(\"Problem reset requested\")\n\n\ndef update_optimization_metrics(results, labels_dict):\n    \"\"\"Update the optimization metrics display\"\"\"\n    if results is None:\n        return\n    # Extract metrics from results\n    iter_num = results.get(\"iter\", 0)\n    j_tr = results.get(\"J_tr\", 0.0)\n    j_vb = results.get(\"J_vb\", 0.0)\n    j_vc = results.get(\"J_vc\", 0.0)\n    cost = results.get(\"cost\", 0.0)\n    status = results.get(\"prob_stat\", \"--\")\n    # Get timing information (these would need to be tracked separately)\n    dis_time = results.get(\"dis_time\", 0.0)\n    solve_time = results.get(\"solve_time\", 0.0)\n    # Update labels\n    labels_dict[\"iter_label\"].setText(f\"Iteration: {iter_num}\")\n    labels_dict[\"j_tr_label\"].setText(f\"J_tr: {j_tr:.2E}\")\n    labels_dict[\"j_vb_label\"].setText(f\"J_vb: {j_vb:.2E}\")\n    labels_dict[\"j_vc_label\"].setText(f\"J_vc: {j_vc:.2E}\")\n    labels_dict[\"objective_label\"].setText(f\"Objective: {cost:.2E}\")\n    labels_dict[\"lam_cost_display_label\"].setText(f\"\u03bb_cost: {problem.settings.scp.lam_cost:.2E}\")\n    labels_dict[\"dis_time_label\"].setText(f\"Dis Time: {dis_time:.1f}ms\")\n    labels_dict[\"solve_time_label\"].setText(f\"Solve Time: {solve_time:.1f}ms\")\n    labels_dict[\"status_label\"].setText(f\"Status: {status}\")\n\n\ndef plot_thread_func():\n    # Initialize PyQtGraph\n    app = QApplication.instance()\n    if app is None:\n        app = QApplication([])\n    # Create main window\n    main_widget = QWidget()\n    main_widget.setWindowTitle(\"Dubins Car Real-time Trajectory\")\n    main_layout = QHBoxLayout()\n    main_widget.setLayout(main_layout)\n    # Create plot window using the custom widget\n    plot_widget = ObstaclePlotWidget()\n    plot_widget.setLabel(\"left\", \"Y Position\")\n    plot_widget.setLabel(\"bottom\", \"X Position\")\n    # Create control panel\n    control_panel = QWidget()\n    control_layout = QVBoxLayout()\n    control_panel.setLayout(control_layout)\n    # Title\n    title = QLabel(\"Dubins Car Control\")\n    title.setStyleSheet(\"font-weight: bold; font-size: 14px;\")\n    control_layout.addWidget(title)\n    # Optimization Metrics Display\n    metrics_group = QGroupBox(\"Optimization Metrics\")\n    metrics_layout = QVBoxLayout()\n    metrics_group.setLayout(metrics_layout)\n    # Create labels for each metric\n    iter_label = QLabel(\"Iteration: 0\")\n    j_tr_label = QLabel(\"J_tr: 0.00E+00\")\n    j_vb_label = QLabel(\"J_vb: 0.00E+00\")\n    j_vc_label = QLabel(\"J_vc: 0.00E+00\")\n    objective_label = QLabel(\"Objective: 0.00E+00\")\n    lam_cost_display_label = QLabel(f\"\u03bb_cost: {problem.settings.scp.lam_cost:.2E}\")\n    dis_time_label = QLabel(\"Dis Time: 0.0ms\")\n    solve_time_label = QLabel(\"Solve Time: 0.0ms\")\n    status_label = QLabel(\"Status: --\")\n    # Style the labels\n    for label in [\n        iter_label,\n        j_tr_label,\n        j_vb_label,\n        j_vc_label,\n        objective_label,\n        lam_cost_display_label,\n        dis_time_label,\n        solve_time_label,\n        status_label,\n    ]:\n        label.setStyleSheet(\"font-family: monospace; font-size: 11px; padding: 2px;\")\n        metrics_layout.addWidget(label)\n    # Create labels dictionary for metrics update\n    labels_dict = {\n        \"iter_label\": iter_label,\n        \"j_tr_label\": j_tr_label,\n        \"j_vb_label\": j_vb_label,\n        \"j_vc_label\": j_vc_label,\n        \"objective_label\": objective_label,\n        \"lam_cost_display_label\": lam_cost_display_label,\n        \"dis_time_label\": dis_time_label,\n        \"solve_time_label\": solve_time_label,\n        \"status_label\": status_label,\n    }\n    control_layout.addWidget(metrics_group)\n    # Optimization Weights\n    weights_group = QGroupBox(\"Optimization Weights\")\n    weights_layout = QVBoxLayout()\n    weights_group.setLayout(weights_layout)\n    # Lambda cost input - Input on left, label on right\n    lam_cost_layout = QHBoxLayout()\n    lam_cost_input = QLineEdit()\n    lam_cost_input.setText(f\"{problem.settings.scp.lam_cost:.2E}\")\n    lam_cost_input.setFixedWidth(80)\n    lam_cost_input.returnPressed.connect(lambda: on_lam_cost_changed(lam_cost_input))\n    lam_cost_label = QLabel(\"\u03bb_cost:\")\n    lam_cost_label.setAlignment(Qt.AlignLeft)\n    lam_cost_layout.addWidget(lam_cost_input)\n    lam_cost_layout.addWidget(lam_cost_label)\n    lam_cost_layout.addStretch()  # Push everything to the left\n    weights_layout.addLayout(lam_cost_layout)\n    # Lambda trust region input - Input on left, label on right\n    lam_tr_layout = QHBoxLayout()\n    lam_tr_input = QLineEdit()\n    lam_tr_input.setText(f\"{problem.settings.scp.w_tr:.2E}\")\n    lam_tr_input.setFixedWidth(80)\n    lam_tr_input.returnPressed.connect(lambda: on_lam_tr_changed(lam_tr_input))\n    lam_tr_label = QLabel(\"\u03bb_tr:\")\n    lam_tr_label.setAlignment(Qt.AlignLeft)\n    lam_tr_layout.addWidget(lam_tr_input)\n    lam_tr_layout.addWidget(lam_tr_label)\n    lam_tr_layout.addStretch()  # Push everything to the left\n    weights_layout.addLayout(lam_tr_layout)\n    control_layout.addWidget(weights_group)\n    # Problem Control\n    problem_control_group = QGroupBox(\"Problem Control\")\n    problem_control_layout = QVBoxLayout()\n    problem_control_group.setLayout(problem_control_layout)\n    reset_problem_button = QPushButton(\"Reset Problem\")\n    reset_problem_button.clicked.connect(lambda: on_reset_clicked())\n    problem_control_layout.addWidget(reset_problem_button)\n    control_layout.addWidget(problem_control_group)\n    control_layout.addStretch()\n    # Add widgets to main layout\n    main_layout.addWidget(plot_widget, stretch=3)\n    main_layout.addWidget(control_panel, stretch=1)\n    main_widget.resize(800, 600)\n    main_widget.show()\n    # Create scatter plot item for trajectory\n    traj_scatter = pg.ScatterPlotItem(pen=None, symbol=\"o\", size=5, brush=\"b\")\n    plot_widget.addItem(traj_scatter)\n    # Create circle for obstacle with true radius\n    obs_circle = QGraphicsEllipseItem(\n        problem.parameters[\"obs_center\"][0] - problem.parameters[\"obs_radius\"],\n        problem.parameters[\"obs_center\"][1] - problem.parameters[\"obs_radius\"],\n        problem.parameters[\"obs_radius\"] * 2,\n        problem.parameters[\"obs_radius\"] * 2,\n    )\n    obs_circle.setPen(pg.mkPen(\"g\", width=2))\n    obs_circle.setBrush(pg.mkBrush(0, 255, 0, 60))\n    plot_widget.addItem(obs_circle)\n    # Set initial plot limits\n    plot_widget.setXRange(-2, 2)\n    plot_widget.setYRange(-2, 2)\n    # Update timer\n    timer = QTimer()\n\n    def update_plot():\n        if latest_results[\"results\"] is not None:\n            try:\n                V_multi_shoot = np.array(latest_results[\"results\"][\"V_multi_shoot\"])\n                n_x = problem.settings.sim.n_states\n                n_u = problem.settings.sim.n_controls\n                i1 = n_x\n                i2 = i1 + n_x * n_x\n                i3 = i2 + n_x * n_u\n                i4 = i3 + n_x * n_u\n                all_pos_segments = []\n                for i_node in range(V_multi_shoot.shape[1]):\n                    node_data = V_multi_shoot[:, i_node]\n                    segments_for_node = node_data.reshape(-1, i4)\n                    pos_segments = segments_for_node[:, :2]\n                    all_pos_segments.append(pos_segments)\n                if all_pos_segments:\n                    full_traj = np.vstack(all_pos_segments)\n                    traj_scatter.setData(full_traj[:, 0], full_traj[:, 1])\n                # Update obstacle circle position\n                obs_circle.setRect(\n                    problem.parameters[\"obs_center\"][0] - problem.parameters[\"obs_radius\"],\n                    problem.parameters[\"obs_center\"][1] - problem.parameters[\"obs_radius\"],\n                    problem.parameters[\"obs_radius\"] * 2,\n                    problem.parameters[\"obs_radius\"] * 2,\n                )\n                # Update optimization metrics display\n                update_optimization_metrics(latest_results[\"results\"], labels_dict)\n            except Exception as e:\n                print(f\"Plot update error: {e}\")\n                if \"x\" in latest_results[\"results\"]:\n                    x_traj = latest_results[\"results\"][\"x\"]  # Now a numpy array\n                    traj_scatter.setData(x_traj[:, 0], x_traj[:, 1])\n\n    timer.timeout.connect(update_plot)\n    timer.start(50)\n    app.exec_()\n\n\nif __name__ == \"__main__\":\n    # Start optimization thread\n    opt_thread = threading.Thread(target=optimization_loop)\n    opt_thread.daemon = True\n    opt_thread.start()\n    # Start plotting in main thread\n    plot_thread_func()\n</code></pre>"},{"location":"examples/realtime/obstacle_avoidance_realtime/","title":"Obstacle Avoidance Realtime","text":"<p>Interactive real-time visualization for drone obstacle avoidance.</p> <p>This module provides a PyQt5-based GUI for interactively solving and visualizing the drone obstacle avoidance trajectory optimization problem in real-time.</p> <p>File: <code>examples/realtime/obstacle_avoidance_realtime.py</code></p> <pre><code>import os\nimport sys\nimport threading\nimport time\n\nimport numpy as np\nfrom PyQt5.QtCore import Qt, QTimer\nfrom PyQt5.QtWidgets import (\n    QApplication,\n    QGroupBox,\n    QHBoxLayout,\n    QLabel,\n    QLineEdit,\n    QPushButton,\n    QSlider,\n    QVBoxLayout,\n    QWidget,\n)\n\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nfrom examples.drone.obstacle_avoidance_realtime_base import (\n    obstacle_centers,\n    plotting_dict,\n    problem,\n)\n\n# Import PyQtGraph OpenGL modules\ntry:\n    from pyqtgraph.opengl import (\n        GLGridItem,\n        GLMeshItem,\n        GLScatterPlotItem,\n        GLViewWidget,\n        MeshData,\n    )\n\n    HAS_OPENGL = True\nexcept ImportError:\n    print(\"PyQtGraph OpenGL not available, falling back to 2D\")\n    HAS_OPENGL = False\nrunning = {\"stop\": False}\nreset_requested = {\"reset\": False}\nlatest_results = {\"results\": None}\nnew_result_event = threading.Event()\n\n\nclass Obstacle3DPlotWidget(QWidget):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Use axes and radii from plotting_dict (from obstacle_avoidance.py)\n        self.ellipsoid_axes = plotting_dict[\"obstacles_axes\"]\n        self.ellipsoid_radii = plotting_dict[\"obstacles_radii\"]\n        layout = QVBoxLayout()\n        self.setLayout(layout)\n        if HAS_OPENGL:\n            # Create 3D view\n            self.view = GLViewWidget()\n            self.view.setCameraPosition(distance=15)\n            # Add grid\n            grid = GLGridItem()\n            self.view.addItem(grid)\n            # Add trajectory scatter plot\n            self.traj_scatter = GLScatterPlotItem(pos=np.zeros((1, 3)), color=(0, 0, 1, 1), size=5)\n            self.view.addItem(self.traj_scatter)\n            # Create main layout with view and control panel\n            main_layout = QHBoxLayout()\n            # Create control panel\n            self.create_control_panel()\n            # Create obstacle ellipsoids\n            self.obs_ellipsoids = []\n            self.create_obstacle_ellipsoids()\n            # Add widgets to main layout\n            main_layout.addWidget(self.view, stretch=3)\n            main_layout.addWidget(self.control_panel, stretch=1)\n            layout.addLayout(main_layout)\n        else:\n            # Fallback to 2D\n            label = QLabel(\"3D OpenGL not available\")\n            layout.addWidget(label)\n\n    def create_control_panel(self):\n        \"\"\"Create the control panel with sliders for each obstacle\"\"\"\n        self.control_panel = QWidget()\n        control_layout = QVBoxLayout()\n        self.control_panel.setLayout(control_layout)\n        # Title\n        title = QLabel(\"3D Obstacle Avoidance Control\")\n        title.setStyleSheet(\"font-weight: bold; font-size: 14px;\")\n        control_layout.addWidget(title)\n        # Optimization Metrics Display\n        metrics_group = QGroupBox(\"Optimization Metrics\")\n        metrics_layout = QVBoxLayout()\n        metrics_group.setLayout(metrics_layout)\n        # Create labels for each metric\n        self.iter_label = QLabel(\"Iteration: 0\")\n        self.j_tr_label = QLabel(\"J_tr: 0.00e+00\")\n        self.j_vb_label = QLabel(\"J_vb: 0.00e+00\")\n        self.j_vc_label = QLabel(\"J_vc: 0.00e+00\")\n        self.objective_label = QLabel(\"Objective: 0.00e+00\")\n        self.lam_cost_display_label = QLabel(f\"\u03bb_cost: {problem.settings.scp.lam_cost:.2E}\")\n        self.dis_time_label = QLabel(\"Dis Time: 0.0ms\")\n        self.solve_time_label = QLabel(\"Solve Time: 0.0ms\")\n        self.status_label = QLabel(\"Status: --\")\n        # Style the labels\n        for label in [\n            self.iter_label,\n            self.j_tr_label,\n            self.j_vb_label,\n            self.j_vc_label,\n            self.objective_label,\n            self.lam_cost_display_label,\n            self.dis_time_label,\n            self.solve_time_label,\n            self.status_label,\n        ]:\n            label.setStyleSheet(\"font-family: monospace; font-size: 11px; padding: 2px;\")\n            metrics_layout.addWidget(label)\n        control_layout.addWidget(metrics_group)\n        # Optimization Weights\n        weights_group = QGroupBox(\"Optimization Weights\")\n        weights_layout = QVBoxLayout()\n        weights_group.setLayout(weights_layout)\n        # Lambda cost input - Input on left, label on right\n        lam_cost_layout = QHBoxLayout()\n        lam_cost_input = QLineEdit()\n        lam_cost_input.setText(f\"{problem.settings.scp.lam_cost:.2E}\")\n        lam_cost_input.setFixedWidth(80)\n        lam_cost_input.returnPressed.connect(lambda: on_lam_cost_changed(lam_cost_input))\n        lam_cost_label = QLabel(\"\u03bb_cost:\")\n        lam_cost_label.setAlignment(Qt.AlignLeft)\n        lam_cost_layout.addWidget(lam_cost_input)\n        lam_cost_layout.addWidget(lam_cost_label)\n        lam_cost_layout.addStretch()  # Push everything to the left\n        weights_layout.addLayout(lam_cost_layout)\n        # Lambda trust region input - Input on left, label on right\n        lam_tr_layout = QHBoxLayout()\n        lam_tr_input = QLineEdit()\n        lam_tr_input.setText(f\"{problem.settings.scp.w_tr:.2E}\")\n        lam_tr_input.setFixedWidth(80)\n        lam_tr_input.returnPressed.connect(lambda: on_lam_tr_changed(lam_tr_input))\n        lam_tr_label = QLabel(\"\u03bb_tr:\")\n        lam_tr_label.setAlignment(Qt.AlignLeft)\n        lam_tr_layout.addWidget(lam_tr_input)\n        lam_tr_layout.addWidget(lam_tr_label)\n        lam_tr_layout.addStretch()  # Push everything to the left\n        weights_layout.addLayout(lam_tr_layout)\n        control_layout.addWidget(weights_group)\n        # Problem Control\n        problem_control_group = QGroupBox(\"Problem Control\")\n        problem_control_layout = QVBoxLayout()\n        problem_control_group.setLayout(problem_control_layout)\n        reset_problem_button = QPushButton(\"Reset Problem\")\n        reset_problem_button.clicked.connect(self.on_reset_clicked)\n        problem_control_layout.addWidget(reset_problem_button)\n        control_layout.addWidget(problem_control_group)\n        # Sliders for each obstacle\n        for i in range(3):\n            obs_group = QGroupBox(f\"Obstacle {i + 1} Position\")\n            obs_layout = QVBoxLayout()\n            obs_group.setLayout(obs_layout)\n            # X, Y, Z sliders\n            sliders = []\n            for j, coord in enumerate([\"X\", \"Y\", \"Z\"]):\n                slider_layout = QHBoxLayout()\n                label = QLabel(f\"{coord}:\")\n                slider = QSlider(Qt.Horizontal)\n                slider.setRange(-100, 100)\n                slider.setValue(0)\n                value_label = QLabel(\"0.00\")\n                # Connect slider to update function\n                slider.valueChanged.connect(\n                    lambda val, obs=i, axis=j, label=value_label: self.on_slider_changed(\n                        val, obs, axis, label\n                    )\n                )\n                slider_layout.addWidget(label)\n                slider_layout.addWidget(slider)\n                slider_layout.addWidget(value_label)\n                obs_layout.addLayout(slider_layout)\n                sliders.append((slider, value_label))\n            # Store sliders for this obstacle\n            setattr(self, f\"obs_{i}_sliders\", sliders)\n            control_layout.addWidget(obs_group)\n        control_layout.addStretch()\n        # Create labels dictionary for metrics update\n        self.labels_dict = {\n            \"iter_label\": self.iter_label,\n            \"j_tr_label\": self.j_tr_label,\n            \"j_vb_label\": self.j_vb_label,\n            \"j_vc_label\": self.j_vc_label,\n            \"objective_label\": self.objective_label,\n            \"lam_cost_display_label\": self.lam_cost_display_label,\n            \"dis_time_label\": self.dis_time_label,\n            \"solve_time_label\": self.solve_time_label,\n            \"status_label\": self.status_label,\n        }\n\n    def create_obstacle_ellipsoids(self):\n        if not HAS_OPENGL:\n            return\n        for _i, (ax, rad) in enumerate(zip(self.ellipsoid_axes, self.ellipsoid_radii)):\n            # Create main ellipsoid\n            mesh = MeshData.sphere(rows=20, cols=20, radius=1.0)\n            verts = mesh.vertexes()\n            verts = verts * 1 / (rad)  # scale to ellipsoid\n            verts = verts @ ax.T  # rotate by axes\n            mesh.setVertexes(verts)\n            ellipsoid = GLMeshItem(\n                meshdata=mesh,\n                color=(0, 1, 0, 0.3),  # RGBA, green, transparent\n                shader=\"shaded\",\n                smooth=True,\n            )\n            ellipsoid.setGLOptions(\"translucent\")  # Enable transparency\n            # Set initial position using translate\n            ellipsoid.translate(0, 0, 0)\n            self.obs_ellipsoids.append(ellipsoid)\n            self.view.addItem(ellipsoid)\n\n    def on_slider_changed(self, value, obstacle_idx, axis, label):\n        \"\"\"Handle slider value changes\"\"\"\n        # Convert slider value (-100 to 100) to world coordinates (-5 to 5)\n        world_value = value * 0.05\n        # Update the parameter\n        param_name = f\"obstacle_center_{obstacle_idx + 1}\"\n        center = problem.parameters[param_name].copy()\n        center[axis] = world_value\n        # Update both the Parameter object's value and problem.parameters\n        obstacle_centers[obstacle_idx].value = center\n        problem.parameters[param_name] = center\n        # Update visualization\n        self.update_obstacle_position(obstacle_idx)\n        # Update label\n        label.setText(f\"{world_value:.2f}\")\n\n    def update_obstacle_position(self, obstacle_idx):\n        \"\"\"Update obstacle position in 3D view\"\"\"\n        if not HAS_OPENGL:\n            return\n        param_name = f\"obstacle_center_{obstacle_idx + 1}\"\n        center = problem.parameters[param_name]\n        # Update ellipsoid position\n        ellipsoid = self.obs_ellipsoids[obstacle_idx]\n        ellipsoid.resetTransform()\n        ellipsoid.translate(center[0], center[1], center[2])\n\n    def update_slider_values(self, obstacle_idx):\n        \"\"\"Update slider values to match current obstacle position\"\"\"\n        param_name = f\"obstacle_center_{obstacle_idx + 1}\"\n        center = problem.parameters[param_name]\n        sliders = getattr(self, f\"obs_{obstacle_idx}_sliders\")\n        for i, (slider, label) in enumerate(sliders):\n            # Convert world coordinates to slider values\n            slider_value = int(center[i] / 0.05)\n            slider.setValue(slider_value)\n            label.setText(f\"{center[i]:.2f}\")\n\n    def on_reset_clicked(self):\n        \"\"\"Handle reset button click\"\"\"\n        reset_requested[\"reset\"] = True\n        print(\"Problem reset requested\")\n\n    def keyPressEvent(self, event):\n        \"\"\"Handle keyboard shortcuts\"\"\"\n        if event.key() == Qt.Key_Escape:\n            self.close()\n        else:\n            super().keyPressEvent(event)\n\n\ndef on_lam_cost_changed(input_widget):\n    \"\"\"Handle lambda cost input changes\"\"\"\n    # Extract the new value from the input widget\n    new_value = input_widget.text()\n    try:\n        # Convert the new value to a float\n        lam_cost_value = float(new_value)\n        problem.settings.scp.lam_cost = lam_cost_value\n        # Update the display with scientific notation\n        input_widget.setText(f\"{lam_cost_value:.2E}\")\n    except ValueError:\n        print(\"Invalid input. Please enter a valid number.\")\n\n\ndef on_lam_tr_changed(input_widget):\n    \"\"\"Handle lambda trust region input changes\"\"\"\n    # Extract the new value from the input widget\n    new_value = input_widget.text()\n    try:\n        # Convert the new value to a float\n        lam_tr_value = float(new_value)\n        problem.settings.scp.w_tr = lam_tr_value\n        # Update the display with scientific notation\n        input_widget.setText(f\"{lam_tr_value:.2E}\")\n    except ValueError:\n        print(\"Invalid input. Please enter a valid number.\")\n\n\ndef update_optimization_metrics(results, labels_dict):\n    \"\"\"Update the optimization metrics display\"\"\"\n    if results is None:\n        return\n    # Extract metrics from results\n    iter_num = results.get(\"iter\", 0)\n    j_tr = results.get(\"J_tr\", 0.0)\n    j_vb = results.get(\"J_vb\", 0.0)\n    j_vc = results.get(\"J_vc\", 0.0)\n    cost = results.get(\"cost\", 0.0)\n    status = results.get(\"prob_stat\", \"--\")\n    # Get timing information (these would need to be tracked separately)\n    dis_time = results.get(\"dis_time\", 0.0)\n    solve_time = results.get(\"solve_time\", 0.0)\n    # Update labels\n    labels_dict[\"iter_label\"].setText(f\"Iteration: {iter_num}\")\n    labels_dict[\"j_tr_label\"].setText(f\"J_tr: {j_tr:.2E}\")\n    labels_dict[\"j_vb_label\"].setText(f\"J_vb: {j_vb:.2E}\")\n    labels_dict[\"j_vc_label\"].setText(f\"J_vc: {j_vc:.2E}\")\n    labels_dict[\"objective_label\"].setText(f\"Objective: {cost:.2E}\")\n    labels_dict[\"lam_cost_display_label\"].setText(f\"\u03bb_cost: {problem.settings.scp.lam_cost:.2E}\")\n    labels_dict[\"dis_time_label\"].setText(f\"Dis Time: {dis_time:.1f}ms\")\n    labels_dict[\"solve_time_label\"].setText(f\"Solve Time: {solve_time:.1f}ms\")\n    labels_dict[\"status_label\"].setText(f\"Status: {status}\")\n\n\ndef optimization_loop():\n    problem.initialize()\n    try:\n        while not running[\"stop\"]:\n            # Check if reset was requested\n            if reset_requested[\"reset\"]:\n                problem.reset()\n                reset_requested[\"reset\"] = False\n                print(\"Problem reset to initial conditions\")\n\n            # Perform a single SCP step (automatically warm-starts from previous iteration)\n            step_result = problem.step()\n\n            # Build results dict for visualization\n            results = {\n                \"iter\": step_result[\"scp_k\"] - 1,  # Display iteration (0-indexed)\n                \"J_tr\": step_result[\"scp_J_tr\"],\n                \"J_vb\": step_result[\"scp_J_vb\"],\n                \"J_vc\": step_result[\"scp_J_vc\"],\n                \"converged\": step_result[\"converged\"],\n                \"V_multi_shoot\": problem.state.V_history[-1] if problem.state.V_history else [],\n                \"x\": problem.state.x,  # Current state trajectory\n                \"u\": problem.state.u,  # Current control trajectory\n            }\n\n            # Get timing from the print queue (emitted data)\n            try:\n                if hasattr(problem, \"print_queue\") and not problem.print_queue.empty():\n                    # Get the latest emitted data\n                    emitted_data = problem.print_queue.get_nowait()\n                    results[\"dis_time\"] = emitted_data.get(\"dis_time\", 0.0)\n                    results[\"solve_time\"] = emitted_data.get(\"subprop_time\", 0.0)\n                    results[\"prob_stat\"] = emitted_data.get(\"prob_stat\", \"--\")\n                    results[\"cost\"] = emitted_data.get(\"cost\", 0.0)\n                else:\n                    results[\"dis_time\"] = 0.0\n                    results[\"solve_time\"] = 0.0\n                    results[\"prob_stat\"] = \"--\"\n                    results[\"cost\"] = 0.0\n            except Exception:\n                results[\"dis_time\"] = 0.0\n                results[\"solve_time\"] = 0.0\n                results[\"prob_stat\"] = \"--\"\n                results[\"cost\"] = 0.0\n\n            results.update(plotting_dict)\n            latest_results[\"results\"] = results\n            new_result_event.set()\n    except KeyboardInterrupt:\n        running[\"stop\"] = True\n        print(\"Stopped by user.\")\n\n\ndef plot_thread_func():\n    # Initialize PyQtGraph\n    app = QApplication.instance()\n    if app is None:\n        app = QApplication([])\n    print(f\"Creating plot window... OpenGL available: {HAS_OPENGL}\")\n    # Create 3D plot window\n    plot_widget = Obstacle3DPlotWidget()\n    plot_widget.setWindowTitle(\"3D Obstacle Avoidance Real-time Trajectory\")\n    plot_widget.resize(800, 600)  # Set explicit size\n    plot_widget.show()\n    print(\"Plot window created and shown\")\n    # Force the window to be visible\n    plot_widget.raise_()\n    plot_widget.activateWindow()\n    # Small delay to ensure window appears\n    time.sleep(0.1)\n    # Update timer\n    timer = QTimer()\n\n    def update_plot():\n        if latest_results[\"results\"] is not None:\n            try:\n                V_multi_shoot = np.array(latest_results[\"results\"][\"V_multi_shoot\"])\n                # Extract 3D position data (first 3 elements of state)\n                n_x = problem.settings.sim.n_states\n                n_u = problem.settings.sim.n_controls\n                i1 = n_x\n                i2 = i1 + n_x * n_x\n                i3 = i2 + n_x * n_u\n                i4 = i3 + n_x * n_u\n                all_pos_segments = []\n                for i_node in range(V_multi_shoot.shape[1]):\n                    node_data = V_multi_shoot[:, i_node]\n                    segments_for_node = node_data.reshape(-1, i4)\n                    pos_segments = segments_for_node[:, :3]  # 3D positions\n                    all_pos_segments.append(pos_segments)\n                if all_pos_segments:\n                    full_traj = np.vstack(all_pos_segments)\n                    if HAS_OPENGL:\n                        plot_widget.traj_scatter.setData(pos=full_traj)\n                        # Update obstacle positions (reset and translate for ellipsoids)\n                        for i, ellipsoid in enumerate(plot_widget.obs_ellipsoids):\n                            param_name = f\"obstacle_center_{i + 1}\"\n                            center = problem.parameters[param_name]\n                            ellipsoid.resetTransform()\n                            ellipsoid.translate(*center)\n                    else:\n                        # 2D fallback - plot X vs Y\n                        plot_widget.traj_curve.setData(full_traj[:, 0], full_traj[:, 1])\n                        # Update obstacle positions in 2D\n                        for i in range(3):\n                            param_name = f\"obstacle_center_{i + 1}\"\n                            center = problem.parameters[param_name]\n                            plot_widget.obs_scatters[i].setData([center[0]], [center[1]])\n                # Update optimization metrics display\n                update_optimization_metrics(latest_results[\"results\"], plot_widget.labels_dict)\n            except Exception as e:\n                print(f\"Plot update error: {e}\")\n                if \"x\" in latest_results[\"results\"]:\n                    x_traj = latest_results[\"results\"][\"x\"]  # Now a numpy array\n                    if HAS_OPENGL:\n                        plot_widget.traj_scatter.setData(pos=x_traj[:, :3])\n                    else:\n                        plot_widget.traj_curve.setData(x_traj[:, 0], x_traj[:, 1])\n\n    timer.timeout.connect(update_plot)\n    timer.start(50)  # Update every 50ms\n    print(\"Starting Qt event loop...\")\n    # Start the Qt event loop\n    app.exec_()\n\n\nif __name__ == \"__main__\":\n    # Start optimization thread\n    opt_thread = threading.Thread(target=optimization_loop)\n    opt_thread.daemon = True\n    opt_thread.start()\n    # Start plotting in main thread (this will block and run the Qt event loop)\n    plot_thread_func()\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>algorithms<ul> <li>autotuning</li> <li>optimization_results</li> <li>ptr</li> <li>solver_state</li> </ul> </li> <li>config</li> <li>discretization<ul> <li>discretization</li> </ul> </li> <li>integrators<ul> <li>runge_kutta</li> </ul> </li> <li>lowered<ul> <li>cvxpy_constraints</li> <li>cvxpy_variables</li> <li>dynamics</li> <li>jax_constraints</li> <li>parameters</li> <li>problem</li> <li>unified</li> </ul> </li> <li>plotting<ul> <li>plotting</li> </ul> </li> <li>problem</li> <li>propagation<ul> <li>post_processing</li> <li>propagation</li> </ul> </li> <li>solvers<ul> <li>cvxpy</li> </ul> </li> <li>symbolic<ul> <li>augmentation</li> <li>builder</li> <li>constraint_set</li> <li>expr<ul> <li>arithmetic</li> <li>array</li> <li>constraint</li> <li>control</li> <li>expr</li> <li>linalg</li> <li>math</li> <li>spatial</li> <li>state</li> <li>stl</li> <li>variable</li> </ul> </li> <li>hashing</li> <li>lower</li> <li>lowerers<ul> <li>cvxpy</li> <li>jax</li> </ul> </li> <li>preprocessing</li> <li>problem</li> <li>time</li> <li>unified</li> </ul> </li> <li>utils<ul> <li>cache</li> <li>caching</li> <li>printing</li> <li>profiling</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/config/","title":"config","text":""},{"location":"reference/config/#openscvx.config.ConvexSolverConfig","title":"<code>ConvexSolverConfig</code>  <code>dataclass</code>","text":"Source code in <code>openscvx/config.py</code> <pre><code>@dataclass\nclass ConvexSolverConfig:\n    def __init__(\n        self,\n        solver: str = \"QOCO\",\n        solver_args: Optional[dict] = None,\n        cvxpygen: bool = False,\n        cvxpygen_override: bool = False,\n    ):\n        \"\"\"\n        Configuration class for convex solver settings.\n\n        This class defines the parameters required for configuring a convex solver.\n\n        These are the arguments most commonly used day-to-day. Generally I have\n        found [QOCO](https://qoco-org.github.io/qoco/index.html) to be the most\n        performant of the CVXPY solvers for these types of problems (I do have a\n        bias as the author is from my group) and can handle up to SOCP's.\n        [CLARABEL](https://clarabel.org/stable/) is also a great option with\n        feasibility checking and can handle a few more problem types.\n        [CVXPYGen](https://github.com/cvxgrp/cvxpygen) is also great if your\n        problem isn't too large. I have found qocogen to be the most performant\n        of the CVXPYGen solvers.\n\n        Args:\n            solver (str): The name of the CVXPY solver to use. A list of options\n                can be found [here](https://www.cvxpy.org/tutorial/solvers/\n                index.html). Defaults to \"QOCO\".\n            solver_args (dict, optional): Ensure you are using the correct\n                arguments for your solver as they are not all common. Additional\n                arguments to configure the solver, such as tolerances. Defaults\n                to {\"abstol\": 1e-6, \"reltol\": 1e-9}.\n            cvxpygen (bool): Whether to enable CVXPY code generation for the\n                solver. Defaults to False.\n        \"\"\"\n        if solver_args is None:\n            solver_args = {\"abstol\": 1e-06, \"reltol\": 1e-09, \"enforce_dpp\": True}\n        self.solver = solver\n        self.solver_args = (\n            solver_args if solver_args is not None else {\"abstol\": 1e-6, \"reltol\": 1e-9}\n        )\n        self.cvxpygen = cvxpygen\n        self.cvxpygen_override = cvxpygen_override\n</code></pre>"},{"location":"reference/config/#openscvx.config.DevConfig","title":"<code>DevConfig</code>  <code>dataclass</code>","text":"Source code in <code>openscvx/config.py</code> <pre><code>@dataclass\nclass DevConfig:\n    def __init__(self, profiling: bool = False, debug: bool = False, printing: bool = True):\n        \"\"\"\n        Configuration class for development settings.\n\n        This class defines the parameters used for development and debugging\n        purposes.\n\n        Main arguments:\n        These are the arguments most commonly used day-to-day.\n\n        Args:\n            profiling (bool): Whether to enable profiling for performance\n                analysis. Defaults to False.\n            debug (bool): Disables all precompilation so you can place\n                breakpoints and inspect values. Defaults to False.\n            printing (bool): Whether to enable printing during development.\n                Defaults to True.\n        \"\"\"\n        self.profiling = profiling\n        self.debug = debug\n        self.printing = printing\n</code></pre>"},{"location":"reference/config/#openscvx.config.DiscretizationConfig","title":"<code>DiscretizationConfig</code>  <code>dataclass</code>","text":"Source code in <code>openscvx/config.py</code> <pre><code>@dataclass\nclass DiscretizationConfig:\n    def __init__(\n        self,\n        dis_type: str = \"FOH\",\n        custom_integrator: bool = False,\n        solver: str = \"Tsit5\",\n        args: Optional[dict] = None,\n        atol: float = 1e-3,\n        rtol: float = 1e-6,\n    ):\n        \"\"\"\n        Configuration class for discretization settings.\n\n        This class defines the parameters required for discretizing system dynamics.\n\n        Main arguments:\n        These are the arguments most commonly used day-to-day.\n\n        Args:\n            dis_type (str): The type of discretization to use (e.g., \"FOH\" for\n                First-Order Hold). Defaults to \"FOH\".\n            custom_integrator (bool): This enables our custom fixed-step RK45\n                algorithm. This tends to be faster than Diffrax but unless you're\n                going for speed, it's recommended to stick with Diffrax for\n                robustness and other solver options. Defaults to False.\n            solver (str): Not used if custom_integrator is enabled. Any choice of\n                solver in Diffrax is valid, please refer here,\n                [How to Choose a Solver](https://docs.kidger.site/diffrax/usage/\n                how-to-choose-a-solver/). Defaults to \"Tsit5\".\n\n        Other arguments:\n        These arguments are less frequently used, and for most purposes you\n        shouldn't need to understand these.\n\n        Args:\n            args (Dict): Additional arguments to pass to the solver which can be\n                found [here](https://docs.kidger.site/diffrax/api/diffeqsolve/).\n                Defaults to an empty dictionary.\n            atol (float): Absolute tolerance for the solver. Defaults to 1e-3.\n            rtol (float): Relative tolerance for the solver. Defaults to 1e-6.\n        \"\"\"\n        self.dis_type = dis_type\n        self.custom_integrator = custom_integrator\n        self.solver = solver\n        self.args = args if args is not None else {}\n        self.atol = atol\n        self.rtol = rtol\n</code></pre>"},{"location":"reference/config/#openscvx.config.PropagationConfig","title":"<code>PropagationConfig</code>  <code>dataclass</code>","text":"Source code in <code>openscvx/config.py</code> <pre><code>@dataclass\nclass PropagationConfig:\n    def __init__(\n        self,\n        inter_sample: int = 30,\n        dt: float = 0.01,\n        solver: str = \"Dopri8\",\n        max_tau_len: int = 1000,\n        args: Optional[dict] = None,\n        atol: float = 1e-3,\n        rtol: float = 1e-6,\n    ):\n        \"\"\"\n        Configuration class for propagation settings.\n\n        This class defines the parameters required for propagating the nonlinear\n        system dynamics using the optimal control sequence.\n\n        Main arguments:\n        These are the arguments most commonly used day-to-day.\n\n        Other arguments:\n        The solver should likely not be changed as it is a high accuracy 8th-order\n        Runge-Kutta method.\n\n        Args:\n            inter_sample (int): How dense the propagation within multishot\n                discretization should be. Defaults to 30.\n            dt (float): The time step for propagation. Defaults to 0.1.\n            solver (str): The numerical solver to use for propagation\n                (e.g., \"Dopri8\"). Defaults to \"Dopri8\".\n            max_tau_len (int): The maximum length of the time vector for\n                propagation. Defaults to 1000.\n            args (Dict, optional): Additional arguments to pass to the solver.\n                Defaults to an empty dictionary.\n            atol (float): Absolute tolerance for the solver. Defaults to 1e-3.\n            rtol (float): Relative tolerance for the solver. Defaults to 1e-6.\n        \"\"\"\n        self.inter_sample = inter_sample\n        self.dt = dt\n        self.solver = solver\n        self.max_tau_len = max_tau_len\n        self.args = args if args is not None else {}\n        self.atol = atol\n        self.rtol = rtol\n</code></pre>"},{"location":"reference/config/#openscvx.config.ScpConfig","title":"<code>ScpConfig</code>  <code>dataclass</code>","text":"Source code in <code>openscvx/config.py</code> <pre><code>@dataclass\nclass ScpConfig:\n    def __init__(\n        self,\n        n: Optional[int] = None,\n        k_max: int = 200,\n        w_tr: float = 1.0,\n        lam_vc: float = 1.0,\n        ep_tr: float = 1e-4,\n        ep_vb: float = 1e-4,\n        ep_vc: float = 1e-8,\n        lam_cost: float = 0.0,\n        lam_vb: float = 0.0,\n        uniform_time_grid: bool = False,\n        cost_drop: int = -1,\n        cost_relax: float = 1.0,\n        w_tr_adapt: float = 1.0,\n        w_tr_max: Optional[float] = None,\n        w_tr_max_scaling_factor: Optional[float] = None,\n    ):\n        \"\"\"\n        Configuration class for Sequential Convex Programming (SCP).\n\n        This class defines the parameters used to configure the SCP solver. You\n        will very likely need to modify the weights for your problem. Please\n        refer to my guide [here](https://haynec.github.io/openscvx/\n        hyperparameter_tuning) for more information.\n\n        Attributes:\n            n (int): The number of discretization nodes. Defaults to `None`.\n            k_max (int): The maximum number of SCP iterations. Defaults to 200.\n            w_tr (float): The trust region weight. Defaults to 1.0.\n            lam_vc (float): The penalty weight for virtual control. Defaults to 1.0.\n            ep_tr (float): The trust region convergence tolerance. Defaults to 1e-4.\n            ep_vb (float): The boundary constraint convergence tolerance.\n                Defaults to 1e-4.\n            ep_vc (float): The virtual constraint convergence tolerance.\n                Defaults to 1e-8.\n            lam_cost (float): The weight for original cost. Defaults to 0.0.\n            lam_vb (float): The weight for virtual buffer. This is only used if\n                there are nonconvex nodal constraints present. Defaults to 0.0.\n            uniform_time_grid (bool): Whether to use a uniform time grid.\n                Defaults to `False`.\n            cost_drop (int): The number of iterations to allow for cost\n                stagnation before termination. Defaults to -1 (disabled).\n            cost_relax (float): The relaxation factor for cost reduction.\n                Defaults to 1.0.\n            w_tr_adapt (float): The adaptation factor for the trust region\n                weight. Defaults to 1.0.\n            w_tr_max (float): The maximum allowable trust region weight.\n                Defaults to `None`.\n            w_tr_max_scaling_factor (float): The scaling factor for the maximum\n                trust region weight. Defaults to `None`.\n        \"\"\"\n        self.n = n\n        self.k_max = k_max\n        self.w_tr = w_tr\n        self.lam_vc = lam_vc\n        self.ep_tr = ep_tr\n        self.ep_vb = ep_vb\n        self.ep_vc = ep_vc\n        self.lam_cost = lam_cost\n        self.lam_vb = lam_vb\n        self.uniform_time_grid = uniform_time_grid\n        self.cost_drop = cost_drop\n        self.cost_relax = cost_relax\n        self.w_tr_adapt = w_tr_adapt\n        self.w_tr_max = w_tr_max\n        self.w_tr_max_scaling_factor = w_tr_max_scaling_factor\n\n    def __post_init__(self):\n        keys_to_scale = [\"w_tr\", \"lam_vc\", \"lam_cost\", \"lam_vb\"]\n        # Handle lam_vc which might be scalar or array\n        scale_values = []\n        for key in keys_to_scale:\n            val = getattr(self, key)\n            if isinstance(val, np.ndarray):\n                scale_values.append(np.max(val))\n            else:\n                scale_values.append(val)\n        scale = max(scale_values)\n        for key in keys_to_scale:\n            val = getattr(self, key)\n            if isinstance(val, np.ndarray):\n                setattr(self, key, val / scale)\n            else:\n                setattr(self, key, val / scale)\n\n        if self.w_tr_max_scaling_factor is not None and self.w_tr_max is None:\n            self.w_tr_max = self.w_tr_max_scaling_factor * self.w_tr\n</code></pre>"},{"location":"reference/config/#openscvx.config.SimConfig","title":"<code>SimConfig</code>  <code>dataclass</code>","text":"Source code in <code>openscvx/config.py</code> <pre><code>@dataclass(init=False)\nclass SimConfig:\n    # No class-level field declarations\n\n    def __init__(\n        self,\n        x: UnifiedState,\n        x_prop: UnifiedState,\n        u: UnifiedControl,\n        total_time: float,\n        save_compiled: bool = False,\n        ctcs_node_intervals: Optional[list] = None,\n        n_states: Optional[int] = None,\n        n_states_prop: Optional[int] = None,\n        n_controls: Optional[int] = None,\n    ):\n        \"\"\"\n        Configuration class for simulation settings.\n\n        This class defines the parameters required for simulating a trajectory\n        optimization problem.\n\n        Main arguments:\n        These are the arguments most commonly used day-to-day.\n\n        Args:\n            x (State): State object, must have .min and .max attributes for bounds.\n            x_prop (State): Propagation state object, must have .min and .max\n                attributes for bounds.\n            u (Control): Control object, must have .min and .max attributes for\n                bounds.\n            total_time (float): The total simulation time.\n            idx_x_true (slice): Slice for true state indices.\n            idx_x_true_prop (slice): Slice for true propagation state indices.\n            idx_u_true (slice): Slice for true control indices.\n            idx_t (slice): Slice for time index.\n            idx_y (slice): Slice for constraint violation indices.\n            idx_y_prop (slice): Slice for propagation constraint violation\n                indices.\n            idx_s (slice): Slice for time dilation index.\n            save_compiled (bool): If True, save and reuse compiled solver\n                functions. Defaults to False.\n            ctcs_node_intervals (list, optional): Node intervals for CTCS\n                constraints.\n            n_states (int, optional): The number of state variables. Defaults to\n                `None` (inferred from x.max).\n            n_states_prop (int, optional): The number of propagation state\n                variables. Defaults to `None` (inferred from x_prop.max).\n            n_controls (int, optional): The number of control variables. Defaults\n                to `None` (inferred from u.max).\n\n        Note:\n            You can specify custom scaling for specific states/controls using\n            the `scaling_min` and `scaling_max` attributes on State, Control, and Time objects.\n            If not set, the default min/max bounds will be used for scaling.\n        \"\"\"\n        # Assign core arguments to self\n        self.x = x\n        self.x_prop = x_prop\n        self.u = u\n        self.total_time = total_time\n        self.save_compiled = save_compiled\n        self.ctcs_node_intervals = ctcs_node_intervals\n        self.n_states = n_states\n        self.n_states_prop = n_states_prop\n        self.n_controls = n_controls\n\n        # Call post init logic\n        self.__post_init__()\n\n    def __post_init__(self):\n        self.n_states = len(self.x.max)\n        self.n_controls = len(self.u.max)\n\n        # State scaling\n        # Use scaling_min/max if provided, otherwise use regular min/max\n        min_x = np.array(self.x.min, dtype=float)\n        max_x = np.array(self.x.max, dtype=float)\n\n        # UnifiedState now always provides full-size scaling arrays when any state has scaling\n        if self.x.scaling_min is not None:\n            lower_x = np.array(self.x.scaling_min, dtype=float)\n        else:\n            lower_x = min_x\n\n        if self.x.scaling_max is not None:\n            upper_x = np.array(self.x.scaling_max, dtype=float)\n        else:\n            upper_x = max_x\n\n        S_x, c_x = get_affine_scaling_matrices(self.n_states, lower_x, upper_x)\n        self.S_x = S_x\n        self.c_x = c_x\n        self.inv_S_x = np.diag(1 / np.diag(self.S_x))\n\n        # Control scaling\n        # Use scaling_min/max if provided, otherwise use regular min/max\n        min_u = np.array(self.u.min, dtype=float)\n        max_u = np.array(self.u.max, dtype=float)\n\n        # UnifiedControl now always provides full-size scaling arrays when any control has scaling\n        if self.u.scaling_min is not None:\n            lower_u = np.array(self.u.scaling_min, dtype=float)\n        else:\n            lower_u = min_u\n\n        if self.u.scaling_max is not None:\n            upper_u = np.array(self.u.scaling_max, dtype=float)\n        else:\n            upper_u = max_u\n\n        S_u, c_u = get_affine_scaling_matrices(self.n_controls, lower_u, upper_u)\n        self.S_u = S_u\n        self.c_u = c_u\n        self.inv_S_u = np.diag(1 / np.diag(self.S_u))\n\n    # Properties for accessing slices from unified objects\n    @property\n    def time_slice(self):\n        \"\"\"Slice for accessing time in the state vector.\"\"\"\n        return self.x.time_slice\n\n    @property\n    def ctcs_slice(self):\n        \"\"\"Slice for accessing CTCS augmented states.\"\"\"\n        return self.x.ctcs_slice\n\n    @property\n    def ctcs_slice_prop(self):\n        \"\"\"Slice for accessing CTCS augmented states in propagation.\"\"\"\n        return self.x_prop.ctcs_slice\n\n    @property\n    def time_dilation_slice(self):\n        \"\"\"Slice for accessing time dilation in the control vector.\"\"\"\n        return self.u.time_dilation_slice\n\n    @property\n    def true_state_slice(self):\n        \"\"\"Slice for accessing true (non-augmented) states.\"\"\"\n        return self.x._true_slice\n\n    @property\n    def true_state_slice_prop(self):\n        \"\"\"Slice for accessing true (non-augmented) propagation states.\"\"\"\n        return self.x_prop._true_slice\n\n    @property\n    def true_control_slice(self):\n        \"\"\"Slice for accessing true (non-augmented) controls.\"\"\"\n        return self.u._true_slice\n</code></pre>"},{"location":"reference/config/#openscvx.config.SimConfig.ctcs_slice","title":"<code>ctcs_slice</code>  <code>property</code>","text":"<p>Slice for accessing CTCS augmented states.</p>"},{"location":"reference/config/#openscvx.config.SimConfig.ctcs_slice_prop","title":"<code>ctcs_slice_prop</code>  <code>property</code>","text":"<p>Slice for accessing CTCS augmented states in propagation.</p>"},{"location":"reference/config/#openscvx.config.SimConfig.time_dilation_slice","title":"<code>time_dilation_slice</code>  <code>property</code>","text":"<p>Slice for accessing time dilation in the control vector.</p>"},{"location":"reference/config/#openscvx.config.SimConfig.time_slice","title":"<code>time_slice</code>  <code>property</code>","text":"<p>Slice for accessing time in the state vector.</p>"},{"location":"reference/config/#openscvx.config.SimConfig.true_control_slice","title":"<code>true_control_slice</code>  <code>property</code>","text":"<p>Slice for accessing true (non-augmented) controls.</p>"},{"location":"reference/config/#openscvx.config.SimConfig.true_state_slice","title":"<code>true_state_slice</code>  <code>property</code>","text":"<p>Slice for accessing true (non-augmented) states.</p>"},{"location":"reference/config/#openscvx.config.SimConfig.true_state_slice_prop","title":"<code>true_state_slice_prop</code>  <code>property</code>","text":"<p>Slice for accessing true (non-augmented) propagation states.</p>"},{"location":"reference/problem/","title":"problem","text":"<p>Core optimization problem interface for trajectory optimization.</p> <p>This module provides the Problem class, the main entry point for defining and solving trajectory optimization problems using Sequential Convex Programming (SCP).</p> Example <p>The prototypical flow is to define a problem, then initialize, solve, and post-process the results</p> <pre><code>problem = Problem(dynamics, constraints, states, controls, N, time)\nproblem.initialize()\nresult = problem.solve()\nresult = problem.post_process()\n</code></pre>"},{"location":"reference/problem/#openscvx.problem.Problem","title":"<code>Problem</code>","text":"Source code in <code>openscvx/problem.py</code> <pre><code>class Problem:\n    def __init__(\n        self,\n        dynamics: dict,\n        constraints: List[Union[Constraint, CTCS]],\n        states: List[State],\n        controls: List[Control],\n        N: int,\n        time: Time,\n        dynamics_prop: Optional[dict] = None,\n        states_prop: Optional[List[State]] = None,\n        licq_min=0.0,\n        licq_max=1e-4,\n        time_dilation_factor_min=0.3,\n        time_dilation_factor_max=3.0,\n    ):\n        \"\"\"\n        The primary class in charge of compiling and exporting the solvers\n\n        Args:\n            dynamics (dict): Dictionary mapping state names to their dynamics expressions.\n                Each key should be a state name, and each value should be an Expr\n                representing the derivative of that state.\n            constraints (List[Union[CTCSConstraint, NodalConstraint]]):\n                List of constraints decorated with @ctcs or @nodal\n            states (List[State]): List of State objects representing the state variables.\n                May optionally include a State named \"time\" (see time parameter below).\n            controls (List[Control]): List of Control objects representing the control variables\n            N (int): Number of segments in the trajectory\n            time (Time): Time configuration object with initial, final, min, max.\n                Required. If including a \"time\" state in states, the Time object will be ignored\n                and time properties should be set on the time State object instead.\n            dynamics_prop (dict, optional): Dictionary mapping EXTRA state names to their\n                dynamics expressions for propagation. Only specify additional states beyond\n                optimization states (e.g., {\"distance\": speed}). Do NOT duplicate optimization\n                state dynamics here.\n            states_prop (List[State], optional): List of EXTRA State objects for propagation only.\n                Only specify additional states beyond optimization states. Used with dynamics_prop.\n            licq_min: Minimum LICQ constraint value\n            licq_max: Maximum LICQ constraint value\n            time_dilation_factor_min: Minimum time dilation factor\n            time_dilation_factor_max: Maximum time dilation factor\n\n        Returns:\n            None\n\n        Note:\n            There are two approaches for handling time:\n            1. Auto-create (simple): Don't include \"time\" in states, provide Time object\n            2. User-provided (for time-dependent constraints): Include \"time\" State in states and\n               in dynamics dict, don't provide Time object\n        \"\"\"\n\n        # Symbolic Preprocessing &amp; Augmentation\n        self.symbolic: SymbolicProblem = preprocess_symbolic_problem(\n            dynamics=dynamics,\n            constraints=ConstraintSet(unsorted=list(constraints)),\n            states=states,\n            controls=controls,\n            N=N,\n            time=time,\n            licq_min=licq_min,\n            licq_max=licq_max,\n            time_dilation_factor_min=time_dilation_factor_min,\n            time_dilation_factor_max=time_dilation_factor_max,\n            dynamics_prop_extra=dynamics_prop,\n            states_prop_extra=states_prop,\n        )\n\n        # Lower to JAX and CVXPy\n        self._lowered: LoweredProblem = lower_symbolic_problem(self.symbolic)\n\n        # Store parameters in two forms:\n        self._parameters = self.symbolic.parameters  # Plain dict for JAX functions\n        # Wrapper dict for user access that auto-syncs\n        self._parameter_wrapper = ParameterDict(self, self._parameters, self.symbolic.parameters)\n\n        # Setup SCP Configuration\n        self.settings = Config(\n            sim=SimConfig(\n                x=self._lowered.x_unified,\n                x_prop=self._lowered.x_prop_unified,\n                u=self._lowered.u_unified,\n                total_time=self._lowered.x_unified.initial[self._lowered.x_unified.time_slice][0],\n                n_states=self._lowered.x_unified.initial.shape[0],\n                n_states_prop=self._lowered.x_prop_unified.initial.shape[0],\n                ctcs_node_intervals=self.symbolic.node_intervals,\n            ),\n            scp=ScpConfig(\n                n=N,\n                w_tr_max_scaling_factor=1e2,  # Maximum Trust Region Weight\n            ),\n            dis=DiscretizationConfig(),\n            dev=DevConfig(),\n            cvx=ConvexSolverConfig(),\n            prp=PropagationConfig(),\n        )\n\n        # OCP construction happens in initialize() so users can modify\n        # settings (like uniform_time_grid) between __init__ and initialize()\n        self._optimal_control_problem: cp.Problem = None\n        self._discretization_solver: callable = None\n        self.cpg_solve = None\n\n        # Set up emitter &amp; thread only if printing is enabled\n        if self.settings.dev.printing:\n            self.print_queue = queue.Queue()\n            self.emitter_function = lambda data: self.print_queue.put(data)\n            self.print_thread = threading.Thread(\n                target=printing.intermediate,\n                args=(self.print_queue, self.settings),\n                daemon=True,\n            )\n            self.print_thread.start()\n        else:\n            # no-op emitter; nothing ever gets queued or printed\n            self.emitter_function = lambda data: None\n\n        self.timing_init = None\n        self.timing_solve = None\n        self.timing_post = None\n\n        # Compiled dynamics (vmapped versions, set in initialize())\n        self._compiled_dynamics: Optional[Dynamics] = None\n        self._compiled_dynamics_prop: Optional[Dynamics] = None\n\n        # Compiled constraints (JIT-compiled versions, set in initialize())\n        self._compiled_constraints: Optional[LoweredJaxConstraints] = None\n\n        # Solver state (created fresh for each solve)\n        self._state: Optional[SolverState] = None\n\n        # Final solution state (saved after successful solve)\n        self._solution: Optional[SolverState] = None\n\n    @property\n    def parameters(self):\n        \"\"\"Get the parameters dictionary.\n\n        The returned dictionary automatically syncs to CVXPy when modified:\n            problem.parameters[\"obs_radius\"] = 2.0  # Auto-syncs to CVXPy\n            problem.parameters.update({\"gate_0_center\": center})  # Also syncs\n\n        Returns:\n            ParameterDict: Special dict that syncs to CVXPy on assignment\n        \"\"\"\n        return self._parameter_wrapper\n\n    @parameters.setter\n    def parameters(self, new_params: dict):\n        \"\"\"Replace the entire parameters dictionary and sync to CVXPy.\n\n        Args:\n            new_params: New parameters dictionary\n        \"\"\"\n        self._parameters = dict(new_params)  # Create new plain dict\n        self._parameter_wrapper = ParameterDict(self, self._parameters, new_params)\n        self._sync_parameters()\n\n    def _sync_parameters(self):\n        \"\"\"Sync all parameter values to CVXPy parameters.\"\"\"\n        if self._lowered.cvxpy_params is not None:\n            for name, value in self._parameter_wrapper.items():\n                if name in self._lowered.cvxpy_params:\n                    self._lowered.cvxpy_params[name].value = value\n\n    @property\n    def state(self) -&gt; Optional[SolverState]:\n        \"\"\"Access the current solver state.\n\n        The solver state contains all mutable state from the SCP iterations,\n        including current guesses, costs, weights, and history.\n\n        Returns:\n            SolverState if initialized, None otherwise\n\n        Example:\n            When using `Problem.step()` can use the state to check convergence _etc._\n\n                problem.initialize()\n                problem.step()\n                print(f\"Iteration {problem.state.k}, J_tr={problem.state.J_tr}\")\n        \"\"\"\n        return self._state\n\n    @property\n    def lowered(self) -&gt; LoweredProblem:\n        \"\"\"Access the lowered problem containing JAX/CVXPy objects.\n\n        Returns:\n            LoweredProblem with dynamics, constraints, unified interfaces, and CVXPy vars\n        \"\"\"\n        return self._lowered\n\n    @property\n    def x_unified(self):\n        \"\"\"Unified state interface (delegates to lowered.x_unified).\"\"\"\n        return self._lowered.x_unified\n\n    @property\n    def u_unified(self):\n        \"\"\"Unified control interface (delegates to lowered.u_unified).\"\"\"\n        return self._lowered.u_unified\n\n    def initialize(self):\n        \"\"\"Compile dynamics, constraints, and solvers; prepare for optimization.\n\n        This method vmaps dynamics, JIT-compiles constraints, builds the convex\n        subproblem, and initializes the solver state. Must be called before solve().\n\n        Example:\n            Prior to calling the `.solve()` method it is necessary to initialize the problem\n\n                problem = Problem(dynamics, constraints, states, controls, N, time)\n                problem.initialize()  # Compile and prepare\n                problem.solve()       # Run optimization\n        \"\"\"\n        printing.intro()\n\n        # Print problem summary\n        printing.print_problem_summary(self.settings, self._lowered)\n\n        # Enable the profiler\n        pr = profiling.profiling_start(self.settings.dev.profiling)\n\n        t_0_while = time.time()\n        # Ensure parameter sizes and normalization are correct\n        self.settings.scp.__post_init__()\n        self.settings.sim.__post_init__()\n\n        # Create compiled (vmapped) dynamics as new instances\n        # This preserves the original un-vmapped versions in _lowered\n        self._compiled_dynamics = Dynamics(\n            f=jax.vmap(self._lowered.dynamics.f, in_axes=(0, 0, 0, None)),\n            A=jax.vmap(self._lowered.dynamics.A, in_axes=(0, 0, 0, None)),\n            B=jax.vmap(self._lowered.dynamics.B, in_axes=(0, 0, 0, None)),\n        )\n\n        self._compiled_dynamics_prop = Dynamics(\n            f=jax.vmap(self._lowered.dynamics_prop.f, in_axes=(0, 0, 0, None)),\n        )\n\n        # Create compiled (JIT-compiled) constraints as new instances\n        # This preserves the original un-JIT'd versions in _lowered\n        # TODO: (haynec) switch to AOT instead of JIT\n        compiled_nodal = [\n            LoweredNodalConstraint(\n                func=jax.jit(c.func),\n                grad_g_x=jax.jit(c.grad_g_x),\n                grad_g_u=jax.jit(c.grad_g_u),\n                nodes=c.nodes,\n            )\n            for c in self._lowered.jax_constraints.nodal\n        ]\n\n        compiled_cross_node = [\n            LoweredCrossNodeConstraint(\n                func=jax.jit(c.func),\n                grad_g_X=jax.jit(c.grad_g_X),\n                grad_g_U=jax.jit(c.grad_g_U),\n            )\n            for c in self._lowered.jax_constraints.cross_node\n        ]\n\n        self._compiled_constraints = LoweredJaxConstraints(\n            nodal=compiled_nodal,\n            cross_node=compiled_cross_node,\n            ctcs=self._lowered.jax_constraints.ctcs,  # CTCS aren't JIT-compiled here\n        )\n\n        # Generate solvers using compiled (vmapped) dynamics\n        self._discretization_solver = get_discretization_solver(\n            self._compiled_dynamics, self.settings\n        )\n        self._propagation_solver = get_propagation_solver(\n            self._compiled_dynamics_prop.f, self.settings\n        )\n\n        # Build optimal control problem using LoweredProblem\n        self._optimal_control_problem = optimal_control_problem(self.settings, self._lowered)\n\n        # Get cache file paths using symbolic AST hashing\n        # This is more stable than hashing lowered JAX code\n        dis_solver_file, prop_solver_file = get_solver_cache_paths(\n            self.symbolic,\n            dt=self.settings.prp.dt,\n            total_time=self.settings.sim.total_time,\n        )\n\n        # Compile the discretization solver\n        self._discretization_solver = load_or_compile_discretization_solver(\n            self._discretization_solver,\n            dis_solver_file,\n            self._parameters,  # Plain dict for JAX\n            self.settings.scp.n,\n            self.settings.sim.n_states,\n            self.settings.sim.n_controls,\n            save_compiled=self.settings.sim.save_compiled,\n            debug=self.settings.dev.debug,\n        )\n\n        # Setup propagation solver parameters\n        dtau = 1.0 / (self.settings.scp.n - 1)\n        dt_max = self.settings.sim.u.max[self.settings.sim.time_dilation_slice][0] * dtau\n        self.settings.prp.max_tau_len = int(dt_max / self.settings.prp.dt) + 2\n\n        # Compile the propagation solver\n        self._propagation_solver = load_or_compile_propagation_solver(\n            self._propagation_solver,\n            prop_solver_file,\n            self._parameters,  # Plain dict for JAX\n            self.settings.sim.n_states_prop,\n            self.settings.sim.n_controls,\n            self.settings.prp.max_tau_len,\n            save_compiled=self.settings.sim.save_compiled,\n        )\n\n        # Initialize the PTR loop\n        print(\"Initializing the SCvx Subproblem Solver...\")\n        self.cpg_solve = PTR_init(\n            self._parameters,  # Plain dict for JAX/CVXPy\n            self._optimal_control_problem,\n            self._discretization_solver,\n            self.settings,\n            self._compiled_constraints,\n        )\n        print(\"\u2713 SCvx Subproblem Solver initialized\")\n\n        # Create fresh solver state\n        self._state = SolverState.from_settings(self.settings)\n\n        t_f_while = time.time()\n        self.timing_init = t_f_while - t_0_while\n        print(\"Total Initialization Time: \", self.timing_init)\n\n        # Prime the propagation solver\n        prime_propagation_solver(self._propagation_solver, self._parameters, self.settings)\n\n        profiling.profiling_end(pr, \"initialize\")\n\n    def reset(self):\n        \"\"\"Reset solver state to re-run optimization from initial conditions.\n\n        Creates fresh SolverState while preserving compiled dynamics and solvers.\n        Use this to run multiple optimizations without re-initializing.\n\n        Raises:\n            ValueError: If initialize() has not been called yet.\n\n        Example:\n            After calling `.step()` it may be necessary to reset the problem back to the initial\n            conditions\n\n                problem.initialize()\n                result1 = problem.step()\n                problem.reset()\n                result2 = problem.solve()  # Fresh run with same setup\n        \"\"\"\n        if self._compiled_dynamics is None:\n            raise ValueError(\"Problem has not been initialized. Call initialize() first\")\n\n        # Create fresh solver state from settings\n        self._state = SolverState.from_settings(self.settings)\n\n        # Reset solution\n        self._solution = None\n\n        # Reset timing\n        self.timing_solve = None\n        self.timing_post = None\n\n    def step(self) -&gt; dict:\n        \"\"\"Perform a single SCP iteration.\n\n        Designed for real-time plotting and interactive optimization. Performs one\n        iteration including subproblem solve, state update, and progress emission.\n\n        Note:\n            This method is NOT idempotent - it mutates internal state and advances\n            the iteration counter. Use reset() to return to initial conditions.\n\n        Returns:\n            dict: Contains \"converged\" (bool) and current iteration state\n\n        Example:\n            Call `.step()` manually in a loop to control the algorithm directly\n\n                problem.initialize()\n                while not problem.step()[\"converged\"]:\n                    plot_trajectory(problem.state.trajs[-1])\n        \"\"\"\n        if self._state is None:\n            raise ValueError(\"Problem has not been initialized. Call initialize() first\")\n\n        converged = PTR_step(\n            self._parameters,  # Plain dict for JAX/CVXPy\n            self.settings,\n            self._state,\n            self._optimal_control_problem,\n            self._discretization_solver,\n            self.cpg_solve,\n            self.emitter_function,\n            self._compiled_constraints,\n        )\n\n        # Return dict matching original API\n        return {\n            \"converged\": converged,\n            \"scp_k\": self._state.k,\n            \"scp_J_tr\": self._state.J_tr,\n            \"scp_J_vb\": self._state.J_vb,\n            \"scp_J_vc\": self._state.J_vc,\n        }\n\n    def solve(\n        self, max_iters: Optional[int] = None, continuous: bool = False\n    ) -&gt; OptimizationResults:\n        \"\"\"Run the SCP algorithm until convergence or iteration limit.\n\n        Args:\n            max_iters: Maximum iterations (default: settings.scp.k_max)\n            continuous: If True, run all iterations regardless of convergence\n\n        Returns:\n            OptimizationResults with trajectory and convergence info\n                (call post_process() for full propagation)\n        \"\"\"\n        # Sync parameters before solving\n        self._sync_parameters()\n\n        required = [\n            self._compiled_dynamics,\n            self._compiled_constraints,\n            self._optimal_control_problem,\n            self._discretization_solver,\n            self._state,\n        ]\n        if any(r is None for r in required):\n            raise ValueError(\"Problem has not been initialized. Call initialize() before solve()\")\n\n        # Enable the profiler\n        pr = profiling.profiling_start(self.settings.dev.profiling)\n\n        t_0_while = time.time()\n        # Print top header for solver results\n        printing.header()\n\n        k_max = max_iters if max_iters is not None else self.settings.scp.k_max\n\n        while self._state.k &lt;= k_max:\n            result = self.step()\n            if result[\"converged\"] and not continuous:\n                break\n\n        t_f_while = time.time()\n        self.timing_solve = t_f_while - t_0_while\n\n        while self.print_queue.qsize() &gt; 0:\n            time.sleep(0.1)\n\n        # Print bottom footer for solver results as well as total computation time\n        printing.footer()\n\n        profiling.profiling_end(pr, \"solve\")\n\n        # Store solution state\n        self._solution = copy.deepcopy(self._state)\n\n        return format_result(self, self._state, self._state.k &lt;= k_max)\n\n    def post_process(self) -&gt; OptimizationResults:\n        \"\"\"Propagate solution through full nonlinear dynamics for high-fidelity trajectory.\n\n        Integrates the converged SCP solution through the nonlinear dynamics to\n        produce x_full, u_full, and t_full. Call after solve() for final results.\n\n        Returns:\n            OptimizationResults with propagated trajectory fields\n\n        Raises:\n            ValueError: If solve() has not been called yet.\n        \"\"\"\n        if self._solution is None:\n            raise ValueError(\"No solution available. Call solve() first.\")\n\n        # Enable the profiler\n        pr = profiling.profiling_start(self.settings.dev.profiling)\n\n        # Create result from stored solution state\n        result = format_result(self, self._solution, self._solution.k &lt;= self.settings.scp.k_max)\n\n        t_0_post = time.time()\n        result = propagate_trajectory_results(\n            self._parameters, self.settings, result, self._propagation_solver\n        )\n        t_f_post = time.time()\n\n        self.timing_post = t_f_post - t_0_post\n\n        # Print results summary\n        printing.print_results_summary(\n            result, self.timing_post, self.timing_init, self.timing_solve\n        )\n\n        profiling.profiling_end(pr, \"postprocess\")\n        return result\n</code></pre>"},{"location":"reference/problem/#openscvx.problem.Problem.lowered","title":"<code>lowered: LoweredProblem</code>  <code>property</code>","text":"<p>Access the lowered problem containing JAX/CVXPy objects.</p> <p>Returns:</p> Type Description <code>LoweredProblem</code> <p>LoweredProblem with dynamics, constraints, unified interfaces, and CVXPy vars</p>"},{"location":"reference/problem/#openscvx.problem.Problem.parameters","title":"<code>parameters</code>  <code>property</code> <code>writable</code>","text":"<p>Get the parameters dictionary.</p> The returned dictionary automatically syncs to CVXPy when modified <p>problem.parameters[\"obs_radius\"] = 2.0  # Auto-syncs to CVXPy problem.parameters.update({\"gate_0_center\": center})  # Also syncs</p> <p>Returns:</p> Name Type Description <code>ParameterDict</code> <p>Special dict that syncs to CVXPy on assignment</p>"},{"location":"reference/problem/#openscvx.problem.Problem.state","title":"<code>state: Optional[SolverState]</code>  <code>property</code>","text":"<p>Access the current solver state.</p> <p>The solver state contains all mutable state from the SCP iterations, including current guesses, costs, weights, and history.</p> <p>Returns:</p> Type Description <code>Optional[SolverState]</code> <p>SolverState if initialized, None otherwise</p> Example <p>When using <code>Problem.step()</code> can use the state to check convergence etc.</p> <pre><code>problem.initialize()\nproblem.step()\nprint(f\"Iteration {problem.state.k}, J_tr={problem.state.J_tr}\")\n</code></pre>"},{"location":"reference/problem/#openscvx.problem.Problem.u_unified","title":"<code>u_unified</code>  <code>property</code>","text":"<p>Unified control interface (delegates to lowered.u_unified).</p>"},{"location":"reference/problem/#openscvx.problem.Problem.x_unified","title":"<code>x_unified</code>  <code>property</code>","text":"<p>Unified state interface (delegates to lowered.x_unified).</p>"},{"location":"reference/problem/#openscvx.problem.Problem._sync_parameters","title":"<code>_sync_parameters()</code>","text":"<p>Sync all parameter values to CVXPy parameters.</p> Source code in <code>openscvx/problem.py</code> <pre><code>def _sync_parameters(self):\n    \"\"\"Sync all parameter values to CVXPy parameters.\"\"\"\n    if self._lowered.cvxpy_params is not None:\n        for name, value in self._parameter_wrapper.items():\n            if name in self._lowered.cvxpy_params:\n                self._lowered.cvxpy_params[name].value = value\n</code></pre>"},{"location":"reference/problem/#openscvx.problem.Problem.initialize","title":"<code>initialize()</code>","text":"<p>Compile dynamics, constraints, and solvers; prepare for optimization.</p> <p>This method vmaps dynamics, JIT-compiles constraints, builds the convex subproblem, and initializes the solver state. Must be called before solve().</p> Example <p>Prior to calling the <code>.solve()</code> method it is necessary to initialize the problem</p> <pre><code>problem = Problem(dynamics, constraints, states, controls, N, time)\nproblem.initialize()  # Compile and prepare\nproblem.solve()       # Run optimization\n</code></pre> Source code in <code>openscvx/problem.py</code> <pre><code>def initialize(self):\n    \"\"\"Compile dynamics, constraints, and solvers; prepare for optimization.\n\n    This method vmaps dynamics, JIT-compiles constraints, builds the convex\n    subproblem, and initializes the solver state. Must be called before solve().\n\n    Example:\n        Prior to calling the `.solve()` method it is necessary to initialize the problem\n\n            problem = Problem(dynamics, constraints, states, controls, N, time)\n            problem.initialize()  # Compile and prepare\n            problem.solve()       # Run optimization\n    \"\"\"\n    printing.intro()\n\n    # Print problem summary\n    printing.print_problem_summary(self.settings, self._lowered)\n\n    # Enable the profiler\n    pr = profiling.profiling_start(self.settings.dev.profiling)\n\n    t_0_while = time.time()\n    # Ensure parameter sizes and normalization are correct\n    self.settings.scp.__post_init__()\n    self.settings.sim.__post_init__()\n\n    # Create compiled (vmapped) dynamics as new instances\n    # This preserves the original un-vmapped versions in _lowered\n    self._compiled_dynamics = Dynamics(\n        f=jax.vmap(self._lowered.dynamics.f, in_axes=(0, 0, 0, None)),\n        A=jax.vmap(self._lowered.dynamics.A, in_axes=(0, 0, 0, None)),\n        B=jax.vmap(self._lowered.dynamics.B, in_axes=(0, 0, 0, None)),\n    )\n\n    self._compiled_dynamics_prop = Dynamics(\n        f=jax.vmap(self._lowered.dynamics_prop.f, in_axes=(0, 0, 0, None)),\n    )\n\n    # Create compiled (JIT-compiled) constraints as new instances\n    # This preserves the original un-JIT'd versions in _lowered\n    # TODO: (haynec) switch to AOT instead of JIT\n    compiled_nodal = [\n        LoweredNodalConstraint(\n            func=jax.jit(c.func),\n            grad_g_x=jax.jit(c.grad_g_x),\n            grad_g_u=jax.jit(c.grad_g_u),\n            nodes=c.nodes,\n        )\n        for c in self._lowered.jax_constraints.nodal\n    ]\n\n    compiled_cross_node = [\n        LoweredCrossNodeConstraint(\n            func=jax.jit(c.func),\n            grad_g_X=jax.jit(c.grad_g_X),\n            grad_g_U=jax.jit(c.grad_g_U),\n        )\n        for c in self._lowered.jax_constraints.cross_node\n    ]\n\n    self._compiled_constraints = LoweredJaxConstraints(\n        nodal=compiled_nodal,\n        cross_node=compiled_cross_node,\n        ctcs=self._lowered.jax_constraints.ctcs,  # CTCS aren't JIT-compiled here\n    )\n\n    # Generate solvers using compiled (vmapped) dynamics\n    self._discretization_solver = get_discretization_solver(\n        self._compiled_dynamics, self.settings\n    )\n    self._propagation_solver = get_propagation_solver(\n        self._compiled_dynamics_prop.f, self.settings\n    )\n\n    # Build optimal control problem using LoweredProblem\n    self._optimal_control_problem = optimal_control_problem(self.settings, self._lowered)\n\n    # Get cache file paths using symbolic AST hashing\n    # This is more stable than hashing lowered JAX code\n    dis_solver_file, prop_solver_file = get_solver_cache_paths(\n        self.symbolic,\n        dt=self.settings.prp.dt,\n        total_time=self.settings.sim.total_time,\n    )\n\n    # Compile the discretization solver\n    self._discretization_solver = load_or_compile_discretization_solver(\n        self._discretization_solver,\n        dis_solver_file,\n        self._parameters,  # Plain dict for JAX\n        self.settings.scp.n,\n        self.settings.sim.n_states,\n        self.settings.sim.n_controls,\n        save_compiled=self.settings.sim.save_compiled,\n        debug=self.settings.dev.debug,\n    )\n\n    # Setup propagation solver parameters\n    dtau = 1.0 / (self.settings.scp.n - 1)\n    dt_max = self.settings.sim.u.max[self.settings.sim.time_dilation_slice][0] * dtau\n    self.settings.prp.max_tau_len = int(dt_max / self.settings.prp.dt) + 2\n\n    # Compile the propagation solver\n    self._propagation_solver = load_or_compile_propagation_solver(\n        self._propagation_solver,\n        prop_solver_file,\n        self._parameters,  # Plain dict for JAX\n        self.settings.sim.n_states_prop,\n        self.settings.sim.n_controls,\n        self.settings.prp.max_tau_len,\n        save_compiled=self.settings.sim.save_compiled,\n    )\n\n    # Initialize the PTR loop\n    print(\"Initializing the SCvx Subproblem Solver...\")\n    self.cpg_solve = PTR_init(\n        self._parameters,  # Plain dict for JAX/CVXPy\n        self._optimal_control_problem,\n        self._discretization_solver,\n        self.settings,\n        self._compiled_constraints,\n    )\n    print(\"\u2713 SCvx Subproblem Solver initialized\")\n\n    # Create fresh solver state\n    self._state = SolverState.from_settings(self.settings)\n\n    t_f_while = time.time()\n    self.timing_init = t_f_while - t_0_while\n    print(\"Total Initialization Time: \", self.timing_init)\n\n    # Prime the propagation solver\n    prime_propagation_solver(self._propagation_solver, self._parameters, self.settings)\n\n    profiling.profiling_end(pr, \"initialize\")\n</code></pre>"},{"location":"reference/problem/#openscvx.problem.Problem.post_process","title":"<code>post_process() -&gt; OptimizationResults</code>","text":"<p>Propagate solution through full nonlinear dynamics for high-fidelity trajectory.</p> <p>Integrates the converged SCP solution through the nonlinear dynamics to produce x_full, u_full, and t_full. Call after solve() for final results.</p> <p>Returns:</p> Type Description <code>OptimizationResults</code> <p>OptimizationResults with propagated trajectory fields</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If solve() has not been called yet.</p> Source code in <code>openscvx/problem.py</code> <pre><code>def post_process(self) -&gt; OptimizationResults:\n    \"\"\"Propagate solution through full nonlinear dynamics for high-fidelity trajectory.\n\n    Integrates the converged SCP solution through the nonlinear dynamics to\n    produce x_full, u_full, and t_full. Call after solve() for final results.\n\n    Returns:\n        OptimizationResults with propagated trajectory fields\n\n    Raises:\n        ValueError: If solve() has not been called yet.\n    \"\"\"\n    if self._solution is None:\n        raise ValueError(\"No solution available. Call solve() first.\")\n\n    # Enable the profiler\n    pr = profiling.profiling_start(self.settings.dev.profiling)\n\n    # Create result from stored solution state\n    result = format_result(self, self._solution, self._solution.k &lt;= self.settings.scp.k_max)\n\n    t_0_post = time.time()\n    result = propagate_trajectory_results(\n        self._parameters, self.settings, result, self._propagation_solver\n    )\n    t_f_post = time.time()\n\n    self.timing_post = t_f_post - t_0_post\n\n    # Print results summary\n    printing.print_results_summary(\n        result, self.timing_post, self.timing_init, self.timing_solve\n    )\n\n    profiling.profiling_end(pr, \"postprocess\")\n    return result\n</code></pre>"},{"location":"reference/problem/#openscvx.problem.Problem.reset","title":"<code>reset()</code>","text":"<p>Reset solver state to re-run optimization from initial conditions.</p> <p>Creates fresh SolverState while preserving compiled dynamics and solvers. Use this to run multiple optimizations without re-initializing.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If initialize() has not been called yet.</p> Example <p>After calling <code>.step()</code> it may be necessary to reset the problem back to the initial conditions</p> <pre><code>problem.initialize()\nresult1 = problem.step()\nproblem.reset()\nresult2 = problem.solve()  # Fresh run with same setup\n</code></pre> Source code in <code>openscvx/problem.py</code> <pre><code>def reset(self):\n    \"\"\"Reset solver state to re-run optimization from initial conditions.\n\n    Creates fresh SolverState while preserving compiled dynamics and solvers.\n    Use this to run multiple optimizations without re-initializing.\n\n    Raises:\n        ValueError: If initialize() has not been called yet.\n\n    Example:\n        After calling `.step()` it may be necessary to reset the problem back to the initial\n        conditions\n\n            problem.initialize()\n            result1 = problem.step()\n            problem.reset()\n            result2 = problem.solve()  # Fresh run with same setup\n    \"\"\"\n    if self._compiled_dynamics is None:\n        raise ValueError(\"Problem has not been initialized. Call initialize() first\")\n\n    # Create fresh solver state from settings\n    self._state = SolverState.from_settings(self.settings)\n\n    # Reset solution\n    self._solution = None\n\n    # Reset timing\n    self.timing_solve = None\n    self.timing_post = None\n</code></pre>"},{"location":"reference/problem/#openscvx.problem.Problem.solve","title":"<code>solve(max_iters: Optional[int] = None, continuous: bool = False) -&gt; OptimizationResults</code>","text":"<p>Run the SCP algorithm until convergence or iteration limit.</p> <p>Parameters:</p> Name Type Description Default <code>max_iters</code> <code>Optional[int]</code> <p>Maximum iterations (default: settings.scp.k_max)</p> <code>None</code> <code>continuous</code> <code>bool</code> <p>If True, run all iterations regardless of convergence</p> <code>False</code> <p>Returns:</p> Type Description <code>OptimizationResults</code> <p>OptimizationResults with trajectory and convergence info (call post_process() for full propagation)</p> Source code in <code>openscvx/problem.py</code> <pre><code>def solve(\n    self, max_iters: Optional[int] = None, continuous: bool = False\n) -&gt; OptimizationResults:\n    \"\"\"Run the SCP algorithm until convergence or iteration limit.\n\n    Args:\n        max_iters: Maximum iterations (default: settings.scp.k_max)\n        continuous: If True, run all iterations regardless of convergence\n\n    Returns:\n        OptimizationResults with trajectory and convergence info\n            (call post_process() for full propagation)\n    \"\"\"\n    # Sync parameters before solving\n    self._sync_parameters()\n\n    required = [\n        self._compiled_dynamics,\n        self._compiled_constraints,\n        self._optimal_control_problem,\n        self._discretization_solver,\n        self._state,\n    ]\n    if any(r is None for r in required):\n        raise ValueError(\"Problem has not been initialized. Call initialize() before solve()\")\n\n    # Enable the profiler\n    pr = profiling.profiling_start(self.settings.dev.profiling)\n\n    t_0_while = time.time()\n    # Print top header for solver results\n    printing.header()\n\n    k_max = max_iters if max_iters is not None else self.settings.scp.k_max\n\n    while self._state.k &lt;= k_max:\n        result = self.step()\n        if result[\"converged\"] and not continuous:\n            break\n\n    t_f_while = time.time()\n    self.timing_solve = t_f_while - t_0_while\n\n    while self.print_queue.qsize() &gt; 0:\n        time.sleep(0.1)\n\n    # Print bottom footer for solver results as well as total computation time\n    printing.footer()\n\n    profiling.profiling_end(pr, \"solve\")\n\n    # Store solution state\n    self._solution = copy.deepcopy(self._state)\n\n    return format_result(self, self._state, self._state.k &lt;= k_max)\n</code></pre>"},{"location":"reference/problem/#openscvx.problem.Problem.step","title":"<code>step() -&gt; dict</code>","text":"<p>Perform a single SCP iteration.</p> <p>Designed for real-time plotting and interactive optimization. Performs one iteration including subproblem solve, state update, and progress emission.</p> Note <p>This method is NOT idempotent - it mutates internal state and advances the iteration counter. Use reset() to return to initial conditions.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Contains \"converged\" (bool) and current iteration state</p> Example <p>Call <code>.step()</code> manually in a loop to control the algorithm directly</p> <pre><code>problem.initialize()\nwhile not problem.step()[\"converged\"]:\n    plot_trajectory(problem.state.trajs[-1])\n</code></pre> Source code in <code>openscvx/problem.py</code> <pre><code>def step(self) -&gt; dict:\n    \"\"\"Perform a single SCP iteration.\n\n    Designed for real-time plotting and interactive optimization. Performs one\n    iteration including subproblem solve, state update, and progress emission.\n\n    Note:\n        This method is NOT idempotent - it mutates internal state and advances\n        the iteration counter. Use reset() to return to initial conditions.\n\n    Returns:\n        dict: Contains \"converged\" (bool) and current iteration state\n\n    Example:\n        Call `.step()` manually in a loop to control the algorithm directly\n\n            problem.initialize()\n            while not problem.step()[\"converged\"]:\n                plot_trajectory(problem.state.trajs[-1])\n    \"\"\"\n    if self._state is None:\n        raise ValueError(\"Problem has not been initialized. Call initialize() first\")\n\n    converged = PTR_step(\n        self._parameters,  # Plain dict for JAX/CVXPy\n        self.settings,\n        self._state,\n        self._optimal_control_problem,\n        self._discretization_solver,\n        self.cpg_solve,\n        self.emitter_function,\n        self._compiled_constraints,\n    )\n\n    # Return dict matching original API\n    return {\n        \"converged\": converged,\n        \"scp_k\": self._state.k,\n        \"scp_J_tr\": self._state.J_tr,\n        \"scp_J_vb\": self._state.J_vb,\n        \"scp_J_vc\": self._state.J_vc,\n    }\n</code></pre>"},{"location":"reference/algorithms/","title":"algorithms","text":"<p>Successive convexification algorithms for trajectory optimization.</p> <p>This module provides implementations of SCvx (Successive Convexification) algorithms for solving non-convex trajectory optimization problems through iterative convex approximation.</p> Current Implementations <p>PTR (Penalized Trust Region): The default SCvx algorithm using trust region     methods with penalty-based constraint handling. Includes adaptive parameter     tuning and virtual control relaxation.</p> <p>Planned Architecture (ABC-based):</p> <p>A base class will be introduced to enable pluggable algorithm implementations. This will enable users to implement custom SCvx variants or research algorithms. Future algorithms will implement the SCvxAlgorithm interface:</p> <pre><code># algorithms/base.py (planned):\nclass SCvxAlgorithm(ABC):\n    @abstractmethod\n    def initialize(self, lowered: LoweredProblem) -&gt; SolverState:\n        '''Initialize solver state from a lowered problem.'''\n        ...\n\n    @abstractmethod\n    def step(self, state: SolverState, solver: ConvexSolver) -&gt; SolverState:\n        '''Execute one iteration of the algorithm.'''\n        ...\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.OptimizationResults","title":"<code>OptimizationResults</code>  <code>dataclass</code>","text":"<p>Structured container for optimization results from the Successive Convexification (SCP) solver.</p> <p>This class provides a type-safe and organized way to store and access optimization results, replacing the previous dictionary-based approach. It includes core optimization data, iteration history for convergence analysis, post-processing results, and flexible storage for plotting and application-specific data.</p> <p>Attributes:</p> Name Type Description <code>converged</code> <code>bool</code> <p>Whether the optimization successfully converged</p> <code>t_final</code> <code>float</code> <p>Final time of the optimized trajectory</p> <code>x_guess</code> <code>ndarray</code> <p>Optimized state trajectory at discretization nodes, shape (N, n_states)</p> <code>u_guess</code> <code>ndarray</code> <p>Optimized control trajectory at discretization nodes, shape (N, n_controls)</p> <code>nodes</code> <code>dict[str, ndarray]</code> <p>Dictionary mapping state/control names to arrays at optimization nodes. Includes both user-defined and augmented variables.</p> <code>trajectory</code> <code>dict[str, ndarray]</code> <p>Dictionary mapping state/control names to arrays along the propagated trajectory. Added by post_process().</p> <code>x_history</code> <code>list[ndarray]</code> <p>State trajectories from each SCP iteration</p> <code>u_history</code> <code>list[ndarray]</code> <p>Control trajectories from each SCP iteration</p> <code>discretization_history</code> <code>list[ndarray]</code> <p>Time discretization from each iteration</p> <code>J_tr_history</code> <code>list[ndarray]</code> <p>Trust region cost history</p> <code>J_vb_history</code> <code>list[ndarray]</code> <p>Virtual buffer cost history</p> <code>J_vc_history</code> <code>list[ndarray]</code> <p>Virtual control cost history</p> <code>t_full</code> <code>Optional[ndarray]</code> <p>Full time grid for interpolated trajectory</p> <code>x_full</code> <code>Optional[ndarray]</code> <p>Interpolated state trajectory on full time grid</p> <code>u_full</code> <code>Optional[ndarray]</code> <p>Interpolated control trajectory on full time grid</p> <code>cost</code> <code>Optional[float]</code> <p>Total cost of the optimized trajectory</p> <code>ctcs_violation</code> <code>Optional[ndarray]</code> <p>Continuous-time constraint violations</p> <code>plotting_data</code> <code>dict[str, Any]</code> <p>Flexible storage for plotting and application data</p> Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>@dataclass\nclass OptimizationResults:\n    \"\"\"\n    Structured container for optimization results from the Successive Convexification (SCP) solver.\n\n    This class provides a type-safe and organized way to store and access optimization results,\n    replacing the previous dictionary-based approach. It includes core optimization data,\n    iteration history for convergence analysis, post-processing results, and flexible\n    storage for plotting and application-specific data.\n\n    Attributes:\n        converged (bool): Whether the optimization successfully converged\n        t_final (float): Final time of the optimized trajectory\n        x_guess (np.ndarray): Optimized state trajectory at discretization nodes,\n            shape (N, n_states)\n        u_guess (np.ndarray): Optimized control trajectory at discretization nodes,\n            shape (N, n_controls)\n\n        # Dictionary-based Access\n        nodes (dict[str, np.ndarray]): Dictionary mapping state/control names to arrays\n            at optimization nodes. Includes both user-defined and augmented variables.\n        trajectory (dict[str, np.ndarray]): Dictionary mapping state/control names to arrays\n            along the propagated trajectory. Added by post_process().\n\n        # SCP Iteration History (for convergence analysis)\n        x_history (list[np.ndarray]): State trajectories from each SCP iteration\n        u_history (list[np.ndarray]): Control trajectories from each SCP iteration\n        discretization_history (list[np.ndarray]): Time discretization from each iteration\n        J_tr_history (list[np.ndarray]): Trust region cost history\n        J_vb_history (list[np.ndarray]): Virtual buffer cost history\n        J_vc_history (list[np.ndarray]): Virtual control cost history\n\n        # Post-processing Results (added by propagate_trajectory_results)\n        t_full (Optional[np.ndarray]): Full time grid for interpolated trajectory\n        x_full (Optional[np.ndarray]): Interpolated state trajectory on full time grid\n        u_full (Optional[np.ndarray]): Interpolated control trajectory on full time grid\n        cost (Optional[float]): Total cost of the optimized trajectory\n        ctcs_violation (Optional[np.ndarray]): Continuous-time constraint violations\n\n        # User-defined Data\n        plotting_data (dict[str, Any]): Flexible storage for plotting and application data\n    \"\"\"\n\n    # Core optimization results\n    converged: bool\n    t_final: float\n\n    # Dictionary-based access to states and controls\n    nodes: dict[str, np.ndarray] = field(default_factory=dict)\n    trajectory: dict[str, np.ndarray] = field(default_factory=dict)\n\n    # Internal metadata for dictionary construction\n    _states: list = field(default_factory=list, repr=False)\n    _controls: list = field(default_factory=list, repr=False)\n\n    # History of SCP iterations (single source of truth)\n    X: list[np.ndarray] = field(default_factory=list)\n    U: list[np.ndarray] = field(default_factory=list)\n    discretization_history: list[np.ndarray] = field(default_factory=list)\n    J_tr_history: list[np.ndarray] = field(default_factory=list)\n    J_vb_history: list[np.ndarray] = field(default_factory=list)\n    J_vc_history: list[np.ndarray] = field(default_factory=list)\n\n    @property\n    def x(self) -&gt; np.ndarray:\n        \"\"\"Optimal state trajectory at discretization nodes.\n\n        Returns the final converged solution from the SCP iteration history.\n\n        Returns:\n            State trajectory array, shape (N, n_states)\n        \"\"\"\n        return self.X[-1]\n\n    @property\n    def u(self) -&gt; np.ndarray:\n        \"\"\"Optimal control trajectory at discretization nodes.\n\n        Returns the final converged solution from the SCP iteration history.\n\n        Returns:\n            Control trajectory array, shape (N, n_controls)\n        \"\"\"\n        return self.U[-1]\n\n    # Post-processing results (added by propagate_trajectory_results)\n    t_full: Optional[np.ndarray] = None\n    x_full: Optional[np.ndarray] = None\n    u_full: Optional[np.ndarray] = None\n    cost: Optional[float] = None\n    ctcs_violation: Optional[np.ndarray] = None\n\n    # Additional plotting/application data (added by user)\n    plotting_data: dict[str, Any] = field(default_factory=dict)\n\n    def __post_init__(self):\n        \"\"\"Initialize the results object.\"\"\"\n        pass\n\n    def update_plotting_data(self, **kwargs):\n        \"\"\"\n        Update the plotting data with additional information.\n\n        Args:\n            **kwargs: Key-value pairs to add to plotting_data\n        \"\"\"\n        self.plotting_data.update(kwargs)\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"\n        Get a value from the results, similar to dict.get().\n\n        Args:\n            key: The key to look up\n            default: Default value if key is not found\n\n        Returns:\n            The value associated with the key, or default if not found\n        \"\"\"\n        # Check if it's a direct attribute\n        if hasattr(self, key):\n            return getattr(self, key)\n\n        # Check if it's in plotting_data\n        if key in self.plotting_data:\n            return self.plotting_data[key]\n\n        return default\n\n    def __getitem__(self, key: str) -&gt; Any:\n        \"\"\"\n        Allow dictionary-style access to results.\n\n        Args:\n            key: The key to look up\n\n        Returns:\n            The value associated with the key\n\n        Raises:\n            KeyError: If key is not found\n        \"\"\"\n        # Check if it's a direct attribute\n        if hasattr(self, key):\n            return getattr(self, key)\n\n        # Check if it's in plotting_data\n        if key in self.plotting_data:\n            return self.plotting_data[key]\n\n        raise KeyError(f\"Key '{key}' not found in results\")\n\n    def __setitem__(self, key: str, value: Any):\n        \"\"\"\n        Allow dictionary-style assignment to results.\n\n        Args:\n            key: The key to set\n            value: The value to assign\n        \"\"\"\n        # Check if it's a direct attribute\n        if hasattr(self, key):\n            setattr(self, key, value)\n        else:\n            # Store in plotting_data\n            self.plotting_data[key] = value\n\n    def __contains__(self, key: str) -&gt; bool:\n        \"\"\"\n        Check if a key exists in the results.\n\n        Args:\n            key: The key to check\n\n        Returns:\n            True if key exists, False otherwise\n        \"\"\"\n        return hasattr(self, key) or key in self.plotting_data\n\n    def update(self, other: dict[str, Any]):\n        \"\"\"\n        Update the results with additional data from a dictionary.\n\n        Args:\n            other: Dictionary containing additional data\n        \"\"\"\n        for key, value in other.items():\n            self[key] = value\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Convert the results to a dictionary for backward compatibility.\n\n        Returns:\n            Dictionary representation of the results\n        \"\"\"\n        result_dict = {}\n\n        # Add all direct attributes\n        for attr_name in self.__dataclass_fields__:\n            if attr_name != \"plotting_data\":\n                result_dict[attr_name] = getattr(self, attr_name)\n\n        # Add plotting data\n        result_dict.update(self.plotting_data)\n\n        return result_dict\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.OptimizationResults.u","title":"<code>u: np.ndarray</code>  <code>property</code>","text":"<p>Optimal control trajectory at discretization nodes.</p> <p>Returns the final converged solution from the SCP iteration history.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Control trajectory array, shape (N, n_controls)</p>"},{"location":"reference/algorithms/#openscvx.algorithms.OptimizationResults.x","title":"<code>x: np.ndarray</code>  <code>property</code>","text":"<p>Optimal state trajectory at discretization nodes.</p> <p>Returns the final converged solution from the SCP iteration history.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>State trajectory array, shape (N, n_states)</p>"},{"location":"reference/algorithms/#openscvx.algorithms.OptimizationResults.get","title":"<code>get(key: str, default: Any = None) -&gt; Any</code>","text":"<p>Get a value from the results, similar to dict.get().</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to look up</p> required <code>default</code> <code>Any</code> <p>Default value if key is not found</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The value associated with the key, or default if not found</p> Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"\n    Get a value from the results, similar to dict.get().\n\n    Args:\n        key: The key to look up\n        default: Default value if key is not found\n\n    Returns:\n        The value associated with the key, or default if not found\n    \"\"\"\n    # Check if it's a direct attribute\n    if hasattr(self, key):\n        return getattr(self, key)\n\n    # Check if it's in plotting_data\n    if key in self.plotting_data:\n        return self.plotting_data[key]\n\n    return default\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.OptimizationResults.to_dict","title":"<code>to_dict() -&gt; dict[str, Any]</code>","text":"<p>Convert the results to a dictionary for backward compatibility.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary representation of the results</p> Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the results to a dictionary for backward compatibility.\n\n    Returns:\n        Dictionary representation of the results\n    \"\"\"\n    result_dict = {}\n\n    # Add all direct attributes\n    for attr_name in self.__dataclass_fields__:\n        if attr_name != \"plotting_data\":\n            result_dict[attr_name] = getattr(self, attr_name)\n\n    # Add plotting data\n    result_dict.update(self.plotting_data)\n\n    return result_dict\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.OptimizationResults.update","title":"<code>update(other: dict[str, Any])</code>","text":"<p>Update the results with additional data from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>dict[str, Any]</code> <p>Dictionary containing additional data</p> required Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>def update(self, other: dict[str, Any]):\n    \"\"\"\n    Update the results with additional data from a dictionary.\n\n    Args:\n        other: Dictionary containing additional data\n    \"\"\"\n    for key, value in other.items():\n        self[key] = value\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.OptimizationResults.update_plotting_data","title":"<code>update_plotting_data(**kwargs)</code>","text":"<p>Update the plotting data with additional information.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Key-value pairs to add to plotting_data</p> <code>{}</code> Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>def update_plotting_data(self, **kwargs):\n    \"\"\"\n    Update the plotting data with additional information.\n\n    Args:\n        **kwargs: Key-value pairs to add to plotting_data\n    \"\"\"\n    self.plotting_data.update(kwargs)\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.SolverState","title":"<code>SolverState</code>  <code>dataclass</code>","text":"<p>Mutable state for SCP iterations.</p> <p>This dataclass holds all state that changes during the solve process. It stores only the evolving trajectory arrays, not the full State/Control objects which contain immutable configuration metadata.</p> <p>Trajectory arrays are stored in history lists, with the current guess accessed via properties that return the latest entry.</p> <p>A fresh instance is created for each solve, enabling easy reset functionality.</p> <p>Attributes:</p> Name Type Description <code>k</code> <code>int</code> <p>Current iteration number (starts at 1)</p> <code>J_tr</code> <code>float</code> <p>Current trust region cost</p> <code>J_vb</code> <code>float</code> <p>Current virtual buffer cost</p> <code>J_vc</code> <code>float</code> <p>Current virtual control cost</p> <code>w_tr</code> <code>float</code> <p>Current trust region weight (may adapt during solve)</p> <code>lam_cost</code> <code>float</code> <p>Current cost weight (may relax during solve)</p> <code>lam_vc</code> <code>Union[float, ndarray]</code> <p>Current virtual control penalty weight</p> <code>lam_vb</code> <code>float</code> <p>Current virtual buffer penalty weight</p> <code>n_x</code> <code>int</code> <p>Number of states (for unpacking V vectors)</p> <code>n_u</code> <code>int</code> <p>Number of controls (for unpacking V vectors)</p> <code>N</code> <code>int</code> <p>Number of trajectory nodes (for unpacking V vectors)</p> <code>X</code> <code>List[ndarray]</code> <p>List of state trajectory iterates</p> <code>U</code> <code>List[ndarray]</code> <p>List of control trajectory iterates</p> <code>V_history</code> <code>List[ndarray]</code> <p>List of discretization history</p> Source code in <code>openscvx/algorithms/solver_state.py</code> <pre><code>@dataclass\nclass SolverState:\n    \"\"\"Mutable state for SCP iterations.\n\n    This dataclass holds all state that changes during the solve process.\n    It stores only the evolving trajectory arrays, not the full State/Control\n    objects which contain immutable configuration metadata.\n\n    Trajectory arrays are stored in history lists, with the current guess\n    accessed via properties that return the latest entry.\n\n    A fresh instance is created for each solve, enabling easy reset functionality.\n\n    Attributes:\n        k: Current iteration number (starts at 1)\n        J_tr: Current trust region cost\n        J_vb: Current virtual buffer cost\n        J_vc: Current virtual control cost\n        w_tr: Current trust region weight (may adapt during solve)\n        lam_cost: Current cost weight (may relax during solve)\n        lam_vc: Current virtual control penalty weight\n        lam_vb: Current virtual buffer penalty weight\n        n_x: Number of states (for unpacking V vectors)\n        n_u: Number of controls (for unpacking V vectors)\n        N: Number of trajectory nodes (for unpacking V vectors)\n        X: List of state trajectory iterates\n        U: List of control trajectory iterates\n        V_history: List of discretization history\n    \"\"\"\n\n    k: int\n    J_tr: float\n    J_vb: float\n    J_vc: float\n    w_tr: float\n    lam_cost: float\n    lam_vc: Union[float, np.ndarray]\n    lam_vb: float\n    n_x: int\n    n_u: int\n    N: int\n    X: List[np.ndarray] = field(default_factory=list)\n    U: List[np.ndarray] = field(default_factory=list)\n    V_history: List[np.ndarray] = field(default_factory=list)\n\n    @property\n    def x(self) -&gt; np.ndarray:\n        \"\"\"Get current state trajectory array.\n\n        Returns:\n            Current state trajectory guess (latest entry in history), shape (N, n_states)\n        \"\"\"\n        return self.X[-1]\n\n    @property\n    def u(self) -&gt; np.ndarray:\n        \"\"\"Get current control trajectory array.\n\n        Returns:\n            Current control trajectory guess (latest entry in history), shape (N, n_controls)\n        \"\"\"\n        return self.U[-1]\n\n    @property\n    def x_prop(self) -&gt; np.ndarray:\n        \"\"\"Extract propagated state trajectory from latest V.\n\n        Returns:\n            Propagated state trajectory x_prop with shape (N-1, n_x), or None if no V_history\n\n        Example:\n            After running an iteration, access the propagated states::\n\n                problem.step()\n                x_prop = problem.state.x_prop  # Shape (N-1, n_x)\n        \"\"\"\n        if not self.V_history:\n            return None\n\n        # V_history contains Vmulti from discretization\n        # Shape: (flattened_size, n_timesteps) where flattened_size = (N-1) * i4\n        V = self.V_history[-1]\n\n        # Take final timestep and reshape to (N-1, i4)\n        i4 = self.n_x + self.n_x * self.n_x + 2 * self.n_x * self.n_u\n        V_final = V[:, -1].reshape(-1, i4)\n\n        # Extract propagated state (first n_x elements of each row)\n        return V_final[:, : self.n_x]\n\n    @property\n    def A_d(self) -&gt; np.ndarray:\n        \"\"\"Extract discretized state transition matrix from latest V.\n\n        Returns:\n            Discretized state Jacobian A_d with shape (N-1, n_x, n_x), or None if no V_history\n\n        Example:\n            After running an iteration, access linearization matrices::\n\n                problem.step()\n                A_d = problem.state.A_d  # Shape (N-1, n_x, n_x)\n        \"\"\"\n        if not self.V_history:\n            return None\n\n        # Extract indices for unpacking V vector\n        i1 = self.n_x\n        i2 = i1 + self.n_x * self.n_x\n\n        # V_history contains Vmulti from discretization\n        # Shape: (flattened_size, n_timesteps) where flattened_size = (N-1) * i4\n        V = self.V_history[-1]\n\n        # Take final timestep and reshape to (N-1, i4)\n        i4 = self.n_x + self.n_x * self.n_x + 2 * self.n_x * self.n_u\n        V_final = V[:, -1].reshape(-1, i4)\n\n        # Extract and reshape A_d matrix\n        return V_final[:, i1:i2].reshape(self.N - 1, self.n_x, self.n_x)\n\n    @property\n    def B_d(self) -&gt; np.ndarray:\n        \"\"\"Extract discretized control influence matrix (current node) from latest V.\n\n        Returns:\n            Discretized control Jacobian B_d with shape (N-1, n_x, n_u), or None if no V_history\n\n        Example:\n            After running an iteration, access linearization matrices::\n\n                problem.step()\n                B_d = problem.state.B_d  # Shape (N-1, n_x, n_u)\n        \"\"\"\n        if not self.V_history:\n            return None\n\n        # Extract indices for unpacking V vector\n        i1 = self.n_x\n        i2 = i1 + self.n_x * self.n_x\n        i3 = i2 + self.n_x * self.n_u\n\n        # V_history contains Vmulti from discretization\n        V = self.V_history[-1]\n\n        # Take final timestep and reshape to (N-1, i4)\n        i4 = self.n_x + self.n_x * self.n_x + 2 * self.n_x * self.n_u\n        V_final = V[:, -1].reshape(-1, i4)\n\n        # Extract and reshape B_d matrix\n        return V_final[:, i2:i3].reshape(self.N - 1, self.n_x, self.n_u)\n\n    @property\n    def C_d(self) -&gt; np.ndarray:\n        \"\"\"Extract discretized control influence matrix (next node) from latest V.\n\n        Returns:\n            Discretized control Jacobian C_d with shape (N-1, n_x, n_u), or None if no V_history\n\n        Example:\n            After running an iteration, access linearization matrices::\n\n                problem.step()\n                C_d = problem.state.C_d  # Shape (N-1, n_x, n_u)\n        \"\"\"\n        if not self.V_history:\n            return None\n\n        # Extract indices for unpacking V vector\n        i2 = self.n_x + self.n_x * self.n_x\n        i3 = i2 + self.n_x * self.n_u\n        i4 = i3 + self.n_x * self.n_u\n\n        # V_history contains Vmulti from discretization\n        V = self.V_history[-1]\n\n        # Take final timestep and reshape to (N-1, i4)\n        V_final = V[:, -1].reshape(-1, i4)\n\n        # Extract and reshape C_d matrix\n        return V_final[:, i3:i4].reshape(self.N - 1, self.n_x, self.n_u)\n\n    @classmethod\n    def from_settings(cls, settings: \"Config\") -&gt; \"SolverState\":\n        \"\"\"Create initial solver state from configuration.\n\n        Copies only the trajectory arrays from settings, leaving all metadata\n        (bounds, boundary conditions, etc.) in the original settings object.\n\n        Args:\n            settings: Configuration object containing initial guesses and SCP parameters\n\n        Returns:\n            Fresh SolverState initialized from settings with copied arrays\n        \"\"\"\n        return cls(\n            k=1,\n            J_tr=1e2,\n            J_vb=1e2,\n            J_vc=1e2,\n            w_tr=settings.scp.w_tr,\n            lam_cost=settings.scp.lam_cost,\n            lam_vc=settings.scp.lam_vc,\n            lam_vb=settings.scp.lam_vb,\n            n_x=settings.sim.n_states,\n            n_u=settings.sim.n_controls,\n            N=settings.scp.n,\n            X=[settings.sim.x.guess.copy()],\n            U=[settings.sim.u.guess.copy()],\n            V_history=[],\n        )\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.SolverState.A_d","title":"<code>A_d: np.ndarray</code>  <code>property</code>","text":"<p>Extract discretized state transition matrix from latest V.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Discretized state Jacobian A_d with shape (N-1, n_x, n_x), or None if no V_history</p> Example <p>After running an iteration, access linearization matrices::</p> <pre><code>problem.step()\nA_d = problem.state.A_d  # Shape (N-1, n_x, n_x)\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.SolverState.B_d","title":"<code>B_d: np.ndarray</code>  <code>property</code>","text":"<p>Extract discretized control influence matrix (current node) from latest V.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Discretized control Jacobian B_d with shape (N-1, n_x, n_u), or None if no V_history</p> Example <p>After running an iteration, access linearization matrices::</p> <pre><code>problem.step()\nB_d = problem.state.B_d  # Shape (N-1, n_x, n_u)\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.SolverState.C_d","title":"<code>C_d: np.ndarray</code>  <code>property</code>","text":"<p>Extract discretized control influence matrix (next node) from latest V.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Discretized control Jacobian C_d with shape (N-1, n_x, n_u), or None if no V_history</p> Example <p>After running an iteration, access linearization matrices::</p> <pre><code>problem.step()\nC_d = problem.state.C_d  # Shape (N-1, n_x, n_u)\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.SolverState.u","title":"<code>u: np.ndarray</code>  <code>property</code>","text":"<p>Get current control trajectory array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Current control trajectory guess (latest entry in history), shape (N, n_controls)</p>"},{"location":"reference/algorithms/#openscvx.algorithms.SolverState.x","title":"<code>x: np.ndarray</code>  <code>property</code>","text":"<p>Get current state trajectory array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Current state trajectory guess (latest entry in history), shape (N, n_states)</p>"},{"location":"reference/algorithms/#openscvx.algorithms.SolverState.x_prop","title":"<code>x_prop: np.ndarray</code>  <code>property</code>","text":"<p>Extract propagated state trajectory from latest V.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Propagated state trajectory x_prop with shape (N-1, n_x), or None if no V_history</p> Example <p>After running an iteration, access the propagated states::</p> <pre><code>problem.step()\nx_prop = problem.state.x_prop  # Shape (N-1, n_x)\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.SolverState.from_settings","title":"<code>from_settings(settings: Config) -&gt; SolverState</code>  <code>classmethod</code>","text":"<p>Create initial solver state from configuration.</p> <p>Copies only the trajectory arrays from settings, leaving all metadata (bounds, boundary conditions, etc.) in the original settings object.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Config</code> <p>Configuration object containing initial guesses and SCP parameters</p> required <p>Returns:</p> Type Description <code>SolverState</code> <p>Fresh SolverState initialized from settings with copied arrays</p> Source code in <code>openscvx/algorithms/solver_state.py</code> <pre><code>@classmethod\ndef from_settings(cls, settings: \"Config\") -&gt; \"SolverState\":\n    \"\"\"Create initial solver state from configuration.\n\n    Copies only the trajectory arrays from settings, leaving all metadata\n    (bounds, boundary conditions, etc.) in the original settings object.\n\n    Args:\n        settings: Configuration object containing initial guesses and SCP parameters\n\n    Returns:\n        Fresh SolverState initialized from settings with copied arrays\n    \"\"\"\n    return cls(\n        k=1,\n        J_tr=1e2,\n        J_vb=1e2,\n        J_vc=1e2,\n        w_tr=settings.scp.w_tr,\n        lam_cost=settings.scp.lam_cost,\n        lam_vc=settings.scp.lam_vc,\n        lam_vb=settings.scp.lam_vb,\n        n_x=settings.sim.n_states,\n        n_u=settings.sim.n_controls,\n        N=settings.scp.n,\n        X=[settings.sim.x.guess.copy()],\n        U=[settings.sim.u.guess.copy()],\n        V_history=[],\n    )\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.PTR_step","title":"<code>PTR_step(params, settings: Config, state: SolverState, prob: cp.Problem, discretization_solver: callable, cpg_solve, emitter_function, jax_constraints: LoweredJaxConstraints) -&gt; bool</code>","text":"<p>Performs a single SCP iteration.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <p>Problem parameters</p> required <code>settings</code> <code>Config</code> <p>Configuration object</p> required <code>state</code> <code>SolverState</code> <p>Solver state (mutated in place)</p> required <code>prob</code> <code>Problem</code> <p>CVXPy problem</p> required <code>discretization_solver</code> <code>callable</code> <p>Discretization solver function</p> required <code>cpg_solve</code> <p>CVXPyGen solver (if enabled)</p> required <code>emitter_function</code> <p>Function to emit iteration data</p> required <code>jax_constraints</code> <code>LoweredJaxConstraints</code> <p>JAX-lowered non-convex constraints</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if converged, False otherwise</p> Source code in <code>openscvx/algorithms/ptr.py</code> <pre><code>def PTR_step(\n    params,\n    settings: Config,\n    state: SolverState,\n    prob: cp.Problem,\n    discretization_solver: callable,\n    cpg_solve,\n    emitter_function,\n    jax_constraints: \"LoweredJaxConstraints\",\n) -&gt; bool:\n    \"\"\"Performs a single SCP iteration.\n\n    Args:\n        params: Problem parameters\n        settings: Configuration object\n        state: Solver state (mutated in place)\n        prob: CVXPy problem\n        discretization_solver: Discretization solver function\n        cpg_solve: CVXPyGen solver (if enabled)\n        emitter_function: Function to emit iteration data\n        jax_constraints: JAX-lowered non-convex constraints\n\n    Returns:\n        bool: True if converged, False otherwise\n    \"\"\"\n    # Run the subproblem\n    (\n        x_sol,\n        u_sol,\n        cost,\n        J_total,\n        J_vb_vec,\n        J_vc_vec,\n        J_tr_vec,\n        prob_stat,\n        V_multi_shoot,\n        subprop_time,\n        dis_time,\n    ) = PTR_subproblem(\n        params.items(),\n        cpg_solve,\n        state,\n        discretization_solver,\n        prob,\n        settings,\n        jax_constraints,\n    )\n\n    # Update state in place by appending to history\n    # The x_guess/u_guess properties will automatically return the latest entry\n    state.V_history.append(V_multi_shoot)\n    state.X.append(x_sol)\n    state.U.append(u_sol)\n\n    state.J_tr = np.sum(np.array(J_tr_vec))\n    state.J_vb = np.sum(np.array(J_vb_vec))\n    state.J_vc = np.sum(np.array(J_vc_vec))\n\n    # Update weights in state\n    update_scp_weights(state, settings, state.k)\n\n    # Emit data\n    emitter_function(\n        {\n            \"iter\": state.k,\n            \"dis_time\": dis_time * 1000.0,\n            \"subprop_time\": subprop_time * 1000.0,\n            \"J_total\": J_total,\n            \"J_tr\": state.J_tr,\n            \"J_vb\": state.J_vb,\n            \"J_vc\": state.J_vc,\n            \"cost\": cost[-1],\n            \"prob_stat\": prob_stat,\n        }\n    )\n\n    # Increment iteration counter\n    state.k += 1\n\n    # Return convergence status\n    return (\n        (state.J_tr &lt; settings.scp.ep_tr)\n        and (state.J_vb &lt; settings.scp.ep_vb)\n        and (state.J_vc &lt; settings.scp.ep_vc)\n    )\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.format_result","title":"<code>format_result(problem, state: SolverState, converged: bool) -&gt; OptimizationResults</code>","text":"<p>Formats the solver state as an OptimizationResults object.</p> <p>Directly passes trajectory arrays from solver state to results - no object construction needed. Results store pure arrays, settings store metadata.</p> <p>Parameters:</p> Name Type Description Default <code>problem</code> <p>The Problem instance (for symbolic metadata and settings).</p> required <code>state</code> <code>SolverState</code> <p>The SolverState to extract results from.</p> required <code>converged</code> <code>bool</code> <p>Whether the optimization converged.</p> required <p>Returns:</p> Type Description <code>OptimizationResults</code> <p>OptimizationResults containing the solution data.</p> Source code in <code>openscvx/algorithms/ptr.py</code> <pre><code>def format_result(problem, state: \"SolverState\", converged: bool) -&gt; OptimizationResults:\n    \"\"\"Formats the solver state as an OptimizationResults object.\n\n    Directly passes trajectory arrays from solver state to results - no object\n    construction needed. Results store pure arrays, settings store metadata.\n\n    Args:\n        problem: The Problem instance (for symbolic metadata and settings).\n        state: The SolverState to extract results from.\n        converged: Whether the optimization converged.\n\n    Returns:\n        OptimizationResults containing the solution data.\n    \"\"\"\n    # Build nodes dictionary with all states and controls\n    nodes_dict = {}\n\n    # Add all states (user-defined and augmented)\n    for sym_state in problem.symbolic.states:\n        nodes_dict[sym_state.name] = state.x[:, sym_state._slice]\n\n    # Add all controls (user-defined and augmented)\n    for control in problem.symbolic.controls:\n        nodes_dict[control.name] = state.u[:, control._slice]\n\n    return OptimizationResults(\n        converged=converged,\n        t_final=state.x[:, problem.settings.sim.time_slice][-1],\n        nodes=nodes_dict,\n        trajectory={},  # Populated by post_process\n        _states=problem.symbolic.states_prop,  # Use propagation states for trajectory dict\n        _controls=problem.symbolic.controls,\n        X=state.X,  # Single source of truth - x and u are properties\n        U=state.U,\n        discretization_history=state.V_history,\n        J_tr_history=state.J_tr,\n        J_vb_history=state.J_vb,\n        J_vc_history=state.J_vc,\n    )\n</code></pre>"},{"location":"reference/algorithms/autotuning/","title":"autotuning","text":"<p>Autotuning functions for SCP (Successive Convex Programming) parameters.</p>"},{"location":"reference/algorithms/autotuning/#openscvx.algorithms.autotuning.update_scp_weights","title":"<code>update_scp_weights(state: SolverState, settings: Config, scp_k: int)</code>","text":"<p>Update SCP weights and cost parameters based on iteration number.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>SolverState</code> <p>Solver state containing current weight values (mutated in place)</p> required <code>settings</code> <code>Config</code> <p>Configuration object containing adaptation parameters</p> required <code>scp_k</code> <code>int</code> <p>Current SCP iteration number</p> required Source code in <code>openscvx/algorithms/autotuning.py</code> <pre><code>def update_scp_weights(state: \"SolverState\", settings: Config, scp_k: int):\n    \"\"\"Update SCP weights and cost parameters based on iteration number.\n\n    Args:\n        state: Solver state containing current weight values (mutated in place)\n        settings: Configuration object containing adaptation parameters\n        scp_k: Current SCP iteration number\n    \"\"\"\n    # Update trust region weight in state\n    state.w_tr = min(state.w_tr * settings.scp.w_tr_adapt, settings.scp.w_tr_max)\n\n    # Update cost relaxation parameter after cost_drop iterations\n    if scp_k &gt; settings.scp.cost_drop:\n        state.lam_cost = state.lam_cost * settings.scp.cost_relax\n</code></pre>"},{"location":"reference/algorithms/optimization_results/","title":"optimization_results","text":""},{"location":"reference/algorithms/optimization_results/#openscvx.algorithms.optimization_results.OptimizationResults","title":"<code>OptimizationResults</code>  <code>dataclass</code>","text":"<p>Structured container for optimization results from the Successive Convexification (SCP) solver.</p> <p>This class provides a type-safe and organized way to store and access optimization results, replacing the previous dictionary-based approach. It includes core optimization data, iteration history for convergence analysis, post-processing results, and flexible storage for plotting and application-specific data.</p> <p>Attributes:</p> Name Type Description <code>converged</code> <code>bool</code> <p>Whether the optimization successfully converged</p> <code>t_final</code> <code>float</code> <p>Final time of the optimized trajectory</p> <code>x_guess</code> <code>ndarray</code> <p>Optimized state trajectory at discretization nodes, shape (N, n_states)</p> <code>u_guess</code> <code>ndarray</code> <p>Optimized control trajectory at discretization nodes, shape (N, n_controls)</p> <code>nodes</code> <code>dict[str, ndarray]</code> <p>Dictionary mapping state/control names to arrays at optimization nodes. Includes both user-defined and augmented variables.</p> <code>trajectory</code> <code>dict[str, ndarray]</code> <p>Dictionary mapping state/control names to arrays along the propagated trajectory. Added by post_process().</p> <code>x_history</code> <code>list[ndarray]</code> <p>State trajectories from each SCP iteration</p> <code>u_history</code> <code>list[ndarray]</code> <p>Control trajectories from each SCP iteration</p> <code>discretization_history</code> <code>list[ndarray]</code> <p>Time discretization from each iteration</p> <code>J_tr_history</code> <code>list[ndarray]</code> <p>Trust region cost history</p> <code>J_vb_history</code> <code>list[ndarray]</code> <p>Virtual buffer cost history</p> <code>J_vc_history</code> <code>list[ndarray]</code> <p>Virtual control cost history</p> <code>t_full</code> <code>Optional[ndarray]</code> <p>Full time grid for interpolated trajectory</p> <code>x_full</code> <code>Optional[ndarray]</code> <p>Interpolated state trajectory on full time grid</p> <code>u_full</code> <code>Optional[ndarray]</code> <p>Interpolated control trajectory on full time grid</p> <code>cost</code> <code>Optional[float]</code> <p>Total cost of the optimized trajectory</p> <code>ctcs_violation</code> <code>Optional[ndarray]</code> <p>Continuous-time constraint violations</p> <code>plotting_data</code> <code>dict[str, Any]</code> <p>Flexible storage for plotting and application data</p> Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>@dataclass\nclass OptimizationResults:\n    \"\"\"\n    Structured container for optimization results from the Successive Convexification (SCP) solver.\n\n    This class provides a type-safe and organized way to store and access optimization results,\n    replacing the previous dictionary-based approach. It includes core optimization data,\n    iteration history for convergence analysis, post-processing results, and flexible\n    storage for plotting and application-specific data.\n\n    Attributes:\n        converged (bool): Whether the optimization successfully converged\n        t_final (float): Final time of the optimized trajectory\n        x_guess (np.ndarray): Optimized state trajectory at discretization nodes,\n            shape (N, n_states)\n        u_guess (np.ndarray): Optimized control trajectory at discretization nodes,\n            shape (N, n_controls)\n\n        # Dictionary-based Access\n        nodes (dict[str, np.ndarray]): Dictionary mapping state/control names to arrays\n            at optimization nodes. Includes both user-defined and augmented variables.\n        trajectory (dict[str, np.ndarray]): Dictionary mapping state/control names to arrays\n            along the propagated trajectory. Added by post_process().\n\n        # SCP Iteration History (for convergence analysis)\n        x_history (list[np.ndarray]): State trajectories from each SCP iteration\n        u_history (list[np.ndarray]): Control trajectories from each SCP iteration\n        discretization_history (list[np.ndarray]): Time discretization from each iteration\n        J_tr_history (list[np.ndarray]): Trust region cost history\n        J_vb_history (list[np.ndarray]): Virtual buffer cost history\n        J_vc_history (list[np.ndarray]): Virtual control cost history\n\n        # Post-processing Results (added by propagate_trajectory_results)\n        t_full (Optional[np.ndarray]): Full time grid for interpolated trajectory\n        x_full (Optional[np.ndarray]): Interpolated state trajectory on full time grid\n        u_full (Optional[np.ndarray]): Interpolated control trajectory on full time grid\n        cost (Optional[float]): Total cost of the optimized trajectory\n        ctcs_violation (Optional[np.ndarray]): Continuous-time constraint violations\n\n        # User-defined Data\n        plotting_data (dict[str, Any]): Flexible storage for plotting and application data\n    \"\"\"\n\n    # Core optimization results\n    converged: bool\n    t_final: float\n\n    # Dictionary-based access to states and controls\n    nodes: dict[str, np.ndarray] = field(default_factory=dict)\n    trajectory: dict[str, np.ndarray] = field(default_factory=dict)\n\n    # Internal metadata for dictionary construction\n    _states: list = field(default_factory=list, repr=False)\n    _controls: list = field(default_factory=list, repr=False)\n\n    # History of SCP iterations (single source of truth)\n    X: list[np.ndarray] = field(default_factory=list)\n    U: list[np.ndarray] = field(default_factory=list)\n    discretization_history: list[np.ndarray] = field(default_factory=list)\n    J_tr_history: list[np.ndarray] = field(default_factory=list)\n    J_vb_history: list[np.ndarray] = field(default_factory=list)\n    J_vc_history: list[np.ndarray] = field(default_factory=list)\n\n    @property\n    def x(self) -&gt; np.ndarray:\n        \"\"\"Optimal state trajectory at discretization nodes.\n\n        Returns the final converged solution from the SCP iteration history.\n\n        Returns:\n            State trajectory array, shape (N, n_states)\n        \"\"\"\n        return self.X[-1]\n\n    @property\n    def u(self) -&gt; np.ndarray:\n        \"\"\"Optimal control trajectory at discretization nodes.\n\n        Returns the final converged solution from the SCP iteration history.\n\n        Returns:\n            Control trajectory array, shape (N, n_controls)\n        \"\"\"\n        return self.U[-1]\n\n    # Post-processing results (added by propagate_trajectory_results)\n    t_full: Optional[np.ndarray] = None\n    x_full: Optional[np.ndarray] = None\n    u_full: Optional[np.ndarray] = None\n    cost: Optional[float] = None\n    ctcs_violation: Optional[np.ndarray] = None\n\n    # Additional plotting/application data (added by user)\n    plotting_data: dict[str, Any] = field(default_factory=dict)\n\n    def __post_init__(self):\n        \"\"\"Initialize the results object.\"\"\"\n        pass\n\n    def update_plotting_data(self, **kwargs):\n        \"\"\"\n        Update the plotting data with additional information.\n\n        Args:\n            **kwargs: Key-value pairs to add to plotting_data\n        \"\"\"\n        self.plotting_data.update(kwargs)\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"\n        Get a value from the results, similar to dict.get().\n\n        Args:\n            key: The key to look up\n            default: Default value if key is not found\n\n        Returns:\n            The value associated with the key, or default if not found\n        \"\"\"\n        # Check if it's a direct attribute\n        if hasattr(self, key):\n            return getattr(self, key)\n\n        # Check if it's in plotting_data\n        if key in self.plotting_data:\n            return self.plotting_data[key]\n\n        return default\n\n    def __getitem__(self, key: str) -&gt; Any:\n        \"\"\"\n        Allow dictionary-style access to results.\n\n        Args:\n            key: The key to look up\n\n        Returns:\n            The value associated with the key\n\n        Raises:\n            KeyError: If key is not found\n        \"\"\"\n        # Check if it's a direct attribute\n        if hasattr(self, key):\n            return getattr(self, key)\n\n        # Check if it's in plotting_data\n        if key in self.plotting_data:\n            return self.plotting_data[key]\n\n        raise KeyError(f\"Key '{key}' not found in results\")\n\n    def __setitem__(self, key: str, value: Any):\n        \"\"\"\n        Allow dictionary-style assignment to results.\n\n        Args:\n            key: The key to set\n            value: The value to assign\n        \"\"\"\n        # Check if it's a direct attribute\n        if hasattr(self, key):\n            setattr(self, key, value)\n        else:\n            # Store in plotting_data\n            self.plotting_data[key] = value\n\n    def __contains__(self, key: str) -&gt; bool:\n        \"\"\"\n        Check if a key exists in the results.\n\n        Args:\n            key: The key to check\n\n        Returns:\n            True if key exists, False otherwise\n        \"\"\"\n        return hasattr(self, key) or key in self.plotting_data\n\n    def update(self, other: dict[str, Any]):\n        \"\"\"\n        Update the results with additional data from a dictionary.\n\n        Args:\n            other: Dictionary containing additional data\n        \"\"\"\n        for key, value in other.items():\n            self[key] = value\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Convert the results to a dictionary for backward compatibility.\n\n        Returns:\n            Dictionary representation of the results\n        \"\"\"\n        result_dict = {}\n\n        # Add all direct attributes\n        for attr_name in self.__dataclass_fields__:\n            if attr_name != \"plotting_data\":\n                result_dict[attr_name] = getattr(self, attr_name)\n\n        # Add plotting data\n        result_dict.update(self.plotting_data)\n\n        return result_dict\n</code></pre>"},{"location":"reference/algorithms/optimization_results/#openscvx.algorithms.optimization_results.OptimizationResults.u","title":"<code>u: np.ndarray</code>  <code>property</code>","text":"<p>Optimal control trajectory at discretization nodes.</p> <p>Returns the final converged solution from the SCP iteration history.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Control trajectory array, shape (N, n_controls)</p>"},{"location":"reference/algorithms/optimization_results/#openscvx.algorithms.optimization_results.OptimizationResults.x","title":"<code>x: np.ndarray</code>  <code>property</code>","text":"<p>Optimal state trajectory at discretization nodes.</p> <p>Returns the final converged solution from the SCP iteration history.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>State trajectory array, shape (N, n_states)</p>"},{"location":"reference/algorithms/optimization_results/#openscvx.algorithms.optimization_results.OptimizationResults.get","title":"<code>get(key: str, default: Any = None) -&gt; Any</code>","text":"<p>Get a value from the results, similar to dict.get().</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to look up</p> required <code>default</code> <code>Any</code> <p>Default value if key is not found</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The value associated with the key, or default if not found</p> Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"\n    Get a value from the results, similar to dict.get().\n\n    Args:\n        key: The key to look up\n        default: Default value if key is not found\n\n    Returns:\n        The value associated with the key, or default if not found\n    \"\"\"\n    # Check if it's a direct attribute\n    if hasattr(self, key):\n        return getattr(self, key)\n\n    # Check if it's in plotting_data\n    if key in self.plotting_data:\n        return self.plotting_data[key]\n\n    return default\n</code></pre>"},{"location":"reference/algorithms/optimization_results/#openscvx.algorithms.optimization_results.OptimizationResults.to_dict","title":"<code>to_dict() -&gt; dict[str, Any]</code>","text":"<p>Convert the results to a dictionary for backward compatibility.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary representation of the results</p> Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the results to a dictionary for backward compatibility.\n\n    Returns:\n        Dictionary representation of the results\n    \"\"\"\n    result_dict = {}\n\n    # Add all direct attributes\n    for attr_name in self.__dataclass_fields__:\n        if attr_name != \"plotting_data\":\n            result_dict[attr_name] = getattr(self, attr_name)\n\n    # Add plotting data\n    result_dict.update(self.plotting_data)\n\n    return result_dict\n</code></pre>"},{"location":"reference/algorithms/optimization_results/#openscvx.algorithms.optimization_results.OptimizationResults.update","title":"<code>update(other: dict[str, Any])</code>","text":"<p>Update the results with additional data from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>dict[str, Any]</code> <p>Dictionary containing additional data</p> required Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>def update(self, other: dict[str, Any]):\n    \"\"\"\n    Update the results with additional data from a dictionary.\n\n    Args:\n        other: Dictionary containing additional data\n    \"\"\"\n    for key, value in other.items():\n        self[key] = value\n</code></pre>"},{"location":"reference/algorithms/optimization_results/#openscvx.algorithms.optimization_results.OptimizationResults.update_plotting_data","title":"<code>update_plotting_data(**kwargs)</code>","text":"<p>Update the plotting data with additional information.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Key-value pairs to add to plotting_data</p> <code>{}</code> Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>def update_plotting_data(self, **kwargs):\n    \"\"\"\n    Update the plotting data with additional information.\n\n    Args:\n        **kwargs: Key-value pairs to add to plotting_data\n    \"\"\"\n    self.plotting_data.update(kwargs)\n</code></pre>"},{"location":"reference/algorithms/ptr/","title":"ptr","text":""},{"location":"reference/algorithms/ptr/#openscvx.algorithms.ptr.PTR_step","title":"<code>PTR_step(params, settings: Config, state: SolverState, prob: cp.Problem, discretization_solver: callable, cpg_solve, emitter_function, jax_constraints: LoweredJaxConstraints) -&gt; bool</code>","text":"<p>Performs a single SCP iteration.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <p>Problem parameters</p> required <code>settings</code> <code>Config</code> <p>Configuration object</p> required <code>state</code> <code>SolverState</code> <p>Solver state (mutated in place)</p> required <code>prob</code> <code>Problem</code> <p>CVXPy problem</p> required <code>discretization_solver</code> <code>callable</code> <p>Discretization solver function</p> required <code>cpg_solve</code> <p>CVXPyGen solver (if enabled)</p> required <code>emitter_function</code> <p>Function to emit iteration data</p> required <code>jax_constraints</code> <code>LoweredJaxConstraints</code> <p>JAX-lowered non-convex constraints</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if converged, False otherwise</p> Source code in <code>openscvx/algorithms/ptr.py</code> <pre><code>def PTR_step(\n    params,\n    settings: Config,\n    state: SolverState,\n    prob: cp.Problem,\n    discretization_solver: callable,\n    cpg_solve,\n    emitter_function,\n    jax_constraints: \"LoweredJaxConstraints\",\n) -&gt; bool:\n    \"\"\"Performs a single SCP iteration.\n\n    Args:\n        params: Problem parameters\n        settings: Configuration object\n        state: Solver state (mutated in place)\n        prob: CVXPy problem\n        discretization_solver: Discretization solver function\n        cpg_solve: CVXPyGen solver (if enabled)\n        emitter_function: Function to emit iteration data\n        jax_constraints: JAX-lowered non-convex constraints\n\n    Returns:\n        bool: True if converged, False otherwise\n    \"\"\"\n    # Run the subproblem\n    (\n        x_sol,\n        u_sol,\n        cost,\n        J_total,\n        J_vb_vec,\n        J_vc_vec,\n        J_tr_vec,\n        prob_stat,\n        V_multi_shoot,\n        subprop_time,\n        dis_time,\n    ) = PTR_subproblem(\n        params.items(),\n        cpg_solve,\n        state,\n        discretization_solver,\n        prob,\n        settings,\n        jax_constraints,\n    )\n\n    # Update state in place by appending to history\n    # The x_guess/u_guess properties will automatically return the latest entry\n    state.V_history.append(V_multi_shoot)\n    state.X.append(x_sol)\n    state.U.append(u_sol)\n\n    state.J_tr = np.sum(np.array(J_tr_vec))\n    state.J_vb = np.sum(np.array(J_vb_vec))\n    state.J_vc = np.sum(np.array(J_vc_vec))\n\n    # Update weights in state\n    update_scp_weights(state, settings, state.k)\n\n    # Emit data\n    emitter_function(\n        {\n            \"iter\": state.k,\n            \"dis_time\": dis_time * 1000.0,\n            \"subprop_time\": subprop_time * 1000.0,\n            \"J_total\": J_total,\n            \"J_tr\": state.J_tr,\n            \"J_vb\": state.J_vb,\n            \"J_vc\": state.J_vc,\n            \"cost\": cost[-1],\n            \"prob_stat\": prob_stat,\n        }\n    )\n\n    # Increment iteration counter\n    state.k += 1\n\n    # Return convergence status\n    return (\n        (state.J_tr &lt; settings.scp.ep_tr)\n        and (state.J_vb &lt; settings.scp.ep_vb)\n        and (state.J_vc &lt; settings.scp.ep_vc)\n    )\n</code></pre>"},{"location":"reference/algorithms/ptr/#openscvx.algorithms.ptr.format_result","title":"<code>format_result(problem, state: SolverState, converged: bool) -&gt; OptimizationResults</code>","text":"<p>Formats the solver state as an OptimizationResults object.</p> <p>Directly passes trajectory arrays from solver state to results - no object construction needed. Results store pure arrays, settings store metadata.</p> <p>Parameters:</p> Name Type Description Default <code>problem</code> <p>The Problem instance (for symbolic metadata and settings).</p> required <code>state</code> <code>SolverState</code> <p>The SolverState to extract results from.</p> required <code>converged</code> <code>bool</code> <p>Whether the optimization converged.</p> required <p>Returns:</p> Type Description <code>OptimizationResults</code> <p>OptimizationResults containing the solution data.</p> Source code in <code>openscvx/algorithms/ptr.py</code> <pre><code>def format_result(problem, state: \"SolverState\", converged: bool) -&gt; OptimizationResults:\n    \"\"\"Formats the solver state as an OptimizationResults object.\n\n    Directly passes trajectory arrays from solver state to results - no object\n    construction needed. Results store pure arrays, settings store metadata.\n\n    Args:\n        problem: The Problem instance (for symbolic metadata and settings).\n        state: The SolverState to extract results from.\n        converged: Whether the optimization converged.\n\n    Returns:\n        OptimizationResults containing the solution data.\n    \"\"\"\n    # Build nodes dictionary with all states and controls\n    nodes_dict = {}\n\n    # Add all states (user-defined and augmented)\n    for sym_state in problem.symbolic.states:\n        nodes_dict[sym_state.name] = state.x[:, sym_state._slice]\n\n    # Add all controls (user-defined and augmented)\n    for control in problem.symbolic.controls:\n        nodes_dict[control.name] = state.u[:, control._slice]\n\n    return OptimizationResults(\n        converged=converged,\n        t_final=state.x[:, problem.settings.sim.time_slice][-1],\n        nodes=nodes_dict,\n        trajectory={},  # Populated by post_process\n        _states=problem.symbolic.states_prop,  # Use propagation states for trajectory dict\n        _controls=problem.symbolic.controls,\n        X=state.X,  # Single source of truth - x and u are properties\n        U=state.U,\n        discretization_history=state.V_history,\n        J_tr_history=state.J_tr,\n        J_vb_history=state.J_vb,\n        J_vc_history=state.J_vc,\n    )\n</code></pre>"},{"location":"reference/algorithms/solver_state/","title":"solver_state","text":"<p>Solver state management for SCP iterations.</p> <p>This module contains the SolverState dataclass that holds all mutable state during successive convex programming iterations. By separating solver state from problem definition, we enable clean reset() functionality and prevent accidental mutation of initial conditions.</p>"},{"location":"reference/algorithms/solver_state/#openscvx.algorithms.solver_state.SolverState","title":"<code>SolverState</code>  <code>dataclass</code>","text":"<p>Mutable state for SCP iterations.</p> <p>This dataclass holds all state that changes during the solve process. It stores only the evolving trajectory arrays, not the full State/Control objects which contain immutable configuration metadata.</p> <p>Trajectory arrays are stored in history lists, with the current guess accessed via properties that return the latest entry.</p> <p>A fresh instance is created for each solve, enabling easy reset functionality.</p> <p>Attributes:</p> Name Type Description <code>k</code> <code>int</code> <p>Current iteration number (starts at 1)</p> <code>J_tr</code> <code>float</code> <p>Current trust region cost</p> <code>J_vb</code> <code>float</code> <p>Current virtual buffer cost</p> <code>J_vc</code> <code>float</code> <p>Current virtual control cost</p> <code>w_tr</code> <code>float</code> <p>Current trust region weight (may adapt during solve)</p> <code>lam_cost</code> <code>float</code> <p>Current cost weight (may relax during solve)</p> <code>lam_vc</code> <code>Union[float, ndarray]</code> <p>Current virtual control penalty weight</p> <code>lam_vb</code> <code>float</code> <p>Current virtual buffer penalty weight</p> <code>n_x</code> <code>int</code> <p>Number of states (for unpacking V vectors)</p> <code>n_u</code> <code>int</code> <p>Number of controls (for unpacking V vectors)</p> <code>N</code> <code>int</code> <p>Number of trajectory nodes (for unpacking V vectors)</p> <code>X</code> <code>List[ndarray]</code> <p>List of state trajectory iterates</p> <code>U</code> <code>List[ndarray]</code> <p>List of control trajectory iterates</p> <code>V_history</code> <code>List[ndarray]</code> <p>List of discretization history</p> Source code in <code>openscvx/algorithms/solver_state.py</code> <pre><code>@dataclass\nclass SolverState:\n    \"\"\"Mutable state for SCP iterations.\n\n    This dataclass holds all state that changes during the solve process.\n    It stores only the evolving trajectory arrays, not the full State/Control\n    objects which contain immutable configuration metadata.\n\n    Trajectory arrays are stored in history lists, with the current guess\n    accessed via properties that return the latest entry.\n\n    A fresh instance is created for each solve, enabling easy reset functionality.\n\n    Attributes:\n        k: Current iteration number (starts at 1)\n        J_tr: Current trust region cost\n        J_vb: Current virtual buffer cost\n        J_vc: Current virtual control cost\n        w_tr: Current trust region weight (may adapt during solve)\n        lam_cost: Current cost weight (may relax during solve)\n        lam_vc: Current virtual control penalty weight\n        lam_vb: Current virtual buffer penalty weight\n        n_x: Number of states (for unpacking V vectors)\n        n_u: Number of controls (for unpacking V vectors)\n        N: Number of trajectory nodes (for unpacking V vectors)\n        X: List of state trajectory iterates\n        U: List of control trajectory iterates\n        V_history: List of discretization history\n    \"\"\"\n\n    k: int\n    J_tr: float\n    J_vb: float\n    J_vc: float\n    w_tr: float\n    lam_cost: float\n    lam_vc: Union[float, np.ndarray]\n    lam_vb: float\n    n_x: int\n    n_u: int\n    N: int\n    X: List[np.ndarray] = field(default_factory=list)\n    U: List[np.ndarray] = field(default_factory=list)\n    V_history: List[np.ndarray] = field(default_factory=list)\n\n    @property\n    def x(self) -&gt; np.ndarray:\n        \"\"\"Get current state trajectory array.\n\n        Returns:\n            Current state trajectory guess (latest entry in history), shape (N, n_states)\n        \"\"\"\n        return self.X[-1]\n\n    @property\n    def u(self) -&gt; np.ndarray:\n        \"\"\"Get current control trajectory array.\n\n        Returns:\n            Current control trajectory guess (latest entry in history), shape (N, n_controls)\n        \"\"\"\n        return self.U[-1]\n\n    @property\n    def x_prop(self) -&gt; np.ndarray:\n        \"\"\"Extract propagated state trajectory from latest V.\n\n        Returns:\n            Propagated state trajectory x_prop with shape (N-1, n_x), or None if no V_history\n\n        Example:\n            After running an iteration, access the propagated states::\n\n                problem.step()\n                x_prop = problem.state.x_prop  # Shape (N-1, n_x)\n        \"\"\"\n        if not self.V_history:\n            return None\n\n        # V_history contains Vmulti from discretization\n        # Shape: (flattened_size, n_timesteps) where flattened_size = (N-1) * i4\n        V = self.V_history[-1]\n\n        # Take final timestep and reshape to (N-1, i4)\n        i4 = self.n_x + self.n_x * self.n_x + 2 * self.n_x * self.n_u\n        V_final = V[:, -1].reshape(-1, i4)\n\n        # Extract propagated state (first n_x elements of each row)\n        return V_final[:, : self.n_x]\n\n    @property\n    def A_d(self) -&gt; np.ndarray:\n        \"\"\"Extract discretized state transition matrix from latest V.\n\n        Returns:\n            Discretized state Jacobian A_d with shape (N-1, n_x, n_x), or None if no V_history\n\n        Example:\n            After running an iteration, access linearization matrices::\n\n                problem.step()\n                A_d = problem.state.A_d  # Shape (N-1, n_x, n_x)\n        \"\"\"\n        if not self.V_history:\n            return None\n\n        # Extract indices for unpacking V vector\n        i1 = self.n_x\n        i2 = i1 + self.n_x * self.n_x\n\n        # V_history contains Vmulti from discretization\n        # Shape: (flattened_size, n_timesteps) where flattened_size = (N-1) * i4\n        V = self.V_history[-1]\n\n        # Take final timestep and reshape to (N-1, i4)\n        i4 = self.n_x + self.n_x * self.n_x + 2 * self.n_x * self.n_u\n        V_final = V[:, -1].reshape(-1, i4)\n\n        # Extract and reshape A_d matrix\n        return V_final[:, i1:i2].reshape(self.N - 1, self.n_x, self.n_x)\n\n    @property\n    def B_d(self) -&gt; np.ndarray:\n        \"\"\"Extract discretized control influence matrix (current node) from latest V.\n\n        Returns:\n            Discretized control Jacobian B_d with shape (N-1, n_x, n_u), or None if no V_history\n\n        Example:\n            After running an iteration, access linearization matrices::\n\n                problem.step()\n                B_d = problem.state.B_d  # Shape (N-1, n_x, n_u)\n        \"\"\"\n        if not self.V_history:\n            return None\n\n        # Extract indices for unpacking V vector\n        i1 = self.n_x\n        i2 = i1 + self.n_x * self.n_x\n        i3 = i2 + self.n_x * self.n_u\n\n        # V_history contains Vmulti from discretization\n        V = self.V_history[-1]\n\n        # Take final timestep and reshape to (N-1, i4)\n        i4 = self.n_x + self.n_x * self.n_x + 2 * self.n_x * self.n_u\n        V_final = V[:, -1].reshape(-1, i4)\n\n        # Extract and reshape B_d matrix\n        return V_final[:, i2:i3].reshape(self.N - 1, self.n_x, self.n_u)\n\n    @property\n    def C_d(self) -&gt; np.ndarray:\n        \"\"\"Extract discretized control influence matrix (next node) from latest V.\n\n        Returns:\n            Discretized control Jacobian C_d with shape (N-1, n_x, n_u), or None if no V_history\n\n        Example:\n            After running an iteration, access linearization matrices::\n\n                problem.step()\n                C_d = problem.state.C_d  # Shape (N-1, n_x, n_u)\n        \"\"\"\n        if not self.V_history:\n            return None\n\n        # Extract indices for unpacking V vector\n        i2 = self.n_x + self.n_x * self.n_x\n        i3 = i2 + self.n_x * self.n_u\n        i4 = i3 + self.n_x * self.n_u\n\n        # V_history contains Vmulti from discretization\n        V = self.V_history[-1]\n\n        # Take final timestep and reshape to (N-1, i4)\n        V_final = V[:, -1].reshape(-1, i4)\n\n        # Extract and reshape C_d matrix\n        return V_final[:, i3:i4].reshape(self.N - 1, self.n_x, self.n_u)\n\n    @classmethod\n    def from_settings(cls, settings: \"Config\") -&gt; \"SolverState\":\n        \"\"\"Create initial solver state from configuration.\n\n        Copies only the trajectory arrays from settings, leaving all metadata\n        (bounds, boundary conditions, etc.) in the original settings object.\n\n        Args:\n            settings: Configuration object containing initial guesses and SCP parameters\n\n        Returns:\n            Fresh SolverState initialized from settings with copied arrays\n        \"\"\"\n        return cls(\n            k=1,\n            J_tr=1e2,\n            J_vb=1e2,\n            J_vc=1e2,\n            w_tr=settings.scp.w_tr,\n            lam_cost=settings.scp.lam_cost,\n            lam_vc=settings.scp.lam_vc,\n            lam_vb=settings.scp.lam_vb,\n            n_x=settings.sim.n_states,\n            n_u=settings.sim.n_controls,\n            N=settings.scp.n,\n            X=[settings.sim.x.guess.copy()],\n            U=[settings.sim.u.guess.copy()],\n            V_history=[],\n        )\n</code></pre>"},{"location":"reference/algorithms/solver_state/#openscvx.algorithms.solver_state.SolverState.A_d","title":"<code>A_d: np.ndarray</code>  <code>property</code>","text":"<p>Extract discretized state transition matrix from latest V.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Discretized state Jacobian A_d with shape (N-1, n_x, n_x), or None if no V_history</p> Example <p>After running an iteration, access linearization matrices::</p> <pre><code>problem.step()\nA_d = problem.state.A_d  # Shape (N-1, n_x, n_x)\n</code></pre>"},{"location":"reference/algorithms/solver_state/#openscvx.algorithms.solver_state.SolverState.B_d","title":"<code>B_d: np.ndarray</code>  <code>property</code>","text":"<p>Extract discretized control influence matrix (current node) from latest V.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Discretized control Jacobian B_d with shape (N-1, n_x, n_u), or None if no V_history</p> Example <p>After running an iteration, access linearization matrices::</p> <pre><code>problem.step()\nB_d = problem.state.B_d  # Shape (N-1, n_x, n_u)\n</code></pre>"},{"location":"reference/algorithms/solver_state/#openscvx.algorithms.solver_state.SolverState.C_d","title":"<code>C_d: np.ndarray</code>  <code>property</code>","text":"<p>Extract discretized control influence matrix (next node) from latest V.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Discretized control Jacobian C_d with shape (N-1, n_x, n_u), or None if no V_history</p> Example <p>After running an iteration, access linearization matrices::</p> <pre><code>problem.step()\nC_d = problem.state.C_d  # Shape (N-1, n_x, n_u)\n</code></pre>"},{"location":"reference/algorithms/solver_state/#openscvx.algorithms.solver_state.SolverState.u","title":"<code>u: np.ndarray</code>  <code>property</code>","text":"<p>Get current control trajectory array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Current control trajectory guess (latest entry in history), shape (N, n_controls)</p>"},{"location":"reference/algorithms/solver_state/#openscvx.algorithms.solver_state.SolverState.x","title":"<code>x: np.ndarray</code>  <code>property</code>","text":"<p>Get current state trajectory array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Current state trajectory guess (latest entry in history), shape (N, n_states)</p>"},{"location":"reference/algorithms/solver_state/#openscvx.algorithms.solver_state.SolverState.x_prop","title":"<code>x_prop: np.ndarray</code>  <code>property</code>","text":"<p>Extract propagated state trajectory from latest V.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Propagated state trajectory x_prop with shape (N-1, n_x), or None if no V_history</p> Example <p>After running an iteration, access the propagated states::</p> <pre><code>problem.step()\nx_prop = problem.state.x_prop  # Shape (N-1, n_x)\n</code></pre>"},{"location":"reference/algorithms/solver_state/#openscvx.algorithms.solver_state.SolverState.from_settings","title":"<code>from_settings(settings: Config) -&gt; SolverState</code>  <code>classmethod</code>","text":"<p>Create initial solver state from configuration.</p> <p>Copies only the trajectory arrays from settings, leaving all metadata (bounds, boundary conditions, etc.) in the original settings object.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Config</code> <p>Configuration object containing initial guesses and SCP parameters</p> required <p>Returns:</p> Type Description <code>SolverState</code> <p>Fresh SolverState initialized from settings with copied arrays</p> Source code in <code>openscvx/algorithms/solver_state.py</code> <pre><code>@classmethod\ndef from_settings(cls, settings: \"Config\") -&gt; \"SolverState\":\n    \"\"\"Create initial solver state from configuration.\n\n    Copies only the trajectory arrays from settings, leaving all metadata\n    (bounds, boundary conditions, etc.) in the original settings object.\n\n    Args:\n        settings: Configuration object containing initial guesses and SCP parameters\n\n    Returns:\n        Fresh SolverState initialized from settings with copied arrays\n    \"\"\"\n    return cls(\n        k=1,\n        J_tr=1e2,\n        J_vb=1e2,\n        J_vc=1e2,\n        w_tr=settings.scp.w_tr,\n        lam_cost=settings.scp.lam_cost,\n        lam_vc=settings.scp.lam_vc,\n        lam_vb=settings.scp.lam_vb,\n        n_x=settings.sim.n_states,\n        n_u=settings.sim.n_controls,\n        N=settings.scp.n,\n        X=[settings.sim.x.guess.copy()],\n        U=[settings.sim.u.guess.copy()],\n        V_history=[],\n    )\n</code></pre>"},{"location":"reference/discretization/","title":"discretization","text":"<p>Discretization methods for trajectory optimization.</p> <p>This module provides implementations of discretization schemes that convert continuous-time optimal control problems into discrete-time approximations suitable for numerical optimization. Discretization is a critical step in trajectory optimization that linearizes the nonlinear dynamics around a reference trajectory.</p> <p>Planned Architecture (ABC-based):</p> <p>A base class will be introduced to enable pluggable discretization methods. This will enable users to implement custom discretization methods. Future discretizers will implement the Discretizer interface:</p> <pre><code># discretization/base.py (planned):\nclass Discretizer(ABC):\n    def __init__(self, integrator: Integrator):\n        '''Initialize with a numerical integrator.'''\n        self.integrator = integrator\n\n    @abstractmethod\n    def discretize(self, dynamics, x, u, dt) -&gt; tuple[A_d, B_d, C_d]:\n        '''Discretize continuous dynamics around trajectory (x, u).\n\n        Args:\n            dynamics: Continuous-time dynamics object\n            x: State trajectory\n            u: Control trajectory\n            dt: Time step\n\n        Returns:\n            A_d: Discretized state transition matrix\n            B_d: Discretized control influence matrix (current node)\n            C_d: Discretized control influence matrix (next node)\n        '''\n        ...\n</code></pre>"},{"location":"reference/discretization/#openscvx.discretization.calculate_discretization","title":"<code>calculate_discretization(x, u, state_dot: callable, A: callable, B: callable, settings: Config, params: dict)</code>","text":"<p>Calculate the discretized system matrices.</p> <p>This function computes the discretized system matrices (A_bar, B_bar, C_bar) and defect vector (z_bar) using numerical integration.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>State trajectory.</p> required <code>u</code> <p>Control trajectory.</p> required <code>state_dot</code> <code>callable</code> <p>Function computing state derivatives.</p> required <code>A</code> <code>callable</code> <p>Function computing state Jacobian.</p> required <code>B</code> <code>callable</code> <p>Function computing control Jacobian.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings for OpenSCvx.</p> required <code>custom_integrator</code> <code>bool</code> <p>Whether to use custom RK45 integrator.</p> required <code>debug</code> <code>bool</code> <p>Whether to use debug mode.</p> required <code>solver</code> <code>str</code> <p>Name of the solver to use.</p> required <code>rtol</code> <code>float</code> <p>Relative tolerance for integration.</p> required <code>atol</code> <code>float</code> <p>Absolute tolerance for integration.</p> required <code>dis_type</code> <code>str</code> <p>Discretization type (\"ZOH\" or \"FOH\").</p> required <code>**kwargs</code> <p>Additional parameters passed to state_dot, A, and B.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(A_bar, B_bar, C_bar, z_bar, Vmulti) where: - A_bar: Discretized state transition matrix - B_bar: Discretized control influence matrix - C_bar: Discretized control influence matrix for next node - z_bar: Defect vector - Vmulti: Full augmented state trajectory</p> Source code in <code>openscvx/discretization/discretization.py</code> <pre><code>def calculate_discretization(\n    x,\n    u,\n    state_dot: callable,\n    A: callable,\n    B: callable,\n    settings: Config,\n    params: dict,\n):\n    \"\"\"Calculate the discretized system matrices.\n\n    This function computes the discretized system matrices (A_bar, B_bar, C_bar)\n    and defect vector (z_bar) using numerical integration.\n\n    Args:\n        x: State trajectory.\n        u: Control trajectory.\n        state_dot (callable): Function computing state derivatives.\n        A (callable): Function computing state Jacobian.\n        B (callable): Function computing control Jacobian.\n        settings: Configuration settings for OpenSCvx.\n        custom_integrator (bool): Whether to use custom RK45 integrator.\n        debug (bool): Whether to use debug mode.\n        solver (str): Name of the solver to use.\n        rtol (float): Relative tolerance for integration.\n        atol (float): Absolute tolerance for integration.\n        dis_type (str): Discretization type (\"ZOH\" or \"FOH\").\n        **kwargs: Additional parameters passed to state_dot, A, and B.\n\n    Returns:\n        tuple: (A_bar, B_bar, C_bar, z_bar, Vmulti) where:\n            - A_bar: Discretized state transition matrix\n            - B_bar: Discretized control influence matrix\n            - C_bar: Discretized control influence matrix for next node\n            - z_bar: Defect vector\n            - Vmulti: Full augmented state trajectory\n    \"\"\"\n    # Unpack settings\n    n_x = settings.sim.n_states\n    n_u = settings.sim.n_controls\n\n    N = settings.scp.n\n\n    # Define indices for slicing the augmented state vector\n    i0 = 0\n    i1 = n_x\n    i2 = i1 + n_x * n_x\n    i3 = i2 + n_x * n_u\n    i4 = i3 + n_x * n_u\n\n    # Initial augmented state\n    V0 = jnp.zeros((N - 1, i4))\n    V0 = V0.at[:, :n_x].set(x[:-1].astype(float))\n    V0 = V0.at[:, n_x : n_x + n_x * n_x].set(jnp.eye(n_x).reshape(1, -1).repeat(N - 1, axis=0))\n\n    # Choose integrator\n    integrator_args = dict(\n        u_cur=u[:-1].astype(float),\n        u_next=u[1:].astype(float),\n        state_dot=state_dot,\n        A=A,\n        B=B,\n        n_x=n_x,\n        n_u=n_u,\n        N=N,\n        dis_type=settings.dis.dis_type,\n        params=params,  # Pass params as single dict\n    )\n\n    # Define dVdt wrapper using named arguments\n    def dVdt_wrapped(t, y):\n        return dVdt(t, y, **integrator_args)\n\n    # Choose integrator\n    if settings.dis.custom_integrator:\n        sol = solve_ivp_rk45(\n            dVdt_wrapped,\n            1.0 / (N - 1),\n            V0.reshape(-1),\n            args=(),\n            is_not_compiled=settings.dev.debug,\n        )\n    else:\n        sol = solve_ivp_diffrax(\n            dVdt_wrapped,\n            1.0 / (N - 1),\n            V0.reshape(-1),\n            solver_name=settings.dis.solver,\n            rtol=settings.dis.rtol,\n            atol=settings.dis.atol,\n            args=(),\n            extra_kwargs=settings.dis.args,\n        )\n\n    Vend = sol[-1].T.reshape(-1, i4)\n    Vmulti = sol.T\n\n    x_prop = Vend[:, i0:i1]\n\n    # Return as 3D arrays: (N-1, n_x, n_x) for A_bar, (N-1, n_x, n_u) for B_bar/C_bar\n    A_bar = Vend[:, i1:i2].reshape(N - 1, n_x, n_x)\n    B_bar = Vend[:, i2:i3].reshape(N - 1, n_x, n_u)\n    C_bar = Vend[:, i3:i4].reshape(N - 1, n_x, n_u)\n\n    return A_bar, B_bar, C_bar, x_prop, Vmulti\n</code></pre>"},{"location":"reference/discretization/#openscvx.discretization.dVdt","title":"<code>dVdt(tau: float, V: jnp.ndarray, u_cur: np.ndarray, u_next: np.ndarray, state_dot: callable, A: callable, B: callable, n_x: int, n_u: int, N: int, dis_type: str, params: dict) -&gt; jnp.ndarray</code>","text":"<p>Compute the time derivative of the augmented state vector.</p> <p>This function computes the time derivative of the augmented state vector V, which includes the state, state transition matrix, and control influence matrix.</p> <p>Parameters:</p> Name Type Description Default <code>tau</code> <code>float</code> <p>Current normalized time in [0,1].</p> required <code>V</code> <code>ndarray</code> <p>Augmented state vector.</p> required <code>u_cur</code> <code>ndarray</code> <p>Control input at current node.</p> required <code>u_next</code> <code>ndarray</code> <p>Control input at next node.</p> required <code>state_dot</code> <code>callable</code> <p>Function computing state derivatives.</p> required <code>A</code> <code>callable</code> <p>Function computing state Jacobian.</p> required <code>B</code> <code>callable</code> <p>Function computing control Jacobian.</p> required <code>n_x</code> <code>int</code> <p>Number of states.</p> required <code>n_u</code> <code>int</code> <p>Number of controls.</p> required <code>N</code> <code>int</code> <p>Number of nodes in trajectory.</p> required <code>dis_type</code> <code>str</code> <p>Discretization type (\"ZOH\" or \"FOH\").</p> required <code>**params</code> <code>dict</code> <p>Additional parameters passed to state_dot, A, and B.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: Time derivative of augmented state vector.</p> Source code in <code>openscvx/discretization/discretization.py</code> <pre><code>def dVdt(\n    tau: float,\n    V: jnp.ndarray,\n    u_cur: np.ndarray,\n    u_next: np.ndarray,\n    state_dot: callable,\n    A: callable,\n    B: callable,\n    n_x: int,\n    n_u: int,\n    N: int,\n    dis_type: str,\n    params: dict,\n) -&gt; jnp.ndarray:\n    \"\"\"Compute the time derivative of the augmented state vector.\n\n    This function computes the time derivative of the augmented state vector V,\n    which includes the state, state transition matrix, and control influence matrix.\n\n    Args:\n        tau (float): Current normalized time in [0,1].\n        V (jnp.ndarray): Augmented state vector.\n        u_cur (np.ndarray): Control input at current node.\n        u_next (np.ndarray): Control input at next node.\n        state_dot (callable): Function computing state derivatives.\n        A (callable): Function computing state Jacobian.\n        B (callable): Function computing control Jacobian.\n        n_x (int): Number of states.\n        n_u (int): Number of controls.\n        N (int): Number of nodes in trajectory.\n        dis_type (str): Discretization type (\"ZOH\" or \"FOH\").\n        **params: Additional parameters passed to state_dot, A, and B.\n\n    Returns:\n        jnp.ndarray: Time derivative of augmented state vector.\n    \"\"\"\n    # Define the nodes\n    nodes = jnp.arange(0, N - 1)\n\n    # Define indices for slicing the augmented state vector\n    i0 = 0\n    i1 = n_x\n    i2 = i1 + n_x * n_x\n    i3 = i2 + n_x * n_u\n    i4 = i3 + n_x * n_u\n\n    # Unflatten V\n    V = V.reshape(-1, i4)\n\n    # Compute the interpolation factor based on the discretization type\n    if dis_type == \"ZOH\":\n        beta = 0.0\n    elif dis_type == \"FOH\":\n        beta = (tau) * N\n    alpha = 1 - beta\n\n    # Interpolate the control input\n    u = u_cur + beta * (u_next - u_cur)\n    s = u[:, -1]\n\n    # Initialize the augmented Jacobians\n    dfdx = jnp.zeros((V.shape[0], n_x, n_x))\n    dfdu = jnp.zeros((V.shape[0], n_x, n_u))\n\n    # Ensure x_seq and u have the same batch size\n    x = V[:, :n_x]\n    u = u[: x.shape[0]]\n\n    # Compute the nonlinear propagation term\n    f = state_dot(x, u[:, :-1], nodes, params)\n    F = s[:, None] * f\n\n    # Evaluate the State Jacobian\n    dfdx = A(x, u[:, :-1], nodes, params)\n    sdfdx = s[:, None, None] * dfdx\n\n    # Evaluate the Control Jacobian\n    dfdu_veh = B(x, u[:, :-1], nodes, params)\n    dfdu = dfdu.at[:, :, :-1].set(s[:, None, None] * dfdu_veh)\n    dfdu = dfdu.at[:, :, -1].set(f)\n\n    # Stack up the results into the augmented state vector\n    # fmt: off\n    dVdt = jnp.zeros_like(V)\n    dVdt = dVdt.at[:, i0:i1].set(F)\n    dVdt = dVdt.at[:, i1:i2].set(\n        jnp.matmul(sdfdx, V[:, i1:i2].reshape(-1, n_x, n_x)).reshape(-1, n_x * n_x)\n    )\n    dVdt = dVdt.at[:, i2:i3].set(\n        (jnp.matmul(sdfdx, V[:, i2:i3].reshape(-1, n_x, n_u)) + dfdu * alpha).reshape(-1, n_x * n_u)\n    )\n    dVdt = dVdt.at[:, i3:i4].set(\n        (jnp.matmul(sdfdx, V[:, i3:i4].reshape(-1, n_x, n_u)) + dfdu * beta).reshape(-1, n_x * n_u)\n    )\n    # fmt: on\n\n    return dVdt.reshape(-1)\n</code></pre>"},{"location":"reference/discretization/#openscvx.discretization.get_discretization_solver","title":"<code>get_discretization_solver(dyn: Dynamics, settings: Config)</code>","text":"<p>Create a discretization solver function.</p> <p>This function creates a solver that computes the discretized system matrices using the specified dynamics and settings.</p> <p>Parameters:</p> Name Type Description Default <code>dyn</code> <code>Dynamics</code> <p>System dynamics object.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings for discretization.</p> required <p>Returns:</p> Name Type Description <code>callable</code> <p>A function that computes the discretized system matrices.</p> Source code in <code>openscvx/discretization/discretization.py</code> <pre><code>def get_discretization_solver(dyn: Dynamics, settings: Config):\n    \"\"\"Create a discretization solver function.\n\n    This function creates a solver that computes the discretized system matrices\n    using the specified dynamics and settings.\n\n    Args:\n        dyn (Dynamics): System dynamics object.\n        settings: Configuration settings for discretization.\n\n    Returns:\n        callable: A function that computes the discretized system matrices.\n    \"\"\"\n    return lambda x, u, params: calculate_discretization(\n        x=x,\n        u=u,\n        state_dot=dyn.f,\n        A=dyn.A,\n        B=dyn.B,\n        settings=settings,\n        params=params,  # Pass as single dict\n    )\n</code></pre>"},{"location":"reference/discretization/discretization/","title":"discretization","text":""},{"location":"reference/discretization/discretization/#openscvx.discretization.discretization.calculate_discretization","title":"<code>calculate_discretization(x, u, state_dot: callable, A: callable, B: callable, settings: Config, params: dict)</code>","text":"<p>Calculate the discretized system matrices.</p> <p>This function computes the discretized system matrices (A_bar, B_bar, C_bar) and defect vector (z_bar) using numerical integration.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>State trajectory.</p> required <code>u</code> <p>Control trajectory.</p> required <code>state_dot</code> <code>callable</code> <p>Function computing state derivatives.</p> required <code>A</code> <code>callable</code> <p>Function computing state Jacobian.</p> required <code>B</code> <code>callable</code> <p>Function computing control Jacobian.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings for OpenSCvx.</p> required <code>custom_integrator</code> <code>bool</code> <p>Whether to use custom RK45 integrator.</p> required <code>debug</code> <code>bool</code> <p>Whether to use debug mode.</p> required <code>solver</code> <code>str</code> <p>Name of the solver to use.</p> required <code>rtol</code> <code>float</code> <p>Relative tolerance for integration.</p> required <code>atol</code> <code>float</code> <p>Absolute tolerance for integration.</p> required <code>dis_type</code> <code>str</code> <p>Discretization type (\"ZOH\" or \"FOH\").</p> required <code>**kwargs</code> <p>Additional parameters passed to state_dot, A, and B.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(A_bar, B_bar, C_bar, z_bar, Vmulti) where: - A_bar: Discretized state transition matrix - B_bar: Discretized control influence matrix - C_bar: Discretized control influence matrix for next node - z_bar: Defect vector - Vmulti: Full augmented state trajectory</p> Source code in <code>openscvx/discretization/discretization.py</code> <pre><code>def calculate_discretization(\n    x,\n    u,\n    state_dot: callable,\n    A: callable,\n    B: callable,\n    settings: Config,\n    params: dict,\n):\n    \"\"\"Calculate the discretized system matrices.\n\n    This function computes the discretized system matrices (A_bar, B_bar, C_bar)\n    and defect vector (z_bar) using numerical integration.\n\n    Args:\n        x: State trajectory.\n        u: Control trajectory.\n        state_dot (callable): Function computing state derivatives.\n        A (callable): Function computing state Jacobian.\n        B (callable): Function computing control Jacobian.\n        settings: Configuration settings for OpenSCvx.\n        custom_integrator (bool): Whether to use custom RK45 integrator.\n        debug (bool): Whether to use debug mode.\n        solver (str): Name of the solver to use.\n        rtol (float): Relative tolerance for integration.\n        atol (float): Absolute tolerance for integration.\n        dis_type (str): Discretization type (\"ZOH\" or \"FOH\").\n        **kwargs: Additional parameters passed to state_dot, A, and B.\n\n    Returns:\n        tuple: (A_bar, B_bar, C_bar, z_bar, Vmulti) where:\n            - A_bar: Discretized state transition matrix\n            - B_bar: Discretized control influence matrix\n            - C_bar: Discretized control influence matrix for next node\n            - z_bar: Defect vector\n            - Vmulti: Full augmented state trajectory\n    \"\"\"\n    # Unpack settings\n    n_x = settings.sim.n_states\n    n_u = settings.sim.n_controls\n\n    N = settings.scp.n\n\n    # Define indices for slicing the augmented state vector\n    i0 = 0\n    i1 = n_x\n    i2 = i1 + n_x * n_x\n    i3 = i2 + n_x * n_u\n    i4 = i3 + n_x * n_u\n\n    # Initial augmented state\n    V0 = jnp.zeros((N - 1, i4))\n    V0 = V0.at[:, :n_x].set(x[:-1].astype(float))\n    V0 = V0.at[:, n_x : n_x + n_x * n_x].set(jnp.eye(n_x).reshape(1, -1).repeat(N - 1, axis=0))\n\n    # Choose integrator\n    integrator_args = dict(\n        u_cur=u[:-1].astype(float),\n        u_next=u[1:].astype(float),\n        state_dot=state_dot,\n        A=A,\n        B=B,\n        n_x=n_x,\n        n_u=n_u,\n        N=N,\n        dis_type=settings.dis.dis_type,\n        params=params,  # Pass params as single dict\n    )\n\n    # Define dVdt wrapper using named arguments\n    def dVdt_wrapped(t, y):\n        return dVdt(t, y, **integrator_args)\n\n    # Choose integrator\n    if settings.dis.custom_integrator:\n        sol = solve_ivp_rk45(\n            dVdt_wrapped,\n            1.0 / (N - 1),\n            V0.reshape(-1),\n            args=(),\n            is_not_compiled=settings.dev.debug,\n        )\n    else:\n        sol = solve_ivp_diffrax(\n            dVdt_wrapped,\n            1.0 / (N - 1),\n            V0.reshape(-1),\n            solver_name=settings.dis.solver,\n            rtol=settings.dis.rtol,\n            atol=settings.dis.atol,\n            args=(),\n            extra_kwargs=settings.dis.args,\n        )\n\n    Vend = sol[-1].T.reshape(-1, i4)\n    Vmulti = sol.T\n\n    x_prop = Vend[:, i0:i1]\n\n    # Return as 3D arrays: (N-1, n_x, n_x) for A_bar, (N-1, n_x, n_u) for B_bar/C_bar\n    A_bar = Vend[:, i1:i2].reshape(N - 1, n_x, n_x)\n    B_bar = Vend[:, i2:i3].reshape(N - 1, n_x, n_u)\n    C_bar = Vend[:, i3:i4].reshape(N - 1, n_x, n_u)\n\n    return A_bar, B_bar, C_bar, x_prop, Vmulti\n</code></pre>"},{"location":"reference/discretization/discretization/#openscvx.discretization.discretization.dVdt","title":"<code>dVdt(tau: float, V: jnp.ndarray, u_cur: np.ndarray, u_next: np.ndarray, state_dot: callable, A: callable, B: callable, n_x: int, n_u: int, N: int, dis_type: str, params: dict) -&gt; jnp.ndarray</code>","text":"<p>Compute the time derivative of the augmented state vector.</p> <p>This function computes the time derivative of the augmented state vector V, which includes the state, state transition matrix, and control influence matrix.</p> <p>Parameters:</p> Name Type Description Default <code>tau</code> <code>float</code> <p>Current normalized time in [0,1].</p> required <code>V</code> <code>ndarray</code> <p>Augmented state vector.</p> required <code>u_cur</code> <code>ndarray</code> <p>Control input at current node.</p> required <code>u_next</code> <code>ndarray</code> <p>Control input at next node.</p> required <code>state_dot</code> <code>callable</code> <p>Function computing state derivatives.</p> required <code>A</code> <code>callable</code> <p>Function computing state Jacobian.</p> required <code>B</code> <code>callable</code> <p>Function computing control Jacobian.</p> required <code>n_x</code> <code>int</code> <p>Number of states.</p> required <code>n_u</code> <code>int</code> <p>Number of controls.</p> required <code>N</code> <code>int</code> <p>Number of nodes in trajectory.</p> required <code>dis_type</code> <code>str</code> <p>Discretization type (\"ZOH\" or \"FOH\").</p> required <code>**params</code> <code>dict</code> <p>Additional parameters passed to state_dot, A, and B.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: Time derivative of augmented state vector.</p> Source code in <code>openscvx/discretization/discretization.py</code> <pre><code>def dVdt(\n    tau: float,\n    V: jnp.ndarray,\n    u_cur: np.ndarray,\n    u_next: np.ndarray,\n    state_dot: callable,\n    A: callable,\n    B: callable,\n    n_x: int,\n    n_u: int,\n    N: int,\n    dis_type: str,\n    params: dict,\n) -&gt; jnp.ndarray:\n    \"\"\"Compute the time derivative of the augmented state vector.\n\n    This function computes the time derivative of the augmented state vector V,\n    which includes the state, state transition matrix, and control influence matrix.\n\n    Args:\n        tau (float): Current normalized time in [0,1].\n        V (jnp.ndarray): Augmented state vector.\n        u_cur (np.ndarray): Control input at current node.\n        u_next (np.ndarray): Control input at next node.\n        state_dot (callable): Function computing state derivatives.\n        A (callable): Function computing state Jacobian.\n        B (callable): Function computing control Jacobian.\n        n_x (int): Number of states.\n        n_u (int): Number of controls.\n        N (int): Number of nodes in trajectory.\n        dis_type (str): Discretization type (\"ZOH\" or \"FOH\").\n        **params: Additional parameters passed to state_dot, A, and B.\n\n    Returns:\n        jnp.ndarray: Time derivative of augmented state vector.\n    \"\"\"\n    # Define the nodes\n    nodes = jnp.arange(0, N - 1)\n\n    # Define indices for slicing the augmented state vector\n    i0 = 0\n    i1 = n_x\n    i2 = i1 + n_x * n_x\n    i3 = i2 + n_x * n_u\n    i4 = i3 + n_x * n_u\n\n    # Unflatten V\n    V = V.reshape(-1, i4)\n\n    # Compute the interpolation factor based on the discretization type\n    if dis_type == \"ZOH\":\n        beta = 0.0\n    elif dis_type == \"FOH\":\n        beta = (tau) * N\n    alpha = 1 - beta\n\n    # Interpolate the control input\n    u = u_cur + beta * (u_next - u_cur)\n    s = u[:, -1]\n\n    # Initialize the augmented Jacobians\n    dfdx = jnp.zeros((V.shape[0], n_x, n_x))\n    dfdu = jnp.zeros((V.shape[0], n_x, n_u))\n\n    # Ensure x_seq and u have the same batch size\n    x = V[:, :n_x]\n    u = u[: x.shape[0]]\n\n    # Compute the nonlinear propagation term\n    f = state_dot(x, u[:, :-1], nodes, params)\n    F = s[:, None] * f\n\n    # Evaluate the State Jacobian\n    dfdx = A(x, u[:, :-1], nodes, params)\n    sdfdx = s[:, None, None] * dfdx\n\n    # Evaluate the Control Jacobian\n    dfdu_veh = B(x, u[:, :-1], nodes, params)\n    dfdu = dfdu.at[:, :, :-1].set(s[:, None, None] * dfdu_veh)\n    dfdu = dfdu.at[:, :, -1].set(f)\n\n    # Stack up the results into the augmented state vector\n    # fmt: off\n    dVdt = jnp.zeros_like(V)\n    dVdt = dVdt.at[:, i0:i1].set(F)\n    dVdt = dVdt.at[:, i1:i2].set(\n        jnp.matmul(sdfdx, V[:, i1:i2].reshape(-1, n_x, n_x)).reshape(-1, n_x * n_x)\n    )\n    dVdt = dVdt.at[:, i2:i3].set(\n        (jnp.matmul(sdfdx, V[:, i2:i3].reshape(-1, n_x, n_u)) + dfdu * alpha).reshape(-1, n_x * n_u)\n    )\n    dVdt = dVdt.at[:, i3:i4].set(\n        (jnp.matmul(sdfdx, V[:, i3:i4].reshape(-1, n_x, n_u)) + dfdu * beta).reshape(-1, n_x * n_u)\n    )\n    # fmt: on\n\n    return dVdt.reshape(-1)\n</code></pre>"},{"location":"reference/discretization/discretization/#openscvx.discretization.discretization.get_discretization_solver","title":"<code>get_discretization_solver(dyn: Dynamics, settings: Config)</code>","text":"<p>Create a discretization solver function.</p> <p>This function creates a solver that computes the discretized system matrices using the specified dynamics and settings.</p> <p>Parameters:</p> Name Type Description Default <code>dyn</code> <code>Dynamics</code> <p>System dynamics object.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings for discretization.</p> required <p>Returns:</p> Name Type Description <code>callable</code> <p>A function that computes the discretized system matrices.</p> Source code in <code>openscvx/discretization/discretization.py</code> <pre><code>def get_discretization_solver(dyn: Dynamics, settings: Config):\n    \"\"\"Create a discretization solver function.\n\n    This function creates a solver that computes the discretized system matrices\n    using the specified dynamics and settings.\n\n    Args:\n        dyn (Dynamics): System dynamics object.\n        settings: Configuration settings for discretization.\n\n    Returns:\n        callable: A function that computes the discretized system matrices.\n    \"\"\"\n    return lambda x, u, params: calculate_discretization(\n        x=x,\n        u=u,\n        state_dot=dyn.f,\n        A=dyn.A,\n        B=dyn.B,\n        settings=settings,\n        params=params,  # Pass as single dict\n    )\n</code></pre>"},{"location":"reference/integrators/","title":"integrators","text":"<p>Numerical integration schemes for trajectory optimization.</p> <p>This module provides implementations of numerical integrators used for simulating continuous-time dynamics.</p> Current Implementations <p>RK45 Integration: Explicit Runge-Kutta-Fehlberg method (4th/5th order)     with both fixed-step and adaptive implementations via Diffrax.     Supports a variety of explicit and implicit ODE solvers through the     Diffrax backend (Dopri5/8, Tsit5, KenCarp3/4/5, etc.).</p> <p>Planned Architecture (ABC-based):</p> <p>A base class will be introduced to enable pluggable integrator implementations. This will enable users to implement custom integrators. Future integrators will implement the Integrator interface:</p> <pre><code># integrators/base.py (planned):\nclass Integrator(ABC):\n    @abstractmethod\n    def step(self, f: Callable, x: Array, u: Array, t: float, dt: float) -&gt; Array:\n        '''Take one integration step from state x at time t with step dt.'''\n        ...\n\n    @abstractmethod\n    def integrate(self, f: Callable, x0: Array, u_traj: Array,\n                    t_span: tuple[float, float], num_steps: int) -&gt; Array:\n        '''Integrate over a time span with given control trajectory.'''\n        ...\n</code></pre>"},{"location":"reference/integrators/#openscvx.integrators.rk45_step","title":"<code>rk45_step(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], t: jnp.ndarray, y: jnp.ndarray, h: float, *args) -&gt; jnp.ndarray</code>","text":"<p>Perform a single RK45 (Runge-Kutta-Fehlberg) integration step.</p> <p>This implements the classic Dorman-Prince coefficients for an explicit 4(5) method, returning the fourth-order estimate.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>t</code> <code>ndarray</code> <p>Current time.</p> required <code>y</code> <code>ndarray</code> <p>Current state vector.</p> required <code>h</code> <code>float</code> <p>Step size.</p> required <code>*args</code> <p>Additional arguments passed to <code>f</code>.</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: Next state estimate at t + h.</p> Source code in <code>openscvx/integrators/runge_kutta.py</code> <pre><code>def rk45_step(\n    f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray],\n    t: jnp.ndarray,\n    y: jnp.ndarray,\n    h: float,\n    *args\n) -&gt; jnp.ndarray:\n    \"\"\"\n    Perform a single RK45 (Runge-Kutta-Fehlberg) integration step.\n\n    This implements the classic Dorman-Prince coefficients for an\n    explicit 4(5) method, returning the fourth-order estimate.\n\n    Args:\n        f (Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray]):\n            ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.\n        t (jnp.ndarray): Current time.\n        y (jnp.ndarray): Current state vector.\n        h (float): Step size.\n        *args: Additional arguments passed to `f`.\n\n    Returns:\n        jnp.ndarray: Next state estimate at t + h.\n    \"\"\"\n    k1 = f(t, y, *args)\n    k2 = f(t + h/4, y + h*k1/4, *args)\n    k3 = f(t + 3*h/8, y + 3*h*k1/32 + 9*h*k2/32, *args)\n    k4 = f(t + 12*h/13, y + 1932*h*k1/2197 - 7200*h*k2/2197 + 7296*h*k3/2197, *args)\n    k5 = f(t + h, y + 439*h*k1/216 - 8*h*k2 + 3680*h*k3/513 - 845*h*k4/4104, *args)\n    y_next = y + h * (25*k1/216 + 1408*k3/2565 + 2197*k4/4104 - k5/5)\n    return y_next\n</code></pre>"},{"location":"reference/integrators/#openscvx.integrators.solve_ivp_diffrax","title":"<code>solve_ivp_diffrax(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; f(t, y, *args).</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>solver_name</code> is not in SOLVER_MAP.</p> Source code in <code>openscvx/integrators/runge_kutta.py</code> <pre><code>def solve_ivp_diffrax(\n    f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray],\n    tau_final: float,\n    y_0: jnp.ndarray,\n    args,\n    tau_0: float = 0.0,\n    num_substeps: int = 50,\n    solver_name: str = \"Dopri8\",\n    rtol: float = 1e-3,\n    atol: float = 1e-6,\n    extra_kwargs=None,\n):\n    \"\"\"\n    Solve an initial-value ODE problem using a Diffrax adaptive solver.\n\n    Args:\n        f (Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray]):\n            ODE right-hand side; f(t, y, *args).\n        tau_final (float): Final integration time.\n        y_0 (jnp.ndarray): Initial state at tau_0.\n        args (tuple): Extra arguments to pass to `f` in the solver term.\n        tau_0 (float, optional): Initial time. Defaults to 0.0.\n        num_substeps (int, optional): Number of save points between tau_0 and tau_final.\n            Defaults to 50.\n        solver_name (str, optional): Key into SOLVER_MAP for the Diffrax solver class.\n            Defaults to \"Dopri8\".\n        rtol (float, optional): Relative tolerance for adaptive stepping. Defaults to 1e-3.\n        atol (float, optional): Absolute tolerance for adaptive stepping. Defaults to 1e-6.\n        extra_kwargs (dict, optional): Additional keyword arguments forwarded to `diffeqsolve`.\n\n    Returns:\n        jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).\n\n    Raises:\n        ValueError: If `solver_name` is not in SOLVER_MAP.\n    \"\"\"\n    substeps = jnp.linspace(tau_0, tau_final, num_substeps)\n\n    solver_class = SOLVER_MAP.get(solver_name)\n    if solver_class is None:\n        raise ValueError(f\"Unknown solver: {solver_name}\")\n    solver = solver_class()\n\n    term = dfx.ODETerm(lambda t, y, args: f(t, y, *args))\n    stepsize_controller = dfx.PIDController(rtol=rtol, atol=atol)\n    solution = dfx.diffeqsolve(\n        term,\n        solver=solver,\n        t0=tau_0,\n        t1=tau_final,\n        dt0=(tau_final - tau_0) / (len(substeps) - 1),\n        y0=y_0,\n        args=args,\n        stepsize_controller=stepsize_controller,\n        saveat=dfx.SaveAt(ts=substeps),\n        progress_meter=dfx.NoProgressMeter(),\n        **(extra_kwargs or {}),\n    )\n\n    return solution.ys\n</code></pre>"},{"location":"reference/integrators/#openscvx.integrators.solve_ivp_diffrax_prop","title":"<code>solve_ivp_diffrax_prop(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None, save_time: jnp.ndarray = None, mask: jnp.ndarray = None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver. This function is specifically designed for use in the context of trajectory optimization and handles the nonlinear single-shot propagation of state variables in undilated time.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <code>save_time</code> <code>ndarray</code> <p>Time points at which to evaluate the solution. Must be provided for export compatibility.</p> <code>None</code> <code>mask</code> <code>ndarray</code> <p>Boolean mask for the save_time points.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:     ValueError: If <code>solver_name</code> is not in SOLVER_MAP or if save_time is not provided.</p> Source code in <code>openscvx/integrators/runge_kutta.py</code> <pre><code>def solve_ivp_diffrax_prop(\n    f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray],\n    tau_final: float,\n    y_0: jnp.ndarray,\n    args,\n    tau_0: float = 0.0,\n    num_substeps: int = 50,\n    solver_name: str = \"Dopri8\",\n    rtol: float = 1e-3,\n    atol: float = 1e-6,\n    extra_kwargs=None,\n    save_time: jnp.ndarray = None,\n    mask: jnp.ndarray = None,\n):\n    \"\"\"\n    Solve an initial-value ODE problem using a Diffrax adaptive solver.\n    This function is specifically designed for use in the context of\n    trajectory optimization and handles the nonlinear single-shot propagation\n    of state variables in undilated time.\n\n    Args:\n        f (Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray]): ODE right-hand side;\n            signature f(t, y, *args) -&gt; dy/dt.\n        tau_final (float): Final integration time.\n        y_0 (jnp.ndarray): Initial state at tau_0.\n        args (tuple): Extra arguments to pass to `f` in the solver term.\n        tau_0 (float, optional): Initial time. Defaults to 0.0.\n        num_substeps (int, optional): Number of save points between tau_0 and tau_final.\n            Defaults to 50.\n        solver_name (str, optional): Key into SOLVER_MAP for the Diffrax solver class.\n            Defaults to \"Dopri8\".\n        rtol (float, optional): Relative tolerance for adaptive stepping. Defaults to 1e-3.\n        atol (float, optional): Absolute tolerance for adaptive stepping. Defaults to 1e-6.\n        extra_kwargs (dict, optional): Additional keyword arguments forwarded to `diffeqsolve`.\n        save_time (jnp.ndarray, optional): Time points at which to evaluate the solution.\n            Must be provided for export compatibility.\n        mask (jnp.ndarray, optional): Boolean mask for the save_time points.\n\n    Returns:\n        jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).\n    Raises:\n        ValueError: If `solver_name` is not in SOLVER_MAP or if save_time is not provided.\n    \"\"\"\n\n    if save_time is None:\n        raise ValueError(\"save_time must be provided for export compatibility.\")\n    if mask is None:\n        mask = jnp.ones_like(save_time, dtype=bool)\n\n    solver_class = SOLVER_MAP.get(solver_name)\n    if solver_class is None:\n        raise ValueError(f\"Unknown solver: {solver_name}\")\n    solver = solver_class()\n\n    term = dfx.ODETerm(lambda t, y, args: f(t, y, *args))\n    stepsize_controller = dfx.PIDController(rtol=rtol, atol=atol)\n\n    solution = dfx.diffeqsolve(\n        term,\n        solver=solver,\n        t0=tau_0,\n        t1=tau_final,\n        dt0=(tau_final - tau_0) / 1,\n        y0=y_0,\n        args=args,\n        stepsize_controller=stepsize_controller,\n        saveat=dfx.SaveAt(dense=True),\n        **(extra_kwargs or {}),\n    )\n\n    # Evaluate all save_time points (static size), then mask them\n    all_evals = jax.vmap(solution.evaluate)(save_time)  # shape: (MAX_TAU_LEN, n_states)\n    masked_array = jnp.where(mask[:, None], all_evals, jnp.zeros_like(all_evals))\n    # shape: (variable_len, n_states)\n\n    return masked_array\n</code></pre>"},{"location":"reference/integrators/#openscvx.integrators.solve_ivp_rk45","title":"<code>solve_ivp_rk45(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, is_not_compiled: bool = False)</code>","text":"<p>Solve an initial-value ODE problem using fixed-step RK45 integration.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code>.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of output time points. Defaults to 50.</p> <code>50</code> <code>is_not_compiled</code> <code>bool</code> <p>If True, use Python loop instead of JAX <code>lax.fori_loop</code>. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Array of shape (num_substeps, state_dim) with solution at each time.</p> Source code in <code>openscvx/integrators/runge_kutta.py</code> <pre><code>def solve_ivp_rk45(\n    f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray],\n    tau_final: float,\n    y_0: jnp.ndarray,\n    args,\n    tau_0: float = 0.0,\n    num_substeps: int = 50,\n    is_not_compiled: bool = False,\n):\n    \"\"\"\n    Solve an initial-value ODE problem using fixed-step RK45 integration.\n\n    Args:\n        f (Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray]):\n            ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.\n        tau_final (float): Final integration time.\n        y_0 (jnp.ndarray): Initial state at tau_0.\n        args (tuple): Extra arguments to pass to `f`.\n        tau_0 (float, optional): Initial time. Defaults to 0.0.\n        num_substeps (int, optional): Number of output time points. Defaults to 50.\n        is_not_compiled (bool, optional): If True, use Python loop instead of\n            JAX `lax.fori_loop`. Defaults to False.\n\n    Returns:\n        jnp.ndarray: Array of shape (num_substeps, state_dim) with solution at each time.\n    \"\"\"\n    substeps = jnp.linspace(tau_0, tau_final, num_substeps)\n\n    h = (tau_final - tau_0) / (len(substeps) - 1)\n    solution = jnp.zeros((len(substeps), len(y_0)))\n    solution = solution.at[0].set(y_0)\n\n    if is_not_compiled:\n        for i in range(1, len(substeps)):\n            t = tau_0 + i * h\n            solution = solution.at[i].set(rk45_step(f, t, solution[i - 1], h, *args))\n    else:\n\n        def body_fun(i, val):\n            t, y, V_result = val\n            y_next = rk45_step(f, t, y, h, *args)\n            V_result = V_result.at[i].set(y_next)\n            return (t + h, y_next, V_result)\n\n        _, _, solution = jax.lax.fori_loop(1, len(substeps), body_fun, (tau_0, y_0, solution))\n\n    return solution\n</code></pre>"},{"location":"reference/integrators/runge_kutta/","title":"runge_kutta","text":""},{"location":"reference/integrators/runge_kutta/#openscvx.integrators.runge_kutta.rk45_step","title":"<code>rk45_step(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], t: jnp.ndarray, y: jnp.ndarray, h: float, *args) -&gt; jnp.ndarray</code>","text":"<p>Perform a single RK45 (Runge-Kutta-Fehlberg) integration step.</p> <p>This implements the classic Dorman-Prince coefficients for an explicit 4(5) method, returning the fourth-order estimate.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>t</code> <code>ndarray</code> <p>Current time.</p> required <code>y</code> <code>ndarray</code> <p>Current state vector.</p> required <code>h</code> <code>float</code> <p>Step size.</p> required <code>*args</code> <p>Additional arguments passed to <code>f</code>.</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: Next state estimate at t + h.</p> Source code in <code>openscvx/integrators/runge_kutta.py</code> <pre><code>def rk45_step(\n    f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray],\n    t: jnp.ndarray,\n    y: jnp.ndarray,\n    h: float,\n    *args\n) -&gt; jnp.ndarray:\n    \"\"\"\n    Perform a single RK45 (Runge-Kutta-Fehlberg) integration step.\n\n    This implements the classic Dorman-Prince coefficients for an\n    explicit 4(5) method, returning the fourth-order estimate.\n\n    Args:\n        f (Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray]):\n            ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.\n        t (jnp.ndarray): Current time.\n        y (jnp.ndarray): Current state vector.\n        h (float): Step size.\n        *args: Additional arguments passed to `f`.\n\n    Returns:\n        jnp.ndarray: Next state estimate at t + h.\n    \"\"\"\n    k1 = f(t, y, *args)\n    k2 = f(t + h/4, y + h*k1/4, *args)\n    k3 = f(t + 3*h/8, y + 3*h*k1/32 + 9*h*k2/32, *args)\n    k4 = f(t + 12*h/13, y + 1932*h*k1/2197 - 7200*h*k2/2197 + 7296*h*k3/2197, *args)\n    k5 = f(t + h, y + 439*h*k1/216 - 8*h*k2 + 3680*h*k3/513 - 845*h*k4/4104, *args)\n    y_next = y + h * (25*k1/216 + 1408*k3/2565 + 2197*k4/4104 - k5/5)\n    return y_next\n</code></pre>"},{"location":"reference/integrators/runge_kutta/#openscvx.integrators.runge_kutta.solve_ivp_diffrax","title":"<code>solve_ivp_diffrax(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; f(t, y, *args).</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>solver_name</code> is not in SOLVER_MAP.</p> Source code in <code>openscvx/integrators/runge_kutta.py</code> <pre><code>def solve_ivp_diffrax(\n    f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray],\n    tau_final: float,\n    y_0: jnp.ndarray,\n    args,\n    tau_0: float = 0.0,\n    num_substeps: int = 50,\n    solver_name: str = \"Dopri8\",\n    rtol: float = 1e-3,\n    atol: float = 1e-6,\n    extra_kwargs=None,\n):\n    \"\"\"\n    Solve an initial-value ODE problem using a Diffrax adaptive solver.\n\n    Args:\n        f (Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray]):\n            ODE right-hand side; f(t, y, *args).\n        tau_final (float): Final integration time.\n        y_0 (jnp.ndarray): Initial state at tau_0.\n        args (tuple): Extra arguments to pass to `f` in the solver term.\n        tau_0 (float, optional): Initial time. Defaults to 0.0.\n        num_substeps (int, optional): Number of save points between tau_0 and tau_final.\n            Defaults to 50.\n        solver_name (str, optional): Key into SOLVER_MAP for the Diffrax solver class.\n            Defaults to \"Dopri8\".\n        rtol (float, optional): Relative tolerance for adaptive stepping. Defaults to 1e-3.\n        atol (float, optional): Absolute tolerance for adaptive stepping. Defaults to 1e-6.\n        extra_kwargs (dict, optional): Additional keyword arguments forwarded to `diffeqsolve`.\n\n    Returns:\n        jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).\n\n    Raises:\n        ValueError: If `solver_name` is not in SOLVER_MAP.\n    \"\"\"\n    substeps = jnp.linspace(tau_0, tau_final, num_substeps)\n\n    solver_class = SOLVER_MAP.get(solver_name)\n    if solver_class is None:\n        raise ValueError(f\"Unknown solver: {solver_name}\")\n    solver = solver_class()\n\n    term = dfx.ODETerm(lambda t, y, args: f(t, y, *args))\n    stepsize_controller = dfx.PIDController(rtol=rtol, atol=atol)\n    solution = dfx.diffeqsolve(\n        term,\n        solver=solver,\n        t0=tau_0,\n        t1=tau_final,\n        dt0=(tau_final - tau_0) / (len(substeps) - 1),\n        y0=y_0,\n        args=args,\n        stepsize_controller=stepsize_controller,\n        saveat=dfx.SaveAt(ts=substeps),\n        progress_meter=dfx.NoProgressMeter(),\n        **(extra_kwargs or {}),\n    )\n\n    return solution.ys\n</code></pre>"},{"location":"reference/integrators/runge_kutta/#openscvx.integrators.runge_kutta.solve_ivp_diffrax_prop","title":"<code>solve_ivp_diffrax_prop(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None, save_time: jnp.ndarray = None, mask: jnp.ndarray = None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver. This function is specifically designed for use in the context of trajectory optimization and handles the nonlinear single-shot propagation of state variables in undilated time.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <code>save_time</code> <code>ndarray</code> <p>Time points at which to evaluate the solution. Must be provided for export compatibility.</p> <code>None</code> <code>mask</code> <code>ndarray</code> <p>Boolean mask for the save_time points.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:     ValueError: If <code>solver_name</code> is not in SOLVER_MAP or if save_time is not provided.</p> Source code in <code>openscvx/integrators/runge_kutta.py</code> <pre><code>def solve_ivp_diffrax_prop(\n    f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray],\n    tau_final: float,\n    y_0: jnp.ndarray,\n    args,\n    tau_0: float = 0.0,\n    num_substeps: int = 50,\n    solver_name: str = \"Dopri8\",\n    rtol: float = 1e-3,\n    atol: float = 1e-6,\n    extra_kwargs=None,\n    save_time: jnp.ndarray = None,\n    mask: jnp.ndarray = None,\n):\n    \"\"\"\n    Solve an initial-value ODE problem using a Diffrax adaptive solver.\n    This function is specifically designed for use in the context of\n    trajectory optimization and handles the nonlinear single-shot propagation\n    of state variables in undilated time.\n\n    Args:\n        f (Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray]): ODE right-hand side;\n            signature f(t, y, *args) -&gt; dy/dt.\n        tau_final (float): Final integration time.\n        y_0 (jnp.ndarray): Initial state at tau_0.\n        args (tuple): Extra arguments to pass to `f` in the solver term.\n        tau_0 (float, optional): Initial time. Defaults to 0.0.\n        num_substeps (int, optional): Number of save points between tau_0 and tau_final.\n            Defaults to 50.\n        solver_name (str, optional): Key into SOLVER_MAP for the Diffrax solver class.\n            Defaults to \"Dopri8\".\n        rtol (float, optional): Relative tolerance for adaptive stepping. Defaults to 1e-3.\n        atol (float, optional): Absolute tolerance for adaptive stepping. Defaults to 1e-6.\n        extra_kwargs (dict, optional): Additional keyword arguments forwarded to `diffeqsolve`.\n        save_time (jnp.ndarray, optional): Time points at which to evaluate the solution.\n            Must be provided for export compatibility.\n        mask (jnp.ndarray, optional): Boolean mask for the save_time points.\n\n    Returns:\n        jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).\n    Raises:\n        ValueError: If `solver_name` is not in SOLVER_MAP or if save_time is not provided.\n    \"\"\"\n\n    if save_time is None:\n        raise ValueError(\"save_time must be provided for export compatibility.\")\n    if mask is None:\n        mask = jnp.ones_like(save_time, dtype=bool)\n\n    solver_class = SOLVER_MAP.get(solver_name)\n    if solver_class is None:\n        raise ValueError(f\"Unknown solver: {solver_name}\")\n    solver = solver_class()\n\n    term = dfx.ODETerm(lambda t, y, args: f(t, y, *args))\n    stepsize_controller = dfx.PIDController(rtol=rtol, atol=atol)\n\n    solution = dfx.diffeqsolve(\n        term,\n        solver=solver,\n        t0=tau_0,\n        t1=tau_final,\n        dt0=(tau_final - tau_0) / 1,\n        y0=y_0,\n        args=args,\n        stepsize_controller=stepsize_controller,\n        saveat=dfx.SaveAt(dense=True),\n        **(extra_kwargs or {}),\n    )\n\n    # Evaluate all save_time points (static size), then mask them\n    all_evals = jax.vmap(solution.evaluate)(save_time)  # shape: (MAX_TAU_LEN, n_states)\n    masked_array = jnp.where(mask[:, None], all_evals, jnp.zeros_like(all_evals))\n    # shape: (variable_len, n_states)\n\n    return masked_array\n</code></pre>"},{"location":"reference/integrators/runge_kutta/#openscvx.integrators.runge_kutta.solve_ivp_rk45","title":"<code>solve_ivp_rk45(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, is_not_compiled: bool = False)</code>","text":"<p>Solve an initial-value ODE problem using fixed-step RK45 integration.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code>.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of output time points. Defaults to 50.</p> <code>50</code> <code>is_not_compiled</code> <code>bool</code> <p>If True, use Python loop instead of JAX <code>lax.fori_loop</code>. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Array of shape (num_substeps, state_dim) with solution at each time.</p> Source code in <code>openscvx/integrators/runge_kutta.py</code> <pre><code>def solve_ivp_rk45(\n    f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray],\n    tau_final: float,\n    y_0: jnp.ndarray,\n    args,\n    tau_0: float = 0.0,\n    num_substeps: int = 50,\n    is_not_compiled: bool = False,\n):\n    \"\"\"\n    Solve an initial-value ODE problem using fixed-step RK45 integration.\n\n    Args:\n        f (Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray]):\n            ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.\n        tau_final (float): Final integration time.\n        y_0 (jnp.ndarray): Initial state at tau_0.\n        args (tuple): Extra arguments to pass to `f`.\n        tau_0 (float, optional): Initial time. Defaults to 0.0.\n        num_substeps (int, optional): Number of output time points. Defaults to 50.\n        is_not_compiled (bool, optional): If True, use Python loop instead of\n            JAX `lax.fori_loop`. Defaults to False.\n\n    Returns:\n        jnp.ndarray: Array of shape (num_substeps, state_dim) with solution at each time.\n    \"\"\"\n    substeps = jnp.linspace(tau_0, tau_final, num_substeps)\n\n    h = (tau_final - tau_0) / (len(substeps) - 1)\n    solution = jnp.zeros((len(substeps), len(y_0)))\n    solution = solution.at[0].set(y_0)\n\n    if is_not_compiled:\n        for i in range(1, len(substeps)):\n            t = tau_0 + i * h\n            solution = solution.at[i].set(rk45_step(f, t, solution[i - 1], h, *args))\n    else:\n\n        def body_fun(i, val):\n            t, y, V_result = val\n            y_next = rk45_step(f, t, y, h, *args)\n            V_result = V_result.at[i].set(y_next)\n            return (t + h, y_next, V_result)\n\n        _, _, solution = jax.lax.fori_loop(1, len(substeps), body_fun, (tau_0, y_0, solution))\n\n    return solution\n</code></pre>"},{"location":"reference/lowered/","title":"lowered","text":"<p>Lowered problem dataclasses.</p> <p>This module contains dataclasses representing the outputs of the lowering phase, where symbolic expressions are converted to executable JAX and CVXPy code.</p>"},{"location":"reference/lowered/#openscvx.lowered.CVXPyVariables","title":"<code>CVXPyVariables</code>  <code>dataclass</code>","text":"<p>CVXPy variables and parameters for the optimal control problem.</p> <p>This dataclass holds all CVXPy Variable and Parameter objects needed to construct and solve the optimal control problem. It replaces the previous untyped dictionary approach with a typed, self-documenting structure.</p> The variables are organized into logical groups <ul> <li>SCP weights: Parameters controlling trust region and penalty weights</li> <li>State: Variables and parameters for the state trajectory</li> <li>Control: Variables and parameters for the control trajectory</li> <li>Dynamics: Parameters for the discretized dynamics constraints</li> <li>Nodal constraints: Parameters for linearized non-convex nodal constraints</li> <li>Cross-node constraints: Parameters for linearized cross-node constraints</li> <li>Scaling: Affine scaling matrices and offset vectors</li> <li>Scaled expressions: CVXPy expressions for scaled state/control at each node</li> </ul> <p>Attributes:</p> Name Type Description <code>w_tr</code> <code>Parameter</code> <p>Trust region weight parameter (scalar, nonneg)</p> <code>lam_cost</code> <code>Parameter</code> <p>Cost function weight parameter (scalar, nonneg)</p> <code>lam_vc</code> <code>Parameter</code> <p>Virtual control penalty weights (N-1 x n_states, nonneg)</p> <code>lam_vb</code> <code>Parameter</code> <p>Virtual buffer penalty weight (scalar, nonneg)</p> <code>x</code> <code>Variable</code> <p>State variable (N x n_states)</p> <code>dx</code> <code>Variable</code> <p>State error variable (N x n_states)</p> <code>x_bar</code> <code>Parameter</code> <p>Previous SCP state parameter (N x n_states)</p> <code>x_init</code> <code>Parameter</code> <p>Initial state parameter (n_states,)</p> <code>x_term</code> <code>Parameter</code> <p>Terminal state parameter (n_states,)</p> <code>u</code> <code>Variable</code> <p>Control variable (N x n_controls)</p> <code>du</code> <code>Variable</code> <p>Control error variable (N x n_controls)</p> <code>u_bar</code> <code>Parameter</code> <p>Previous SCP control parameter (N x n_controls)</p> <code>A_d</code> <code>Parameter</code> <p>Discretized state Jacobian parameter (N-1 x n_states*n_states)</p> <code>B_d</code> <code>Parameter</code> <p>Discretized control Jacobian parameter (N-1 x n_states*n_controls)</p> <code>C_d</code> <code>Parameter</code> <p>Discretized control Jacobian (next node) parameter</p> <code>x_prop</code> <code>Parameter</code> <p>Propagated state parameter (N-1 x n_states)</p> <code>nu</code> <code>Variable</code> <p>Virtual control variable (N-1 x n_states)</p> <code>g</code> <code>List[Parameter]</code> <p>List of constraint value parameters (one per nodal constraint)</p> <code>grad_g_x</code> <code>List[Parameter]</code> <p>List of state gradient parameters (one per nodal constraint)</p> <code>grad_g_u</code> <code>List[Parameter]</code> <p>List of control gradient parameters (one per nodal constraint)</p> <code>nu_vb</code> <code>List[Variable]</code> <p>List of virtual buffer variables (one per nodal constraint)</p> <code>g_cross</code> <code>List[Parameter]</code> <p>List of cross-node constraint value parameters</p> <code>grad_g_X_cross</code> <code>List[Parameter]</code> <p>List of trajectory state gradient parameters</p> <code>grad_g_U_cross</code> <code>List[Parameter]</code> <p>List of trajectory control gradient parameters</p> <code>nu_vb_cross</code> <code>List[Variable]</code> <p>List of cross-node virtual buffer variables</p> <code>S_x</code> <code>ndarray</code> <p>State scaling matrix (n_states x n_states)</p> <code>inv_S_x</code> <code>ndarray</code> <p>Inverse state scaling matrix</p> <code>c_x</code> <code>ndarray</code> <p>State offset vector (n_states,)</p> <code>S_u</code> <code>ndarray</code> <p>Control scaling matrix (n_controls x n_controls)</p> <code>inv_S_u</code> <code>ndarray</code> <p>Inverse control scaling matrix</p> <code>c_u</code> <code>ndarray</code> <p>Control offset vector (n_controls,)</p> <code>x_nonscaled</code> <code>List</code> <p>List of scaled state expressions at each node</p> <code>u_nonscaled</code> <code>List</code> <p>List of scaled control expressions at each node</p> <code>dx_nonscaled</code> <code>List</code> <p>List of scaled state error expressions at each node</p> <code>du_nonscaled</code> <code>List</code> <p>List of scaled control error expressions at each node</p> Source code in <code>openscvx/lowered/cvxpy_variables.py</code> <pre><code>@dataclass\nclass CVXPyVariables:\n    \"\"\"CVXPy variables and parameters for the optimal control problem.\n\n    This dataclass holds all CVXPy Variable and Parameter objects needed to\n    construct and solve the optimal control problem. It replaces the previous\n    untyped dictionary approach with a typed, self-documenting structure.\n\n    The variables are organized into logical groups:\n        - SCP weights: Parameters controlling trust region and penalty weights\n        - State: Variables and parameters for the state trajectory\n        - Control: Variables and parameters for the control trajectory\n        - Dynamics: Parameters for the discretized dynamics constraints\n        - Nodal constraints: Parameters for linearized non-convex nodal constraints\n        - Cross-node constraints: Parameters for linearized cross-node constraints\n        - Scaling: Affine scaling matrices and offset vectors\n        - Scaled expressions: CVXPy expressions for scaled state/control at each node\n\n    Attributes:\n        w_tr: Trust region weight parameter (scalar, nonneg)\n        lam_cost: Cost function weight parameter (scalar, nonneg)\n        lam_vc: Virtual control penalty weights (N-1 x n_states, nonneg)\n        lam_vb: Virtual buffer penalty weight (scalar, nonneg)\n\n        x: State variable (N x n_states)\n        dx: State error variable (N x n_states)\n        x_bar: Previous SCP state parameter (N x n_states)\n        x_init: Initial state parameter (n_states,)\n        x_term: Terminal state parameter (n_states,)\n\n        u: Control variable (N x n_controls)\n        du: Control error variable (N x n_controls)\n        u_bar: Previous SCP control parameter (N x n_controls)\n\n        A_d: Discretized state Jacobian parameter (N-1 x n_states*n_states)\n        B_d: Discretized control Jacobian parameter (N-1 x n_states*n_controls)\n        C_d: Discretized control Jacobian (next node) parameter\n        x_prop: Propagated state parameter (N-1 x n_states)\n        nu: Virtual control variable (N-1 x n_states)\n\n        g: List of constraint value parameters (one per nodal constraint)\n        grad_g_x: List of state gradient parameters (one per nodal constraint)\n        grad_g_u: List of control gradient parameters (one per nodal constraint)\n        nu_vb: List of virtual buffer variables (one per nodal constraint)\n\n        g_cross: List of cross-node constraint value parameters\n        grad_g_X_cross: List of trajectory state gradient parameters\n        grad_g_U_cross: List of trajectory control gradient parameters\n        nu_vb_cross: List of cross-node virtual buffer variables\n\n        S_x: State scaling matrix (n_states x n_states)\n        inv_S_x: Inverse state scaling matrix\n        c_x: State offset vector (n_states,)\n        S_u: Control scaling matrix (n_controls x n_controls)\n        inv_S_u: Inverse control scaling matrix\n        c_u: Control offset vector (n_controls,)\n\n        x_nonscaled: List of scaled state expressions at each node\n        u_nonscaled: List of scaled control expressions at each node\n        dx_nonscaled: List of scaled state error expressions at each node\n        du_nonscaled: List of scaled control error expressions at each node\n    \"\"\"\n\n    # SCP weight parameters\n    w_tr: \"cp.Parameter\"\n    lam_cost: \"cp.Parameter\"\n    lam_vc: \"cp.Parameter\"\n    lam_vb: \"cp.Parameter\"\n\n    # State variables and parameters\n    x: \"cp.Variable\"\n    dx: \"cp.Variable\"\n    x_bar: \"cp.Parameter\"\n    x_init: \"cp.Parameter\"\n    x_term: \"cp.Parameter\"\n\n    # Control variables and parameters\n    u: \"cp.Variable\"\n    du: \"cp.Variable\"\n    u_bar: \"cp.Parameter\"\n\n    # Dynamics discretization parameters\n    A_d: \"cp.Parameter\"\n    B_d: \"cp.Parameter\"\n    C_d: \"cp.Parameter\"\n    x_prop: \"cp.Parameter\"\n    nu: \"cp.Variable\"\n\n    # Nodal constraint linearization (lists, one per constraint)\n    g: List[\"cp.Parameter\"] = field(default_factory=list)\n    grad_g_x: List[\"cp.Parameter\"] = field(default_factory=list)\n    grad_g_u: List[\"cp.Parameter\"] = field(default_factory=list)\n    nu_vb: List[\"cp.Variable\"] = field(default_factory=list)\n\n    # Cross-node constraint linearization (lists, one per constraint)\n    g_cross: List[\"cp.Parameter\"] = field(default_factory=list)\n    grad_g_X_cross: List[\"cp.Parameter\"] = field(default_factory=list)\n    grad_g_U_cross: List[\"cp.Parameter\"] = field(default_factory=list)\n    nu_vb_cross: List[\"cp.Variable\"] = field(default_factory=list)\n\n    # Scaling matrices and offsets (numpy arrays)\n    S_x: np.ndarray = field(default_factory=lambda: np.array([]))\n    inv_S_x: np.ndarray = field(default_factory=lambda: np.array([]))\n    c_x: np.ndarray = field(default_factory=lambda: np.array([]))\n    S_u: np.ndarray = field(default_factory=lambda: np.array([]))\n    inv_S_u: np.ndarray = field(default_factory=lambda: np.array([]))\n    c_u: np.ndarray = field(default_factory=lambda: np.array([]))\n\n    # Scaled CVXPy expressions at each node (lists of length N)\n    x_nonscaled: List = field(default_factory=list)\n    u_nonscaled: List = field(default_factory=list)\n    dx_nonscaled: List = field(default_factory=list)\n    du_nonscaled: List = field(default_factory=list)\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.Dynamics","title":"<code>Dynamics</code>  <code>dataclass</code>","text":"<p>Dataclass to hold a system dynamics function and its Jacobians.</p> <p>This dataclass is used internally by openscvx to store the compiled dynamics function and its gradients after symbolic expressions are lowered to JAX. Users typically don't instantiate this class directly.</p> <p>Attributes:</p> Name Type Description <code>f</code> <code>Callable[[ndarray, ndarray], ndarray]</code> <p>Function defining the continuous time nonlinear system dynamics as x_dot = f(x, u, ...params). - x: 1D array (state at a single node), shape (n_x,) - u: 1D array (control at a single node), shape (n_u,) - Additional parameters: passed as keyword arguments with names   matching the parameter name plus an underscore (e.g., g_ for   Parameter('g')). If you use vectorized integration or batch evaluation, x and u may be 2D arrays (N, n_x) and (N, n_u).</p> <code>A</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of <code>f</code> w.r.t. <code>x</code>.</p> <code>B</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of <code>f</code> w.r.t. <code>u</code>.</p> Source code in <code>openscvx/lowered/dynamics.py</code> <pre><code>@dataclass\nclass Dynamics:\n    \"\"\"Dataclass to hold a system dynamics function and its Jacobians.\n\n    This dataclass is used internally by openscvx to store the compiled dynamics\n    function and its gradients after symbolic expressions are lowered to JAX.\n    Users typically don't instantiate this class directly.\n\n    Attributes:\n        f (Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]):\n            Function defining the continuous time nonlinear system dynamics\n            as x_dot = f(x, u, ...params).\n            - x: 1D array (state at a single node), shape (n_x,)\n            - u: 1D array (control at a single node), shape (n_u,)\n            - Additional parameters: passed as keyword arguments with names\n              matching the parameter name plus an underscore (e.g., g_ for\n              Parameter('g')).\n            If you use vectorized integration or batch evaluation, x and u\n            may be 2D arrays (N, n_x) and (N, n_u).\n        A (Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]]):\n            Jacobian of ``f`` w.r.t. ``x``.\n        B (Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]]):\n            Jacobian of ``f`` w.r.t. ``u``.\n    \"\"\"\n\n    f: Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]\n    A: Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]] = None\n    B: Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]] = None\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.LoweredCrossNodeConstraint","title":"<code>LoweredCrossNodeConstraint</code>  <code>dataclass</code>","text":"<p>Lowered cross-node constraint with trajectory-level evaluation.</p> <p>Unlike regular LoweredNodalConstraint which operates on single-node vectors and is vmapped across the trajectory, LoweredCrossNodeConstraint operates on full trajectory arrays to relate multiple nodes simultaneously.</p> <p>This is necessary for constraints like: - Rate limits: x[k] - x[k-1] &lt;= max_rate - Multi-step dependencies: x[k] = 2*x[k-1] - x[k-2] - Periodic boundaries: x[0] = x[N-1]</p> <p>The function signatures differ from LoweredNodalConstraint: - Regular: f(x, u, node, params) -&gt; scalar (vmapped to handle (N, n_x)) - Cross-node: f(X, U, params) -&gt; scalar (single constraint with fixed node indices)</p> <p>Attributes:</p> Name Type Description <code>func</code> <code>Callable[[ndarray, ndarray, dict], ndarray]</code> <p>Function (X, U, params) -&gt; scalar residual where X: (N, n_x), U: (N, n_u) Returns constraint residual following g(X, U) &lt;= 0 convention The constraint references fixed trajectory nodes (e.g., X[5] - X[4])</p> <code>grad_g_X</code> <code>Callable[[ndarray, ndarray, dict], ndarray]</code> <p>Function (X, U, params) -&gt; (N, n_x) Jacobian wrt full state trajectory This is typically sparse - most constraints only couple nearby nodes</p> <code>grad_g_U</code> <code>Callable[[ndarray, ndarray, dict], ndarray]</code> <p>Function (X, U, params) -&gt; (N, n_u) Jacobian wrt full control trajectory Often zero or very sparse for cross-node state constraints</p> Example <p>For rate constraint x[5] - x[4] &lt;= r:</p> <pre><code>func(X, U, params) -&gt; scalar residual\ngrad_g_X(X, U, params) -&gt; (N, n_x) sparse Jacobian\n    where grad_g_X[5, :] = \u2202g/\u2202x[5] (derivative wrt node 5)\n    and grad_g_X[4, :] = \u2202g/\u2202x[4] (derivative wrt node 4)\n    all other entries are zero\n</code></pre> Performance Note - Dense Jacobian Storage <p>The Jacobian matrices grad_g_X and grad_g_U are stored as DENSE arrays with shape (N, n_x) and (N, n_u), but most cross-node constraints only couple a small number of nearby nodes, making these matrices extremely sparse.</p> <p>For example, a rate limit constraint x[k] - x[k-1] &lt;= r only has non-zero Jacobian entries at positions [k, :] and [k-1, :]. All other N-2 rows are zero but still stored in memory.</p> <p>Memory impact for large problems: - A single constraint with N=100 nodes, n_x=10 states requires ~8KB for   grad_g_X (compared to ~160 bytes if sparse with 2 non-zero rows) - Multiple cross-node constraints multiply this overhead - May cause issues for N &gt; 1000 with many constraints</p> <p>Performance impact: - Slower autodiff (computes many zero gradients) - Inefficient constraint linearization in the SCP solver - Potential GPU memory limitations for very large problems</p> <p>The current implementation prioritizes simplicity and compatibility with JAX's autodiff over memory efficiency. Future versions may support sparse Jacobian formats (COO, CSR, or custom sparse representations) if this becomes a bottleneck in practice.</p> Source code in <code>openscvx/lowered/jax_constraints.py</code> <pre><code>@dataclass\nclass LoweredCrossNodeConstraint:\n    \"\"\"Lowered cross-node constraint with trajectory-level evaluation.\n\n    Unlike regular LoweredNodalConstraint which operates on single-node vectors\n    and is vmapped across the trajectory, LoweredCrossNodeConstraint operates\n    on full trajectory arrays to relate multiple nodes simultaneously.\n\n    This is necessary for constraints like:\n    - Rate limits: x[k] - x[k-1] &lt;= max_rate\n    - Multi-step dependencies: x[k] = 2*x[k-1] - x[k-2]\n    - Periodic boundaries: x[0] = x[N-1]\n\n    The function signatures differ from LoweredNodalConstraint:\n    - Regular: f(x, u, node, params) -&gt; scalar (vmapped to handle (N, n_x))\n    - Cross-node: f(X, U, params) -&gt; scalar (single constraint with fixed node indices)\n\n    Attributes:\n        func: Function (X, U, params) -&gt; scalar residual\n            where X: (N, n_x), U: (N, n_u)\n            Returns constraint residual following g(X, U) &lt;= 0 convention\n            The constraint references fixed trajectory nodes (e.g., X[5] - X[4])\n        grad_g_X: Function (X, U, params) -&gt; (N, n_x) Jacobian wrt full state trajectory\n            This is typically sparse - most constraints only couple nearby nodes\n        grad_g_U: Function (X, U, params) -&gt; (N, n_u) Jacobian wrt full control trajectory\n            Often zero or very sparse for cross-node state constraints\n\n    Example:\n        For rate constraint x[5] - x[4] &lt;= r:\n\n            func(X, U, params) -&gt; scalar residual\n            grad_g_X(X, U, params) -&gt; (N, n_x) sparse Jacobian\n                where grad_g_X[5, :] = \u2202g/\u2202x[5] (derivative wrt node 5)\n                and grad_g_X[4, :] = \u2202g/\u2202x[4] (derivative wrt node 4)\n                all other entries are zero\n\n    Performance Note - Dense Jacobian Storage:\n        The Jacobian matrices grad_g_X and grad_g_U are stored as DENSE arrays with\n        shape (N, n_x) and (N, n_u), but most cross-node constraints only couple a\n        small number of nearby nodes, making these matrices extremely sparse.\n\n        For example, a rate limit constraint x[k] - x[k-1] &lt;= r only has non-zero\n        Jacobian entries at positions [k, :] and [k-1, :]. All other N-2 rows are\n        zero but still stored in memory.\n\n        Memory impact for large problems:\n        - A single constraint with N=100 nodes, n_x=10 states requires ~8KB for\n          grad_g_X (compared to ~160 bytes if sparse with 2 non-zero rows)\n        - Multiple cross-node constraints multiply this overhead\n        - May cause issues for N &gt; 1000 with many constraints\n\n        Performance impact:\n        - Slower autodiff (computes many zero gradients)\n        - Inefficient constraint linearization in the SCP solver\n        - Potential GPU memory limitations for very large problems\n\n        The current implementation prioritizes simplicity and compatibility with\n        JAX's autodiff over memory efficiency. Future versions may support sparse\n        Jacobian formats (COO, CSR, or custom sparse representations) if this\n        becomes a bottleneck in practice.\n    \"\"\"\n\n    func: Callable[[jnp.ndarray, jnp.ndarray, dict], jnp.ndarray]\n    grad_g_X: Callable[[jnp.ndarray, jnp.ndarray, dict], jnp.ndarray]\n    grad_g_U: Callable[[jnp.ndarray, jnp.ndarray, dict], jnp.ndarray]\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.LoweredCvxpyConstraints","title":"<code>LoweredCvxpyConstraints</code>  <code>dataclass</code>","text":"<p>CVXPy-lowered convex constraints.</p> <p>Contains constraints that have been lowered to CVXPy constraint objects. These are added directly to the optimal control problem without linearization.</p> <p>Attributes:</p> Name Type Description <code>constraints</code> <code>list[Constraint]</code> <p>List of CVXPy constraint objects (cp.Constraint). Includes both nodal and cross-node convex constraints.</p> Source code in <code>openscvx/lowered/cvxpy_constraints.py</code> <pre><code>@dataclass\nclass LoweredCvxpyConstraints:\n    \"\"\"CVXPy-lowered convex constraints.\n\n    Contains constraints that have been lowered to CVXPy constraint objects.\n    These are added directly to the optimal control problem without\n    linearization.\n\n    Attributes:\n        constraints: List of CVXPy constraint objects (cp.Constraint).\n            Includes both nodal and cross-node convex constraints.\n    \"\"\"\n\n    constraints: list[\"cp.Constraint\"] = field(default_factory=list)\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.LoweredJaxConstraints","title":"<code>LoweredJaxConstraints</code>  <code>dataclass</code>","text":"<p>JAX-lowered non-convex constraints with gradient functions.</p> <p>Contains constraints that have been lowered to JAX callable functions with automatically computed gradients. These are used for linearization in the SCP (Sequential Convex Programming) loop.</p> <p>Attributes:</p> Name Type Description <code>nodal</code> <code>list[LoweredNodalConstraint]</code> <p>List of LoweredNodalConstraint objects. Each has <code>func</code>, <code>grad_g_x</code>, <code>grad_g_u</code> callables and <code>nodes</code> list.</p> <code>cross_node</code> <code>list[LoweredCrossNodeConstraint]</code> <p>List of LoweredCrossNodeConstraint objects. Each has <code>func</code>, <code>grad_g_X</code>, <code>grad_g_U</code> for trajectory-level constraints.</p> <code>ctcs</code> <code>list[CTCS]</code> <p>CTCS constraints (unchanged from input, not lowered here).</p> Source code in <code>openscvx/lowered/jax_constraints.py</code> <pre><code>@dataclass\nclass LoweredJaxConstraints:\n    \"\"\"JAX-lowered non-convex constraints with gradient functions.\n\n    Contains constraints that have been lowered to JAX callable functions\n    with automatically computed gradients. These are used for linearization\n    in the SCP (Sequential Convex Programming) loop.\n\n    Attributes:\n        nodal: List of LoweredNodalConstraint objects. Each has `func`,\n            `grad_g_x`, `grad_g_u` callables and `nodes` list.\n        cross_node: List of LoweredCrossNodeConstraint objects. Each has\n            `func`, `grad_g_X`, `grad_g_U` for trajectory-level constraints.\n        ctcs: CTCS constraints (unchanged from input, not lowered here).\n    \"\"\"\n\n    nodal: list[LoweredNodalConstraint] = field(default_factory=list)\n    cross_node: list[LoweredCrossNodeConstraint] = field(default_factory=list)\n    ctcs: list[\"CTCS\"] = field(default_factory=list)\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.LoweredNodalConstraint","title":"<code>LoweredNodalConstraint</code>  <code>dataclass</code>","text":"<p>Dataclass to hold a lowered symbolic constraint function and its jacobians.</p> <p>This is a simplified drop-in replacement for NodalConstraint that holds only the essential lowered JAX functions and their jacobians, without the complexity of convex/vectorized flags or post-initialization logic.</p> <p>Designed for use with symbolic expressions that have been lowered to JAX and will be linearized for sequential convex programming.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[ndarray, ndarray], ndarray]</code> <p>The lowered constraint function g(x, u, ...params) that returns constraint residuals. Should follow g(x, u) &lt;= 0 convention. - x: 1D array (state at a single node), shape (n_x,) - u: 1D array (control at a single node), shape (n_u,) - Additional parameters: passed as keyword arguments</p> required <code>grad_g_x</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of g w.r.t. x. If None, should be computed using jax.jacfwd.</p> <code>None</code> <code>grad_g_u</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of g w.r.t. u. If None, should be computed using jax.jacfwd.</p> <code>None</code> <code>nodes</code> <code>Optional[List[int]]</code> <p>List of node indices where this constraint applies. Set after lowering from NodalConstraint.</p> <code>None</code> Source code in <code>openscvx/lowered/jax_constraints.py</code> <pre><code>@dataclass\nclass LoweredNodalConstraint:\n    \"\"\"\n    Dataclass to hold a lowered symbolic constraint function and its jacobians.\n\n    This is a simplified drop-in replacement for NodalConstraint that holds\n    only the essential lowered JAX functions and their jacobians, without\n    the complexity of convex/vectorized flags or post-initialization logic.\n\n    Designed for use with symbolic expressions that have been lowered to JAX\n    and will be linearized for sequential convex programming.\n\n    Args:\n        func (Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]):\n            The lowered constraint function g(x, u, ...params) that returns\n            constraint residuals. Should follow g(x, u) &lt;= 0 convention.\n            - x: 1D array (state at a single node), shape (n_x,)\n            - u: 1D array (control at a single node), shape (n_u,)\n            - Additional parameters: passed as keyword arguments\n\n        grad_g_x (Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]]):\n            Jacobian of g w.r.t. x. If None, should be computed using jax.jacfwd.\n\n        grad_g_u (Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]]):\n            Jacobian of g w.r.t. u. If None, should be computed using jax.jacfwd.\n\n        nodes (Optional[List[int]]): List of node indices where this constraint applies.\n            Set after lowering from NodalConstraint.\n    \"\"\"\n\n    func: Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]\n    grad_g_x: Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]] = None\n    grad_g_u: Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]] = None\n    nodes: Optional[List[int]] = None\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.LoweredProblem","title":"<code>LoweredProblem</code>  <code>dataclass</code>","text":"<p>Container for all outputs from symbolic problem lowering.</p> <p>This dataclass holds all the results of lowering symbolic expressions to executable JAX and CVXPy code. It provides a clean, typed interface for accessing the various components needed for optimization.</p> <p>Attributes:</p> Name Type Description <code>dynamics</code> <code>Dynamics</code> <p>Optimization dynamics with fields f, A, B (JAX functions)</p> <code>dynamics_prop</code> <code>Dynamics</code> <p>Propagation dynamics with fields f, A, B</p> <code>jax_constraints</code> <code>LoweredJaxConstraints</code> <p>Non-convex constraints lowered to JAX with gradients</p> <code>cvxpy_constraints</code> <code>LoweredCvxpyConstraints</code> <p>Convex constraints lowered to CVXPy</p> <code>x_unified</code> <code>UnifiedState</code> <p>Aggregated optimization state interface</p> <code>u_unified</code> <code>UnifiedControl</code> <p>Aggregated optimization control interface</p> <code>x_prop_unified</code> <code>UnifiedState</code> <p>Aggregated propagation state interface</p> <code>ocp_vars</code> <code>CVXPyVariables</code> <p>Typed CVXPy variables and parameters for OCP construction</p> <code>cvxpy_params</code> <code>Dict[str, Parameter]</code> <p>Dict mapping user parameter names to CVXPy Parameter objects</p> Example <p>After lowering a symbolic problem::</p> <pre><code>lowered = lower_symbolic_problem(\n    dynamics_aug=dynamics,\n    states_aug=states,\n    controls_aug=controls,\n    constraints=constraint_set,\n    parameters=params,\n    N=50,\n)\n\n# Access components\ndx_dt = lowered.dynamics.f(x, u, node, params)\njacobian_A = lowered.dynamics.A(x, u, node, params)\n\n# Use CVXPy objects\nocp = OptimalControlProblem(settings, lowered)\n</code></pre> Source code in <code>openscvx/lowered/problem.py</code> <pre><code>@dataclass\nclass LoweredProblem:\n    \"\"\"Container for all outputs from symbolic problem lowering.\n\n    This dataclass holds all the results of lowering symbolic expressions\n    to executable JAX and CVXPy code. It provides a clean, typed interface\n    for accessing the various components needed for optimization.\n\n    Attributes:\n        dynamics: Optimization dynamics with fields f, A, B (JAX functions)\n        dynamics_prop: Propagation dynamics with fields f, A, B\n        jax_constraints: Non-convex constraints lowered to JAX with gradients\n        cvxpy_constraints: Convex constraints lowered to CVXPy\n        x_unified: Aggregated optimization state interface\n        u_unified: Aggregated optimization control interface\n        x_prop_unified: Aggregated propagation state interface\n        ocp_vars: Typed CVXPy variables and parameters for OCP construction\n        cvxpy_params: Dict mapping user parameter names to CVXPy Parameter objects\n\n    Example:\n        After lowering a symbolic problem::\n\n            lowered = lower_symbolic_problem(\n                dynamics_aug=dynamics,\n                states_aug=states,\n                controls_aug=controls,\n                constraints=constraint_set,\n                parameters=params,\n                N=50,\n            )\n\n            # Access components\n            dx_dt = lowered.dynamics.f(x, u, node, params)\n            jacobian_A = lowered.dynamics.A(x, u, node, params)\n\n            # Use CVXPy objects\n            ocp = OptimalControlProblem(settings, lowered)\n    \"\"\"\n\n    # JAX dynamics\n    dynamics: Dynamics\n    dynamics_prop: Dynamics\n\n    # Lowered constraints (separate types for JAX vs CVXPy)\n    jax_constraints: LoweredJaxConstraints\n    cvxpy_constraints: LoweredCvxpyConstraints\n\n    # Unified interfaces\n    x_unified: UnifiedState\n    u_unified: UnifiedControl\n    x_prop_unified: UnifiedState\n\n    # CVXPy objects\n    ocp_vars: CVXPyVariables\n    cvxpy_params: Dict[str, \"cp.Parameter\"]\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.ParameterDict","title":"<code>ParameterDict</code>","text":"<p>               Bases: <code>dict</code></p> <p>Dictionary that syncs to both internal _parameters dict and CVXPy parameters.</p> This allows users to naturally update parameters like <p>problem.parameters[\"obs_radius\"] = 2.0</p> <p>Changes automatically propagate to: 1. Internal _parameters dict (plain dict for JAX) 2. CVXPy parameters (for optimization)</p> Source code in <code>openscvx/lowered/parameters.py</code> <pre><code>class ParameterDict(dict):\n    \"\"\"Dictionary that syncs to both internal _parameters dict and CVXPy parameters.\n\n    This allows users to naturally update parameters like:\n        problem.parameters[\"obs_radius\"] = 2.0\n\n    Changes automatically propagate to:\n    1. Internal _parameters dict (plain dict for JAX)\n    2. CVXPy parameters (for optimization)\n    \"\"\"\n\n    def __init__(self, problem, internal_dict, *args, **kwargs):\n        self._problem = problem\n        self._internal_dict = internal_dict  # Reference to plain dict for JAX\n        super().__init__()\n        # Initialize with float enforcement by using __setitem__\n        if args:\n            other = args[0]\n            if hasattr(other, \"items\"):\n                for key, value in other.items():\n                    self[key] = value\n            else:\n                for key, value in other:\n                    self[key] = value\n        for key, value in kwargs.items():\n            self[key] = value\n\n    def __setitem__(self, key, value):\n        # Enforce float dtype to prevent int/float mismatch bugs\n        value = np.asarray(value, dtype=float)\n        super().__setitem__(key, value)\n        # Sync to internal dict for JAX\n        self._internal_dict[key] = value\n        # Sync to CVXPy if it exists\n        lowered = getattr(self._problem, \"_lowered\", None)\n        if lowered is not None and key in lowered.cvxpy_params:\n            lowered.cvxpy_params[key].value = value\n\n    def update(self, other=None, **kwargs):\n        \"\"\"Update multiple parameters and sync to internal dict and CVXPy.\"\"\"\n        if other is not None:\n            if hasattr(other, \"items\"):\n                for key, value in other.items():\n                    self[key] = value\n            else:\n                for key, value in other:\n                    self[key] = value\n        for key, value in kwargs.items():\n            self[key] = value\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.ParameterDict.update","title":"<code>update(other=None, **kwargs)</code>","text":"<p>Update multiple parameters and sync to internal dict and CVXPy.</p> Source code in <code>openscvx/lowered/parameters.py</code> <pre><code>def update(self, other=None, **kwargs):\n    \"\"\"Update multiple parameters and sync to internal dict and CVXPy.\"\"\"\n    if other is not None:\n        if hasattr(other, \"items\"):\n            for key, value in other.items():\n                self[key] = value\n        else:\n            for key, value in other:\n                self[key] = value\n    for key, value in kwargs.items():\n        self[key] = value\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.UnifiedControl","title":"<code>UnifiedControl</code>  <code>dataclass</code>","text":"<p>Unified control vector aggregating multiple Control objects.</p> <p>UnifiedControl is a drop-in replacement for individual Control objects that holds aggregated data from multiple Control instances. It maintains compatibility with optimization infrastructure while providing access to individual control components through slicing.</p> <p>The unified control separates user-defined \"true\" controls from augmented controls added internally (e.g., for time dilation). This separation allows clean access to physical control inputs while supporting advanced features.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the unified control vector</p> <code>shape</code> <code>tuple</code> <p>Combined shape (total_dim,) of all aggregated controls</p> <code>min</code> <code>ndarray</code> <p>Lower bounds for all control variables, shape (total_dim,)</p> <code>max</code> <code>ndarray</code> <p>Upper bounds for all control variables, shape (total_dim,)</p> <code>guess</code> <code>ndarray</code> <p>Initial guess trajectory, shape (num_nodes, total_dim)</p> <code>_true_dim</code> <code>int</code> <p>Number of user-defined control dimensions (excludes augmented)</p> <code>_true_slice</code> <code>slice</code> <p>Slice for extracting true controls from unified vector</p> <code>_augmented_slice</code> <code>slice</code> <p>Slice for extracting augmented controls</p> <code>time_dilation_slice</code> <code>Optional[slice]</code> <p>Slice for time dilation control, if present</p> Properties <p>true: Returns UnifiedControl view containing only true (user-defined) controls augmented: Returns UnifiedControl view containing only augmented controls</p> Example <p>Creating a unified control from multiple Control objects::</p> <pre><code>from openscvx.symbolic.unified import unify_controls\n\nthrust = ox.Control(\"thrust\", shape=(3,), min=0, max=10)\ntorque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n\nunified = unify_controls([thrust, torque], name=\"u\")\nprint(unified.shape)        # (6,)\nprint(unified.min)          # [0, 0, 0, -1, -1, -1]\nprint(unified.true.shape)   # (6,) - all are true controls\nprint(unified.augmented.shape)  # (0,) - no augmented controls\n</code></pre> <p>Appending controls dynamically::</p> <pre><code>unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.0)  # Add scalar control\nprint(unified.shape)  # (1,)\n</code></pre> See Also <ul> <li>unify_controls(): Factory function for creating UnifiedControl from Control list</li> <li>Control: Individual symbolic control variable</li> <li>UnifiedState: Analogous unified state vector</li> </ul> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>@dataclass\nclass UnifiedControl:\n    \"\"\"Unified control vector aggregating multiple Control objects.\n\n    UnifiedControl is a drop-in replacement for individual Control objects that holds\n    aggregated data from multiple Control instances. It maintains compatibility with\n    optimization infrastructure while providing access to individual control components\n    through slicing.\n\n    The unified control separates user-defined \"true\" controls from augmented controls\n    added internally (e.g., for time dilation). This separation allows clean access to\n    physical control inputs while supporting advanced features.\n\n    Attributes:\n        name (str): Name identifier for the unified control vector\n        shape (tuple): Combined shape (total_dim,) of all aggregated controls\n        min (np.ndarray): Lower bounds for all control variables, shape (total_dim,)\n        max (np.ndarray): Upper bounds for all control variables, shape (total_dim,)\n        guess (np.ndarray): Initial guess trajectory, shape (num_nodes, total_dim)\n        _true_dim (int): Number of user-defined control dimensions (excludes augmented)\n        _true_slice (slice): Slice for extracting true controls from unified vector\n        _augmented_slice (slice): Slice for extracting augmented controls\n        time_dilation_slice (Optional[slice]): Slice for time dilation control, if present\n\n    Properties:\n        true: Returns UnifiedControl view containing only true (user-defined) controls\n        augmented: Returns UnifiedControl view containing only augmented controls\n\n    Example:\n        Creating a unified control from multiple Control objects::\n\n            from openscvx.symbolic.unified import unify_controls\n\n            thrust = ox.Control(\"thrust\", shape=(3,), min=0, max=10)\n            torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n\n            unified = unify_controls([thrust, torque], name=\"u\")\n            print(unified.shape)        # (6,)\n            print(unified.min)          # [0, 0, 0, -1, -1, -1]\n            print(unified.true.shape)   # (6,) - all are true controls\n            print(unified.augmented.shape)  # (0,) - no augmented controls\n\n        Appending controls dynamically::\n\n            unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.0)  # Add scalar control\n            print(unified.shape)  # (1,)\n\n    See Also:\n        - unify_controls(): Factory function for creating UnifiedControl from Control list\n        - Control: Individual symbolic control variable\n        - UnifiedState: Analogous unified state vector\n    \"\"\"\n\n    name: str\n    shape: tuple\n    min: Optional[np.ndarray] = None\n    max: Optional[np.ndarray] = None\n    guess: Optional[np.ndarray] = None\n    _true_dim: int = 0\n    _true_slice: Optional[slice] = None\n    _augmented_slice: Optional[slice] = None\n    time_dilation_slice: Optional[slice] = None  # Slice for time dilation control\n    scaling_min: Optional[np.ndarray] = None  # Scaling minimum bounds for unified control\n    scaling_max: Optional[np.ndarray] = None  # Scaling maximum bounds for unified control\n\n    def __post_init__(self):\n        \"\"\"Initialize slices after dataclass creation.\"\"\"\n        if self._true_slice is None:\n            self._true_slice = slice(0, self._true_dim)\n        if self._augmented_slice is None:\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    @property\n    def true(self) -&gt; \"UnifiedControl\":\n        \"\"\"Get the true (user-defined) control variables.\n\n        Returns a view of the unified control containing only user-defined controls,\n        excluding internal augmented controls added for time dilation, etc.\n\n        Returns:\n            UnifiedControl: Sliced view containing only true control variables\n\n        Example:\n            Get true user defined controls::\n\n                unified = unify_controls([thrust, torque, time_dilation], name=\"u\")\n                true_controls = unified.true  # Only thrust and torque\n        \"\"\"\n        return self[self._true_slice]\n\n    @property\n    def augmented(self) -&gt; \"UnifiedControl\":\n        \"\"\"Get the augmented (internal) control variables.\n\n        Returns a view of the unified control containing only augmented controls\n        added internally by the optimization framework (e.g., time dilation control).\n\n        Returns:\n            UnifiedControl: Sliced view containing only augmented control variables\n\n        Example:\n            Get augmented controls::\n\n                unified = unify_controls([thrust, time_dilation], name=\"u\")\n                aug_controls = unified.augmented  # Only time dilation\n        \"\"\"\n        return self[self._augmented_slice]\n\n    def append(\n        self,\n        other: \"Optional[Control | UnifiedControl]\" = None,\n        *,\n        min=-np.inf,\n        max=np.inf,\n        guess=0.0,\n        augmented=False,\n    ):\n        \"\"\"Append another control or create a new control variable.\n\n        This method allows dynamic extension of the unified control, either by appending\n        another Control/UnifiedControl object or by creating a new scalar control variable\n        with specified properties. Modifies the unified control in-place.\n\n        Args:\n            other (Optional[Control | UnifiedControl]): Control object to append. If None,\n                creates a new scalar control variable with properties from keyword args.\n            min (float): Lower bound for new scalar control (default: -inf)\n            max (float): Upper bound for new scalar control (default: inf)\n            guess (float): Initial guess value for new scalar control (default: 0.0)\n            augmented (bool): Whether the appended control is augmented (internal) rather\n                than true (user-defined). Affects _true_dim tracking. Default: False\n\n        Returns:\n            None: Modifies the unified control in-place\n\n        Example:\n            Appending a Control object::\n\n                unified = unify_controls([thrust], name=\"u\")\n                torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n                unified.append(torque)\n                print(unified.shape)  # (6,) - thrust (3) + torque (3)\n\n            Creating new scalar control variables::\n\n                unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\n                unified.append(min=-1, max=1, guess=0.0)  # Add scalar control\n                print(unified.shape)  # (1,)\n        \"\"\"\n        # Import here to avoid circular imports at module level\n        from openscvx.symbolic.expr.control import Control\n\n        if isinstance(other, (Control, UnifiedControl)):\n            # Append another control object\n            new_shape = (self.shape[0] + other.shape[0],)\n\n            # Update bounds\n            if self.min is not None and other.min is not None:\n                new_min = np.concatenate([self.min, other.min])\n            else:\n                new_min = self.min\n\n            if self.max is not None and other.max is not None:\n                new_max = np.concatenate([self.max, other.max])\n            else:\n                new_max = self.max\n\n            # Update guess\n            if self.guess is not None and other.guess is not None:\n                new_guess = np.concatenate([self.guess, other.guess], axis=1)\n            else:\n                new_guess = self.guess\n\n            # Update true dimension\n            if not augmented:\n                new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n            else:\n                new_true_dim = self._true_dim\n\n            # Update all attributes in place\n            self.shape = new_shape\n            self.min = new_min\n            self.max = new_max\n            self.guess = new_guess\n            self._true_dim = new_true_dim\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n        else:\n            # Create a single new variable\n            new_shape = (self.shape[0] + 1,)\n\n            # Extend arrays\n            if self.min is not None:\n                self.min = np.concatenate([self.min, np.array([min])])\n            if self.max is not None:\n                self.max = np.concatenate([self.max, np.array([max])])\n            if self.guess is not None:\n                guess_arr = np.full((self.guess.shape[0], 1), guess)\n                self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n\n            # Update dimensions\n            self.shape = new_shape\n            if not augmented:\n                self._true_dim += 1\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    def __getitem__(self, idx):\n        \"\"\"Get a subset of the unified control variables.\n\n        Enables slicing of the unified control to extract subsets of control variables.\n        Returns a new UnifiedControl containing only the sliced dimensions.\n\n        Args:\n            idx (slice): Slice object specifying which control dimensions to extract.\n                Only simple slices with step=1 are supported.\n\n        Returns:\n            UnifiedControl: New unified control containing only the sliced dimensions\n\n        Raises:\n            NotImplementedError: If idx is not a slice, or if step != 1\n\n        Example:\n            Generate unified control object::\n\n                unified = unify_controls([thrust, torque], name=\"u\")\n\n            thrust has shape (3,), torque has shape (3,)::\n\n                first_three = unified[0:3]  # Extract thrust only\n                print(first_three.shape)  # (3,)\n\n        Note:\n            The sliced control maintains all properties (bounds, guesses, etc.) for\n            the selected dimensions. The _true_dim is recalculated based on which\n            dimensions fall within the original true control range.\n        \"\"\"\n        if isinstance(idx, slice):\n            start, stop, step = idx.indices(self.shape[0])\n            if step != 1:\n                raise NotImplementedError(\"Step slicing not supported\")\n\n            new_shape = (stop - start,)\n            new_name = f\"{self.name}[{start}:{stop}]\"\n\n            # Slice all arrays\n            new_min = self.min[idx] if self.min is not None else None\n            new_max = self.max[idx] if self.max is not None else None\n            new_guess = self.guess[:, idx] if self.guess is not None else None\n\n            # Calculate new true dimension\n            new_true_dim = max(0, min(stop, self._true_dim) - max(start, 0))\n\n            return UnifiedControl(\n                name=new_name,\n                shape=new_shape,\n                min=new_min,\n                max=new_max,\n                guess=new_guess,\n                _true_dim=new_true_dim,\n                _true_slice=slice(0, new_true_dim),\n                _augmented_slice=slice(new_true_dim, new_shape[0]),\n            )\n        else:\n            raise NotImplementedError(\"Only slice indexing is supported\")\n\n    def __repr__(self):\n        \"\"\"String representation of the UnifiedControl object.\"\"\"\n        return f\"UnifiedControl('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.UnifiedControl.augmented","title":"<code>augmented: UnifiedControl</code>  <code>property</code>","text":"<p>Get the augmented (internal) control variables.</p> <p>Returns a view of the unified control containing only augmented controls added internally by the optimization framework (e.g., time dilation control).</p> <p>Returns:</p> Name Type Description <code>UnifiedControl</code> <code>UnifiedControl</code> <p>Sliced view containing only augmented control variables</p> Example <p>Get augmented controls::</p> <pre><code>unified = unify_controls([thrust, time_dilation], name=\"u\")\naug_controls = unified.augmented  # Only time dilation\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.UnifiedControl.true","title":"<code>true: UnifiedControl</code>  <code>property</code>","text":"<p>Get the true (user-defined) control variables.</p> <p>Returns a view of the unified control containing only user-defined controls, excluding internal augmented controls added for time dilation, etc.</p> <p>Returns:</p> Name Type Description <code>UnifiedControl</code> <code>UnifiedControl</code> <p>Sliced view containing only true control variables</p> Example <p>Get true user defined controls::</p> <pre><code>unified = unify_controls([thrust, torque, time_dilation], name=\"u\")\ntrue_controls = unified.true  # Only thrust and torque\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.UnifiedControl.append","title":"<code>append(other: Optional[Control | UnifiedControl] = None, *, min=-np.inf, max=np.inf, guess=0.0, augmented=False)</code>","text":"<p>Append another control or create a new control variable.</p> <p>This method allows dynamic extension of the unified control, either by appending another Control/UnifiedControl object or by creating a new scalar control variable with specified properties. Modifies the unified control in-place.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Optional[Control | UnifiedControl]</code> <p>Control object to append. If None, creates a new scalar control variable with properties from keyword args.</p> <code>None</code> <code>min</code> <code>float</code> <p>Lower bound for new scalar control (default: -inf)</p> <code>-inf</code> <code>max</code> <code>float</code> <p>Upper bound for new scalar control (default: inf)</p> <code>inf</code> <code>guess</code> <code>float</code> <p>Initial guess value for new scalar control (default: 0.0)</p> <code>0.0</code> <code>augmented</code> <code>bool</code> <p>Whether the appended control is augmented (internal) rather than true (user-defined). Affects _true_dim tracking. Default: False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <p>Modifies the unified control in-place</p> Example <p>Appending a Control object::</p> <pre><code>unified = unify_controls([thrust], name=\"u\")\ntorque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\nunified.append(torque)\nprint(unified.shape)  # (6,) - thrust (3) + torque (3)\n</code></pre> <p>Creating new scalar control variables::</p> <pre><code>unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.0)  # Add scalar control\nprint(unified.shape)  # (1,)\n</code></pre> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>def append(\n    self,\n    other: \"Optional[Control | UnifiedControl]\" = None,\n    *,\n    min=-np.inf,\n    max=np.inf,\n    guess=0.0,\n    augmented=False,\n):\n    \"\"\"Append another control or create a new control variable.\n\n    This method allows dynamic extension of the unified control, either by appending\n    another Control/UnifiedControl object or by creating a new scalar control variable\n    with specified properties. Modifies the unified control in-place.\n\n    Args:\n        other (Optional[Control | UnifiedControl]): Control object to append. If None,\n            creates a new scalar control variable with properties from keyword args.\n        min (float): Lower bound for new scalar control (default: -inf)\n        max (float): Upper bound for new scalar control (default: inf)\n        guess (float): Initial guess value for new scalar control (default: 0.0)\n        augmented (bool): Whether the appended control is augmented (internal) rather\n            than true (user-defined). Affects _true_dim tracking. Default: False\n\n    Returns:\n        None: Modifies the unified control in-place\n\n    Example:\n        Appending a Control object::\n\n            unified = unify_controls([thrust], name=\"u\")\n            torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n            unified.append(torque)\n            print(unified.shape)  # (6,) - thrust (3) + torque (3)\n\n        Creating new scalar control variables::\n\n            unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.0)  # Add scalar control\n            print(unified.shape)  # (1,)\n    \"\"\"\n    # Import here to avoid circular imports at module level\n    from openscvx.symbolic.expr.control import Control\n\n    if isinstance(other, (Control, UnifiedControl)):\n        # Append another control object\n        new_shape = (self.shape[0] + other.shape[0],)\n\n        # Update bounds\n        if self.min is not None and other.min is not None:\n            new_min = np.concatenate([self.min, other.min])\n        else:\n            new_min = self.min\n\n        if self.max is not None and other.max is not None:\n            new_max = np.concatenate([self.max, other.max])\n        else:\n            new_max = self.max\n\n        # Update guess\n        if self.guess is not None and other.guess is not None:\n            new_guess = np.concatenate([self.guess, other.guess], axis=1)\n        else:\n            new_guess = self.guess\n\n        # Update true dimension\n        if not augmented:\n            new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n        else:\n            new_true_dim = self._true_dim\n\n        # Update all attributes in place\n        self.shape = new_shape\n        self.min = new_min\n        self.max = new_max\n        self.guess = new_guess\n        self._true_dim = new_true_dim\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    else:\n        # Create a single new variable\n        new_shape = (self.shape[0] + 1,)\n\n        # Extend arrays\n        if self.min is not None:\n            self.min = np.concatenate([self.min, np.array([min])])\n        if self.max is not None:\n            self.max = np.concatenate([self.max, np.array([max])])\n        if self.guess is not None:\n            guess_arr = np.full((self.guess.shape[0], 1), guess)\n            self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n\n        # Update dimensions\n        self.shape = new_shape\n        if not augmented:\n            self._true_dim += 1\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.UnifiedState","title":"<code>UnifiedState</code>  <code>dataclass</code>","text":"<p>Unified state vector aggregating multiple State objects.</p> <p>UnifiedState is a drop-in replacement for individual State objects that holds aggregated data from multiple State instances. It maintains compatibility with optimization infrastructure while providing access to individual state components through slicing.</p> <p>The unified state separates user-defined \"true\" states from augmented states added internally (e.g., for CTCS constraints or time variables). This separation allows clean access to physical states while supporting advanced features.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the unified state vector</p> <code>shape</code> <code>tuple</code> <p>Combined shape (total_dim,) of all aggregated states</p> <code>min</code> <code>ndarray</code> <p>Lower bounds for all state variables, shape (total_dim,)</p> <code>max</code> <code>ndarray</code> <p>Upper bounds for all state variables, shape (total_dim,)</p> <code>guess</code> <code>ndarray</code> <p>Initial guess trajectory, shape (num_nodes, total_dim)</p> <code>initial</code> <code>ndarray</code> <p>Initial boundary conditions, shape (total_dim,)</p> <code>final</code> <code>ndarray</code> <p>Final boundary conditions, shape (total_dim,)</p> <code>_initial</code> <code>ndarray</code> <p>Internal initial values, shape (total_dim,)</p> <code>_final</code> <code>ndarray</code> <p>Internal final values, shape (total_dim,)</p> <code>initial_type</code> <code>ndarray</code> <p>Boundary condition types at t0 (\"Fix\" or \"Free\"), shape (total_dim,), dtype=object</p> <code>final_type</code> <code>ndarray</code> <p>Boundary condition types at tf (\"Fix\" or \"Free\"), shape (total_dim,), dtype=object</p> <code>_true_dim</code> <code>int</code> <p>Number of user-defined state dimensions (excludes augmented)</p> <code>_true_slice</code> <code>slice</code> <p>Slice for extracting true states from unified vector</p> <code>_augmented_slice</code> <code>slice</code> <p>Slice for extracting augmented states</p> <code>time_slice</code> <code>Optional[slice]</code> <p>Slice for time state variable, if present</p> <code>ctcs_slice</code> <code>Optional[slice]</code> <p>Slice for CTCS augmented states, if present</p> Properties <p>true: Returns UnifiedState view containing only true (user-defined) states augmented: Returns UnifiedState view containing only augmented states</p> Example <p>Creating a unified state from multiple State objects::</p> <pre><code>from openscvx.symbolic.unified import unify_states\n\nposition = ox.State(\"pos\", shape=(3,), min=-10, max=10)\nvelocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n\nunified = unify_states([position, velocity], name=\"x\")\nprint(unified.shape)        # (6,)\nprint(unified.min)          # [-10, -10, -10, -5, -5, -5]\nprint(unified.true.shape)   # (6,) - all are true states\nprint(unified.augmented.shape)  # (0,) - no augmented states\n</code></pre> <p>Appending states dynamically::</p> <pre><code>unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.5)  # Add scalar state\nprint(unified.shape)  # (1,)\n</code></pre> See Also <ul> <li>unify_states(): Factory function for creating UnifiedState from State list</li> <li>State: Individual symbolic state variable</li> <li>UnifiedControl: Analogous unified control vector</li> </ul> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>@dataclass\nclass UnifiedState:\n    \"\"\"Unified state vector aggregating multiple State objects.\n\n    UnifiedState is a drop-in replacement for individual State objects that holds\n    aggregated data from multiple State instances. It maintains compatibility with\n    optimization infrastructure while providing access to individual state components\n    through slicing.\n\n    The unified state separates user-defined \"true\" states from augmented states\n    added internally (e.g., for CTCS constraints or time variables). This separation\n    allows clean access to physical states while supporting advanced features.\n\n    Attributes:\n        name (str): Name identifier for the unified state vector\n        shape (tuple): Combined shape (total_dim,) of all aggregated states\n        min (np.ndarray): Lower bounds for all state variables, shape (total_dim,)\n        max (np.ndarray): Upper bounds for all state variables, shape (total_dim,)\n        guess (np.ndarray): Initial guess trajectory, shape (num_nodes, total_dim)\n        initial (np.ndarray): Initial boundary conditions, shape (total_dim,)\n        final (np.ndarray): Final boundary conditions, shape (total_dim,)\n        _initial (np.ndarray): Internal initial values, shape (total_dim,)\n        _final (np.ndarray): Internal final values, shape (total_dim,)\n        initial_type (np.ndarray): Boundary condition types at t0 (\"Fix\" or \"Free\"),\n            shape (total_dim,), dtype=object\n        final_type (np.ndarray): Boundary condition types at tf (\"Fix\" or \"Free\"),\n            shape (total_dim,), dtype=object\n        _true_dim (int): Number of user-defined state dimensions (excludes augmented)\n        _true_slice (slice): Slice for extracting true states from unified vector\n        _augmented_slice (slice): Slice for extracting augmented states\n        time_slice (Optional[slice]): Slice for time state variable, if present\n        ctcs_slice (Optional[slice]): Slice for CTCS augmented states, if present\n\n    Properties:\n        true: Returns UnifiedState view containing only true (user-defined) states\n        augmented: Returns UnifiedState view containing only augmented states\n\n    Example:\n        Creating a unified state from multiple State objects::\n\n            from openscvx.symbolic.unified import unify_states\n\n            position = ox.State(\"pos\", shape=(3,), min=-10, max=10)\n            velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n\n            unified = unify_states([position, velocity], name=\"x\")\n            print(unified.shape)        # (6,)\n            print(unified.min)          # [-10, -10, -10, -5, -5, -5]\n            print(unified.true.shape)   # (6,) - all are true states\n            print(unified.augmented.shape)  # (0,) - no augmented states\n\n        Appending states dynamically::\n\n            unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.5)  # Add scalar state\n            print(unified.shape)  # (1,)\n\n    See Also:\n        - unify_states(): Factory function for creating UnifiedState from State list\n        - State: Individual symbolic state variable\n        - UnifiedControl: Analogous unified control vector\n    \"\"\"\n\n    name: str\n    shape: tuple\n    min: Optional[np.ndarray] = None\n    max: Optional[np.ndarray] = None\n    guess: Optional[np.ndarray] = None\n    initial: Optional[np.ndarray] = None\n    final: Optional[np.ndarray] = None\n    _initial: Optional[np.ndarray] = None\n    _final: Optional[np.ndarray] = None\n    initial_type: Optional[np.ndarray] = None\n    final_type: Optional[np.ndarray] = None\n    _true_dim: int = 0\n    _true_slice: Optional[slice] = None\n    _augmented_slice: Optional[slice] = None\n    time_slice: Optional[slice] = None  # Slice for time state\n    ctcs_slice: Optional[slice] = None  # Slice for CTCS augmented states\n    scaling_min: Optional[np.ndarray] = None  # Scaling minimum bounds for unified state\n    scaling_max: Optional[np.ndarray] = None  # Scaling maximum bounds for unified state\n\n    def __post_init__(self):\n        \"\"\"Initialize slices after dataclass creation.\"\"\"\n        if self._true_slice is None:\n            self._true_slice = slice(0, self._true_dim)\n        if self._augmented_slice is None:\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    @property\n    def true(self) -&gt; \"UnifiedState\":\n        \"\"\"Get the true (user-defined) state variables.\n\n        Returns a view of the unified state containing only user-defined states,\n        excluding internal augmented states added for CTCS, time, etc.\n\n        Returns:\n            UnifiedState: Sliced view containing only true state variables\n\n        Example:\n            Get true user-defined state::\n\n                unified = unify_states([position, velocity, ctcs_aug], name=\"x\")\n                true_states = unified.true  # Only position and velocity\n                true_states.shape  # (6,) if position and velocity are 3D each\n        \"\"\"\n        return self[self._true_slice]\n\n    @property\n    def augmented(self) -&gt; \"UnifiedState\":\n        \"\"\"Get the augmented (internal) state variables.\n\n        Returns a view of the unified state containing only augmented states\n        added internally by the optimization framework (e.g., CTCS penalty states,\n        time variables).\n\n        Returns:\n            UnifiedState: Sliced view containing only augmented state variables\n\n        Example:\n            Get augmented state::\n\n                unified = unify_states([position, ctcs_aug], name=\"x\")\n                aug_states = unified.augmented  # Only CTCS states\n        \"\"\"\n        return self[self._augmented_slice]\n\n    def append(\n        self,\n        other: \"Optional[State | UnifiedState]\" = None,\n        *,\n        min=-np.inf,\n        max=np.inf,\n        guess=0.0,\n        initial=0.0,\n        final=0.0,\n        augmented=False,\n    ):\n        \"\"\"Append another state or create a new state variable.\n\n        This method allows dynamic extension of the unified state, either by appending\n        another State/UnifiedState object or by creating a new scalar state variable\n        with specified properties. Modifies the unified state in-place.\n\n        Args:\n            other (Optional[State | UnifiedState]): State object to append. If None,\n                creates a new scalar state variable with properties from keyword args.\n            min (float): Lower bound for new scalar state (default: -inf)\n            max (float): Upper bound for new scalar state (default: inf)\n            guess (float): Initial guess value for new scalar state (default: 0.0)\n            initial (float): Initial boundary condition for new scalar state (default: 0.0)\n            final (float): Final boundary condition for new scalar state (default: 0.0)\n            augmented (bool): Whether the appended state is augmented (internal) rather\n                than true (user-defined). Affects _true_dim tracking. Default: False\n\n        Returns:\n            None: Modifies the unified state in-place\n\n        Example:\n            Appending a State object::\n\n                unified = unify_states([position], name=\"x\")\n                velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n                unified.append(velocity)\n                print(unified.shape)  # (6,) - position (3) + velocity (3)\n\n            Creating new scalar state variables::\n\n                unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\n                unified.append(min=-1, max=1, guess=0.5)  # Add scalar state\n                unified.append(min=-2, max=2, augmented=True)  # Add augmented state\n                print(unified.shape)  # (2,)\n                print(unified._true_dim)  # 1 (only first is true)\n\n        Note:\n            Maintains the invariant that true states appear before augmented states\n            in the unified vector. When appending augmented states, they are added\n            to the end but don't increment _true_dim.\n        \"\"\"\n        # Import here to avoid circular imports at module level\n        from openscvx.symbolic.expr.state import State\n\n        if isinstance(other, (State, UnifiedState)):\n            # Append another state object\n            new_shape = (self.shape[0] + other.shape[0],)\n\n            # Update bounds\n            if self.min is not None and other.min is not None:\n                new_min = np.concatenate([self.min, other.min])\n            else:\n                new_min = self.min\n\n            if self.max is not None and other.max is not None:\n                new_max = np.concatenate([self.max, other.max])\n            else:\n                new_max = self.max\n\n            # Update guess\n            if self.guess is not None and other.guess is not None:\n                new_guess = np.concatenate([self.guess, other.guess], axis=1)\n            else:\n                new_guess = self.guess\n\n            # Update initial/final conditions\n            if self.initial is not None and other.initial is not None:\n                new_initial = np.concatenate([self.initial, other.initial])\n            else:\n                new_initial = self.initial\n\n            if self.final is not None and other.final is not None:\n                new_final = np.concatenate([self.final, other.final])\n            else:\n                new_final = self.final\n\n            # Update internal arrays\n            if self._initial is not None and other._initial is not None:\n                new__initial = np.concatenate([self._initial, other._initial])\n            else:\n                new__initial = self._initial\n\n            if self._final is not None and other._final is not None:\n                new__final = np.concatenate([self._final, other._final])\n            else:\n                new__final = self._final\n\n            # Update types\n            if self.initial_type is not None and other.initial_type is not None:\n                new_initial_type = np.concatenate([self.initial_type, other.initial_type])\n            else:\n                new_initial_type = self.initial_type\n\n            if self.final_type is not None and other.final_type is not None:\n                new_final_type = np.concatenate([self.final_type, other.final_type])\n            else:\n                new_final_type = self.final_type\n\n            # Update true dimension\n            if not augmented:\n                new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n            else:\n                new_true_dim = self._true_dim\n\n            # Update all attributes in place\n            self.shape = new_shape\n            self.min = new_min\n            self.max = new_max\n            self.guess = new_guess\n            self.initial = new_initial\n            self.final = new_final\n            self._initial = new__initial\n            self._final = new__final\n            self.initial_type = new_initial_type\n            self.final_type = new_final_type\n            self._true_dim = new_true_dim\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n        else:\n            # Create a single new variable\n            new_shape = (self.shape[0] + 1,)\n\n            # Extend arrays\n            if self.min is not None:\n                self.min = np.concatenate([self.min, np.array([min])])\n            if self.max is not None:\n                self.max = np.concatenate([self.max, np.array([max])])\n            if self.guess is not None:\n                guess_arr = np.full((self.guess.shape[0], 1), guess)\n                self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n            if self.initial is not None:\n                self.initial = np.concatenate([self.initial, np.array([initial])])\n            if self.final is not None:\n                self.final = np.concatenate([self.final, np.array([final])])\n            if self._initial is not None:\n                self._initial = np.concatenate([self._initial, np.array([initial])])\n            if self._final is not None:\n                self._final = np.concatenate([self._final, np.array([final])])\n            if self.initial_type is not None:\n                self.initial_type = np.concatenate(\n                    [self.initial_type, np.array([\"Fix\"], dtype=object)]\n                )\n            if self.final_type is not None:\n                self.final_type = np.concatenate([self.final_type, np.array([\"Fix\"], dtype=object)])\n\n            # Update dimensions\n            self.shape = new_shape\n            if not augmented:\n                self._true_dim += 1\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    def __getitem__(self, idx):\n        \"\"\"Get a subset of the unified state variables.\n\n        Enables slicing of the unified state to extract subsets of state variables.\n        Returns a new UnifiedState containing only the sliced dimensions.\n\n        Args:\n            idx (slice): Slice object specifying which state dimensions to extract.\n                Only simple slices with step=1 are supported.\n\n        Returns:\n            UnifiedState: New unified state containing only the sliced dimensions\n\n        Raises:\n            NotImplementedError: If idx is not a slice, or if step != 1\n\n        Example:\n            Generate unified state object::\n\n                unified = unify_states([position, velocity], name=\"x\")\n\n            position has shape (3,), velocity has shape (3,)::\n\n                first_three = unified[0:3]  # Extract position only\n                print(first_three.shape)  # (3,)\n                last_three = unified[3:6]  # Extract velocity only\n                print(last_three.shape)  # (3,)\n\n        Note:\n            The sliced state maintains all properties (bounds, guesses, etc.) for\n            the selected dimensions. The _true_dim is recalculated based on which\n            dimensions fall within the original true state range.\n        \"\"\"\n        if isinstance(idx, slice):\n            start, stop, step = idx.indices(self.shape[0])\n            if step != 1:\n                raise NotImplementedError(\"Step slicing not supported\")\n\n            new_shape = (stop - start,)\n            new_name = f\"{self.name}[{start}:{stop}]\"\n\n            # Slice all arrays\n            new_min = self.min[idx] if self.min is not None else None\n            new_max = self.max[idx] if self.max is not None else None\n            new_guess = self.guess[:, idx] if self.guess is not None else None\n            new_initial = self.initial[idx] if self.initial is not None else None\n            new_final = self.final[idx] if self.final is not None else None\n            new__initial = self._initial[idx] if self._initial is not None else None\n            new__final = self._final[idx] if self._final is not None else None\n            new_initial_type = self.initial_type[idx] if self.initial_type is not None else None\n            new_final_type = self.final_type[idx] if self.final_type is not None else None\n\n            # Calculate new true dimension\n            new_true_dim = max(0, min(stop, self._true_dim) - max(start, 0))\n\n            return UnifiedState(\n                name=new_name,\n                shape=new_shape,\n                min=new_min,\n                max=new_max,\n                guess=new_guess,\n                initial=new_initial,\n                final=new_final,\n                _initial=new__initial,\n                _final=new__final,\n                initial_type=new_initial_type,\n                final_type=new_final_type,\n                _true_dim=new_true_dim,\n                _true_slice=slice(0, new_true_dim),\n                _augmented_slice=slice(new_true_dim, new_shape[0]),\n            )\n        else:\n            raise NotImplementedError(\"Only slice indexing is supported\")\n\n    def __repr__(self):\n        \"\"\"String representation of the UnifiedState object.\"\"\"\n        return f\"UnifiedState('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.UnifiedState.augmented","title":"<code>augmented: UnifiedState</code>  <code>property</code>","text":"<p>Get the augmented (internal) state variables.</p> <p>Returns a view of the unified state containing only augmented states added internally by the optimization framework (e.g., CTCS penalty states, time variables).</p> <p>Returns:</p> Name Type Description <code>UnifiedState</code> <code>UnifiedState</code> <p>Sliced view containing only augmented state variables</p> Example <p>Get augmented state::</p> <pre><code>unified = unify_states([position, ctcs_aug], name=\"x\")\naug_states = unified.augmented  # Only CTCS states\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.UnifiedState.true","title":"<code>true: UnifiedState</code>  <code>property</code>","text":"<p>Get the true (user-defined) state variables.</p> <p>Returns a view of the unified state containing only user-defined states, excluding internal augmented states added for CTCS, time, etc.</p> <p>Returns:</p> Name Type Description <code>UnifiedState</code> <code>UnifiedState</code> <p>Sliced view containing only true state variables</p> Example <p>Get true user-defined state::</p> <pre><code>unified = unify_states([position, velocity, ctcs_aug], name=\"x\")\ntrue_states = unified.true  # Only position and velocity\ntrue_states.shape  # (6,) if position and velocity are 3D each\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.UnifiedState.append","title":"<code>append(other: Optional[State | UnifiedState] = None, *, min=-np.inf, max=np.inf, guess=0.0, initial=0.0, final=0.0, augmented=False)</code>","text":"<p>Append another state or create a new state variable.</p> <p>This method allows dynamic extension of the unified state, either by appending another State/UnifiedState object or by creating a new scalar state variable with specified properties. Modifies the unified state in-place.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Optional[State | UnifiedState]</code> <p>State object to append. If None, creates a new scalar state variable with properties from keyword args.</p> <code>None</code> <code>min</code> <code>float</code> <p>Lower bound for new scalar state (default: -inf)</p> <code>-inf</code> <code>max</code> <code>float</code> <p>Upper bound for new scalar state (default: inf)</p> <code>inf</code> <code>guess</code> <code>float</code> <p>Initial guess value for new scalar state (default: 0.0)</p> <code>0.0</code> <code>initial</code> <code>float</code> <p>Initial boundary condition for new scalar state (default: 0.0)</p> <code>0.0</code> <code>final</code> <code>float</code> <p>Final boundary condition for new scalar state (default: 0.0)</p> <code>0.0</code> <code>augmented</code> <code>bool</code> <p>Whether the appended state is augmented (internal) rather than true (user-defined). Affects _true_dim tracking. Default: False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <p>Modifies the unified state in-place</p> Example <p>Appending a State object::</p> <pre><code>unified = unify_states([position], name=\"x\")\nvelocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\nunified.append(velocity)\nprint(unified.shape)  # (6,) - position (3) + velocity (3)\n</code></pre> <p>Creating new scalar state variables::</p> <pre><code>unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.5)  # Add scalar state\nunified.append(min=-2, max=2, augmented=True)  # Add augmented state\nprint(unified.shape)  # (2,)\nprint(unified._true_dim)  # 1 (only first is true)\n</code></pre> Note <p>Maintains the invariant that true states appear before augmented states in the unified vector. When appending augmented states, they are added to the end but don't increment _true_dim.</p> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>def append(\n    self,\n    other: \"Optional[State | UnifiedState]\" = None,\n    *,\n    min=-np.inf,\n    max=np.inf,\n    guess=0.0,\n    initial=0.0,\n    final=0.0,\n    augmented=False,\n):\n    \"\"\"Append another state or create a new state variable.\n\n    This method allows dynamic extension of the unified state, either by appending\n    another State/UnifiedState object or by creating a new scalar state variable\n    with specified properties. Modifies the unified state in-place.\n\n    Args:\n        other (Optional[State | UnifiedState]): State object to append. If None,\n            creates a new scalar state variable with properties from keyword args.\n        min (float): Lower bound for new scalar state (default: -inf)\n        max (float): Upper bound for new scalar state (default: inf)\n        guess (float): Initial guess value for new scalar state (default: 0.0)\n        initial (float): Initial boundary condition for new scalar state (default: 0.0)\n        final (float): Final boundary condition for new scalar state (default: 0.0)\n        augmented (bool): Whether the appended state is augmented (internal) rather\n            than true (user-defined). Affects _true_dim tracking. Default: False\n\n    Returns:\n        None: Modifies the unified state in-place\n\n    Example:\n        Appending a State object::\n\n            unified = unify_states([position], name=\"x\")\n            velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n            unified.append(velocity)\n            print(unified.shape)  # (6,) - position (3) + velocity (3)\n\n        Creating new scalar state variables::\n\n            unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.5)  # Add scalar state\n            unified.append(min=-2, max=2, augmented=True)  # Add augmented state\n            print(unified.shape)  # (2,)\n            print(unified._true_dim)  # 1 (only first is true)\n\n    Note:\n        Maintains the invariant that true states appear before augmented states\n        in the unified vector. When appending augmented states, they are added\n        to the end but don't increment _true_dim.\n    \"\"\"\n    # Import here to avoid circular imports at module level\n    from openscvx.symbolic.expr.state import State\n\n    if isinstance(other, (State, UnifiedState)):\n        # Append another state object\n        new_shape = (self.shape[0] + other.shape[0],)\n\n        # Update bounds\n        if self.min is not None and other.min is not None:\n            new_min = np.concatenate([self.min, other.min])\n        else:\n            new_min = self.min\n\n        if self.max is not None and other.max is not None:\n            new_max = np.concatenate([self.max, other.max])\n        else:\n            new_max = self.max\n\n        # Update guess\n        if self.guess is not None and other.guess is not None:\n            new_guess = np.concatenate([self.guess, other.guess], axis=1)\n        else:\n            new_guess = self.guess\n\n        # Update initial/final conditions\n        if self.initial is not None and other.initial is not None:\n            new_initial = np.concatenate([self.initial, other.initial])\n        else:\n            new_initial = self.initial\n\n        if self.final is not None and other.final is not None:\n            new_final = np.concatenate([self.final, other.final])\n        else:\n            new_final = self.final\n\n        # Update internal arrays\n        if self._initial is not None and other._initial is not None:\n            new__initial = np.concatenate([self._initial, other._initial])\n        else:\n            new__initial = self._initial\n\n        if self._final is not None and other._final is not None:\n            new__final = np.concatenate([self._final, other._final])\n        else:\n            new__final = self._final\n\n        # Update types\n        if self.initial_type is not None and other.initial_type is not None:\n            new_initial_type = np.concatenate([self.initial_type, other.initial_type])\n        else:\n            new_initial_type = self.initial_type\n\n        if self.final_type is not None and other.final_type is not None:\n            new_final_type = np.concatenate([self.final_type, other.final_type])\n        else:\n            new_final_type = self.final_type\n\n        # Update true dimension\n        if not augmented:\n            new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n        else:\n            new_true_dim = self._true_dim\n\n        # Update all attributes in place\n        self.shape = new_shape\n        self.min = new_min\n        self.max = new_max\n        self.guess = new_guess\n        self.initial = new_initial\n        self.final = new_final\n        self._initial = new__initial\n        self._final = new__final\n        self.initial_type = new_initial_type\n        self.final_type = new_final_type\n        self._true_dim = new_true_dim\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    else:\n        # Create a single new variable\n        new_shape = (self.shape[0] + 1,)\n\n        # Extend arrays\n        if self.min is not None:\n            self.min = np.concatenate([self.min, np.array([min])])\n        if self.max is not None:\n            self.max = np.concatenate([self.max, np.array([max])])\n        if self.guess is not None:\n            guess_arr = np.full((self.guess.shape[0], 1), guess)\n            self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n        if self.initial is not None:\n            self.initial = np.concatenate([self.initial, np.array([initial])])\n        if self.final is not None:\n            self.final = np.concatenate([self.final, np.array([final])])\n        if self._initial is not None:\n            self._initial = np.concatenate([self._initial, np.array([initial])])\n        if self._final is not None:\n            self._final = np.concatenate([self._final, np.array([final])])\n        if self.initial_type is not None:\n            self.initial_type = np.concatenate(\n                [self.initial_type, np.array([\"Fix\"], dtype=object)]\n            )\n        if self.final_type is not None:\n            self.final_type = np.concatenate([self.final_type, np.array([\"Fix\"], dtype=object)])\n\n        # Update dimensions\n        self.shape = new_shape\n        if not augmented:\n            self._true_dim += 1\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n</code></pre>"},{"location":"reference/lowered/cvxpy_constraints/","title":"cvxpy_constraints","text":"<p>CVXPy-lowered constraint dataclass.</p>"},{"location":"reference/lowered/cvxpy_constraints/#openscvx.lowered.cvxpy_constraints.LoweredCvxpyConstraints","title":"<code>LoweredCvxpyConstraints</code>  <code>dataclass</code>","text":"<p>CVXPy-lowered convex constraints.</p> <p>Contains constraints that have been lowered to CVXPy constraint objects. These are added directly to the optimal control problem without linearization.</p> <p>Attributes:</p> Name Type Description <code>constraints</code> <code>list[Constraint]</code> <p>List of CVXPy constraint objects (cp.Constraint). Includes both nodal and cross-node convex constraints.</p> Source code in <code>openscvx/lowered/cvxpy_constraints.py</code> <pre><code>@dataclass\nclass LoweredCvxpyConstraints:\n    \"\"\"CVXPy-lowered convex constraints.\n\n    Contains constraints that have been lowered to CVXPy constraint objects.\n    These are added directly to the optimal control problem without\n    linearization.\n\n    Attributes:\n        constraints: List of CVXPy constraint objects (cp.Constraint).\n            Includes both nodal and cross-node convex constraints.\n    \"\"\"\n\n    constraints: list[\"cp.Constraint\"] = field(default_factory=list)\n</code></pre>"},{"location":"reference/lowered/cvxpy_variables/","title":"cvxpy_variables","text":"<p>CVXPy variables and parameters dataclass for the optimal control problem.</p>"},{"location":"reference/lowered/cvxpy_variables/#openscvx.lowered.cvxpy_variables.CVXPyVariables","title":"<code>CVXPyVariables</code>  <code>dataclass</code>","text":"<p>CVXPy variables and parameters for the optimal control problem.</p> <p>This dataclass holds all CVXPy Variable and Parameter objects needed to construct and solve the optimal control problem. It replaces the previous untyped dictionary approach with a typed, self-documenting structure.</p> The variables are organized into logical groups <ul> <li>SCP weights: Parameters controlling trust region and penalty weights</li> <li>State: Variables and parameters for the state trajectory</li> <li>Control: Variables and parameters for the control trajectory</li> <li>Dynamics: Parameters for the discretized dynamics constraints</li> <li>Nodal constraints: Parameters for linearized non-convex nodal constraints</li> <li>Cross-node constraints: Parameters for linearized cross-node constraints</li> <li>Scaling: Affine scaling matrices and offset vectors</li> <li>Scaled expressions: CVXPy expressions for scaled state/control at each node</li> </ul> <p>Attributes:</p> Name Type Description <code>w_tr</code> <code>Parameter</code> <p>Trust region weight parameter (scalar, nonneg)</p> <code>lam_cost</code> <code>Parameter</code> <p>Cost function weight parameter (scalar, nonneg)</p> <code>lam_vc</code> <code>Parameter</code> <p>Virtual control penalty weights (N-1 x n_states, nonneg)</p> <code>lam_vb</code> <code>Parameter</code> <p>Virtual buffer penalty weight (scalar, nonneg)</p> <code>x</code> <code>Variable</code> <p>State variable (N x n_states)</p> <code>dx</code> <code>Variable</code> <p>State error variable (N x n_states)</p> <code>x_bar</code> <code>Parameter</code> <p>Previous SCP state parameter (N x n_states)</p> <code>x_init</code> <code>Parameter</code> <p>Initial state parameter (n_states,)</p> <code>x_term</code> <code>Parameter</code> <p>Terminal state parameter (n_states,)</p> <code>u</code> <code>Variable</code> <p>Control variable (N x n_controls)</p> <code>du</code> <code>Variable</code> <p>Control error variable (N x n_controls)</p> <code>u_bar</code> <code>Parameter</code> <p>Previous SCP control parameter (N x n_controls)</p> <code>A_d</code> <code>Parameter</code> <p>Discretized state Jacobian parameter (N-1 x n_states*n_states)</p> <code>B_d</code> <code>Parameter</code> <p>Discretized control Jacobian parameter (N-1 x n_states*n_controls)</p> <code>C_d</code> <code>Parameter</code> <p>Discretized control Jacobian (next node) parameter</p> <code>x_prop</code> <code>Parameter</code> <p>Propagated state parameter (N-1 x n_states)</p> <code>nu</code> <code>Variable</code> <p>Virtual control variable (N-1 x n_states)</p> <code>g</code> <code>List[Parameter]</code> <p>List of constraint value parameters (one per nodal constraint)</p> <code>grad_g_x</code> <code>List[Parameter]</code> <p>List of state gradient parameters (one per nodal constraint)</p> <code>grad_g_u</code> <code>List[Parameter]</code> <p>List of control gradient parameters (one per nodal constraint)</p> <code>nu_vb</code> <code>List[Variable]</code> <p>List of virtual buffer variables (one per nodal constraint)</p> <code>g_cross</code> <code>List[Parameter]</code> <p>List of cross-node constraint value parameters</p> <code>grad_g_X_cross</code> <code>List[Parameter]</code> <p>List of trajectory state gradient parameters</p> <code>grad_g_U_cross</code> <code>List[Parameter]</code> <p>List of trajectory control gradient parameters</p> <code>nu_vb_cross</code> <code>List[Variable]</code> <p>List of cross-node virtual buffer variables</p> <code>S_x</code> <code>ndarray</code> <p>State scaling matrix (n_states x n_states)</p> <code>inv_S_x</code> <code>ndarray</code> <p>Inverse state scaling matrix</p> <code>c_x</code> <code>ndarray</code> <p>State offset vector (n_states,)</p> <code>S_u</code> <code>ndarray</code> <p>Control scaling matrix (n_controls x n_controls)</p> <code>inv_S_u</code> <code>ndarray</code> <p>Inverse control scaling matrix</p> <code>c_u</code> <code>ndarray</code> <p>Control offset vector (n_controls,)</p> <code>x_nonscaled</code> <code>List</code> <p>List of scaled state expressions at each node</p> <code>u_nonscaled</code> <code>List</code> <p>List of scaled control expressions at each node</p> <code>dx_nonscaled</code> <code>List</code> <p>List of scaled state error expressions at each node</p> <code>du_nonscaled</code> <code>List</code> <p>List of scaled control error expressions at each node</p> Source code in <code>openscvx/lowered/cvxpy_variables.py</code> <pre><code>@dataclass\nclass CVXPyVariables:\n    \"\"\"CVXPy variables and parameters for the optimal control problem.\n\n    This dataclass holds all CVXPy Variable and Parameter objects needed to\n    construct and solve the optimal control problem. It replaces the previous\n    untyped dictionary approach with a typed, self-documenting structure.\n\n    The variables are organized into logical groups:\n        - SCP weights: Parameters controlling trust region and penalty weights\n        - State: Variables and parameters for the state trajectory\n        - Control: Variables and parameters for the control trajectory\n        - Dynamics: Parameters for the discretized dynamics constraints\n        - Nodal constraints: Parameters for linearized non-convex nodal constraints\n        - Cross-node constraints: Parameters for linearized cross-node constraints\n        - Scaling: Affine scaling matrices and offset vectors\n        - Scaled expressions: CVXPy expressions for scaled state/control at each node\n\n    Attributes:\n        w_tr: Trust region weight parameter (scalar, nonneg)\n        lam_cost: Cost function weight parameter (scalar, nonneg)\n        lam_vc: Virtual control penalty weights (N-1 x n_states, nonneg)\n        lam_vb: Virtual buffer penalty weight (scalar, nonneg)\n\n        x: State variable (N x n_states)\n        dx: State error variable (N x n_states)\n        x_bar: Previous SCP state parameter (N x n_states)\n        x_init: Initial state parameter (n_states,)\n        x_term: Terminal state parameter (n_states,)\n\n        u: Control variable (N x n_controls)\n        du: Control error variable (N x n_controls)\n        u_bar: Previous SCP control parameter (N x n_controls)\n\n        A_d: Discretized state Jacobian parameter (N-1 x n_states*n_states)\n        B_d: Discretized control Jacobian parameter (N-1 x n_states*n_controls)\n        C_d: Discretized control Jacobian (next node) parameter\n        x_prop: Propagated state parameter (N-1 x n_states)\n        nu: Virtual control variable (N-1 x n_states)\n\n        g: List of constraint value parameters (one per nodal constraint)\n        grad_g_x: List of state gradient parameters (one per nodal constraint)\n        grad_g_u: List of control gradient parameters (one per nodal constraint)\n        nu_vb: List of virtual buffer variables (one per nodal constraint)\n\n        g_cross: List of cross-node constraint value parameters\n        grad_g_X_cross: List of trajectory state gradient parameters\n        grad_g_U_cross: List of trajectory control gradient parameters\n        nu_vb_cross: List of cross-node virtual buffer variables\n\n        S_x: State scaling matrix (n_states x n_states)\n        inv_S_x: Inverse state scaling matrix\n        c_x: State offset vector (n_states,)\n        S_u: Control scaling matrix (n_controls x n_controls)\n        inv_S_u: Inverse control scaling matrix\n        c_u: Control offset vector (n_controls,)\n\n        x_nonscaled: List of scaled state expressions at each node\n        u_nonscaled: List of scaled control expressions at each node\n        dx_nonscaled: List of scaled state error expressions at each node\n        du_nonscaled: List of scaled control error expressions at each node\n    \"\"\"\n\n    # SCP weight parameters\n    w_tr: \"cp.Parameter\"\n    lam_cost: \"cp.Parameter\"\n    lam_vc: \"cp.Parameter\"\n    lam_vb: \"cp.Parameter\"\n\n    # State variables and parameters\n    x: \"cp.Variable\"\n    dx: \"cp.Variable\"\n    x_bar: \"cp.Parameter\"\n    x_init: \"cp.Parameter\"\n    x_term: \"cp.Parameter\"\n\n    # Control variables and parameters\n    u: \"cp.Variable\"\n    du: \"cp.Variable\"\n    u_bar: \"cp.Parameter\"\n\n    # Dynamics discretization parameters\n    A_d: \"cp.Parameter\"\n    B_d: \"cp.Parameter\"\n    C_d: \"cp.Parameter\"\n    x_prop: \"cp.Parameter\"\n    nu: \"cp.Variable\"\n\n    # Nodal constraint linearization (lists, one per constraint)\n    g: List[\"cp.Parameter\"] = field(default_factory=list)\n    grad_g_x: List[\"cp.Parameter\"] = field(default_factory=list)\n    grad_g_u: List[\"cp.Parameter\"] = field(default_factory=list)\n    nu_vb: List[\"cp.Variable\"] = field(default_factory=list)\n\n    # Cross-node constraint linearization (lists, one per constraint)\n    g_cross: List[\"cp.Parameter\"] = field(default_factory=list)\n    grad_g_X_cross: List[\"cp.Parameter\"] = field(default_factory=list)\n    grad_g_U_cross: List[\"cp.Parameter\"] = field(default_factory=list)\n    nu_vb_cross: List[\"cp.Variable\"] = field(default_factory=list)\n\n    # Scaling matrices and offsets (numpy arrays)\n    S_x: np.ndarray = field(default_factory=lambda: np.array([]))\n    inv_S_x: np.ndarray = field(default_factory=lambda: np.array([]))\n    c_x: np.ndarray = field(default_factory=lambda: np.array([]))\n    S_u: np.ndarray = field(default_factory=lambda: np.array([]))\n    inv_S_u: np.ndarray = field(default_factory=lambda: np.array([]))\n    c_u: np.ndarray = field(default_factory=lambda: np.array([]))\n\n    # Scaled CVXPy expressions at each node (lists of length N)\n    x_nonscaled: List = field(default_factory=list)\n    u_nonscaled: List = field(default_factory=list)\n    dx_nonscaled: List = field(default_factory=list)\n    du_nonscaled: List = field(default_factory=list)\n</code></pre>"},{"location":"reference/lowered/dynamics/","title":"dynamics","text":""},{"location":"reference/lowered/dynamics/#openscvx.lowered.dynamics.Dynamics","title":"<code>Dynamics</code>  <code>dataclass</code>","text":"<p>Dataclass to hold a system dynamics function and its Jacobians.</p> <p>This dataclass is used internally by openscvx to store the compiled dynamics function and its gradients after symbolic expressions are lowered to JAX. Users typically don't instantiate this class directly.</p> <p>Attributes:</p> Name Type Description <code>f</code> <code>Callable[[ndarray, ndarray], ndarray]</code> <p>Function defining the continuous time nonlinear system dynamics as x_dot = f(x, u, ...params). - x: 1D array (state at a single node), shape (n_x,) - u: 1D array (control at a single node), shape (n_u,) - Additional parameters: passed as keyword arguments with names   matching the parameter name plus an underscore (e.g., g_ for   Parameter('g')). If you use vectorized integration or batch evaluation, x and u may be 2D arrays (N, n_x) and (N, n_u).</p> <code>A</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of <code>f</code> w.r.t. <code>x</code>.</p> <code>B</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of <code>f</code> w.r.t. <code>u</code>.</p> Source code in <code>openscvx/lowered/dynamics.py</code> <pre><code>@dataclass\nclass Dynamics:\n    \"\"\"Dataclass to hold a system dynamics function and its Jacobians.\n\n    This dataclass is used internally by openscvx to store the compiled dynamics\n    function and its gradients after symbolic expressions are lowered to JAX.\n    Users typically don't instantiate this class directly.\n\n    Attributes:\n        f (Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]):\n            Function defining the continuous time nonlinear system dynamics\n            as x_dot = f(x, u, ...params).\n            - x: 1D array (state at a single node), shape (n_x,)\n            - u: 1D array (control at a single node), shape (n_u,)\n            - Additional parameters: passed as keyword arguments with names\n              matching the parameter name plus an underscore (e.g., g_ for\n              Parameter('g')).\n            If you use vectorized integration or batch evaluation, x and u\n            may be 2D arrays (N, n_x) and (N, n_u).\n        A (Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]]):\n            Jacobian of ``f`` w.r.t. ``x``.\n        B (Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]]):\n            Jacobian of ``f`` w.r.t. ``u``.\n    \"\"\"\n\n    f: Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]\n    A: Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]] = None\n    B: Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]] = None\n</code></pre>"},{"location":"reference/lowered/jax_constraints/","title":"jax_constraints","text":"<p>JAX-lowered constraint dataclass.</p>"},{"location":"reference/lowered/jax_constraints/#openscvx.lowered.jax_constraints.LoweredCrossNodeConstraint","title":"<code>LoweredCrossNodeConstraint</code>  <code>dataclass</code>","text":"<p>Lowered cross-node constraint with trajectory-level evaluation.</p> <p>Unlike regular LoweredNodalConstraint which operates on single-node vectors and is vmapped across the trajectory, LoweredCrossNodeConstraint operates on full trajectory arrays to relate multiple nodes simultaneously.</p> <p>This is necessary for constraints like: - Rate limits: x[k] - x[k-1] &lt;= max_rate - Multi-step dependencies: x[k] = 2*x[k-1] - x[k-2] - Periodic boundaries: x[0] = x[N-1]</p> <p>The function signatures differ from LoweredNodalConstraint: - Regular: f(x, u, node, params) -&gt; scalar (vmapped to handle (N, n_x)) - Cross-node: f(X, U, params) -&gt; scalar (single constraint with fixed node indices)</p> <p>Attributes:</p> Name Type Description <code>func</code> <code>Callable[[ndarray, ndarray, dict], ndarray]</code> <p>Function (X, U, params) -&gt; scalar residual where X: (N, n_x), U: (N, n_u) Returns constraint residual following g(X, U) &lt;= 0 convention The constraint references fixed trajectory nodes (e.g., X[5] - X[4])</p> <code>grad_g_X</code> <code>Callable[[ndarray, ndarray, dict], ndarray]</code> <p>Function (X, U, params) -&gt; (N, n_x) Jacobian wrt full state trajectory This is typically sparse - most constraints only couple nearby nodes</p> <code>grad_g_U</code> <code>Callable[[ndarray, ndarray, dict], ndarray]</code> <p>Function (X, U, params) -&gt; (N, n_u) Jacobian wrt full control trajectory Often zero or very sparse for cross-node state constraints</p> Example <p>For rate constraint x[5] - x[4] &lt;= r:</p> <pre><code>func(X, U, params) -&gt; scalar residual\ngrad_g_X(X, U, params) -&gt; (N, n_x) sparse Jacobian\n    where grad_g_X[5, :] = \u2202g/\u2202x[5] (derivative wrt node 5)\n    and grad_g_X[4, :] = \u2202g/\u2202x[4] (derivative wrt node 4)\n    all other entries are zero\n</code></pre> Performance Note - Dense Jacobian Storage <p>The Jacobian matrices grad_g_X and grad_g_U are stored as DENSE arrays with shape (N, n_x) and (N, n_u), but most cross-node constraints only couple a small number of nearby nodes, making these matrices extremely sparse.</p> <p>For example, a rate limit constraint x[k] - x[k-1] &lt;= r only has non-zero Jacobian entries at positions [k, :] and [k-1, :]. All other N-2 rows are zero but still stored in memory.</p> <p>Memory impact for large problems: - A single constraint with N=100 nodes, n_x=10 states requires ~8KB for   grad_g_X (compared to ~160 bytes if sparse with 2 non-zero rows) - Multiple cross-node constraints multiply this overhead - May cause issues for N &gt; 1000 with many constraints</p> <p>Performance impact: - Slower autodiff (computes many zero gradients) - Inefficient constraint linearization in the SCP solver - Potential GPU memory limitations for very large problems</p> <p>The current implementation prioritizes simplicity and compatibility with JAX's autodiff over memory efficiency. Future versions may support sparse Jacobian formats (COO, CSR, or custom sparse representations) if this becomes a bottleneck in practice.</p> Source code in <code>openscvx/lowered/jax_constraints.py</code> <pre><code>@dataclass\nclass LoweredCrossNodeConstraint:\n    \"\"\"Lowered cross-node constraint with trajectory-level evaluation.\n\n    Unlike regular LoweredNodalConstraint which operates on single-node vectors\n    and is vmapped across the trajectory, LoweredCrossNodeConstraint operates\n    on full trajectory arrays to relate multiple nodes simultaneously.\n\n    This is necessary for constraints like:\n    - Rate limits: x[k] - x[k-1] &lt;= max_rate\n    - Multi-step dependencies: x[k] = 2*x[k-1] - x[k-2]\n    - Periodic boundaries: x[0] = x[N-1]\n\n    The function signatures differ from LoweredNodalConstraint:\n    - Regular: f(x, u, node, params) -&gt; scalar (vmapped to handle (N, n_x))\n    - Cross-node: f(X, U, params) -&gt; scalar (single constraint with fixed node indices)\n\n    Attributes:\n        func: Function (X, U, params) -&gt; scalar residual\n            where X: (N, n_x), U: (N, n_u)\n            Returns constraint residual following g(X, U) &lt;= 0 convention\n            The constraint references fixed trajectory nodes (e.g., X[5] - X[4])\n        grad_g_X: Function (X, U, params) -&gt; (N, n_x) Jacobian wrt full state trajectory\n            This is typically sparse - most constraints only couple nearby nodes\n        grad_g_U: Function (X, U, params) -&gt; (N, n_u) Jacobian wrt full control trajectory\n            Often zero or very sparse for cross-node state constraints\n\n    Example:\n        For rate constraint x[5] - x[4] &lt;= r:\n\n            func(X, U, params) -&gt; scalar residual\n            grad_g_X(X, U, params) -&gt; (N, n_x) sparse Jacobian\n                where grad_g_X[5, :] = \u2202g/\u2202x[5] (derivative wrt node 5)\n                and grad_g_X[4, :] = \u2202g/\u2202x[4] (derivative wrt node 4)\n                all other entries are zero\n\n    Performance Note - Dense Jacobian Storage:\n        The Jacobian matrices grad_g_X and grad_g_U are stored as DENSE arrays with\n        shape (N, n_x) and (N, n_u), but most cross-node constraints only couple a\n        small number of nearby nodes, making these matrices extremely sparse.\n\n        For example, a rate limit constraint x[k] - x[k-1] &lt;= r only has non-zero\n        Jacobian entries at positions [k, :] and [k-1, :]. All other N-2 rows are\n        zero but still stored in memory.\n\n        Memory impact for large problems:\n        - A single constraint with N=100 nodes, n_x=10 states requires ~8KB for\n          grad_g_X (compared to ~160 bytes if sparse with 2 non-zero rows)\n        - Multiple cross-node constraints multiply this overhead\n        - May cause issues for N &gt; 1000 with many constraints\n\n        Performance impact:\n        - Slower autodiff (computes many zero gradients)\n        - Inefficient constraint linearization in the SCP solver\n        - Potential GPU memory limitations for very large problems\n\n        The current implementation prioritizes simplicity and compatibility with\n        JAX's autodiff over memory efficiency. Future versions may support sparse\n        Jacobian formats (COO, CSR, or custom sparse representations) if this\n        becomes a bottleneck in practice.\n    \"\"\"\n\n    func: Callable[[jnp.ndarray, jnp.ndarray, dict], jnp.ndarray]\n    grad_g_X: Callable[[jnp.ndarray, jnp.ndarray, dict], jnp.ndarray]\n    grad_g_U: Callable[[jnp.ndarray, jnp.ndarray, dict], jnp.ndarray]\n</code></pre>"},{"location":"reference/lowered/jax_constraints/#openscvx.lowered.jax_constraints.LoweredJaxConstraints","title":"<code>LoweredJaxConstraints</code>  <code>dataclass</code>","text":"<p>JAX-lowered non-convex constraints with gradient functions.</p> <p>Contains constraints that have been lowered to JAX callable functions with automatically computed gradients. These are used for linearization in the SCP (Sequential Convex Programming) loop.</p> <p>Attributes:</p> Name Type Description <code>nodal</code> <code>list[LoweredNodalConstraint]</code> <p>List of LoweredNodalConstraint objects. Each has <code>func</code>, <code>grad_g_x</code>, <code>grad_g_u</code> callables and <code>nodes</code> list.</p> <code>cross_node</code> <code>list[LoweredCrossNodeConstraint]</code> <p>List of LoweredCrossNodeConstraint objects. Each has <code>func</code>, <code>grad_g_X</code>, <code>grad_g_U</code> for trajectory-level constraints.</p> <code>ctcs</code> <code>list[CTCS]</code> <p>CTCS constraints (unchanged from input, not lowered here).</p> Source code in <code>openscvx/lowered/jax_constraints.py</code> <pre><code>@dataclass\nclass LoweredJaxConstraints:\n    \"\"\"JAX-lowered non-convex constraints with gradient functions.\n\n    Contains constraints that have been lowered to JAX callable functions\n    with automatically computed gradients. These are used for linearization\n    in the SCP (Sequential Convex Programming) loop.\n\n    Attributes:\n        nodal: List of LoweredNodalConstraint objects. Each has `func`,\n            `grad_g_x`, `grad_g_u` callables and `nodes` list.\n        cross_node: List of LoweredCrossNodeConstraint objects. Each has\n            `func`, `grad_g_X`, `grad_g_U` for trajectory-level constraints.\n        ctcs: CTCS constraints (unchanged from input, not lowered here).\n    \"\"\"\n\n    nodal: list[LoweredNodalConstraint] = field(default_factory=list)\n    cross_node: list[LoweredCrossNodeConstraint] = field(default_factory=list)\n    ctcs: list[\"CTCS\"] = field(default_factory=list)\n</code></pre>"},{"location":"reference/lowered/jax_constraints/#openscvx.lowered.jax_constraints.LoweredNodalConstraint","title":"<code>LoweredNodalConstraint</code>  <code>dataclass</code>","text":"<p>Dataclass to hold a lowered symbolic constraint function and its jacobians.</p> <p>This is a simplified drop-in replacement for NodalConstraint that holds only the essential lowered JAX functions and their jacobians, without the complexity of convex/vectorized flags or post-initialization logic.</p> <p>Designed for use with symbolic expressions that have been lowered to JAX and will be linearized for sequential convex programming.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[ndarray, ndarray], ndarray]</code> <p>The lowered constraint function g(x, u, ...params) that returns constraint residuals. Should follow g(x, u) &lt;= 0 convention. - x: 1D array (state at a single node), shape (n_x,) - u: 1D array (control at a single node), shape (n_u,) - Additional parameters: passed as keyword arguments</p> required <code>grad_g_x</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of g w.r.t. x. If None, should be computed using jax.jacfwd.</p> <code>None</code> <code>grad_g_u</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of g w.r.t. u. If None, should be computed using jax.jacfwd.</p> <code>None</code> <code>nodes</code> <code>Optional[List[int]]</code> <p>List of node indices where this constraint applies. Set after lowering from NodalConstraint.</p> <code>None</code> Source code in <code>openscvx/lowered/jax_constraints.py</code> <pre><code>@dataclass\nclass LoweredNodalConstraint:\n    \"\"\"\n    Dataclass to hold a lowered symbolic constraint function and its jacobians.\n\n    This is a simplified drop-in replacement for NodalConstraint that holds\n    only the essential lowered JAX functions and their jacobians, without\n    the complexity of convex/vectorized flags or post-initialization logic.\n\n    Designed for use with symbolic expressions that have been lowered to JAX\n    and will be linearized for sequential convex programming.\n\n    Args:\n        func (Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]):\n            The lowered constraint function g(x, u, ...params) that returns\n            constraint residuals. Should follow g(x, u) &lt;= 0 convention.\n            - x: 1D array (state at a single node), shape (n_x,)\n            - u: 1D array (control at a single node), shape (n_u,)\n            - Additional parameters: passed as keyword arguments\n\n        grad_g_x (Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]]):\n            Jacobian of g w.r.t. x. If None, should be computed using jax.jacfwd.\n\n        grad_g_u (Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]]):\n            Jacobian of g w.r.t. u. If None, should be computed using jax.jacfwd.\n\n        nodes (Optional[List[int]]): List of node indices where this constraint applies.\n            Set after lowering from NodalConstraint.\n    \"\"\"\n\n    func: Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]\n    grad_g_x: Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]] = None\n    grad_g_u: Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]] = None\n    nodes: Optional[List[int]] = None\n</code></pre>"},{"location":"reference/lowered/parameters/","title":"parameters","text":"<p>Parameter dictionary that syncs between JAX and CVXPy.</p>"},{"location":"reference/lowered/parameters/#openscvx.lowered.parameters.ParameterDict","title":"<code>ParameterDict</code>","text":"<p>               Bases: <code>dict</code></p> <p>Dictionary that syncs to both internal _parameters dict and CVXPy parameters.</p> This allows users to naturally update parameters like <p>problem.parameters[\"obs_radius\"] = 2.0</p> <p>Changes automatically propagate to: 1. Internal _parameters dict (plain dict for JAX) 2. CVXPy parameters (for optimization)</p> Source code in <code>openscvx/lowered/parameters.py</code> <pre><code>class ParameterDict(dict):\n    \"\"\"Dictionary that syncs to both internal _parameters dict and CVXPy parameters.\n\n    This allows users to naturally update parameters like:\n        problem.parameters[\"obs_radius\"] = 2.0\n\n    Changes automatically propagate to:\n    1. Internal _parameters dict (plain dict for JAX)\n    2. CVXPy parameters (for optimization)\n    \"\"\"\n\n    def __init__(self, problem, internal_dict, *args, **kwargs):\n        self._problem = problem\n        self._internal_dict = internal_dict  # Reference to plain dict for JAX\n        super().__init__()\n        # Initialize with float enforcement by using __setitem__\n        if args:\n            other = args[0]\n            if hasattr(other, \"items\"):\n                for key, value in other.items():\n                    self[key] = value\n            else:\n                for key, value in other:\n                    self[key] = value\n        for key, value in kwargs.items():\n            self[key] = value\n\n    def __setitem__(self, key, value):\n        # Enforce float dtype to prevent int/float mismatch bugs\n        value = np.asarray(value, dtype=float)\n        super().__setitem__(key, value)\n        # Sync to internal dict for JAX\n        self._internal_dict[key] = value\n        # Sync to CVXPy if it exists\n        lowered = getattr(self._problem, \"_lowered\", None)\n        if lowered is not None and key in lowered.cvxpy_params:\n            lowered.cvxpy_params[key].value = value\n\n    def update(self, other=None, **kwargs):\n        \"\"\"Update multiple parameters and sync to internal dict and CVXPy.\"\"\"\n        if other is not None:\n            if hasattr(other, \"items\"):\n                for key, value in other.items():\n                    self[key] = value\n            else:\n                for key, value in other:\n                    self[key] = value\n        for key, value in kwargs.items():\n            self[key] = value\n</code></pre>"},{"location":"reference/lowered/parameters/#openscvx.lowered.parameters.ParameterDict.update","title":"<code>update(other=None, **kwargs)</code>","text":"<p>Update multiple parameters and sync to internal dict and CVXPy.</p> Source code in <code>openscvx/lowered/parameters.py</code> <pre><code>def update(self, other=None, **kwargs):\n    \"\"\"Update multiple parameters and sync to internal dict and CVXPy.\"\"\"\n    if other is not None:\n        if hasattr(other, \"items\"):\n            for key, value in other.items():\n                self[key] = value\n        else:\n            for key, value in other:\n                self[key] = value\n    for key, value in kwargs.items():\n        self[key] = value\n</code></pre>"},{"location":"reference/lowered/problem/","title":"problem","text":"<p>LoweredProblem dataclass - container for all lowering outputs.</p>"},{"location":"reference/lowered/problem/#openscvx.lowered.problem.LoweredProblem","title":"<code>LoweredProblem</code>  <code>dataclass</code>","text":"<p>Container for all outputs from symbolic problem lowering.</p> <p>This dataclass holds all the results of lowering symbolic expressions to executable JAX and CVXPy code. It provides a clean, typed interface for accessing the various components needed for optimization.</p> <p>Attributes:</p> Name Type Description <code>dynamics</code> <code>Dynamics</code> <p>Optimization dynamics with fields f, A, B (JAX functions)</p> <code>dynamics_prop</code> <code>Dynamics</code> <p>Propagation dynamics with fields f, A, B</p> <code>jax_constraints</code> <code>LoweredJaxConstraints</code> <p>Non-convex constraints lowered to JAX with gradients</p> <code>cvxpy_constraints</code> <code>LoweredCvxpyConstraints</code> <p>Convex constraints lowered to CVXPy</p> <code>x_unified</code> <code>UnifiedState</code> <p>Aggregated optimization state interface</p> <code>u_unified</code> <code>UnifiedControl</code> <p>Aggregated optimization control interface</p> <code>x_prop_unified</code> <code>UnifiedState</code> <p>Aggregated propagation state interface</p> <code>ocp_vars</code> <code>CVXPyVariables</code> <p>Typed CVXPy variables and parameters for OCP construction</p> <code>cvxpy_params</code> <code>Dict[str, Parameter]</code> <p>Dict mapping user parameter names to CVXPy Parameter objects</p> Example <p>After lowering a symbolic problem::</p> <pre><code>lowered = lower_symbolic_problem(\n    dynamics_aug=dynamics,\n    states_aug=states,\n    controls_aug=controls,\n    constraints=constraint_set,\n    parameters=params,\n    N=50,\n)\n\n# Access components\ndx_dt = lowered.dynamics.f(x, u, node, params)\njacobian_A = lowered.dynamics.A(x, u, node, params)\n\n# Use CVXPy objects\nocp = OptimalControlProblem(settings, lowered)\n</code></pre> Source code in <code>openscvx/lowered/problem.py</code> <pre><code>@dataclass\nclass LoweredProblem:\n    \"\"\"Container for all outputs from symbolic problem lowering.\n\n    This dataclass holds all the results of lowering symbolic expressions\n    to executable JAX and CVXPy code. It provides a clean, typed interface\n    for accessing the various components needed for optimization.\n\n    Attributes:\n        dynamics: Optimization dynamics with fields f, A, B (JAX functions)\n        dynamics_prop: Propagation dynamics with fields f, A, B\n        jax_constraints: Non-convex constraints lowered to JAX with gradients\n        cvxpy_constraints: Convex constraints lowered to CVXPy\n        x_unified: Aggregated optimization state interface\n        u_unified: Aggregated optimization control interface\n        x_prop_unified: Aggregated propagation state interface\n        ocp_vars: Typed CVXPy variables and parameters for OCP construction\n        cvxpy_params: Dict mapping user parameter names to CVXPy Parameter objects\n\n    Example:\n        After lowering a symbolic problem::\n\n            lowered = lower_symbolic_problem(\n                dynamics_aug=dynamics,\n                states_aug=states,\n                controls_aug=controls,\n                constraints=constraint_set,\n                parameters=params,\n                N=50,\n            )\n\n            # Access components\n            dx_dt = lowered.dynamics.f(x, u, node, params)\n            jacobian_A = lowered.dynamics.A(x, u, node, params)\n\n            # Use CVXPy objects\n            ocp = OptimalControlProblem(settings, lowered)\n    \"\"\"\n\n    # JAX dynamics\n    dynamics: Dynamics\n    dynamics_prop: Dynamics\n\n    # Lowered constraints (separate types for JAX vs CVXPy)\n    jax_constraints: LoweredJaxConstraints\n    cvxpy_constraints: LoweredCvxpyConstraints\n\n    # Unified interfaces\n    x_unified: UnifiedState\n    u_unified: UnifiedControl\n    x_prop_unified: UnifiedState\n\n    # CVXPy objects\n    ocp_vars: CVXPyVariables\n    cvxpy_params: Dict[str, \"cp.Parameter\"]\n</code></pre>"},{"location":"reference/lowered/unified/","title":"unified","text":"<p>Unified state and control dataclasses for the lowered representation.</p> <p>This module contains the UnifiedState and UnifiedControl dataclasses that describe the structure of the monolithic state and control vectors used in numerical optimization.</p> <p>In the symbolic world, users define many named State and Control objects (position, velocity, thrust, etc.). In the lowered world, these are aggregated into single monolithic x and u vectors. UnifiedState and UnifiedControl hold the metadata describing this aggregation: bounds, guesses, boundary conditions, and slices for extracting individual components.</p> See Also <ul> <li>openscvx.symbolic.unified: Contains unify_states() and unify_controls()   functions that create these dataclasses from symbolic State/Control objects.</li> </ul>"},{"location":"reference/lowered/unified/#openscvx.lowered.unified.UnifiedControl","title":"<code>UnifiedControl</code>  <code>dataclass</code>","text":"<p>Unified control vector aggregating multiple Control objects.</p> <p>UnifiedControl is a drop-in replacement for individual Control objects that holds aggregated data from multiple Control instances. It maintains compatibility with optimization infrastructure while providing access to individual control components through slicing.</p> <p>The unified control separates user-defined \"true\" controls from augmented controls added internally (e.g., for time dilation). This separation allows clean access to physical control inputs while supporting advanced features.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the unified control vector</p> <code>shape</code> <code>tuple</code> <p>Combined shape (total_dim,) of all aggregated controls</p> <code>min</code> <code>ndarray</code> <p>Lower bounds for all control variables, shape (total_dim,)</p> <code>max</code> <code>ndarray</code> <p>Upper bounds for all control variables, shape (total_dim,)</p> <code>guess</code> <code>ndarray</code> <p>Initial guess trajectory, shape (num_nodes, total_dim)</p> <code>_true_dim</code> <code>int</code> <p>Number of user-defined control dimensions (excludes augmented)</p> <code>_true_slice</code> <code>slice</code> <p>Slice for extracting true controls from unified vector</p> <code>_augmented_slice</code> <code>slice</code> <p>Slice for extracting augmented controls</p> <code>time_dilation_slice</code> <code>Optional[slice]</code> <p>Slice for time dilation control, if present</p> Properties <p>true: Returns UnifiedControl view containing only true (user-defined) controls augmented: Returns UnifiedControl view containing only augmented controls</p> Example <p>Creating a unified control from multiple Control objects::</p> <pre><code>from openscvx.symbolic.unified import unify_controls\n\nthrust = ox.Control(\"thrust\", shape=(3,), min=0, max=10)\ntorque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n\nunified = unify_controls([thrust, torque], name=\"u\")\nprint(unified.shape)        # (6,)\nprint(unified.min)          # [0, 0, 0, -1, -1, -1]\nprint(unified.true.shape)   # (6,) - all are true controls\nprint(unified.augmented.shape)  # (0,) - no augmented controls\n</code></pre> <p>Appending controls dynamically::</p> <pre><code>unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.0)  # Add scalar control\nprint(unified.shape)  # (1,)\n</code></pre> See Also <ul> <li>unify_controls(): Factory function for creating UnifiedControl from Control list</li> <li>Control: Individual symbolic control variable</li> <li>UnifiedState: Analogous unified state vector</li> </ul> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>@dataclass\nclass UnifiedControl:\n    \"\"\"Unified control vector aggregating multiple Control objects.\n\n    UnifiedControl is a drop-in replacement for individual Control objects that holds\n    aggregated data from multiple Control instances. It maintains compatibility with\n    optimization infrastructure while providing access to individual control components\n    through slicing.\n\n    The unified control separates user-defined \"true\" controls from augmented controls\n    added internally (e.g., for time dilation). This separation allows clean access to\n    physical control inputs while supporting advanced features.\n\n    Attributes:\n        name (str): Name identifier for the unified control vector\n        shape (tuple): Combined shape (total_dim,) of all aggregated controls\n        min (np.ndarray): Lower bounds for all control variables, shape (total_dim,)\n        max (np.ndarray): Upper bounds for all control variables, shape (total_dim,)\n        guess (np.ndarray): Initial guess trajectory, shape (num_nodes, total_dim)\n        _true_dim (int): Number of user-defined control dimensions (excludes augmented)\n        _true_slice (slice): Slice for extracting true controls from unified vector\n        _augmented_slice (slice): Slice for extracting augmented controls\n        time_dilation_slice (Optional[slice]): Slice for time dilation control, if present\n\n    Properties:\n        true: Returns UnifiedControl view containing only true (user-defined) controls\n        augmented: Returns UnifiedControl view containing only augmented controls\n\n    Example:\n        Creating a unified control from multiple Control objects::\n\n            from openscvx.symbolic.unified import unify_controls\n\n            thrust = ox.Control(\"thrust\", shape=(3,), min=0, max=10)\n            torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n\n            unified = unify_controls([thrust, torque], name=\"u\")\n            print(unified.shape)        # (6,)\n            print(unified.min)          # [0, 0, 0, -1, -1, -1]\n            print(unified.true.shape)   # (6,) - all are true controls\n            print(unified.augmented.shape)  # (0,) - no augmented controls\n\n        Appending controls dynamically::\n\n            unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.0)  # Add scalar control\n            print(unified.shape)  # (1,)\n\n    See Also:\n        - unify_controls(): Factory function for creating UnifiedControl from Control list\n        - Control: Individual symbolic control variable\n        - UnifiedState: Analogous unified state vector\n    \"\"\"\n\n    name: str\n    shape: tuple\n    min: Optional[np.ndarray] = None\n    max: Optional[np.ndarray] = None\n    guess: Optional[np.ndarray] = None\n    _true_dim: int = 0\n    _true_slice: Optional[slice] = None\n    _augmented_slice: Optional[slice] = None\n    time_dilation_slice: Optional[slice] = None  # Slice for time dilation control\n    scaling_min: Optional[np.ndarray] = None  # Scaling minimum bounds for unified control\n    scaling_max: Optional[np.ndarray] = None  # Scaling maximum bounds for unified control\n\n    def __post_init__(self):\n        \"\"\"Initialize slices after dataclass creation.\"\"\"\n        if self._true_slice is None:\n            self._true_slice = slice(0, self._true_dim)\n        if self._augmented_slice is None:\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    @property\n    def true(self) -&gt; \"UnifiedControl\":\n        \"\"\"Get the true (user-defined) control variables.\n\n        Returns a view of the unified control containing only user-defined controls,\n        excluding internal augmented controls added for time dilation, etc.\n\n        Returns:\n            UnifiedControl: Sliced view containing only true control variables\n\n        Example:\n            Get true user defined controls::\n\n                unified = unify_controls([thrust, torque, time_dilation], name=\"u\")\n                true_controls = unified.true  # Only thrust and torque\n        \"\"\"\n        return self[self._true_slice]\n\n    @property\n    def augmented(self) -&gt; \"UnifiedControl\":\n        \"\"\"Get the augmented (internal) control variables.\n\n        Returns a view of the unified control containing only augmented controls\n        added internally by the optimization framework (e.g., time dilation control).\n\n        Returns:\n            UnifiedControl: Sliced view containing only augmented control variables\n\n        Example:\n            Get augmented controls::\n\n                unified = unify_controls([thrust, time_dilation], name=\"u\")\n                aug_controls = unified.augmented  # Only time dilation\n        \"\"\"\n        return self[self._augmented_slice]\n\n    def append(\n        self,\n        other: \"Optional[Control | UnifiedControl]\" = None,\n        *,\n        min=-np.inf,\n        max=np.inf,\n        guess=0.0,\n        augmented=False,\n    ):\n        \"\"\"Append another control or create a new control variable.\n\n        This method allows dynamic extension of the unified control, either by appending\n        another Control/UnifiedControl object or by creating a new scalar control variable\n        with specified properties. Modifies the unified control in-place.\n\n        Args:\n            other (Optional[Control | UnifiedControl]): Control object to append. If None,\n                creates a new scalar control variable with properties from keyword args.\n            min (float): Lower bound for new scalar control (default: -inf)\n            max (float): Upper bound for new scalar control (default: inf)\n            guess (float): Initial guess value for new scalar control (default: 0.0)\n            augmented (bool): Whether the appended control is augmented (internal) rather\n                than true (user-defined). Affects _true_dim tracking. Default: False\n\n        Returns:\n            None: Modifies the unified control in-place\n\n        Example:\n            Appending a Control object::\n\n                unified = unify_controls([thrust], name=\"u\")\n                torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n                unified.append(torque)\n                print(unified.shape)  # (6,) - thrust (3) + torque (3)\n\n            Creating new scalar control variables::\n\n                unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\n                unified.append(min=-1, max=1, guess=0.0)  # Add scalar control\n                print(unified.shape)  # (1,)\n        \"\"\"\n        # Import here to avoid circular imports at module level\n        from openscvx.symbolic.expr.control import Control\n\n        if isinstance(other, (Control, UnifiedControl)):\n            # Append another control object\n            new_shape = (self.shape[0] + other.shape[0],)\n\n            # Update bounds\n            if self.min is not None and other.min is not None:\n                new_min = np.concatenate([self.min, other.min])\n            else:\n                new_min = self.min\n\n            if self.max is not None and other.max is not None:\n                new_max = np.concatenate([self.max, other.max])\n            else:\n                new_max = self.max\n\n            # Update guess\n            if self.guess is not None and other.guess is not None:\n                new_guess = np.concatenate([self.guess, other.guess], axis=1)\n            else:\n                new_guess = self.guess\n\n            # Update true dimension\n            if not augmented:\n                new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n            else:\n                new_true_dim = self._true_dim\n\n            # Update all attributes in place\n            self.shape = new_shape\n            self.min = new_min\n            self.max = new_max\n            self.guess = new_guess\n            self._true_dim = new_true_dim\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n        else:\n            # Create a single new variable\n            new_shape = (self.shape[0] + 1,)\n\n            # Extend arrays\n            if self.min is not None:\n                self.min = np.concatenate([self.min, np.array([min])])\n            if self.max is not None:\n                self.max = np.concatenate([self.max, np.array([max])])\n            if self.guess is not None:\n                guess_arr = np.full((self.guess.shape[0], 1), guess)\n                self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n\n            # Update dimensions\n            self.shape = new_shape\n            if not augmented:\n                self._true_dim += 1\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    def __getitem__(self, idx):\n        \"\"\"Get a subset of the unified control variables.\n\n        Enables slicing of the unified control to extract subsets of control variables.\n        Returns a new UnifiedControl containing only the sliced dimensions.\n\n        Args:\n            idx (slice): Slice object specifying which control dimensions to extract.\n                Only simple slices with step=1 are supported.\n\n        Returns:\n            UnifiedControl: New unified control containing only the sliced dimensions\n\n        Raises:\n            NotImplementedError: If idx is not a slice, or if step != 1\n\n        Example:\n            Generate unified control object::\n\n                unified = unify_controls([thrust, torque], name=\"u\")\n\n            thrust has shape (3,), torque has shape (3,)::\n\n                first_three = unified[0:3]  # Extract thrust only\n                print(first_three.shape)  # (3,)\n\n        Note:\n            The sliced control maintains all properties (bounds, guesses, etc.) for\n            the selected dimensions. The _true_dim is recalculated based on which\n            dimensions fall within the original true control range.\n        \"\"\"\n        if isinstance(idx, slice):\n            start, stop, step = idx.indices(self.shape[0])\n            if step != 1:\n                raise NotImplementedError(\"Step slicing not supported\")\n\n            new_shape = (stop - start,)\n            new_name = f\"{self.name}[{start}:{stop}]\"\n\n            # Slice all arrays\n            new_min = self.min[idx] if self.min is not None else None\n            new_max = self.max[idx] if self.max is not None else None\n            new_guess = self.guess[:, idx] if self.guess is not None else None\n\n            # Calculate new true dimension\n            new_true_dim = max(0, min(stop, self._true_dim) - max(start, 0))\n\n            return UnifiedControl(\n                name=new_name,\n                shape=new_shape,\n                min=new_min,\n                max=new_max,\n                guess=new_guess,\n                _true_dim=new_true_dim,\n                _true_slice=slice(0, new_true_dim),\n                _augmented_slice=slice(new_true_dim, new_shape[0]),\n            )\n        else:\n            raise NotImplementedError(\"Only slice indexing is supported\")\n\n    def __repr__(self):\n        \"\"\"String representation of the UnifiedControl object.\"\"\"\n        return f\"UnifiedControl('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/lowered/unified/#openscvx.lowered.unified.UnifiedControl.augmented","title":"<code>augmented: UnifiedControl</code>  <code>property</code>","text":"<p>Get the augmented (internal) control variables.</p> <p>Returns a view of the unified control containing only augmented controls added internally by the optimization framework (e.g., time dilation control).</p> <p>Returns:</p> Name Type Description <code>UnifiedControl</code> <code>UnifiedControl</code> <p>Sliced view containing only augmented control variables</p> Example <p>Get augmented controls::</p> <pre><code>unified = unify_controls([thrust, time_dilation], name=\"u\")\naug_controls = unified.augmented  # Only time dilation\n</code></pre>"},{"location":"reference/lowered/unified/#openscvx.lowered.unified.UnifiedControl.true","title":"<code>true: UnifiedControl</code>  <code>property</code>","text":"<p>Get the true (user-defined) control variables.</p> <p>Returns a view of the unified control containing only user-defined controls, excluding internal augmented controls added for time dilation, etc.</p> <p>Returns:</p> Name Type Description <code>UnifiedControl</code> <code>UnifiedControl</code> <p>Sliced view containing only true control variables</p> Example <p>Get true user defined controls::</p> <pre><code>unified = unify_controls([thrust, torque, time_dilation], name=\"u\")\ntrue_controls = unified.true  # Only thrust and torque\n</code></pre>"},{"location":"reference/lowered/unified/#openscvx.lowered.unified.UnifiedControl.append","title":"<code>append(other: Optional[Control | UnifiedControl] = None, *, min=-np.inf, max=np.inf, guess=0.0, augmented=False)</code>","text":"<p>Append another control or create a new control variable.</p> <p>This method allows dynamic extension of the unified control, either by appending another Control/UnifiedControl object or by creating a new scalar control variable with specified properties. Modifies the unified control in-place.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Optional[Control | UnifiedControl]</code> <p>Control object to append. If None, creates a new scalar control variable with properties from keyword args.</p> <code>None</code> <code>min</code> <code>float</code> <p>Lower bound for new scalar control (default: -inf)</p> <code>-inf</code> <code>max</code> <code>float</code> <p>Upper bound for new scalar control (default: inf)</p> <code>inf</code> <code>guess</code> <code>float</code> <p>Initial guess value for new scalar control (default: 0.0)</p> <code>0.0</code> <code>augmented</code> <code>bool</code> <p>Whether the appended control is augmented (internal) rather than true (user-defined). Affects _true_dim tracking. Default: False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <p>Modifies the unified control in-place</p> Example <p>Appending a Control object::</p> <pre><code>unified = unify_controls([thrust], name=\"u\")\ntorque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\nunified.append(torque)\nprint(unified.shape)  # (6,) - thrust (3) + torque (3)\n</code></pre> <p>Creating new scalar control variables::</p> <pre><code>unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.0)  # Add scalar control\nprint(unified.shape)  # (1,)\n</code></pre> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>def append(\n    self,\n    other: \"Optional[Control | UnifiedControl]\" = None,\n    *,\n    min=-np.inf,\n    max=np.inf,\n    guess=0.0,\n    augmented=False,\n):\n    \"\"\"Append another control or create a new control variable.\n\n    This method allows dynamic extension of the unified control, either by appending\n    another Control/UnifiedControl object or by creating a new scalar control variable\n    with specified properties. Modifies the unified control in-place.\n\n    Args:\n        other (Optional[Control | UnifiedControl]): Control object to append. If None,\n            creates a new scalar control variable with properties from keyword args.\n        min (float): Lower bound for new scalar control (default: -inf)\n        max (float): Upper bound for new scalar control (default: inf)\n        guess (float): Initial guess value for new scalar control (default: 0.0)\n        augmented (bool): Whether the appended control is augmented (internal) rather\n            than true (user-defined). Affects _true_dim tracking. Default: False\n\n    Returns:\n        None: Modifies the unified control in-place\n\n    Example:\n        Appending a Control object::\n\n            unified = unify_controls([thrust], name=\"u\")\n            torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n            unified.append(torque)\n            print(unified.shape)  # (6,) - thrust (3) + torque (3)\n\n        Creating new scalar control variables::\n\n            unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.0)  # Add scalar control\n            print(unified.shape)  # (1,)\n    \"\"\"\n    # Import here to avoid circular imports at module level\n    from openscvx.symbolic.expr.control import Control\n\n    if isinstance(other, (Control, UnifiedControl)):\n        # Append another control object\n        new_shape = (self.shape[0] + other.shape[0],)\n\n        # Update bounds\n        if self.min is not None and other.min is not None:\n            new_min = np.concatenate([self.min, other.min])\n        else:\n            new_min = self.min\n\n        if self.max is not None and other.max is not None:\n            new_max = np.concatenate([self.max, other.max])\n        else:\n            new_max = self.max\n\n        # Update guess\n        if self.guess is not None and other.guess is not None:\n            new_guess = np.concatenate([self.guess, other.guess], axis=1)\n        else:\n            new_guess = self.guess\n\n        # Update true dimension\n        if not augmented:\n            new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n        else:\n            new_true_dim = self._true_dim\n\n        # Update all attributes in place\n        self.shape = new_shape\n        self.min = new_min\n        self.max = new_max\n        self.guess = new_guess\n        self._true_dim = new_true_dim\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    else:\n        # Create a single new variable\n        new_shape = (self.shape[0] + 1,)\n\n        # Extend arrays\n        if self.min is not None:\n            self.min = np.concatenate([self.min, np.array([min])])\n        if self.max is not None:\n            self.max = np.concatenate([self.max, np.array([max])])\n        if self.guess is not None:\n            guess_arr = np.full((self.guess.shape[0], 1), guess)\n            self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n\n        # Update dimensions\n        self.shape = new_shape\n        if not augmented:\n            self._true_dim += 1\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n</code></pre>"},{"location":"reference/lowered/unified/#openscvx.lowered.unified.UnifiedState","title":"<code>UnifiedState</code>  <code>dataclass</code>","text":"<p>Unified state vector aggregating multiple State objects.</p> <p>UnifiedState is a drop-in replacement for individual State objects that holds aggregated data from multiple State instances. It maintains compatibility with optimization infrastructure while providing access to individual state components through slicing.</p> <p>The unified state separates user-defined \"true\" states from augmented states added internally (e.g., for CTCS constraints or time variables). This separation allows clean access to physical states while supporting advanced features.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the unified state vector</p> <code>shape</code> <code>tuple</code> <p>Combined shape (total_dim,) of all aggregated states</p> <code>min</code> <code>ndarray</code> <p>Lower bounds for all state variables, shape (total_dim,)</p> <code>max</code> <code>ndarray</code> <p>Upper bounds for all state variables, shape (total_dim,)</p> <code>guess</code> <code>ndarray</code> <p>Initial guess trajectory, shape (num_nodes, total_dim)</p> <code>initial</code> <code>ndarray</code> <p>Initial boundary conditions, shape (total_dim,)</p> <code>final</code> <code>ndarray</code> <p>Final boundary conditions, shape (total_dim,)</p> <code>_initial</code> <code>ndarray</code> <p>Internal initial values, shape (total_dim,)</p> <code>_final</code> <code>ndarray</code> <p>Internal final values, shape (total_dim,)</p> <code>initial_type</code> <code>ndarray</code> <p>Boundary condition types at t0 (\"Fix\" or \"Free\"), shape (total_dim,), dtype=object</p> <code>final_type</code> <code>ndarray</code> <p>Boundary condition types at tf (\"Fix\" or \"Free\"), shape (total_dim,), dtype=object</p> <code>_true_dim</code> <code>int</code> <p>Number of user-defined state dimensions (excludes augmented)</p> <code>_true_slice</code> <code>slice</code> <p>Slice for extracting true states from unified vector</p> <code>_augmented_slice</code> <code>slice</code> <p>Slice for extracting augmented states</p> <code>time_slice</code> <code>Optional[slice]</code> <p>Slice for time state variable, if present</p> <code>ctcs_slice</code> <code>Optional[slice]</code> <p>Slice for CTCS augmented states, if present</p> Properties <p>true: Returns UnifiedState view containing only true (user-defined) states augmented: Returns UnifiedState view containing only augmented states</p> Example <p>Creating a unified state from multiple State objects::</p> <pre><code>from openscvx.symbolic.unified import unify_states\n\nposition = ox.State(\"pos\", shape=(3,), min=-10, max=10)\nvelocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n\nunified = unify_states([position, velocity], name=\"x\")\nprint(unified.shape)        # (6,)\nprint(unified.min)          # [-10, -10, -10, -5, -5, -5]\nprint(unified.true.shape)   # (6,) - all are true states\nprint(unified.augmented.shape)  # (0,) - no augmented states\n</code></pre> <p>Appending states dynamically::</p> <pre><code>unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.5)  # Add scalar state\nprint(unified.shape)  # (1,)\n</code></pre> See Also <ul> <li>unify_states(): Factory function for creating UnifiedState from State list</li> <li>State: Individual symbolic state variable</li> <li>UnifiedControl: Analogous unified control vector</li> </ul> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>@dataclass\nclass UnifiedState:\n    \"\"\"Unified state vector aggregating multiple State objects.\n\n    UnifiedState is a drop-in replacement for individual State objects that holds\n    aggregated data from multiple State instances. It maintains compatibility with\n    optimization infrastructure while providing access to individual state components\n    through slicing.\n\n    The unified state separates user-defined \"true\" states from augmented states\n    added internally (e.g., for CTCS constraints or time variables). This separation\n    allows clean access to physical states while supporting advanced features.\n\n    Attributes:\n        name (str): Name identifier for the unified state vector\n        shape (tuple): Combined shape (total_dim,) of all aggregated states\n        min (np.ndarray): Lower bounds for all state variables, shape (total_dim,)\n        max (np.ndarray): Upper bounds for all state variables, shape (total_dim,)\n        guess (np.ndarray): Initial guess trajectory, shape (num_nodes, total_dim)\n        initial (np.ndarray): Initial boundary conditions, shape (total_dim,)\n        final (np.ndarray): Final boundary conditions, shape (total_dim,)\n        _initial (np.ndarray): Internal initial values, shape (total_dim,)\n        _final (np.ndarray): Internal final values, shape (total_dim,)\n        initial_type (np.ndarray): Boundary condition types at t0 (\"Fix\" or \"Free\"),\n            shape (total_dim,), dtype=object\n        final_type (np.ndarray): Boundary condition types at tf (\"Fix\" or \"Free\"),\n            shape (total_dim,), dtype=object\n        _true_dim (int): Number of user-defined state dimensions (excludes augmented)\n        _true_slice (slice): Slice for extracting true states from unified vector\n        _augmented_slice (slice): Slice for extracting augmented states\n        time_slice (Optional[slice]): Slice for time state variable, if present\n        ctcs_slice (Optional[slice]): Slice for CTCS augmented states, if present\n\n    Properties:\n        true: Returns UnifiedState view containing only true (user-defined) states\n        augmented: Returns UnifiedState view containing only augmented states\n\n    Example:\n        Creating a unified state from multiple State objects::\n\n            from openscvx.symbolic.unified import unify_states\n\n            position = ox.State(\"pos\", shape=(3,), min=-10, max=10)\n            velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n\n            unified = unify_states([position, velocity], name=\"x\")\n            print(unified.shape)        # (6,)\n            print(unified.min)          # [-10, -10, -10, -5, -5, -5]\n            print(unified.true.shape)   # (6,) - all are true states\n            print(unified.augmented.shape)  # (0,) - no augmented states\n\n        Appending states dynamically::\n\n            unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.5)  # Add scalar state\n            print(unified.shape)  # (1,)\n\n    See Also:\n        - unify_states(): Factory function for creating UnifiedState from State list\n        - State: Individual symbolic state variable\n        - UnifiedControl: Analogous unified control vector\n    \"\"\"\n\n    name: str\n    shape: tuple\n    min: Optional[np.ndarray] = None\n    max: Optional[np.ndarray] = None\n    guess: Optional[np.ndarray] = None\n    initial: Optional[np.ndarray] = None\n    final: Optional[np.ndarray] = None\n    _initial: Optional[np.ndarray] = None\n    _final: Optional[np.ndarray] = None\n    initial_type: Optional[np.ndarray] = None\n    final_type: Optional[np.ndarray] = None\n    _true_dim: int = 0\n    _true_slice: Optional[slice] = None\n    _augmented_slice: Optional[slice] = None\n    time_slice: Optional[slice] = None  # Slice for time state\n    ctcs_slice: Optional[slice] = None  # Slice for CTCS augmented states\n    scaling_min: Optional[np.ndarray] = None  # Scaling minimum bounds for unified state\n    scaling_max: Optional[np.ndarray] = None  # Scaling maximum bounds for unified state\n\n    def __post_init__(self):\n        \"\"\"Initialize slices after dataclass creation.\"\"\"\n        if self._true_slice is None:\n            self._true_slice = slice(0, self._true_dim)\n        if self._augmented_slice is None:\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    @property\n    def true(self) -&gt; \"UnifiedState\":\n        \"\"\"Get the true (user-defined) state variables.\n\n        Returns a view of the unified state containing only user-defined states,\n        excluding internal augmented states added for CTCS, time, etc.\n\n        Returns:\n            UnifiedState: Sliced view containing only true state variables\n\n        Example:\n            Get true user-defined state::\n\n                unified = unify_states([position, velocity, ctcs_aug], name=\"x\")\n                true_states = unified.true  # Only position and velocity\n                true_states.shape  # (6,) if position and velocity are 3D each\n        \"\"\"\n        return self[self._true_slice]\n\n    @property\n    def augmented(self) -&gt; \"UnifiedState\":\n        \"\"\"Get the augmented (internal) state variables.\n\n        Returns a view of the unified state containing only augmented states\n        added internally by the optimization framework (e.g., CTCS penalty states,\n        time variables).\n\n        Returns:\n            UnifiedState: Sliced view containing only augmented state variables\n\n        Example:\n            Get augmented state::\n\n                unified = unify_states([position, ctcs_aug], name=\"x\")\n                aug_states = unified.augmented  # Only CTCS states\n        \"\"\"\n        return self[self._augmented_slice]\n\n    def append(\n        self,\n        other: \"Optional[State | UnifiedState]\" = None,\n        *,\n        min=-np.inf,\n        max=np.inf,\n        guess=0.0,\n        initial=0.0,\n        final=0.0,\n        augmented=False,\n    ):\n        \"\"\"Append another state or create a new state variable.\n\n        This method allows dynamic extension of the unified state, either by appending\n        another State/UnifiedState object or by creating a new scalar state variable\n        with specified properties. Modifies the unified state in-place.\n\n        Args:\n            other (Optional[State | UnifiedState]): State object to append. If None,\n                creates a new scalar state variable with properties from keyword args.\n            min (float): Lower bound for new scalar state (default: -inf)\n            max (float): Upper bound for new scalar state (default: inf)\n            guess (float): Initial guess value for new scalar state (default: 0.0)\n            initial (float): Initial boundary condition for new scalar state (default: 0.0)\n            final (float): Final boundary condition for new scalar state (default: 0.0)\n            augmented (bool): Whether the appended state is augmented (internal) rather\n                than true (user-defined). Affects _true_dim tracking. Default: False\n\n        Returns:\n            None: Modifies the unified state in-place\n\n        Example:\n            Appending a State object::\n\n                unified = unify_states([position], name=\"x\")\n                velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n                unified.append(velocity)\n                print(unified.shape)  # (6,) - position (3) + velocity (3)\n\n            Creating new scalar state variables::\n\n                unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\n                unified.append(min=-1, max=1, guess=0.5)  # Add scalar state\n                unified.append(min=-2, max=2, augmented=True)  # Add augmented state\n                print(unified.shape)  # (2,)\n                print(unified._true_dim)  # 1 (only first is true)\n\n        Note:\n            Maintains the invariant that true states appear before augmented states\n            in the unified vector. When appending augmented states, they are added\n            to the end but don't increment _true_dim.\n        \"\"\"\n        # Import here to avoid circular imports at module level\n        from openscvx.symbolic.expr.state import State\n\n        if isinstance(other, (State, UnifiedState)):\n            # Append another state object\n            new_shape = (self.shape[0] + other.shape[0],)\n\n            # Update bounds\n            if self.min is not None and other.min is not None:\n                new_min = np.concatenate([self.min, other.min])\n            else:\n                new_min = self.min\n\n            if self.max is not None and other.max is not None:\n                new_max = np.concatenate([self.max, other.max])\n            else:\n                new_max = self.max\n\n            # Update guess\n            if self.guess is not None and other.guess is not None:\n                new_guess = np.concatenate([self.guess, other.guess], axis=1)\n            else:\n                new_guess = self.guess\n\n            # Update initial/final conditions\n            if self.initial is not None and other.initial is not None:\n                new_initial = np.concatenate([self.initial, other.initial])\n            else:\n                new_initial = self.initial\n\n            if self.final is not None and other.final is not None:\n                new_final = np.concatenate([self.final, other.final])\n            else:\n                new_final = self.final\n\n            # Update internal arrays\n            if self._initial is not None and other._initial is not None:\n                new__initial = np.concatenate([self._initial, other._initial])\n            else:\n                new__initial = self._initial\n\n            if self._final is not None and other._final is not None:\n                new__final = np.concatenate([self._final, other._final])\n            else:\n                new__final = self._final\n\n            # Update types\n            if self.initial_type is not None and other.initial_type is not None:\n                new_initial_type = np.concatenate([self.initial_type, other.initial_type])\n            else:\n                new_initial_type = self.initial_type\n\n            if self.final_type is not None and other.final_type is not None:\n                new_final_type = np.concatenate([self.final_type, other.final_type])\n            else:\n                new_final_type = self.final_type\n\n            # Update true dimension\n            if not augmented:\n                new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n            else:\n                new_true_dim = self._true_dim\n\n            # Update all attributes in place\n            self.shape = new_shape\n            self.min = new_min\n            self.max = new_max\n            self.guess = new_guess\n            self.initial = new_initial\n            self.final = new_final\n            self._initial = new__initial\n            self._final = new__final\n            self.initial_type = new_initial_type\n            self.final_type = new_final_type\n            self._true_dim = new_true_dim\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n        else:\n            # Create a single new variable\n            new_shape = (self.shape[0] + 1,)\n\n            # Extend arrays\n            if self.min is not None:\n                self.min = np.concatenate([self.min, np.array([min])])\n            if self.max is not None:\n                self.max = np.concatenate([self.max, np.array([max])])\n            if self.guess is not None:\n                guess_arr = np.full((self.guess.shape[0], 1), guess)\n                self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n            if self.initial is not None:\n                self.initial = np.concatenate([self.initial, np.array([initial])])\n            if self.final is not None:\n                self.final = np.concatenate([self.final, np.array([final])])\n            if self._initial is not None:\n                self._initial = np.concatenate([self._initial, np.array([initial])])\n            if self._final is not None:\n                self._final = np.concatenate([self._final, np.array([final])])\n            if self.initial_type is not None:\n                self.initial_type = np.concatenate(\n                    [self.initial_type, np.array([\"Fix\"], dtype=object)]\n                )\n            if self.final_type is not None:\n                self.final_type = np.concatenate([self.final_type, np.array([\"Fix\"], dtype=object)])\n\n            # Update dimensions\n            self.shape = new_shape\n            if not augmented:\n                self._true_dim += 1\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    def __getitem__(self, idx):\n        \"\"\"Get a subset of the unified state variables.\n\n        Enables slicing of the unified state to extract subsets of state variables.\n        Returns a new UnifiedState containing only the sliced dimensions.\n\n        Args:\n            idx (slice): Slice object specifying which state dimensions to extract.\n                Only simple slices with step=1 are supported.\n\n        Returns:\n            UnifiedState: New unified state containing only the sliced dimensions\n\n        Raises:\n            NotImplementedError: If idx is not a slice, or if step != 1\n\n        Example:\n            Generate unified state object::\n\n                unified = unify_states([position, velocity], name=\"x\")\n\n            position has shape (3,), velocity has shape (3,)::\n\n                first_three = unified[0:3]  # Extract position only\n                print(first_three.shape)  # (3,)\n                last_three = unified[3:6]  # Extract velocity only\n                print(last_three.shape)  # (3,)\n\n        Note:\n            The sliced state maintains all properties (bounds, guesses, etc.) for\n            the selected dimensions. The _true_dim is recalculated based on which\n            dimensions fall within the original true state range.\n        \"\"\"\n        if isinstance(idx, slice):\n            start, stop, step = idx.indices(self.shape[0])\n            if step != 1:\n                raise NotImplementedError(\"Step slicing not supported\")\n\n            new_shape = (stop - start,)\n            new_name = f\"{self.name}[{start}:{stop}]\"\n\n            # Slice all arrays\n            new_min = self.min[idx] if self.min is not None else None\n            new_max = self.max[idx] if self.max is not None else None\n            new_guess = self.guess[:, idx] if self.guess is not None else None\n            new_initial = self.initial[idx] if self.initial is not None else None\n            new_final = self.final[idx] if self.final is not None else None\n            new__initial = self._initial[idx] if self._initial is not None else None\n            new__final = self._final[idx] if self._final is not None else None\n            new_initial_type = self.initial_type[idx] if self.initial_type is not None else None\n            new_final_type = self.final_type[idx] if self.final_type is not None else None\n\n            # Calculate new true dimension\n            new_true_dim = max(0, min(stop, self._true_dim) - max(start, 0))\n\n            return UnifiedState(\n                name=new_name,\n                shape=new_shape,\n                min=new_min,\n                max=new_max,\n                guess=new_guess,\n                initial=new_initial,\n                final=new_final,\n                _initial=new__initial,\n                _final=new__final,\n                initial_type=new_initial_type,\n                final_type=new_final_type,\n                _true_dim=new_true_dim,\n                _true_slice=slice(0, new_true_dim),\n                _augmented_slice=slice(new_true_dim, new_shape[0]),\n            )\n        else:\n            raise NotImplementedError(\"Only slice indexing is supported\")\n\n    def __repr__(self):\n        \"\"\"String representation of the UnifiedState object.\"\"\"\n        return f\"UnifiedState('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/lowered/unified/#openscvx.lowered.unified.UnifiedState.augmented","title":"<code>augmented: UnifiedState</code>  <code>property</code>","text":"<p>Get the augmented (internal) state variables.</p> <p>Returns a view of the unified state containing only augmented states added internally by the optimization framework (e.g., CTCS penalty states, time variables).</p> <p>Returns:</p> Name Type Description <code>UnifiedState</code> <code>UnifiedState</code> <p>Sliced view containing only augmented state variables</p> Example <p>Get augmented state::</p> <pre><code>unified = unify_states([position, ctcs_aug], name=\"x\")\naug_states = unified.augmented  # Only CTCS states\n</code></pre>"},{"location":"reference/lowered/unified/#openscvx.lowered.unified.UnifiedState.true","title":"<code>true: UnifiedState</code>  <code>property</code>","text":"<p>Get the true (user-defined) state variables.</p> <p>Returns a view of the unified state containing only user-defined states, excluding internal augmented states added for CTCS, time, etc.</p> <p>Returns:</p> Name Type Description <code>UnifiedState</code> <code>UnifiedState</code> <p>Sliced view containing only true state variables</p> Example <p>Get true user-defined state::</p> <pre><code>unified = unify_states([position, velocity, ctcs_aug], name=\"x\")\ntrue_states = unified.true  # Only position and velocity\ntrue_states.shape  # (6,) if position and velocity are 3D each\n</code></pre>"},{"location":"reference/lowered/unified/#openscvx.lowered.unified.UnifiedState.append","title":"<code>append(other: Optional[State | UnifiedState] = None, *, min=-np.inf, max=np.inf, guess=0.0, initial=0.0, final=0.0, augmented=False)</code>","text":"<p>Append another state or create a new state variable.</p> <p>This method allows dynamic extension of the unified state, either by appending another State/UnifiedState object or by creating a new scalar state variable with specified properties. Modifies the unified state in-place.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Optional[State | UnifiedState]</code> <p>State object to append. If None, creates a new scalar state variable with properties from keyword args.</p> <code>None</code> <code>min</code> <code>float</code> <p>Lower bound for new scalar state (default: -inf)</p> <code>-inf</code> <code>max</code> <code>float</code> <p>Upper bound for new scalar state (default: inf)</p> <code>inf</code> <code>guess</code> <code>float</code> <p>Initial guess value for new scalar state (default: 0.0)</p> <code>0.0</code> <code>initial</code> <code>float</code> <p>Initial boundary condition for new scalar state (default: 0.0)</p> <code>0.0</code> <code>final</code> <code>float</code> <p>Final boundary condition for new scalar state (default: 0.0)</p> <code>0.0</code> <code>augmented</code> <code>bool</code> <p>Whether the appended state is augmented (internal) rather than true (user-defined). Affects _true_dim tracking. Default: False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <p>Modifies the unified state in-place</p> Example <p>Appending a State object::</p> <pre><code>unified = unify_states([position], name=\"x\")\nvelocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\nunified.append(velocity)\nprint(unified.shape)  # (6,) - position (3) + velocity (3)\n</code></pre> <p>Creating new scalar state variables::</p> <pre><code>unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.5)  # Add scalar state\nunified.append(min=-2, max=2, augmented=True)  # Add augmented state\nprint(unified.shape)  # (2,)\nprint(unified._true_dim)  # 1 (only first is true)\n</code></pre> Note <p>Maintains the invariant that true states appear before augmented states in the unified vector. When appending augmented states, they are added to the end but don't increment _true_dim.</p> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>def append(\n    self,\n    other: \"Optional[State | UnifiedState]\" = None,\n    *,\n    min=-np.inf,\n    max=np.inf,\n    guess=0.0,\n    initial=0.0,\n    final=0.0,\n    augmented=False,\n):\n    \"\"\"Append another state or create a new state variable.\n\n    This method allows dynamic extension of the unified state, either by appending\n    another State/UnifiedState object or by creating a new scalar state variable\n    with specified properties. Modifies the unified state in-place.\n\n    Args:\n        other (Optional[State | UnifiedState]): State object to append. If None,\n            creates a new scalar state variable with properties from keyword args.\n        min (float): Lower bound for new scalar state (default: -inf)\n        max (float): Upper bound for new scalar state (default: inf)\n        guess (float): Initial guess value for new scalar state (default: 0.0)\n        initial (float): Initial boundary condition for new scalar state (default: 0.0)\n        final (float): Final boundary condition for new scalar state (default: 0.0)\n        augmented (bool): Whether the appended state is augmented (internal) rather\n            than true (user-defined). Affects _true_dim tracking. Default: False\n\n    Returns:\n        None: Modifies the unified state in-place\n\n    Example:\n        Appending a State object::\n\n            unified = unify_states([position], name=\"x\")\n            velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n            unified.append(velocity)\n            print(unified.shape)  # (6,) - position (3) + velocity (3)\n\n        Creating new scalar state variables::\n\n            unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.5)  # Add scalar state\n            unified.append(min=-2, max=2, augmented=True)  # Add augmented state\n            print(unified.shape)  # (2,)\n            print(unified._true_dim)  # 1 (only first is true)\n\n    Note:\n        Maintains the invariant that true states appear before augmented states\n        in the unified vector. When appending augmented states, they are added\n        to the end but don't increment _true_dim.\n    \"\"\"\n    # Import here to avoid circular imports at module level\n    from openscvx.symbolic.expr.state import State\n\n    if isinstance(other, (State, UnifiedState)):\n        # Append another state object\n        new_shape = (self.shape[0] + other.shape[0],)\n\n        # Update bounds\n        if self.min is not None and other.min is not None:\n            new_min = np.concatenate([self.min, other.min])\n        else:\n            new_min = self.min\n\n        if self.max is not None and other.max is not None:\n            new_max = np.concatenate([self.max, other.max])\n        else:\n            new_max = self.max\n\n        # Update guess\n        if self.guess is not None and other.guess is not None:\n            new_guess = np.concatenate([self.guess, other.guess], axis=1)\n        else:\n            new_guess = self.guess\n\n        # Update initial/final conditions\n        if self.initial is not None and other.initial is not None:\n            new_initial = np.concatenate([self.initial, other.initial])\n        else:\n            new_initial = self.initial\n\n        if self.final is not None and other.final is not None:\n            new_final = np.concatenate([self.final, other.final])\n        else:\n            new_final = self.final\n\n        # Update internal arrays\n        if self._initial is not None and other._initial is not None:\n            new__initial = np.concatenate([self._initial, other._initial])\n        else:\n            new__initial = self._initial\n\n        if self._final is not None and other._final is not None:\n            new__final = np.concatenate([self._final, other._final])\n        else:\n            new__final = self._final\n\n        # Update types\n        if self.initial_type is not None and other.initial_type is not None:\n            new_initial_type = np.concatenate([self.initial_type, other.initial_type])\n        else:\n            new_initial_type = self.initial_type\n\n        if self.final_type is not None and other.final_type is not None:\n            new_final_type = np.concatenate([self.final_type, other.final_type])\n        else:\n            new_final_type = self.final_type\n\n        # Update true dimension\n        if not augmented:\n            new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n        else:\n            new_true_dim = self._true_dim\n\n        # Update all attributes in place\n        self.shape = new_shape\n        self.min = new_min\n        self.max = new_max\n        self.guess = new_guess\n        self.initial = new_initial\n        self.final = new_final\n        self._initial = new__initial\n        self._final = new__final\n        self.initial_type = new_initial_type\n        self.final_type = new_final_type\n        self._true_dim = new_true_dim\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    else:\n        # Create a single new variable\n        new_shape = (self.shape[0] + 1,)\n\n        # Extend arrays\n        if self.min is not None:\n            self.min = np.concatenate([self.min, np.array([min])])\n        if self.max is not None:\n            self.max = np.concatenate([self.max, np.array([max])])\n        if self.guess is not None:\n            guess_arr = np.full((self.guess.shape[0], 1), guess)\n            self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n        if self.initial is not None:\n            self.initial = np.concatenate([self.initial, np.array([initial])])\n        if self.final is not None:\n            self.final = np.concatenate([self.final, np.array([final])])\n        if self._initial is not None:\n            self._initial = np.concatenate([self._initial, np.array([initial])])\n        if self._final is not None:\n            self._final = np.concatenate([self._final, np.array([final])])\n        if self.initial_type is not None:\n            self.initial_type = np.concatenate(\n                [self.initial_type, np.array([\"Fix\"], dtype=object)]\n            )\n        if self.final_type is not None:\n            self.final_type = np.concatenate([self.final_type, np.array([\"Fix\"], dtype=object)])\n\n        # Update dimensions\n        self.shape = new_shape\n        if not augmented:\n            self._true_dim += 1\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n</code></pre>"},{"location":"reference/plotting/","title":"plotting","text":"<p>Trajectory visualization and plotting utilities.</p> <p>Important</p> <p>THIS MODULE IS IN MAJOR NEED OF REFACTORING AND SHOULD NOT BE USED.</p> <p>The plotting module is currently undergoing significant restructuring and should be considered unstable. The API is subject to change without notice. Use at your own risk.</p> <p>This module provides visualization utilities for trajectory optimization results. It includes functions for plotting state trajectories, control inputs, constraint violations, and creating animations of the optimization process.</p>"},{"location":"reference/plotting/#openscvx.plotting.qdcm","title":"<code>qdcm(q: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Convert a quaternion to a direction cosine matrix (DCM).</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>ndarray</code> <p>Quaternion array [w, x, y, z] where w is the scalar part</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix (direction cosine matrix)</p> Source code in <code>openscvx/plotting/plotting.py</code> <pre><code>def qdcm(q: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Convert a quaternion to a direction cosine matrix (DCM).\n\n    Args:\n        q: Quaternion array [w, x, y, z] where w is the scalar part\n\n    Returns:\n        3x3 rotation matrix (direction cosine matrix)\n    \"\"\"\n    q_norm = (q[0] ** 2 + q[1] ** 2 + q[2] ** 2 + q[3] ** 2) ** 0.5\n    w, x, y, z = q / q_norm\n    return np.array(\n        [\n            [1 - 2 * (y**2 + z**2), 2 * (x * y - z * w), 2 * (x * z + y * w)],\n            [2 * (x * y + z * w), 1 - 2 * (x**2 + z**2), 2 * (y * z - x * w)],\n            [2 * (x * z - y * w), 2 * (y * z + x * w), 1 - 2 * (x**2 + y**2)],\n        ]\n    )\n</code></pre>"},{"location":"reference/plotting/plotting/","title":"plotting","text":""},{"location":"reference/plotting/plotting/#openscvx.plotting.plotting.qdcm","title":"<code>qdcm(q: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Convert a quaternion to a direction cosine matrix (DCM).</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>ndarray</code> <p>Quaternion array [w, x, y, z] where w is the scalar part</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix (direction cosine matrix)</p> Source code in <code>openscvx/plotting/plotting.py</code> <pre><code>def qdcm(q: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Convert a quaternion to a direction cosine matrix (DCM).\n\n    Args:\n        q: Quaternion array [w, x, y, z] where w is the scalar part\n\n    Returns:\n        3x3 rotation matrix (direction cosine matrix)\n    \"\"\"\n    q_norm = (q[0] ** 2 + q[1] ** 2 + q[2] ** 2 + q[3] ** 2) ** 0.5\n    w, x, y, z = q / q_norm\n    return np.array(\n        [\n            [1 - 2 * (y**2 + z**2), 2 * (x * y - z * w), 2 * (x * z + y * w)],\n            [2 * (x * y + z * w), 1 - 2 * (x**2 + z**2), 2 * (y * z - x * w)],\n            [2 * (x * z - y * w), 2 * (y * z + x * w), 1 - 2 * (x**2 + y**2)],\n        ]\n    )\n</code></pre>"},{"location":"reference/propagation/","title":"propagation","text":"<p>Trajectory propagation for trajectory optimization.</p> <p>This module provides implementations of trajectory propagation methods that simulate the nonlinear system dynamics forward in time. Propagation is used to evaluate solution quality, verify constraint satisfaction, and generate high-fidelity trajectories from optimized control sequences.</p> Current Implementations <p>Forward Simulation: The default propagation method that integrates the     nonlinear dynamics forward in time using adaptive or fixed-step     numerical integration (via Diffrax). Supports both ZOH and FOH     control interpolation schemes.</p> <p>Planned Architecture (ABC-based):</p> <p>A base class will be introduced to enable pluggable propagation methods. This will enable users to implement custom propagation methods. Future propagators will implement the Propagator interface:</p> <pre><code># propagation/base.py (planned):\nclass Propagator(ABC):\n    def __init__(self, integrator: Integrator):\n        '''Initialize with a numerical integrator.'''\n        self.integrator = integrator\n\n    @abstractmethod\n    def propagate(self, dynamics, x0, u_traj, time_grid) -&gt; Array:\n        '''Propagate trajectory forward in time.\n\n        Args:\n            dynamics: Continuous-time dynamics object\n            x0: Initial state\n            u_traj: Control trajectory\n            time_grid: Time points for dense output\n\n        Returns:\n            State trajectory evaluated at time_grid points\n        '''\n        ...\n</code></pre>"},{"location":"reference/propagation/#openscvx.propagation.get_propagation_solver","title":"<code>get_propagation_solver(state_dot: Dynamics, settings: Config)</code>","text":"<p>Create a propagation solver function.</p> <p>This function creates a solver that propagates the system state using the specified dynamics and settings.</p> <p>Parameters:</p> Name Type Description Default <code>state_dot</code> <code>callable</code> <p>Function computing state derivatives.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings for propagation.</p> required <code>param_map</code> <code>dict</code> <p>Mapping of parameter names to values.</p> required <p>Returns:</p> Name Type Description <code>callable</code> <p>A function that solves the propagation problem.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def get_propagation_solver(state_dot: Dynamics, settings: Config):\n    \"\"\"Create a propagation solver function.\n\n    This function creates a solver that propagates the system state using the\n    specified dynamics and settings.\n\n    Args:\n        state_dot (callable): Function computing state derivatives.\n        settings: Configuration settings for propagation.\n        param_map (dict): Mapping of parameter names to values.\n\n    Returns:\n        callable: A function that solves the propagation problem.\n    \"\"\"\n\n    def propagation_solver(\n        V0, tau_grid, u_cur, u_next, tau_init, node, idx_s, save_time, mask, params\n    ):\n        param_map_update = params\n        return solve_ivp_diffrax_prop(\n            f=prop_aug_dy,\n            tau_final=tau_grid[1],  # scalar\n            y_0=V0,  # shape (n_states,)\n            args=(\n                u_cur,  # shape (1, n_controls)\n                u_next,  # shape (1, n_controls)\n                tau_init,  # shape (1, 1)\n                node,  # shape (1, 1)\n                idx_s,  # int\n                state_dot,  # function or array\n                settings.dis.dis_type,\n                settings.scp.n,\n                param_map_update,\n                # additional named parameters as **kwargs\n            ),\n            tau_0=tau_grid[0],  # scalar\n            solver_name=settings.prp.solver,\n            rtol=settings.prp.rtol,\n            atol=settings.prp.atol,\n            extra_kwargs=settings.prp.args,\n            save_time=save_time,  # shape (MAX_TAU_LEN,)\n            mask=mask,  # shape (MAX_TAU_LEN,), dtype=bool\n        )\n\n    return propagation_solver\n</code></pre>"},{"location":"reference/propagation/#openscvx.propagation.prop_aug_dy","title":"<code>prop_aug_dy(tau: float, x: np.ndarray, u_current: np.ndarray, u_next: np.ndarray, tau_init: float, node: int, idx_s: int, state_dot: callable, dis_type: str, N: int, params) -&gt; np.ndarray</code>","text":"<p>Compute the augmented dynamics for propagation.</p> <p>This function computes the time-scaled dynamics for propagating the system state, taking into account the discretization type (ZOH or FOH) and time dilation.</p> <p>Parameters:</p> Name Type Description Default <code>tau</code> <code>float</code> <p>Current normalized time in [0,1].</p> required <code>x</code> <code>ndarray</code> <p>Current state vector.</p> required <code>u_current</code> <code>ndarray</code> <p>Control input at current node.</p> required <code>u_next</code> <code>ndarray</code> <p>Control input at next node.</p> required <code>tau_init</code> <code>float</code> <p>Initial normalized time.</p> required <code>node</code> <code>int</code> <p>Current node index.</p> required <code>idx_s</code> <code>int</code> <p>Index of time dilation variable in control vector.</p> required <code>state_dot</code> <code>callable</code> <p>Function computing state derivatives.</p> required <code>dis_type</code> <code>str</code> <p>Discretization type (\"ZOH\" or \"FOH\").</p> required <code>N</code> <code>int</code> <p>Number of nodes in trajectory.</p> required <code>params</code> <p>Dictionary of additional parameters passed to state_dot.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Time-scaled state derivatives.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def prop_aug_dy(\n    tau: float,\n    x: np.ndarray,\n    u_current: np.ndarray,\n    u_next: np.ndarray,\n    tau_init: float,\n    node: int,\n    idx_s: int,\n    state_dot: callable,\n    dis_type: str,\n    N: int,\n    params,\n) -&gt; np.ndarray:\n    \"\"\"Compute the augmented dynamics for propagation.\n\n    This function computes the time-scaled dynamics for propagating the system state,\n    taking into account the discretization type (ZOH or FOH) and time dilation.\n\n    Args:\n        tau (float): Current normalized time in [0,1].\n        x (np.ndarray): Current state vector.\n        u_current (np.ndarray): Control input at current node.\n        u_next (np.ndarray): Control input at next node.\n        tau_init (float): Initial normalized time.\n        node (int): Current node index.\n        idx_s (int): Index of time dilation variable in control vector.\n        state_dot (callable): Function computing state derivatives.\n        dis_type (str): Discretization type (\"ZOH\" or \"FOH\").\n        N (int): Number of nodes in trajectory.\n        params: Dictionary of additional parameters passed to state_dot.\n\n    Returns:\n        np.ndarray: Time-scaled state derivatives.\n    \"\"\"\n    x = x[None, :]\n\n    if dis_type == \"ZOH\":\n        beta = 0.0\n    elif dis_type == \"FOH\":\n        beta = (tau - tau_init) * N\n    u = u_current + beta * (u_next - u_current)\n\n    return u[:, idx_s] * state_dot(x, u[:, :-1], node, params).squeeze()\n</code></pre>"},{"location":"reference/propagation/#openscvx.propagation.propagate_trajectory_results","title":"<code>propagate_trajectory_results(params: dict, settings: Config, result: OptimizationResults, propagation_solver: callable) -&gt; OptimizationResults</code>","text":"<p>Propagate the optimal trajectory and compute additional results.</p> <p>This function takes the optimal control solution and propagates it through the nonlinear dynamics to compute the actual state trajectory and other metrics.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>System parameters.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings.</p> required <code>result</code> <code>OptimizationResults</code> <p>Optimization results object.</p> required <code>propagation_solver</code> <code>callable</code> <p>Function for propagating the system state.</p> required <p>Returns:</p> Name Type Description <code>OptimizationResults</code> <code>OptimizationResults</code> <p>Updated results object containing: - t_full: Full time vector - x_full: Full state trajectory - u_full: Full control trajectory - cost: Computed cost - ctcs_violation: CTCS constraint violation</p> Source code in <code>openscvx/propagation/post_processing.py</code> <pre><code>def propagate_trajectory_results(\n    params: dict, settings: Config, result: OptimizationResults, propagation_solver: callable\n) -&gt; OptimizationResults:\n    \"\"\"Propagate the optimal trajectory and compute additional results.\n\n    This function takes the optimal control solution and propagates it through the\n    nonlinear dynamics to compute the actual state trajectory and other metrics.\n\n    Args:\n        params (dict): System parameters.\n        settings (Config): Configuration settings.\n        result (OptimizationResults): Optimization results object.\n        propagation_solver (callable): Function for propagating the system state.\n\n    Returns:\n        OptimizationResults: Updated results object containing:\n            - t_full: Full time vector\n            - x_full: Full state trajectory\n            - u_full: Full control trajectory\n            - cost: Computed cost\n            - ctcs_violation: CTCS constraint violation\n    \"\"\"\n    # Get arrays from result\n    x = result.x\n    u = result.u\n\n    t = np.array(s_to_t(x, u, settings)).squeeze()\n\n    t_full = np.arange(t[0], t[-1], settings.prp.dt)\n\n    tau_vals, u_full = t_to_tau(u, t_full, t, settings)\n\n    # Create a copy of x_prop for propagation to avoid mutating settings\n    # Match free values from initial state to the initial value from the result\n    x_prop_for_propagation = copy.copy(settings.sim.x_prop)\n\n    # Only copy for states that exist in optimization (propagation may have extra states at the end)\n    n_opt_states = x.shape[1]\n    n_prop_states = settings.sim.x_prop.initial.shape[0]\n\n    if n_opt_states == n_prop_states:\n        # Same size - copy all\n        # Use metadata from settings (immutable configuration)\n        mask = jnp.array([t == \"Free\" for t in settings.sim.x.initial_type], dtype=bool)\n        x_prop_for_propagation.initial = jnp.where(mask, x[0, :], settings.sim.x_prop.initial)\n    else:\n        # Propagation has extra states - only copy the overlapping portion\n        # Use metadata from settings (immutable configuration)\n        mask = jnp.array([t == \"Free\" for t in settings.sim.x.initial_type], dtype=bool)\n        x_prop_initial_updated = settings.sim.x_prop.initial.copy()\n        x_prop_initial_updated[:n_opt_states] = jnp.where(\n            mask, x[0, :], settings.sim.x_prop.initial[:n_opt_states]\n        )\n        x_prop_for_propagation.initial = x_prop_initial_updated\n\n    # Temporarily replace x_prop with our modified copy for propagation\n    # Save original to restore after propagation\n    original_x_prop = settings.sim.x_prop\n    settings.sim.x_prop = x_prop_for_propagation\n\n    try:\n        x_full = simulate_nonlinear_time(params, x, u, tau_vals, t, settings, propagation_solver)\n    finally:\n        # Always restore original x_prop, even if propagation fails\n        settings.sim.x_prop = original_x_prop\n\n    # Calculate cost using utility function and metadata from settings\n    cost = calculate_cost_from_boundaries(x, settings.sim.x.initial_type, settings.sim.x.final_type)\n\n    # Calculate CTCS constraint violation\n    ctcs_violation = x_full[-1, settings.sim.ctcs_slice_prop]\n\n    # Build trajectory dictionary with all states and controls\n    trajectory_dict = {}\n\n    # Add all states (user-defined and augmented)\n    for state in result._states:\n        trajectory_dict[state.name] = x_full[:, state._slice]\n\n    # Add all controls (user-defined and augmented)\n    for control in result._controls:\n        trajectory_dict[control.name] = u_full[:, control._slice]\n\n    # Update the results object with post-processing data\n    result.t_full = t_full\n    result.x_full = x_full\n    result.u_full = u_full\n    result.cost = cost\n    result.ctcs_violation = ctcs_violation\n    result.trajectory = trajectory_dict\n\n    return result\n</code></pre>"},{"location":"reference/propagation/#openscvx.propagation.s_to_t","title":"<code>s_to_t(x: np.ndarray, u: np.ndarray, settings: Config)</code>","text":"<p>Convert normalized time s to real time t.</p> <p>This function converts the normalized time variable s to real time t based on the discretization type and time dilation factors.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>State trajectory array, shape (N, n_states).</p> required <code>u</code> <code>ndarray</code> <p>Control trajectory array, shape (N, n_controls).</p> required <code>settings</code> <code>Config</code> <p>Configuration settings.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of real time points.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def s_to_t(x: np.ndarray, u: np.ndarray, settings: Config):\n    \"\"\"Convert normalized time s to real time t.\n\n    This function converts the normalized time variable s to real time t\n    based on the discretization type and time dilation factors.\n\n    Args:\n        x: State trajectory array, shape (N, n_states).\n        u: Control trajectory array, shape (N, n_controls).\n        settings (Config): Configuration settings.\n\n    Returns:\n        list: List of real time points.\n    \"\"\"\n    t = [x[:, settings.sim.time_slice][0]]\n    tau = np.linspace(0, 1, settings.scp.n)\n    for k in range(1, settings.scp.n):\n        s_kp = u[k - 1, -1]\n        s_k = u[k, -1]\n        if settings.dis.dis_type == \"ZOH\":\n            t.append(t[k - 1] + (tau[k] - tau[k - 1]) * (s_kp))\n        else:\n            t.append(t[k - 1] + 0.5 * (s_k + s_kp) * (tau[k] - tau[k - 1]))\n    return t\n</code></pre>"},{"location":"reference/propagation/#openscvx.propagation.simulate_nonlinear_time","title":"<code>simulate_nonlinear_time(params, x, u, tau_vals, t, settings, propagation_solver)</code>","text":"<p>Simulate the nonlinear system dynamics over time.</p> <p>This function simulates the system dynamics using the optimal control sequence and returns the resulting state trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <p>System parameters.</p> required <code>x</code> <p>State trajectory array, shape (N, n_states).</p> required <code>u</code> <p>Control trajectory array, shape (N, n_controls).</p> required <code>tau_vals</code> <code>ndarray</code> <p>Normalized time points for simulation.</p> required <code>t</code> <code>ndarray</code> <p>Real time points.</p> required <code>settings</code> <p>Configuration settings.</p> required <code>propagation_solver</code> <code>callable</code> <p>Function for propagating the system state.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Simulated state trajectory.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def simulate_nonlinear_time(params, x, u, tau_vals, t, settings, propagation_solver):\n    \"\"\"Simulate the nonlinear system dynamics over time.\n\n    This function simulates the system dynamics using the optimal control sequence\n    and returns the resulting state trajectory.\n\n    Args:\n        params: System parameters.\n        x: State trajectory array, shape (N, n_states).\n        u: Control trajectory array, shape (N, n_controls).\n        tau_vals (np.ndarray): Normalized time points for simulation.\n        t (np.ndarray): Real time points.\n        settings: Configuration settings.\n        propagation_solver (callable): Function for propagating the system state.\n\n    Returns:\n        np.ndarray: Simulated state trajectory.\n    \"\"\"\n    x_0 = settings.sim.x_prop.initial\n\n    n_segments = settings.scp.n - 1\n    n_states = x_0.shape[0]\n    n_tau = len(tau_vals)\n\n    states = np.empty((n_states, n_tau))\n    tau = np.linspace(0, 1, settings.scp.n)\n\n    # Precompute control interpolation\n    u_interp = np.stack([np.interp(t, t, u[:, i]) for i in range(u.shape[1])], axis=-1)\n\n    # Bin tau_vals into segments of tau\n    tau_inds = np.digitize(tau_vals, tau) - 1\n    tau_inds = np.where(tau_inds == settings.scp.n - 1, settings.scp.n - 2, tau_inds)\n\n    prev_count = 0\n    out_idx = 0\n\n    for k in range(n_segments):\n        controls_current = u_interp[k][None, :]\n        controls_next = u_interp[k + 1][None, :]\n\n        # Mask for tau_vals in current segment\n        mask = (tau_inds &gt;= k) &amp; (tau_inds &lt; k + 1)\n        count = np.sum(mask)\n\n        tau_cur = tau_vals[prev_count : prev_count + count]\n        tau_cur = np.concatenate([tau_cur, np.array([tau[k + 1]])])  # Always include final point\n        count += 1\n\n        # Pad to fixed length\n        pad_len = settings.prp.max_tau_len - count\n        tau_cur_padded = np.pad(tau_cur, (0, pad_len), constant_values=tau[k + 1])\n        mask_padded = np.concatenate([np.ones(count), np.zeros(pad_len)]).astype(bool)\n\n        # Call the solver with padded tau_cur and mask\n        sol = propagation_solver.call(\n            x_0,\n            (tau[k], tau[k + 1]),\n            controls_current,\n            controls_next,\n            np.array([[tau[k]]]),\n            np.array([[k]]),\n            settings.sim.time_dilation_slice.stop,\n            tau_cur_padded,\n            mask_padded,\n            params,\n        )\n\n        # Only store the valid portion (excluding the final point which becomes next x_0)\n        states[:, out_idx : out_idx + count - 1] = sol[: count - 1].T\n        out_idx += count - 1\n        x_0 = sol[count - 1]  # Last value used as next x_0\n\n        prev_count += count - 1\n\n    return states.T\n</code></pre>"},{"location":"reference/propagation/#openscvx.propagation.t_to_tau","title":"<code>t_to_tau(u: np.ndarray, t, t_nodal, settings: Config)</code>","text":"<p>Convert real time t to normalized time tau.</p> <p>This function converts real time t to normalized time tau and interpolates the control inputs accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>ndarray</code> <p>Control trajectory array, shape (N, n_controls).</p> required <code>t</code> <code>ndarray</code> <p>Real time points.</p> required <code>t_nodal</code> <code>ndarray</code> <p>Nodal time points.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(tau, u_interp) where tau is normalized time and u_interp is interpolated controls.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def t_to_tau(u: np.ndarray, t, t_nodal, settings: Config):\n    \"\"\"Convert real time t to normalized time tau.\n\n    This function converts real time t to normalized time tau and interpolates\n    the control inputs accordingly.\n\n    Args:\n        u (np.ndarray): Control trajectory array, shape (N, n_controls).\n        t (np.ndarray): Real time points.\n        t_nodal (np.ndarray): Nodal time points.\n        settings (Config): Configuration settings.\n\n    Returns:\n        tuple: (tau, u_interp) where tau is normalized time and u_interp is interpolated controls.\n    \"\"\"\n    if settings.dis.dis_type == \"ZOH\":\n        # Zero-Order Hold: step interpolation (hold previous value)\n        def u_lam(new_t):\n            # Find the index of the last nodal time &lt;= new_t\n            idx = np.searchsorted(t_nodal, new_t, side=\"right\") - 1\n            idx = np.clip(idx, 0, len(t_nodal) - 1)\n            return u[idx, :]\n    elif settings.dis.dis_type == \"FOH\":\n        # First-Order Hold: linear interpolation\n        def u_lam(new_t):\n            return np.array([np.interp(new_t, t_nodal, u[:, i]) for i in range(u.shape[1])]).T\n    else:\n        raise ValueError(\"Currently unsupported discretization type\")\n\n    u_interp = np.array([u_lam(t_i) for t_i in t])\n\n    tau = np.zeros(len(t))\n    tau_nodal = np.linspace(0, 1, settings.scp.n)\n    for k in range(1, len(t)):\n        k_nodal = np.where(t_nodal &lt; t[k])[0][-1]\n        s_kp = u[k_nodal, -1]\n        tp = t_nodal[k_nodal]\n        tau_p = tau_nodal[k_nodal]\n\n        s_k = u[k_nodal + 1, -1]\n        if settings.dis.dis_type == \"ZOH\":\n            tau[k] = tau_p + (t[k] - tp) / s_kp\n        else:\n            tau[k] = tau_p + 2 * (t[k] - tp) / (s_k + s_kp)\n    return tau, u_interp\n</code></pre>"},{"location":"reference/propagation/post_processing/","title":"post_processing","text":""},{"location":"reference/propagation/post_processing/#openscvx.propagation.post_processing.propagate_trajectory_results","title":"<code>propagate_trajectory_results(params: dict, settings: Config, result: OptimizationResults, propagation_solver: callable) -&gt; OptimizationResults</code>","text":"<p>Propagate the optimal trajectory and compute additional results.</p> <p>This function takes the optimal control solution and propagates it through the nonlinear dynamics to compute the actual state trajectory and other metrics.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>System parameters.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings.</p> required <code>result</code> <code>OptimizationResults</code> <p>Optimization results object.</p> required <code>propagation_solver</code> <code>callable</code> <p>Function for propagating the system state.</p> required <p>Returns:</p> Name Type Description <code>OptimizationResults</code> <code>OptimizationResults</code> <p>Updated results object containing: - t_full: Full time vector - x_full: Full state trajectory - u_full: Full control trajectory - cost: Computed cost - ctcs_violation: CTCS constraint violation</p> Source code in <code>openscvx/propagation/post_processing.py</code> <pre><code>def propagate_trajectory_results(\n    params: dict, settings: Config, result: OptimizationResults, propagation_solver: callable\n) -&gt; OptimizationResults:\n    \"\"\"Propagate the optimal trajectory and compute additional results.\n\n    This function takes the optimal control solution and propagates it through the\n    nonlinear dynamics to compute the actual state trajectory and other metrics.\n\n    Args:\n        params (dict): System parameters.\n        settings (Config): Configuration settings.\n        result (OptimizationResults): Optimization results object.\n        propagation_solver (callable): Function for propagating the system state.\n\n    Returns:\n        OptimizationResults: Updated results object containing:\n            - t_full: Full time vector\n            - x_full: Full state trajectory\n            - u_full: Full control trajectory\n            - cost: Computed cost\n            - ctcs_violation: CTCS constraint violation\n    \"\"\"\n    # Get arrays from result\n    x = result.x\n    u = result.u\n\n    t = np.array(s_to_t(x, u, settings)).squeeze()\n\n    t_full = np.arange(t[0], t[-1], settings.prp.dt)\n\n    tau_vals, u_full = t_to_tau(u, t_full, t, settings)\n\n    # Create a copy of x_prop for propagation to avoid mutating settings\n    # Match free values from initial state to the initial value from the result\n    x_prop_for_propagation = copy.copy(settings.sim.x_prop)\n\n    # Only copy for states that exist in optimization (propagation may have extra states at the end)\n    n_opt_states = x.shape[1]\n    n_prop_states = settings.sim.x_prop.initial.shape[0]\n\n    if n_opt_states == n_prop_states:\n        # Same size - copy all\n        # Use metadata from settings (immutable configuration)\n        mask = jnp.array([t == \"Free\" for t in settings.sim.x.initial_type], dtype=bool)\n        x_prop_for_propagation.initial = jnp.where(mask, x[0, :], settings.sim.x_prop.initial)\n    else:\n        # Propagation has extra states - only copy the overlapping portion\n        # Use metadata from settings (immutable configuration)\n        mask = jnp.array([t == \"Free\" for t in settings.sim.x.initial_type], dtype=bool)\n        x_prop_initial_updated = settings.sim.x_prop.initial.copy()\n        x_prop_initial_updated[:n_opt_states] = jnp.where(\n            mask, x[0, :], settings.sim.x_prop.initial[:n_opt_states]\n        )\n        x_prop_for_propagation.initial = x_prop_initial_updated\n\n    # Temporarily replace x_prop with our modified copy for propagation\n    # Save original to restore after propagation\n    original_x_prop = settings.sim.x_prop\n    settings.sim.x_prop = x_prop_for_propagation\n\n    try:\n        x_full = simulate_nonlinear_time(params, x, u, tau_vals, t, settings, propagation_solver)\n    finally:\n        # Always restore original x_prop, even if propagation fails\n        settings.sim.x_prop = original_x_prop\n\n    # Calculate cost using utility function and metadata from settings\n    cost = calculate_cost_from_boundaries(x, settings.sim.x.initial_type, settings.sim.x.final_type)\n\n    # Calculate CTCS constraint violation\n    ctcs_violation = x_full[-1, settings.sim.ctcs_slice_prop]\n\n    # Build trajectory dictionary with all states and controls\n    trajectory_dict = {}\n\n    # Add all states (user-defined and augmented)\n    for state in result._states:\n        trajectory_dict[state.name] = x_full[:, state._slice]\n\n    # Add all controls (user-defined and augmented)\n    for control in result._controls:\n        trajectory_dict[control.name] = u_full[:, control._slice]\n\n    # Update the results object with post-processing data\n    result.t_full = t_full\n    result.x_full = x_full\n    result.u_full = u_full\n    result.cost = cost\n    result.ctcs_violation = ctcs_violation\n    result.trajectory = trajectory_dict\n\n    return result\n</code></pre>"},{"location":"reference/propagation/propagation/","title":"propagation","text":""},{"location":"reference/propagation/propagation/#openscvx.propagation.propagation.get_propagation_solver","title":"<code>get_propagation_solver(state_dot: Dynamics, settings: Config)</code>","text":"<p>Create a propagation solver function.</p> <p>This function creates a solver that propagates the system state using the specified dynamics and settings.</p> <p>Parameters:</p> Name Type Description Default <code>state_dot</code> <code>callable</code> <p>Function computing state derivatives.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings for propagation.</p> required <code>param_map</code> <code>dict</code> <p>Mapping of parameter names to values.</p> required <p>Returns:</p> Name Type Description <code>callable</code> <p>A function that solves the propagation problem.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def get_propagation_solver(state_dot: Dynamics, settings: Config):\n    \"\"\"Create a propagation solver function.\n\n    This function creates a solver that propagates the system state using the\n    specified dynamics and settings.\n\n    Args:\n        state_dot (callable): Function computing state derivatives.\n        settings: Configuration settings for propagation.\n        param_map (dict): Mapping of parameter names to values.\n\n    Returns:\n        callable: A function that solves the propagation problem.\n    \"\"\"\n\n    def propagation_solver(\n        V0, tau_grid, u_cur, u_next, tau_init, node, idx_s, save_time, mask, params\n    ):\n        param_map_update = params\n        return solve_ivp_diffrax_prop(\n            f=prop_aug_dy,\n            tau_final=tau_grid[1],  # scalar\n            y_0=V0,  # shape (n_states,)\n            args=(\n                u_cur,  # shape (1, n_controls)\n                u_next,  # shape (1, n_controls)\n                tau_init,  # shape (1, 1)\n                node,  # shape (1, 1)\n                idx_s,  # int\n                state_dot,  # function or array\n                settings.dis.dis_type,\n                settings.scp.n,\n                param_map_update,\n                # additional named parameters as **kwargs\n            ),\n            tau_0=tau_grid[0],  # scalar\n            solver_name=settings.prp.solver,\n            rtol=settings.prp.rtol,\n            atol=settings.prp.atol,\n            extra_kwargs=settings.prp.args,\n            save_time=save_time,  # shape (MAX_TAU_LEN,)\n            mask=mask,  # shape (MAX_TAU_LEN,), dtype=bool\n        )\n\n    return propagation_solver\n</code></pre>"},{"location":"reference/propagation/propagation/#openscvx.propagation.propagation.prop_aug_dy","title":"<code>prop_aug_dy(tau: float, x: np.ndarray, u_current: np.ndarray, u_next: np.ndarray, tau_init: float, node: int, idx_s: int, state_dot: callable, dis_type: str, N: int, params) -&gt; np.ndarray</code>","text":"<p>Compute the augmented dynamics for propagation.</p> <p>This function computes the time-scaled dynamics for propagating the system state, taking into account the discretization type (ZOH or FOH) and time dilation.</p> <p>Parameters:</p> Name Type Description Default <code>tau</code> <code>float</code> <p>Current normalized time in [0,1].</p> required <code>x</code> <code>ndarray</code> <p>Current state vector.</p> required <code>u_current</code> <code>ndarray</code> <p>Control input at current node.</p> required <code>u_next</code> <code>ndarray</code> <p>Control input at next node.</p> required <code>tau_init</code> <code>float</code> <p>Initial normalized time.</p> required <code>node</code> <code>int</code> <p>Current node index.</p> required <code>idx_s</code> <code>int</code> <p>Index of time dilation variable in control vector.</p> required <code>state_dot</code> <code>callable</code> <p>Function computing state derivatives.</p> required <code>dis_type</code> <code>str</code> <p>Discretization type (\"ZOH\" or \"FOH\").</p> required <code>N</code> <code>int</code> <p>Number of nodes in trajectory.</p> required <code>params</code> <p>Dictionary of additional parameters passed to state_dot.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Time-scaled state derivatives.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def prop_aug_dy(\n    tau: float,\n    x: np.ndarray,\n    u_current: np.ndarray,\n    u_next: np.ndarray,\n    tau_init: float,\n    node: int,\n    idx_s: int,\n    state_dot: callable,\n    dis_type: str,\n    N: int,\n    params,\n) -&gt; np.ndarray:\n    \"\"\"Compute the augmented dynamics for propagation.\n\n    This function computes the time-scaled dynamics for propagating the system state,\n    taking into account the discretization type (ZOH or FOH) and time dilation.\n\n    Args:\n        tau (float): Current normalized time in [0,1].\n        x (np.ndarray): Current state vector.\n        u_current (np.ndarray): Control input at current node.\n        u_next (np.ndarray): Control input at next node.\n        tau_init (float): Initial normalized time.\n        node (int): Current node index.\n        idx_s (int): Index of time dilation variable in control vector.\n        state_dot (callable): Function computing state derivatives.\n        dis_type (str): Discretization type (\"ZOH\" or \"FOH\").\n        N (int): Number of nodes in trajectory.\n        params: Dictionary of additional parameters passed to state_dot.\n\n    Returns:\n        np.ndarray: Time-scaled state derivatives.\n    \"\"\"\n    x = x[None, :]\n\n    if dis_type == \"ZOH\":\n        beta = 0.0\n    elif dis_type == \"FOH\":\n        beta = (tau - tau_init) * N\n    u = u_current + beta * (u_next - u_current)\n\n    return u[:, idx_s] * state_dot(x, u[:, :-1], node, params).squeeze()\n</code></pre>"},{"location":"reference/propagation/propagation/#openscvx.propagation.propagation.s_to_t","title":"<code>s_to_t(x: np.ndarray, u: np.ndarray, settings: Config)</code>","text":"<p>Convert normalized time s to real time t.</p> <p>This function converts the normalized time variable s to real time t based on the discretization type and time dilation factors.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>State trajectory array, shape (N, n_states).</p> required <code>u</code> <code>ndarray</code> <p>Control trajectory array, shape (N, n_controls).</p> required <code>settings</code> <code>Config</code> <p>Configuration settings.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of real time points.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def s_to_t(x: np.ndarray, u: np.ndarray, settings: Config):\n    \"\"\"Convert normalized time s to real time t.\n\n    This function converts the normalized time variable s to real time t\n    based on the discretization type and time dilation factors.\n\n    Args:\n        x: State trajectory array, shape (N, n_states).\n        u: Control trajectory array, shape (N, n_controls).\n        settings (Config): Configuration settings.\n\n    Returns:\n        list: List of real time points.\n    \"\"\"\n    t = [x[:, settings.sim.time_slice][0]]\n    tau = np.linspace(0, 1, settings.scp.n)\n    for k in range(1, settings.scp.n):\n        s_kp = u[k - 1, -1]\n        s_k = u[k, -1]\n        if settings.dis.dis_type == \"ZOH\":\n            t.append(t[k - 1] + (tau[k] - tau[k - 1]) * (s_kp))\n        else:\n            t.append(t[k - 1] + 0.5 * (s_k + s_kp) * (tau[k] - tau[k - 1]))\n    return t\n</code></pre>"},{"location":"reference/propagation/propagation/#openscvx.propagation.propagation.simulate_nonlinear_time","title":"<code>simulate_nonlinear_time(params, x, u, tau_vals, t, settings, propagation_solver)</code>","text":"<p>Simulate the nonlinear system dynamics over time.</p> <p>This function simulates the system dynamics using the optimal control sequence and returns the resulting state trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <p>System parameters.</p> required <code>x</code> <p>State trajectory array, shape (N, n_states).</p> required <code>u</code> <p>Control trajectory array, shape (N, n_controls).</p> required <code>tau_vals</code> <code>ndarray</code> <p>Normalized time points for simulation.</p> required <code>t</code> <code>ndarray</code> <p>Real time points.</p> required <code>settings</code> <p>Configuration settings.</p> required <code>propagation_solver</code> <code>callable</code> <p>Function for propagating the system state.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Simulated state trajectory.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def simulate_nonlinear_time(params, x, u, tau_vals, t, settings, propagation_solver):\n    \"\"\"Simulate the nonlinear system dynamics over time.\n\n    This function simulates the system dynamics using the optimal control sequence\n    and returns the resulting state trajectory.\n\n    Args:\n        params: System parameters.\n        x: State trajectory array, shape (N, n_states).\n        u: Control trajectory array, shape (N, n_controls).\n        tau_vals (np.ndarray): Normalized time points for simulation.\n        t (np.ndarray): Real time points.\n        settings: Configuration settings.\n        propagation_solver (callable): Function for propagating the system state.\n\n    Returns:\n        np.ndarray: Simulated state trajectory.\n    \"\"\"\n    x_0 = settings.sim.x_prop.initial\n\n    n_segments = settings.scp.n - 1\n    n_states = x_0.shape[0]\n    n_tau = len(tau_vals)\n\n    states = np.empty((n_states, n_tau))\n    tau = np.linspace(0, 1, settings.scp.n)\n\n    # Precompute control interpolation\n    u_interp = np.stack([np.interp(t, t, u[:, i]) for i in range(u.shape[1])], axis=-1)\n\n    # Bin tau_vals into segments of tau\n    tau_inds = np.digitize(tau_vals, tau) - 1\n    tau_inds = np.where(tau_inds == settings.scp.n - 1, settings.scp.n - 2, tau_inds)\n\n    prev_count = 0\n    out_idx = 0\n\n    for k in range(n_segments):\n        controls_current = u_interp[k][None, :]\n        controls_next = u_interp[k + 1][None, :]\n\n        # Mask for tau_vals in current segment\n        mask = (tau_inds &gt;= k) &amp; (tau_inds &lt; k + 1)\n        count = np.sum(mask)\n\n        tau_cur = tau_vals[prev_count : prev_count + count]\n        tau_cur = np.concatenate([tau_cur, np.array([tau[k + 1]])])  # Always include final point\n        count += 1\n\n        # Pad to fixed length\n        pad_len = settings.prp.max_tau_len - count\n        tau_cur_padded = np.pad(tau_cur, (0, pad_len), constant_values=tau[k + 1])\n        mask_padded = np.concatenate([np.ones(count), np.zeros(pad_len)]).astype(bool)\n\n        # Call the solver with padded tau_cur and mask\n        sol = propagation_solver.call(\n            x_0,\n            (tau[k], tau[k + 1]),\n            controls_current,\n            controls_next,\n            np.array([[tau[k]]]),\n            np.array([[k]]),\n            settings.sim.time_dilation_slice.stop,\n            tau_cur_padded,\n            mask_padded,\n            params,\n        )\n\n        # Only store the valid portion (excluding the final point which becomes next x_0)\n        states[:, out_idx : out_idx + count - 1] = sol[: count - 1].T\n        out_idx += count - 1\n        x_0 = sol[count - 1]  # Last value used as next x_0\n\n        prev_count += count - 1\n\n    return states.T\n</code></pre>"},{"location":"reference/propagation/propagation/#openscvx.propagation.propagation.t_to_tau","title":"<code>t_to_tau(u: np.ndarray, t, t_nodal, settings: Config)</code>","text":"<p>Convert real time t to normalized time tau.</p> <p>This function converts real time t to normalized time tau and interpolates the control inputs accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>ndarray</code> <p>Control trajectory array, shape (N, n_controls).</p> required <code>t</code> <code>ndarray</code> <p>Real time points.</p> required <code>t_nodal</code> <code>ndarray</code> <p>Nodal time points.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(tau, u_interp) where tau is normalized time and u_interp is interpolated controls.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def t_to_tau(u: np.ndarray, t, t_nodal, settings: Config):\n    \"\"\"Convert real time t to normalized time tau.\n\n    This function converts real time t to normalized time tau and interpolates\n    the control inputs accordingly.\n\n    Args:\n        u (np.ndarray): Control trajectory array, shape (N, n_controls).\n        t (np.ndarray): Real time points.\n        t_nodal (np.ndarray): Nodal time points.\n        settings (Config): Configuration settings.\n\n    Returns:\n        tuple: (tau, u_interp) where tau is normalized time and u_interp is interpolated controls.\n    \"\"\"\n    if settings.dis.dis_type == \"ZOH\":\n        # Zero-Order Hold: step interpolation (hold previous value)\n        def u_lam(new_t):\n            # Find the index of the last nodal time &lt;= new_t\n            idx = np.searchsorted(t_nodal, new_t, side=\"right\") - 1\n            idx = np.clip(idx, 0, len(t_nodal) - 1)\n            return u[idx, :]\n    elif settings.dis.dis_type == \"FOH\":\n        # First-Order Hold: linear interpolation\n        def u_lam(new_t):\n            return np.array([np.interp(new_t, t_nodal, u[:, i]) for i in range(u.shape[1])]).T\n    else:\n        raise ValueError(\"Currently unsupported discretization type\")\n\n    u_interp = np.array([u_lam(t_i) for t_i in t])\n\n    tau = np.zeros(len(t))\n    tau_nodal = np.linspace(0, 1, settings.scp.n)\n    for k in range(1, len(t)):\n        k_nodal = np.where(t_nodal &lt; t[k])[0][-1]\n        s_kp = u[k_nodal, -1]\n        tp = t_nodal[k_nodal]\n        tau_p = tau_nodal[k_nodal]\n\n        s_k = u[k_nodal + 1, -1]\n        if settings.dis.dis_type == \"ZOH\":\n            tau[k] = tau_p + (t[k] - tp) / s_kp\n        else:\n            tau[k] = tau_p + 2 * (t[k] - tp) / (s_k + s_kp)\n    return tau, u_interp\n</code></pre>"},{"location":"reference/solvers/","title":"solvers","text":"<p>Convex subproblem solvers for trajectory optimization.</p> <p>This module provides implementations of convex subproblem solvers used within SCvx algorithms. At each iteration of a successive convexification algorithm, the non-convex problem is approximated by a convex subproblem, which is then solved using one of these solver backends.</p> Current Implementations <p>CVXPy Solver: The default solver backend using CVXPy's modeling language     with support for multiple backend solvers (CLARABEL, etc.).     Includes optional code generation via cvxpygen for improved performance.</p> <p>Planned Architecture (ABC-based):</p> <p>A base class will be introduced to enable pluggable solver implementations. This will enable users to implement custom solver backends such as:</p> <ul> <li>Direct Clarabel solver (Rust-based, GPU-capable)</li> <li>QPAX (JAX-based QP solver for end-to-end differentiability)</li> <li>OSQP direct interface (specialized for QP structure)</li> <li>Custom embedded solvers for real-time applications</li> <li>Research solvers with specialized structure exploitation</li> </ul> <p>This should also make the solver choice independent of the algorithm choice</p> <p>Future solvers will implement the ConvexSolver interface:</p> <pre><code># solvers/base.py (planned):\nclass ConvexSolver(ABC):\n    @abstractmethod\n    def build_subproblem(self, state: SolverState, lowered: LoweredProblem):\n        '''Build the convex subproblem from current state.'''\n        ...\n\n    @abstractmethod\n    def solve(self) -&gt; OptimizationResults:\n        '''Solve the convex subproblem and return results.'''\n        ...\n</code></pre>"},{"location":"reference/solvers/#openscvx.solvers.optimal_control_problem","title":"<code>optimal_control_problem(settings: Config, lowered: LoweredProblem)</code>","text":"<p>Build the complete optimal control problem with all constraints.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Config</code> <p>Configuration settings for the optimization problem</p> required <code>lowered</code> <code>LoweredProblem</code> <p>LoweredProblem containing ocp_vars and lowered constraints</p> required Source code in <code>openscvx/solvers/cvxpy.py</code> <pre><code>def optimal_control_problem(settings: Config, lowered: \"LoweredProblem\"):\n    \"\"\"Build the complete optimal control problem with all constraints.\n\n    Args:\n        settings: Configuration settings for the optimization problem\n        lowered: LoweredProblem containing ocp_vars and lowered constraints\n    \"\"\"\n    # Extract typed CVXPy variables from LoweredProblem\n    ocp_vars = lowered.ocp_vars\n\n    # Extract variables from the dataclass for easier access\n    w_tr = ocp_vars.w_tr\n    lam_cost = ocp_vars.lam_cost\n    lam_vc = ocp_vars.lam_vc\n    lam_vb = ocp_vars.lam_vb\n    x = ocp_vars.x\n    dx = ocp_vars.dx\n    x_bar = ocp_vars.x_bar\n    x_init = ocp_vars.x_init\n    x_term = ocp_vars.x_term\n    u = ocp_vars.u\n    du = ocp_vars.du\n    u_bar = ocp_vars.u_bar\n    A_d = ocp_vars.A_d\n    B_d = ocp_vars.B_d\n    C_d = ocp_vars.C_d\n    x_prop = ocp_vars.x_prop\n    nu = ocp_vars.nu\n    g = ocp_vars.g\n    grad_g_x = ocp_vars.grad_g_x\n    grad_g_u = ocp_vars.grad_g_u\n    nu_vb = ocp_vars.nu_vb\n    g_cross = ocp_vars.g_cross\n    grad_g_X_cross = ocp_vars.grad_g_X_cross\n    grad_g_U_cross = ocp_vars.grad_g_U_cross\n    nu_vb_cross = ocp_vars.nu_vb_cross\n    S_x = ocp_vars.S_x\n    c_x = ocp_vars.c_x\n    S_u = ocp_vars.S_u\n    c_u = ocp_vars.c_u\n    x_nonscaled = ocp_vars.x_nonscaled\n    u_nonscaled = ocp_vars.u_nonscaled\n    dx_nonscaled = ocp_vars.dx_nonscaled\n    du_nonscaled = ocp_vars.du_nonscaled\n\n    # Extract lowered constraints\n    jax_constraints = lowered.jax_constraints\n    cvxpy_constraints = lowered.cvxpy_constraints\n\n    constr = []\n    cost = lam_cost * 0\n    cost += lam_vb * 0\n\n    #############\n    # CONSTRAINTS\n    #############\n\n    # Linearized nodal constraints (from JAX-lowered non-convex)\n    idx_ncvx = 0\n    if jax_constraints.nodal:\n        for constraint in jax_constraints.nodal:\n            # nodes should already be validated and normalized in preprocessing\n            nodes = constraint.nodes\n            constr += [\n                (\n                    g[idx_ncvx][node]\n                    + grad_g_x[idx_ncvx][node] @ dx[node]\n                    + grad_g_u[idx_ncvx][node] @ du[node]\n                )\n                == nu_vb[idx_ncvx][node]\n                for node in nodes\n            ]\n            idx_ncvx += 1\n\n    # Linearized cross-node constraints (from JAX-lowered non-convex)\n    idx_cross = 0\n    if jax_constraints.cross_node:\n        for constraint in jax_constraints.cross_node:\n            # Linearization: g(X_bar, U_bar) + \u2207g_X @ dX + \u2207g_U @ dU == nu_vb\n            # Sum over all trajectory nodes to couple multiple nodes\n            residual = g_cross[idx_cross]\n            for k in range(settings.scp.n):\n                # Contribution from state at node k\n                residual += grad_g_X_cross[idx_cross][k, :] @ dx[k]\n                # Contribution from control at node k\n                residual += grad_g_U_cross[idx_cross][k, :] @ du[k]\n            # Add constraint: residual == slack variable\n            constr += [residual == nu_vb_cross[idx_cross]]\n            idx_cross += 1\n\n    # Convex constraints (already lowered to CVXPy)\n    if cvxpy_constraints.constraints:\n        constr += cvxpy_constraints.constraints\n\n    for i in range(settings.sim.true_state_slice.start, settings.sim.true_state_slice.stop):\n        if settings.sim.x.initial_type[i] == \"Fix\":\n            constr += [x_nonscaled[0][i] == x_init[i]]  # Initial Boundary Conditions\n        if settings.sim.x.final_type[i] == \"Fix\":\n            constr += [x_nonscaled[-1][i] == x_term[i]]  # Final Boundary Conditions\n        if settings.sim.x.initial_type[i] == \"Minimize\":\n            cost += lam_cost * x_nonscaled[0][i]\n        if settings.sim.x.final_type[i] == \"Minimize\":\n            cost += lam_cost * x_nonscaled[-1][i]\n        if settings.sim.x.initial_type[i] == \"Maximize\":\n            cost -= lam_cost * x_nonscaled[0][i]\n        if settings.sim.x.final_type[i] == \"Maximize\":\n            cost -= lam_cost * x_nonscaled[-1][i]\n\n    if settings.scp.uniform_time_grid:\n        constr += [\n            u_nonscaled[i][settings.sim.time_dilation_slice]\n            == u_nonscaled[i - 1][settings.sim.time_dilation_slice]\n            for i in range(1, settings.scp.n)\n        ]\n\n    constr += [\n        (x[i] - np.linalg.inv(S_x) @ (x_bar[i] - c_x) - dx[i]) == 0 for i in range(settings.scp.n)\n    ]  # State Error\n    constr += [\n        (u[i] - np.linalg.inv(S_u) @ (u_bar[i] - c_u) - du[i]) == 0 for i in range(settings.scp.n)\n    ]  # Control Error\n\n    constr += [\n        x_nonscaled[i]\n        == A_d[i - 1] @ dx_nonscaled[i - 1]\n        + B_d[i - 1] @ du_nonscaled[i - 1]\n        + C_d[i - 1] @ du_nonscaled[i]\n        + x_prop[i - 1]\n        + nu[i - 1]\n        for i in range(1, settings.scp.n)\n    ]  # Dynamics Constraint\n\n    constr += [u_nonscaled[i] &lt;= settings.sim.u.max for i in range(settings.scp.n)]\n    constr += [\n        u_nonscaled[i] &gt;= settings.sim.u.min for i in range(settings.scp.n)\n    ]  # Control Constraints\n\n    # TODO: (norrisg) formalize this\n    constr += [x_nonscaled[i][:] &lt;= settings.sim.x.max for i in range(settings.scp.n)]\n    constr += [\n        x_nonscaled[i][:] &gt;= settings.sim.x.min for i in range(settings.scp.n)\n    ]  # State Constraints (Also implemented in CTCS but included for numerical stability)\n\n    ########\n    # COSTS\n    ########\n\n    cost += sum(\n        w_tr * cp.sum_squares(cp.hstack((dx[i], du[i]))) for i in range(settings.scp.n)\n    )  # Trust Region Cost\n    cost += sum(\n        cp.sum(lam_vc[i - 1] * cp.abs(nu[i - 1])) for i in range(1, settings.scp.n)\n    )  # Virtual Control Slack\n\n    idx_ncvx = 0\n    if jax_constraints.nodal:\n        for constraint in jax_constraints.nodal:\n            cost += lam_vb * cp.sum(cp.pos(nu_vb[idx_ncvx]))\n            idx_ncvx += 1\n\n    # Virtual slack penalty for cross-node constraints\n    idx_cross = 0\n    if jax_constraints.cross_node:\n        for constraint in jax_constraints.cross_node:\n            cost += lam_vb * cp.pos(nu_vb_cross[idx_cross])\n            idx_cross += 1\n\n    for idx, nodes in zip(\n        np.arange(settings.sim.ctcs_slice.start, settings.sim.ctcs_slice.stop),\n        settings.sim.ctcs_node_intervals,\n    ):\n        start_idx = 1 if nodes[0] == 0 else nodes[0]\n        constr += [\n            cp.abs(x_nonscaled[i][idx] - x_nonscaled[i - 1][idx]) &lt;= settings.sim.x.max[idx]\n            for i in range(start_idx, nodes[1])\n        ]\n        constr += [x_nonscaled[0][idx] == 0]\n\n    #########\n    # PROBLEM\n    #########\n    prob = cp.Problem(cp.Minimize(cost), constr)\n    if settings.cvx.cvxpygen:\n        if not CVXPYGEN_AVAILABLE:\n            raise ImportError(\n                \"cvxpygen is required for code generation but not installed. \"\n                \"Install it with: pip install openscvx[cvxpygen] or pip install cvxpygen\"\n            )\n        # Check to see if solver directory exists\n        if not os.path.exists(\"solver\"):\n            cpg.generate_code(prob, solver=settings.cvx.solver, code_dir=\"solver\", wrapper=True)\n        else:\n            # Prompt the use to indicate if they wish to overwrite the solver\n            # directory or use the existing compiled solver\n            if settings.cvx.cvxpygen_override:\n                cpg.generate_code(prob, solver=settings.cvx.solver, code_dir=\"solver\", wrapper=True)\n            else:\n                overwrite = input(\"Solver directory already exists. Overwrite? (y/n): \")\n                if overwrite.lower() == \"y\":\n                    cpg.generate_code(\n                        prob, solver=settings.cvx.solver, code_dir=\"solver\", wrapper=True\n                    )\n                else:\n                    pass\n    return prob\n</code></pre>"},{"location":"reference/solvers/cvxpy/","title":"cvxpy","text":""},{"location":"reference/solvers/cvxpy/#openscvx.solvers.cvxpy.optimal_control_problem","title":"<code>optimal_control_problem(settings: Config, lowered: LoweredProblem)</code>","text":"<p>Build the complete optimal control problem with all constraints.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Config</code> <p>Configuration settings for the optimization problem</p> required <code>lowered</code> <code>LoweredProblem</code> <p>LoweredProblem containing ocp_vars and lowered constraints</p> required Source code in <code>openscvx/solvers/cvxpy.py</code> <pre><code>def optimal_control_problem(settings: Config, lowered: \"LoweredProblem\"):\n    \"\"\"Build the complete optimal control problem with all constraints.\n\n    Args:\n        settings: Configuration settings for the optimization problem\n        lowered: LoweredProblem containing ocp_vars and lowered constraints\n    \"\"\"\n    # Extract typed CVXPy variables from LoweredProblem\n    ocp_vars = lowered.ocp_vars\n\n    # Extract variables from the dataclass for easier access\n    w_tr = ocp_vars.w_tr\n    lam_cost = ocp_vars.lam_cost\n    lam_vc = ocp_vars.lam_vc\n    lam_vb = ocp_vars.lam_vb\n    x = ocp_vars.x\n    dx = ocp_vars.dx\n    x_bar = ocp_vars.x_bar\n    x_init = ocp_vars.x_init\n    x_term = ocp_vars.x_term\n    u = ocp_vars.u\n    du = ocp_vars.du\n    u_bar = ocp_vars.u_bar\n    A_d = ocp_vars.A_d\n    B_d = ocp_vars.B_d\n    C_d = ocp_vars.C_d\n    x_prop = ocp_vars.x_prop\n    nu = ocp_vars.nu\n    g = ocp_vars.g\n    grad_g_x = ocp_vars.grad_g_x\n    grad_g_u = ocp_vars.grad_g_u\n    nu_vb = ocp_vars.nu_vb\n    g_cross = ocp_vars.g_cross\n    grad_g_X_cross = ocp_vars.grad_g_X_cross\n    grad_g_U_cross = ocp_vars.grad_g_U_cross\n    nu_vb_cross = ocp_vars.nu_vb_cross\n    S_x = ocp_vars.S_x\n    c_x = ocp_vars.c_x\n    S_u = ocp_vars.S_u\n    c_u = ocp_vars.c_u\n    x_nonscaled = ocp_vars.x_nonscaled\n    u_nonscaled = ocp_vars.u_nonscaled\n    dx_nonscaled = ocp_vars.dx_nonscaled\n    du_nonscaled = ocp_vars.du_nonscaled\n\n    # Extract lowered constraints\n    jax_constraints = lowered.jax_constraints\n    cvxpy_constraints = lowered.cvxpy_constraints\n\n    constr = []\n    cost = lam_cost * 0\n    cost += lam_vb * 0\n\n    #############\n    # CONSTRAINTS\n    #############\n\n    # Linearized nodal constraints (from JAX-lowered non-convex)\n    idx_ncvx = 0\n    if jax_constraints.nodal:\n        for constraint in jax_constraints.nodal:\n            # nodes should already be validated and normalized in preprocessing\n            nodes = constraint.nodes\n            constr += [\n                (\n                    g[idx_ncvx][node]\n                    + grad_g_x[idx_ncvx][node] @ dx[node]\n                    + grad_g_u[idx_ncvx][node] @ du[node]\n                )\n                == nu_vb[idx_ncvx][node]\n                for node in nodes\n            ]\n            idx_ncvx += 1\n\n    # Linearized cross-node constraints (from JAX-lowered non-convex)\n    idx_cross = 0\n    if jax_constraints.cross_node:\n        for constraint in jax_constraints.cross_node:\n            # Linearization: g(X_bar, U_bar) + \u2207g_X @ dX + \u2207g_U @ dU == nu_vb\n            # Sum over all trajectory nodes to couple multiple nodes\n            residual = g_cross[idx_cross]\n            for k in range(settings.scp.n):\n                # Contribution from state at node k\n                residual += grad_g_X_cross[idx_cross][k, :] @ dx[k]\n                # Contribution from control at node k\n                residual += grad_g_U_cross[idx_cross][k, :] @ du[k]\n            # Add constraint: residual == slack variable\n            constr += [residual == nu_vb_cross[idx_cross]]\n            idx_cross += 1\n\n    # Convex constraints (already lowered to CVXPy)\n    if cvxpy_constraints.constraints:\n        constr += cvxpy_constraints.constraints\n\n    for i in range(settings.sim.true_state_slice.start, settings.sim.true_state_slice.stop):\n        if settings.sim.x.initial_type[i] == \"Fix\":\n            constr += [x_nonscaled[0][i] == x_init[i]]  # Initial Boundary Conditions\n        if settings.sim.x.final_type[i] == \"Fix\":\n            constr += [x_nonscaled[-1][i] == x_term[i]]  # Final Boundary Conditions\n        if settings.sim.x.initial_type[i] == \"Minimize\":\n            cost += lam_cost * x_nonscaled[0][i]\n        if settings.sim.x.final_type[i] == \"Minimize\":\n            cost += lam_cost * x_nonscaled[-1][i]\n        if settings.sim.x.initial_type[i] == \"Maximize\":\n            cost -= lam_cost * x_nonscaled[0][i]\n        if settings.sim.x.final_type[i] == \"Maximize\":\n            cost -= lam_cost * x_nonscaled[-1][i]\n\n    if settings.scp.uniform_time_grid:\n        constr += [\n            u_nonscaled[i][settings.sim.time_dilation_slice]\n            == u_nonscaled[i - 1][settings.sim.time_dilation_slice]\n            for i in range(1, settings.scp.n)\n        ]\n\n    constr += [\n        (x[i] - np.linalg.inv(S_x) @ (x_bar[i] - c_x) - dx[i]) == 0 for i in range(settings.scp.n)\n    ]  # State Error\n    constr += [\n        (u[i] - np.linalg.inv(S_u) @ (u_bar[i] - c_u) - du[i]) == 0 for i in range(settings.scp.n)\n    ]  # Control Error\n\n    constr += [\n        x_nonscaled[i]\n        == A_d[i - 1] @ dx_nonscaled[i - 1]\n        + B_d[i - 1] @ du_nonscaled[i - 1]\n        + C_d[i - 1] @ du_nonscaled[i]\n        + x_prop[i - 1]\n        + nu[i - 1]\n        for i in range(1, settings.scp.n)\n    ]  # Dynamics Constraint\n\n    constr += [u_nonscaled[i] &lt;= settings.sim.u.max for i in range(settings.scp.n)]\n    constr += [\n        u_nonscaled[i] &gt;= settings.sim.u.min for i in range(settings.scp.n)\n    ]  # Control Constraints\n\n    # TODO: (norrisg) formalize this\n    constr += [x_nonscaled[i][:] &lt;= settings.sim.x.max for i in range(settings.scp.n)]\n    constr += [\n        x_nonscaled[i][:] &gt;= settings.sim.x.min for i in range(settings.scp.n)\n    ]  # State Constraints (Also implemented in CTCS but included for numerical stability)\n\n    ########\n    # COSTS\n    ########\n\n    cost += sum(\n        w_tr * cp.sum_squares(cp.hstack((dx[i], du[i]))) for i in range(settings.scp.n)\n    )  # Trust Region Cost\n    cost += sum(\n        cp.sum(lam_vc[i - 1] * cp.abs(nu[i - 1])) for i in range(1, settings.scp.n)\n    )  # Virtual Control Slack\n\n    idx_ncvx = 0\n    if jax_constraints.nodal:\n        for constraint in jax_constraints.nodal:\n            cost += lam_vb * cp.sum(cp.pos(nu_vb[idx_ncvx]))\n            idx_ncvx += 1\n\n    # Virtual slack penalty for cross-node constraints\n    idx_cross = 0\n    if jax_constraints.cross_node:\n        for constraint in jax_constraints.cross_node:\n            cost += lam_vb * cp.pos(nu_vb_cross[idx_cross])\n            idx_cross += 1\n\n    for idx, nodes in zip(\n        np.arange(settings.sim.ctcs_slice.start, settings.sim.ctcs_slice.stop),\n        settings.sim.ctcs_node_intervals,\n    ):\n        start_idx = 1 if nodes[0] == 0 else nodes[0]\n        constr += [\n            cp.abs(x_nonscaled[i][idx] - x_nonscaled[i - 1][idx]) &lt;= settings.sim.x.max[idx]\n            for i in range(start_idx, nodes[1])\n        ]\n        constr += [x_nonscaled[0][idx] == 0]\n\n    #########\n    # PROBLEM\n    #########\n    prob = cp.Problem(cp.Minimize(cost), constr)\n    if settings.cvx.cvxpygen:\n        if not CVXPYGEN_AVAILABLE:\n            raise ImportError(\n                \"cvxpygen is required for code generation but not installed. \"\n                \"Install it with: pip install openscvx[cvxpygen] or pip install cvxpygen\"\n            )\n        # Check to see if solver directory exists\n        if not os.path.exists(\"solver\"):\n            cpg.generate_code(prob, solver=settings.cvx.solver, code_dir=\"solver\", wrapper=True)\n        else:\n            # Prompt the use to indicate if they wish to overwrite the solver\n            # directory or use the existing compiled solver\n            if settings.cvx.cvxpygen_override:\n                cpg.generate_code(prob, solver=settings.cvx.solver, code_dir=\"solver\", wrapper=True)\n            else:\n                overwrite = input(\"Solver directory already exists. Overwrite? (y/n): \")\n                if overwrite.lower() == \"y\":\n                    cpg.generate_code(\n                        prob, solver=settings.cvx.solver, code_dir=\"solver\", wrapper=True\n                    )\n                else:\n                    pass\n    return prob\n</code></pre>"},{"location":"reference/symbolic/","title":"symbolic","text":"<p>Symbolic expression system for trajectory optimization.</p> <p>See openscvx.symbolic.expr for detailed documentation and examples.</p>"},{"location":"reference/symbolic/#openscvx.symbolic.ConstraintSet","title":"<code>ConstraintSet</code>  <code>dataclass</code>","text":"<p>Container for categorized symbolic constraints.</p> <p>This dataclass holds all symbolic constraint types in a structured way, providing type safety and a clear API for accessing constraint categories. This is a pre-lowering container - after lowering, constraints live in LoweredJaxConstraints and LoweredCvxpyConstraints.</p> <p>The constraint set supports two lifecycle stages:</p> <ol> <li>Before preprocessing: Raw constraints live in <code>unsorted</code></li> <li>After preprocessing: <code>unsorted</code> is empty, constraints are categorized</li> </ol> <p>Use <code>is_categorized</code> to check which stage the constraint set is in.</p> <p>Attributes:</p> Name Type Description <code>unsorted</code> <code>List[Union[Constraint, CTCS]]</code> <p>Raw constraints before categorization. Empty after preprocessing.</p> <code>ctcs</code> <code>List[CTCS]</code> <p>CTCS (continuous-time) constraints.</p> <code>nodal</code> <code>List[NodalConstraint]</code> <p>Non-convex nodal constraints (will be lowered to JAX).</p> <code>nodal_convex</code> <code>List[NodalConstraint]</code> <p>Convex nodal constraints (will be lowered to CVXPy).</p> <code>cross_node</code> <code>List[CrossNodeConstraint]</code> <p>Non-convex cross-node constraints (will be lowered to JAX).</p> <code>cross_node_convex</code> <code>List[CrossNodeConstraint]</code> <p>Convex cross-node constraints (will be lowered to CVXPy).</p> Example <p>Before preprocessing (raw constraints)::</p> <pre><code>constraints = ConstraintSet(unsorted=[c1, c2, c3])\nassert not constraints.is_categorized\n</code></pre> <p>After preprocessing (categorized)::</p> <pre><code># preprocess_symbolic_problem drains unsorted -&gt; fills categories\nassert constraints.is_categorized\nfor c in constraints.nodal:\n    # Process non-convex nodal constraints\n    pass\n</code></pre> Source code in <code>openscvx/symbolic/constraint_set.py</code> <pre><code>@dataclass\nclass ConstraintSet:\n    \"\"\"Container for categorized symbolic constraints.\n\n    This dataclass holds all symbolic constraint types in a structured way,\n    providing type safety and a clear API for accessing constraint categories.\n    This is a pre-lowering container - after lowering, constraints live in\n    LoweredJaxConstraints and LoweredCvxpyConstraints.\n\n    The constraint set supports two lifecycle stages:\n\n    1. **Before preprocessing**: Raw constraints live in `unsorted`\n    2. **After preprocessing**: `unsorted` is empty, constraints are categorized\n\n    Use `is_categorized` to check which stage the constraint set is in.\n\n    Attributes:\n        unsorted: Raw constraints before categorization. Empty after preprocessing.\n        ctcs: CTCS (continuous-time) constraints.\n        nodal: Non-convex nodal constraints (will be lowered to JAX).\n        nodal_convex: Convex nodal constraints (will be lowered to CVXPy).\n        cross_node: Non-convex cross-node constraints (will be lowered to JAX).\n        cross_node_convex: Convex cross-node constraints (will be lowered to CVXPy).\n\n    Example:\n        Before preprocessing (raw constraints)::\n\n            constraints = ConstraintSet(unsorted=[c1, c2, c3])\n            assert not constraints.is_categorized\n\n        After preprocessing (categorized)::\n\n            # preprocess_symbolic_problem drains unsorted -&gt; fills categories\n            assert constraints.is_categorized\n            for c in constraints.nodal:\n                # Process non-convex nodal constraints\n                pass\n    \"\"\"\n\n    # Raw constraints before categorization (empty after preprocessing)\n    unsorted: List[Union[\"Constraint\", \"CTCS\"]] = field(default_factory=list)\n\n    # Categorized symbolic constraints (populated by preprocessing)\n    ctcs: List[\"CTCS\"] = field(default_factory=list)\n    nodal: List[\"NodalConstraint\"] = field(default_factory=list)\n    nodal_convex: List[\"NodalConstraint\"] = field(default_factory=list)\n    cross_node: List[\"CrossNodeConstraint\"] = field(default_factory=list)\n    cross_node_convex: List[\"CrossNodeConstraint\"] = field(default_factory=list)\n\n    @property\n    def is_categorized(self) -&gt; bool:\n        \"\"\"True if all constraints have been sorted into categories.\n\n        After preprocessing, `unsorted` should be empty and all constraints\n        should be in their appropriate category lists.\n        \"\"\"\n        return len(self.unsorted) == 0\n\n    def __bool__(self) -&gt; bool:\n        \"\"\"Return True if any constraint list is non-empty.\"\"\"\n        return bool(\n            self.unsorted\n            or self.ctcs\n            or self.nodal\n            or self.nodal_convex\n            or self.cross_node\n            or self.cross_node_convex\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return total number of constraints across all lists.\"\"\"\n        return (\n            len(self.unsorted)\n            + len(self.ctcs)\n            + len(self.nodal)\n            + len(self.nodal_convex)\n            + len(self.cross_node)\n            + len(self.cross_node_convex)\n        )\n</code></pre>"},{"location":"reference/symbolic/#openscvx.symbolic.ConstraintSet.is_categorized","title":"<code>is_categorized: bool</code>  <code>property</code>","text":"<p>True if all constraints have been sorted into categories.</p> <p>After preprocessing, <code>unsorted</code> should be empty and all constraints should be in their appropriate category lists.</p>"},{"location":"reference/symbolic/#openscvx.symbolic.SymbolicProblem","title":"<code>SymbolicProblem</code>  <code>dataclass</code>","text":"<p>Container for symbolic problem specification.</p> <p>This dataclass holds a trajectory optimization problem in symbolic form, either as raw user input or after preprocessing/augmentation. It provides a typed interface for the preprocessing and lowering pipeline.</p> Lifecycle Stages <ol> <li>Before preprocessing: User creates with raw dynamics, states,    controls, and unsorted constraints. Propagation fields are None.</li> <li>After preprocessing: Dynamics and states are augmented (CTCS,    time dilation), constraints are categorized, propagation fields    are populated.</li> </ol> <p>Use <code>is_preprocessed</code> to check whether preprocessing has completed.</p> <p>Attributes:</p> Name Type Description <code>dynamics</code> <code>Expr</code> <p>Symbolic dynamics expression (dx/dt = f(x, u)). After preprocessing, includes CTCS augmented state dynamics.</p> <code>states</code> <code>List[State]</code> <p>List of State objects. After preprocessing, includes time state and CTCS augmented states.</p> <code>controls</code> <code>List[Control]</code> <p>List of Control objects. After preprocessing, includes time dilation control.</p> <code>constraints</code> <code>ConstraintSet</code> <p>ConstraintSet holding all constraints. Before preprocessing, raw constraints live in <code>constraints.unsorted</code>. After preprocessing, constraints are categorized into ctcs, nodal, nodal_convex, etc.</p> <code>parameters</code> <code>Dict[str, any]</code> <p>Dictionary mapping parameter names to numpy arrays.</p> <code>N</code> <code>int</code> <p>Number of discretization nodes.</p> <code>node_intervals</code> <code>List[Tuple[int, int]]</code> <p>List of (start, end) tuples for CTCS constraint intervals. Populated during preprocessing when CTCS constraints are sorted.</p> <code>dynamics_prop</code> <code>Optional[Expr]</code> <p>Propagation dynamics (may include extra states). None before preprocessing, populated after.</p> <code>states_prop</code> <code>Optional[List[State]]</code> <p>Propagation states (may include extra states). None before preprocessing, populated after.</p> <code>controls_prop</code> <code>Optional[List[Control]]</code> <p>Propagation controls (typically same as controls). None before preprocessing, populated after.</p> Example <p>Before preprocessing::</p> <pre><code>problem = SymbolicProblem(\n    dynamics=dynamics_expr,\n    states=[x, v],\n    controls=[u],\n    constraints=ConstraintSet(unsorted=[c1, c2, c3]),\n    parameters={\"mass\": 1.0},\n    N=50,\n)\nassert not problem.is_preprocessed\n</code></pre> <p>After preprocessing::</p> <pre><code>processed = preprocess_symbolic_problem(problem, time=time_config)\nassert processed.is_preprocessed\nassert processed.constraints.is_categorized\n# Now ready for lowering\nlowered = lower_symbolic_problem(processed)\n</code></pre> Source code in <code>openscvx/symbolic/problem.py</code> <pre><code>@dataclass\nclass SymbolicProblem:\n    \"\"\"Container for symbolic problem specification.\n\n    This dataclass holds a trajectory optimization problem in symbolic form,\n    either as raw user input or after preprocessing/augmentation. It provides\n    a typed interface for the preprocessing and lowering pipeline.\n\n    Lifecycle Stages:\n        1. **Before preprocessing**: User creates with raw dynamics, states,\n           controls, and unsorted constraints. Propagation fields are None.\n        2. **After preprocessing**: Dynamics and states are augmented (CTCS,\n           time dilation), constraints are categorized, propagation fields\n           are populated.\n\n    Use `is_preprocessed` to check whether preprocessing has completed.\n\n    Attributes:\n        dynamics: Symbolic dynamics expression (dx/dt = f(x, u)).\n            After preprocessing, includes CTCS augmented state dynamics.\n        states: List of State objects. After preprocessing, includes\n            time state and CTCS augmented states.\n        controls: List of Control objects. After preprocessing, includes\n            time dilation control.\n        constraints: ConstraintSet holding all constraints. Before preprocessing,\n            raw constraints live in `constraints.unsorted`. After preprocessing,\n            constraints are categorized into ctcs, nodal, nodal_convex, etc.\n        parameters: Dictionary mapping parameter names to numpy arrays.\n        N: Number of discretization nodes.\n        node_intervals: List of (start, end) tuples for CTCS constraint intervals.\n            Populated during preprocessing when CTCS constraints are sorted.\n\n        dynamics_prop: Propagation dynamics (may include extra states).\n            None before preprocessing, populated after.\n        states_prop: Propagation states (may include extra states).\n            None before preprocessing, populated after.\n        controls_prop: Propagation controls (typically same as controls).\n            None before preprocessing, populated after.\n\n    Example:\n        Before preprocessing::\n\n            problem = SymbolicProblem(\n                dynamics=dynamics_expr,\n                states=[x, v],\n                controls=[u],\n                constraints=ConstraintSet(unsorted=[c1, c2, c3]),\n                parameters={\"mass\": 1.0},\n                N=50,\n            )\n            assert not problem.is_preprocessed\n\n        After preprocessing::\n\n            processed = preprocess_symbolic_problem(problem, time=time_config)\n            assert processed.is_preprocessed\n            assert processed.constraints.is_categorized\n            # Now ready for lowering\n            lowered = lower_symbolic_problem(processed)\n    \"\"\"\n\n    # Core problem specification\n    dynamics: \"Expr\"\n    states: List[\"State\"]\n    controls: List[\"Control\"]\n    constraints: ConstraintSet\n    parameters: Dict[str, any]\n    N: int\n\n    # CTCS node intervals (populated during preprocessing)\n    node_intervals: List[Tuple[int, int]] = field(default_factory=list)\n\n    # Propagation (None before preprocessing, populated after)\n    dynamics_prop: Optional[\"Expr\"] = None\n    states_prop: Optional[List[\"State\"]] = None\n    controls_prop: Optional[List[\"Control\"]] = None\n\n    @property\n    def is_preprocessed(self) -&gt; bool:\n        \"\"\"True if the problem has been preprocessed and is ready for lowering.\n\n        A problem is considered preprocessed when:\n        1. All constraints have been categorized (unsorted is empty)\n        2. Propagation dynamics have been set up\n        \"\"\"\n        return self.constraints.is_categorized and self.dynamics_prop is not None\n</code></pre>"},{"location":"reference/symbolic/#openscvx.symbolic.SymbolicProblem.is_preprocessed","title":"<code>is_preprocessed: bool</code>  <code>property</code>","text":"<p>True if the problem has been preprocessed and is ready for lowering.</p> <p>A problem is considered preprocessed when: 1. All constraints have been categorized (unsorted is empty) 2. Propagation dynamics have been set up</p>"},{"location":"reference/symbolic/augmentation/","title":"augmentation","text":"<p>State and dynamics augmentation for continuous-time constraint satisfaction.</p> <p>This module provides utilities for augmenting trajectory optimization problems with additional states and dynamics to handle continuous-time constraint satisfaction (CTCS). The CTCS method enforces path constraints continuously along the trajectory rather than just at discretization nodes.</p> Key functionality <ul> <li>CTCS constraint grouping: Sort and group CTCS constraints by time intervals</li> <li>Constraint separation: Separate CTCS, nodal, and convex constraints</li> <li>Vector decomposition: Decompose vector constraints into scalar components</li> <li>Time augmentation: Add time state with appropriate dynamics and constraints</li> <li>CTCS dynamics augmentation: Add augmented states and time dilation control</li> </ul> <p>The augmentation process transforms the original dynamics x_dot = f(x, u) into an augmented system with additional states for constraint satisfaction and time dilation.</p> Architecture <p>The CTCS method works by:</p> <ol> <li>Grouping constraints by time interval and assigning index (idx)</li> <li>Creating augmented states (one per constraint group)</li> <li>Adding penalty dynamics: aug_dot = penalty(constraint_violation)</li> <li>Adding time dilation control to slow down near constraint boundaries</li> </ol> Example <p>Augmenting dynamics with CTCS constraints::</p> <pre><code>import openscvx as ox\n\n# Define problem\nx = ox.State(\"x\", shape=(3,))\nu = ox.Control(\"u\", shape=(2,))\n\n# Create dynamics\nxdot = u @ A  # Some dynamics expression\n\n# Define path constraint\npath_constraint = (ox.Norm(x) &lt;= 1.0).over((0, 50))  # CTCS constraint\n\n# Augment dynamics with CTCS\nfrom openscvx.symbolic.augmentation import augment_dynamics_with_ctcs\n\nxdot_aug, states_aug, controls_aug = augment_dynamics_with_ctcs(\n    xdot=xdot,\n    states=[x],\n    controls=[u],\n    constraints_ctcs=[path_constraint],\n    N=50\n)\n# xdot_aug now includes augmented state dynamics\n# states_aug includes original states + augmented states\n# controls_aug includes original controls + time dilation\n</code></pre>"},{"location":"reference/symbolic/augmentation/#openscvx.symbolic.augmentation.augment_dynamics_with_ctcs","title":"<code>augment_dynamics_with_ctcs(xdot: Expr, states: List[State], controls: List[Control], constraints_ctcs: List[CTCS], N: int, licq_min: float = 0.0, licq_max: float = 0.0001, time_dilation_factor_min: float = 0.3, time_dilation_factor_max: float = 3.0) -&gt; Tuple[Expr, List[State], List[Control]]</code>","text":"<p>Augment dynamics with continuous-time constraint satisfaction states.</p> <p>Implements the CTCS method by adding augmented states and time dilation control to the original dynamics. For each group of CTCS constraints, an augmented state is created whose dynamics are the penalty function of constraint violations.</p> <p>The CTCS method enforces path constraints continuously by: 1. Creating augmented states with dynamics = penalty(constraint_violation) 2. Constraining augmented states to stay near zero (LICQ condition) 3. Adding time dilation control to slow down near constraint boundaries</p> The augmented dynamics become <p>x_dot = f(x, u) aug_dot = penalty(g(x, u))  # For each constraint group time_dot = time_dilation</p> <p>Parameters:</p> Name Type Description Default <code>xdot</code> <code>Expr</code> <p>Original dynamics expression for states</p> required <code>states</code> <code>List[State]</code> <p>List of state variables (must include a state named \"time\")</p> required <code>controls</code> <code>List[Control]</code> <p>List of control variables</p> required <code>constraints_ctcs</code> <code>List[CTCS]</code> <p>List of CTCS constraints (should be sorted and grouped)</p> required <code>N</code> <code>int</code> <p>Number of discretization nodes</p> required <code>licq_min</code> <code>float</code> <p>Minimum bound for augmented states (default: 0.0)</p> <code>0.0</code> <code>licq_max</code> <code>float</code> <p>Maximum bound for augmented states (default: 1e-4)</p> <code>0.0001</code> <code>time_dilation_factor_min</code> <code>float</code> <p>Minimum time dilation factor (default: 0.3)</p> <code>0.3</code> <code>time_dilation_factor_max</code> <code>float</code> <p>Maximum time dilation factor (default: 3.0)</p> <code>3.0</code> <p>Returns:</p> Type Description <code>Tuple[Expr, List[State], List[Control]]</code> <p>Tuple of: - Augmented dynamics expression (original + augmented state dynamics) - Updated states list (original + augmented states) - Updated controls list (original + time dilation control)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no state named \"time\" is found in the states list</p> Example <p>Augment dynamics with CTCS penalty states:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nu = ox.Control(\"u\", shape=(2,))\ntime = ox.State(\"time\", shape=(1,))\nxdot = u @ A  # Some dynamics\nconstraint = (ox.Norm(x) &lt;= 1.0).over((0, 50))\nxdot_aug, states_aug, controls_aug = augment_dynamics_with_ctcs(\n    xdot=xdot,\n    states=[x, time],\n    controls=[u],\n    constraints_ctcs=[constraint],\n    N=50\n)\n</code></pre> <p>states_aug includes x, time, and _ctcs_aug_0, controls_aug includes u and _time_dilation</p> Source code in <code>openscvx/symbolic/augmentation.py</code> <pre><code>def augment_dynamics_with_ctcs(\n    xdot: Expr,\n    states: List[State],\n    controls: List[Control],\n    constraints_ctcs: List[CTCS],\n    N: int,\n    licq_min: float = 0.0,\n    licq_max: float = 1e-4,\n    time_dilation_factor_min: float = 0.3,\n    time_dilation_factor_max: float = 3.0,\n) -&gt; Tuple[Expr, List[State], List[Control]]:\n    \"\"\"Augment dynamics with continuous-time constraint satisfaction states.\n\n    Implements the CTCS method by adding augmented states and time dilation control\n    to the original dynamics. For each group of CTCS constraints, an augmented state\n    is created whose dynamics are the penalty function of constraint violations.\n\n    The CTCS method enforces path constraints continuously by:\n    1. Creating augmented states with dynamics = penalty(constraint_violation)\n    2. Constraining augmented states to stay near zero (LICQ condition)\n    3. Adding time dilation control to slow down near constraint boundaries\n\n    The augmented dynamics become:\n        x_dot = f(x, u)\n        aug_dot = penalty(g(x, u))  # For each constraint group\n        time_dot = time_dilation\n\n    Args:\n        xdot: Original dynamics expression for states\n        states: List of state variables (must include a state named \"time\")\n        controls: List of control variables\n        constraints_ctcs: List of CTCS constraints (should be sorted and grouped)\n        N: Number of discretization nodes\n        licq_min: Minimum bound for augmented states (default: 0.0)\n        licq_max: Maximum bound for augmented states (default: 1e-4)\n        time_dilation_factor_min: Minimum time dilation factor (default: 0.3)\n        time_dilation_factor_max: Maximum time dilation factor (default: 3.0)\n\n    Returns:\n        Tuple of:\n            - Augmented dynamics expression (original + augmented state dynamics)\n            - Updated states list (original + augmented states)\n            - Updated controls list (original + time dilation control)\n\n    Raises:\n        ValueError: If no state named \"time\" is found in the states list\n\n    Example:\n        Augment dynamics with CTCS penalty states:\n\n            x = ox.State(\"x\", shape=(3,))\n            u = ox.Control(\"u\", shape=(2,))\n            time = ox.State(\"time\", shape=(1,))\n            xdot = u @ A  # Some dynamics\n            constraint = (ox.Norm(x) &lt;= 1.0).over((0, 50))\n            xdot_aug, states_aug, controls_aug = augment_dynamics_with_ctcs(\n                xdot=xdot,\n                states=[x, time],\n                controls=[u],\n                constraints_ctcs=[constraint],\n                N=50\n            )\n\n        states_aug includes x, time, and _ctcs_aug_0,\n        controls_aug includes u and _time_dilation\n    \"\"\"\n    # Copy the original states and controls lists\n    states_augmented = list(states)\n    controls_augmented = list(controls)\n\n    if constraints_ctcs:\n        # Group penalty expressions by idx (constraints should already be sorted)\n        penalty_groups: Dict[int, List[Expr]] = {}\n\n        for ctcs in constraints_ctcs:\n            # Keep the CTCS wrapper intact to preserve node interval information\n            # The JAX lowerer's visit_ctcs() method will handle the conditional logic\n\n            # TODO: In the future, apply scaling here if ctcs has a scaling attribute\n            # if hasattr(ctcs, 'scaling') and ctcs.scaling != 1.0:\n            #     ctcs = scale_ctcs(ctcs, scaling_factor)\n\n            if ctcs.idx not in penalty_groups:\n                penalty_groups[ctcs.idx] = []\n            penalty_groups[ctcs.idx].append(ctcs)\n\n        # Create augmented state expressions for each group\n        augmented_state_exprs = []\n        for idx in sorted(penalty_groups.keys()):\n            penalty_terms = penalty_groups[idx]\n            if len(penalty_terms) == 1:\n                augmented_state_expr = penalty_terms[0]\n            else:\n                augmented_state_expr = Add(*penalty_terms)\n            augmented_state_exprs.append(augmented_state_expr)\n\n        # Calculate number of augmented states from the penalty groups\n        num_augmented_states = len(penalty_groups)\n\n        # Create augmented state variables\n        for idx in range(num_augmented_states):\n            aug_var = State(f\"_ctcs_aug_{idx}\", shape=(1,))\n            aug_var.initial = np.array([licq_min])  # Set initial to respect bounds\n            aug_var.final = [(\"free\", 0)]\n            aug_var.min = np.array([licq_min])\n            aug_var.max = np.array([licq_max])\n            # Set guess to licq_min as well\n            aug_var.guess = np.full([N, 1], licq_min)  # N x num augmented states\n            states_augmented.append(aug_var)\n\n        # Concatenate with original dynamics\n        xdot_aug = Concat(xdot, *augmented_state_exprs)\n    else:\n        xdot_aug = xdot\n\n    time_dilation = Control(\"_time_dilation\", shape=(1,))\n\n    # Set up time dilation bounds and initial guess\n    # Find the time state by name\n    time_state = None\n    for state in states:\n        if state.name == \"time\":\n            time_state = state\n            break\n\n    if time_state is None:\n        raise ValueError(\"No state named 'time' found in states list\")\n\n    time_final = time_state.final[0]\n    time_dilation.min = np.array([time_dilation_factor_min * time_final])\n    time_dilation.max = np.array([time_dilation_factor_max * time_final])\n    time_dilation.guess = np.ones([N, 1]) * time_final\n\n    controls_augmented.append(time_dilation)\n\n    return xdot_aug, states_augmented, controls_augmented\n</code></pre>"},{"location":"reference/symbolic/augmentation/#openscvx.symbolic.augmentation.augment_with_time_state","title":"<code>augment_with_time_state(states: List[State], constraints: ConstraintSet, time_initial: float | tuple, time_final: float | tuple, time_min: float, time_max: float, N: int, time_scaling_min: Optional[float] = None, time_scaling_max: Optional[float] = None) -&gt; Tuple[List[State], ConstraintSet]</code>","text":"<p>Augment problem with a time state variable.</p> <p>Creates a time state variable if one doesn't already exist and adds it to the states list. Also adds CTCS constraints to enforce time bounds continuously throughout the trajectory.</p> <p>The time state tracks physical time along the trajectory and is used for time-optimal control problems. Boundary conditions can be fixed values or free variables with initial guesses.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>List[State]</code> <p>List of State objects (will not be modified, copy is returned)</p> required <code>constraints</code> <code>ConstraintSet</code> <p>ConstraintSet with unsorted constraints (will be modified in place)</p> required <code>time_initial</code> <code>float | tuple</code> <p>Initial time boundary condition: - float: Fixed initial time - tuple: (\"free\", guess) for free initial time with initial guess</p> required <code>time_final</code> <code>float | tuple</code> <p>Final time boundary condition (same format as time_initial)</p> required <code>time_min</code> <code>float</code> <p>Minimum bound for time variable throughout trajectory</p> required <code>time_max</code> <code>float</code> <p>Maximum bound for time variable throughout trajectory</p> required <code>N</code> <code>int</code> <p>Number of discretization nodes (for initial guess generation)</p> required <p>Returns:</p> Type Description <code>Tuple[List[State], ConstraintSet]</code> <p>Tuple of: - Updated states list (original + time state if created) - The same ConstraintSet with time CTCS constraints added to unsorted</p> Note <p>If a state named \"time\" already exists, it is not modified and no constraints are added.</p> Example <p>Get augmented states::</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraints = ConstraintSet()\nstates_aug, constraints = augment_with_time_state(\n    states=[x],\n    constraints=constraints,\n    time_initial=0.0,\n    time_final=(\"free\", 10.0),\n    time_min=0.0,\n    time_max=100.0,\n    N=50\n)\n</code></pre> <p>states_aug now includes time state with initial=0, final=free</p> Source code in <code>openscvx/symbolic/augmentation.py</code> <pre><code>def augment_with_time_state(\n    states: List[State],\n    constraints: ConstraintSet,\n    time_initial: float | tuple,\n    time_final: float | tuple,\n    time_min: float,\n    time_max: float,\n    N: int,\n    time_scaling_min: Optional[float] = None,\n    time_scaling_max: Optional[float] = None,\n) -&gt; Tuple[List[State], ConstraintSet]:\n    \"\"\"Augment problem with a time state variable.\n\n    Creates a time state variable if one doesn't already exist and adds it to the\n    states list. Also adds CTCS constraints to enforce time bounds continuously\n    throughout the trajectory.\n\n    The time state tracks physical time along the trajectory and is used for\n    time-optimal control problems. Boundary conditions can be fixed values or\n    free variables with initial guesses.\n\n    Args:\n        states: List of State objects (will not be modified, copy is returned)\n        constraints: ConstraintSet with unsorted constraints (will be modified in place)\n        time_initial: Initial time boundary condition:\n            - float: Fixed initial time\n            - tuple: (\"free\", guess) for free initial time with initial guess\n        time_final: Final time boundary condition (same format as time_initial)\n        time_min: Minimum bound for time variable throughout trajectory\n        time_max: Maximum bound for time variable throughout trajectory\n        N: Number of discretization nodes (for initial guess generation)\n\n    Returns:\n        Tuple of:\n            - Updated states list (original + time state if created)\n            - The same ConstraintSet with time CTCS constraints added to unsorted\n\n    Note:\n        If a state named \"time\" already exists, it is not modified and no\n        constraints are added.\n\n    Example:\n        Get augmented states::\n\n            x = ox.State(\"x\", shape=(3,))\n            constraints = ConstraintSet()\n            states_aug, constraints = augment_with_time_state(\n                states=[x],\n                constraints=constraints,\n                time_initial=0.0,\n                time_final=(\"free\", 10.0),\n                time_min=0.0,\n                time_max=100.0,\n                N=50\n            )\n\n        states_aug now includes time state with initial=0, final=free\n    \"\"\"\n    # Create copy of states to avoid mutating input\n    states_aug = list(states)\n\n    # Check if a time state already exists\n    time_state = None\n    for state in states_aug:\n        if state.name == \"time\":\n            time_state = state\n            break\n\n    if time_state is None:\n        # Create time State only if it doesn't exist\n        time_state = State(\"time\", shape=(1,))\n        time_state.min = np.array([time_min])\n        time_state.max = np.array([time_max])\n\n        # Set time boundary conditions\n        time_state.initial = [time_initial]\n        time_state.final = [time_final]\n\n        # Create initial guess for time (linear interpolation)\n        time_guess_start = (\n            time_state.initial[0]\n            if isinstance(time_state.initial[0], (int, float))\n            else time_state.initial[0][1]\n        )\n        time_guess_end = (\n            time_state.final[0]\n            if isinstance(time_state.final[0], (int, float))\n            else time_state.final[0][1]\n        )\n        time_state.guess = np.linspace(time_guess_start, time_guess_end, N).reshape(-1, 1)\n\n        # Transfer scaling_min/max from Time object if provided\n        if time_scaling_min is not None:\n            time_state.scaling_min = np.array([time_scaling_min])\n        if time_scaling_max is not None:\n            time_state.scaling_max = np.array([time_scaling_max])\n\n        # Add time state to the list\n        states_aug.append(time_state)\n\n        # Add CTCS constraints for time bounds to unsorted\n        constraints.unsorted.append(CTCS(time_state &lt;= time_state.max))\n        constraints.unsorted.append(CTCS(time_state.min &lt;= time_state))\n\n    return states_aug, constraints\n</code></pre>"},{"location":"reference/symbolic/augmentation/#openscvx.symbolic.augmentation.decompose_vector_nodal_constraints","title":"<code>decompose_vector_nodal_constraints(constraints_nodal: List[NodalConstraint]) -&gt; List[NodalConstraint]</code>","text":"<p>Decompose vector-valued nodal constraints into scalar constraints.</p> <p>Decomposes vector constraints into individual scalar constraints, which is necessary for nonconvex nodal constraints that are lowered to JAX functions. The JAX-to-CVXPY interface expects scalar constraint values at each node.</p> <p>For example, a constraint with shape (3,) is decomposed into 3 separate scalar constraints using indexing. CTCS constraints don't need decomposition since they handle vector values internally.</p> <p>Parameters:</p> Name Type Description Default <code>constraints_nodal</code> <code>List[NodalConstraint]</code> <p>List of NodalConstraint objects (must be canonicalized)</p> required <p>Returns:</p> Type Description <code>List[NodalConstraint]</code> <p>List of NodalConstraint objects with vector constraints decomposed into scalars.</p> <code>List[NodalConstraint]</code> <p>Scalar constraints are passed through unchanged.</p> Note <p>Constraints are assumed to be in canonical form: residual &lt;= 0 or residual == 0, where residual is the lhs of the constraint.</p> Example <p>Decompose vector constraint into 3 constraints:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = (x &lt;= 5).at([0, 10, 20])  # Vector constraint, shape (3,)\ndecomposed = decompose_vector_nodal_constraints([constraint])\n# Returns 3 constraints: x[0] &lt;= 5, x[1] &lt;= 5, x[2] &lt;= 5\n</code></pre> Source code in <code>openscvx/symbolic/augmentation.py</code> <pre><code>def decompose_vector_nodal_constraints(\n    constraints_nodal: List[NodalConstraint],\n) -&gt; List[NodalConstraint]:\n    \"\"\"Decompose vector-valued nodal constraints into scalar constraints.\n\n    Decomposes vector constraints into individual scalar constraints, which is necessary\n    for nonconvex nodal constraints that are lowered to JAX functions. The JAX-to-CVXPY\n    interface expects scalar constraint values at each node.\n\n    For example, a constraint with shape (3,) is decomposed into 3 separate scalar\n    constraints using indexing. CTCS constraints don't need decomposition since they\n    handle vector values internally.\n\n    Args:\n        constraints_nodal (List[NodalConstraint]): List of NodalConstraint objects\n            (must be canonicalized)\n\n    Returns:\n        List of NodalConstraint objects with vector constraints decomposed into scalars.\n        Scalar constraints are passed through unchanged.\n\n    Note:\n        Constraints are assumed to be in canonical form: residual &lt;= 0 or residual == 0,\n        where residual is the lhs of the constraint.\n\n    Example:\n        Decompose vector constraint into 3 constraints:\n\n            x = ox.State(\"x\", shape=(3,))\n            constraint = (x &lt;= 5).at([0, 10, 20])  # Vector constraint, shape (3,)\n            decomposed = decompose_vector_nodal_constraints([constraint])\n            # Returns 3 constraints: x[0] &lt;= 5, x[1] &lt;= 5, x[2] &lt;= 5\n    \"\"\"\n    decomposed_constraints = []\n\n    for nodal_constraint in constraints_nodal:\n        constraint = nodal_constraint.constraint\n        nodes = nodal_constraint.nodes\n\n        try:\n            # Get the shape of the constraint residual\n            # Canonicalized constraints are in form: residual &lt;= 0 or residual == 0\n            residual_shape = constraint.lhs.check_shape()\n\n            # Check if this is a vector constraint\n            # Decompose ALL vector-shaped constraints (including shape=(1,)) to avoid\n            # vmap adding an extra dimension when stacking results\n            if len(residual_shape) &gt; 0:\n                # Vector constraint - decompose into scalar constraints\n                total_elements = int(np.prod(residual_shape))\n\n                for i in range(total_elements):\n                    # Create indexed version: residual[i] &lt;= 0 or residual[i] == 0\n                    indexed_lhs = Index(constraint.lhs, i)\n                    indexed_rhs = constraint.rhs  # Should be Constant(0)\n                    indexed_constraint = constraint.__class__(indexed_lhs, indexed_rhs)\n                    decomposed_constraints.append(NodalConstraint(indexed_constraint, nodes))\n            else:\n                # Scalar constraint - keep as is\n                decomposed_constraints.append(nodal_constraint)\n\n        except Exception:\n            # If shape analysis fails, keep original constraint for backward compatibility\n            decomposed_constraints.append(nodal_constraint)\n\n    return decomposed_constraints\n</code></pre>"},{"location":"reference/symbolic/augmentation/#openscvx.symbolic.augmentation.get_nodal_constraints_from_ctcs","title":"<code>get_nodal_constraints_from_ctcs(constraints_ctcs: List[CTCS]) -&gt; List[tuple[Constraint, tuple[int, int]]]</code>","text":"<p>Extract constraints from CTCS wrappers that should be checked nodally.</p> <p>Some CTCS constraints have the check_nodally flag set, indicating that the underlying constraint should be enforced both continuously (via CTCS) and discretely at the nodes. This function extracts those underlying constraints along with their node intervals.</p> <p>Parameters:</p> Name Type Description Default <code>constraints_ctcs</code> <code>List[CTCS]</code> <p>List of CTCS constraint wrappers</p> required <p>Returns:</p> Type Description <code>List[tuple[Constraint, tuple[int, int]]]</code> <p>List of tuples (constraint, nodes) where: - constraint: The underlying Constraint object from CTCS with check_nodally=True - nodes: The (start, end) interval from the CTCS wrapper</p> Example <p>Extract CTCS constraint that should also be checked at nodes:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = (x &lt;= 5).over((10, 50), check_nodally=True)\nnodal = get_nodal_constraints_from_ctcs([constraint])\n</code></pre> <p>Returns [(x &lt;= 5, (10, 50))] to be enforced at nodes 10 through 49</p> Source code in <code>openscvx/symbolic/augmentation.py</code> <pre><code>def get_nodal_constraints_from_ctcs(\n    constraints_ctcs: List[CTCS],\n) -&gt; List[tuple[Constraint, tuple[int, int]]]:\n    \"\"\"Extract constraints from CTCS wrappers that should be checked nodally.\n\n    Some CTCS constraints have the check_nodally flag set, indicating that the\n    underlying constraint should be enforced both continuously (via CTCS) and\n    discretely at the nodes. This function extracts those underlying constraints\n    along with their node intervals.\n\n    Args:\n        constraints_ctcs: List of CTCS constraint wrappers\n\n    Returns:\n        List of tuples (constraint, nodes) where:\n            - constraint: The underlying Constraint object from CTCS with check_nodally=True\n            - nodes: The (start, end) interval from the CTCS wrapper\n\n    Example:\n        Extract CTCS constraint that should also be checked at nodes:\n\n            x = ox.State(\"x\", shape=(3,))\n            constraint = (x &lt;= 5).over((10, 50), check_nodally=True)\n            nodal = get_nodal_constraints_from_ctcs([constraint])\n\n        Returns [(x &lt;= 5, (10, 50))] to be enforced at nodes 10 through 49\n    \"\"\"\n    nodal_ctcs = []\n    for ctcs in constraints_ctcs:\n        if ctcs.check_nodally:\n            nodal_ctcs.append((ctcs.constraint, ctcs.nodes))\n    return nodal_ctcs\n</code></pre>"},{"location":"reference/symbolic/augmentation/#openscvx.symbolic.augmentation.separate_constraints","title":"<code>separate_constraints(constraint_set: ConstraintSet, n_nodes: int) -&gt; ConstraintSet</code>","text":"<p>Separate and categorize constraints by type and convexity.</p> <p>Moves constraints from <code>constraint_set.unsorted</code> into their appropriate category fields (ctcs, nodal, nodal_convex, cross_node, cross_node_convex).</p> <p>Bare Constraint objects are automatically categorized: - If they contain NodeReferences (from .at(k) calls), they become CrossNodeConstraint - Otherwise, they become NodalConstraint applied at all nodes</p> <p>Constraints within CTCS wrappers that have check_nodally=True are also extracted and added to the nodal constraint lists.</p> <p>Parameters:</p> Name Type Description Default <code>constraint_set</code> <code>ConstraintSet</code> <p>ConstraintSet with raw constraints in <code>unsorted</code> field</p> required <code>n_nodes</code> <code>int</code> <p>Total number of nodes in the trajectory</p> required <p>Returns:</p> Type Description <code>ConstraintSet</code> <p>The same ConstraintSet with <code>unsorted</code> drained and categories populated</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a constraint is not one of the expected types</p> <code>ValueError</code> <p>If a NodalConstraint contains NodeReferences (use bare Constraint instead)</p> <code>ValueError</code> <p>If a CTCS constraint contains NodeReferences</p> Example <p>Separate and categorize constraints::</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint_set = ConstraintSet(unsorted=[\n    (x &lt;= 5).over((0, 50)),           # CTCS\n    (x &gt;= 0).at([0, 10, 20]),         # NodalConstraint\n    ox.Norm(x) &lt;= 1,                  # Bare -&gt; all nodes\n    x.at(5) - x.at(4) &lt;= 0.1,         # Bare with NodeRef -&gt; cross-node\n])\nseparate_constraints(constraint_set, n_nodes=50)\nassert constraint_set.is_categorized\n# Access via: constraint_set.ctcs, constraint_set.nodal, etc.\n</code></pre> Source code in <code>openscvx/symbolic/augmentation.py</code> <pre><code>def separate_constraints(constraint_set: ConstraintSet, n_nodes: int) -&gt; ConstraintSet:\n    \"\"\"Separate and categorize constraints by type and convexity.\n\n    Moves constraints from `constraint_set.unsorted` into their appropriate\n    category fields (ctcs, nodal, nodal_convex, cross_node, cross_node_convex).\n\n    Bare Constraint objects are automatically categorized:\n    - If they contain NodeReferences (from .at(k) calls), they become CrossNodeConstraint\n    - Otherwise, they become NodalConstraint applied at all nodes\n\n    Constraints within CTCS wrappers that have check_nodally=True are also extracted\n    and added to the nodal constraint lists.\n\n    Args:\n        constraint_set: ConstraintSet with raw constraints in `unsorted` field\n        n_nodes: Total number of nodes in the trajectory\n\n    Returns:\n        The same ConstraintSet with `unsorted` drained and categories populated\n\n    Raises:\n        ValueError: If a constraint is not one of the expected types\n        ValueError: If a NodalConstraint contains NodeReferences (use bare Constraint instead)\n        ValueError: If a CTCS constraint contains NodeReferences\n\n    Example:\n        Separate and categorize constraints::\n\n            x = ox.State(\"x\", shape=(3,))\n            constraint_set = ConstraintSet(unsorted=[\n                (x &lt;= 5).over((0, 50)),           # CTCS\n                (x &gt;= 0).at([0, 10, 20]),         # NodalConstraint\n                ox.Norm(x) &lt;= 1,                  # Bare -&gt; all nodes\n                x.at(5) - x.at(4) &lt;= 0.1,         # Bare with NodeRef -&gt; cross-node\n            ])\n            separate_constraints(constraint_set, n_nodes=50)\n            assert constraint_set.is_categorized\n            # Access via: constraint_set.ctcs, constraint_set.nodal, etc.\n    \"\"\"\n    from openscvx.symbolic.lower import _contains_node_reference\n\n    # Process all constraints from unsorted\n    for c in constraint_set.unsorted:\n        if isinstance(c, CTCS):\n            # Validate that CTCS constraints don't contain NodeReferences\n            if _contains_node_reference(c.constraint):\n                raise ValueError(\n                    \"CTCS constraints cannot contain NodeReferences (.at(k)). \"\n                    \"Cross-node constraints should be specified as bare Constraint objects. \"\n                    f\"Constraint: {c.constraint}\"\n                )\n            # Normalize None to full horizon\n            c.nodes = c.nodes or (0, n_nodes)\n            constraint_set.ctcs.append(c)\n\n        elif isinstance(c, NodalConstraint):\n            # NodalConstraint means user explicitly called .at([...])\n            # Cross-node constraints should NOT use .at([...]) wrapper\n            if _contains_node_reference(c.constraint):\n                raise ValueError(\n                    f\"Cross-node constraints should not use .at([...]) wrapper. \"\n                    f\"The constraint already references specific nodes via .at(k) inside the \"\n                    f\"expression. Remove the outer .at([...]) wrapper and use the bare \"\n                    f\"constraint directly. \"\n                    f\"Constraint: {c.constraint}\"\n                )\n\n            # Regular nodal constraint - categorize by convexity\n            if c.constraint.is_convex:\n                constraint_set.nodal_convex.append(c)\n            else:\n                constraint_set.nodal.append(c)\n\n        elif isinstance(c, Constraint):\n            # Bare constraint - check if it's a cross-node constraint\n            if _contains_node_reference(c):\n                # Cross-node constraint: wrap in CrossNodeConstraint\n                cross_node = CrossNodeConstraint(c)\n                if c.is_convex:\n                    constraint_set.cross_node_convex.append(cross_node)\n                else:\n                    constraint_set.cross_node.append(cross_node)\n            else:\n                # Regular constraint: apply at all nodes\n                all_nodes = list(range(n_nodes))\n                nodal_constraint = NodalConstraint(c, all_nodes)\n                if c.is_convex:\n                    constraint_set.nodal_convex.append(nodal_constraint)\n                else:\n                    constraint_set.nodal.append(nodal_constraint)\n\n        else:\n            raise ValueError(\n                \"Constraints must be `Constraint`, `NodalConstraint`, or `CTCS`, \"\n                f\"got {type(c).__name__}\"\n            )\n\n    # Clear unsorted now that all have been categorized\n    constraint_set.unsorted = []\n\n    # Add nodal constraints from CTCS constraints that have check_nodally=True\n    ctcs_nodal_constraints = get_nodal_constraints_from_ctcs(constraint_set.ctcs)\n    for constraint, interval in ctcs_nodal_constraints:\n        # CTCS check_nodally constraints cannot have NodeReferences (validated above)\n        # Convert CTCS interval (start, end) to list of nodes [start, start+1, ..., end-1]\n        interval_nodes = list(range(interval[0], interval[1]))\n        nodal_constraint = NodalConstraint(constraint, interval_nodes)\n\n        if constraint.is_convex:\n            constraint_set.nodal_convex.append(nodal_constraint)\n        else:\n            constraint_set.nodal.append(nodal_constraint)\n\n    # Validate cross-node constraints (bounds and variable consistency)\n    from openscvx.symbolic.preprocessing import validate_cross_node_constraint\n\n    for cross_node_constraint in constraint_set.cross_node + constraint_set.cross_node_convex:\n        validate_cross_node_constraint(cross_node_constraint, n_nodes)\n\n    return constraint_set\n</code></pre>"},{"location":"reference/symbolic/augmentation/#openscvx.symbolic.augmentation.sort_ctcs_constraints","title":"<code>sort_ctcs_constraints(constraints_ctcs: List[CTCS]) -&gt; Tuple[List[CTCS], List[Tuple[int, int]], int]</code>","text":"<p>Sort and group CTCS constraints by time interval and assign indices.</p> <p>Groups CTCS constraints by their time intervals (nodes) and assigns a unique index (idx) to each group. Constraints with the same time interval can share an augmented state (same idx), while constraints with different intervals must have different augmented states.</p> Grouping rules <ul> <li>Constraints with the same node interval can share an idx</li> <li>Constraints with different node intervals must have different idx values</li> <li>idx values must form a contiguous block starting from 0</li> <li>Unspecified idx values are automatically assigned</li> <li>User-specified idx values are validated for consistency</li> </ul> <p>Parameters:</p> Name Type Description Default <code>constraints_ctcs</code> <code>List[CTCS]</code> <p>List of CTCS constraints to sort and group</p> required <p>Returns:</p> Type Description <code>Tuple[List[CTCS], List[Tuple[int, int]], int]</code> <p>Tuple of: - List of CTCS constraints with idx assigned to each - List of node intervals (start, end) in ascending idx order - Number of augmented states needed (number of unique idx values)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If user-specified idx values are inconsistent or non-contiguous</p> Example <p>Sort CTCS constraints by interval and index:</p> <pre><code>constraint1 = (x &lt;= 5).over((0, 50))  # Auto-assigned idx\nconstraint2 = (y &lt;= 10).over((0, 50))  # Same interval, same idx\nconstraint3 = (z &lt;= 15).over((20, 80))  # Different interval, different idx\nsorted_ctcs, intervals, n_aug = sort_ctcs_constraints([c1, c2, c3])\n# constraint1.idx = 0, constraint2.idx = 0, constraint3.idx = 1\n# intervals = [(0, 50), (20, 80)]\n# n_aug = 2\n</code></pre> Source code in <code>openscvx/symbolic/augmentation.py</code> <pre><code>def sort_ctcs_constraints(\n    constraints_ctcs: List[CTCS],\n) -&gt; Tuple[List[CTCS], List[Tuple[int, int]], int]:\n    \"\"\"Sort and group CTCS constraints by time interval and assign indices.\n\n    Groups CTCS constraints by their time intervals (nodes) and assigns a unique\n    index (idx) to each group. Constraints with the same time interval can share\n    an augmented state (same idx), while constraints with different intervals must\n    have different augmented states.\n\n    Grouping rules:\n        - Constraints with the same node interval can share an idx\n        - Constraints with different node intervals must have different idx values\n        - idx values must form a contiguous block starting from 0\n        - Unspecified idx values are automatically assigned\n        - User-specified idx values are validated for consistency\n\n    Args:\n        constraints_ctcs: List of CTCS constraints to sort and group\n\n    Returns:\n        Tuple of:\n            - List of CTCS constraints with idx assigned to each\n            - List of node intervals (start, end) in ascending idx order\n            - Number of augmented states needed (number of unique idx values)\n\n    Raises:\n        ValueError: If user-specified idx values are inconsistent or non-contiguous\n\n    Example:\n        Sort CTCS constraints by interval and index:\n\n            constraint1 = (x &lt;= 5).over((0, 50))  # Auto-assigned idx\n            constraint2 = (y &lt;= 10).over((0, 50))  # Same interval, same idx\n            constraint3 = (z &lt;= 15).over((20, 80))  # Different interval, different idx\n            sorted_ctcs, intervals, n_aug = sort_ctcs_constraints([c1, c2, c3])\n            # constraint1.idx = 0, constraint2.idx = 0, constraint3.idx = 1\n            # intervals = [(0, 50), (20, 80)]\n            # n_aug = 2\n    \"\"\"\n    idx_to_nodes: Dict[int, Tuple[int, int]] = {}\n    next_idx = 0\n\n    for c in constraints_ctcs:\n        key = c.nodes\n\n        if c.idx is not None:\n            # User supplied an identifier: ensure it always points to the same interval\n            if c.idx in idx_to_nodes:\n                if idx_to_nodes[c.idx] != key:\n                    raise ValueError(\n                        f\"idx={c.idx} was first used with interval={idx_to_nodes[c.idx]}, \"\n                        f\"but now you gave it interval={key}\"\n                    )\n            else:\n                # When idx is explicitly provided, always create a separate group\n                # even if nodes are the same - this allows multiple constraint groups\n                # with the same node interval but different idx values\n                idx_to_nodes[c.idx] = key\n        else:\n            # No identifier: see if this interval already has one\n            for existing_id, nodes in idx_to_nodes.items():\n                if nodes == key:\n                    c.idx = existing_id\n                    break\n            else:\n                # Brand-new interval: pick the next free auto-id\n                while next_idx in idx_to_nodes:\n                    next_idx += 1\n                c.idx = next_idx\n                idx_to_nodes[next_idx] = key\n                next_idx += 1\n\n    # Validate that idx values form a contiguous block starting from 0\n    ordered_ids = sorted(idx_to_nodes.keys())\n    expected_ids = list(range(len(ordered_ids)))\n    if ordered_ids != expected_ids:\n        raise ValueError(\n            f\"CTCS constraint idx values must form a contiguous block starting from 0. \"\n            f\"Got {ordered_ids}, expected {expected_ids}\"\n        )\n\n    # Extract intervals in ascending idx order\n    node_intervals = [idx_to_nodes[i] for i in ordered_ids]\n    num_augmented_states = len(ordered_ids)\n\n    return constraints_ctcs, node_intervals, num_augmented_states\n</code></pre>"},{"location":"reference/symbolic/builder/","title":"builder","text":"<p>Symbolic problem preprocessing and augmentation pipeline.</p> <p>This module provides the main preprocessing pipeline for trajectory optimization problems, transforming user-specified symbolic dynamics and constraints into an augmented form ready for compilation to executable code.</p> <p>The preprocessing pipeline is purely symbolic - no code generation occurs here. Instead, it performs validation, canonicalization, and augmentation to prepare the problem for efficient numerical solution.</p> Key functionality <ul> <li>Problem validation: Check shapes, variable names, constraint placement</li> <li>Time handling: Auto-create time state or validate user-provided time</li> <li>Canonicalization: Simplify expressions algebraically</li> <li>Parameter collection: Extract parameter values from expressions</li> <li>Constraint separation: Categorize constraints by type (CTCS, nodal, convex)</li> <li>CTCS augmentation: Add augmented states and time dilation for path constraints</li> <li>Propagation dynamics: Optionally extend dynamics for post-solution propagation</li> </ul> <p>The preprocessing pipeline is purely symbolic - no code generation occurs here.</p> Pipeline stages <ol> <li>Time handling &amp; validation</li> <li>Expression validation (shapes, names, constraint structure)</li> <li>Canonicalization &amp; parameter collection</li> <li>Constraint separation &amp; CTCS augmentation</li> <li>Propagation dynamics creation</li> </ol> <p>See <code>preprocess_symbolic_problem()</code> for the main entry point.</p>"},{"location":"reference/symbolic/builder/#openscvx.symbolic.builder.add_propagation_states","title":"<code>add_propagation_states(dynamics_extra: dict, states_extra: List[State], dynamics_opt: any, states_opt: List[State], controls_opt: List[Control], parameters: Dict[str, any]) -&gt; Tuple</code>","text":"<p>Extend optimization dynamics with additional propagation-only states.</p> <p>This function augments the optimization dynamics with extra states that are only needed for post-solution trajectory propagation and simulation. These states don't affect the optimization but are useful for computing derived quantities like distance traveled, energy consumed, or accumulated cost.</p> <p>Propagation-only states are NOT part of the optimization problem - they are integrated forward after solving using the optimized state and control trajectories. This is more efficient than including them as optimization variables.</p> <p>The user specifies only the ADDITIONAL states and their dynamics. These are appended after all optimization states (user states + time + CTCS augmented states).</p> State ordering in propagation dynamics <p>[user_states, time, ctcs_aug_states, extra_prop_states]</p> <p>Parameters:</p> Name Type Description Default <code>dynamics_extra</code> <code>dict</code> <p>Dictionary mapping extra state names to dynamics expressions. Only specify NEW states, not optimization states. Example: {\"distance\": speed}</p> required <code>states_extra</code> <code>List[State]</code> <p>List of extra State objects for propagation only</p> required <code>dynamics_opt</code> <code>any</code> <p>Augmented optimization dynamics expression (from preprocessing)</p> required <code>states_opt</code> <code>List[State]</code> <p>Augmented optimization states (user + time + CTCS augmented)</p> required <code>controls_opt</code> <code>List[Control]</code> <p>Augmented optimization controls (user + time dilation)</p> required <code>parameters</code> <code>Dict[str, any]</code> <p>Dictionary of parameter values from optimization preprocessing</p> required <p>Returns:</p> Type Description <code>Tuple</code> <p>Tuple containing: - dynamics_prop (Expr): Extended dynamics (optimization + extra) - states_prop (List[State]): Extended states (optimization + extra) - controls_prop (List[Control]): Same as controls_opt - parameters_updated (Dict): Updated parameters including any from extra dynamics</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If extra states conflict with optimization state names or if        validation fails</p> Example <p>Adding distance and energy tracking for propagation::</p> <pre><code>    # After preprocessing, add propagation states\n    import openscvx as ox\n    import numpy as np\n\n    # Define extra states for tracking\n    distance = ox.State(\"distance\", shape=(1,))\n    distance.initial = np.array([0.0])\n\n    energy = ox.State(\"energy\", shape=(1,))\n    energy.initial = np.array([0.0])\n\n    # Define their dynamics (using optimization states/controls)\n    # Assume v and u are optimization states/controls\n    dynamics_extra = {\n        \"distance\": ox.Norm(v),  # Integrate velocity magnitude\n        \"energy\": ox.Norm(u)**2  # Integrate squared control\n    }\n\n    dyn_prop, states_prop, controls_prop, params = add_propagation_states(\n        dynamics_extra=dynamics_extra,\n        states_extra=[distance, energy],\n        dynamics_opt=dynamics_aug,\n        states_opt=states_aug,\n        controls_opt=controls_aug,\n        parameters=parameters\n    )\n\n    # Now states_prop includes all states for forward simulation\n    # distance and energy will be integrated during propagation\n</code></pre> Note <p>The extra states should have initial conditions set, as they will be integrated from these initial values during propagation.</p> Source code in <code>openscvx/symbolic/builder.py</code> <pre><code>def add_propagation_states(\n    dynamics_extra: dict,\n    states_extra: List[State],\n    dynamics_opt: any,\n    states_opt: List[State],\n    controls_opt: List[Control],\n    parameters: Dict[str, any],\n) -&gt; Tuple:\n    \"\"\"Extend optimization dynamics with additional propagation-only states.\n\n    This function augments the optimization dynamics with extra states that are only\n    needed for post-solution trajectory propagation and simulation. These states\n    don't affect the optimization but are useful for computing derived quantities\n    like distance traveled, energy consumed, or accumulated cost.\n\n    Propagation-only states are NOT part of the optimization problem - they are\n    integrated forward after solving using the optimized state and control trajectories.\n    This is more efficient than including them as optimization variables.\n\n    The user specifies only the ADDITIONAL states and their dynamics. These are\n    appended after all optimization states (user states + time + CTCS augmented states).\n\n    State ordering in propagation dynamics:\n        [user_states, time, ctcs_aug_states, extra_prop_states]\n\n    Args:\n        dynamics_extra: Dictionary mapping extra state names to dynamics expressions.\n            Only specify NEW states, not optimization states. Example: {\"distance\": speed}\n        states_extra: List of extra State objects for propagation only\n        dynamics_opt: Augmented optimization dynamics expression (from preprocessing)\n        states_opt: Augmented optimization states (user + time + CTCS augmented)\n        controls_opt: Augmented optimization controls (user + time dilation)\n        parameters: Dictionary of parameter values from optimization preprocessing\n\n    Returns:\n        Tuple containing:\n            - dynamics_prop (Expr): Extended dynamics (optimization + extra)\n            - states_prop (List[State]): Extended states (optimization + extra)\n            - controls_prop (List[Control]): Same as controls_opt\n            - parameters_updated (Dict): Updated parameters including any from extra dynamics\n\n    Raises:\n        ValueError: If extra states conflict with optimization state names or if\n                   validation fails\n\n    Example:\n        Adding distance and energy tracking for propagation::\n\n                # After preprocessing, add propagation states\n                import openscvx as ox\n                import numpy as np\n\n                # Define extra states for tracking\n                distance = ox.State(\"distance\", shape=(1,))\n                distance.initial = np.array([0.0])\n\n                energy = ox.State(\"energy\", shape=(1,))\n                energy.initial = np.array([0.0])\n\n                # Define their dynamics (using optimization states/controls)\n                # Assume v and u are optimization states/controls\n                dynamics_extra = {\n                    \"distance\": ox.Norm(v),  # Integrate velocity magnitude\n                    \"energy\": ox.Norm(u)**2  # Integrate squared control\n                }\n\n                dyn_prop, states_prop, controls_prop, params = add_propagation_states(\n                    dynamics_extra=dynamics_extra,\n                    states_extra=[distance, energy],\n                    dynamics_opt=dynamics_aug,\n                    states_opt=states_aug,\n                    controls_opt=controls_aug,\n                    parameters=parameters\n                )\n\n                # Now states_prop includes all states for forward simulation\n                # distance and energy will be integrated during propagation\n\n    Note:\n        The extra states should have initial conditions set, as they will be\n        integrated from these initial values during propagation.\n    \"\"\"\n\n    # Make copies to avoid mutating inputs\n    states_extra = list(states_extra)\n    dynamics_extra = dict(dynamics_extra)\n    parameters = dict(parameters)\n\n    # ==================== PHASE 1: Validate Extra States ====================\n\n    # Validate that extra states don't conflict with optimization state names\n    opt_state_names = {s.name for s in states_opt}\n    extra_state_names = {s.name for s in states_extra}\n    conflicts = opt_state_names &amp; extra_state_names\n    if conflicts:\n        raise ValueError(\n            f\"Extra propagation states conflict with optimization states: {conflicts}. \"\n            f\"Only specify additional states, not optimization states.\"\n        )\n\n    # Validate dynamics dict for extra states\n    validate_dynamics_dict(dynamics_extra, states_extra)\n    validate_dynamics_dict_dimensions(dynamics_extra, states_extra)\n\n    # ==================== PHASE 2: Process Extra Dynamics ====================\n\n    # Convert extra dynamics to expression\n    _, dynamics_extra_concat = convert_dynamics_dict_to_expr(dynamics_extra, states_extra)\n\n    # Validate and canonicalize\n    validate_variable_names([dynamics_extra_concat])\n\n    # Temporarily assign slices for validation (will be recalculated below)\n    collect_and_assign_slices(states_extra, controls_opt)\n    validate_shapes([dynamics_extra_concat])\n    validate_dynamics_dimension(dynamics_extra_concat, states_extra)\n    dynamics_extra_concat = dynamics_extra_concat.canonicalize()\n\n    # Collect any new parameter values from extra dynamics\n    def collect_param_values(expr):\n        if isinstance(expr, Parameter):\n            if expr.name not in parameters:\n                parameters[expr.name] = expr.value\n\n    traverse(dynamics_extra_concat, collect_param_values)\n\n    # ==================== PHASE 3: Concatenate with Optimization Dynamics ====================\n\n    # Concatenate: {opt dynamics, extra dynamics}\n    from openscvx.symbolic.expr import Concat\n\n    dynamics_prop = Concat(dynamics_opt, dynamics_extra_concat)\n\n    # Manually assign slices to extra states ONLY (don't modify optimization state slices)\n    # Extra states are appended after all optimization states\n    n_opt_states = states_opt[-1]._slice.stop if states_opt else 0\n    start_idx = n_opt_states\n    for state in states_extra:\n        end_idx = start_idx + state.shape[0]\n        state._slice = slice(start_idx, end_idx)\n        start_idx = end_idx\n\n    # Append extra states to optimization states\n    states_prop = states_opt + states_extra\n\n    # Propagation uses same controls as optimization\n    controls_prop = controls_opt\n\n    # ==================== Return Symbolic Outputs ====================\n\n    return (\n        dynamics_prop,\n        states_prop,\n        controls_prop,\n        parameters,\n    )\n</code></pre>"},{"location":"reference/symbolic/builder/#openscvx.symbolic.builder.preprocess_symbolic_problem","title":"<code>preprocess_symbolic_problem(dynamics: dict, constraints: ConstraintSet, states: List[State], controls: List[Control], N: int, time: Time, licq_min: float = 0.0, licq_max: float = 0.0001, time_dilation_factor_min: float = 0.3, time_dilation_factor_max: float = 3.0, dynamics_prop_extra: dict = None, states_prop_extra: List[State] = None) -&gt; SymbolicProblem</code>","text":"<p>Preprocess and augment symbolic trajectory optimization problem.</p> <p>This is the main preprocessing pipeline that transforms a user-specified symbolic problem into an augmented form ready for compilation. It performs validation, canonicalization, constraint separation, and CTCS augmentation in a series of well-defined phases.</p> <p>The function is purely symbolic - no code generation or compilation occurs. The output is a SymbolicProblem dataclass that can be lowered to JAX or CVXPy by downstream compilation functions.</p> Pipeline phases <ol> <li>Time handling &amp; validation: Auto-create or validate time state</li> <li>Expression validation: Validate shapes, names, constraints</li> <li>Canonicalization &amp; parameter collection: Simplify and extract parameters</li> <li>Constraint separation &amp; augmentation: Sort constraints and add CTCS states</li> <li>Propagation dynamics creation: Optionally add extra states for simulation</li> </ol> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>dict</code> <p>Dictionary mapping state names to dynamics expressions. Example: {\"x\": v, \"v\": u}</p> required <code>constraints</code> <code>ConstraintSet</code> <p>ConstraintSet with raw constraints in <code>unsorted</code> field. Create with: ConstraintSet(unsorted=[c1, c2, c3])</p> required <code>states</code> <code>List[State]</code> <p>List of user-defined State objects (should NOT include time or CTCS states)</p> required <code>controls</code> <code>List[Control]</code> <p>List of user-defined Control objects (should NOT include time dilation)</p> required <code>N</code> <code>int</code> <p>Number of discretization nodes in the trajectory</p> required <code>time</code> <code>Time</code> <p>Time configuration object specifying time bounds and constraints</p> required <code>licq_min</code> <code>float</code> <p>Minimum bound for CTCS augmented states (default: 0.0)</p> <code>0.0</code> <code>licq_max</code> <code>float</code> <p>Maximum bound for CTCS augmented states (default: 1e-4)</p> <code>0.0001</code> <code>time_dilation_factor_min</code> <code>float</code> <p>Minimum factor for time dilation control (default: 0.3)</p> <code>0.3</code> <code>time_dilation_factor_max</code> <code>float</code> <p>Maximum factor for time dilation control (default: 3.0)</p> <code>3.0</code> <code>dynamics_prop_extra</code> <code>dict</code> <p>Optional dictionary of additional dynamics for propagation-only states (default: None)</p> <code>None</code> <code>states_prop_extra</code> <code>List[State]</code> <p>Optional list of additional State objects for propagation only (default: None)</p> <code>None</code> <p>Returns:</p> Type Description <code>SymbolicProblem</code> <p>SymbolicProblem dataclass with: - dynamics: Augmented dynamics (user + time + CTCS penalties) - states: Augmented states (user + time + CTCS augmented) - controls: Augmented controls (user + time dilation) - constraints: ConstraintSet with is_categorized=True - parameters: Dict of extracted parameter values - node_intervals: List of (start, end) tuples for CTCS intervals - dynamics_prop: Propagation dynamics - states_prop: Propagation states - controls_prop: Propagation controls</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails at any stage</p> Example <p>Basic usage with CTCS constraint::</p> <pre><code>import openscvx as ox\nfrom openscvx.symbolic.constraint_set import ConstraintSet\n\nx = ox.State(\"x\", shape=(2,))\nv = ox.State(\"v\", shape=(2,))\nu = ox.Control(\"u\", shape=(2,))\n\ndynamics = {\"x\": v, \"v\": u}\nconstraints = ConstraintSet(unsorted=[\n    (ox.Norm(x) &lt;= 5.0).over((0, 50))\n])\n\nproblem = preprocess_symbolic_problem(\n    dynamics=dynamics,\n    constraints=constraints,\n    states=[x, v],\n    controls=[u],\n    N=50,\n    time=ox.Time(initial=0.0, final=10.0)\n)\n\nassert problem.is_preprocessed\n# problem.dynamics: augmented dynamics expression\n# problem.states: [x, v, time, _ctcs_aug_0]\n# problem.controls: [u, _time_dilation]\nprint([s.name for s in problem.states])\n# ['x', 'v', 'time', '_ctcs_aug_0']\n</code></pre> <p>With propagation-only states::</p> <pre><code>distance = ox.State(\"distance\", shape=(1,))\ndynamics_extra = {\"distance\": ox.Norm(v)}\n\nproblem = preprocess_symbolic_problem(\n    dynamics=dynamics,\n    constraints=constraints,\n    states=[x, v],\n    controls=[u],\n    N=50,\n    time=ox.Time(initial=0.0, final=10.0),\n    dynamics_prop_extra=dynamics_extra,\n    states_prop_extra=[distance]\n)\n\n# Propagation states include distance for post-solve simulation\nprint([s.name for s in problem.states_prop])\n</code></pre> Source code in <code>openscvx/symbolic/builder.py</code> <pre><code>def preprocess_symbolic_problem(\n    dynamics: dict,\n    constraints: ConstraintSet,\n    states: List[State],\n    controls: List[Control],\n    N: int,\n    time: Time,\n    licq_min: float = 0.0,\n    licq_max: float = 1e-4,\n    time_dilation_factor_min: float = 0.3,\n    time_dilation_factor_max: float = 3.0,\n    dynamics_prop_extra: dict = None,\n    states_prop_extra: List[State] = None,\n) -&gt; SymbolicProblem:\n    \"\"\"Preprocess and augment symbolic trajectory optimization problem.\n\n    This is the main preprocessing pipeline that transforms a user-specified symbolic\n    problem into an augmented form ready for compilation. It performs validation,\n    canonicalization, constraint separation, and CTCS augmentation in a series of\n    well-defined phases.\n\n    The function is purely symbolic - no code generation or compilation occurs. The\n    output is a SymbolicProblem dataclass that can be lowered to JAX or CVXPy by\n    downstream compilation functions.\n\n    Pipeline phases:\n        1. Time handling &amp; validation: Auto-create or validate time state\n        2. Expression validation: Validate shapes, names, constraints\n        3. Canonicalization &amp; parameter collection: Simplify and extract parameters\n        4. Constraint separation &amp; augmentation: Sort constraints and add CTCS states\n        5. Propagation dynamics creation: Optionally add extra states for simulation\n\n    Args:\n        dynamics: Dictionary mapping state names to dynamics expressions.\n            Example: {\"x\": v, \"v\": u}\n        constraints: ConstraintSet with raw constraints in `unsorted` field.\n            Create with: ConstraintSet(unsorted=[c1, c2, c3])\n        states: List of user-defined State objects (should NOT include time or CTCS states)\n        controls: List of user-defined Control objects (should NOT include time dilation)\n        N: Number of discretization nodes in the trajectory\n        time: Time configuration object specifying time bounds and constraints\n        licq_min: Minimum bound for CTCS augmented states (default: 0.0)\n        licq_max: Maximum bound for CTCS augmented states (default: 1e-4)\n        time_dilation_factor_min: Minimum factor for time dilation control (default: 0.3)\n        time_dilation_factor_max: Maximum factor for time dilation control (default: 3.0)\n        dynamics_prop_extra: Optional dictionary of additional dynamics for propagation-only\n            states (default: None)\n        states_prop_extra: Optional list of additional State objects for propagation only\n            (default: None)\n\n    Returns:\n        SymbolicProblem dataclass with:\n            - dynamics: Augmented dynamics (user + time + CTCS penalties)\n            - states: Augmented states (user + time + CTCS augmented)\n            - controls: Augmented controls (user + time dilation)\n            - constraints: ConstraintSet with is_categorized=True\n            - parameters: Dict of extracted parameter values\n            - node_intervals: List of (start, end) tuples for CTCS intervals\n            - dynamics_prop: Propagation dynamics\n            - states_prop: Propagation states\n            - controls_prop: Propagation controls\n\n    Raises:\n        ValueError: If validation fails at any stage\n\n    Example:\n        Basic usage with CTCS constraint::\n\n            import openscvx as ox\n            from openscvx.symbolic.constraint_set import ConstraintSet\n\n            x = ox.State(\"x\", shape=(2,))\n            v = ox.State(\"v\", shape=(2,))\n            u = ox.Control(\"u\", shape=(2,))\n\n            dynamics = {\"x\": v, \"v\": u}\n            constraints = ConstraintSet(unsorted=[\n                (ox.Norm(x) &lt;= 5.0).over((0, 50))\n            ])\n\n            problem = preprocess_symbolic_problem(\n                dynamics=dynamics,\n                constraints=constraints,\n                states=[x, v],\n                controls=[u],\n                N=50,\n                time=ox.Time(initial=0.0, final=10.0)\n            )\n\n            assert problem.is_preprocessed\n            # problem.dynamics: augmented dynamics expression\n            # problem.states: [x, v, time, _ctcs_aug_0]\n            # problem.controls: [u, _time_dilation]\n            print([s.name for s in problem.states])\n            # ['x', 'v', 'time', '_ctcs_aug_0']\n\n        With propagation-only states::\n\n            distance = ox.State(\"distance\", shape=(1,))\n            dynamics_extra = {\"distance\": ox.Norm(v)}\n\n            problem = preprocess_symbolic_problem(\n                dynamics=dynamics,\n                constraints=constraints,\n                states=[x, v],\n                controls=[u],\n                N=50,\n                time=ox.Time(initial=0.0, final=10.0),\n                dynamics_prop_extra=dynamics_extra,\n                states_prop_extra=[distance]\n            )\n\n            # Propagation states include distance for post-solve simulation\n            print([s.name for s in problem.states_prop])\n    \"\"\"\n\n    # ==================== PHASE 1: Time Handling &amp; Validation ====================\n\n    # Validate time handling approach and get processed parameters\n    (\n        has_time_state,\n        time_initial,\n        time_final,\n        time_derivative,\n        time_min,\n        time_max,\n    ) = validate_time_parameters(states, time)\n\n    # Augment states with time state if needed (auto-create approach)\n    if not has_time_state:\n        states, constraints = augment_with_time_state(\n            states,\n            constraints,\n            time_initial,\n            time_final,\n            time_min,\n            time_max,\n            N,\n            time_scaling_min=getattr(time, \"scaling_min\", None),\n            time_scaling_max=getattr(time, \"scaling_max\", None),\n        )\n\n    # Add time derivative to dynamics dict (if not already present)\n    # Time derivative is always 1.0 when using Time object\n    dynamics = dict(dynamics)  # Make a copy to avoid mutating the input\n    if \"time\" not in dynamics:\n        dynamics[\"time\"] = 1.0\n\n    # Validate dynamics dict matches state names and dimensions\n    validate_dynamics_dict(dynamics, states)\n    validate_dynamics_dict_dimensions(dynamics, states)\n\n    # Convert dynamics dict to concatenated expression\n    dynamics, dynamics_concat = convert_dynamics_dict_to_expr(dynamics, states)\n\n    # ==================== PHASE 2: Expression Validation ====================\n\n    # Validate all expressions (use unsorted constraints)\n    all_exprs = [dynamics_concat] + constraints.unsorted\n    validate_variable_names(all_exprs)\n    collect_and_assign_slices(states, controls)\n    validate_shapes(all_exprs)\n    validate_constraints_at_root(constraints.unsorted)\n    validate_and_normalize_constraint_nodes(constraints.unsorted, N)\n    validate_dynamics_dimension(dynamics_concat, states)\n\n    # ==================== PHASE 3: Canonicalization &amp; Parameter Collection ====================\n\n    # Canonicalize all expressions after validation\n    dynamics_concat = dynamics_concat.canonicalize()\n    constraints.unsorted = [expr.canonicalize() for expr in constraints.unsorted]\n\n    # Collect parameter values from all constraints and dynamics\n    parameters = {}\n\n    def collect_param_values(expr):\n        if isinstance(expr, Parameter):\n            if expr.name not in parameters:\n                parameters[expr.name] = expr.value\n\n    # Collect from dynamics\n    traverse(dynamics_concat, collect_param_values)\n\n    # Collect from constraints\n    for constraint in constraints.unsorted:\n        traverse(constraint, collect_param_values)\n\n    # ==================== PHASE 4: Constraint Separation &amp; Augmentation ====================\n\n    # Sort and separate constraints by type (drains unsorted -&gt; fills categories)\n    separate_constraints(constraints, N)\n\n    # Decompose vector-valued nodal constraints into scalar constraints\n    # This is necessary for non-convex nodal constraints that get lowered to JAX\n    constraints.nodal = decompose_vector_nodal_constraints(constraints.nodal)\n\n    # Sort CTCS constraints by their idx to get node_intervals\n    constraints.ctcs, node_intervals, _ = sort_ctcs_constraints(constraints.ctcs)\n\n    # Augment dynamics, states, and controls with CTCS constraints, time dilation\n    dynamics_aug, states_aug, controls_aug = augment_dynamics_with_ctcs(\n        dynamics_concat,\n        states,\n        controls,\n        constraints.ctcs,\n        N,\n        licq_min=licq_min,\n        licq_max=licq_max,\n        time_dilation_factor_min=time_dilation_factor_min,\n        time_dilation_factor_max=time_dilation_factor_max,\n    )\n\n    # Assign slices to augmented states and controls in canonical order\n    collect_and_assign_slices(states_aug, controls_aug)\n\n    # ==================== PHASE 5: Create Propagation Dynamics ====================\n\n    # By default, propagation dynamics are the same as optimization dynamics\n    # Use deepcopy to avoid reference issues when lowering\n    from copy import deepcopy\n\n    dynamics_prop = deepcopy(dynamics_aug)\n    states_prop = list(states_aug)  # Shallow copy of list is fine for states\n    controls_prop = list(controls_aug)\n\n    # If user provided extra propagation states, extend propagation dynamics\n    if dynamics_prop_extra is not None and states_prop_extra is not None:\n        (\n            dynamics_prop,\n            states_prop,\n            controls_prop,\n            parameters,\n        ) = add_propagation_states(\n            dynamics_extra=dynamics_prop_extra,\n            states_extra=states_prop_extra,\n            dynamics_opt=dynamics_prop,\n            states_opt=states_prop,\n            controls_opt=controls_prop,\n            parameters=parameters,\n        )\n\n    # ==================== Return SymbolicProblem ====================\n\n    return SymbolicProblem(\n        dynamics=dynamics_aug,\n        states=states_aug,\n        controls=controls_aug,\n        constraints=constraints,\n        parameters=parameters,\n        N=N,\n        node_intervals=node_intervals,\n        dynamics_prop=dynamics_prop,\n        states_prop=states_prop,\n        controls_prop=controls_prop,\n    )\n</code></pre>"},{"location":"reference/symbolic/constraint_set/","title":"constraint_set","text":"<p>Container for categorized symbolic constraints.</p> <p>This module provides a dataclass to hold all symbolic constraint types in a structured way before they are lowered to JAX/CVXPy.</p>"},{"location":"reference/symbolic/constraint_set/#openscvx.symbolic.constraint_set.ConstraintSet","title":"<code>ConstraintSet</code>  <code>dataclass</code>","text":"<p>Container for categorized symbolic constraints.</p> <p>This dataclass holds all symbolic constraint types in a structured way, providing type safety and a clear API for accessing constraint categories. This is a pre-lowering container - after lowering, constraints live in LoweredJaxConstraints and LoweredCvxpyConstraints.</p> <p>The constraint set supports two lifecycle stages:</p> <ol> <li>Before preprocessing: Raw constraints live in <code>unsorted</code></li> <li>After preprocessing: <code>unsorted</code> is empty, constraints are categorized</li> </ol> <p>Use <code>is_categorized</code> to check which stage the constraint set is in.</p> <p>Attributes:</p> Name Type Description <code>unsorted</code> <code>List[Union[Constraint, CTCS]]</code> <p>Raw constraints before categorization. Empty after preprocessing.</p> <code>ctcs</code> <code>List[CTCS]</code> <p>CTCS (continuous-time) constraints.</p> <code>nodal</code> <code>List[NodalConstraint]</code> <p>Non-convex nodal constraints (will be lowered to JAX).</p> <code>nodal_convex</code> <code>List[NodalConstraint]</code> <p>Convex nodal constraints (will be lowered to CVXPy).</p> <code>cross_node</code> <code>List[CrossNodeConstraint]</code> <p>Non-convex cross-node constraints (will be lowered to JAX).</p> <code>cross_node_convex</code> <code>List[CrossNodeConstraint]</code> <p>Convex cross-node constraints (will be lowered to CVXPy).</p> Example <p>Before preprocessing (raw constraints)::</p> <pre><code>constraints = ConstraintSet(unsorted=[c1, c2, c3])\nassert not constraints.is_categorized\n</code></pre> <p>After preprocessing (categorized)::</p> <pre><code># preprocess_symbolic_problem drains unsorted -&gt; fills categories\nassert constraints.is_categorized\nfor c in constraints.nodal:\n    # Process non-convex nodal constraints\n    pass\n</code></pre> Source code in <code>openscvx/symbolic/constraint_set.py</code> <pre><code>@dataclass\nclass ConstraintSet:\n    \"\"\"Container for categorized symbolic constraints.\n\n    This dataclass holds all symbolic constraint types in a structured way,\n    providing type safety and a clear API for accessing constraint categories.\n    This is a pre-lowering container - after lowering, constraints live in\n    LoweredJaxConstraints and LoweredCvxpyConstraints.\n\n    The constraint set supports two lifecycle stages:\n\n    1. **Before preprocessing**: Raw constraints live in `unsorted`\n    2. **After preprocessing**: `unsorted` is empty, constraints are categorized\n\n    Use `is_categorized` to check which stage the constraint set is in.\n\n    Attributes:\n        unsorted: Raw constraints before categorization. Empty after preprocessing.\n        ctcs: CTCS (continuous-time) constraints.\n        nodal: Non-convex nodal constraints (will be lowered to JAX).\n        nodal_convex: Convex nodal constraints (will be lowered to CVXPy).\n        cross_node: Non-convex cross-node constraints (will be lowered to JAX).\n        cross_node_convex: Convex cross-node constraints (will be lowered to CVXPy).\n\n    Example:\n        Before preprocessing (raw constraints)::\n\n            constraints = ConstraintSet(unsorted=[c1, c2, c3])\n            assert not constraints.is_categorized\n\n        After preprocessing (categorized)::\n\n            # preprocess_symbolic_problem drains unsorted -&gt; fills categories\n            assert constraints.is_categorized\n            for c in constraints.nodal:\n                # Process non-convex nodal constraints\n                pass\n    \"\"\"\n\n    # Raw constraints before categorization (empty after preprocessing)\n    unsorted: List[Union[\"Constraint\", \"CTCS\"]] = field(default_factory=list)\n\n    # Categorized symbolic constraints (populated by preprocessing)\n    ctcs: List[\"CTCS\"] = field(default_factory=list)\n    nodal: List[\"NodalConstraint\"] = field(default_factory=list)\n    nodal_convex: List[\"NodalConstraint\"] = field(default_factory=list)\n    cross_node: List[\"CrossNodeConstraint\"] = field(default_factory=list)\n    cross_node_convex: List[\"CrossNodeConstraint\"] = field(default_factory=list)\n\n    @property\n    def is_categorized(self) -&gt; bool:\n        \"\"\"True if all constraints have been sorted into categories.\n\n        After preprocessing, `unsorted` should be empty and all constraints\n        should be in their appropriate category lists.\n        \"\"\"\n        return len(self.unsorted) == 0\n\n    def __bool__(self) -&gt; bool:\n        \"\"\"Return True if any constraint list is non-empty.\"\"\"\n        return bool(\n            self.unsorted\n            or self.ctcs\n            or self.nodal\n            or self.nodal_convex\n            or self.cross_node\n            or self.cross_node_convex\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return total number of constraints across all lists.\"\"\"\n        return (\n            len(self.unsorted)\n            + len(self.ctcs)\n            + len(self.nodal)\n            + len(self.nodal_convex)\n            + len(self.cross_node)\n            + len(self.cross_node_convex)\n        )\n</code></pre>"},{"location":"reference/symbolic/constraint_set/#openscvx.symbolic.constraint_set.ConstraintSet.is_categorized","title":"<code>is_categorized: bool</code>  <code>property</code>","text":"<p>True if all constraints have been sorted into categories.</p> <p>After preprocessing, <code>unsorted</code> should be empty and all constraints should be in their appropriate category lists.</p>"},{"location":"reference/symbolic/hashing/","title":"hashing","text":"<p>Structural hashing for symbolic problems.</p> <p>This module provides name-invariant hashing for symbolic optimization problems. Two problems with the same mathematical structure will produce the same hash, regardless of the variable names used.</p> <p>This enables efficient caching: if a problem has already been compiled with the same structure, the cached compiled artifacts can be reused.</p>"},{"location":"reference/symbolic/hashing/#openscvx.symbolic.hashing.hash_symbolic_problem","title":"<code>hash_symbolic_problem(problem: SymbolicProblem) -&gt; str</code>","text":"<p>Compute a structural hash of a symbolic optimization problem.</p> <p>This function computes a hash that depends only on the mathematical structure of the problem, not on variable names or runtime values. Two problems with the same: - Dynamics expressions (using _slice for canonical variable positions) - Constraints - State/control shapes and boundary condition types - Parameter shapes - Configuration (N, etc.)</p> <p>will produce the same hash, regardless of what names are used for variables.</p> <p>Notably, the following are NOT included in the hash (allowing solver reuse): - Boundary condition values (initial/final state values) - Bound values (min/max for states and controls) - Parameter values (only shapes are hashed)</p> <p>Parameters:</p> Name Type Description Default <code>problem</code> <code>SymbolicProblem</code> <p>A SymbolicProblem (should be preprocessed for best results,      so that _slice attributes are set on states/controls)</p> required <p>Returns:</p> Type Description <code>str</code> <p>A hex string representing the SHA-256 hash of the problem structure</p> Source code in <code>openscvx/symbolic/hashing.py</code> <pre><code>def hash_symbolic_problem(problem: \"SymbolicProblem\") -&gt; str:\n    \"\"\"Compute a structural hash of a symbolic optimization problem.\n\n    This function computes a hash that depends only on the mathematical structure\n    of the problem, not on variable names or runtime values. Two problems with the same:\n    - Dynamics expressions (using _slice for canonical variable positions)\n    - Constraints\n    - State/control shapes and boundary condition types\n    - Parameter shapes\n    - Configuration (N, etc.)\n\n    will produce the same hash, regardless of what names are used for variables.\n\n    Notably, the following are NOT included in the hash (allowing solver reuse):\n    - Boundary condition values (initial/final state values)\n    - Bound values (min/max for states and controls)\n    - Parameter values (only shapes are hashed)\n\n    Args:\n        problem: A SymbolicProblem (should be preprocessed for best results,\n                 so that _slice attributes are set on states/controls)\n\n    Returns:\n        A hex string representing the SHA-256 hash of the problem structure\n    \"\"\"\n    hasher = hashlib.sha256()\n\n    # Include library version to invalidate cache on version changes\n    hasher.update(f\"openscvx:{__version__}:\".encode())\n\n    # Hash the dynamics\n    hasher.update(b\"dynamics:\")\n    problem.dynamics._hash_into(hasher)\n\n    # Hash propagation dynamics if present\n    if problem.dynamics_prop is not None:\n        hasher.update(b\"dynamics_prop:\")\n        problem.dynamics_prop._hash_into(hasher)\n\n    # Hash all constraints (order-invariant within each category)\n    # We compute individual hashes and sort them so that the same set of\n    # constraints produces the same hash regardless of definition order.\n    hasher.update(b\"constraints:\")\n    for constraint_list in [\n        problem.constraints.ctcs,\n        problem.constraints.nodal,\n        problem.constraints.nodal_convex,\n        problem.constraints.cross_node,\n        problem.constraints.cross_node_convex,\n    ]:\n        # Compute individual hashes for each constraint\n        constraint_hashes = sorted(c.structural_hash() for c in constraint_list)\n        # Hash the count and sorted hashes\n        hasher.update(len(constraint_hashes).to_bytes(4, \"big\"))\n        for h in constraint_hashes:\n            hasher.update(h)\n\n    # Hash all states and controls explicitly to capture metadata (boundary\n    # condition types) that may not appear in expressions. For example, a state\n    # with dynamics dx/dt = 1.0 doesn't appear in the expression tree, but its\n    # boundary condition types still affect the compiled problem structure.\n    hasher.update(b\"states:\")\n    for state in problem.states:\n        state._hash_into(hasher)\n\n    hasher.update(b\"controls:\")\n    for control in problem.controls:\n        control._hash_into(hasher)\n\n    # Hash parameter shapes (not values) from the problem's parameter dict.\n    # This allows the same compiled solver to be reused across parameter sweeps -\n    # only the structure matters for compilation, not the actual values.\n    hasher.update(b\"parameters:\")\n    hasher.update(str(len(problem.parameters)).encode())  # Hash count for structure\n    for name in sorted(problem.parameters.keys()):\n        value = problem.parameters[name]\n        # Only hash shape, not name - maintains name-invariance\n        if isinstance(value, np.ndarray):\n            hasher.update(str(value.shape).encode())\n        else:\n            hasher.update(b\"scalar\")\n\n    # Hash configuration\n    hasher.update(f\"N:{problem.N}\".encode())\n\n    # Hash node intervals for CTCS\n    hasher.update(b\"node_intervals:\")\n    for interval in problem.node_intervals:\n        hasher.update(f\"{interval}\".encode())\n\n    return hasher.hexdigest()\n</code></pre>"},{"location":"reference/symbolic/lower/","title":"lower","text":"<p>Symbolic expression lowering to executable code.</p> <p>This module provides the main entry point for converting symbolic expressions (AST nodes) into executable code for different backends (JAX, CVXPy, etc.). The lowering process translates the symbolic expression tree into functions that can be executed during optimization.</p> Architecture <p>The lowering process follows a visitor pattern where each backend implements a lowerer class (e.g., JaxLowerer, CVXPyLowerer) with visitor methods for each expression type. The <code>lower()</code> function dispatches expression nodes to the appropriate backend.</p> <p>Lowering Flow:</p> <ol> <li>Symbolic expressions are built during problem specification</li> <li>lower_symbolic_expressions() coordinates the full lowering process</li> <li>Backend-specific lowerers convert each expression node to executable code</li> <li>Automatic differentiation creates Jacobians for dynamics and constraints</li> <li>Result is a set of executable functions ready for numerical optimization</li> </ol> Backends <ul> <li>JAX: For dynamics and non-convex constraints (with automatic differentiation)</li> <li>CVXPy: For convex constraints (with disciplined convex programming)</li> </ul> Example <p>Basic lowering to JAX::</p> <pre><code>import openscvx as ox\nfrom openscvx.symbolic.lower import lower_to_jax\n\n# Define symbolic expression\nx = ox.State(\"x\", shape=(3,))\nu = ox.Control(\"u\", shape=(2,))\nexpr = ox.Norm(x)**2 + 0.1 * ox.Norm(u)**2\n\n# Lower to JAX function\nf = lower_to_jax(expr)\n# f is now a callable: f(x_val, u_val, node, params) -&gt; scalar\n</code></pre> <p>Full problem lowering::</p> <pre><code># After building symbolic problem...\nlowered = lower_symbolic_problem(\n    dynamics_aug, states_aug, controls_aug,\n    constraints, parameters, N,\n    dynamics_prop, states_prop, controls_prop\n)\n# Access via LoweredProblem dataclass\ndynamics = lowered.dynamics\njax_constraints = lowered.jax_constraints\n# Now have executable JAX functions with Jacobians\n</code></pre>"},{"location":"reference/symbolic/lower/#openscvx.symbolic.lower._contains_node_reference","title":"<code>_contains_node_reference(expr: Expr) -&gt; bool</code>","text":"<p>Check if an expression contains any NodeReference nodes.</p> <p>Internal helper for routing constraints during lowering.</p> <p>Recursively traverses the expression tree to detect the presence of NodeReference nodes, which indicate cross-node constraints.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Expression to check for NodeReference nodes</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the expression contains at least one NodeReference, False otherwise</p> Example <p>position = State(\"pos\", shape=(3,))</p> Source code in <code>openscvx/symbolic/lower.py</code> <pre><code>def _contains_node_reference(expr: Expr) -&gt; bool:\n    \"\"\"Check if an expression contains any NodeReference nodes.\n\n    Internal helper for routing constraints during lowering.\n\n    Recursively traverses the expression tree to detect the presence of\n    NodeReference nodes, which indicate cross-node constraints.\n\n    Args:\n        expr: Expression to check for NodeReference nodes\n\n    Returns:\n        True if the expression contains at least one NodeReference, False otherwise\n\n    Example:\n        position = State(\"pos\", shape=(3,))\n\n        # Regular expression - no NodeReference\n        _contains_node_reference(position)  # False\n\n        # Cross-node expression - has NodeReference\n        _contains_node_reference(position.at(10) - position.at(9))  # True\n    \"\"\"\n    if isinstance(expr, NodeReference):\n        return True\n\n    # Recursively check all children\n    for child in expr.children():\n        if _contains_node_reference(child):\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/symbolic/lower/#openscvx.symbolic.lower._contains_node_reference--regular-expression-no-nodereference","title":"Regular expression - no NodeReference","text":"<p>_contains_node_reference(position)  # False</p>"},{"location":"reference/symbolic/lower/#openscvx.symbolic.lower._contains_node_reference--cross-node-expression-has-nodereference","title":"Cross-node expression - has NodeReference","text":"<p>_contains_node_reference(position.at(10) - position.at(9))  # True</p>"},{"location":"reference/symbolic/lower/#openscvx.symbolic.lower._lower_cvxpy","title":"<code>_lower_cvxpy(constraints: ConstraintSet, parameters: dict, N: int, x_unified: UnifiedState, u_unified: UnifiedControl) -&gt; Tuple[CVXPyVariables, LoweredCvxpyConstraints, dict]</code>","text":"<p>Create CVXPy variables and lower convex constraints.</p> <p>Creates all CVXPy variables/parameters needed for the OCP and lowers convex constraints to CVXPy constraint objects.</p> <p>Parameters:</p> Name Type Description Default <code>constraints</code> <code>ConstraintSet</code> <p>ConstraintSet containing convex constraints</p> required <code>parameters</code> <code>dict</code> <p>Dict of parameter values for constraint lowering</p> required <code>N</code> <code>int</code> <p>Number of discretization nodes</p> required <code>x_unified</code> <code>UnifiedState</code> <p>Unified state interface (for dimensions and scaling)</p> required <code>u_unified</code> <code>UnifiedControl</code> <p>Unified control interface (for dimensions and scaling)</p> required <p>Returns:</p> Type Description <code>CVXPyVariables</code> <p>Tuple of:</p> <code>LoweredCvxpyConstraints</code> <ul> <li>CVXPyVariables dataclass with all OCP variables</li> </ul> <code>dict</code> <ul> <li>LoweredCvxpyConstraints with CVXPy constraint objects</li> </ul> <code>Tuple[CVXPyVariables, LoweredCvxpyConstraints, dict]</code> <ul> <li>Dict mapping parameter names to CVXPy Parameter objects</li> </ul> Source code in <code>openscvx/symbolic/lower.py</code> <pre><code>def _lower_cvxpy(\n    constraints: ConstraintSet,\n    parameters: dict,\n    N: int,\n    x_unified: UnifiedState,\n    u_unified: UnifiedControl,\n) -&gt; Tuple[CVXPyVariables, LoweredCvxpyConstraints, dict]:\n    \"\"\"Create CVXPy variables and lower convex constraints.\n\n    Creates all CVXPy variables/parameters needed for the OCP and lowers\n    convex constraints to CVXPy constraint objects.\n\n    Args:\n        constraints: ConstraintSet containing convex constraints\n        parameters: Dict of parameter values for constraint lowering\n        N: Number of discretization nodes\n        x_unified: Unified state interface (for dimensions and scaling)\n        u_unified: Unified control interface (for dimensions and scaling)\n\n    Returns:\n        Tuple of:\n        - CVXPyVariables dataclass with all OCP variables\n        - LoweredCvxpyConstraints with CVXPy constraint objects\n        - Dict mapping parameter names to CVXPy Parameter objects\n    \"\"\"\n    from openscvx.config import get_affine_scaling_matrices\n\n    n_states = len(x_unified.max)\n    n_controls = len(u_unified.max)\n\n    # Compute scaling matrices from unified object bounds\n    if x_unified.scaling_min is not None:\n        lower_x = np.array(x_unified.scaling_min, dtype=float)\n    else:\n        lower_x = np.array(x_unified.min, dtype=float)\n\n    if x_unified.scaling_max is not None:\n        upper_x = np.array(x_unified.scaling_max, dtype=float)\n    else:\n        upper_x = np.array(x_unified.max, dtype=float)\n\n    S_x, c_x = get_affine_scaling_matrices(n_states, lower_x, upper_x)\n\n    if u_unified.scaling_min is not None:\n        lower_u = np.array(u_unified.scaling_min, dtype=float)\n    else:\n        lower_u = np.array(u_unified.min, dtype=float)\n\n    if u_unified.scaling_max is not None:\n        upper_u = np.array(u_unified.scaling_max, dtype=float)\n    else:\n        upper_u = np.array(u_unified.max, dtype=float)\n\n    S_u, c_u = get_affine_scaling_matrices(n_controls, lower_u, upper_u)\n\n    # Create all CVXPy variables for the OCP\n    ocp_vars = create_cvxpy_variables(\n        N=N,\n        n_states=n_states,\n        n_controls=n_controls,\n        S_x=S_x,\n        c_x=c_x,\n        S_u=S_u,\n        c_u=c_u,\n        n_nodal_constraints=len(constraints.nodal),\n        n_cross_node_constraints=len(constraints.cross_node),\n    )\n\n    # Lower convex constraints to CVXPy\n    lowered_cvxpy_constraint_list, cvxpy_params = lower_cvxpy_constraints(\n        constraints,\n        ocp_vars.x_nonscaled,\n        ocp_vars.u_nonscaled,\n        parameters,\n    )\n\n    cvxpy_constraints = LoweredCvxpyConstraints(\n        constraints=lowered_cvxpy_constraint_list,\n    )\n\n    return ocp_vars, cvxpy_constraints, cvxpy_params\n</code></pre>"},{"location":"reference/symbolic/lower/#openscvx.symbolic.lower._lower_dynamics","title":"<code>_lower_dynamics(dynamics_expr) -&gt; Dynamics</code>","text":"<p>Lower symbolic dynamics to JAX function with Jacobians.</p> <p>Converts a symbolic dynamics expression to a JAX function and computes Jacobians via automatic differentiation.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics_expr</code> <p>Symbolic dynamics expression (dx/dt = f(x, u))</p> required <p>Returns:</p> Type Description <code>Dynamics</code> <p>Dynamics object with f, A (df/dx), B (df/du)</p> Source code in <code>openscvx/symbolic/lower.py</code> <pre><code>def _lower_dynamics(dynamics_expr) -&gt; Dynamics:\n    \"\"\"Lower symbolic dynamics to JAX function with Jacobians.\n\n    Converts a symbolic dynamics expression to a JAX function and computes\n    Jacobians via automatic differentiation.\n\n    Args:\n        dynamics_expr: Symbolic dynamics expression (dx/dt = f(x, u))\n\n    Returns:\n        Dynamics object with f, A (df/dx), B (df/du)\n    \"\"\"\n    dyn_fn = lower_to_jax(dynamics_expr)\n    return Dynamics(\n        f=dyn_fn,\n        A=jacfwd(dyn_fn, argnums=0),  # df/dx\n        B=jacfwd(dyn_fn, argnums=1),  # df/du\n    )\n</code></pre>"},{"location":"reference/symbolic/lower/#openscvx.symbolic.lower._lower_jax_constraints","title":"<code>_lower_jax_constraints(constraints: ConstraintSet) -&gt; LoweredJaxConstraints</code>","text":"<p>Lower non-convex constraints to JAX functions with gradients.</p> <p>Converts symbolic non-convex constraints to JAX callable functions with automatically computed gradients for use in SCP linearization.</p> <p>Parameters:</p> Name Type Description Default <code>constraints</code> <code>ConstraintSet</code> <p>ConstraintSet containing nodal and cross_node constraints</p> required <p>Returns:</p> Type Description <code>LoweredJaxConstraints</code> <p>LoweredJaxConstraints with nodal, cross_node, and ctcs lists</p> Source code in <code>openscvx/symbolic/lower.py</code> <pre><code>def _lower_jax_constraints(\n    constraints: ConstraintSet,\n) -&gt; LoweredJaxConstraints:\n    \"\"\"Lower non-convex constraints to JAX functions with gradients.\n\n    Converts symbolic non-convex constraints to JAX callable functions with\n    automatically computed gradients for use in SCP linearization.\n\n    Args:\n        constraints: ConstraintSet containing nodal and cross_node constraints\n\n    Returns:\n        LoweredJaxConstraints with nodal, cross_node, and ctcs lists\n    \"\"\"\n    lowered_nodal: List[LoweredNodalConstraint] = []\n    lowered_cross_node: List[LoweredCrossNodeConstraint] = []\n\n    # Lower regular nodal constraints\n    if len(constraints.nodal) &gt; 0:\n        # Convert symbolic constraint expressions to JAX functions\n        constraints_nodal_fns = lower_to_jax(constraints.nodal)\n\n        # Create LoweredConstraint objects with Jacobians\n        for i, fn in enumerate(constraints_nodal_fns):\n            # Apply vectorization to handle (N, n_x) and (N, n_u) inputs\n            constraint = LoweredNodalConstraint(\n                func=jax.vmap(fn, in_axes=(0, 0, None, None)),\n                grad_g_x=jax.vmap(jacfwd(fn, argnums=0), in_axes=(0, 0, None, None)),\n                grad_g_u=jax.vmap(jacfwd(fn, argnums=1), in_axes=(0, 0, None, None)),\n                nodes=constraints.nodal[i].nodes,\n            )\n            lowered_nodal.append(constraint)\n\n    # Lower cross-node constraints (trajectory-level)\n    for cross_node_constraint in constraints.cross_node:\n        # Lower the CrossNodeConstraint - visitor handles wrapping\n        constraint_fn = lower_to_jax(cross_node_constraint)\n\n        # Compute Jacobians for trajectory-level function\n        grad_g_X = jacfwd(constraint_fn, argnums=0)  # dg/dX - shape (N, n_x)\n        grad_g_U = jacfwd(constraint_fn, argnums=1)  # dg/dU - shape (N, n_u)\n\n        cross_node_lowered = LoweredCrossNodeConstraint(\n            func=constraint_fn,\n            grad_g_X=grad_g_X,\n            grad_g_U=grad_g_U,\n        )\n        lowered_cross_node.append(cross_node_lowered)\n\n    return LoweredJaxConstraints(\n        nodal=lowered_nodal,\n        cross_node=lowered_cross_node,\n        ctcs=list(constraints.ctcs),  # Copy the list\n    )\n</code></pre>"},{"location":"reference/symbolic/lower/#openscvx.symbolic.lower.create_cvxpy_variables","title":"<code>create_cvxpy_variables(N: int, n_states: int, n_controls: int, S_x: np.ndarray, c_x: np.ndarray, S_u: np.ndarray, c_u: np.ndarray, n_nodal_constraints: int, n_cross_node_constraints: int) -&gt; CVXPyVariables</code>","text":"<p>Create CVXPy variables and parameters for the optimal control problem.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Number of discretization nodes</p> required <code>n_states</code> <code>int</code> <p>Number of state variables</p> required <code>n_controls</code> <code>int</code> <p>Number of control variables</p> required <code>S_x</code> <code>ndarray</code> <p>State scaling matrix</p> required <code>c_x</code> <code>ndarray</code> <p>State offset vector</p> required <code>S_u</code> <code>ndarray</code> <p>Control scaling matrix</p> required <code>c_u</code> <code>ndarray</code> <p>Control offset vector</p> required <code>n_nodal_constraints</code> <code>int</code> <p>Number of non-convex nodal constraints (for linearization params)</p> required <code>n_cross_node_constraints</code> <code>int</code> <p>Number of non-convex cross-node constraints</p> required <p>Returns:</p> Type Description <code>CVXPyVariables</code> <p>CVXPyVariables dataclass containing all CVXPy variables and parameters for the OCP</p> Source code in <code>openscvx/symbolic/lower.py</code> <pre><code>def create_cvxpy_variables(\n    N: int,\n    n_states: int,\n    n_controls: int,\n    S_x: np.ndarray,\n    c_x: np.ndarray,\n    S_u: np.ndarray,\n    c_u: np.ndarray,\n    n_nodal_constraints: int,\n    n_cross_node_constraints: int,\n) -&gt; CVXPyVariables:\n    \"\"\"Create CVXPy variables and parameters for the optimal control problem.\n\n    Args:\n        N: Number of discretization nodes\n        n_states: Number of state variables\n        n_controls: Number of control variables\n        S_x: State scaling matrix\n        c_x: State offset vector\n        S_u: Control scaling matrix\n        c_u: Control offset vector\n        n_nodal_constraints: Number of non-convex nodal constraints (for linearization params)\n        n_cross_node_constraints: Number of non-convex cross-node constraints\n\n    Returns:\n        CVXPyVariables dataclass containing all CVXPy variables and parameters for the OCP\n    \"\"\"\n    ########################\n    # VARIABLES &amp; PARAMETERS\n    ########################\n\n    inv_S_x = np.linalg.inv(S_x)\n    inv_S_u = np.linalg.inv(S_u)\n\n    # Parameters\n    w_tr = cp.Parameter(nonneg=True, name=\"w_tr\")\n    lam_cost = cp.Parameter(nonneg=True, name=\"lam_cost\")\n    lam_vc = cp.Parameter((N - 1, n_states), nonneg=True, name=\"lam_vc\")\n    lam_vb = cp.Parameter(nonneg=True, name=\"lam_vb\")\n\n    # State\n    x = cp.Variable((N, n_states), name=\"x\")  # Current State\n    dx = cp.Variable((N, n_states), name=\"dx\")  # State Error\n    x_bar = cp.Parameter((N, n_states), name=\"x_bar\")  # Previous SCP State\n    x_init = cp.Parameter(n_states, name=\"x_init\")  # Initial State\n    x_term = cp.Parameter(n_states, name=\"x_term\")  # Final State\n\n    # Control\n    u = cp.Variable((N, n_controls), name=\"u\")  # Current Control\n    du = cp.Variable((N, n_controls), name=\"du\")  # Control Error\n    u_bar = cp.Parameter((N, n_controls), name=\"u_bar\")  # Previous SCP Control\n\n    # Discretized Augmented Dynamics Constraints\n    A_d = cp.Parameter((N - 1, n_states, n_states), name=\"A_d\")\n    B_d = cp.Parameter((N - 1, n_states, n_controls), name=\"B_d\")\n    C_d = cp.Parameter((N - 1, n_states, n_controls), name=\"C_d\")\n    x_prop = cp.Parameter((N - 1, n_states), name=\"x_prop\")\n    nu = cp.Variable((N - 1, n_states), name=\"nu\")  # Virtual Control\n\n    # Linearized Nonconvex Nodal Constraints\n    g = []\n    grad_g_x = []\n    grad_g_u = []\n    nu_vb = []\n    for idx_ncvx in range(n_nodal_constraints):\n        g.append(cp.Parameter(N, name=\"g_\" + str(idx_ncvx)))\n        grad_g_x.append(cp.Parameter((N, n_states), name=\"grad_g_x_\" + str(idx_ncvx)))\n        grad_g_u.append(cp.Parameter((N, n_controls), name=\"grad_g_u_\" + str(idx_ncvx)))\n        nu_vb.append(cp.Variable(N, name=\"nu_vb_\" + str(idx_ncvx)))  # Virtual Control for VB\n\n    # Linearized Cross-Node Constraints\n    g_cross = []\n    grad_g_X_cross = []\n    grad_g_U_cross = []\n    nu_vb_cross = []\n    for idx_cross in range(n_cross_node_constraints):\n        # Cross-node constraints are single constraints with fixed node references\n        g_cross.append(cp.Parameter(name=\"g_cross_\" + str(idx_cross)))\n        grad_g_X_cross.append(cp.Parameter((N, n_states), name=\"grad_g_X_cross_\" + str(idx_cross)))\n        grad_g_U_cross.append(\n            cp.Parameter((N, n_controls), name=\"grad_g_U_cross_\" + str(idx_cross))\n        )\n        nu_vb_cross.append(\n            cp.Variable(name=\"nu_vb_cross_\" + str(idx_cross))\n        )  # Virtual Control for VB\n\n    # Applying the affine scaling to state and control\n    x_nonscaled = []\n    u_nonscaled = []\n    dx_nonscaled = []\n    du_nonscaled = []\n    for k in range(N):\n        x_nonscaled.append(S_x @ x[k] + c_x)\n        u_nonscaled.append(S_u @ u[k] + c_u)\n        dx_nonscaled.append(S_x @ dx[k])\n        du_nonscaled.append(S_u @ du[k])\n\n    return CVXPyVariables(\n        w_tr=w_tr,\n        lam_cost=lam_cost,\n        lam_vc=lam_vc,\n        lam_vb=lam_vb,\n        x=x,\n        dx=dx,\n        x_bar=x_bar,\n        x_init=x_init,\n        x_term=x_term,\n        u=u,\n        du=du,\n        u_bar=u_bar,\n        A_d=A_d,\n        B_d=B_d,\n        C_d=C_d,\n        x_prop=x_prop,\n        nu=nu,\n        g=g,\n        grad_g_x=grad_g_x,\n        grad_g_u=grad_g_u,\n        nu_vb=nu_vb,\n        g_cross=g_cross,\n        grad_g_X_cross=grad_g_X_cross,\n        grad_g_U_cross=grad_g_U_cross,\n        nu_vb_cross=nu_vb_cross,\n        S_x=S_x,\n        inv_S_x=inv_S_x,\n        c_x=c_x,\n        S_u=S_u,\n        inv_S_u=inv_S_u,\n        c_u=c_u,\n        x_nonscaled=x_nonscaled,\n        u_nonscaled=u_nonscaled,\n        dx_nonscaled=dx_nonscaled,\n        du_nonscaled=du_nonscaled,\n    )\n</code></pre>"},{"location":"reference/symbolic/lower/#openscvx.symbolic.lower.lower","title":"<code>lower(expr: Expr, lowerer: Any)</code>","text":"<p>Dispatch an expression node to the appropriate lowerer backend.</p> <p>This is the main entry point for lowering a single symbolic expression to executable code. It delegates to the lowerer's <code>lower()</code> method, which uses the visitor pattern to dispatch based on expression type.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Symbolic expression to lower (any Expr subclass)</p> required <code>lowerer</code> <code>Any</code> <p>Backend lowerer instance (e.g., JaxLowerer, CVXPyLowerer)</p> required <p>Returns:</p> Type Description <p>Backend-specific representation of the expression. For JaxLowerer,</p> <p>returns a callable with signature (x, u, node, params) -&gt; result.</p> <p>For CVXPyLowerer, returns a CVXPy expression object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the lowerer doesn't support the expression type</p> Example <p>Lower an expression to the appropriate backend (here JAX):</p> <pre><code>from openscvx.symbolic.lowerers.jax import JaxLowerer\nx = ox.State(\"x\", shape=(3,))\nexpr = ox.Norm(x)\nlowerer = JaxLowerer()\nf = lower(expr, lowerer)\n</code></pre> <p>f is now callable: f(x_val, u_val, node, params) -&gt; scalar</p> Source code in <code>openscvx/symbolic/lower.py</code> <pre><code>def lower(expr: Expr, lowerer: Any):\n    \"\"\"Dispatch an expression node to the appropriate lowerer backend.\n\n    This is the main entry point for lowering a single symbolic expression to\n    executable code. It delegates to the lowerer's `lower()` method, which\n    uses the visitor pattern to dispatch based on expression type.\n\n    Args:\n        expr: Symbolic expression to lower (any Expr subclass)\n        lowerer: Backend lowerer instance (e.g., JaxLowerer, CVXPyLowerer)\n\n    Returns:\n        Backend-specific representation of the expression. For JaxLowerer,\n        returns a callable with signature (x, u, node, params) -&gt; result.\n        For CVXPyLowerer, returns a CVXPy expression object.\n\n    Raises:\n        NotImplementedError: If the lowerer doesn't support the expression type\n\n    Example:\n        Lower an expression to the appropriate backend (here JAX):\n\n            from openscvx.symbolic.lowerers.jax import JaxLowerer\n            x = ox.State(\"x\", shape=(3,))\n            expr = ox.Norm(x)\n            lowerer = JaxLowerer()\n            f = lower(expr, lowerer)\n\n        f is now callable: f(x_val, u_val, node, params) -&gt; scalar\n    \"\"\"\n    return lowerer.lower(expr)\n</code></pre>"},{"location":"reference/symbolic/lower/#openscvx.symbolic.lower.lower_cvxpy_constraints","title":"<code>lower_cvxpy_constraints(constraints: ConstraintSet, x_cvxpy: List, u_cvxpy: List, parameters: dict = None) -&gt; Tuple[List, dict]</code>","text":"<p>Lower symbolic convex constraints to CVXPy constraints.</p> <p>Converts symbolic convex constraint expressions to CVXPy constraint objects that can be used in the optimal control problem. This function handles both nodal constraints (applied at specific trajectory nodes) and cross-node constraints (relating multiple nodes).</p> <p>Parameters:</p> Name Type Description Default <code>constraints</code> <code>ConstraintSet</code> <p>ConstraintSet containing nodal_convex and cross_node_convex</p> required <code>x_cvxpy</code> <code>List</code> <p>List of CVXPy expressions for state at each node (length N). Typically the x_nonscaled list from create_cvxpy_variables().</p> required <code>u_cvxpy</code> <code>List</code> <p>List of CVXPy expressions for control at each node (length N). Typically the u_nonscaled list from create_cvxpy_variables().</p> required <code>parameters</code> <code>dict</code> <p>Optional dict of parameter values to use for any Parameter expressions in the constraints. If None, uses Parameter default values.</p> <code>None</code> <p>Returns:</p> Type Description <code>List</code> <p>Tuple of:</p> <code>dict</code> <ul> <li>List of CVXPy constraint objects ready for the OCP</li> </ul> <code>Tuple[List, dict]</code> <ul> <li>Dict mapping parameter names to their CVXPy Parameter objects</li> </ul> Example <p>After creating CVXPy variables::</p> <pre><code>ocp_vars = create_cvxpy_variables(settings)\ncvxpy_constraints, cvxpy_params = lower_cvxpy_constraints(\n    constraint_set,\n    ocp_vars.x_nonscaled,\n    ocp_vars.u_nonscaled,\n    parameters,\n)\n</code></pre> Note <p>This function only processes convex constraints (nodal_convex and cross_node_convex). Non-convex constraints are lowered to JAX in lower_symbolic_expressions() and handled via linearization in the SCP.</p> Source code in <code>openscvx/symbolic/lower.py</code> <pre><code>def lower_cvxpy_constraints(\n    constraints: ConstraintSet,\n    x_cvxpy: List,\n    u_cvxpy: List,\n    parameters: dict = None,\n) -&gt; Tuple[List, dict]:\n    \"\"\"Lower symbolic convex constraints to CVXPy constraints.\n\n    Converts symbolic convex constraint expressions to CVXPy constraint objects\n    that can be used in the optimal control problem. This function handles both\n    nodal constraints (applied at specific trajectory nodes) and cross-node\n    constraints (relating multiple nodes).\n\n    Args:\n        constraints: ConstraintSet containing nodal_convex and cross_node_convex\n        x_cvxpy: List of CVXPy expressions for state at each node (length N).\n            Typically the x_nonscaled list from create_cvxpy_variables().\n        u_cvxpy: List of CVXPy expressions for control at each node (length N).\n            Typically the u_nonscaled list from create_cvxpy_variables().\n        parameters: Optional dict of parameter values to use for any Parameter\n            expressions in the constraints. If None, uses Parameter default values.\n\n    Returns:\n        Tuple of:\n        - List of CVXPy constraint objects ready for the OCP\n        - Dict mapping parameter names to their CVXPy Parameter objects\n\n    Example:\n        After creating CVXPy variables::\n\n            ocp_vars = create_cvxpy_variables(settings)\n            cvxpy_constraints, cvxpy_params = lower_cvxpy_constraints(\n                constraint_set,\n                ocp_vars.x_nonscaled,\n                ocp_vars.u_nonscaled,\n                parameters,\n            )\n\n    Note:\n        This function only processes convex constraints (nodal_convex and\n        cross_node_convex). Non-convex constraints are lowered to JAX in\n        lower_symbolic_expressions() and handled via linearization in the SCP.\n    \"\"\"\n    import cvxpy as cp\n\n    from openscvx.symbolic.expr import Parameter, traverse\n    from openscvx.symbolic.expr.control import Control\n    from openscvx.symbolic.expr.state import State\n    from openscvx.symbolic.lowerers.cvxpy import lower_to_cvxpy\n\n    all_constraints = list(constraints.nodal_convex) + list(constraints.cross_node_convex)\n\n    if not all_constraints:\n        return [], {}\n\n    # Collect all unique Parameters across all constraints and create cp.Parameter objects\n    all_params = {}\n\n    def collect_params(expr):\n        if isinstance(expr, Parameter):\n            if expr.name not in all_params:\n                # Use value from params dict if provided, otherwise use Parameter's initial value\n                if parameters and expr.name in parameters:\n                    param_value = parameters[expr.name]\n                else:\n                    param_value = expr.value\n\n                cvx_param = cp.Parameter(expr.shape, value=param_value, name=expr.name)\n                all_params[expr.name] = cvx_param\n\n    # Collect all parameters from all constraints\n    for constraint in all_constraints:\n        traverse(constraint.constraint, collect_params)\n\n    cvxpy_constraints = []\n\n    # Process nodal constraints\n    for constraint in constraints.nodal_convex:\n        # nodes should already be validated and normalized in preprocessing\n        nodes = constraint.nodes\n\n        # Collect all State and Control variables referenced in the constraint\n        state_vars = {}\n        control_vars = {}\n\n        def collect_vars(expr):\n            if isinstance(expr, State):\n                state_vars[expr.name] = expr\n            elif isinstance(expr, Control):\n                control_vars[expr.name] = expr\n\n        traverse(constraint.constraint, collect_vars)\n\n        # Regular nodal constraint: apply at each specified node\n        for node in nodes:\n            # Create variable map for this specific node\n            variable_map = {}\n\n            if state_vars:\n                variable_map[\"x\"] = x_cvxpy[node]\n\n            if control_vars:\n                variable_map[\"u\"] = u_cvxpy[node]\n\n            # Add all CVXPy Parameter objects to the variable map\n            variable_map.update(all_params)\n\n            # Verify all variables have slices (should be guaranteed by preprocessing)\n            for state_name, state_var in state_vars.items():\n                if state_var._slice is None:\n                    raise ValueError(\n                        f\"State variable '{state_name}' has no slice assigned. \"\n                        f\"This indicates a bug in the preprocessing pipeline.\"\n                    )\n\n            for control_name, control_var in control_vars.items():\n                if control_var._slice is None:\n                    raise ValueError(\n                        f\"Control variable '{control_name}' has no slice assigned. \"\n                        f\"This indicates a bug in the preprocessing pipeline.\"\n                    )\n\n            # Lower the constraint to CVXPy\n            cvxpy_constraint = lower_to_cvxpy(constraint.constraint, variable_map)\n            cvxpy_constraints.append(cvxpy_constraint)\n\n    # Process cross-node constraints\n    for constraint in constraints.cross_node_convex:\n        # Collect all State and Control variables referenced in the constraint\n        state_vars = {}\n        control_vars = {}\n\n        def collect_vars(expr):\n            if isinstance(expr, State):\n                state_vars[expr.name] = expr\n            elif isinstance(expr, Control):\n                control_vars[expr.name] = expr\n\n        traverse(constraint.constraint, collect_vars)\n\n        # Cross-node constraint: provide full trajectory\n        variable_map = {}\n\n        # Stack all nodes into (N, n_x) and (N, n_u) matrices\n        if state_vars:\n            variable_map[\"x\"] = cp.vstack(x_cvxpy)\n\n        if control_vars:\n            variable_map[\"u\"] = cp.vstack(u_cvxpy)\n\n        # Add all CVXPy Parameter objects to the variable map\n        variable_map.update(all_params)\n\n        # Verify all variables have slices\n        for state_name, state_var in state_vars.items():\n            if state_var._slice is None:\n                raise ValueError(\n                    f\"State variable '{state_name}' has no slice assigned. \"\n                    f\"This indicates a bug in the preprocessing pipeline.\"\n                )\n\n        for control_name, control_var in control_vars.items():\n            if control_var._slice is None:\n                raise ValueError(\n                    f\"Control variable '{control_name}' has no slice assigned. \"\n                    f\"This indicates a bug in the preprocessing pipeline.\"\n                )\n\n        # Lower the constraint once - NodeReference handles node indexing internally\n        cvxpy_constraint = lower_to_cvxpy(constraint.constraint, variable_map)\n        cvxpy_constraints.append(cvxpy_constraint)\n\n    return cvxpy_constraints, all_params\n</code></pre>"},{"location":"reference/symbolic/lower/#openscvx.symbolic.lower.lower_symbolic_problem","title":"<code>lower_symbolic_problem(problem: SymbolicProblem) -&gt; LoweredProblem</code>","text":"<p>Lower symbolic problem specification to executable JAX and CVXPy code.</p> <p>This is the main orchestrator for converting a preprocessed SymbolicProblem into executable numerical code. It coordinates the lowering of dynamics, constraints, and state/control interfaces from symbolic AST representations to JAX functions (with automatic differentiation) and CVXPy constraints.</p> <p>This is pure translation - no validation, shape checking, or augmentation occurs here. The input problem must be preprocessed (problem.is_preprocessed == True).</p> <p>Parameters:</p> Name Type Description Default <code>problem</code> <code>SymbolicProblem</code> <p>Preprocessed SymbolicProblem from preprocess_symbolic_problem(). Must have is_preprocessed == True.</p> required <p>Returns:</p> Type Description <code>LoweredProblem</code> <p>LoweredProblem dataclass containing lowered problem</p> Example <p>After preprocessing::</p> <pre><code>problem = preprocess_symbolic_problem(...)\nlowered = lower_symbolic_problem(problem)\n\n# Access dynamics\ndx = lowered.dynamics.f(x_val, u_val, node=0, params={...})\n\n# Use CVXPy objects for OCP\nocp = OptimalControlProblem(settings, lowered)\n</code></pre> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If problem.is_preprocessed is False</p> Source code in <code>openscvx/symbolic/lower.py</code> <pre><code>def lower_symbolic_problem(problem: \"SymbolicProblem\") -&gt; LoweredProblem:\n    \"\"\"Lower symbolic problem specification to executable JAX and CVXPy code.\n\n    This is the main orchestrator for converting a preprocessed SymbolicProblem\n    into executable numerical code. It coordinates the lowering of dynamics,\n    constraints, and state/control interfaces from symbolic AST representations\n    to JAX functions (with automatic differentiation) and CVXPy constraints.\n\n    This is pure translation - no validation, shape checking, or augmentation occurs\n    here. The input problem must be preprocessed (problem.is_preprocessed == True).\n\n    Args:\n        problem: Preprocessed SymbolicProblem from preprocess_symbolic_problem().\n            Must have is_preprocessed == True.\n\n    Returns:\n        LoweredProblem dataclass containing lowered problem\n\n    Example:\n        After preprocessing::\n\n            problem = preprocess_symbolic_problem(...)\n            lowered = lower_symbolic_problem(problem)\n\n            # Access dynamics\n            dx = lowered.dynamics.f(x_val, u_val, node=0, params={...})\n\n            # Use CVXPy objects for OCP\n            ocp = OptimalControlProblem(settings, lowered)\n\n    Raises:\n        AssertionError: If problem.is_preprocessed is False\n    \"\"\"\n    assert problem.is_preprocessed, \"Problem must be preprocessed before lowering\"\n\n    # Create unified state/control interfaces\n    x_unified = unify_states(problem.states, name=\"x\")\n    u_unified = unify_controls(problem.controls)\n    x_prop_unified = unify_states(problem.states_prop, name=\"x_prop\")\n\n    # Lower dynamics to JAX\n    dynamics = _lower_dynamics(problem.dynamics)\n    dynamics_prop = _lower_dynamics(problem.dynamics_prop)\n\n    # Lower non-convex constraints to JAX\n    jax_constraints = _lower_jax_constraints(problem.constraints)\n\n    # Create CVXPy variables and lower convex constraints\n    ocp_vars, cvxpy_constraints, cvxpy_params = _lower_cvxpy(\n        problem.constraints, problem.parameters, problem.N, x_unified, u_unified\n    )\n\n    return LoweredProblem(\n        dynamics=dynamics,\n        dynamics_prop=dynamics_prop,\n        jax_constraints=jax_constraints,\n        cvxpy_constraints=cvxpy_constraints,\n        x_unified=x_unified,\n        u_unified=u_unified,\n        x_prop_unified=x_prop_unified,\n        ocp_vars=ocp_vars,\n        cvxpy_params=cvxpy_params,\n    )\n</code></pre>"},{"location":"reference/symbolic/lower/#openscvx.symbolic.lower.lower_to_jax","title":"<code>lower_to_jax(exprs: Union[Expr, Sequence[Expr]]) -&gt; Union[callable, list[callable]]</code>","text":"<p>Lower symbolic expression(s) to JAX callable(s).</p> <p>Convenience wrapper that creates a JaxLowerer and lowers one or more symbolic expressions to JAX functions. The resulting functions can be JIT-compiled and automatically differentiated.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>Union[Expr, Sequence[Expr]]</code> <p>Single expression or sequence of expressions to lower</p> required <p>Returns:</p> Type Description <code>Union[callable, list[callable]]</code> <ul> <li>If exprs is a single Expr: Returns a single callable with signature (x, u, node, params) -&gt; array</li> </ul> <code>Union[callable, list[callable]]</code> <ul> <li>If exprs is a sequence: Returns a list of callables with the same signature</li> </ul> Example <p>Single expression::</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nexpr = ox.Norm(x)**2\nf = lower_to_jax(expr)\n# f(x_val, u_val, node_idx, params_dict) -&gt; scalar\n</code></pre> <p>Multiple expressions::</p> <pre><code>exprs = [ox.Norm(x), ox.Norm(u), x @ A @ x]\nfns = lower_to_jax(exprs)\n# fns is [f1, f2, f3], each with same signature\n</code></pre> Note <p>All returned JAX functions have a uniform signature (x, u, node, params) regardless of whether they use all arguments. This standardization simplifies vectorization and differentiation.</p> Source code in <code>openscvx/symbolic/lower.py</code> <pre><code>def lower_to_jax(exprs: Union[Expr, Sequence[Expr]]) -&gt; Union[callable, list[callable]]:\n    \"\"\"Lower symbolic expression(s) to JAX callable(s).\n\n    Convenience wrapper that creates a JaxLowerer and lowers one or more\n    symbolic expressions to JAX functions. The resulting functions can be\n    JIT-compiled and automatically differentiated.\n\n    Args:\n        exprs: Single expression or sequence of expressions to lower\n\n    Returns:\n        - If exprs is a single Expr: Returns a single callable with signature\n          (x, u, node, params) -&gt; array\n        - If exprs is a sequence: Returns a list of callables with the same signature\n\n    Example:\n        Single expression::\n\n            x = ox.State(\"x\", shape=(3,))\n            expr = ox.Norm(x)**2\n            f = lower_to_jax(expr)\n            # f(x_val, u_val, node_idx, params_dict) -&gt; scalar\n\n        Multiple expressions::\n\n            exprs = [ox.Norm(x), ox.Norm(u), x @ A @ x]\n            fns = lower_to_jax(exprs)\n            # fns is [f1, f2, f3], each with same signature\n\n    Note:\n        All returned JAX functions have a uniform signature\n        (x, u, node, params) regardless of whether they use all arguments.\n        This standardization simplifies vectorization and differentiation.\n    \"\"\"\n    from openscvx.symbolic.lowerers.jax import JaxLowerer\n\n    jl = JaxLowerer()\n    if isinstance(exprs, Expr):\n        return lower(exprs, jl)\n    fns = [lower(e, jl) for e in exprs]\n    return fns\n</code></pre>"},{"location":"reference/symbolic/preprocessing/","title":"preprocessing","text":"<p>Validation and preprocessing utilities for symbolic expressions.</p> <p>This module provides preprocessing and validation functions for symbolic expressions in trajectory optimization problems. These utilities ensure that expressions are well-formed and constraints are properly specified before compilation to solvers.</p> The preprocessing pipeline includes <ul> <li>Shape validation: Ensure all expressions have compatible shapes</li> <li>Variable name validation: Check for unique, non-reserved variable names</li> <li>Constraint validation: Verify constraints appear only at root level</li> <li>Dynamics validation: Check that dynamics match state dimensions</li> <li>Time parameter validation: Validate time configuration</li> <li>Slice assignment: Assign contiguous memory slices to variables</li> </ul> <p>These functions are typically called automatically during problem construction, but can also be used manually for debugging or custom problem setups.</p> Example <p>Validating expressions before problem construction::</p> <pre><code>import openscvx as ox\n\nx = ox.State(\"x\", shape=(3,))\nu = ox.Control(\"u\", shape=(2,))\n\n# Build dynamics and constraints\ndynamics = {\n    \"x\": u  # Will fail validation - dimension mismatch!\n}\n\n# Validate dimensions before creating problem\nfrom openscvx.symbolic.preprocessing import validate_dynamics_dict_dimensions\n\ntry:\n    validate_dynamics_dict_dimensions(dynamics, [x])\nexcept ValueError as e:\n    print(f\"Validation error: {e}\")\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing._traverse_with_depth","title":"<code>_traverse_with_depth(expr: Expr, visit: Callable[[Expr, int], None], depth: int = 0)</code>","text":"<p>Depth-first traversal of an expression tree with depth tracking.</p> <p>Internal helper function that extends the standard traverse function to track the depth of each node in the tree. Used for constraint validation.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Root expression node to start traversal from</p> required <code>visit</code> <code>Callable[[Expr, int], None]</code> <p>Callback function applied to each (node, depth) pair during traversal</p> required <code>depth</code> <code>int</code> <p>Current depth level (default: 0)</p> <code>0</code> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def _traverse_with_depth(expr: Expr, visit: Callable[[Expr, int], None], depth: int = 0):\n    \"\"\"Depth-first traversal of an expression tree with depth tracking.\n\n    Internal helper function that extends the standard traverse function to track\n    the depth of each node in the tree. Used for constraint validation.\n\n    Args:\n        expr: Root expression node to start traversal from\n        visit: Callback function applied to each (node, depth) pair during traversal\n        depth: Current depth level (default: 0)\n    \"\"\"\n    visit(expr, depth)\n    for child in expr.children():\n        _traverse_with_depth(child, visit, depth + 1)\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.collect_and_assign_slices","title":"<code>collect_and_assign_slices(states: List[State], controls: List[Control], *, start_index: int = 0) -&gt; Tuple[list[State], list[Control]]</code>","text":"<p>Assign contiguous memory slices to states and controls.</p> <p>This function assigns slice objects to states and controls that determine their positions in the flat decision variable vector. Variables can have either: - Auto-assigned slices: Automatically assigned contiguously based on order - Manual slices: User-specified slices that must be contiguous and non-overlapping</p> <p>If any variables have manual slices, they must: - Start at index 0 (or start_index if specified) - Be contiguous and non-overlapping - Match the variable's flattened dimension</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>List[State]</code> <p>List of State objects in canonical order</p> required <code>controls</code> <code>List[Control]</code> <p>List of Control objects in canonical order</p> required <code>start_index</code> <code>int</code> <p>Starting index for slice assignment (default: 0)</p> <code>0</code> <p>Returns:</p> Type Description <code>Tuple[list[State], list[Control]]</code> <p>Tuple of (states, controls) with slice attributes assigned</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If manual slices are invalid (wrong size, overlapping, not starting at 0)</p> Example <p>x = ox.State(\"x\", shape=(3,)) u = ox.Control(\"u\", shape=(2,)) states, controls = collect_and_assign_slices([x], [u]) print(x._slice)  # slice(0, 3) print(u._slice)  # slice(0, 2)</p> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def collect_and_assign_slices(\n    states: List[State], controls: List[Control], *, start_index: int = 0\n) -&gt; Tuple[list[State], list[Control]]:\n    \"\"\"Assign contiguous memory slices to states and controls.\n\n    This function assigns slice objects to states and controls that determine their\n    positions in the flat decision variable vector. Variables can have either:\n    - Auto-assigned slices: Automatically assigned contiguously based on order\n    - Manual slices: User-specified slices that must be contiguous and non-overlapping\n\n    If any variables have manual slices, they must:\n    - Start at index 0 (or start_index if specified)\n    - Be contiguous and non-overlapping\n    - Match the variable's flattened dimension\n\n    Args:\n        states: List of State objects in canonical order\n        controls: List of Control objects in canonical order\n        start_index: Starting index for slice assignment (default: 0)\n\n    Returns:\n        Tuple of (states, controls) with slice attributes assigned\n\n    Raises:\n        ValueError: If manual slices are invalid (wrong size, overlapping, not starting at 0)\n\n    Example:\n            x = ox.State(\"x\", shape=(3,))\n            u = ox.Control(\"u\", shape=(2,))\n            states, controls = collect_and_assign_slices([x], [u])\n            print(x._slice)  # slice(0, 3)\n            print(u._slice)  # slice(0, 2)\n    \"\"\"\n\n    def assign(vars_list, start_index):\n        # split into manual vs auto\n        manual = [v for v in vars_list if v._slice is not None]\n        auto = [v for v in vars_list if v._slice is None]\n\n        if manual:\n            # 1) shape\u2010match check\n            for v in manual:\n                dim = int(np.prod(v.shape))\n                sl = v._slice\n                if (sl.stop - sl.start) != dim:\n                    raise ValueError(\n                        f\"Manual slice for {v.name!r} is length {sl.stop - sl.start}, \"\n                        f\"but variable has shape {v.shape} (dim {dim})\"\n                    )\n            # sort by the start of their slices\n            manual.sort(key=lambda v: v._slice.start)\n            # 2a) must start at 0\n            if manual[0]._slice.start != start_index:\n                raise ValueError(\"User-defined slices must start at index 0\")\n            # 2b) check contiguity &amp; no overlaps\n            cursor = start_index\n            for v in manual:\n                sl = v._slice\n                dim = int(np.prod(v.shape))\n                if sl.start != cursor or sl.stop != cursor + dim:\n                    raise ValueError(\n                        f\"Manual slice for {v.name!r} must be contiguous and non-overlapping\"\n                    )\n                cursor += dim\n            offset = cursor\n        else:\n            offset = start_index\n\n        # 3) auto-assign the rest\n        for v in auto:\n            dim = int(np.prod(v.shape))\n            v._slice = slice(offset, offset + dim)\n            offset += dim\n\n    # run separately on states (x) and controls (u)\n    assign(states, start_index)\n    assign(controls, start_index)\n\n    # Return the collected variables\n    return states, controls\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.convert_dynamics_dict_to_expr","title":"<code>convert_dynamics_dict_to_expr(dynamics: Dict[str, Expr], states: List[State]) -&gt; Tuple[Dict[str, Expr], Expr]</code>","text":"<p>Convert dynamics dictionary to concatenated expression in canonical order.</p> <p>Converts a dictionary-based dynamics specification to a single concatenated expression that represents the full ODE system x_dot = f(x, u, t). The dynamics are ordered according to the states list to ensure consistent variable ordering.</p> <p>This function also normalizes scalar values (int, float) to Constant expressions.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>Dict[str, Expr]</code> <p>Dictionary mapping state names to their dynamics expressions</p> required <code>states</code> <code>List[State]</code> <p>List of State objects defining the canonical order</p> required <p>Returns:</p> Type Description <code>Tuple[Dict[str, Expr], Expr]</code> <p>Tuple of: - Updated dynamics dictionary (with scalars converted to Constant expressions) - Concatenated dynamics expression ordered by states list</p> Example <p>Convert dynamics dict to a single expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(2,))\ndynamics_dict = {\"x\": x * 2, \"y\": 1.0}  # Scalar for y\nconverted_dict, concat_expr = convert_dynamics_dict_to_expr(\n    dynamics_dict, [x, y]\n)\n# converted_dict[\"y\"] is now Constant(1.0)\n# concat_expr is Concat(x * 2, Constant(1.0))\n</code></pre> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def convert_dynamics_dict_to_expr(\n    dynamics: Dict[str, Expr], states: List[State]\n) -&gt; Tuple[Dict[str, Expr], Expr]:\n    \"\"\"Convert dynamics dictionary to concatenated expression in canonical order.\n\n    Converts a dictionary-based dynamics specification to a single concatenated expression\n    that represents the full ODE system x_dot = f(x, u, t). The dynamics are ordered\n    according to the states list to ensure consistent variable ordering.\n\n    This function also normalizes scalar values (int, float) to Constant expressions.\n\n    Args:\n        dynamics: Dictionary mapping state names to their dynamics expressions\n        states: List of State objects defining the canonical order\n\n    Returns:\n        Tuple of:\n            - Updated dynamics dictionary (with scalars converted to Constant expressions)\n            - Concatenated dynamics expression ordered by states list\n\n    Example:\n        Convert dynamics dict to a single expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(2,))\n            dynamics_dict = {\"x\": x * 2, \"y\": 1.0}  # Scalar for y\n            converted_dict, concat_expr = convert_dynamics_dict_to_expr(\n                dynamics_dict, [x, y]\n            )\n            # converted_dict[\"y\"] is now Constant(1.0)\n            # concat_expr is Concat(x * 2, Constant(1.0))\n    \"\"\"\n    # Create a copy to avoid mutating the input\n    dynamics_converted = dict(dynamics)\n\n    # Convert scalar values to Constant expressions\n    for state_name, dyn_expr in dynamics_converted.items():\n        if isinstance(dyn_expr, (int, float)):\n            dynamics_converted[state_name] = Constant(dyn_expr)\n\n    # Create concatenated expression ordered by states list\n    dynamics_exprs = [dynamics_converted[state.name] for state in states]\n    dynamics_concat = Concat(*dynamics_exprs)\n\n    return dynamics_converted, dynamics_concat\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_and_normalize_constraint_nodes","title":"<code>validate_and_normalize_constraint_nodes(exprs: Union[Expr, list[Expr]], n_nodes: int)</code>","text":"<p>Validate and normalize constraint node specifications.</p> <p>This function validates and normalizes node specifications for constraint wrappers:</p> For NodalConstraint <ul> <li>nodes should be a list of specific node indices: [2, 4, 6, 8]</li> <li>Validates all nodes are within the valid range [0, n_nodes)</li> </ul> <p>For CTCS (Continuous-Time Constraint Satisfaction) constraints:     - nodes should be a tuple of (start, end): (0, 10)     - None is replaced with (0, n_nodes) to apply over entire trajectory     - Validation ensures tuple has exactly 2 elements and start &lt; end     - Validates indices are within trajectory bounds</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>Union[Expr, list[Expr]]</code> <p>Single expression or list of expressions to validate</p> required <code>n_nodes</code> <code>int</code> <p>Total number of nodes in the trajectory</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If node specifications are invalid (out of range, malformed, etc.)</p> Example <p>x = ox.State(\"x\", shape=(3,)) constraint = (x &lt;= 5).at([0, 10, 20])  # NodalConstraint validate_and_normalize_constraint_nodes([constraint], n_nodes=50)  # OK</p> <p>ctcs_constraint = (x &lt;= 5).over((0, 100))  # CTCS validate_and_normalize_constraint_nodes([ctcs_constraint], n_nodes=50)</p> <pre><code># Raises ValueError: Range exceeds trajectory length\n</code></pre> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_and_normalize_constraint_nodes(exprs: Union[Expr, list[Expr]], n_nodes: int):\n    \"\"\"Validate and normalize constraint node specifications.\n\n    This function validates and normalizes node specifications for constraint wrappers:\n\n    For NodalConstraint:\n        - nodes should be a list of specific node indices: [2, 4, 6, 8]\n        - Validates all nodes are within the valid range [0, n_nodes)\n\n    For CTCS (Continuous-Time Constraint Satisfaction) constraints:\n        - nodes should be a tuple of (start, end): (0, 10)\n        - None is replaced with (0, n_nodes) to apply over entire trajectory\n        - Validation ensures tuple has exactly 2 elements and start &lt; end\n        - Validates indices are within trajectory bounds\n\n    Args:\n        exprs: Single expression or list of expressions to validate\n        n_nodes: Total number of nodes in the trajectory\n\n    Raises:\n        ValueError: If node specifications are invalid (out of range, malformed, etc.)\n\n    Example:\n            x = ox.State(\"x\", shape=(3,))\n            constraint = (x &lt;= 5).at([0, 10, 20])  # NodalConstraint\n            validate_and_normalize_constraint_nodes([constraint], n_nodes=50)  # OK\n\n            ctcs_constraint = (x &lt;= 5).over((0, 100))  # CTCS\n            validate_and_normalize_constraint_nodes([ctcs_constraint], n_nodes=50)\n        # Raises ValueError: Range exceeds trajectory length\n    \"\"\"\n\n    # Normalize to list\n    expr_list = exprs if isinstance(exprs, (list, tuple)) else [exprs]\n\n    for expr in expr_list:\n        if isinstance(expr, CTCS):\n            # CTCS constraint validation (already done in __init__, but normalize None)\n            if expr.nodes is None:\n                expr.nodes = (0, n_nodes)\n            elif expr.nodes[0] &gt;= n_nodes or expr.nodes[1] &gt; n_nodes:\n                raise ValueError(\n                    f\"CTCS node range {expr.nodes} exceeds trajectory length {n_nodes}\"\n                )\n\n        elif isinstance(expr, NodalConstraint):\n            # NodalConstraint validation - nodes are already validated in __init__\n            # Just need to check they're within trajectory range\n            for node in expr.nodes:\n                if node &lt; 0 or node &gt;= n_nodes:\n                    raise ValueError(f\"NodalConstraint node {node} is out of range [0, {n_nodes})\")\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_constraints_at_root","title":"<code>validate_constraints_at_root(exprs: Union[Expr, list[Expr]])</code>","text":"<p>Validate that constraints only appear at the root level of expression trees.</p> <p>Constraints and constraint wrappers (CTCS, NodalConstraint, CrossNodeConstraint) must only appear as top-level expressions, not nested within other expressions. However, constraints inside constraint wrappers are allowed (e.g., the constraint inside CTCS(x &lt;= 5)).</p> <p>This ensures constraints are properly processed during problem compilation and prevents ambiguous constraint specifications.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>Union[Expr, list[Expr]]</code> <p>Single expression or list of expressions to validate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any constraint or constraint wrapper is found at depth &gt; 0</p> Example <p>x = ox.State(\"x\", shape=(3,)) constraint = x &lt;= 5 validate_constraints_at_root([constraint])  # OK - constraint at root</p> <p>bad_expr = ox.Sum(x &lt;= 5)  # Constraint nested inside Sum validate_constraints_at_root([bad_expr])  # Raises ValueError</p> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_constraints_at_root(exprs: Union[Expr, list[Expr]]):\n    \"\"\"Validate that constraints only appear at the root level of expression trees.\n\n    Constraints and constraint wrappers (CTCS, NodalConstraint, CrossNodeConstraint)\n    must only appear as top-level expressions, not nested within other expressions.\n    However, constraints inside constraint wrappers are allowed (e.g., the constraint\n    inside CTCS(x &lt;= 5)).\n\n    This ensures constraints are properly processed during problem compilation and\n    prevents ambiguous constraint specifications.\n\n    Args:\n        exprs: Single expression or list of expressions to validate\n\n    Raises:\n        ValueError: If any constraint or constraint wrapper is found at depth &gt; 0\n\n    Example:\n            x = ox.State(\"x\", shape=(3,))\n            constraint = x &lt;= 5\n            validate_constraints_at_root([constraint])  # OK - constraint at root\n\n            bad_expr = ox.Sum(x &lt;= 5)  # Constraint nested inside Sum\n            validate_constraints_at_root([bad_expr])  # Raises ValueError\n    \"\"\"\n\n    # Define constraint wrappers that must also be at root level\n    CONSTRAINT_WRAPPERS = (CTCS, NodalConstraint, CrossNodeConstraint)\n\n    # normalize to list\n    expr_list = exprs if isinstance(exprs, (list, tuple)) else [exprs]\n\n    for expr in expr_list:\n\n        def visit(node: Expr, depth: int):\n            if depth &gt; 0:\n                if isinstance(node, CONSTRAINT_WRAPPERS):\n                    raise ValueError(\n                        f\"Nested constraint wrapper found at depth {depth!r}: {node!r}; \"\n                        \"constraint wrappers must only appear as top-level roots\"\n                    )\n                elif isinstance(node, Constraint):\n                    raise ValueError(\n                        f\"Nested Constraint found at depth {depth!r}: {node!r}; \"\n                        \"constraints must only appear as top-level roots\"\n                    )\n\n            # If this is a constraint wrapper, don't validate its children\n            # (we allow constraints inside constraint wrappers)\n            if isinstance(node, CONSTRAINT_WRAPPERS):\n                return  # Skip traversing children\n\n            # Otherwise, continue traversing children\n            for child in node.children():\n                visit(child, depth + 1)\n\n        # Start traversal\n        visit(expr, 0)\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_cross_node_constraint","title":"<code>validate_cross_node_constraint(cross_node_constraint, n_nodes: int) -&gt; None</code>","text":"<p>Validate cross-node constraint bounds and variable consistency.</p> <p>This function performs two validations in a single tree traversal:</p> <ol> <li> <p>Bounds checking: Ensures all NodeReference indices are within [0, n_nodes).    Cross-node constraints reference fixed trajectory nodes (e.g., position.at(5)),    and this validates those indices are valid. Negative indices are normalized    (e.g., -1 becomes n_nodes-1) before checking.</p> </li> <li> <p>Variable consistency: Ensures that if ANY variable uses .at(), then ALL    state/control variables must use .at(). Mixing causes shape mismatches during    lowering because:</p> </li> <li>Variables with .at(k) extract single-node values: X[k, :] \u2192 shape (n_x,)</li> <li>Variables without .at() expect full trajectory: X[:, :] \u2192 shape (N, n_x)</li> </ol> <p>Parameters:</p> Name Type Description Default <code>cross_node_constraint</code> <p>The CrossNodeConstraint to validate</p> required <code>n_nodes</code> <code>int</code> <p>Total number of trajectory nodes</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any NodeReference accesses nodes outside [0, n_nodes)</p> <code>ValueError</code> <p>If constraint mixes .at() and non-.at() variables</p> Example <p>Valid cross-node constraint:</p> <pre><code>from openscvx.symbolic.expr import CrossNodeConstraint\n\nposition = State(\"pos\", shape=(3,))\n\n# Valid: all variables use .at(), indices in bounds\nconstraint = CrossNodeConstraint(position.at(5) - position.at(4) &lt;= 0.1)\nvalidate_cross_node_constraint(constraint, n_nodes=10)  # OK\n</code></pre> <p>Invalid - out of bounds:</p> <pre><code># Invalid: node 10 is out of bounds for n_nodes=10\nbad_bounds = CrossNodeConstraint(position.at(0) == position.at(10))\nvalidate_cross_node_constraint(bad_bounds, n_nodes=10)  # Raises ValueError\n</code></pre> <p>Invalid - mixed .at() usage:</p> <pre><code>velocity = State(\"vel\", shape=(3,))\n# Invalid: position uses .at(), velocity doesn't\nbad_mixed = CrossNodeConstraint(position.at(5) - velocity &lt;= 0.1)\nvalidate_cross_node_constraint(bad_mixed, n_nodes=10)  # Raises ValueError\n</code></pre> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_cross_node_constraint(cross_node_constraint, n_nodes: int) -&gt; None:\n    \"\"\"Validate cross-node constraint bounds and variable consistency.\n\n    This function performs two validations in a single tree traversal:\n\n    1. **Bounds checking**: Ensures all NodeReference indices are within [0, n_nodes).\n       Cross-node constraints reference fixed trajectory nodes (e.g., position.at(5)),\n       and this validates those indices are valid. Negative indices are normalized\n       (e.g., -1 becomes n_nodes-1) before checking.\n\n    2. **Variable consistency**: Ensures that if ANY variable uses .at(), then ALL\n       state/control variables must use .at(). Mixing causes shape mismatches during\n       lowering because:\n       - Variables with .at(k) extract single-node values: X[k, :] \u2192 shape (n_x,)\n       - Variables without .at() expect full trajectory: X[:, :] \u2192 shape (N, n_x)\n\n    Args:\n        cross_node_constraint: The CrossNodeConstraint to validate\n        n_nodes: Total number of trajectory nodes\n\n    Raises:\n        ValueError: If any NodeReference accesses nodes outside [0, n_nodes)\n        ValueError: If constraint mixes .at() and non-.at() variables\n\n    Example:\n        Valid cross-node constraint:\n\n            from openscvx.symbolic.expr import CrossNodeConstraint\n\n            position = State(\"pos\", shape=(3,))\n\n            # Valid: all variables use .at(), indices in bounds\n            constraint = CrossNodeConstraint(position.at(5) - position.at(4) &lt;= 0.1)\n            validate_cross_node_constraint(constraint, n_nodes=10)  # OK\n\n        Invalid - out of bounds:\n\n            # Invalid: node 10 is out of bounds for n_nodes=10\n            bad_bounds = CrossNodeConstraint(position.at(0) == position.at(10))\n            validate_cross_node_constraint(bad_bounds, n_nodes=10)  # Raises ValueError\n\n        Invalid - mixed .at() usage:\n\n            velocity = State(\"vel\", shape=(3,))\n            # Invalid: position uses .at(), velocity doesn't\n            bad_mixed = CrossNodeConstraint(position.at(5) - velocity &lt;= 0.1)\n            validate_cross_node_constraint(bad_mixed, n_nodes=10)  # Raises ValueError\n    \"\"\"\n    from openscvx.symbolic.expr import Control, CrossNodeConstraint, NodeReference, State\n\n    if not isinstance(cross_node_constraint, CrossNodeConstraint):\n        raise TypeError(\n            f\"Expected CrossNodeConstraint, got {type(cross_node_constraint).__name__}. \"\n            f\"Bare constraints with NodeReferences should be wrapped in CrossNodeConstraint \"\n            f\"by separate_constraints() before validation.\"\n        )\n\n    constraint = cross_node_constraint.constraint\n\n    # Collect information in a single traversal\n    node_refs = []  # List of (node_idx, normalized_idx) tuples\n    unwrapped_vars = []  # List of variable names without .at()\n\n    def traverse(expr):\n        if isinstance(expr, NodeReference):\n            # Normalize negative indices\n            idx = expr.node_idx\n            normalized_idx = idx if idx &gt;= 0 else n_nodes + idx\n            node_refs.append((idx, normalized_idx))\n            # Don't traverse into children - NodeReference wraps the variable\n            return\n\n        if isinstance(expr, (State, Control)):\n            # Found a bare State/Control not wrapped in NodeReference\n            unwrapped_vars.append(expr.name)\n            return\n\n        # Recurse on children\n        for child in expr.children():\n            traverse(child)\n\n    # Traverse the constraint expression (both sides)\n    traverse(constraint.lhs)\n    traverse(constraint.rhs)\n\n    # Check 1: Bounds validation\n    for orig_idx, normalized_idx in node_refs:\n        if normalized_idx &lt; 0 or normalized_idx &gt;= n_nodes:\n            raise ValueError(\n                f\"Cross-node constraint references invalid node index {orig_idx}. \"\n                f\"Node indices must be in range [0, {n_nodes}) \"\n                f\"(or negative indices in range [-{n_nodes}, -1]). \"\n                f\"Constraint: {constraint}\"\n            )\n\n    # Check 2: Variable consistency - if we have NodeReferences, all vars must use .at()\n    if node_refs and unwrapped_vars:\n        raise ValueError(\n            f\"Cross-node constraint contains NodeReferences (variables with .at(k)) \"\n            f\"but also has variables without .at(): {unwrapped_vars}. \"\n            f\"All state/control variables in cross-node constraints must use .at(k). \"\n            f\"For example, if you use 'position.at(5)', you must also use 'velocity.at(4)' \"\n            f\"instead of just 'velocity'. \"\n            f\"Constraint: {constraint}\"\n        )\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_dynamics_dict","title":"<code>validate_dynamics_dict(dynamics: Dict[str, Expr], states: List[State]) -&gt; None</code>","text":"<p>Validate that dynamics dictionary keys match state names exactly.</p> <p>Ensures that the dynamics dictionary has exactly the same keys as the state names, with no missing states and no extra keys. This is required when using dictionary-based dynamics specification.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>Dict[str, Expr]</code> <p>Dictionary mapping state names to their dynamics expressions</p> required <code>states</code> <code>List[State]</code> <p>List of State objects</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If there's a mismatch between state names and dynamics keys</p> Example <p>x = ox.State(\"x\", shape=(3,)) y = ox.State(\"y\", shape=(2,)) dynamics = {\"x\": x * 2, \"y\": y + 1} validate_dynamics_dict(dynamics, [x, y])  # OK</p> <p>bad_dynamics = {\"x\": x * 2}  # Missing \"y\" validate_dynamics_dict(bad_dynamics, [x, y])  # Raises ValueError</p> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_dynamics_dict(dynamics: Dict[str, Expr], states: List[State]) -&gt; None:\n    \"\"\"Validate that dynamics dictionary keys match state names exactly.\n\n    Ensures that the dynamics dictionary has exactly the same keys as the state names,\n    with no missing states and no extra keys. This is required when using dictionary-based\n    dynamics specification.\n\n    Args:\n        dynamics: Dictionary mapping state names to their dynamics expressions\n        states: List of State objects\n\n    Raises:\n        ValueError: If there's a mismatch between state names and dynamics keys\n\n    Example:\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(2,))\n            dynamics = {\"x\": x * 2, \"y\": y + 1}\n            validate_dynamics_dict(dynamics, [x, y])  # OK\n\n            bad_dynamics = {\"x\": x * 2}  # Missing \"y\"\n            validate_dynamics_dict(bad_dynamics, [x, y])  # Raises ValueError\n    \"\"\"\n    state_names_set = set(state.name for state in states)\n    dynamics_names_set = set(dynamics.keys())\n\n    if dynamics_names_set != state_names_set:\n        missing_in_dynamics = state_names_set - dynamics_names_set\n        extra_in_dynamics = dynamics_names_set - state_names_set\n        error_msg = \"Mismatch between state names and dynamics keys.\\n\"\n        if missing_in_dynamics:\n            error_msg += f\"  States missing from dynamics: {missing_in_dynamics}\\n\"\n        if extra_in_dynamics:\n            error_msg += f\"  Extra keys in dynamics: {extra_in_dynamics}\\n\"\n        raise ValueError(error_msg)\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_dynamics_dict_dimensions","title":"<code>validate_dynamics_dict_dimensions(dynamics: Dict[str, Expr], states: List[State]) -&gt; None</code>","text":"<p>Validate that each dynamics expression matches its corresponding state shape.</p> <p>For dictionary-based dynamics specification, ensures that each state's dynamics expression has the same shape as the state itself. This validates that each component of x_dot = f(x, u, t) has the correct dimension.</p> <p>Scalars are normalized to shape (1,) for comparison, matching Concat behavior.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>Dict[str, Expr]</code> <p>Dictionary mapping state names to their dynamics expressions</p> required <code>states</code> <code>List[State]</code> <p>List of State objects</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any dynamics expression dimension doesn't match its state shape</p> Example <p>x = ox.State(\"x\", shape=(3,)) y = ox.State(\"y\", shape=(2,)) u = ox.Control(\"u\", shape=(3,)) dynamics = {\"x\": u, \"y\": y + 1} validate_dynamics_dict_dimensions(dynamics, [x, y])  # OK</p> <p>bad_dynamics = {\"x\": u, \"y\": u}  # y dynamics has wrong shape validate_dynamics_dict_dimensions(bad_dynamics, [x, y])  # Raises ValueError</p> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_dynamics_dict_dimensions(dynamics: Dict[str, Expr], states: List[State]) -&gt; None:\n    \"\"\"Validate that each dynamics expression matches its corresponding state shape.\n\n    For dictionary-based dynamics specification, ensures that each state's dynamics\n    expression has the same shape as the state itself. This validates that each\n    component of x_dot = f(x, u, t) has the correct dimension.\n\n    Scalars are normalized to shape (1,) for comparison, matching Concat behavior.\n\n    Args:\n        dynamics: Dictionary mapping state names to their dynamics expressions\n        states: List of State objects\n\n    Raises:\n        ValueError: If any dynamics expression dimension doesn't match its state shape\n\n    Example:\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(2,))\n            u = ox.Control(\"u\", shape=(3,))\n            dynamics = {\"x\": u, \"y\": y + 1}\n            validate_dynamics_dict_dimensions(dynamics, [x, y])  # OK\n\n            bad_dynamics = {\"x\": u, \"y\": u}  # y dynamics has wrong shape\n            validate_dynamics_dict_dimensions(bad_dynamics, [x, y])  # Raises ValueError\n    \"\"\"\n\n    def normalize_scalars(shape: Tuple[int, ...]) -&gt; Tuple[int, ...]:\n        \"\"\"Normalize shape: scalar () becomes (1,)\"\"\"\n        return (1,) if len(shape) == 0 else shape\n\n    for state in states:\n        dyn_expr = dynamics[state.name]\n        expected_shape = state.shape\n\n        # Handle raw Python numbers (which will be converted to Constant later)\n        if isinstance(dyn_expr, (int, float)):\n            actual_shape = ()  # Scalars have shape ()\n        else:\n            # Compute the shape of the dynamics expression\n            actual_shape = dyn_expr.check_shape()\n\n        # Normalize both shapes for comparison (consistent with Concat behavior)\n        if normalize_scalars(actual_shape) != normalize_scalars(expected_shape):\n            raise ValueError(\n                f\"Dynamics for state '{state.name}' has shape {actual_shape}, \"\n                f\"but state has shape {expected_shape}\"\n            )\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_dynamics_dimension","title":"<code>validate_dynamics_dimension(dynamics_expr: Union[Expr, list[Expr]], states: Union[State, list[State]]) -&gt; None</code>","text":"<p>Validate that dynamics expression dimensions match state dimensions.</p> <p>Ensures that the total dimension of all dynamics expressions matches the total dimension of all states. Each dynamics expression must be a 1D vector, and their combined dimension must equal the sum of all state dimensions.</p> <p>This is essential for ensuring the ODE system x_dot = f(x, u, t) is well-formed.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics_expr</code> <code>Union[Expr, list[Expr]]</code> <p>Single dynamics expression or list of dynamics expressions.           Combined, they represent x_dot = f(x, u, t) for all states.</p> required <code>states</code> <code>Union[State, list[State]]</code> <p>Single state variable or list of state variables that the dynamics describe.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If dimensions don't match or if any dynamics is not a 1D vector</p> Example <p>x = ox.State(\"x\", shape=(3,)) y = ox.State(\"y\", shape=(2,)) dynamics = ox.Concat(x * 2, y + 1)  # Shape (5,) - matches total state dim validate_dynamics_dimension(dynamics, [x, y])  # OK</p> <p>bad_dynamics = x  # Shape (3,) - doesn't match total dim of 5 validate_dynamics_dimension(bad_dynamics, [x, y])  # Raises ValueError</p> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_dynamics_dimension(\n    dynamics_expr: Union[Expr, list[Expr]], states: Union[State, list[State]]\n) -&gt; None:\n    \"\"\"Validate that dynamics expression dimensions match state dimensions.\n\n    Ensures that the total dimension of all dynamics expressions matches the total\n    dimension of all states. Each dynamics expression must be a 1D vector, and their\n    combined dimension must equal the sum of all state dimensions.\n\n    This is essential for ensuring the ODE system x_dot = f(x, u, t) is well-formed.\n\n    Args:\n        dynamics_expr: Single dynamics expression or list of dynamics expressions.\n                      Combined, they represent x_dot = f(x, u, t) for all states.\n        states: Single state variable or list of state variables that the dynamics describe.\n\n    Raises:\n        ValueError: If dimensions don't match or if any dynamics is not a 1D vector\n\n    Example:\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(2,))\n            dynamics = ox.Concat(x * 2, y + 1)  # Shape (5,) - matches total state dim\n            validate_dynamics_dimension(dynamics, [x, y])  # OK\n\n            bad_dynamics = x  # Shape (3,) - doesn't match total dim of 5\n            validate_dynamics_dimension(bad_dynamics, [x, y])  # Raises ValueError\n    \"\"\"\n    # Normalize inputs to lists\n    dynamics_list = dynamics_expr if isinstance(dynamics_expr, (list, tuple)) else [dynamics_expr]\n    states_list = states if isinstance(states, (list, tuple)) else [states]\n\n    # Calculate total state dimension\n    total_state_dim = sum(int(np.prod(state.shape)) for state in states_list)\n\n    # Validate each dynamics expression and calculate total dynamics dimension\n    total_dynamics_dim = 0\n\n    for i, dyn_expr in enumerate(dynamics_list):\n        # Get the shape of this dynamics expression\n        dynamics_shape = dyn_expr.check_shape()\n\n        # Dynamics should be a 1D vector\n        if len(dynamics_shape) != 1:\n            prefix = f\"Dynamics expression {i}\" if len(dynamics_list) &gt; 1 else \"Dynamics expression\"\n            raise ValueError(\n                f\"{prefix} must be 1-dimensional (vector), but got shape {dynamics_shape}\"\n            )\n\n        total_dynamics_dim += dynamics_shape[0]\n\n    # Check that total dynamics dimension matches total state dimension\n    if total_dynamics_dim != total_state_dim:\n        if len(dynamics_list) == 1:\n            raise ValueError(\n                f\"Dynamics dimension mismatch: dynamics has dimension {total_dynamics_dim}, \"\n                f\"but total state dimension is {total_state_dim}. \"\n                f\"States: {[(s.name, s.shape) for s in states_list]}\"\n            )\n        else:\n            dynamics_dims = [dyn.check_shape()[0] for dyn in dynamics_list]\n            raise ValueError(\n                f\"Dynamics dimension mismatch: {len(dynamics_list)} dynamics expressions \"\n                f\"have combined dimension {total_dynamics_dim} {dynamics_dims}, \"\n                f\"but total state dimension is {total_state_dim}. \"\n                f\"States: {[(s.name, s.shape) for s in states_list]}\"\n            )\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_shapes","title":"<code>validate_shapes(exprs: Union[Expr, list[Expr]]) -&gt; None</code>","text":"<p>Validate shapes for a single expression or list of expressions.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>Union[Expr, list[Expr]]</code> <p>Single expression or list of expressions to validate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any expression has invalid shapes</p> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_shapes(exprs: Union[Expr, list[Expr]]) -&gt; None:\n    \"\"\"Validate shapes for a single expression or list of expressions.\n\n    Args:\n        exprs: Single expression or list of expressions to validate\n\n    Raises:\n        ValueError: If any expression has invalid shapes\n    \"\"\"\n    exprs = exprs if isinstance(exprs, (list, tuple)) else [exprs]\n    for e in exprs:\n        e.check_shape()  # will raise ValueError if anything's wrong\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_time_parameters","title":"<code>validate_time_parameters(states: List[State], time: Time) -&gt; Tuple[bool, Union[float, tuple, None], Union[float, tuple, None], float, Union[float, None], Union[float, None]]</code>","text":"<p>Validate time parameter usage and configuration.</p> <p>There are two valid approaches for handling time in trajectory optimization:</p> <ol> <li> <p>Auto-create time (recommended): Don't include \"time\" in states, provide Time object.    The time state is automatically created and managed.</p> </li> <li> <p>User-provided time (advanced): Include a \"time\" State in states. The Time object    is ignored and the user has full control over time dynamics.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>List[State]</code> <p>List of State objects</p> required <code>time</code> <code>Time</code> <p>Time configuration object (required, but ignored if time state exists)</p> required <p>Returns:</p> Type Description <code>Tuple[bool, Union[float, tuple, None], Union[float, tuple, None], float, Union[float, None], Union[float, None]]</code> <p>Tuple of (has_time_state, time_initial, time_final, time_derivative, time_min, time_max): - has_time_state: True if user provided a time state - time_initial: Initial time value (None if user-provided time) - time_final: Final time value (None if user-provided time) - time_derivative: Always 1.0 for auto-created time (None if user-provided) - time_min: Minimum time bound (None if user-provided) - time_max: Maximum time bound (None if user-provided)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If Time object is not provided or has invalid type</p> Example <pre><code>(False, 0.0, 10.0, 1.0, None, None)\n\n    # Approach 2: User-provided time\n    x = ox.State(\"x\", shape=(3,))\n    time_state = ox.State(\"time\", shape=())\n    validate_time_parameters([x, time_state], time_obj)\n(True, None, None, None, None, None)\n</code></pre> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_time_parameters(\n    states: List[State],\n    time: \"Time\",\n) -&gt; Tuple[\n    bool,\n    Union[float, tuple, None],\n    Union[float, tuple, None],\n    float,\n    Union[float, None],\n    Union[float, None],\n]:\n    \"\"\"Validate time parameter usage and configuration.\n\n    There are two valid approaches for handling time in trajectory optimization:\n\n    1. Auto-create time (recommended): Don't include \"time\" in states, provide Time object.\n       The time state is automatically created and managed.\n\n    2. User-provided time (advanced): Include a \"time\" State in states. The Time object\n       is ignored and the user has full control over time dynamics.\n\n    Args:\n        states: List of State objects\n        time: Time configuration object (required, but ignored if time state exists)\n\n    Returns:\n        Tuple of (has_time_state, time_initial, time_final, time_derivative, time_min, time_max):\n            - has_time_state: True if user provided a time state\n            - time_initial: Initial time value (None if user-provided time)\n            - time_final: Final time value (None if user-provided time)\n            - time_derivative: Always 1.0 for auto-created time (None if user-provided)\n            - time_min: Minimum time bound (None if user-provided)\n            - time_max: Maximum time bound (None if user-provided)\n\n    Raises:\n        ValueError: If Time object is not provided or has invalid type\n\n    Example:\n            # Approach 1: Auto-create time\n            x = ox.State(\"x\", shape=(3,))\n            time_obj = ox.Time(initial=0.0, final=10.0)\n            validate_time_parameters([x], time_obj)\n        (False, 0.0, 10.0, 1.0, None, None)\n\n            # Approach 2: User-provided time\n            x = ox.State(\"x\", shape=(3,))\n            time_state = ox.State(\"time\", shape=())\n            validate_time_parameters([x, time_state], time_obj)\n        (True, None, None, None, None, None)\n    \"\"\"\n    from openscvx.symbolic.time import Time\n\n    if not isinstance(time, Time):\n        raise ValueError(f\"Expected Time object, but got {type(time).__name__}\")\n\n    has_time_state = any(state.name == \"time\" for state in states)\n\n    if has_time_state:\n        # Approach 2: User-provided time state\n        # Time object is provided but ignored - user handles everything via State\n        # Return None for all time parameters since user handles everything\n        return True, None, None, None, None, None\n    else:\n        # Approach 1: Auto-create time state\n        # Extract values from Time object\n        time_initial = time.initial\n        time_final = time.final\n        time_derivative = 1.0  # Always 1.0 when using Time object\n        time_min = time.min\n        time_max = time.max\n\n        return False, time_initial, time_final, time_derivative, time_min, time_max\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_time_parameters--approach-1-auto-create-time","title":"Approach 1: Auto-create time","text":"<p>x = ox.State(\"x\", shape=(3,)) time_obj = ox.Time(initial=0.0, final=10.0) validate_time_parameters([x], time_obj)</p>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_variable_names","title":"<code>validate_variable_names(exprs: Iterable[Expr], *, reserved_prefix: str = '_', reserved_names: Set[str] = None) -&gt; None</code>","text":"<p>Validate variable names for uniqueness and reserved name conflicts.</p> <p>This function ensures that all State and Control variable names are: 1. Unique across distinct variable instances 2. Not starting with the reserved prefix (default: \"_\") 3. Not colliding with explicitly reserved names</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>Iterable[Expr]</code> <p>Iterable of expression trees to scan for variables</p> required <code>reserved_prefix</code> <code>str</code> <p>Prefix that user variables cannot start with (default: \"_\")</p> <code>'_'</code> <code>reserved_names</code> <code>Set[str]</code> <p>Set of explicitly reserved names that cannot be used (default: None)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any variable name violates uniqueness or reserved name rules</p> Example <p>x1 = ox.State(\"x\", shape=(3,)) x2 = ox.State(\"x\", shape=(2,))  # Same name, different object validate_variable_names([x1 + x2])  # Raises ValueError: Duplicate name 'x'</p> <p>bad = ox.State(\"internal\", shape=(2,)) validate_variable_names([bad])  # Raises ValueError: Reserved prefix ''</p> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_variable_names(\n    exprs: Iterable[Expr],\n    *,\n    reserved_prefix: str = \"_\",\n    reserved_names: Set[str] = None,\n) -&gt; None:\n    \"\"\"Validate variable names for uniqueness and reserved name conflicts.\n\n    This function ensures that all State and Control variable names are:\n    1. Unique across distinct variable instances\n    2. Not starting with the reserved prefix (default: \"_\")\n    3. Not colliding with explicitly reserved names\n\n    Args:\n        exprs: Iterable of expression trees to scan for variables\n        reserved_prefix: Prefix that user variables cannot start with (default: \"_\")\n        reserved_names: Set of explicitly reserved names that cannot be used (default: None)\n\n    Raises:\n        ValueError: If any variable name violates uniqueness or reserved name rules\n\n    Example:\n            x1 = ox.State(\"x\", shape=(3,))\n            x2 = ox.State(\"x\", shape=(2,))  # Same name, different object\n            validate_variable_names([x1 + x2])  # Raises ValueError: Duplicate name 'x'\n\n            bad = ox.State(\"_internal\", shape=(2,))\n            validate_variable_names([bad])  # Raises ValueError: Reserved prefix '_'\n    \"\"\"\n    seen_names = set()\n    seen_ids = set()\n    reserved = set(reserved_names or ())\n\n    def visitor(node):\n        if not isinstance(node, (State, Control)):\n            return\n\n        node_id = id(node)\n        if node_id in seen_ids:\n            # we already checked this exact object\n            return\n\n        name = node.name\n\n        # 1) uniqueness across *different* variables\n        if name in seen_names:\n            raise ValueError(f\"Duplicate variable name: {name!r}\")\n\n        # 2) no leading underscore\n        if name.startswith(reserved_prefix):\n            raise ValueError(\n                f\"Variable name {name!r} is reserved (cannot start with {reserved_prefix!r})\"\n            )\n\n        # 3) no collision with explicit reserved set\n        if name in reserved:\n            raise ValueError(f\"Variable name {name!r} collides with reserved name\")\n\n        seen_names.add(name)\n        seen_ids.add(node_id)\n\n    for e in exprs:\n        traverse(e, visitor)\n</code></pre>"},{"location":"reference/symbolic/problem/","title":"problem","text":"<p>SymbolicProblem dataclass - container for symbolic problem specification.</p> <p>This module provides the SymbolicProblem dataclass that represents a trajectory optimization problem in symbolic form, before lowering to executable code.</p> <p>The SymbolicProblem can represent two lifecycle stages:</p> <ol> <li>Before preprocessing: Raw user input with unsorted constraints</li> <li>After preprocessing: Augmented and validated, ready for lowering</li> </ol> <p>Use <code>is_preprocessed</code> to check which stage the problem is in.</p>"},{"location":"reference/symbolic/problem/#openscvx.symbolic.problem.SymbolicProblem","title":"<code>SymbolicProblem</code>  <code>dataclass</code>","text":"<p>Container for symbolic problem specification.</p> <p>This dataclass holds a trajectory optimization problem in symbolic form, either as raw user input or after preprocessing/augmentation. It provides a typed interface for the preprocessing and lowering pipeline.</p> Lifecycle Stages <ol> <li>Before preprocessing: User creates with raw dynamics, states,    controls, and unsorted constraints. Propagation fields are None.</li> <li>After preprocessing: Dynamics and states are augmented (CTCS,    time dilation), constraints are categorized, propagation fields    are populated.</li> </ol> <p>Use <code>is_preprocessed</code> to check whether preprocessing has completed.</p> <p>Attributes:</p> Name Type Description <code>dynamics</code> <code>Expr</code> <p>Symbolic dynamics expression (dx/dt = f(x, u)). After preprocessing, includes CTCS augmented state dynamics.</p> <code>states</code> <code>List[State]</code> <p>List of State objects. After preprocessing, includes time state and CTCS augmented states.</p> <code>controls</code> <code>List[Control]</code> <p>List of Control objects. After preprocessing, includes time dilation control.</p> <code>constraints</code> <code>ConstraintSet</code> <p>ConstraintSet holding all constraints. Before preprocessing, raw constraints live in <code>constraints.unsorted</code>. After preprocessing, constraints are categorized into ctcs, nodal, nodal_convex, etc.</p> <code>parameters</code> <code>Dict[str, any]</code> <p>Dictionary mapping parameter names to numpy arrays.</p> <code>N</code> <code>int</code> <p>Number of discretization nodes.</p> <code>node_intervals</code> <code>List[Tuple[int, int]]</code> <p>List of (start, end) tuples for CTCS constraint intervals. Populated during preprocessing when CTCS constraints are sorted.</p> <code>dynamics_prop</code> <code>Optional[Expr]</code> <p>Propagation dynamics (may include extra states). None before preprocessing, populated after.</p> <code>states_prop</code> <code>Optional[List[State]]</code> <p>Propagation states (may include extra states). None before preprocessing, populated after.</p> <code>controls_prop</code> <code>Optional[List[Control]]</code> <p>Propagation controls (typically same as controls). None before preprocessing, populated after.</p> Example <p>Before preprocessing::</p> <pre><code>problem = SymbolicProblem(\n    dynamics=dynamics_expr,\n    states=[x, v],\n    controls=[u],\n    constraints=ConstraintSet(unsorted=[c1, c2, c3]),\n    parameters={\"mass\": 1.0},\n    N=50,\n)\nassert not problem.is_preprocessed\n</code></pre> <p>After preprocessing::</p> <pre><code>processed = preprocess_symbolic_problem(problem, time=time_config)\nassert processed.is_preprocessed\nassert processed.constraints.is_categorized\n# Now ready for lowering\nlowered = lower_symbolic_problem(processed)\n</code></pre> Source code in <code>openscvx/symbolic/problem.py</code> <pre><code>@dataclass\nclass SymbolicProblem:\n    \"\"\"Container for symbolic problem specification.\n\n    This dataclass holds a trajectory optimization problem in symbolic form,\n    either as raw user input or after preprocessing/augmentation. It provides\n    a typed interface for the preprocessing and lowering pipeline.\n\n    Lifecycle Stages:\n        1. **Before preprocessing**: User creates with raw dynamics, states,\n           controls, and unsorted constraints. Propagation fields are None.\n        2. **After preprocessing**: Dynamics and states are augmented (CTCS,\n           time dilation), constraints are categorized, propagation fields\n           are populated.\n\n    Use `is_preprocessed` to check whether preprocessing has completed.\n\n    Attributes:\n        dynamics: Symbolic dynamics expression (dx/dt = f(x, u)).\n            After preprocessing, includes CTCS augmented state dynamics.\n        states: List of State objects. After preprocessing, includes\n            time state and CTCS augmented states.\n        controls: List of Control objects. After preprocessing, includes\n            time dilation control.\n        constraints: ConstraintSet holding all constraints. Before preprocessing,\n            raw constraints live in `constraints.unsorted`. After preprocessing,\n            constraints are categorized into ctcs, nodal, nodal_convex, etc.\n        parameters: Dictionary mapping parameter names to numpy arrays.\n        N: Number of discretization nodes.\n        node_intervals: List of (start, end) tuples for CTCS constraint intervals.\n            Populated during preprocessing when CTCS constraints are sorted.\n\n        dynamics_prop: Propagation dynamics (may include extra states).\n            None before preprocessing, populated after.\n        states_prop: Propagation states (may include extra states).\n            None before preprocessing, populated after.\n        controls_prop: Propagation controls (typically same as controls).\n            None before preprocessing, populated after.\n\n    Example:\n        Before preprocessing::\n\n            problem = SymbolicProblem(\n                dynamics=dynamics_expr,\n                states=[x, v],\n                controls=[u],\n                constraints=ConstraintSet(unsorted=[c1, c2, c3]),\n                parameters={\"mass\": 1.0},\n                N=50,\n            )\n            assert not problem.is_preprocessed\n\n        After preprocessing::\n\n            processed = preprocess_symbolic_problem(problem, time=time_config)\n            assert processed.is_preprocessed\n            assert processed.constraints.is_categorized\n            # Now ready for lowering\n            lowered = lower_symbolic_problem(processed)\n    \"\"\"\n\n    # Core problem specification\n    dynamics: \"Expr\"\n    states: List[\"State\"]\n    controls: List[\"Control\"]\n    constraints: ConstraintSet\n    parameters: Dict[str, any]\n    N: int\n\n    # CTCS node intervals (populated during preprocessing)\n    node_intervals: List[Tuple[int, int]] = field(default_factory=list)\n\n    # Propagation (None before preprocessing, populated after)\n    dynamics_prop: Optional[\"Expr\"] = None\n    states_prop: Optional[List[\"State\"]] = None\n    controls_prop: Optional[List[\"Control\"]] = None\n\n    @property\n    def is_preprocessed(self) -&gt; bool:\n        \"\"\"True if the problem has been preprocessed and is ready for lowering.\n\n        A problem is considered preprocessed when:\n        1. All constraints have been categorized (unsorted is empty)\n        2. Propagation dynamics have been set up\n        \"\"\"\n        return self.constraints.is_categorized and self.dynamics_prop is not None\n</code></pre>"},{"location":"reference/symbolic/problem/#openscvx.symbolic.problem.SymbolicProblem.is_preprocessed","title":"<code>is_preprocessed: bool</code>  <code>property</code>","text":"<p>True if the problem has been preprocessed and is ready for lowering.</p> <p>A problem is considered preprocessed when: 1. All constraints have been categorized (unsorted is empty) 2. Propagation dynamics have been set up</p>"},{"location":"reference/symbolic/time/","title":"time","text":""},{"location":"reference/symbolic/time/#openscvx.symbolic.time.Time","title":"<code>Time</code>","text":"<p>Time configuration for trajectory optimization problems.</p> <p>This class encapsulates time-related parameters for trajectory optimization. The time derivative is internally assumed to be 1.0.</p> <p>Attributes:</p> Name Type Description <code>initial</code> <code>float or tuple</code> <p>Initial time boundary condition. Can be a float (fixed) or tuple like (\"free\", value), (\"minimize\", value), or (\"maximize\", value).</p> <code>final</code> <code>float or tuple</code> <p>Final time boundary condition. Can be a float (fixed) or tuple like (\"free\", value), (\"minimize\", value), or (\"maximize\", value).</p> <code>min</code> <code>float</code> <p>Minimum bound for time variable (required).</p> <code>max</code> <code>float</code> <p>Maximum bound for time variable (required).</p> Example <pre><code># Fixed initial and final time\ntime = Time(initial=0.0, final=10.0, min=0.0, max=20.0)\n\n# Free final time\ntime = Time(initial=0.0, final=(\"free\", 10.0), min=0.0, max=20.0)\n\n# Minimize final time\ntime = Time(initial=0.0, final=(\"minimize\", 10.0), min=0.0, max=20.0)\n\n# Maximize initial time\ntime = Time(initial=(\"maximize\", 0.0), final=10.0, min=0.0, max=20.0)\n</code></pre> Source code in <code>openscvx/symbolic/time.py</code> <pre><code>class Time:\n    \"\"\"Time configuration for trajectory optimization problems.\n\n    This class encapsulates time-related parameters for trajectory optimization.\n    The time derivative is internally assumed to be 1.0.\n\n    Attributes:\n        initial (float or tuple): Initial time boundary condition.\n            Can be a float (fixed) or tuple like (\"free\", value), (\"minimize\", value),\n            or (\"maximize\", value).\n        final (float or tuple): Final time boundary condition.\n            Can be a float (fixed) or tuple like (\"free\", value), (\"minimize\", value),\n            or (\"maximize\", value).\n        min (float): Minimum bound for time variable (required).\n        max (float): Maximum bound for time variable (required).\n\n    Example:\n        ```python\n        # Fixed initial and final time\n        time = Time(initial=0.0, final=10.0, min=0.0, max=20.0)\n\n        # Free final time\n        time = Time(initial=0.0, final=(\"free\", 10.0), min=0.0, max=20.0)\n\n        # Minimize final time\n        time = Time(initial=0.0, final=(\"minimize\", 10.0), min=0.0, max=20.0)\n\n        # Maximize initial time\n        time = Time(initial=(\"maximize\", 0.0), final=10.0, min=0.0, max=20.0)\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        initial: Union[float, tuple],\n        final: Union[float, tuple],\n        min: float,\n        max: float,\n    ):\n        \"\"\"Initialize a Time object.\n\n        Args:\n            initial: Initial time boundary condition (float or tuple).\n                Tuple format: (\"free\", value), (\"minimize\", value), or (\"maximize\", value).\n            final: Final time boundary condition (float or tuple).\n                Tuple format: (\"free\", value), (\"minimize\", value), or (\"maximize\", value).\n            min: Minimum bound for time variable (required).\n            max: Maximum bound for time variable (required).\n\n        Raises:\n            ValueError: If tuple format is invalid.\n        \"\"\"\n        # Validate tuple format if provided\n        for name, value in [(\"initial\", initial), (\"final\", final)]:\n            if isinstance(value, tuple):\n                if len(value) != 2:\n                    raise ValueError(f\"{name} tuple must have exactly 2 elements: (type, value)\")\n                bc_type, bc_value = value\n                if bc_type not in [\"free\", \"minimize\", \"maximize\"]:\n                    raise ValueError(\n                        f\"{name} boundary condition type must be 'free', \"\n                        f\"'minimize', or 'maximize', got '{bc_type}'\"\n                    )\n                if not isinstance(bc_value, (int, float)):\n                    raise ValueError(\n                        f\"{name} boundary condition value must be a number, \"\n                        f\"got {type(bc_value).__name__}\"\n                    )\n\n        self.initial = initial\n        self.final = final\n        self.min = min\n        self.max = max\n        # Time derivative is always 1.0 internally\n        self.derivative = 1.0\n        self._scaling_min = None\n        self._scaling_max = None\n\n    @property\n    def scaling_min(self):\n        \"\"\"Get the scaling minimum bound for the time variable.\n\n        Returns:\n            Scaling minimum value, or None if not set.\n        \"\"\"\n        return self._scaling_min\n\n    @scaling_min.setter\n    def scaling_min(self, val):\n        \"\"\"Set the scaling minimum bound for the time variable.\n\n        Args:\n            val: Scaling minimum value (float or None)\n        \"\"\"\n        self._scaling_min = float(val) if val is not None else None\n\n    @property\n    def scaling_max(self):\n        \"\"\"Get the scaling maximum bound for the time variable.\n\n        Returns:\n            Scaling maximum value, or None if not set.\n        \"\"\"\n        return self._scaling_max\n\n    @scaling_max.setter\n    def scaling_max(self, val):\n        \"\"\"Set the scaling maximum bound for the time variable.\n\n        Args:\n            val: Scaling maximum value (float or None)\n        \"\"\"\n        self._scaling_max = float(val) if val is not None else None\n</code></pre>"},{"location":"reference/symbolic/time/#openscvx.symbolic.time.Time.scaling_max","title":"<code>scaling_max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling maximum bound for the time variable.</p> <p>Returns:</p> Type Description <p>Scaling maximum value, or None if not set.</p>"},{"location":"reference/symbolic/time/#openscvx.symbolic.time.Time.scaling_min","title":"<code>scaling_min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling minimum bound for the time variable.</p> <p>Returns:</p> Type Description <p>Scaling minimum value, or None if not set.</p>"},{"location":"reference/symbolic/unified/","title":"unified","text":"<p>Unification functions for aggregating symbolic State and Control objects.</p> <p>This module provides the unification layer that transforms multiple symbolic State and Control objects into unified representations for numerical optimization.</p> The unification process <ol> <li>Collection: Gathers all State and Control objects from expression trees</li> <li>Sorting: Organizes variables (user-defined first, then augmented)</li> <li>Aggregation: Concatenates bounds, guesses, and boundary conditions</li> <li>Slice Assignment: Assigns each State/Control a slice for indexing</li> <li>Unified Representation: Creates UnifiedState/UnifiedControl objects</li> </ol> <p>This separation allows users to define problems with natural variable names while maintaining efficient vectorized operations during optimization.</p> Example <p>Creating and unifying multiple states::</p> <pre><code>import openscvx as ox\nfrom openscvx.symbolic.unified import unify_states\n\n# Define separate symbolic states\nposition = ox.State(\"position\", shape=(3,), min=-10, max=10)\nvelocity = ox.State(\"velocity\", shape=(3,), min=-5, max=5)\nmass = ox.State(\"mass\", shape=(1,), min=0.1, max=10.0)\n\n# Unify into single state vector\nunified_x = unify_states([position, velocity, mass], name=\"x\")\n\n# Access unified properties\nprint(unified_x.shape)    # (7,) - combined shape\nprint(unified_x.min)      # Combined bounds: [-10, -10, -10, -5, -5, -5, 0.1]\nprint(unified_x.true)     # Access only user-defined states\n</code></pre> <p>Accessing slices after unification::</p> <pre><code># After unification, each State has a slice assigned\nprint(position._slice)    # slice(0, 3)\nprint(velocity._slice)    # slice(3, 6)\nprint(mass._slice)        # slice(6, 7)\n\n# During lowering, these slices extract values from unified vector\nx_unified = jnp.array([1, 2, 3, 4, 5, 6, 7])\nposition_val = x_unified[position._slice]  # [1, 2, 3]\n</code></pre> See Also <ul> <li>UnifiedState: Dataclass for unified state representation (in openscvx.lowered.unified)</li> <li>UnifiedControl: Dataclass for unified control representation (in openscvx.lowered.unified)</li> <li>State: Individual symbolic state variable (symbolic/expr/state.py)</li> <li>Control: Individual symbolic control variable (symbolic/expr/control.py)</li> </ul>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.UnifiedControl","title":"<code>UnifiedControl</code>  <code>dataclass</code>","text":"<p>Unified control vector aggregating multiple Control objects.</p> <p>UnifiedControl is a drop-in replacement for individual Control objects that holds aggregated data from multiple Control instances. It maintains compatibility with optimization infrastructure while providing access to individual control components through slicing.</p> <p>The unified control separates user-defined \"true\" controls from augmented controls added internally (e.g., for time dilation). This separation allows clean access to physical control inputs while supporting advanced features.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the unified control vector</p> <code>shape</code> <code>tuple</code> <p>Combined shape (total_dim,) of all aggregated controls</p> <code>min</code> <code>ndarray</code> <p>Lower bounds for all control variables, shape (total_dim,)</p> <code>max</code> <code>ndarray</code> <p>Upper bounds for all control variables, shape (total_dim,)</p> <code>guess</code> <code>ndarray</code> <p>Initial guess trajectory, shape (num_nodes, total_dim)</p> <code>_true_dim</code> <code>int</code> <p>Number of user-defined control dimensions (excludes augmented)</p> <code>_true_slice</code> <code>slice</code> <p>Slice for extracting true controls from unified vector</p> <code>_augmented_slice</code> <code>slice</code> <p>Slice for extracting augmented controls</p> <code>time_dilation_slice</code> <code>Optional[slice]</code> <p>Slice for time dilation control, if present</p> Properties <p>true: Returns UnifiedControl view containing only true (user-defined) controls augmented: Returns UnifiedControl view containing only augmented controls</p> Example <p>Creating a unified control from multiple Control objects::</p> <pre><code>from openscvx.symbolic.unified import unify_controls\n\nthrust = ox.Control(\"thrust\", shape=(3,), min=0, max=10)\ntorque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n\nunified = unify_controls([thrust, torque], name=\"u\")\nprint(unified.shape)        # (6,)\nprint(unified.min)          # [0, 0, 0, -1, -1, -1]\nprint(unified.true.shape)   # (6,) - all are true controls\nprint(unified.augmented.shape)  # (0,) - no augmented controls\n</code></pre> <p>Appending controls dynamically::</p> <pre><code>unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.0)  # Add scalar control\nprint(unified.shape)  # (1,)\n</code></pre> See Also <ul> <li>unify_controls(): Factory function for creating UnifiedControl from Control list</li> <li>Control: Individual symbolic control variable</li> <li>UnifiedState: Analogous unified state vector</li> </ul> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>@dataclass\nclass UnifiedControl:\n    \"\"\"Unified control vector aggregating multiple Control objects.\n\n    UnifiedControl is a drop-in replacement for individual Control objects that holds\n    aggregated data from multiple Control instances. It maintains compatibility with\n    optimization infrastructure while providing access to individual control components\n    through slicing.\n\n    The unified control separates user-defined \"true\" controls from augmented controls\n    added internally (e.g., for time dilation). This separation allows clean access to\n    physical control inputs while supporting advanced features.\n\n    Attributes:\n        name (str): Name identifier for the unified control vector\n        shape (tuple): Combined shape (total_dim,) of all aggregated controls\n        min (np.ndarray): Lower bounds for all control variables, shape (total_dim,)\n        max (np.ndarray): Upper bounds for all control variables, shape (total_dim,)\n        guess (np.ndarray): Initial guess trajectory, shape (num_nodes, total_dim)\n        _true_dim (int): Number of user-defined control dimensions (excludes augmented)\n        _true_slice (slice): Slice for extracting true controls from unified vector\n        _augmented_slice (slice): Slice for extracting augmented controls\n        time_dilation_slice (Optional[slice]): Slice for time dilation control, if present\n\n    Properties:\n        true: Returns UnifiedControl view containing only true (user-defined) controls\n        augmented: Returns UnifiedControl view containing only augmented controls\n\n    Example:\n        Creating a unified control from multiple Control objects::\n\n            from openscvx.symbolic.unified import unify_controls\n\n            thrust = ox.Control(\"thrust\", shape=(3,), min=0, max=10)\n            torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n\n            unified = unify_controls([thrust, torque], name=\"u\")\n            print(unified.shape)        # (6,)\n            print(unified.min)          # [0, 0, 0, -1, -1, -1]\n            print(unified.true.shape)   # (6,) - all are true controls\n            print(unified.augmented.shape)  # (0,) - no augmented controls\n\n        Appending controls dynamically::\n\n            unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.0)  # Add scalar control\n            print(unified.shape)  # (1,)\n\n    See Also:\n        - unify_controls(): Factory function for creating UnifiedControl from Control list\n        - Control: Individual symbolic control variable\n        - UnifiedState: Analogous unified state vector\n    \"\"\"\n\n    name: str\n    shape: tuple\n    min: Optional[np.ndarray] = None\n    max: Optional[np.ndarray] = None\n    guess: Optional[np.ndarray] = None\n    _true_dim: int = 0\n    _true_slice: Optional[slice] = None\n    _augmented_slice: Optional[slice] = None\n    time_dilation_slice: Optional[slice] = None  # Slice for time dilation control\n    scaling_min: Optional[np.ndarray] = None  # Scaling minimum bounds for unified control\n    scaling_max: Optional[np.ndarray] = None  # Scaling maximum bounds for unified control\n\n    def __post_init__(self):\n        \"\"\"Initialize slices after dataclass creation.\"\"\"\n        if self._true_slice is None:\n            self._true_slice = slice(0, self._true_dim)\n        if self._augmented_slice is None:\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    @property\n    def true(self) -&gt; \"UnifiedControl\":\n        \"\"\"Get the true (user-defined) control variables.\n\n        Returns a view of the unified control containing only user-defined controls,\n        excluding internal augmented controls added for time dilation, etc.\n\n        Returns:\n            UnifiedControl: Sliced view containing only true control variables\n\n        Example:\n            Get true user defined controls::\n\n                unified = unify_controls([thrust, torque, time_dilation], name=\"u\")\n                true_controls = unified.true  # Only thrust and torque\n        \"\"\"\n        return self[self._true_slice]\n\n    @property\n    def augmented(self) -&gt; \"UnifiedControl\":\n        \"\"\"Get the augmented (internal) control variables.\n\n        Returns a view of the unified control containing only augmented controls\n        added internally by the optimization framework (e.g., time dilation control).\n\n        Returns:\n            UnifiedControl: Sliced view containing only augmented control variables\n\n        Example:\n            Get augmented controls::\n\n                unified = unify_controls([thrust, time_dilation], name=\"u\")\n                aug_controls = unified.augmented  # Only time dilation\n        \"\"\"\n        return self[self._augmented_slice]\n\n    def append(\n        self,\n        other: \"Optional[Control | UnifiedControl]\" = None,\n        *,\n        min=-np.inf,\n        max=np.inf,\n        guess=0.0,\n        augmented=False,\n    ):\n        \"\"\"Append another control or create a new control variable.\n\n        This method allows dynamic extension of the unified control, either by appending\n        another Control/UnifiedControl object or by creating a new scalar control variable\n        with specified properties. Modifies the unified control in-place.\n\n        Args:\n            other (Optional[Control | UnifiedControl]): Control object to append. If None,\n                creates a new scalar control variable with properties from keyword args.\n            min (float): Lower bound for new scalar control (default: -inf)\n            max (float): Upper bound for new scalar control (default: inf)\n            guess (float): Initial guess value for new scalar control (default: 0.0)\n            augmented (bool): Whether the appended control is augmented (internal) rather\n                than true (user-defined). Affects _true_dim tracking. Default: False\n\n        Returns:\n            None: Modifies the unified control in-place\n\n        Example:\n            Appending a Control object::\n\n                unified = unify_controls([thrust], name=\"u\")\n                torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n                unified.append(torque)\n                print(unified.shape)  # (6,) - thrust (3) + torque (3)\n\n            Creating new scalar control variables::\n\n                unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\n                unified.append(min=-1, max=1, guess=0.0)  # Add scalar control\n                print(unified.shape)  # (1,)\n        \"\"\"\n        # Import here to avoid circular imports at module level\n        from openscvx.symbolic.expr.control import Control\n\n        if isinstance(other, (Control, UnifiedControl)):\n            # Append another control object\n            new_shape = (self.shape[0] + other.shape[0],)\n\n            # Update bounds\n            if self.min is not None and other.min is not None:\n                new_min = np.concatenate([self.min, other.min])\n            else:\n                new_min = self.min\n\n            if self.max is not None and other.max is not None:\n                new_max = np.concatenate([self.max, other.max])\n            else:\n                new_max = self.max\n\n            # Update guess\n            if self.guess is not None and other.guess is not None:\n                new_guess = np.concatenate([self.guess, other.guess], axis=1)\n            else:\n                new_guess = self.guess\n\n            # Update true dimension\n            if not augmented:\n                new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n            else:\n                new_true_dim = self._true_dim\n\n            # Update all attributes in place\n            self.shape = new_shape\n            self.min = new_min\n            self.max = new_max\n            self.guess = new_guess\n            self._true_dim = new_true_dim\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n        else:\n            # Create a single new variable\n            new_shape = (self.shape[0] + 1,)\n\n            # Extend arrays\n            if self.min is not None:\n                self.min = np.concatenate([self.min, np.array([min])])\n            if self.max is not None:\n                self.max = np.concatenate([self.max, np.array([max])])\n            if self.guess is not None:\n                guess_arr = np.full((self.guess.shape[0], 1), guess)\n                self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n\n            # Update dimensions\n            self.shape = new_shape\n            if not augmented:\n                self._true_dim += 1\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    def __getitem__(self, idx):\n        \"\"\"Get a subset of the unified control variables.\n\n        Enables slicing of the unified control to extract subsets of control variables.\n        Returns a new UnifiedControl containing only the sliced dimensions.\n\n        Args:\n            idx (slice): Slice object specifying which control dimensions to extract.\n                Only simple slices with step=1 are supported.\n\n        Returns:\n            UnifiedControl: New unified control containing only the sliced dimensions\n\n        Raises:\n            NotImplementedError: If idx is not a slice, or if step != 1\n\n        Example:\n            Generate unified control object::\n\n                unified = unify_controls([thrust, torque], name=\"u\")\n\n            thrust has shape (3,), torque has shape (3,)::\n\n                first_three = unified[0:3]  # Extract thrust only\n                print(first_three.shape)  # (3,)\n\n        Note:\n            The sliced control maintains all properties (bounds, guesses, etc.) for\n            the selected dimensions. The _true_dim is recalculated based on which\n            dimensions fall within the original true control range.\n        \"\"\"\n        if isinstance(idx, slice):\n            start, stop, step = idx.indices(self.shape[0])\n            if step != 1:\n                raise NotImplementedError(\"Step slicing not supported\")\n\n            new_shape = (stop - start,)\n            new_name = f\"{self.name}[{start}:{stop}]\"\n\n            # Slice all arrays\n            new_min = self.min[idx] if self.min is not None else None\n            new_max = self.max[idx] if self.max is not None else None\n            new_guess = self.guess[:, idx] if self.guess is not None else None\n\n            # Calculate new true dimension\n            new_true_dim = max(0, min(stop, self._true_dim) - max(start, 0))\n\n            return UnifiedControl(\n                name=new_name,\n                shape=new_shape,\n                min=new_min,\n                max=new_max,\n                guess=new_guess,\n                _true_dim=new_true_dim,\n                _true_slice=slice(0, new_true_dim),\n                _augmented_slice=slice(new_true_dim, new_shape[0]),\n            )\n        else:\n            raise NotImplementedError(\"Only slice indexing is supported\")\n\n    def __repr__(self):\n        \"\"\"String representation of the UnifiedControl object.\"\"\"\n        return f\"UnifiedControl('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.UnifiedControl.augmented","title":"<code>augmented: UnifiedControl</code>  <code>property</code>","text":"<p>Get the augmented (internal) control variables.</p> <p>Returns a view of the unified control containing only augmented controls added internally by the optimization framework (e.g., time dilation control).</p> <p>Returns:</p> Name Type Description <code>UnifiedControl</code> <code>UnifiedControl</code> <p>Sliced view containing only augmented control variables</p> Example <p>Get augmented controls::</p> <pre><code>unified = unify_controls([thrust, time_dilation], name=\"u\")\naug_controls = unified.augmented  # Only time dilation\n</code></pre>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.UnifiedControl.true","title":"<code>true: UnifiedControl</code>  <code>property</code>","text":"<p>Get the true (user-defined) control variables.</p> <p>Returns a view of the unified control containing only user-defined controls, excluding internal augmented controls added for time dilation, etc.</p> <p>Returns:</p> Name Type Description <code>UnifiedControl</code> <code>UnifiedControl</code> <p>Sliced view containing only true control variables</p> Example <p>Get true user defined controls::</p> <pre><code>unified = unify_controls([thrust, torque, time_dilation], name=\"u\")\ntrue_controls = unified.true  # Only thrust and torque\n</code></pre>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.UnifiedControl.append","title":"<code>append(other: Optional[Control | UnifiedControl] = None, *, min=-np.inf, max=np.inf, guess=0.0, augmented=False)</code>","text":"<p>Append another control or create a new control variable.</p> <p>This method allows dynamic extension of the unified control, either by appending another Control/UnifiedControl object or by creating a new scalar control variable with specified properties. Modifies the unified control in-place.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Optional[Control | UnifiedControl]</code> <p>Control object to append. If None, creates a new scalar control variable with properties from keyword args.</p> <code>None</code> <code>min</code> <code>float</code> <p>Lower bound for new scalar control (default: -inf)</p> <code>-inf</code> <code>max</code> <code>float</code> <p>Upper bound for new scalar control (default: inf)</p> <code>inf</code> <code>guess</code> <code>float</code> <p>Initial guess value for new scalar control (default: 0.0)</p> <code>0.0</code> <code>augmented</code> <code>bool</code> <p>Whether the appended control is augmented (internal) rather than true (user-defined). Affects _true_dim tracking. Default: False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <p>Modifies the unified control in-place</p> Example <p>Appending a Control object::</p> <pre><code>unified = unify_controls([thrust], name=\"u\")\ntorque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\nunified.append(torque)\nprint(unified.shape)  # (6,) - thrust (3) + torque (3)\n</code></pre> <p>Creating new scalar control variables::</p> <pre><code>unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.0)  # Add scalar control\nprint(unified.shape)  # (1,)\n</code></pre> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>def append(\n    self,\n    other: \"Optional[Control | UnifiedControl]\" = None,\n    *,\n    min=-np.inf,\n    max=np.inf,\n    guess=0.0,\n    augmented=False,\n):\n    \"\"\"Append another control or create a new control variable.\n\n    This method allows dynamic extension of the unified control, either by appending\n    another Control/UnifiedControl object or by creating a new scalar control variable\n    with specified properties. Modifies the unified control in-place.\n\n    Args:\n        other (Optional[Control | UnifiedControl]): Control object to append. If None,\n            creates a new scalar control variable with properties from keyword args.\n        min (float): Lower bound for new scalar control (default: -inf)\n        max (float): Upper bound for new scalar control (default: inf)\n        guess (float): Initial guess value for new scalar control (default: 0.0)\n        augmented (bool): Whether the appended control is augmented (internal) rather\n            than true (user-defined). Affects _true_dim tracking. Default: False\n\n    Returns:\n        None: Modifies the unified control in-place\n\n    Example:\n        Appending a Control object::\n\n            unified = unify_controls([thrust], name=\"u\")\n            torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n            unified.append(torque)\n            print(unified.shape)  # (6,) - thrust (3) + torque (3)\n\n        Creating new scalar control variables::\n\n            unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.0)  # Add scalar control\n            print(unified.shape)  # (1,)\n    \"\"\"\n    # Import here to avoid circular imports at module level\n    from openscvx.symbolic.expr.control import Control\n\n    if isinstance(other, (Control, UnifiedControl)):\n        # Append another control object\n        new_shape = (self.shape[0] + other.shape[0],)\n\n        # Update bounds\n        if self.min is not None and other.min is not None:\n            new_min = np.concatenate([self.min, other.min])\n        else:\n            new_min = self.min\n\n        if self.max is not None and other.max is not None:\n            new_max = np.concatenate([self.max, other.max])\n        else:\n            new_max = self.max\n\n        # Update guess\n        if self.guess is not None and other.guess is not None:\n            new_guess = np.concatenate([self.guess, other.guess], axis=1)\n        else:\n            new_guess = self.guess\n\n        # Update true dimension\n        if not augmented:\n            new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n        else:\n            new_true_dim = self._true_dim\n\n        # Update all attributes in place\n        self.shape = new_shape\n        self.min = new_min\n        self.max = new_max\n        self.guess = new_guess\n        self._true_dim = new_true_dim\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    else:\n        # Create a single new variable\n        new_shape = (self.shape[0] + 1,)\n\n        # Extend arrays\n        if self.min is not None:\n            self.min = np.concatenate([self.min, np.array([min])])\n        if self.max is not None:\n            self.max = np.concatenate([self.max, np.array([max])])\n        if self.guess is not None:\n            guess_arr = np.full((self.guess.shape[0], 1), guess)\n            self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n\n        # Update dimensions\n        self.shape = new_shape\n        if not augmented:\n            self._true_dim += 1\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n</code></pre>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.UnifiedState","title":"<code>UnifiedState</code>  <code>dataclass</code>","text":"<p>Unified state vector aggregating multiple State objects.</p> <p>UnifiedState is a drop-in replacement for individual State objects that holds aggregated data from multiple State instances. It maintains compatibility with optimization infrastructure while providing access to individual state components through slicing.</p> <p>The unified state separates user-defined \"true\" states from augmented states added internally (e.g., for CTCS constraints or time variables). This separation allows clean access to physical states while supporting advanced features.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the unified state vector</p> <code>shape</code> <code>tuple</code> <p>Combined shape (total_dim,) of all aggregated states</p> <code>min</code> <code>ndarray</code> <p>Lower bounds for all state variables, shape (total_dim,)</p> <code>max</code> <code>ndarray</code> <p>Upper bounds for all state variables, shape (total_dim,)</p> <code>guess</code> <code>ndarray</code> <p>Initial guess trajectory, shape (num_nodes, total_dim)</p> <code>initial</code> <code>ndarray</code> <p>Initial boundary conditions, shape (total_dim,)</p> <code>final</code> <code>ndarray</code> <p>Final boundary conditions, shape (total_dim,)</p> <code>_initial</code> <code>ndarray</code> <p>Internal initial values, shape (total_dim,)</p> <code>_final</code> <code>ndarray</code> <p>Internal final values, shape (total_dim,)</p> <code>initial_type</code> <code>ndarray</code> <p>Boundary condition types at t0 (\"Fix\" or \"Free\"), shape (total_dim,), dtype=object</p> <code>final_type</code> <code>ndarray</code> <p>Boundary condition types at tf (\"Fix\" or \"Free\"), shape (total_dim,), dtype=object</p> <code>_true_dim</code> <code>int</code> <p>Number of user-defined state dimensions (excludes augmented)</p> <code>_true_slice</code> <code>slice</code> <p>Slice for extracting true states from unified vector</p> <code>_augmented_slice</code> <code>slice</code> <p>Slice for extracting augmented states</p> <code>time_slice</code> <code>Optional[slice]</code> <p>Slice for time state variable, if present</p> <code>ctcs_slice</code> <code>Optional[slice]</code> <p>Slice for CTCS augmented states, if present</p> Properties <p>true: Returns UnifiedState view containing only true (user-defined) states augmented: Returns UnifiedState view containing only augmented states</p> Example <p>Creating a unified state from multiple State objects::</p> <pre><code>from openscvx.symbolic.unified import unify_states\n\nposition = ox.State(\"pos\", shape=(3,), min=-10, max=10)\nvelocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n\nunified = unify_states([position, velocity], name=\"x\")\nprint(unified.shape)        # (6,)\nprint(unified.min)          # [-10, -10, -10, -5, -5, -5]\nprint(unified.true.shape)   # (6,) - all are true states\nprint(unified.augmented.shape)  # (0,) - no augmented states\n</code></pre> <p>Appending states dynamically::</p> <pre><code>unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.5)  # Add scalar state\nprint(unified.shape)  # (1,)\n</code></pre> See Also <ul> <li>unify_states(): Factory function for creating UnifiedState from State list</li> <li>State: Individual symbolic state variable</li> <li>UnifiedControl: Analogous unified control vector</li> </ul> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>@dataclass\nclass UnifiedState:\n    \"\"\"Unified state vector aggregating multiple State objects.\n\n    UnifiedState is a drop-in replacement for individual State objects that holds\n    aggregated data from multiple State instances. It maintains compatibility with\n    optimization infrastructure while providing access to individual state components\n    through slicing.\n\n    The unified state separates user-defined \"true\" states from augmented states\n    added internally (e.g., for CTCS constraints or time variables). This separation\n    allows clean access to physical states while supporting advanced features.\n\n    Attributes:\n        name (str): Name identifier for the unified state vector\n        shape (tuple): Combined shape (total_dim,) of all aggregated states\n        min (np.ndarray): Lower bounds for all state variables, shape (total_dim,)\n        max (np.ndarray): Upper bounds for all state variables, shape (total_dim,)\n        guess (np.ndarray): Initial guess trajectory, shape (num_nodes, total_dim)\n        initial (np.ndarray): Initial boundary conditions, shape (total_dim,)\n        final (np.ndarray): Final boundary conditions, shape (total_dim,)\n        _initial (np.ndarray): Internal initial values, shape (total_dim,)\n        _final (np.ndarray): Internal final values, shape (total_dim,)\n        initial_type (np.ndarray): Boundary condition types at t0 (\"Fix\" or \"Free\"),\n            shape (total_dim,), dtype=object\n        final_type (np.ndarray): Boundary condition types at tf (\"Fix\" or \"Free\"),\n            shape (total_dim,), dtype=object\n        _true_dim (int): Number of user-defined state dimensions (excludes augmented)\n        _true_slice (slice): Slice for extracting true states from unified vector\n        _augmented_slice (slice): Slice for extracting augmented states\n        time_slice (Optional[slice]): Slice for time state variable, if present\n        ctcs_slice (Optional[slice]): Slice for CTCS augmented states, if present\n\n    Properties:\n        true: Returns UnifiedState view containing only true (user-defined) states\n        augmented: Returns UnifiedState view containing only augmented states\n\n    Example:\n        Creating a unified state from multiple State objects::\n\n            from openscvx.symbolic.unified import unify_states\n\n            position = ox.State(\"pos\", shape=(3,), min=-10, max=10)\n            velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n\n            unified = unify_states([position, velocity], name=\"x\")\n            print(unified.shape)        # (6,)\n            print(unified.min)          # [-10, -10, -10, -5, -5, -5]\n            print(unified.true.shape)   # (6,) - all are true states\n            print(unified.augmented.shape)  # (0,) - no augmented states\n\n        Appending states dynamically::\n\n            unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.5)  # Add scalar state\n            print(unified.shape)  # (1,)\n\n    See Also:\n        - unify_states(): Factory function for creating UnifiedState from State list\n        - State: Individual symbolic state variable\n        - UnifiedControl: Analogous unified control vector\n    \"\"\"\n\n    name: str\n    shape: tuple\n    min: Optional[np.ndarray] = None\n    max: Optional[np.ndarray] = None\n    guess: Optional[np.ndarray] = None\n    initial: Optional[np.ndarray] = None\n    final: Optional[np.ndarray] = None\n    _initial: Optional[np.ndarray] = None\n    _final: Optional[np.ndarray] = None\n    initial_type: Optional[np.ndarray] = None\n    final_type: Optional[np.ndarray] = None\n    _true_dim: int = 0\n    _true_slice: Optional[slice] = None\n    _augmented_slice: Optional[slice] = None\n    time_slice: Optional[slice] = None  # Slice for time state\n    ctcs_slice: Optional[slice] = None  # Slice for CTCS augmented states\n    scaling_min: Optional[np.ndarray] = None  # Scaling minimum bounds for unified state\n    scaling_max: Optional[np.ndarray] = None  # Scaling maximum bounds for unified state\n\n    def __post_init__(self):\n        \"\"\"Initialize slices after dataclass creation.\"\"\"\n        if self._true_slice is None:\n            self._true_slice = slice(0, self._true_dim)\n        if self._augmented_slice is None:\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    @property\n    def true(self) -&gt; \"UnifiedState\":\n        \"\"\"Get the true (user-defined) state variables.\n\n        Returns a view of the unified state containing only user-defined states,\n        excluding internal augmented states added for CTCS, time, etc.\n\n        Returns:\n            UnifiedState: Sliced view containing only true state variables\n\n        Example:\n            Get true user-defined state::\n\n                unified = unify_states([position, velocity, ctcs_aug], name=\"x\")\n                true_states = unified.true  # Only position and velocity\n                true_states.shape  # (6,) if position and velocity are 3D each\n        \"\"\"\n        return self[self._true_slice]\n\n    @property\n    def augmented(self) -&gt; \"UnifiedState\":\n        \"\"\"Get the augmented (internal) state variables.\n\n        Returns a view of the unified state containing only augmented states\n        added internally by the optimization framework (e.g., CTCS penalty states,\n        time variables).\n\n        Returns:\n            UnifiedState: Sliced view containing only augmented state variables\n\n        Example:\n            Get augmented state::\n\n                unified = unify_states([position, ctcs_aug], name=\"x\")\n                aug_states = unified.augmented  # Only CTCS states\n        \"\"\"\n        return self[self._augmented_slice]\n\n    def append(\n        self,\n        other: \"Optional[State | UnifiedState]\" = None,\n        *,\n        min=-np.inf,\n        max=np.inf,\n        guess=0.0,\n        initial=0.0,\n        final=0.0,\n        augmented=False,\n    ):\n        \"\"\"Append another state or create a new state variable.\n\n        This method allows dynamic extension of the unified state, either by appending\n        another State/UnifiedState object or by creating a new scalar state variable\n        with specified properties. Modifies the unified state in-place.\n\n        Args:\n            other (Optional[State | UnifiedState]): State object to append. If None,\n                creates a new scalar state variable with properties from keyword args.\n            min (float): Lower bound for new scalar state (default: -inf)\n            max (float): Upper bound for new scalar state (default: inf)\n            guess (float): Initial guess value for new scalar state (default: 0.0)\n            initial (float): Initial boundary condition for new scalar state (default: 0.0)\n            final (float): Final boundary condition for new scalar state (default: 0.0)\n            augmented (bool): Whether the appended state is augmented (internal) rather\n                than true (user-defined). Affects _true_dim tracking. Default: False\n\n        Returns:\n            None: Modifies the unified state in-place\n\n        Example:\n            Appending a State object::\n\n                unified = unify_states([position], name=\"x\")\n                velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n                unified.append(velocity)\n                print(unified.shape)  # (6,) - position (3) + velocity (3)\n\n            Creating new scalar state variables::\n\n                unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\n                unified.append(min=-1, max=1, guess=0.5)  # Add scalar state\n                unified.append(min=-2, max=2, augmented=True)  # Add augmented state\n                print(unified.shape)  # (2,)\n                print(unified._true_dim)  # 1 (only first is true)\n\n        Note:\n            Maintains the invariant that true states appear before augmented states\n            in the unified vector. When appending augmented states, they are added\n            to the end but don't increment _true_dim.\n        \"\"\"\n        # Import here to avoid circular imports at module level\n        from openscvx.symbolic.expr.state import State\n\n        if isinstance(other, (State, UnifiedState)):\n            # Append another state object\n            new_shape = (self.shape[0] + other.shape[0],)\n\n            # Update bounds\n            if self.min is not None and other.min is not None:\n                new_min = np.concatenate([self.min, other.min])\n            else:\n                new_min = self.min\n\n            if self.max is not None and other.max is not None:\n                new_max = np.concatenate([self.max, other.max])\n            else:\n                new_max = self.max\n\n            # Update guess\n            if self.guess is not None and other.guess is not None:\n                new_guess = np.concatenate([self.guess, other.guess], axis=1)\n            else:\n                new_guess = self.guess\n\n            # Update initial/final conditions\n            if self.initial is not None and other.initial is not None:\n                new_initial = np.concatenate([self.initial, other.initial])\n            else:\n                new_initial = self.initial\n\n            if self.final is not None and other.final is not None:\n                new_final = np.concatenate([self.final, other.final])\n            else:\n                new_final = self.final\n\n            # Update internal arrays\n            if self._initial is not None and other._initial is not None:\n                new__initial = np.concatenate([self._initial, other._initial])\n            else:\n                new__initial = self._initial\n\n            if self._final is not None and other._final is not None:\n                new__final = np.concatenate([self._final, other._final])\n            else:\n                new__final = self._final\n\n            # Update types\n            if self.initial_type is not None and other.initial_type is not None:\n                new_initial_type = np.concatenate([self.initial_type, other.initial_type])\n            else:\n                new_initial_type = self.initial_type\n\n            if self.final_type is not None and other.final_type is not None:\n                new_final_type = np.concatenate([self.final_type, other.final_type])\n            else:\n                new_final_type = self.final_type\n\n            # Update true dimension\n            if not augmented:\n                new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n            else:\n                new_true_dim = self._true_dim\n\n            # Update all attributes in place\n            self.shape = new_shape\n            self.min = new_min\n            self.max = new_max\n            self.guess = new_guess\n            self.initial = new_initial\n            self.final = new_final\n            self._initial = new__initial\n            self._final = new__final\n            self.initial_type = new_initial_type\n            self.final_type = new_final_type\n            self._true_dim = new_true_dim\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n        else:\n            # Create a single new variable\n            new_shape = (self.shape[0] + 1,)\n\n            # Extend arrays\n            if self.min is not None:\n                self.min = np.concatenate([self.min, np.array([min])])\n            if self.max is not None:\n                self.max = np.concatenate([self.max, np.array([max])])\n            if self.guess is not None:\n                guess_arr = np.full((self.guess.shape[0], 1), guess)\n                self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n            if self.initial is not None:\n                self.initial = np.concatenate([self.initial, np.array([initial])])\n            if self.final is not None:\n                self.final = np.concatenate([self.final, np.array([final])])\n            if self._initial is not None:\n                self._initial = np.concatenate([self._initial, np.array([initial])])\n            if self._final is not None:\n                self._final = np.concatenate([self._final, np.array([final])])\n            if self.initial_type is not None:\n                self.initial_type = np.concatenate(\n                    [self.initial_type, np.array([\"Fix\"], dtype=object)]\n                )\n            if self.final_type is not None:\n                self.final_type = np.concatenate([self.final_type, np.array([\"Fix\"], dtype=object)])\n\n            # Update dimensions\n            self.shape = new_shape\n            if not augmented:\n                self._true_dim += 1\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    def __getitem__(self, idx):\n        \"\"\"Get a subset of the unified state variables.\n\n        Enables slicing of the unified state to extract subsets of state variables.\n        Returns a new UnifiedState containing only the sliced dimensions.\n\n        Args:\n            idx (slice): Slice object specifying which state dimensions to extract.\n                Only simple slices with step=1 are supported.\n\n        Returns:\n            UnifiedState: New unified state containing only the sliced dimensions\n\n        Raises:\n            NotImplementedError: If idx is not a slice, or if step != 1\n\n        Example:\n            Generate unified state object::\n\n                unified = unify_states([position, velocity], name=\"x\")\n\n            position has shape (3,), velocity has shape (3,)::\n\n                first_three = unified[0:3]  # Extract position only\n                print(first_three.shape)  # (3,)\n                last_three = unified[3:6]  # Extract velocity only\n                print(last_three.shape)  # (3,)\n\n        Note:\n            The sliced state maintains all properties (bounds, guesses, etc.) for\n            the selected dimensions. The _true_dim is recalculated based on which\n            dimensions fall within the original true state range.\n        \"\"\"\n        if isinstance(idx, slice):\n            start, stop, step = idx.indices(self.shape[0])\n            if step != 1:\n                raise NotImplementedError(\"Step slicing not supported\")\n\n            new_shape = (stop - start,)\n            new_name = f\"{self.name}[{start}:{stop}]\"\n\n            # Slice all arrays\n            new_min = self.min[idx] if self.min is not None else None\n            new_max = self.max[idx] if self.max is not None else None\n            new_guess = self.guess[:, idx] if self.guess is not None else None\n            new_initial = self.initial[idx] if self.initial is not None else None\n            new_final = self.final[idx] if self.final is not None else None\n            new__initial = self._initial[idx] if self._initial is not None else None\n            new__final = self._final[idx] if self._final is not None else None\n            new_initial_type = self.initial_type[idx] if self.initial_type is not None else None\n            new_final_type = self.final_type[idx] if self.final_type is not None else None\n\n            # Calculate new true dimension\n            new_true_dim = max(0, min(stop, self._true_dim) - max(start, 0))\n\n            return UnifiedState(\n                name=new_name,\n                shape=new_shape,\n                min=new_min,\n                max=new_max,\n                guess=new_guess,\n                initial=new_initial,\n                final=new_final,\n                _initial=new__initial,\n                _final=new__final,\n                initial_type=new_initial_type,\n                final_type=new_final_type,\n                _true_dim=new_true_dim,\n                _true_slice=slice(0, new_true_dim),\n                _augmented_slice=slice(new_true_dim, new_shape[0]),\n            )\n        else:\n            raise NotImplementedError(\"Only slice indexing is supported\")\n\n    def __repr__(self):\n        \"\"\"String representation of the UnifiedState object.\"\"\"\n        return f\"UnifiedState('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.UnifiedState.augmented","title":"<code>augmented: UnifiedState</code>  <code>property</code>","text":"<p>Get the augmented (internal) state variables.</p> <p>Returns a view of the unified state containing only augmented states added internally by the optimization framework (e.g., CTCS penalty states, time variables).</p> <p>Returns:</p> Name Type Description <code>UnifiedState</code> <code>UnifiedState</code> <p>Sliced view containing only augmented state variables</p> Example <p>Get augmented state::</p> <pre><code>unified = unify_states([position, ctcs_aug], name=\"x\")\naug_states = unified.augmented  # Only CTCS states\n</code></pre>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.UnifiedState.true","title":"<code>true: UnifiedState</code>  <code>property</code>","text":"<p>Get the true (user-defined) state variables.</p> <p>Returns a view of the unified state containing only user-defined states, excluding internal augmented states added for CTCS, time, etc.</p> <p>Returns:</p> Name Type Description <code>UnifiedState</code> <code>UnifiedState</code> <p>Sliced view containing only true state variables</p> Example <p>Get true user-defined state::</p> <pre><code>unified = unify_states([position, velocity, ctcs_aug], name=\"x\")\ntrue_states = unified.true  # Only position and velocity\ntrue_states.shape  # (6,) if position and velocity are 3D each\n</code></pre>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.UnifiedState.append","title":"<code>append(other: Optional[State | UnifiedState] = None, *, min=-np.inf, max=np.inf, guess=0.0, initial=0.0, final=0.0, augmented=False)</code>","text":"<p>Append another state or create a new state variable.</p> <p>This method allows dynamic extension of the unified state, either by appending another State/UnifiedState object or by creating a new scalar state variable with specified properties. Modifies the unified state in-place.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Optional[State | UnifiedState]</code> <p>State object to append. If None, creates a new scalar state variable with properties from keyword args.</p> <code>None</code> <code>min</code> <code>float</code> <p>Lower bound for new scalar state (default: -inf)</p> <code>-inf</code> <code>max</code> <code>float</code> <p>Upper bound for new scalar state (default: inf)</p> <code>inf</code> <code>guess</code> <code>float</code> <p>Initial guess value for new scalar state (default: 0.0)</p> <code>0.0</code> <code>initial</code> <code>float</code> <p>Initial boundary condition for new scalar state (default: 0.0)</p> <code>0.0</code> <code>final</code> <code>float</code> <p>Final boundary condition for new scalar state (default: 0.0)</p> <code>0.0</code> <code>augmented</code> <code>bool</code> <p>Whether the appended state is augmented (internal) rather than true (user-defined). Affects _true_dim tracking. Default: False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <p>Modifies the unified state in-place</p> Example <p>Appending a State object::</p> <pre><code>unified = unify_states([position], name=\"x\")\nvelocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\nunified.append(velocity)\nprint(unified.shape)  # (6,) - position (3) + velocity (3)\n</code></pre> <p>Creating new scalar state variables::</p> <pre><code>unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.5)  # Add scalar state\nunified.append(min=-2, max=2, augmented=True)  # Add augmented state\nprint(unified.shape)  # (2,)\nprint(unified._true_dim)  # 1 (only first is true)\n</code></pre> Note <p>Maintains the invariant that true states appear before augmented states in the unified vector. When appending augmented states, they are added to the end but don't increment _true_dim.</p> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>def append(\n    self,\n    other: \"Optional[State | UnifiedState]\" = None,\n    *,\n    min=-np.inf,\n    max=np.inf,\n    guess=0.0,\n    initial=0.0,\n    final=0.0,\n    augmented=False,\n):\n    \"\"\"Append another state or create a new state variable.\n\n    This method allows dynamic extension of the unified state, either by appending\n    another State/UnifiedState object or by creating a new scalar state variable\n    with specified properties. Modifies the unified state in-place.\n\n    Args:\n        other (Optional[State | UnifiedState]): State object to append. If None,\n            creates a new scalar state variable with properties from keyword args.\n        min (float): Lower bound for new scalar state (default: -inf)\n        max (float): Upper bound for new scalar state (default: inf)\n        guess (float): Initial guess value for new scalar state (default: 0.0)\n        initial (float): Initial boundary condition for new scalar state (default: 0.0)\n        final (float): Final boundary condition for new scalar state (default: 0.0)\n        augmented (bool): Whether the appended state is augmented (internal) rather\n            than true (user-defined). Affects _true_dim tracking. Default: False\n\n    Returns:\n        None: Modifies the unified state in-place\n\n    Example:\n        Appending a State object::\n\n            unified = unify_states([position], name=\"x\")\n            velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n            unified.append(velocity)\n            print(unified.shape)  # (6,) - position (3) + velocity (3)\n\n        Creating new scalar state variables::\n\n            unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.5)  # Add scalar state\n            unified.append(min=-2, max=2, augmented=True)  # Add augmented state\n            print(unified.shape)  # (2,)\n            print(unified._true_dim)  # 1 (only first is true)\n\n    Note:\n        Maintains the invariant that true states appear before augmented states\n        in the unified vector. When appending augmented states, they are added\n        to the end but don't increment _true_dim.\n    \"\"\"\n    # Import here to avoid circular imports at module level\n    from openscvx.symbolic.expr.state import State\n\n    if isinstance(other, (State, UnifiedState)):\n        # Append another state object\n        new_shape = (self.shape[0] + other.shape[0],)\n\n        # Update bounds\n        if self.min is not None and other.min is not None:\n            new_min = np.concatenate([self.min, other.min])\n        else:\n            new_min = self.min\n\n        if self.max is not None and other.max is not None:\n            new_max = np.concatenate([self.max, other.max])\n        else:\n            new_max = self.max\n\n        # Update guess\n        if self.guess is not None and other.guess is not None:\n            new_guess = np.concatenate([self.guess, other.guess], axis=1)\n        else:\n            new_guess = self.guess\n\n        # Update initial/final conditions\n        if self.initial is not None and other.initial is not None:\n            new_initial = np.concatenate([self.initial, other.initial])\n        else:\n            new_initial = self.initial\n\n        if self.final is not None and other.final is not None:\n            new_final = np.concatenate([self.final, other.final])\n        else:\n            new_final = self.final\n\n        # Update internal arrays\n        if self._initial is not None and other._initial is not None:\n            new__initial = np.concatenate([self._initial, other._initial])\n        else:\n            new__initial = self._initial\n\n        if self._final is not None and other._final is not None:\n            new__final = np.concatenate([self._final, other._final])\n        else:\n            new__final = self._final\n\n        # Update types\n        if self.initial_type is not None and other.initial_type is not None:\n            new_initial_type = np.concatenate([self.initial_type, other.initial_type])\n        else:\n            new_initial_type = self.initial_type\n\n        if self.final_type is not None and other.final_type is not None:\n            new_final_type = np.concatenate([self.final_type, other.final_type])\n        else:\n            new_final_type = self.final_type\n\n        # Update true dimension\n        if not augmented:\n            new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n        else:\n            new_true_dim = self._true_dim\n\n        # Update all attributes in place\n        self.shape = new_shape\n        self.min = new_min\n        self.max = new_max\n        self.guess = new_guess\n        self.initial = new_initial\n        self.final = new_final\n        self._initial = new__initial\n        self._final = new__final\n        self.initial_type = new_initial_type\n        self.final_type = new_final_type\n        self._true_dim = new_true_dim\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    else:\n        # Create a single new variable\n        new_shape = (self.shape[0] + 1,)\n\n        # Extend arrays\n        if self.min is not None:\n            self.min = np.concatenate([self.min, np.array([min])])\n        if self.max is not None:\n            self.max = np.concatenate([self.max, np.array([max])])\n        if self.guess is not None:\n            guess_arr = np.full((self.guess.shape[0], 1), guess)\n            self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n        if self.initial is not None:\n            self.initial = np.concatenate([self.initial, np.array([initial])])\n        if self.final is not None:\n            self.final = np.concatenate([self.final, np.array([final])])\n        if self._initial is not None:\n            self._initial = np.concatenate([self._initial, np.array([initial])])\n        if self._final is not None:\n            self._final = np.concatenate([self._final, np.array([final])])\n        if self.initial_type is not None:\n            self.initial_type = np.concatenate(\n                [self.initial_type, np.array([\"Fix\"], dtype=object)]\n            )\n        if self.final_type is not None:\n            self.final_type = np.concatenate([self.final_type, np.array([\"Fix\"], dtype=object)])\n\n        # Update dimensions\n        self.shape = new_shape\n        if not augmented:\n            self._true_dim += 1\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n</code></pre>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.unify_controls","title":"<code>unify_controls(controls: List[Control], name: str = 'unified_control') -&gt; UnifiedControl</code>","text":"<p>Create a UnifiedControl from a list of Control objects.</p> <p>This function is the primary way to aggregate multiple symbolic Control objects into a single unified control vector for numerical optimization. It:</p> <ol> <li>Sorts controls (user-defined first, augmented controls second)</li> <li>Concatenates all control properties (bounds, guesses)</li> <li>Assigns slices to each Control for extracting values from unified vector</li> <li>Identifies special controls (time dilation)</li> <li>Returns a UnifiedControl with all aggregated data</li> </ol> <p>Parameters:</p> Name Type Description Default <code>controls</code> <code>List[Control]</code> <p>List of Control objects to unify. Can include both user-defined controls and augmented controls (names starting with '_').</p> required <code>name</code> <code>str</code> <p>Name identifier for the unified control vector (default: \"unified_control\")</p> <code>'unified_control'</code> <p>Returns:</p> Name Type Description <code>UnifiedControl</code> <code>UnifiedControl</code> <p>Unified control object containing: - Aggregated bounds and guesses - Shape equal to sum of all control shapes - Slices for extracting individual control components - Properties for accessing true vs augmented controls</p> Example <p>Basic unification::</p> <pre><code>import openscvx as ox\nfrom openscvx.symbolic.unified import unify_controls\n\nthrust = ox.Control(\"thrust\", shape=(3,), min=0, max=10)\ntorque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n\nunified = unify_controls([thrust, torque], name=\"u\")\nprint(unified.shape)       # (6,)\nprint(unified._true_dim)   # 6 (all are user controls)\nprint(thrust._slice)       # slice(0, 3) - assigned during unification\nprint(torque._slice)       # slice(3, 6)\n</code></pre> <p>With augmented controls::</p> <pre><code># Time-optimal problems may add time dilation control\ntime_dilation = ox.Control(\"_time_dilation\", shape=(1,))\n\nunified = unify_controls([thrust, torque, time_dilation])\nprint(unified._true_dim)         # 6 (thrust + torque)\nprint(unified.true.shape)        # (6,)\nprint(unified.augmented.shape)   # (1,) - time dilation\n</code></pre> Note <p>After unification, each Control object has its <code>_slice</code> attribute set, which is used during JAX lowering to extract the correct values from the unified control vector.</p> See Also <ul> <li>UnifiedControl: Return type with detailed documentation</li> <li>unify_states(): Analogous function for State objects</li> <li>Control: Individual symbolic control variable</li> </ul> Source code in <code>openscvx/symbolic/unified.py</code> <pre><code>def unify_controls(controls: List[Control], name: str = \"unified_control\") -&gt; UnifiedControl:\n    \"\"\"Create a UnifiedControl from a list of Control objects.\n\n    This function is the primary way to aggregate multiple symbolic Control objects into\n    a single unified control vector for numerical optimization. It:\n\n    1. Sorts controls (user-defined first, augmented controls second)\n    2. Concatenates all control properties (bounds, guesses)\n    3. Assigns slices to each Control for extracting values from unified vector\n    4. Identifies special controls (time dilation)\n    5. Returns a UnifiedControl with all aggregated data\n\n    Args:\n        controls (List[Control]): List of Control objects to unify. Can include both\n            user-defined controls and augmented controls (names starting with '_').\n        name (str): Name identifier for the unified control vector (default: \"unified_control\")\n\n    Returns:\n        UnifiedControl: Unified control object containing:\n            - Aggregated bounds and guesses\n            - Shape equal to sum of all control shapes\n            - Slices for extracting individual control components\n            - Properties for accessing true vs augmented controls\n\n    Example:\n        Basic unification::\n\n            import openscvx as ox\n            from openscvx.symbolic.unified import unify_controls\n\n            thrust = ox.Control(\"thrust\", shape=(3,), min=0, max=10)\n            torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n\n            unified = unify_controls([thrust, torque], name=\"u\")\n            print(unified.shape)       # (6,)\n            print(unified._true_dim)   # 6 (all are user controls)\n            print(thrust._slice)       # slice(0, 3) - assigned during unification\n            print(torque._slice)       # slice(3, 6)\n\n        With augmented controls::\n\n            # Time-optimal problems may add time dilation control\n            time_dilation = ox.Control(\"_time_dilation\", shape=(1,))\n\n            unified = unify_controls([thrust, torque, time_dilation])\n            print(unified._true_dim)         # 6 (thrust + torque)\n            print(unified.true.shape)        # (6,)\n            print(unified.augmented.shape)   # (1,) - time dilation\n\n    Note:\n        After unification, each Control object has its `_slice` attribute set,\n        which is used during JAX lowering to extract the correct values from\n        the unified control vector.\n\n    See Also:\n        - UnifiedControl: Return type with detailed documentation\n        - unify_states(): Analogous function for State objects\n        - Control: Individual symbolic control variable\n    \"\"\"\n    if not controls:\n        return UnifiedControl(name=name, shape=(0,))\n\n    # Sort controls: true controls (not starting with '_') first, then augmented controls\n    # (starting with '_')\n    true_controls = [control for control in controls if not control.name.startswith(\"_\")]\n    augmented_controls = [control for control in controls if control.name.startswith(\"_\")]\n    sorted_controls = true_controls + augmented_controls\n\n    # Calculate total shape\n    total_shape = sum(control.shape[0] for control in sorted_controls)\n\n    # Concatenate all arrays, handling None values properly\n    min_arrays = []\n    max_arrays = []\n    guess_arrays = []\n\n    for control in sorted_controls:\n        if control.min is not None:\n            min_arrays.append(control.min)\n        else:\n            # If min is None, fill with -inf for this control's dimensions\n            min_arrays.append(np.full(control.shape[0], -np.inf))\n\n        if control.max is not None:\n            max_arrays.append(control.max)\n        else:\n            # If max is None, fill with +inf for this control's dimensions\n            max_arrays.append(np.full(control.shape[0], np.inf))\n\n        if control.guess is not None:\n            guess_arrays.append(control.guess)\n\n    # Concatenate arrays if they exist\n    unified_min = np.concatenate(min_arrays) if min_arrays else None\n    unified_max = np.concatenate(max_arrays) if max_arrays else None\n    unified_guess = np.concatenate(guess_arrays, axis=1) if guess_arrays else None\n\n    # Calculate true dimension (only from user-defined controls, not augmented ones)\n    # Since we simplified State/Control classes, all user controls are \"true\" dimensions\n    true_dim = sum(control.shape[0] for control in true_controls)\n\n    # Find time dilation control slice\n    time_dilation_control = next((c for c in sorted_controls if c.name == \"_time_dilation\"), None)\n    time_dilation_slice = time_dilation_control._slice if time_dilation_control else None\n\n    # Aggregate scaling_min and scaling_max from individual controls\n    # Build full arrays using scaling where available, min/max otherwise\n    unified_scaling_min = None\n    unified_scaling_max = None\n\n    # Check if any control has scaling\n    has_any_scaling = any(\n        control.scaling_min is not None or control.scaling_max is not None\n        for control in sorted_controls\n    )\n\n    if has_any_scaling:\n        # Build full scaling arrays\n        scaling_min_list = []\n        scaling_max_list = []\n        for control in sorted_controls:\n            if control.scaling_min is not None:\n                scaling_min_list.append(control.scaling_min)\n            else:\n                # Use min as fallback\n                if control.min is not None:\n                    scaling_min_list.append(control.min)\n                else:\n                    scaling_min_list.append(np.full(control.shape[0], -np.inf))\n\n            if control.scaling_max is not None:\n                scaling_max_list.append(control.scaling_max)\n            else:\n                # Use max as fallback\n                if control.max is not None:\n                    scaling_max_list.append(control.max)\n                else:\n                    scaling_max_list.append(np.full(control.shape[0], np.inf))\n\n        unified_scaling_min = np.concatenate(scaling_min_list)\n        unified_scaling_max = np.concatenate(scaling_max_list)\n\n    return UnifiedControl(\n        name=name,\n        shape=(total_shape,),\n        min=unified_min,\n        max=unified_max,\n        guess=unified_guess,\n        _true_dim=true_dim,\n        _true_slice=slice(0, true_dim),\n        _augmented_slice=slice(true_dim, total_shape),\n        time_dilation_slice=time_dilation_slice,\n        scaling_min=unified_scaling_min,\n        scaling_max=unified_scaling_max,\n    )\n</code></pre>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.unify_states","title":"<code>unify_states(states: List[State], name: str = 'unified_state') -&gt; UnifiedState</code>","text":"<p>Create a UnifiedState from a list of State objects.</p> <p>This function is the primary way to aggregate multiple symbolic State objects into a single unified state vector for numerical optimization. It:</p> <ol> <li>Sorts states (user-defined first, augmented states second)</li> <li>Concatenates all state properties (bounds, guesses, boundary conditions)</li> <li>Assigns slices to each State for extracting values from unified vector</li> <li>Identifies special states (time, CTCS augmented states)</li> <li>Returns a UnifiedState with all aggregated data</li> </ol> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>List[State]</code> <p>List of State objects to unify. Can include both user-defined states and augmented states (names starting with '_').</p> required <code>name</code> <code>str</code> <p>Name identifier for the unified state vector (default: \"unified_state\")</p> <code>'unified_state'</code> <p>Returns:</p> Name Type Description <code>UnifiedState</code> <code>UnifiedState</code> <p>Unified state object containing: - Aggregated bounds, guesses, and boundary conditions - Shape equal to sum of all state shapes - Slices for extracting individual state components - Properties for accessing true vs augmented states</p> Example <p>Basic unification::</p> <pre><code>import openscvx as ox\nfrom openscvx.symbolic.unified import unify_states\n\nposition = ox.State(\"pos\", shape=(3,), min=-10, max=10)\nvelocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n\nunified = unify_states([position, velocity], name=\"x\")\nprint(unified.shape)       # (6,)\nprint(unified._true_dim)   # 6 (all are user states)\nprint(position._slice)     # slice(0, 3) - assigned during unification\nprint(velocity._slice)     # slice(3, 6)\n</code></pre> <p>With augmented states::</p> <pre><code># CTCS or other features may add augmented states\ntime_state = ox.State(\"time\", shape=(1,))\nctcs_aug = ox.State(\"_ctcs_aug_0\", shape=(2,))  # Augmented state\n\nunified = unify_states([position, velocity, time_state, ctcs_aug])\nprint(unified._true_dim)         # 7 (pos + vel + time)\nprint(unified.true.shape)        # (7,)\nprint(unified.augmented.shape)   # (2,) - only CTCS augmented\n</code></pre> Note <p>After unification, each State object has its <code>_slice</code> attribute set, which is used during JAX lowering to extract the correct values from the unified state vector.</p> See Also <ul> <li>UnifiedState: Return type with detailed documentation</li> <li>unify_controls(): Analogous function for Control objects</li> <li>State: Individual symbolic state variable</li> </ul> Source code in <code>openscvx/symbolic/unified.py</code> <pre><code>def unify_states(states: List[State], name: str = \"unified_state\") -&gt; UnifiedState:\n    \"\"\"Create a UnifiedState from a list of State objects.\n\n    This function is the primary way to aggregate multiple symbolic State objects into\n    a single unified state vector for numerical optimization. It:\n\n    1. Sorts states (user-defined first, augmented states second)\n    2. Concatenates all state properties (bounds, guesses, boundary conditions)\n    3. Assigns slices to each State for extracting values from unified vector\n    4. Identifies special states (time, CTCS augmented states)\n    5. Returns a UnifiedState with all aggregated data\n\n    Args:\n        states (List[State]): List of State objects to unify. Can include both\n            user-defined states and augmented states (names starting with '_').\n        name (str): Name identifier for the unified state vector (default: \"unified_state\")\n\n    Returns:\n        UnifiedState: Unified state object containing:\n            - Aggregated bounds, guesses, and boundary conditions\n            - Shape equal to sum of all state shapes\n            - Slices for extracting individual state components\n            - Properties for accessing true vs augmented states\n\n    Example:\n        Basic unification::\n\n            import openscvx as ox\n            from openscvx.symbolic.unified import unify_states\n\n            position = ox.State(\"pos\", shape=(3,), min=-10, max=10)\n            velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n\n            unified = unify_states([position, velocity], name=\"x\")\n            print(unified.shape)       # (6,)\n            print(unified._true_dim)   # 6 (all are user states)\n            print(position._slice)     # slice(0, 3) - assigned during unification\n            print(velocity._slice)     # slice(3, 6)\n\n        With augmented states::\n\n            # CTCS or other features may add augmented states\n            time_state = ox.State(\"time\", shape=(1,))\n            ctcs_aug = ox.State(\"_ctcs_aug_0\", shape=(2,))  # Augmented state\n\n            unified = unify_states([position, velocity, time_state, ctcs_aug])\n            print(unified._true_dim)         # 7 (pos + vel + time)\n            print(unified.true.shape)        # (7,)\n            print(unified.augmented.shape)   # (2,) - only CTCS augmented\n\n    Note:\n        After unification, each State object has its `_slice` attribute set,\n        which is used during JAX lowering to extract the correct values from\n        the unified state vector.\n\n    See Also:\n        - UnifiedState: Return type with detailed documentation\n        - unify_controls(): Analogous function for Control objects\n        - State: Individual symbolic state variable\n    \"\"\"\n    if not states:\n        return UnifiedState(name=name, shape=(0,))\n\n    # Sort states: true states (not starting with '_') first, then augmented states\n    # (starting with '_')\n    true_states = [state for state in states if not state.name.startswith(\"_\")]\n    augmented_states = [state for state in states if state.name.startswith(\"_\")]\n    sorted_states = true_states + augmented_states\n\n    # Calculate total shape\n    total_shape = sum(state.shape[0] for state in sorted_states)\n\n    # Concatenate all arrays, handling None values properly\n    min_arrays = []\n    max_arrays = []\n    guess_arrays = []\n    initial_arrays = []\n    final_arrays = []\n    _initial_arrays = []\n    _final_arrays = []\n    initial_type_arrays = []\n    final_type_arrays = []\n\n    for state in sorted_states:\n        if state.min is not None:\n            min_arrays.append(state.min)\n        else:\n            # If min is None, fill with -inf for this state's dimensions\n            min_arrays.append(np.full(state.shape[0], -np.inf))\n\n        if state.max is not None:\n            max_arrays.append(state.max)\n        else:\n            # If max is None, fill with +inf for this state's dimensions\n            max_arrays.append(np.full(state.shape[0], np.inf))\n\n        if state.guess is not None:\n            guess_arrays.append(state.guess)\n        if state.initial is not None:\n            initial_arrays.append(state.initial)\n        if state.final is not None:\n            final_arrays.append(state.final)\n        if state._initial is not None:\n            _initial_arrays.append(state._initial)\n        if state._final is not None:\n            _final_arrays.append(state._final)\n        if state.initial_type is not None:\n            initial_type_arrays.append(state.initial_type)\n        else:\n            # If initial_type is None, fill with \"Free\" for this state's dimensions\n            initial_type_arrays.append(np.full(state.shape[0], \"Free\", dtype=object))\n\n        if state.final_type is not None:\n            final_type_arrays.append(state.final_type)\n        else:\n            # If final_type is None, fill with \"Free\" for this state's dimensions\n            final_type_arrays.append(np.full(state.shape[0], \"Free\", dtype=object))\n\n    # Concatenate arrays if they exist\n    unified_min = np.concatenate(min_arrays) if min_arrays else None\n    unified_max = np.concatenate(max_arrays) if max_arrays else None\n    unified_guess = np.concatenate(guess_arrays, axis=1) if guess_arrays else None\n    unified_initial = np.concatenate(initial_arrays) if initial_arrays else None\n    unified_final = np.concatenate(final_arrays) if final_arrays else None\n    unified__initial = np.concatenate(_initial_arrays) if _initial_arrays else None\n    unified__final = np.concatenate(_final_arrays) if _final_arrays else None\n    unified_initial_type = np.concatenate(initial_type_arrays) if initial_type_arrays else None\n    unified_final_type = np.concatenate(final_type_arrays) if final_type_arrays else None\n\n    # Calculate true dimension (only from user-defined states, not augmented ones)\n    # Since we simplified State/Control classes, all user states are \"true\" dimensions\n    true_dim = sum(state.shape[0] for state in true_states)\n\n    # Find time state slice\n    time_state = next((s for s in sorted_states if s.name == \"time\"), None)\n    time_slice = time_state._slice if time_state else None\n\n    # Find CTCS augmented states slice\n    ctcs_states = [s for s in sorted_states if s.name.startswith(\"_ctcs_aug_\")]\n    ctcs_slice = (\n        slice(ctcs_states[0]._slice.start, ctcs_states[-1]._slice.stop) if ctcs_states else None\n    )\n\n    # Aggregate scaling_min and scaling_max from individual states\n    # Build full arrays using scaling where available, min/max otherwise\n    unified_scaling_min = None\n    unified_scaling_max = None\n\n    # Check if any state has scaling\n    has_any_scaling = any(\n        state.scaling_min is not None or state.scaling_max is not None for state in sorted_states\n    )\n\n    if has_any_scaling:\n        # Build full scaling arrays\n        scaling_min_list = []\n        scaling_max_list = []\n        for state in sorted_states:\n            if state.scaling_min is not None:\n                scaling_min_list.append(state.scaling_min)\n            else:\n                # Use min as fallback\n                if state.min is not None:\n                    scaling_min_list.append(state.min)\n                else:\n                    scaling_min_list.append(np.full(state.shape[0], -np.inf))\n\n            if state.scaling_max is not None:\n                scaling_max_list.append(state.scaling_max)\n            else:\n                # Use max as fallback\n                if state.max is not None:\n                    scaling_max_list.append(state.max)\n                else:\n                    scaling_max_list.append(np.full(state.shape[0], np.inf))\n\n        unified_scaling_min = np.concatenate(scaling_min_list)\n        unified_scaling_max = np.concatenate(scaling_max_list)\n\n    return UnifiedState(\n        name=name,\n        shape=(total_shape,),\n        min=unified_min,\n        max=unified_max,\n        guess=unified_guess,\n        initial=unified_initial,\n        final=unified_final,\n        _initial=unified__initial,\n        _final=unified__final,\n        initial_type=unified_initial_type,\n        final_type=unified_final_type,\n        _true_dim=true_dim,\n        _true_slice=slice(0, true_dim),\n        _augmented_slice=slice(true_dim, total_shape),\n        time_slice=time_slice,\n        ctcs_slice=ctcs_slice,\n        scaling_min=unified_scaling_min,\n        scaling_max=unified_scaling_max,\n    )\n</code></pre>"},{"location":"reference/symbolic/expr/","title":"expr","text":"<p>Symbolic expression package for trajectory optimization.</p> <p>This package provides a comprehensive symbolic expression system for building optimization problems in openscvx. It implements an Abstract Syntax Tree (AST) framework that allows you to write optimization problems using natural mathematical notation.</p> Example <p>Import the package through the main openscvx module::</p> <pre><code>import openscvx as ox\n\n# Create symbolic variables\nx = ox.Variable(\"x\", shape=(3,))\nu = ox.Control(\"u\", shape=(2,))\n\n# Build expressions\ncost = ox.Norm(x - [1, 2, 3])**2 + 0.1 * ox.Norm(u)**2\nconstraint = x[0] &lt;= 5.0\n</code></pre> Module Organization <p>The package is organized into the following modules:</p> <p>Core Expressions (expr.py):     Base classes and utilities including <code>Expr</code>, <code>Leaf</code>, <code>Parameter</code>, <code>Constant</code>,     and helper functions <code>to_expr</code> and <code>traverse</code>.</p> <p>Arithmetic Operations (arithmetic.py):     Fundamental arithmetic operations including <code>Add</code>, <code>Sub</code>, <code>Mul</code>, <code>Div</code>,     <code>MatMul</code>, <code>Neg</code>, and <code>Power</code>.</p> <p>Array Operations (array.py):     Array manipulation operations including <code>Index</code>, <code>Concat</code>, <code>Stack</code>, <code>Hstack</code>,     and <code>Vstack</code> for indexing, slicing, and combining arrays.</p> <p>Constraints (constraint.py):     Constraint types including <code>Constraint</code>, <code>Equality</code>, <code>Inequality</code>,     <code>NodalConstraint</code>, and <code>CTCS</code> (Continuous-Time Constraint Satisfaction).</p> <p>Optimization Variables (variable.py, state.py, control.py):     <code>Variable</code> for general optimization variables, <code>State</code> for time-varying state     in trajectory problems, and <code>Control</code> for control inputs.</p> <p>Mathematical Functions (math.py):     Trigonometric functions (<code>Sin</code>, <code>Cos</code>), exponential functions (<code>Exp</code>, <code>Log</code>,     <code>Sqrt</code>, <code>Square</code>), and nonlinear functions (<code>PositivePart</code>, <code>Huber</code>,     <code>SmoothReLU</code>, <code>Max</code>).</p> <p>Linear Algebra (linalg.py):     Matrix operations (<code>Transpose</code>, <code>Diag</code>) and reductions (<code>Sum</code>, <code>Norm</code>).</p> <p>Spatial Operations (spatial.py):     6-DOF operations for aerospace and robotics including <code>QDCM</code> (Quaternion to     Direction Cosine Matrix), <code>SSMP</code> (4\u00d74 skew-symmetric matrix for quaternion     dynamics), and <code>SSM</code> (3\u00d73 skew-symmetric matrix for cross products).</p> <p>Constraint Specifications (constraint.py):     <code>NodalConstraint</code> for enforcing constraints at discrete nodes and <code>CTCS</code> for     continuous-time constraint satisfaction.</p> <p>Signal Temporal Logic (stl.py):     <code>Or</code> for logical disjunction in task specifications.</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Abs","title":"<code>Abs</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise absolute value function for symbolic expressions.</p> <p>Computes the absolute value (|x|) of each element in the operand. Preserves the shape of the input expression. The absolute value function is convex and DCP-compliant in CVXPy.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply absolute value to</p> Example <p>Define an Abs expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\nabs_x = Abs(x)  # Element-wise |x|\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Abs(Expr):\n    \"\"\"Element-wise absolute value function for symbolic expressions.\n\n    Computes the absolute value (|x|) of each element in the operand. Preserves\n    the shape of the input expression. The absolute value function is convex\n    and DCP-compliant in CVXPy.\n\n    Attributes:\n        operand: Expression to apply absolute value to\n\n    Example:\n        Define an Abs expression:\n\n            x = Variable(\"x\", shape=(3,))\n            abs_x = Abs(x)  # Element-wise |x|\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize an absolute value operation.\n\n        Args:\n            operand: Expression to apply absolute value to\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Abs(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Abs preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"abs({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Abs.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Abs preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Abs preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Add","title":"<code>Add</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Addition operation for symbolic expressions.</p> <p>Represents element-wise addition of two or more expressions. Supports broadcasting following NumPy rules. Can be created using the + operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>terms</code> <p>List of expression operands to add together</p> Example <p>Define an Add expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(3,))\nz = x + y + 5  # Creates Add(x, y, Constant(5))\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Add(Expr):\n    \"\"\"Addition operation for symbolic expressions.\n\n    Represents element-wise addition of two or more expressions. Supports broadcasting\n    following NumPy rules. Can be created using the + operator on Expr objects.\n\n    Attributes:\n        terms: List of expression operands to add together\n\n    Example:\n        Define an Add expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(3,))\n            z = x + y + 5  # Creates Add(x, y, Constant(5))\n    \"\"\"\n\n    def __init__(self, *args):\n        \"\"\"Initialize an addition operation.\n\n        Args:\n            *args: Two or more expressions to add together\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(args) &lt; 2:\n            raise ValueError(\"Add requires two or more operands\")\n        self.terms = [to_expr(a) for a in args]\n\n    def children(self):\n        return list(self.terms)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize addition: flatten, fold constants, and eliminate zeros.\n\n        Returns:\n            Expr: Canonical form of the addition expression\n        \"\"\"\n        terms = []\n        const_vals = []\n\n        for t in self.terms:\n            c = t.canonicalize()\n            if isinstance(c, Add):\n                terms.extend(c.terms)\n            elif isinstance(c, Constant):\n                const_vals.append(c.value)\n            else:\n                terms.append(c)\n\n        if const_vals:\n            total = sum(const_vals)\n            # If not all-zero, keep it\n            if not (isinstance(total, np.ndarray) and np.all(total == 0)):\n                terms.append(Constant(total))\n\n        if not terms:\n            return Constant(np.array(0))\n        if len(terms) == 1:\n            return terms[0]\n        return Add(*terms)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n        Returns:\n            tuple: The broadcasted shape of all operands\n\n        Raises:\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Add shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        inner = \" + \".join(repr(e) for e in self.terms)\n        return f\"({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Add.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize addition: flatten, fold constants, and eliminate zeros.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the addition expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize addition: flatten, fold constants, and eliminate zeros.\n\n    Returns:\n        Expr: Canonical form of the addition expression\n    \"\"\"\n    terms = []\n    const_vals = []\n\n    for t in self.terms:\n        c = t.canonicalize()\n        if isinstance(c, Add):\n            terms.extend(c.terms)\n        elif isinstance(c, Constant):\n            const_vals.append(c.value)\n        else:\n            terms.append(c)\n\n    if const_vals:\n        total = sum(const_vals)\n        # If not all-zero, keep it\n        if not (isinstance(total, np.ndarray) and np.all(total == 0)):\n            terms.append(Constant(total))\n\n    if not terms:\n        return Constant(np.array(0))\n    if len(terms) == 1:\n        return terms[0]\n    return Add(*terms)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Add.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check shape compatibility and compute broadcasted result shape like NumPy.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The broadcasted shape of all operands</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n    Returns:\n        tuple: The broadcasted shape of all operands\n\n    Raises:\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Add shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.BoundaryType","title":"<code>BoundaryType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of boundary condition types for state variables.</p> <p>This enum allows users to specify boundary conditions using plain strings while maintaining type safety internally. Boundary conditions control how the optimizer handles initial and final state values.</p> <p>Attributes:</p> Name Type Description <code>FIXED</code> <code>str</code> <p>State value is fixed to a specific value</p> <code>FREE</code> <code>str</code> <p>State value is free to be optimized within bounds</p> <code>MINIMIZE</code> <code>str</code> <p>Objective term to minimize the state value</p> <code>MAXIMIZE</code> <code>str</code> <p>Objective term to maximize the state value</p> Example <p>Can use either enum or string:</p> <pre><code>BoundaryType.FIXED\n\"fixed\"  # Equivalent\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>class BoundaryType(str, Enum):\n    \"\"\"Enumeration of boundary condition types for state variables.\n\n    This enum allows users to specify boundary conditions using plain strings\n    while maintaining type safety internally. Boundary conditions control how\n    the optimizer handles initial and final state values.\n\n    Attributes:\n        FIXED (str): State value is fixed to a specific value\n        FREE (str): State value is free to be optimized within bounds\n        MINIMIZE (str): Objective term to minimize the state value\n        MAXIMIZE (str): Objective term to maximize the state value\n\n    Example:\n        Can use either enum or string:\n\n            BoundaryType.FIXED\n            \"fixed\"  # Equivalent\n    \"\"\"\n\n    FIXED = \"fixed\"\n    FREE = \"free\"\n    MINIMIZE = \"minimize\"\n    MAXIMIZE = \"maximize\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CTCS","title":"<code>CTCS</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Continuous-Time Constraint Satisfaction using augmented state dynamics.</p> <p>CTCS enables strict continuous-time constraint enforcement in discretized trajectory optimization by augmenting the state vector with additional states whose dynamics are the constraint violation penalties. By constraining these augmented states to remain at zero throughout the trajectory, the original constraints are guaranteed to be satisfied continuously, not just at discrete nodes.</p> <p>How it works:</p> <ol> <li>Each constraint (in canonical form: lhs &lt;= 0) is wrapped in a penalty function</li> <li>Augmented states s_aug_i are added with dynamics: ds_aug_i/dt = sum(penalty_j(lhs_j))    for all CTCS constraints j in group i</li> <li>Each augmented state is constrained: s_aug_i(t) = 0 for all t (strictly enforced)</li> <li>Since s_aug_i integrates the penalties, s_aug_i = 0 implies all penalties in the    group are zero, which means all constraints in the group are satisfied continuously</li> </ol> <p>Grouping and augmented states:</p> <ul> <li>CTCS constraints with the same node interval are grouped into a single augmented   state by default (their penalties are summed)</li> <li>CTCS constraints with different node intervals create separate augmented states</li> <li>Using the <code>idx</code> parameter explicitly assigns constraints to specific augmented states,   allowing manual control over grouping</li> <li>Each unique group creates one augmented state named <code>_ctcs_aug_0</code>, <code>_ctcs_aug_1</code>, etc.</li> </ul> <p>This is particularly useful for:</p> <ul> <li>Path constraints that must hold throughout the entire trajectory (not just at nodes)</li> <li>Obstacle avoidance where constraint violation between nodes could be catastrophic</li> <li>State limits that should be respected continuously (e.g., altitude &gt; 0 for aircraft)</li> <li>Ensuring smooth, feasible trajectories between discretization points</li> </ul> <p>Penalty functions (applied to constraint violations):</p> <ul> <li>squared_relu: Square(PositivePart(lhs)) - smooth, differentiable (default)</li> <li>huber: Huber(PositivePart(lhs)) - less sensitive to outliers than squared</li> <li>smooth_relu: SmoothReLU(lhs) - smooth approximation of ReLU</li> </ul> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (typically Inequality) to enforce continuously</p> <code>penalty</code> <p>Penalty function type ('squared_relu', 'huber', or 'smooth_relu')</p> <code>nodes</code> <p>Optional (start, end) tuple specifying the interval for enforcement, or None to enforce over the entire trajectory</p> <code>idx</code> <p>Optional grouping index for managing multiple augmented states. CTCS constraints with the same idx and nodes are grouped together, sharing an augmented state. If None, auto-assigned based on node intervals.</p> <code>check_nodally</code> <p>Whether to also enforce the constraint at discrete nodes for additional numerical robustness (creates both continuous and nodal constraints)</p> Example <p>Single augmented state (default behavior - same node interval):</p> <pre><code>altitude = State(\"alt\", shape=(1,))\nconstraints = [\n    (altitude &gt;= 10).over((0, 10)),  # Both constraints share\n    (altitude &lt;= 1000).over((0, 10))  # one augmented state\n]\n</code></pre> <p>Multiple augmented states (different node intervals):</p> <pre><code>constraints = [\n    (altitude &gt;= 10).over((0, 5)),  # Creates _ctcs_aug_0\n    (altitude &gt;= 20).over((5, 10))  # Creates _ctcs_aug_1\n]\n</code></pre> <p>Manual grouping with idx parameter:</p> <pre><code>constraints = [\n    (altitude &gt;= 10).over((0, 10), idx=0),    # Group 0\n    (velocity &lt;= 100).over((0, 10), idx=1),   # Group 1 (separate state)\n    (altitude &lt;= 1000).over((0, 10), idx=0)   # Also group 0\n]\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class CTCS(Expr):\n    \"\"\"Continuous-Time Constraint Satisfaction using augmented state dynamics.\n\n    CTCS enables strict continuous-time constraint enforcement in discretized trajectory\n    optimization by augmenting the state vector with additional states whose dynamics\n    are the constraint violation penalties. By constraining these augmented states to remain\n    at zero throughout the trajectory, the original constraints are guaranteed to be satisfied\n    continuously, not just at discrete nodes.\n\n    **How it works:**\n\n    1. Each constraint (in canonical form: lhs &lt;= 0) is wrapped in a penalty function\n    2. Augmented states s_aug_i are added with dynamics: ds_aug_i/dt = sum(penalty_j(lhs_j))\n       for all CTCS constraints j in group i\n    3. Each augmented state is constrained: s_aug_i(t) = 0 for all t (strictly enforced)\n    4. Since s_aug_i integrates the penalties, s_aug_i = 0 implies all penalties in the\n       group are zero, which means all constraints in the group are satisfied continuously\n\n    **Grouping and augmented states:**\n\n    - CTCS constraints with the **same node interval** are grouped into a single augmented\n      state by default (their penalties are summed)\n    - CTCS constraints with **different node intervals** create separate augmented states\n    - Using the `idx` parameter explicitly assigns constraints to specific augmented states,\n      allowing manual control over grouping\n    - Each unique group creates one augmented state named `_ctcs_aug_0`, `_ctcs_aug_1`, etc.\n\n    This is particularly useful for:\n\n    - Path constraints that must hold throughout the entire trajectory (not just at nodes)\n    - Obstacle avoidance where constraint violation between nodes could be catastrophic\n    - State limits that should be respected continuously (e.g., altitude &gt; 0 for aircraft)\n    - Ensuring smooth, feasible trajectories between discretization points\n\n    **Penalty functions** (applied to constraint violations):\n\n    - **squared_relu**: Square(PositivePart(lhs)) - smooth, differentiable (default)\n    - **huber**: Huber(PositivePart(lhs)) - less sensitive to outliers than squared\n    - **smooth_relu**: SmoothReLU(lhs) - smooth approximation of ReLU\n\n    Attributes:\n        constraint: The wrapped Constraint (typically Inequality) to enforce continuously\n        penalty: Penalty function type ('squared_relu', 'huber', or 'smooth_relu')\n        nodes: Optional (start, end) tuple specifying the interval for enforcement,\n            or None to enforce over the entire trajectory\n        idx: Optional grouping index for managing multiple augmented states.\n            CTCS constraints with the same idx and nodes are grouped together, sharing\n            an augmented state. If None, auto-assigned based on node intervals.\n        check_nodally: Whether to also enforce the constraint at discrete nodes for\n            additional numerical robustness (creates both continuous and nodal constraints)\n\n    Example:\n        Single augmented state (default behavior - same node interval):\n\n            altitude = State(\"alt\", shape=(1,))\n            constraints = [\n                (altitude &gt;= 10).over((0, 10)),  # Both constraints share\n                (altitude &lt;= 1000).over((0, 10))  # one augmented state\n            ]\n\n        Multiple augmented states (different node intervals):\n\n            constraints = [\n                (altitude &gt;= 10).over((0, 5)),  # Creates _ctcs_aug_0\n                (altitude &gt;= 20).over((5, 10))  # Creates _ctcs_aug_1\n            ]\n\n        Manual grouping with idx parameter:\n\n            constraints = [\n                (altitude &gt;= 10).over((0, 10), idx=0),    # Group 0\n                (velocity &lt;= 100).over((0, 10), idx=1),   # Group 1 (separate state)\n                (altitude &lt;= 1000).over((0, 10), idx=0)   # Also group 0\n            ]\n    \"\"\"\n\n    def __init__(\n        self,\n        constraint: Constraint,\n        penalty: str = \"squared_relu\",\n        nodes: Optional[Tuple[int, int]] = None,\n        idx: Optional[int] = None,\n        check_nodally: bool = False,\n    ):\n        \"\"\"Initialize a CTCS constraint.\n\n        Args:\n            constraint: The Constraint to enforce continuously (typically an Inequality)\n            penalty: Penalty function type. Options:\n                - 'squared_relu': Square(PositivePart(lhs)) - default, smooth, differentiable\n                - 'huber': Huber(PositivePart(lhs)) - robust to outliers\n                - 'smooth_relu': SmoothReLU(lhs) - smooth ReLU approximation\n            nodes: Optional (start, end) tuple of node indices defining the enforcement interval.\n                None means enforce over the entire trajectory. Must satisfy start &lt; end.\n                CTCS constraints with the same nodes are automatically grouped together.\n            idx: Optional grouping index for multiple augmented states. Allows organizing\n                multiple CTCS constraints with separate augmented state variables.\n                If None, constraints are auto-grouped by their node intervals.\n                Explicitly setting idx allows manual control over which constraints\n                share an augmented state.\n            check_nodally: If True, also enforce the constraint at discrete nodes for\n                numerical stability (creates both continuous and nodal constraints).\n                Defaults to False.\n\n        Raises:\n            TypeError: If constraint is not a Constraint instance\n            ValueError: If nodes is not None or a 2-tuple of integers\n            ValueError: If nodes[0] &gt;= nodes[1] (invalid interval)\n        \"\"\"\n        if not isinstance(constraint, Constraint):\n            raise TypeError(\"CTCS must wrap a Constraint\")\n\n        # Validate nodes parameter for CTCS\n        if nodes is not None:\n            if not isinstance(nodes, tuple) or len(nodes) != 2:\n                raise ValueError(\n                    \"CTCS constraints must specify nodes as a tuple of (start, end) or None \"\n                    \"for all nodes\"\n                )\n            if not all(isinstance(n, int) for n in nodes):\n                raise ValueError(\"CTCS node indices must be integers\")\n            if nodes[0] &gt;= nodes[1]:\n                raise ValueError(\"CTCS node range must have start &lt; end\")\n\n        self.constraint = constraint\n        self.penalty = penalty\n        self.nodes = nodes  # (start, end) node range or None for all nodes\n        self.idx = idx  # Optional grouping index for multiple augmented states\n        # Whether to also enforce this constraint nodally for numerical stability\n        self.check_nodally = check_nodally\n\n    def children(self):\n        \"\"\"Return the wrapped constraint as the only child.\n\n        Returns:\n            list: Single-element list containing the wrapped constraint\n        \"\"\"\n        return [self.constraint]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the inner constraint while preserving CTCS parameters.\n\n        Returns:\n            CTCS: A new CTCS with canonicalized inner constraint and same parameters\n        \"\"\"\n        canon_constraint = self.constraint.canonicalize()\n        return CTCS(\n            canon_constraint,\n            penalty=self.penalty,\n            nodes=self.nodes,\n            idx=self.idx,\n            check_nodally=self.check_nodally,\n        )\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Validate the constraint and penalty expression shapes.\n\n        CTCS transforms the wrapped constraint into a penalty expression that is\n        summed (integrated) over the trajectory, always producing a scalar result.\n\n        Returns:\n            tuple: Empty tuple () representing scalar shape\n\n        Raises:\n            ValueError: If the wrapped constraint has invalid shape\n            ValueError: If the generated penalty expression is not scalar\n        \"\"\"\n        # First validate the wrapped constraint's shape\n        self.constraint.check_shape()\n\n        # Also validate the penalty expression that would be generated\n        try:\n            penalty_expr = self.penalty_expr()\n            penalty_shape = penalty_expr.check_shape()\n\n            # The penalty expression should always be scalar due to Sum wrapper\n            if penalty_shape != ():\n                raise ValueError(\n                    f\"CTCS penalty expression should be scalar, but got shape {penalty_shape}\"\n                )\n        except Exception as e:\n            # Re-raise with more context about which CTCS node failed\n            raise ValueError(f\"CTCS penalty expression validation failed: {e}\") from e\n\n        # CTCS always produces a scalar due to the Sum in penalty_expr\n        return ()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash CTCS including all its parameters.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"CTCS\")\n        # Hash penalty type\n        hasher.update(self.penalty.encode())\n        # Hash nodes interval\n        if self.nodes is not None:\n            hasher.update(struct.pack(\"&gt;ii\", self.nodes[0], self.nodes[1]))\n        else:\n            hasher.update(b\"None\")\n        # Hash idx\n        if self.idx is not None:\n            hasher.update(struct.pack(\"&gt;i\", self.idx))\n        else:\n            hasher.update(b\"None\")\n        # Hash check_nodally\n        hasher.update(b\"1\" if self.check_nodally else b\"0\")\n        # Hash the wrapped constraint\n        self.constraint._hash_into(hasher)\n\n    def over(self, interval: tuple[int, int]) -&gt; \"CTCS\":\n        \"\"\"Set or update the continuous interval for this CTCS constraint.\n\n        Args:\n            interval: Tuple of (start, end) node indices defining the enforcement interval\n\n        Returns:\n            CTCS: New CTCS constraint with the specified interval\n\n        Example:\n            Define constraint over range:\n\n                constraint = (altitude &gt;= 10).over((0, 50))\n\n            Update interval to cover different range:\n\n                constraint_updated = constraint.over((50, 100))\n        \"\"\"\n        return CTCS(\n            self.constraint,\n            penalty=self.penalty,\n            nodes=interval,\n            idx=self.idx,\n            check_nodally=self.check_nodally,\n        )\n\n    def __repr__(self):\n        \"\"\"String representation of the CTCS constraint.\n\n        Returns:\n            str: String showing constraint, penalty type, and optional parameters\n        \"\"\"\n        parts = [f\"{self.constraint!r}\", f\"penalty={self.penalty!r}\"]\n        if self.nodes is not None:\n            parts.append(f\"nodes={self.nodes}\")\n        if self.idx is not None:\n            parts.append(f\"idx={self.idx}\")\n        if self.check_nodally:\n            parts.append(f\"check_nodally={self.check_nodally}\")\n        return f\"CTCS({', '.join(parts)})\"\n\n    def penalty_expr(self) -&gt; Expr:\n        \"\"\"Build the penalty expression for this CTCS constraint.\n\n        Transforms the constraint's left-hand side (in canonical form: lhs &lt;= 0)\n        into a penalty expression using the specified penalty function. The penalty\n        is zero when the constraint is satisfied and positive when violated.\n\n        This penalty expression becomes part of the dynamics of an augmented state.\n        Multiple CTCS constraints in the same group (same idx) have their penalties\n        summed: ds_aug_i/dt = sum(penalty_j) for all j in group i. By constraining\n        s_aug_i(t) = 0 for all t, we ensure all penalties in the group are zero,\n        which strictly enforces all constraints in the group continuously.\n\n        Returns:\n            Expr: Sum of the penalty function applied to the constraint violation\n\n        Raises:\n            ValueError: If an unknown penalty type is specified\n\n        Note:\n            This method is used internally during problem compilation to create\n            augmented state dynamics. Multiple penalty expressions with the same\n            idx are summed together before being added to the dynamics vector via Concat.\n        \"\"\"\n        lhs = self.constraint.lhs\n\n        if self.penalty == \"squared_relu\":\n            from openscvx.symbolic.expr.math import PositivePart, Square\n\n            penalty = Square(PositivePart(lhs))\n        elif self.penalty == \"huber\":\n            from openscvx.symbolic.expr.math import Huber, PositivePart\n\n            penalty = Huber(PositivePart(lhs))\n        elif self.penalty == \"smooth_relu\":\n            from openscvx.symbolic.expr.math import SmoothReLU\n\n            penalty = SmoothReLU(lhs)\n        else:\n            raise ValueError(f\"Unknown penalty {self.penalty!r}\")\n\n        return Sum(penalty)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CTCS._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash CTCS including all its parameters.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash CTCS including all its parameters.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(b\"CTCS\")\n    # Hash penalty type\n    hasher.update(self.penalty.encode())\n    # Hash nodes interval\n    if self.nodes is not None:\n        hasher.update(struct.pack(\"&gt;ii\", self.nodes[0], self.nodes[1]))\n    else:\n        hasher.update(b\"None\")\n    # Hash idx\n    if self.idx is not None:\n        hasher.update(struct.pack(\"&gt;i\", self.idx))\n    else:\n        hasher.update(b\"None\")\n    # Hash check_nodally\n    hasher.update(b\"1\" if self.check_nodally else b\"0\")\n    # Hash the wrapped constraint\n    self.constraint._hash_into(hasher)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CTCS.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the inner constraint while preserving CTCS parameters.</p> <p>Returns:</p> Name Type Description <code>CTCS</code> <code>Expr</code> <p>A new CTCS with canonicalized inner constraint and same parameters</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the inner constraint while preserving CTCS parameters.\n\n    Returns:\n        CTCS: A new CTCS with canonicalized inner constraint and same parameters\n    \"\"\"\n    canon_constraint = self.constraint.canonicalize()\n    return CTCS(\n        canon_constraint,\n        penalty=self.penalty,\n        nodes=self.nodes,\n        idx=self.idx,\n        check_nodally=self.check_nodally,\n    )\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CTCS.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the constraint and penalty expression shapes.</p> <p>CTCS transforms the wrapped constraint into a penalty expression that is summed (integrated) over the trajectory, always producing a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the wrapped constraint has invalid shape</p> <code>ValueError</code> <p>If the generated penalty expression is not scalar</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Validate the constraint and penalty expression shapes.\n\n    CTCS transforms the wrapped constraint into a penalty expression that is\n    summed (integrated) over the trajectory, always producing a scalar result.\n\n    Returns:\n        tuple: Empty tuple () representing scalar shape\n\n    Raises:\n        ValueError: If the wrapped constraint has invalid shape\n        ValueError: If the generated penalty expression is not scalar\n    \"\"\"\n    # First validate the wrapped constraint's shape\n    self.constraint.check_shape()\n\n    # Also validate the penalty expression that would be generated\n    try:\n        penalty_expr = self.penalty_expr()\n        penalty_shape = penalty_expr.check_shape()\n\n        # The penalty expression should always be scalar due to Sum wrapper\n        if penalty_shape != ():\n            raise ValueError(\n                f\"CTCS penalty expression should be scalar, but got shape {penalty_shape}\"\n            )\n    except Exception as e:\n        # Re-raise with more context about which CTCS node failed\n        raise ValueError(f\"CTCS penalty expression validation failed: {e}\") from e\n\n    # CTCS always produces a scalar due to the Sum in penalty_expr\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CTCS.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def children(self):\n    \"\"\"Return the wrapped constraint as the only child.\n\n    Returns:\n        list: Single-element list containing the wrapped constraint\n    \"\"\"\n    return [self.constraint]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CTCS.over","title":"<code>over(interval: tuple[int, int]) -&gt; CTCS</code>","text":"<p>Set or update the continuous interval for this CTCS constraint.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>tuple[int, int]</code> <p>Tuple of (start, end) node indices defining the enforcement interval</p> required <p>Returns:</p> Name Type Description <code>CTCS</code> <code>CTCS</code> <p>New CTCS constraint with the specified interval</p> Example <p>Define constraint over range:</p> <pre><code>constraint = (altitude &gt;= 10).over((0, 50))\n</code></pre> <p>Update interval to cover different range:</p> <pre><code>constraint_updated = constraint.over((50, 100))\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def over(self, interval: tuple[int, int]) -&gt; \"CTCS\":\n    \"\"\"Set or update the continuous interval for this CTCS constraint.\n\n    Args:\n        interval: Tuple of (start, end) node indices defining the enforcement interval\n\n    Returns:\n        CTCS: New CTCS constraint with the specified interval\n\n    Example:\n        Define constraint over range:\n\n            constraint = (altitude &gt;= 10).over((0, 50))\n\n        Update interval to cover different range:\n\n            constraint_updated = constraint.over((50, 100))\n    \"\"\"\n    return CTCS(\n        self.constraint,\n        penalty=self.penalty,\n        nodes=interval,\n        idx=self.idx,\n        check_nodally=self.check_nodally,\n    )\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CTCS.penalty_expr","title":"<code>penalty_expr() -&gt; Expr</code>","text":"<p>Build the penalty expression for this CTCS constraint.</p> <p>Transforms the constraint's left-hand side (in canonical form: lhs &lt;= 0) into a penalty expression using the specified penalty function. The penalty is zero when the constraint is satisfied and positive when violated.</p> <p>This penalty expression becomes part of the dynamics of an augmented state. Multiple CTCS constraints in the same group (same idx) have their penalties summed: ds_aug_i/dt = sum(penalty_j) for all j in group i. By constraining s_aug_i(t) = 0 for all t, we ensure all penalties in the group are zero, which strictly enforces all constraints in the group continuously.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Sum of the penalty function applied to the constraint violation</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown penalty type is specified</p> Note <p>This method is used internally during problem compilation to create augmented state dynamics. Multiple penalty expressions with the same idx are summed together before being added to the dynamics vector via Concat.</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def penalty_expr(self) -&gt; Expr:\n    \"\"\"Build the penalty expression for this CTCS constraint.\n\n    Transforms the constraint's left-hand side (in canonical form: lhs &lt;= 0)\n    into a penalty expression using the specified penalty function. The penalty\n    is zero when the constraint is satisfied and positive when violated.\n\n    This penalty expression becomes part of the dynamics of an augmented state.\n    Multiple CTCS constraints in the same group (same idx) have their penalties\n    summed: ds_aug_i/dt = sum(penalty_j) for all j in group i. By constraining\n    s_aug_i(t) = 0 for all t, we ensure all penalties in the group are zero,\n    which strictly enforces all constraints in the group continuously.\n\n    Returns:\n        Expr: Sum of the penalty function applied to the constraint violation\n\n    Raises:\n        ValueError: If an unknown penalty type is specified\n\n    Note:\n        This method is used internally during problem compilation to create\n        augmented state dynamics. Multiple penalty expressions with the same\n        idx are summed together before being added to the dynamics vector via Concat.\n    \"\"\"\n    lhs = self.constraint.lhs\n\n    if self.penalty == \"squared_relu\":\n        from openscvx.symbolic.expr.math import PositivePart, Square\n\n        penalty = Square(PositivePart(lhs))\n    elif self.penalty == \"huber\":\n        from openscvx.symbolic.expr.math import Huber, PositivePart\n\n        penalty = Huber(PositivePart(lhs))\n    elif self.penalty == \"smooth_relu\":\n        from openscvx.symbolic.expr.math import SmoothReLU\n\n        penalty = SmoothReLU(lhs)\n    else:\n        raise ValueError(f\"Unknown penalty {self.penalty!r}\")\n\n    return Sum(penalty)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Concat","title":"<code>Concat</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Concatenation operation for symbolic expressions.</p> <p>Concatenates a sequence of expressions along their first dimension. All inputs must have the same rank and matching dimensions except for the first dimension.</p> <p>Attributes:</p> Name Type Description <code>exprs</code> <p>Tuple of expressions to concatenate</p> Example <p>Define a Concat expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(4,))\nz = Concat(x, y)  # Creates Concat(x, y), result shape (7,)\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Concat(Expr):\n    \"\"\"Concatenation operation for symbolic expressions.\n\n    Concatenates a sequence of expressions along their first dimension. All inputs\n    must have the same rank and matching dimensions except for the first dimension.\n\n    Attributes:\n        exprs: Tuple of expressions to concatenate\n\n    Example:\n        Define a Concat expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(4,))\n            z = Concat(x, y)  # Creates Concat(x, y), result shape (7,)\n    \"\"\"\n\n    def __init__(self, *exprs: Expr):\n        \"\"\"Initialize a concatenation operation.\n\n        Args:\n            *exprs: Expressions to concatenate along the first dimension\n        \"\"\"\n        # wrap raw values as Constant if needed\n        self.exprs = [to_expr(e) for e in exprs]\n\n    def children(self):\n        return list(self.exprs)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize concatenation by canonicalizing all operands.\n\n        Returns:\n            Expr: Canonical form of the concatenation expression\n        \"\"\"\n        exprs = [e.canonicalize() for e in self.exprs]\n        return Concat(*exprs)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check concatenation shape compatibility and return result shape.\"\"\"\n        shapes = [e.check_shape() for e in self.exprs]\n        shapes = [(1,) if len(s) == 0 else s for s in shapes]\n        rank = len(shapes[0])\n        if any(len(s) != rank for s in shapes):\n            raise ValueError(f\"Concat rank mismatch: {shapes}\")\n        if any(s[1:] != shapes[0][1:] for s in shapes[1:]):\n            raise ValueError(f\"Concat non-0 dims differ: {shapes}\")\n        return (sum(s[0] for s in shapes),) + shapes[0][1:]\n\n    def __repr__(self):\n        inner = \", \".join(repr(e) for e in self.exprs)\n        return f\"Concat({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Concat.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize concatenation by canonicalizing all operands.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the concatenation expression</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize concatenation by canonicalizing all operands.\n\n    Returns:\n        Expr: Canonical form of the concatenation expression\n    \"\"\"\n    exprs = [e.canonicalize() for e in self.exprs]\n    return Concat(*exprs)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Concat.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check concatenation shape compatibility and return result shape.</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check concatenation shape compatibility and return result shape.\"\"\"\n    shapes = [e.check_shape() for e in self.exprs]\n    shapes = [(1,) if len(s) == 0 else s for s in shapes]\n    rank = len(shapes[0])\n    if any(len(s) != rank for s in shapes):\n        raise ValueError(f\"Concat rank mismatch: {shapes}\")\n    if any(s[1:] != shapes[0][1:] for s in shapes[1:]):\n        raise ValueError(f\"Concat non-0 dims differ: {shapes}\")\n    return (sum(s[0] for s in shapes),) + shapes[0][1:]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constant","title":"<code>Constant</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Constant value expression.</p> <p>Represents a constant numeric value in the expression tree. Constants are automatically normalized (squeezed) upon construction to ensure consistency.</p> <p>Attributes:</p> Name Type Description <code>value</code> <p>The numpy array representing the constant value (squeezed)</p> Example <p>Define constants:</p> <pre><code>c1 = Constant(5.0)        # Scalar constant\nc2 = Constant([1, 2, 3])  # Vector constant\nc3 = to_expr(10)          # Also creates a Constant\n</code></pre> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class Constant(Expr):\n    \"\"\"Constant value expression.\n\n    Represents a constant numeric value in the expression tree. Constants are\n    automatically normalized (squeezed) upon construction to ensure consistency.\n\n    Attributes:\n        value: The numpy array representing the constant value (squeezed)\n\n    Example:\n        Define constants:\n\n            c1 = Constant(5.0)        # Scalar constant\n            c2 = Constant([1, 2, 3])  # Vector constant\n            c3 = to_expr(10)          # Also creates a Constant\n    \"\"\"\n\n    def __init__(self, value: np.ndarray):\n        \"\"\"Initialize a constant expression.\n\n        Args:\n            value: Numeric value or numpy array to wrap as a constant.\n                   Will be converted to numpy array and squeezed.\n        \"\"\"\n        # Normalize immediately upon construction to ensure consistency\n        # This ensures Constant(5.0) and Constant([5.0]) create identical objects\n        if not isinstance(value, np.ndarray):\n            value = np.array(value, dtype=float)\n        self.value = np.squeeze(value)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Constants are already in canonical form.\n\n        Returns:\n            Expr: Returns self since constants are already canonical\n        \"\"\"\n        return self\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Return the shape of this constant's value.\n\n        Returns:\n            tuple: The shape of the constant's numpy array value\n        \"\"\"\n        # Verify the invariant: constants should already be squeezed during construction\n        original_shape = self.value.shape\n        squeezed_shape = np.squeeze(self.value).shape\n        if original_shape != squeezed_shape:\n            raise ValueError(\n                f\"Constant not properly normalized: has shape {original_shape} \"\n                \"but should have shape {squeezed_shape}. \"\n                \"Constants should be squeezed during construction.\"\n            )\n        return self.value.shape\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash constant by its value.\n\n        Constants are hashed by their actual numeric value, ensuring that\n        expressions with the same constant values produce the same hash.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Constant\")\n        hasher.update(str(self.value.shape).encode())\n        hasher.update(self.value.tobytes())\n\n    def __repr__(self):\n        # Show clean representation - always show as Python values, not numpy arrays\n        if self.value.ndim == 0:\n            # Scalar: show as plain number\n            return f\"Const({self.value.item()!r})\"\n        else:\n            # Array: show as Python list for readability\n            return f\"Const({self.value.tolist()!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constant._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash constant by its value.</p> <p>Constants are hashed by their actual numeric value, ensuring that expressions with the same constant values produce the same hash.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash constant by its value.\n\n    Constants are hashed by their actual numeric value, ensuring that\n    expressions with the same constant values produce the same hash.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(b\"Constant\")\n    hasher.update(str(self.value.shape).encode())\n    hasher.update(self.value.tobytes())\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constant.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Constants are already in canonical form.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Returns self since constants are already canonical</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Constants are already in canonical form.\n\n    Returns:\n        Expr: Returns self since constants are already canonical\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constant.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Return the shape of this constant's value.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The shape of the constant's numpy array value</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Return the shape of this constant's value.\n\n    Returns:\n        tuple: The shape of the constant's numpy array value\n    \"\"\"\n    # Verify the invariant: constants should already be squeezed during construction\n    original_shape = self.value.shape\n    squeezed_shape = np.squeeze(self.value).shape\n    if original_shape != squeezed_shape:\n        raise ValueError(\n            f\"Constant not properly normalized: has shape {original_shape} \"\n            \"but should have shape {squeezed_shape}. \"\n            \"Constants should be squeezed during construction.\"\n        )\n    return self.value.shape\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constraint","title":"<code>Constraint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Abstract base class for optimization constraints.</p> <p>Constraints represent relationships between expressions that must be satisfied in the optimization problem. This base class provides common functionality for both equality and inequality constraints.</p> <p>Attributes:</p> Name Type Description <code>lhs</code> <p>Left-hand side expression</p> <code>rhs</code> <p>Right-hand side expression</p> <code>is_convex</code> <p>Flag indicating if the constraint is known to be convex</p> Note <p>Constraints are canonicalized to standard form: (lhs - rhs) {op} 0</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class Constraint(Expr):\n    \"\"\"Abstract base class for optimization constraints.\n\n    Constraints represent relationships between expressions that must be satisfied\n    in the optimization problem. This base class provides common functionality for\n    both equality and inequality constraints.\n\n    Attributes:\n        lhs: Left-hand side expression\n        rhs: Right-hand side expression\n        is_convex: Flag indicating if the constraint is known to be convex\n\n    Note:\n        Constraints are canonicalized to standard form: (lhs - rhs) {op} 0\n    \"\"\"\n\n    def __init__(self, lhs: Expr, rhs: Expr):\n        \"\"\"Initialize a constraint.\n\n        Args:\n            lhs: Left-hand side expression\n            rhs: Right-hand side expression\n        \"\"\"\n        self.lhs = lhs\n        self.rhs = rhs\n        self.is_convex = False\n\n    def children(self):\n        return [self.lhs, self.rhs]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize constraint to standard form: (lhs - rhs) {op} 0.\n\n        This works for both Equality and Inequality by using type(self) to\n        construct the appropriate subclass type.\n        \"\"\"\n        diff = Sub(self.lhs, self.rhs)\n        canon_diff = diff.canonicalize()\n        new_constraint = type(self)(canon_diff, Constant(np.array(0)))\n        new_constraint.is_convex = self.is_convex  # Preserve convex flag\n        return new_constraint\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that constraint operands are broadcastable. Returns scalar shape.\"\"\"\n        L_shape = self.lhs.check_shape()\n        R_shape = self.rhs.check_shape()\n\n        # Figure out their broadcasted shape (or error if incompatible)\n        try:\n            np.broadcast_shapes(L_shape, R_shape)\n        except ValueError as e:\n            constraint_type = type(self).__name__\n            raise ValueError(f\"{constraint_type} not broadcastable: {L_shape} vs {R_shape}\") from e\n\n        # Allow vector constraints - they're interpreted element-wise\n        # Return () as constraints always produce a scalar\n        return ()\n\n    def at(self, nodes: Union[list, tuple]):\n        \"\"\"Apply this constraint only at specific discrete nodes.\n\n        Args:\n            nodes: List of node indices where the constraint should be enforced\n\n        Returns:\n            NodalConstraint wrapping this constraint with node specification\n        \"\"\"\n        if isinstance(nodes, int):\n            nodes = [nodes]\n        return NodalConstraint(self, list(nodes))\n\n    def over(\n        self,\n        interval: tuple[int, int],\n        penalty: str = \"squared_relu\",\n        idx: Optional[int] = None,\n        check_nodally: bool = False,\n    ):\n        \"\"\"Apply this constraint over a continuous interval using CTCS.\n\n        Args:\n            interval: Tuple of (start, end) node indices for the continuous interval\n            penalty: Penalty function type (\"squared_relu\", \"huber\", \"smooth_relu\")\n            idx: Optional grouping index for multiple augmented states\n            check_nodally: Whether to also enforce this constraint nodally\n\n        Returns:\n            CTCS constraint wrapping this constraint with interval specification\n        \"\"\"\n        return CTCS(self, penalty=penalty, nodes=interval, idx=idx, check_nodally=check_nodally)\n\n    def convex(self) -&gt; \"Constraint\":\n        \"\"\"Mark this constraint as convex for CVXPy lowering.\n\n        Returns:\n            Self with convex flag set to True (enables method chaining)\n        \"\"\"\n        self.is_convex = True\n        return self\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constraint.at","title":"<code>at(nodes: Union[list, tuple])</code>","text":"<p>Apply this constraint only at specific discrete nodes.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>Union[list, tuple]</code> <p>List of node indices where the constraint should be enforced</p> required <p>Returns:</p> Type Description <p>NodalConstraint wrapping this constraint with node specification</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def at(self, nodes: Union[list, tuple]):\n    \"\"\"Apply this constraint only at specific discrete nodes.\n\n    Args:\n        nodes: List of node indices where the constraint should be enforced\n\n    Returns:\n        NodalConstraint wrapping this constraint with node specification\n    \"\"\"\n    if isinstance(nodes, int):\n        nodes = [nodes]\n    return NodalConstraint(self, list(nodes))\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constraint.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize constraint to standard form: (lhs - rhs) {op} 0.</p> <p>This works for both Equality and Inequality by using type(self) to construct the appropriate subclass type.</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize constraint to standard form: (lhs - rhs) {op} 0.\n\n    This works for both Equality and Inequality by using type(self) to\n    construct the appropriate subclass type.\n    \"\"\"\n    diff = Sub(self.lhs, self.rhs)\n    canon_diff = diff.canonicalize()\n    new_constraint = type(self)(canon_diff, Constant(np.array(0)))\n    new_constraint.is_convex = self.is_convex  # Preserve convex flag\n    return new_constraint\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constraint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that constraint operands are broadcastable. Returns scalar shape.</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that constraint operands are broadcastable. Returns scalar shape.\"\"\"\n    L_shape = self.lhs.check_shape()\n    R_shape = self.rhs.check_shape()\n\n    # Figure out their broadcasted shape (or error if incompatible)\n    try:\n        np.broadcast_shapes(L_shape, R_shape)\n    except ValueError as e:\n        constraint_type = type(self).__name__\n        raise ValueError(f\"{constraint_type} not broadcastable: {L_shape} vs {R_shape}\") from e\n\n    # Allow vector constraints - they're interpreted element-wise\n    # Return () as constraints always produce a scalar\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constraint.convex","title":"<code>convex() -&gt; Constraint</code>","text":"<p>Mark this constraint as convex for CVXPy lowering.</p> <p>Returns:</p> Type Description <code>Constraint</code> <p>Self with convex flag set to True (enables method chaining)</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def convex(self) -&gt; \"Constraint\":\n    \"\"\"Mark this constraint as convex for CVXPy lowering.\n\n    Returns:\n        Self with convex flag set to True (enables method chaining)\n    \"\"\"\n    self.is_convex = True\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constraint.over","title":"<code>over(interval: tuple[int, int], penalty: str = 'squared_relu', idx: Optional[int] = None, check_nodally: bool = False)</code>","text":"<p>Apply this constraint over a continuous interval using CTCS.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>tuple[int, int]</code> <p>Tuple of (start, end) node indices for the continuous interval</p> required <code>penalty</code> <code>str</code> <p>Penalty function type (\"squared_relu\", \"huber\", \"smooth_relu\")</p> <code>'squared_relu'</code> <code>idx</code> <code>Optional[int]</code> <p>Optional grouping index for multiple augmented states</p> <code>None</code> <code>check_nodally</code> <code>bool</code> <p>Whether to also enforce this constraint nodally</p> <code>False</code> <p>Returns:</p> Type Description <p>CTCS constraint wrapping this constraint with interval specification</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def over(\n    self,\n    interval: tuple[int, int],\n    penalty: str = \"squared_relu\",\n    idx: Optional[int] = None,\n    check_nodally: bool = False,\n):\n    \"\"\"Apply this constraint over a continuous interval using CTCS.\n\n    Args:\n        interval: Tuple of (start, end) node indices for the continuous interval\n        penalty: Penalty function type (\"squared_relu\", \"huber\", \"smooth_relu\")\n        idx: Optional grouping index for multiple augmented states\n        check_nodally: Whether to also enforce this constraint nodally\n\n    Returns:\n        CTCS constraint wrapping this constraint with interval specification\n    \"\"\"\n    return CTCS(self, penalty=penalty, nodes=interval, idx=idx, check_nodally=check_nodally)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Control","title":"<code>Control</code>","text":"<p>               Bases: <code>Variable</code></p> <p>Control input variable for trajectory optimization problems.</p> <p>Control represents control input variables (actuator commands) in a trajectory optimization problem. Unlike State variables which evolve according to dynamics, Controls are direct decision variables that the optimizer can freely adjust (within specified bounds) at each time step to influence the system dynamics.</p> <p>Controls are conceptually similar to State variables but simpler - they don't have boundary conditions (initial/final specifications) since controls are typically not constrained at the endpoints. Like States, Controls support:</p> <ul> <li>Min/max bounds to enforce actuator limits</li> <li>Initial trajectory guesses to help the optimizer converge</li> </ul> <p>Common examples of control inputs include:</p> <ul> <li>Thrust magnitude and direction for spacecraft/rockets</li> <li>Throttle settings for engines</li> <li>Steering angles for vehicles</li> <li>Torques for robotic manipulators</li> <li>Force/acceleration commands</li> </ul> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name identifier for this control variable</p> <code>_shape</code> <code>tuple[int, ...]</code> <p>Shape of the control vector (typically 1D like (3,) for 3D thrust)</p> <code>_slice</code> <code>slice | None</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <code>ndarray | None</code> <p>Minimum bounds for each element of the control</p> <code>_max</code> <code>ndarray | None</code> <p>Maximum bounds for each element of the control</p> <code>_guess</code> <code>ndarray | None</code> <p>Initial guess for the control trajectory (n_points, n_controls)</p> Example <p>Scalar throttle control bounded [0, 1]:</p> <pre><code>throttle = Control(\"throttle\", shape=(1,))\nthrottle.min = [0.0]\nthrottle.max = [1.0]\nthrottle.guess = np.full((50, 1), 0.5)  # Start at 50% throttle\n</code></pre> <p>3D thrust vector for spacecraft:</p> <pre><code>thrust = Control(\"thrust\", shape=(3,))\nthrust.min = [-10, -10, 0]    # No downward thrust\nthrust.max = [10, 10, 50]     # Limited thrust\nthrust.guess = np.zeros((50, 3))  # Initialize with zero thrust\n</code></pre> <p>2D steering control (left/right, forward/backward):</p> <pre><code>steer = Control(\"steer\", shape=(2,))\nsteer.min = [-1, -1]\nsteer.max = [1, 1]\nsteer.guess = np.linspace([0, 0], [0, 1], 50)  # Gradual acceleration\n</code></pre> Source code in <code>openscvx/symbolic/expr/control.py</code> <pre><code>class Control(Variable):\n    \"\"\"Control input variable for trajectory optimization problems.\n\n    Control represents control input variables (actuator commands) in a trajectory\n    optimization problem. Unlike State variables which evolve according to dynamics,\n    Controls are direct decision variables that the optimizer can freely adjust\n    (within specified bounds) at each time step to influence the system dynamics.\n\n    Controls are conceptually similar to State variables but simpler - they don't\n    have boundary conditions (initial/final specifications) since controls are\n    typically not constrained at the endpoints. Like States, Controls support:\n\n    - Min/max bounds to enforce actuator limits\n    - Initial trajectory guesses to help the optimizer converge\n\n    Common examples of control inputs include:\n\n    - Thrust magnitude and direction for spacecraft/rockets\n    - Throttle settings for engines\n    - Steering angles for vehicles\n    - Torques for robotic manipulators\n    - Force/acceleration commands\n\n    Attributes:\n        name (str): Unique name identifier for this control variable\n        _shape (tuple[int, ...]): Shape of the control vector (typically 1D like (3,) for 3D thrust)\n        _slice (slice | None): Internal slice information for variable indexing\n        _min (np.ndarray | None): Minimum bounds for each element of the control\n        _max (np.ndarray | None): Maximum bounds for each element of the control\n        _guess (np.ndarray | None): Initial guess for the control trajectory (n_points, n_controls)\n\n    Example:\n        Scalar throttle control bounded [0, 1]:\n\n            throttle = Control(\"throttle\", shape=(1,))\n            throttle.min = [0.0]\n            throttle.max = [1.0]\n            throttle.guess = np.full((50, 1), 0.5)  # Start at 50% throttle\n\n        3D thrust vector for spacecraft:\n\n            thrust = Control(\"thrust\", shape=(3,))\n            thrust.min = [-10, -10, 0]    # No downward thrust\n            thrust.max = [10, 10, 50]     # Limited thrust\n            thrust.guess = np.zeros((50, 3))  # Initialize with zero thrust\n\n        2D steering control (left/right, forward/backward):\n\n            steer = Control(\"steer\", shape=(2,))\n            steer.min = [-1, -1]\n            steer.max = [1, 1]\n            steer.guess = np.linspace([0, 0], [0, 1], 50)  # Gradual acceleration\n    \"\"\"\n\n    def __init__(self, name, shape):\n        \"\"\"Initialize a Control object.\n\n        Args:\n            name: Name identifier for the control variable\n            shape: Shape of the control vector (typically 1D tuple like (3,))\n        \"\"\"\n        super().__init__(name, shape)\n        self._scaling_min = None\n        self._scaling_max = None\n\n    @property\n    def scaling_min(self):\n        \"\"\"Get the scaling minimum bounds for the control variables.\n\n        Returns:\n            Array of scaling minimum values for each control variable element, or None if not set.\n        \"\"\"\n        return self._scaling_min\n\n    @scaling_min.setter\n    def scaling_min(self, val):\n        \"\"\"Set the scaling minimum bounds for the control variables.\n\n        Args:\n            val: Array of scaling minimum values, must match the control shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the control shape\n        \"\"\"\n        if val is None:\n            self._scaling_min = None\n            return\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(\n                f\"Scaling min shape {val.shape} does not match Control shape {self.shape}\"\n            )\n        self._scaling_min = val\n\n    @property\n    def scaling_max(self):\n        \"\"\"Get the scaling maximum bounds for the control variables.\n\n        Returns:\n            Array of scaling maximum values for each control variable element, or None if not set.\n        \"\"\"\n        return self._scaling_max\n\n    @scaling_max.setter\n    def scaling_max(self, val):\n        \"\"\"Set the scaling maximum bounds for the control variables.\n\n        Args:\n            val: Array of scaling maximum values, must match the control shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the control shape\n        \"\"\"\n        if val is None:\n            self._scaling_max = None\n            return\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(\n                f\"Scaling max shape {val.shape} does not match Control shape {self.shape}\"\n            )\n        self._scaling_max = val\n\n    def __repr__(self):\n        \"\"\"String representation of the Control object.\n\n        Returns:\n            Concise string showing the control name and shape.\n        \"\"\"\n        return f\"Control('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Control.scaling_max","title":"<code>scaling_max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling maximum bounds for the control variables.</p> <p>Returns:</p> Type Description <p>Array of scaling maximum values for each control variable element, or None if not set.</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Control.scaling_min","title":"<code>scaling_min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling minimum bounds for the control variables.</p> <p>Returns:</p> Type Description <p>Array of scaling minimum values for each control variable element, or None if not set.</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Cos","title":"<code>Cos</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise cosine function for symbolic expressions.</p> <p>Computes the cosine of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply cosine function to</p> Example <p>Define a Cos expression:</p> <pre><code>theta = Variable(\"theta\", shape=(3,))\ncos_theta = Cos(theta)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Cos(Expr):\n    \"\"\"Element-wise cosine function for symbolic expressions.\n\n    Computes the cosine of each element in the operand. Preserves the shape\n    of the input expression.\n\n    Attributes:\n        operand: Expression to apply cosine function to\n\n    Example:\n        Define a Cos expression:\n\n            theta = Variable(\"theta\", shape=(3,))\n            cos_theta = Cos(theta)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a cosine operation.\n\n        Args:\n            operand: Expression to apply cosine function to\n        \"\"\"\n        self.operand = operand\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Cos(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Cos preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"(cos({self.operand!r}))\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Cos.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Cos preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Cos preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CrossNodeConstraint","title":"<code>CrossNodeConstraint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>A constraint that couples specific trajectory nodes via .at(k) references.</p> <p>Unlike NodalConstraint which applies a constraint pattern at multiple nodes (via vmapping), CrossNodeConstraint is a single constraint with fixed node indices embedded in the expression via NodeReference nodes.</p> <p>CrossNodeConstraint is created automatically when a bare Constraint contains NodeReference nodes (from .at(k) calls). Users should NOT manually wrap cross-node constraints - they are auto-detected during constraint separation.</p> <p>Key differences from NodalConstraint:</p> <ul> <li>NodalConstraint: Same constraint evaluated at multiple nodes via vmapping.   Signature: (x, u, node, params) \u2192 scalar, vmapped to (N, n_x) inputs.</li> <li>CrossNodeConstraint: Single constraint coupling specific fixed nodes.   Signature: (X, U, params) \u2192 scalar, operates on full trajectory arrays.</li> </ul> <p>Lowering:</p> <ul> <li>Non-convex: Lowered to JAX with automatic differentiation for SCP linearization</li> <li>Convex: Lowered to CVXPy and solved directly by the convex solver</li> </ul> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint containing NodeReference nodes</p> Example <p>Rate limit constraint (auto-detected as CrossNodeConstraint):</p> <pre><code>position = State(\"pos\", shape=(3,))\n\n# This creates a CrossNodeConstraint automatically:\nrate_limit = position.at(5) - position.at(4) &lt;= 0.1\n\n# Mark as convex if the constraint is convex:\nrate_limit_convex = (position.at(5) - position.at(4) &lt;= 0.1).convex()\n</code></pre> <p>Creating multiple cross-node constraints with a loop:</p> <pre><code>constraints = []\nfor k in range(1, N):\n    # Each iteration creates one CrossNodeConstraint\n    rate_limit = position.at(k) - position.at(k-1) &lt;= max_step\n    constraints.append(rate_limit)\n</code></pre> Note <p>Do NOT use .at([...]) on cross-node constraints. The nodes are already specified via .at(k) inside the expression. Using .at([...]) will raise an error during constraint separation.</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class CrossNodeConstraint(Expr):\n    \"\"\"A constraint that couples specific trajectory nodes via .at(k) references.\n\n    Unlike NodalConstraint which applies a constraint pattern at multiple nodes\n    (via vmapping), CrossNodeConstraint is a single constraint with fixed node\n    indices embedded in the expression via NodeReference nodes.\n\n    CrossNodeConstraint is created automatically when a bare Constraint contains\n    NodeReference nodes (from .at(k) calls). Users should NOT manually wrap\n    cross-node constraints - they are auto-detected during constraint separation.\n\n    **Key differences from NodalConstraint:**\n\n    - **NodalConstraint**: Same constraint evaluated at multiple nodes via vmapping.\n      Signature: (x, u, node, params) \u2192 scalar, vmapped to (N, n_x) inputs.\n    - **CrossNodeConstraint**: Single constraint coupling specific fixed nodes.\n      Signature: (X, U, params) \u2192 scalar, operates on full trajectory arrays.\n\n    **Lowering:**\n\n    - **Non-convex**: Lowered to JAX with automatic differentiation for SCP linearization\n    - **Convex**: Lowered to CVXPy and solved directly by the convex solver\n\n    Attributes:\n        constraint: The wrapped Constraint containing NodeReference nodes\n\n    Example:\n        Rate limit constraint (auto-detected as CrossNodeConstraint):\n\n            position = State(\"pos\", shape=(3,))\n\n            # This creates a CrossNodeConstraint automatically:\n            rate_limit = position.at(5) - position.at(4) &lt;= 0.1\n\n            # Mark as convex if the constraint is convex:\n            rate_limit_convex = (position.at(5) - position.at(4) &lt;= 0.1).convex()\n\n        Creating multiple cross-node constraints with a loop:\n\n            constraints = []\n            for k in range(1, N):\n                # Each iteration creates one CrossNodeConstraint\n                rate_limit = position.at(k) - position.at(k-1) &lt;= max_step\n                constraints.append(rate_limit)\n\n    Note:\n        Do NOT use .at([...]) on cross-node constraints. The nodes are already\n        specified via .at(k) inside the expression. Using .at([...]) will raise\n        an error during constraint separation.\n    \"\"\"\n\n    def __init__(self, constraint: Constraint):\n        \"\"\"Initialize a CrossNodeConstraint.\n\n        Args:\n            constraint: The Constraint containing NodeReference nodes.\n                Must contain at least one NodeReference (from .at(k) calls).\n\n        Raises:\n            TypeError: If constraint is not a Constraint instance\n        \"\"\"\n        if not isinstance(constraint, Constraint):\n            raise TypeError(\"CrossNodeConstraint must wrap a Constraint\")\n\n        self.constraint = constraint\n\n    @property\n    def is_convex(self) -&gt; bool:\n        \"\"\"Whether the underlying constraint is marked as convex.\n\n        Returns:\n            bool: True if the constraint is convex, False otherwise\n        \"\"\"\n        return self.constraint.is_convex\n\n    def children(self):\n        \"\"\"Return the wrapped constraint as the only child.\n\n        Returns:\n            list: Single-element list containing the wrapped constraint\n        \"\"\"\n        return [self.constraint]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the wrapped constraint.\n\n        Returns:\n            CrossNodeConstraint: A new CrossNodeConstraint with canonicalized inner constraint\n        \"\"\"\n        canon_constraint = self.constraint.canonicalize()\n        return CrossNodeConstraint(canon_constraint)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Validate the wrapped constraint's shape.\n\n        Returns:\n            tuple: Empty tuple () representing scalar shape\n        \"\"\"\n        self.constraint.check_shape()\n        return ()\n\n    def convex(self) -&gt; \"CrossNodeConstraint\":\n        \"\"\"Mark the underlying constraint as convex for CVXPy lowering.\n\n        Returns:\n            Self with underlying constraint's convex flag set to True\n        \"\"\"\n        self.constraint.convex()\n        return self\n\n    def __repr__(self):\n        \"\"\"String representation of the CrossNodeConstraint.\n\n        Returns:\n            str: String showing the wrapped constraint\n        \"\"\"\n        return f\"CrossNodeConstraint({self.constraint!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CrossNodeConstraint.is_convex","title":"<code>is_convex: bool</code>  <code>property</code>","text":"<p>Whether the underlying constraint is marked as convex.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the constraint is convex, False otherwise</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CrossNodeConstraint.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the wrapped constraint.</p> <p>Returns:</p> Name Type Description <code>CrossNodeConstraint</code> <code>Expr</code> <p>A new CrossNodeConstraint with canonicalized inner constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the wrapped constraint.\n\n    Returns:\n        CrossNodeConstraint: A new CrossNodeConstraint with canonicalized inner constraint\n    \"\"\"\n    canon_constraint = self.constraint.canonicalize()\n    return CrossNodeConstraint(canon_constraint)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CrossNodeConstraint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the wrapped constraint's shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Validate the wrapped constraint's shape.\n\n    Returns:\n        tuple: Empty tuple () representing scalar shape\n    \"\"\"\n    self.constraint.check_shape()\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CrossNodeConstraint.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def children(self):\n    \"\"\"Return the wrapped constraint as the only child.\n\n    Returns:\n        list: Single-element list containing the wrapped constraint\n    \"\"\"\n    return [self.constraint]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CrossNodeConstraint.convex","title":"<code>convex() -&gt; CrossNodeConstraint</code>","text":"<p>Mark the underlying constraint as convex for CVXPy lowering.</p> <p>Returns:</p> Type Description <code>CrossNodeConstraint</code> <p>Self with underlying constraint's convex flag set to True</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def convex(self) -&gt; \"CrossNodeConstraint\":\n    \"\"\"Mark the underlying constraint as convex for CVXPy lowering.\n\n    Returns:\n        Self with underlying constraint's convex flag set to True\n    \"\"\"\n    self.constraint.convex()\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Diag","title":"<code>Diag</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Diagonal matrix construction from a vector.</p> <p>Creates a square diagonal matrix from a 1D vector. The vector elements become the diagonal entries, with all off-diagonal entries set to zero. This is analogous to numpy.diag() or jax.numpy.diag().</p> Note <p>Currently only supports creating diagonal matrices from vectors. Extracting diagonals from matrices is not yet implemented.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>1D vector expression to place on the diagonal</p> Example <p>Define a Diag:</p> <pre><code>v = Variable(\"v\", shape=(3,))\nD = Diag(v)  # Creates a (3, 3) diagonal matrix\n</code></pre> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>class Diag(Expr):\n    \"\"\"Diagonal matrix construction from a vector.\n\n    Creates a square diagonal matrix from a 1D vector. The vector elements become\n    the diagonal entries, with all off-diagonal entries set to zero. This is\n    analogous to numpy.diag() or jax.numpy.diag().\n\n    Note:\n        Currently only supports creating diagonal matrices from vectors.\n        Extracting diagonals from matrices is not yet implemented.\n\n    Attributes:\n        operand: 1D vector expression to place on the diagonal\n\n    Example:\n        Define a Diag:\n\n            v = Variable(\"v\", shape=(3,))\n            D = Diag(v)  # Creates a (3, 3) diagonal matrix\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a diagonal matrix operation.\n\n        Args:\n            operand: 1D vector expression to place on the diagonal\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Diag(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Diag converts a vector (n,) to a diagonal matrix (n,n).\"\"\"\n        operand_shape = self.operand.check_shape()\n        if len(operand_shape) != 1:\n            raise ValueError(f\"Diag expects a 1D vector, got shape {operand_shape}\")\n        n = operand_shape[0]\n        return (n, n)\n\n    def __repr__(self):\n        return f\"diag({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Diag.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Diag converts a vector (n,) to a diagonal matrix (n,n).</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Diag converts a vector (n,) to a diagonal matrix (n,n).\"\"\"\n    operand_shape = self.operand.check_shape()\n    if len(operand_shape) != 1:\n        raise ValueError(f\"Diag expects a 1D vector, got shape {operand_shape}\")\n    n = operand_shape[0]\n    return (n, n)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Div","title":"<code>Div</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise division operation for symbolic expressions.</p> <p>Represents element-wise division (left / right). Supports broadcasting following NumPy rules. Can be created using the / operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>left</code> <p>Numerator expression</p> <code>right</code> <p>Denominator expression</p> Example <p>Define a Div expression</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(3,))\nz = x / y  # Creates Div(x, y)\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Div(Expr):\n    \"\"\"Element-wise division operation for symbolic expressions.\n\n    Represents element-wise division (left / right). Supports broadcasting\n    following NumPy rules. Can be created using the / operator on Expr objects.\n\n    Attributes:\n        left: Numerator expression\n        right: Denominator expression\n\n    Example:\n        Define a Div expression\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(3,))\n            z = x / y  # Creates Div(x, y)\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\"Initialize a division operation.\n\n        Args:\n            left: Expression for the numerator\n            right: Expression for the denominator\n        \"\"\"\n        self.left = left\n        self.right = right\n\n    def children(self):\n        return [self.left, self.right]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize division: fold constants if both sides are constants.\n\n        Returns:\n            Expr: Canonical form of the division expression\n        \"\"\"\n        lhs = self.left.canonicalize()\n        rhs = self.right.canonicalize()\n        if isinstance(lhs, Constant) and isinstance(rhs, Constant):\n            return Constant(lhs.value / rhs.value)\n        return Div(lhs, rhs)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n        Returns:\n            tuple: The broadcasted shape of both operands\n\n        Raises:\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Div shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        return f\"({self.left!r} / {self.right!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Div.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize division: fold constants if both sides are constants.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the division expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize division: fold constants if both sides are constants.\n\n    Returns:\n        Expr: Canonical form of the division expression\n    \"\"\"\n    lhs = self.left.canonicalize()\n    rhs = self.right.canonicalize()\n    if isinstance(lhs, Constant) and isinstance(rhs, Constant):\n        return Constant(lhs.value / rhs.value)\n    return Div(lhs, rhs)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Div.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check shape compatibility and compute broadcasted result shape like NumPy.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The broadcasted shape of both operands</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n    Returns:\n        tuple: The broadcasted shape of both operands\n\n    Raises:\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Div shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Equality","title":"<code>Equality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Equality constraint for optimization problems.</p> <p>Represents an equality constraint: lhs == rhs. Can be created using the == operator on Expr objects.</p> Example <p>Define an Equality constraint:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = x == 0  # Creates Equality(x, Constant(0))\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class Equality(Constraint):\n    \"\"\"Equality constraint for optimization problems.\n\n    Represents an equality constraint: lhs == rhs. Can be created using the ==\n    operator on Expr objects.\n\n    Example:\n        Define an Equality constraint:\n\n            x = ox.State(\"x\", shape=(3,))\n            constraint = x == 0  # Creates Equality(x, Constant(0))\n    \"\"\"\n\n    def __repr__(self):\n        return f\"{self.lhs!r} == {self.rhs!r}\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Exp","title":"<code>Exp</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise exponential function for symbolic expressions.</p> <p>Computes e^x for each element in the operand, where e is Euler's number. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply exponential function to</p> Example <p>Define an Exp expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\nexp_x = Exp(x)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Exp(Expr):\n    \"\"\"Element-wise exponential function for symbolic expressions.\n\n    Computes e^x for each element in the operand, where e is Euler's number.\n    Preserves the shape of the input expression.\n\n    Attributes:\n        operand: Expression to apply exponential function to\n\n    Example:\n        Define an Exp expression:\n\n            x = Variable(\"x\", shape=(3,))\n            exp_x = Exp(x)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize an exponential operation.\n\n        Args:\n            operand: Expression to apply exponential function to\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Exp(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Exp preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"exp({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Exp.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Exp preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Exp preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Expr","title":"<code>Expr</code>","text":"<p>Base class for symbolic expressions in optimization problems.</p> <p>Expr is the foundation of the symbolic expression system in openscvx. It represents nodes in an abstract syntax tree (AST) for mathematical expressions. Expressions support:</p> <ul> <li>Arithmetic operations: +, -, *, /, @, **</li> <li>Comparison operations: ==, &lt;=, &gt;=</li> <li>Indexing and slicing: []</li> <li>Transposition: .T property</li> <li>Shape checking and validation</li> <li>Canonicalization (algebraic simplification)</li> </ul> <p>All Expr subclasses implement a tree structure where each node can have child expressions accessed via the children() method.</p> <p>Attributes:</p> Name Type Description <code>__array_priority__</code> <p>Priority for operations with numpy arrays (set to 1000)</p> Note <p>When used in operations with numpy arrays, Expr objects take precedence, allowing symbolic expressions to wrap numeric values automatically.</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class Expr:\n    \"\"\"Base class for symbolic expressions in optimization problems.\n\n    Expr is the foundation of the symbolic expression system in openscvx. It represents\n    nodes in an abstract syntax tree (AST) for mathematical expressions. Expressions\n    support:\n\n    - Arithmetic operations: +, -, *, /, @, **\n    - Comparison operations: ==, &lt;=, &gt;=\n    - Indexing and slicing: []\n    - Transposition: .T property\n    - Shape checking and validation\n    - Canonicalization (algebraic simplification)\n\n    All Expr subclasses implement a tree structure where each node can have child\n    expressions accessed via the children() method.\n\n    Attributes:\n        __array_priority__: Priority for operations with numpy arrays (set to 1000)\n\n    Note:\n        When used in operations with numpy arrays, Expr objects take precedence,\n        allowing symbolic expressions to wrap numeric values automatically.\n    \"\"\"\n\n    # Give Expr objects higher priority than numpy arrays in operations\n    __array_priority__ = 1000\n\n    def __le__(self, other):\n        from .constraint import Inequality\n\n        return Inequality(self, to_expr(other))\n\n    def __ge__(self, other):\n        from .constraint import Inequality\n\n        return Inequality(to_expr(other), self)\n\n    def __eq__(self, other):\n        from .constraint import Equality\n\n        return Equality(self, to_expr(other))\n\n    def __add__(self, other):\n        from .arithmetic import Add\n\n        return Add(self, to_expr(other))\n\n    def __radd__(self, other):\n        from .arithmetic import Add\n\n        return Add(to_expr(other), self)\n\n    def __sub__(self, other):\n        from .arithmetic import Sub\n\n        return Sub(self, to_expr(other))\n\n    def __rsub__(self, other):\n        # e.g. 5 - a  \u21d2 Sub(Constant(5), a)\n        from .arithmetic import Sub\n\n        return Sub(to_expr(other), self)\n\n    def __truediv__(self, other):\n        from .arithmetic import Div\n\n        return Div(self, to_expr(other))\n\n    def __rtruediv__(self, other):\n        # e.g. 10 / a\n        from .arithmetic import Div\n\n        return Div(to_expr(other), self)\n\n    def __mul__(self, other):\n        from .arithmetic import Mul\n\n        return Mul(self, to_expr(other))\n\n    def __rmul__(self, other):\n        from .arithmetic import Mul\n\n        return Mul(to_expr(other), self)\n\n    def __matmul__(self, other):\n        from .arithmetic import MatMul\n\n        return MatMul(self, to_expr(other))\n\n    def __rmatmul__(self, other):\n        from .arithmetic import MatMul\n\n        return MatMul(to_expr(other), self)\n\n    def __rle__(self, other):\n        # other &lt;= self  =&gt;  Inequality(other, self)\n        from .constraint import Inequality\n\n        return Inequality(to_expr(other), self)\n\n    def __rge__(self, other):\n        # other &gt;= self  =&gt;  Inequality(self, other)\n        from .constraint import Inequality\n\n        return Inequality(self, to_expr(other))\n\n    def __req__(self, other):\n        # other == self  =&gt;  Equality(other, self)\n        from .constraint import Equality\n\n        return Equality(to_expr(other), self)\n\n    def __neg__(self):\n        from .arithmetic import Neg\n\n        return Neg(self)\n\n    def __pow__(self, other):\n        from .arithmetic import Power\n\n        return Power(self, to_expr(other))\n\n    def __rpow__(self, other):\n        from .arithmetic import Power\n\n        return Power(to_expr(other), self)\n\n    def __getitem__(self, idx):\n        from .array import Index\n\n        return Index(self, idx)\n\n    @property\n    def T(self):\n        \"\"\"Transpose property for matrix expressions.\n\n        Returns:\n            Transpose: A Transpose expression wrapping this expression\n\n        Example:\n            Create a transpose:\n\n                A = ox.State(\"A\", shape=(3, 4))\n                A_T = A.T  # Creates Transpose(A), result shape (4, 3)\n        \"\"\"\n        from .linalg import Transpose\n\n        return Transpose(self)\n\n    def at(self, k: int) -&gt; \"NodeReference\":\n        \"\"\"Reference this expression at a specific trajectory node.\n\n        This method enables inter-node constraints where you can reference\n        the value of an expression at different time steps. Common patterns\n        include rate limits and multi-step dependencies.\n\n        Args:\n            k: Absolute node index (integer) in the trajectory.\n               Can be positive (0, 1, 2, ...) or negative (-1 for last node).\n\n        Returns:\n            NodeReference: An expression representing this expression at node k\n\n        Example:\n            Rate limit constraint (applied across trajectory using a loop):\n\n                position = State(\"pos\", shape=(3,))\n\n                # Create rate limit for each node\n                constraints = [\n                    (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n                    for k in range(1, N)\n                ]\n\n            Multi-step dependency:\n\n                state = State(\"x\", shape=(1,))\n\n                # Fibonacci-like recurrence\n                constraints = [\n                    (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n                    for k in range(2, N)\n                ]\n\n        Performance Note:\n            Cross-node constraints use dense Jacobian storage which can be memory-intensive\n            for large N (&gt;100 nodes). See LoweredCrossNodeConstraint documentation for\n            details on memory usage and future sparse Jacobian support.\n        \"\"\"\n        return NodeReference(self, k)\n\n    def children(self):\n        \"\"\"Return the child expressions of this node.\n\n        Returns:\n            list: List of child Expr objects. Empty list for leaf nodes.\n        \"\"\"\n        return []\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"\n        Return a canonical (simplified) form of this expression.\n\n        Canonicalization performs algebraic simplifications such as:\n        - Constant folding (e.g., 2 + 3 \u2192 5)\n        - Identity elimination (e.g., x + 0 \u2192 x, x * 1 \u2192 x)\n        - Flattening nested operations (e.g., Add(Add(a, b), c) \u2192 Add(a, b, c))\n        - Algebraic rewrites (e.g., constraints to standard form)\n\n        Returns:\n            Expr: A canonical version of this expression\n\n        Raises:\n            NotImplementedError: If canonicalization is not implemented for this node type\n        \"\"\"\n        raise NotImplementedError(f\"canonicalize() not implemented for {self.__class__.__name__}\")\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"\n        Compute and validate the shape of this expression.\n\n        This method:\n        1. Recursively checks shapes of all child expressions\n        2. Validates that operations are shape-compatible (e.g., broadcasting rules)\n        3. Returns the output shape of this expression\n\n        For example:\n        - A Parameter with shape (3, 4) returns (3, 4)\n        - MatMul of (3, 4) @ (4, 5) returns (3, 5)\n        - Sum of any shape returns () (scalar)\n        - Add broadcasts shapes like NumPy\n\n        Returns:\n            tuple: The shape of this expression as a tuple of integers.\n                   Empty tuple () represents a scalar.\n\n        Raises:\n            NotImplementedError: If shape checking is not implemented for this node type\n            ValueError: If the expression has invalid shapes (e.g., incompatible dimensions)\n        \"\"\"\n        raise NotImplementedError(f\"check_shape() not implemented for {self.__class__.__name__}\")\n\n    def pretty(self, indent=0):\n        \"\"\"Generate a pretty-printed string representation of the expression tree.\n\n        Creates an indented, hierarchical view of the expression tree structure,\n        useful for debugging and visualization.\n\n        Args:\n            indent: Current indentation level (default: 0)\n\n        Returns:\n            str: Multi-line string representation of the expression tree\n\n        Example:\n            Pretty print an expression:\n\n                expr = (x + y) * z\n                print(expr.pretty())\n                # Mul\n                #   Add\n                #     State\n                #     State\n                #   State\n        \"\"\"\n        pad = \"  \" * indent\n        pad = \"  \" * indent\n        lines = [f\"{pad}{self.__class__.__name__}\"]\n        for child in self.children():\n            lines.append(child.pretty(indent + 1))\n        return \"\\n\".join(lines)\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Contribute this expression's structural identity to a hash.\n\n        This method is used to compute a structural hash of the expression tree\n        that is name-invariant (same structure = same hash regardless of variable names).\n\n        The default implementation hashes the class name and recursively hashes all\n        children. Subclasses with additional attributes (like Norm.ord, Index.index)\n        should override this to include those attributes.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        # Hash the class name to distinguish different node types\n        hasher.update(self.__class__.__name__.encode())\n        # Recursively hash all children\n        for child in self.children():\n            child._hash_into(hasher)\n\n    def structural_hash(self) -&gt; bytes:\n        \"\"\"Compute a structural hash of this expression.\n\n        Returns a hash that depends only on the mathematical structure of the\n        expression, not on variable names. Two expressions that are structurally\n        equivalent (same operations, same variable positions) will have the same hash.\n\n        Returns:\n            bytes: SHA-256 digest of the expression structure\n        \"\"\"\n        hasher = hashlib.sha256()\n        self._hash_into(hasher)\n        return hasher.digest()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Expr.T","title":"<code>T</code>  <code>property</code>","text":"<p>Transpose property for matrix expressions.</p> <p>Returns:</p> Name Type Description <code>Transpose</code> <p>A Transpose expression wrapping this expression</p> Example <p>Create a transpose:</p> <pre><code>A = ox.State(\"A\", shape=(3, 4))\nA_T = A.T  # Creates Transpose(A), result shape (4, 3)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Expr._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Contribute this expression's structural identity to a hash.</p> <p>This method is used to compute a structural hash of the expression tree that is name-invariant (same structure = same hash regardless of variable names).</p> <p>The default implementation hashes the class name and recursively hashes all children. Subclasses with additional attributes (like Norm.ord, Index.index) should override this to include those attributes.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Contribute this expression's structural identity to a hash.\n\n    This method is used to compute a structural hash of the expression tree\n    that is name-invariant (same structure = same hash regardless of variable names).\n\n    The default implementation hashes the class name and recursively hashes all\n    children. Subclasses with additional attributes (like Norm.ord, Index.index)\n    should override this to include those attributes.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    # Hash the class name to distinguish different node types\n    hasher.update(self.__class__.__name__.encode())\n    # Recursively hash all children\n    for child in self.children():\n        child._hash_into(hasher)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Expr.at","title":"<code>at(k: int) -&gt; NodeReference</code>","text":"<p>Reference this expression at a specific trajectory node.</p> <p>This method enables inter-node constraints where you can reference the value of an expression at different time steps. Common patterns include rate limits and multi-step dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>Absolute node index (integer) in the trajectory. Can be positive (0, 1, 2, ...) or negative (-1 for last node).</p> required <p>Returns:</p> Name Type Description <code>NodeReference</code> <code>NodeReference</code> <p>An expression representing this expression at node k</p> Example <p>Rate limit constraint (applied across trajectory using a loop):</p> <pre><code>position = State(\"pos\", shape=(3,))\n\n# Create rate limit for each node\nconstraints = [\n    (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n    for k in range(1, N)\n]\n</code></pre> <p>Multi-step dependency:</p> <pre><code>state = State(\"x\", shape=(1,))\n\n# Fibonacci-like recurrence\nconstraints = [\n    (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n    for k in range(2, N)\n]\n</code></pre> Performance Note <p>Cross-node constraints use dense Jacobian storage which can be memory-intensive for large N (&gt;100 nodes). See LoweredCrossNodeConstraint documentation for details on memory usage and future sparse Jacobian support.</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def at(self, k: int) -&gt; \"NodeReference\":\n    \"\"\"Reference this expression at a specific trajectory node.\n\n    This method enables inter-node constraints where you can reference\n    the value of an expression at different time steps. Common patterns\n    include rate limits and multi-step dependencies.\n\n    Args:\n        k: Absolute node index (integer) in the trajectory.\n           Can be positive (0, 1, 2, ...) or negative (-1 for last node).\n\n    Returns:\n        NodeReference: An expression representing this expression at node k\n\n    Example:\n        Rate limit constraint (applied across trajectory using a loop):\n\n            position = State(\"pos\", shape=(3,))\n\n            # Create rate limit for each node\n            constraints = [\n                (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n                for k in range(1, N)\n            ]\n\n        Multi-step dependency:\n\n            state = State(\"x\", shape=(1,))\n\n            # Fibonacci-like recurrence\n            constraints = [\n                (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n                for k in range(2, N)\n            ]\n\n    Performance Note:\n        Cross-node constraints use dense Jacobian storage which can be memory-intensive\n        for large N (&gt;100 nodes). See LoweredCrossNodeConstraint documentation for\n        details on memory usage and future sparse Jacobian support.\n    \"\"\"\n    return NodeReference(self, k)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Expr.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Return a canonical (simplified) form of this expression.</p> <p>Canonicalization performs algebraic simplifications such as: - Constant folding (e.g., 2 + 3 \u2192 5) - Identity elimination (e.g., x + 0 \u2192 x, x * 1 \u2192 x) - Flattening nested operations (e.g., Add(Add(a, b), c) \u2192 Add(a, b, c)) - Algebraic rewrites (e.g., constraints to standard form)</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>A canonical version of this expression</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If canonicalization is not implemented for this node type</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"\n    Return a canonical (simplified) form of this expression.\n\n    Canonicalization performs algebraic simplifications such as:\n    - Constant folding (e.g., 2 + 3 \u2192 5)\n    - Identity elimination (e.g., x + 0 \u2192 x, x * 1 \u2192 x)\n    - Flattening nested operations (e.g., Add(Add(a, b), c) \u2192 Add(a, b, c))\n    - Algebraic rewrites (e.g., constraints to standard form)\n\n    Returns:\n        Expr: A canonical version of this expression\n\n    Raises:\n        NotImplementedError: If canonicalization is not implemented for this node type\n    \"\"\"\n    raise NotImplementedError(f\"canonicalize() not implemented for {self.__class__.__name__}\")\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Expr.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Compute and validate the shape of this expression.</p> <p>This method: 1. Recursively checks shapes of all child expressions 2. Validates that operations are shape-compatible (e.g., broadcasting rules) 3. Returns the output shape of this expression</p> <p>For example: - A Parameter with shape (3, 4) returns (3, 4) - MatMul of (3, 4) @ (4, 5) returns (3, 5) - Sum of any shape returns () (scalar) - Add broadcasts shapes like NumPy</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The shape of this expression as a tuple of integers.    Empty tuple () represents a scalar.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If shape checking is not implemented for this node type</p> <code>ValueError</code> <p>If the expression has invalid shapes (e.g., incompatible dimensions)</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"\n    Compute and validate the shape of this expression.\n\n    This method:\n    1. Recursively checks shapes of all child expressions\n    2. Validates that operations are shape-compatible (e.g., broadcasting rules)\n    3. Returns the output shape of this expression\n\n    For example:\n    - A Parameter with shape (3, 4) returns (3, 4)\n    - MatMul of (3, 4) @ (4, 5) returns (3, 5)\n    - Sum of any shape returns () (scalar)\n    - Add broadcasts shapes like NumPy\n\n    Returns:\n        tuple: The shape of this expression as a tuple of integers.\n               Empty tuple () represents a scalar.\n\n    Raises:\n        NotImplementedError: If shape checking is not implemented for this node type\n        ValueError: If the expression has invalid shapes (e.g., incompatible dimensions)\n    \"\"\"\n    raise NotImplementedError(f\"check_shape() not implemented for {self.__class__.__name__}\")\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Expr.children","title":"<code>children()</code>","text":"<p>Return the child expressions of this node.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of child Expr objects. Empty list for leaf nodes.</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def children(self):\n    \"\"\"Return the child expressions of this node.\n\n    Returns:\n        list: List of child Expr objects. Empty list for leaf nodes.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Expr.pretty","title":"<code>pretty(indent=0)</code>","text":"<p>Generate a pretty-printed string representation of the expression tree.</p> <p>Creates an indented, hierarchical view of the expression tree structure, useful for debugging and visualization.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <p>Current indentation level (default: 0)</p> <code>0</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Multi-line string representation of the expression tree</p> Example <p>Pretty print an expression:</p> <pre><code>expr = (x + y) * z\nprint(expr.pretty())\n# Mul\n#   Add\n#     State\n#     State\n#   State\n</code></pre> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def pretty(self, indent=0):\n    \"\"\"Generate a pretty-printed string representation of the expression tree.\n\n    Creates an indented, hierarchical view of the expression tree structure,\n    useful for debugging and visualization.\n\n    Args:\n        indent: Current indentation level (default: 0)\n\n    Returns:\n        str: Multi-line string representation of the expression tree\n\n    Example:\n        Pretty print an expression:\n\n            expr = (x + y) * z\n            print(expr.pretty())\n            # Mul\n            #   Add\n            #     State\n            #     State\n            #   State\n    \"\"\"\n    pad = \"  \" * indent\n    pad = \"  \" * indent\n    lines = [f\"{pad}{self.__class__.__name__}\"]\n    for child in self.children():\n        lines.append(child.pretty(indent + 1))\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Expr.structural_hash","title":"<code>structural_hash() -&gt; bytes</code>","text":"<p>Compute a structural hash of this expression.</p> <p>Returns a hash that depends only on the mathematical structure of the expression, not on variable names. Two expressions that are structurally equivalent (same operations, same variable positions) will have the same hash.</p> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>SHA-256 digest of the expression structure</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def structural_hash(self) -&gt; bytes:\n    \"\"\"Compute a structural hash of this expression.\n\n    Returns a hash that depends only on the mathematical structure of the\n    expression, not on variable names. Two expressions that are structurally\n    equivalent (same operations, same variable positions) will have the same hash.\n\n    Returns:\n        bytes: SHA-256 digest of the expression structure\n    \"\"\"\n    hasher = hashlib.sha256()\n    self._hash_into(hasher)\n    return hasher.digest()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Hstack","title":"<code>Hstack</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Horizontal stacking operation for symbolic expressions.</p> <p>Concatenates expressions horizontally (along columns for 2D arrays). This is analogous to numpy.hstack() or jax.numpy.hstack().</p> <p>Behavior depends on input dimensionality: - 1D arrays: Concatenates along axis 0 (making a longer vector) - 2D arrays: Concatenates along axis 1 (columns), rows must match - Higher-D: Concatenates along axis 1, all other dimensions must match</p> <p>Attributes:</p> Name Type Description <code>arrays</code> <p>List of expressions to stack horizontally</p> Example <p>1D case: concatenate vectors:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(2,))\nh = Hstack([x, y])  # Result shape (5,)\n</code></pre> <p>2D case: concatenate matrices horizontally:</p> <pre><code>A = Variable(\"A\", shape=(3, 4))\nB = Variable(\"B\", shape=(3, 2))\nC = Hstack([A, B])  # Result shape (3, 6)\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Hstack(Expr):\n    \"\"\"Horizontal stacking operation for symbolic expressions.\n\n    Concatenates expressions horizontally (along columns for 2D arrays).\n    This is analogous to numpy.hstack() or jax.numpy.hstack().\n\n    Behavior depends on input dimensionality:\n    - 1D arrays: Concatenates along axis 0 (making a longer vector)\n    - 2D arrays: Concatenates along axis 1 (columns), rows must match\n    - Higher-D: Concatenates along axis 1, all other dimensions must match\n\n    Attributes:\n        arrays: List of expressions to stack horizontally\n\n    Example:\n        1D case: concatenate vectors:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(2,))\n            h = Hstack([x, y])  # Result shape (5,)\n\n        2D case: concatenate matrices horizontally:\n\n            A = Variable(\"A\", shape=(3, 4))\n            B = Variable(\"B\", shape=(3, 2))\n            C = Hstack([A, B])  # Result shape (3, 6)\n    \"\"\"\n\n    def __init__(self, arrays):\n        \"\"\"Initialize a horizontal stack operation.\n\n        Args:\n            arrays: List of expressions to concatenate horizontally\n        \"\"\"\n        self.arrays = [to_expr(arr) for arr in arrays]\n\n    def children(self):\n        return self.arrays\n\n    def canonicalize(self) -&gt; \"Expr\":\n        arrays = [arr.canonicalize() for arr in self.arrays]\n        return Hstack(arrays)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Horizontal stack concatenates arrays along the second axis (columns).\"\"\"\n        if not self.arrays:\n            raise ValueError(\"Hstack requires at least one array\")\n\n        array_shapes = [arr.check_shape() for arr in self.arrays]\n\n        # All arrays must have the same number of dimensions\n        first_ndim = len(array_shapes[0])\n        for i, shape in enumerate(array_shapes[1:], 1):\n            if len(shape) != first_ndim:\n                raise ValueError(\n                    f\"Hstack array {i} has {len(shape)} dimensions, but array 0 has {first_ndim}\"\n                )\n\n        # For 1D arrays, hstack concatenates along axis 0\n        if first_ndim == 1:\n            total_length = sum(shape[0] for shape in array_shapes)\n            return (total_length,)\n\n        # For 2D+ arrays, all dimensions except the second must match\n        first_shape = array_shapes[0]\n        for i, shape in enumerate(array_shapes[1:], 1):\n            if shape[0] != first_shape[0]:\n                raise ValueError(\n                    f\"Hstack array {i} has {shape[0]} rows, but array 0 has {first_shape[0]} rows\"\n                )\n            if shape[2:] != first_shape[2:]:\n                raise ValueError(\n                    f\"Hstack array {i} has trailing dimensions {shape[2:]}, \"\n                    f\"but array 0 has {first_shape[2:]}\"\n                )\n\n        # Result shape: concatenate along axis 1 (columns)\n        total_cols = sum(shape[1] for shape in array_shapes)\n        return (first_shape[0], total_cols) + first_shape[2:]\n\n    def __repr__(self):\n        arrays_repr = \", \".join(repr(arr) for arr in self.arrays)\n        return f\"Hstack([{arrays_repr}])\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Hstack.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Horizontal stack concatenates arrays along the second axis (columns).</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Horizontal stack concatenates arrays along the second axis (columns).\"\"\"\n    if not self.arrays:\n        raise ValueError(\"Hstack requires at least one array\")\n\n    array_shapes = [arr.check_shape() for arr in self.arrays]\n\n    # All arrays must have the same number of dimensions\n    first_ndim = len(array_shapes[0])\n    for i, shape in enumerate(array_shapes[1:], 1):\n        if len(shape) != first_ndim:\n            raise ValueError(\n                f\"Hstack array {i} has {len(shape)} dimensions, but array 0 has {first_ndim}\"\n            )\n\n    # For 1D arrays, hstack concatenates along axis 0\n    if first_ndim == 1:\n        total_length = sum(shape[0] for shape in array_shapes)\n        return (total_length,)\n\n    # For 2D+ arrays, all dimensions except the second must match\n    first_shape = array_shapes[0]\n    for i, shape in enumerate(array_shapes[1:], 1):\n        if shape[0] != first_shape[0]:\n            raise ValueError(\n                f\"Hstack array {i} has {shape[0]} rows, but array 0 has {first_shape[0]} rows\"\n            )\n        if shape[2:] != first_shape[2:]:\n            raise ValueError(\n                f\"Hstack array {i} has trailing dimensions {shape[2:]}, \"\n                f\"but array 0 has {first_shape[2:]}\"\n            )\n\n    # Result shape: concatenate along axis 1 (columns)\n    total_cols = sum(shape[1] for shape in array_shapes)\n    return (first_shape[0], total_cols) + first_shape[2:]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Huber","title":"<code>Huber</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Huber penalty function for symbolic expressions.</p> <p>The Huber penalty is a smooth approximation to the absolute value function that is quadratic for small values (|x| &lt; delta) and linear for large values (|x| &gt;= delta). This makes it more robust to outliers than squared penalties while maintaining smoothness.</p> <p>The Huber function is defined as: - (x^2) / (2*delta)           for |x| &lt;= delta - |x| - delta/2               for |x| &gt; delta</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Expression to apply Huber penalty to</p> <code>delta</code> <p>Threshold parameter controlling the transition point (default: 0.25)</p> Example <p>Define a Huber penalty expression:</p> <pre><code>residual = y_measured - y_predicted\npenalty = Huber(residual, delta=0.5)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Huber(Expr):\n    \"\"\"Huber penalty function for symbolic expressions.\n\n    The Huber penalty is a smooth approximation to the absolute value function\n    that is quadratic for small values (|x| &lt; delta) and linear for large values\n    (|x| &gt;= delta). This makes it more robust to outliers than squared penalties\n    while maintaining smoothness.\n\n    The Huber function is defined as:\n    - (x^2) / (2*delta)           for |x| &lt;= delta\n    - |x| - delta/2               for |x| &gt; delta\n\n    Attributes:\n        x: Expression to apply Huber penalty to\n        delta: Threshold parameter controlling the transition point (default: 0.25)\n\n    Example:\n        Define a Huber penalty expression:\n\n            residual = y_measured - y_predicted\n            penalty = Huber(residual, delta=0.5)\n    \"\"\"\n\n    def __init__(self, x, delta: float = 0.25):\n        \"\"\"Initialize a Huber penalty operation.\n\n        Args:\n            x: Expression to apply Huber penalty to\n            delta: Threshold parameter for quadratic-to-linear transition (default: 0.25)\n        \"\"\"\n        self.x = to_expr(x)\n        self.delta = float(delta)\n\n    def children(self):\n        return [self.x]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the operand but preserve delta parameter.\"\"\"\n        x = self.x.canonicalize()\n        return Huber(x, delta=self.delta)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Huber penalty preserves the shape of x.\"\"\"\n        return self.x.check_shape()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Huber including its delta parameter.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Huber\")\n        # Hash delta as bytes\n        hasher.update(struct.pack(\"&gt;d\", self.delta))\n        # Hash the operand\n        self.x._hash_into(hasher)\n\n    def __repr__(self):\n        return f\"huber({self.x!r}, delta={self.delta})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Huber._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash Huber including its delta parameter.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash Huber including its delta parameter.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(b\"Huber\")\n    # Hash delta as bytes\n    hasher.update(struct.pack(\"&gt;d\", self.delta))\n    # Hash the operand\n    self.x._hash_into(hasher)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Huber.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the operand but preserve delta parameter.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the operand but preserve delta parameter.\"\"\"\n    x = self.x.canonicalize()\n    return Huber(x, delta=self.delta)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Huber.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Huber penalty preserves the shape of x.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Huber penalty preserves the shape of x.\"\"\"\n    return self.x.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Index","title":"<code>Index</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Indexing and slicing operation for symbolic expressions.</p> <p>Represents indexing or slicing of an expression using NumPy-style indexing. Can be created using square bracket notation on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>base</code> <p>Expression to index into</p> <code>index</code> <p>Index specification (int, slice, or tuple of indices/slices)</p> Example <p>Define an Index expression:</p> <pre><code>x = ox.State(\"x\", shape=(10,))\ny = x[0:5]  # Creates Index(x, slice(0, 5))\nz = x[3]    # Creates Index(x, 3)\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Index(Expr):\n    \"\"\"Indexing and slicing operation for symbolic expressions.\n\n    Represents indexing or slicing of an expression using NumPy-style indexing.\n    Can be created using square bracket notation on Expr objects.\n\n    Attributes:\n        base: Expression to index into\n        index: Index specification (int, slice, or tuple of indices/slices)\n\n    Example:\n        Define an Index expression:\n\n            x = ox.State(\"x\", shape=(10,))\n            y = x[0:5]  # Creates Index(x, slice(0, 5))\n            z = x[3]    # Creates Index(x, 3)\n    \"\"\"\n\n    def __init__(self, base: Expr, index: Union[int, slice, tuple]):\n        \"\"\"Initialize an indexing operation.\n\n        Args:\n            base: Expression to index into\n            index: NumPy-style index (int, slice, or tuple of indices/slices)\n        \"\"\"\n        self.base = base\n        self.index = index\n\n    def children(self):\n        return [self.base]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize index by canonicalizing the base expression.\n\n        Returns:\n            Expr: Canonical form of the indexing expression\n        \"\"\"\n        base = self.base.canonicalize()\n        return Index(base, self.index)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Compute the shape after indexing.\"\"\"\n        base_shape = self.base.check_shape()\n        dummy = np.zeros(base_shape)\n        try:\n            result = dummy[self.index]\n        except Exception as e:\n            raise ValueError(f\"Bad index {self.index} for shape {base_shape}\") from e\n        return result.shape\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Index including its index specification.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Index\")\n        # Hash the index specification (convert to string for generality)\n        hasher.update(repr(self.index).encode())\n        # Hash the base expression\n        self.base._hash_into(hasher)\n\n    def __repr__(self):\n        return f\"{self.base!r}[{self.index!r}]\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Index._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash Index including its index specification.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash Index including its index specification.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(b\"Index\")\n    # Hash the index specification (convert to string for generality)\n    hasher.update(repr(self.index).encode())\n    # Hash the base expression\n    self.base._hash_into(hasher)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Index.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize index by canonicalizing the base expression.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the indexing expression</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize index by canonicalizing the base expression.\n\n    Returns:\n        Expr: Canonical form of the indexing expression\n    \"\"\"\n    base = self.base.canonicalize()\n    return Index(base, self.index)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Index.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Compute the shape after indexing.</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Compute the shape after indexing.\"\"\"\n    base_shape = self.base.check_shape()\n    dummy = np.zeros(base_shape)\n    try:\n        result = dummy[self.index]\n    except Exception as e:\n        raise ValueError(f\"Bad index {self.index} for shape {base_shape}\") from e\n    return result.shape\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Inequality","title":"<code>Inequality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Inequality constraint for optimization problems.</p> <p>Represents an inequality constraint: lhs &lt;= rhs. Can be created using the &lt;= operator on Expr objects.</p> Example <p>Define an Inequality constraint:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = x &lt;= 10  # Creates Inequality(x, Constant(10))\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class Inequality(Constraint):\n    \"\"\"Inequality constraint for optimization problems.\n\n    Represents an inequality constraint: lhs &lt;= rhs. Can be created using the &lt;=\n    operator on Expr objects.\n\n    Example:\n        Define an Inequality constraint:\n\n            x = ox.State(\"x\", shape=(3,))\n            constraint = x &lt;= 10  # Creates Inequality(x, Constant(10))\n    \"\"\"\n\n    def __repr__(self):\n        return f\"{self.lhs!r} &lt;= {self.rhs!r}\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Leaf","title":"<code>Leaf</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Base class for leaf nodes (terminal expressions) in the symbolic expression tree.</p> <p>Leaf nodes represent named symbolic variables that don't have child expressions. This includes Parameters, Variables, States, and Controls.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the leaf node</p> <code>_shape</code> <code>tuple</code> <p>Shape of the leaf node</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class Leaf(Expr):\n    \"\"\"\n    Base class for leaf nodes (terminal expressions) in the symbolic expression tree.\n\n    Leaf nodes represent named symbolic variables that don't have child expressions.\n    This includes Parameters, Variables, States, and Controls.\n\n    Attributes:\n        name (str): Name identifier for the leaf node\n        _shape (tuple): Shape of the leaf node\n    \"\"\"\n\n    def __init__(self, name: str, shape: tuple = ()):\n        \"\"\"Initialize a Leaf node.\n\n        Args:\n            name (str): Name identifier for the leaf node\n            shape (tuple): Shape of the leaf node\n        \"\"\"\n        super().__init__()\n        self.name = name\n        self._shape = shape\n\n    @property\n    def shape(self):\n        \"\"\"Get the shape of the leaf node.\n\n        Returns:\n            tuple: Shape of the leaf node\n        \"\"\"\n        return self._shape\n\n    def children(self):\n        \"\"\"Leaf nodes have no children.\n\n        Returns:\n            list: Empty list since leaf nodes are terminal\n        \"\"\"\n        return []\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Leaf nodes are already in canonical form.\n\n        Returns:\n            Expr: Returns self since leaf nodes are already canonical\n        \"\"\"\n        return self\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Return the shape of this leaf node.\n\n        Returns:\n            tuple: The shape of the leaf node\n        \"\"\"\n        return self._shape\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash leaf node by class name and shape.\n\n        This base implementation hashes the class name and shape. Subclasses\n        like Variable and Parameter override this to add their specific\n        canonical identifiers (_slice for Variables, value for Parameters).\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(self.__class__.__name__.encode())\n        hasher.update(str(self._shape).encode())\n\n    def __repr__(self):\n        \"\"\"String representation of the leaf node.\n\n        Returns:\n            str: A string describing the leaf node\n        \"\"\"\n        return f\"{self.__class__.__name__}('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Leaf.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Get the shape of the leaf node.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Shape of the leaf node</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Leaf._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash leaf node by class name and shape.</p> <p>This base implementation hashes the class name and shape. Subclasses like Variable and Parameter override this to add their specific canonical identifiers (_slice for Variables, value for Parameters).</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash leaf node by class name and shape.\n\n    This base implementation hashes the class name and shape. Subclasses\n    like Variable and Parameter override this to add their specific\n    canonical identifiers (_slice for Variables, value for Parameters).\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(self.__class__.__name__.encode())\n    hasher.update(str(self._shape).encode())\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Leaf.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Leaf nodes are already in canonical form.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Returns self since leaf nodes are already canonical</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Leaf nodes are already in canonical form.\n\n    Returns:\n        Expr: Returns self since leaf nodes are already canonical\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Leaf.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Return the shape of this leaf node.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The shape of the leaf node</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Return the shape of this leaf node.\n\n    Returns:\n        tuple: The shape of the leaf node\n    \"\"\"\n    return self._shape\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Leaf.children","title":"<code>children()</code>","text":"<p>Leaf nodes have no children.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Empty list since leaf nodes are terminal</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def children(self):\n    \"\"\"Leaf nodes have no children.\n\n    Returns:\n        list: Empty list since leaf nodes are terminal\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Log","title":"<code>Log</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise natural logarithm function for symbolic expressions.</p> <p>Computes the natural logarithm (base e) of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply logarithm to</p> Example <p>Define a Log expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\nlog_x = Log(x)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Log(Expr):\n    \"\"\"Element-wise natural logarithm function for symbolic expressions.\n\n    Computes the natural logarithm (base e) of each element in the operand.\n    Preserves the shape of the input expression.\n\n    Attributes:\n        operand: Expression to apply logarithm to\n\n    Example:\n        Define a Log expression:\n\n            x = Variable(\"x\", shape=(3,))\n            log_x = Log(x)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a natural logarithm operation.\n\n        Args:\n            operand: Expression to apply logarithm to\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Log(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Log preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"log({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Log.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Log preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Log preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.LogSumExp","title":"<code>LogSumExp</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Log-sum-exp function for symbolic expressions.</p> <p>Computes the log-sum-exp (LSE) of multiple operands, which is a smooth, differentiable approximation to the maximum function. The log-sum-exp is defined as:</p> <pre><code>logsumexp(x\u2081, x\u2082, ..., x\u2099) = log(exp(x\u2081) + exp(x\u2082) + ... + exp(x\u2099))\n</code></pre> <p>This function is numerically stable and is commonly used in optimization as a smooth alternative to the non-differentiable maximum function. It satisfies the inequality:</p> <pre><code>max(x\u2081, x\u2082, ..., x\u2099) \u2264 logsumexp(x\u2081, x\u2082, ..., x\u2099) \u2264 max(x\u2081, x\u2082, ..., x\u2099) + log(n)\n</code></pre> <p>The log-sum-exp is convex and is particularly useful for: - Smooth approximations of maximum constraints - Soft maximum operations in neural networks - Relaxing logical OR operations in STL specifications</p> <p>Attributes:</p> Name Type Description <code>operands</code> <p>List of expressions to compute log-sum-exp over</p> Example <p>Define a LogSumExp expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(3,))\nz = Variable(\"z\", shape=(3,))\nlse = LogSumExp(x, y, z)  # Smooth approximation to max(x, y, z)\n</code></pre> <p>Use in STL relaxation:</p> <pre><code>import openscvx as ox\n# Relax: Or(\u03c6\u2081, \u03c6\u2082) using log-sum-exp\nphi1 = ox.Norm(x - goal1) - 0.5\nphi2 = ox.Norm(x - goal2) - 0.5\nrelaxed_or = LogSumExp(phi1, phi2) &gt;= 0\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class LogSumExp(Expr):\n    \"\"\"Log-sum-exp function for symbolic expressions.\n\n    Computes the log-sum-exp (LSE) of multiple operands, which is a smooth,\n    differentiable approximation to the maximum function. The log-sum-exp is\n    defined as:\n\n        logsumexp(x\u2081, x\u2082, ..., x\u2099) = log(exp(x\u2081) + exp(x\u2082) + ... + exp(x\u2099))\n\n    This function is numerically stable and is commonly used in optimization\n    as a smooth alternative to the non-differentiable maximum function. It\n    satisfies the inequality:\n\n        max(x\u2081, x\u2082, ..., x\u2099) \u2264 logsumexp(x\u2081, x\u2082, ..., x\u2099) \u2264 max(x\u2081, x\u2082, ..., x\u2099) + log(n)\n\n    The log-sum-exp is convex and is particularly useful for:\n    - Smooth approximations of maximum constraints\n    - Soft maximum operations in neural networks\n    - Relaxing logical OR operations in STL specifications\n\n    Attributes:\n        operands: List of expressions to compute log-sum-exp over\n\n    Example:\n        Define a LogSumExp expression:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(3,))\n            z = Variable(\"z\", shape=(3,))\n            lse = LogSumExp(x, y, z)  # Smooth approximation to max(x, y, z)\n\n        Use in STL relaxation:\n\n            import openscvx as ox\n            # Relax: Or(\u03c6\u2081, \u03c6\u2082) using log-sum-exp\n            phi1 = ox.Norm(x - goal1) - 0.5\n            phi2 = ox.Norm(x - goal2) - 0.5\n            relaxed_or = LogSumExp(phi1, phi2) &gt;= 0\n    \"\"\"\n\n    def __init__(self, *args):\n        \"\"\"Initialize a log-sum-exp operation.\n\n        Args:\n            *args: Two or more expressions to compute log-sum-exp over\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(args) &lt; 2:\n            raise ValueError(\"LogSumExp requires two or more operands\")\n        self.operands = [to_expr(a) for a in args]\n\n    def children(self):\n        return list(self.operands)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize log-sum-exp: flatten nested LogSumExp, fold constants.\"\"\"\n        from .expr import Constant\n\n        operands = []\n        const_vals = []\n\n        for op in self.operands:\n            c = op.canonicalize()\n            if isinstance(c, LogSumExp):\n                operands.extend(c.operands)\n            elif isinstance(c, Constant):\n                const_vals.append(c.value)\n            else:\n                operands.append(c)\n\n        # If we have constants, compute their log-sum-exp and keep it\n        if const_vals:\n            # For constants, we can compute logsumexp directly\n            # logsumexp(c1, c2, ..., cn) = log(sum(exp(ci)))\n            exp_vals = [np.exp(v) for v in const_vals]\n            lse_const = np.log(np.sum(exp_vals))\n            operands.append(Constant(lse_const))\n\n        if not operands:\n            raise ValueError(\"LogSumExp must have at least one operand after canonicalization\")\n        if len(operands) == 1:\n            return operands[0]\n        return LogSumExp(*operands)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"LogSumExp broadcasts shapes like NumPy, preserving element-wise shape.\"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"LogSumExp shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        inner = \", \".join(repr(op) for op in self.operands)\n        return f\"logsumexp({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.LogSumExp.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize log-sum-exp: flatten nested LogSumExp, fold constants.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize log-sum-exp: flatten nested LogSumExp, fold constants.\"\"\"\n    from .expr import Constant\n\n    operands = []\n    const_vals = []\n\n    for op in self.operands:\n        c = op.canonicalize()\n        if isinstance(c, LogSumExp):\n            operands.extend(c.operands)\n        elif isinstance(c, Constant):\n            const_vals.append(c.value)\n        else:\n            operands.append(c)\n\n    # If we have constants, compute their log-sum-exp and keep it\n    if const_vals:\n        # For constants, we can compute logsumexp directly\n        # logsumexp(c1, c2, ..., cn) = log(sum(exp(ci)))\n        exp_vals = [np.exp(v) for v in const_vals]\n        lse_const = np.log(np.sum(exp_vals))\n        operands.append(Constant(lse_const))\n\n    if not operands:\n        raise ValueError(\"LogSumExp must have at least one operand after canonicalization\")\n    if len(operands) == 1:\n        return operands[0]\n    return LogSumExp(*operands)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.LogSumExp.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>LogSumExp broadcasts shapes like NumPy, preserving element-wise shape.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"LogSumExp broadcasts shapes like NumPy, preserving element-wise shape.\"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"LogSumExp shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.MatMul","title":"<code>MatMul</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Matrix multiplication operation for symbolic expressions.</p> <p>Represents matrix multiplication following standard linear algebra rules. Can be created using the @ operator on Expr objects. Handles: - Matrix @ Matrix: (m,n) @ (n,k) -&gt; (m,k) - Matrix @ Vector: (m,n) @ (n,) -&gt; (m,) - Vector @ Matrix: (m,) @ (m,n) -&gt; (n,) - Vector @ Vector: (m,) @ (m,) -&gt; scalar</p> <p>Attributes:</p> Name Type Description <code>left</code> <p>Left-hand side expression</p> <code>right</code> <p>Right-hand side expression</p> Example <p>Define a MatMul expression:</p> <pre><code>A = ox.State(\"A\", shape=(3, 4))\nx = ox.State(\"x\", shape=(4,))\ny = A @ x  # Creates MatMul(A, x), result shape (3,)\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class MatMul(Expr):\n    \"\"\"Matrix multiplication operation for symbolic expressions.\n\n    Represents matrix multiplication following standard linear algebra rules.\n    Can be created using the @ operator on Expr objects. Handles:\n    - Matrix @ Matrix: (m,n) @ (n,k) -&gt; (m,k)\n    - Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n    - Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n    - Vector @ Vector: (m,) @ (m,) -&gt; scalar\n\n    Attributes:\n        left: Left-hand side expression\n        right: Right-hand side expression\n\n    Example:\n        Define a MatMul expression:\n\n            A = ox.State(\"A\", shape=(3, 4))\n            x = ox.State(\"x\", shape=(4,))\n            y = A @ x  # Creates MatMul(A, x), result shape (3,)\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\"Initialize a matrix multiplication operation.\n\n        Args:\n            left: Left-hand side expression for matrix multiplication\n            right: Right-hand side expression for matrix multiplication\n        \"\"\"\n        self.left = left\n        self.right = right\n\n    def children(self):\n        return [self.left, self.right]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        left = self.left.canonicalize()\n        right = self.right.canonicalize()\n        return MatMul(left, right)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check matrix multiplication shape compatibility and return result shape.\"\"\"\n        L, R = self.left.check_shape(), self.right.check_shape()\n\n        # Handle different matmul cases:\n        # Matrix @ Matrix: (m,n) @ (n,k) -&gt; (m,k)\n        # Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n        # Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n        # Vector @ Vector: (m,) @ (m,) -&gt; ()\n\n        if len(L) == 0 or len(R) == 0:\n            raise ValueError(f\"MatMul requires at least 1D operands: {L} @ {R}\")\n\n        if len(L) == 1 and len(R) == 1:\n            # Vector @ Vector -&gt; scalar\n            if L[0] != R[0]:\n                raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n            return ()\n        elif len(L) == 1:\n            # Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n            if len(R) &lt; 2 or L[0] != R[-2]:\n                raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n            return R[-1:]\n        elif len(R) == 1:\n            # Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n            if len(L) &lt; 2 or L[-1] != R[0]:\n                raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n            return L[:-1]\n        else:\n            # Matrix @ Matrix: (...,m,n) @ (...,n,k) -&gt; (...,m,k)\n            if len(L) &lt; 2 or len(R) &lt; 2 or L[-1] != R[-2]:\n                raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n            return L[:-1] + (R[-1],)\n\n    def __repr__(self):\n        return f\"({self.left!r} * {self.right!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.MatMul.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check matrix multiplication shape compatibility and return result shape.</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check matrix multiplication shape compatibility and return result shape.\"\"\"\n    L, R = self.left.check_shape(), self.right.check_shape()\n\n    # Handle different matmul cases:\n    # Matrix @ Matrix: (m,n) @ (n,k) -&gt; (m,k)\n    # Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n    # Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n    # Vector @ Vector: (m,) @ (m,) -&gt; ()\n\n    if len(L) == 0 or len(R) == 0:\n        raise ValueError(f\"MatMul requires at least 1D operands: {L} @ {R}\")\n\n    if len(L) == 1 and len(R) == 1:\n        # Vector @ Vector -&gt; scalar\n        if L[0] != R[0]:\n            raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n        return ()\n    elif len(L) == 1:\n        # Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n        if len(R) &lt; 2 or L[0] != R[-2]:\n            raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n        return R[-1:]\n    elif len(R) == 1:\n        # Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n        if len(L) &lt; 2 or L[-1] != R[0]:\n            raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n        return L[:-1]\n    else:\n        # Matrix @ Matrix: (...,m,n) @ (...,n,k) -&gt; (...,m,k)\n        if len(L) &lt; 2 or len(R) &lt; 2 or L[-1] != R[-2]:\n            raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n        return L[:-1] + (R[-1],)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Max","title":"<code>Max</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise maximum function for symbolic expressions.</p> <p>Computes the element-wise maximum across two or more operands. Supports broadcasting following NumPy rules. During canonicalization, nested Max operations are flattened and constants are folded.</p> <p>Attributes:</p> Name Type Description <code>operands</code> <p>List of expressions to compute maximum over</p> Example <p>Define a Max expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(3,))\nmax_xy = Max(x, y, 0)  # Element-wise max(x, y, 0)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Max(Expr):\n    \"\"\"Element-wise maximum function for symbolic expressions.\n\n    Computes the element-wise maximum across two or more operands. Supports\n    broadcasting following NumPy rules. During canonicalization, nested Max\n    operations are flattened and constants are folded.\n\n    Attributes:\n        operands: List of expressions to compute maximum over\n\n    Example:\n        Define a Max expression:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(3,))\n            max_xy = Max(x, y, 0)  # Element-wise max(x, y, 0)\n    \"\"\"\n\n    def __init__(self, *args):\n        \"\"\"Initialize a maximum operation.\n\n        Args:\n            *args: Two or more expressions to compute maximum over\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(args) &lt; 2:\n            raise ValueError(\"Max requires two or more operands\")\n        self.operands = [to_expr(a) for a in args]\n\n    def children(self):\n        return list(self.operands)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize max: flatten nested Max, fold constants.\"\"\"\n        from .expr import Constant\n\n        operands = []\n        const_vals = []\n\n        for op in self.operands:\n            c = op.canonicalize()\n            if isinstance(c, Max):\n                operands.extend(c.operands)\n            elif isinstance(c, Constant):\n                const_vals.append(c.value)\n            else:\n                operands.append(c)\n\n        # If we have constants, compute their max and keep it\n        if const_vals:\n            max_const = np.maximum.reduce(const_vals)\n            operands.append(Constant(max_const))\n\n        if not operands:\n            raise ValueError(\"Max must have at least one operand after canonicalization\")\n        if len(operands) == 1:\n            return operands[0]\n        return Max(*operands)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Max broadcasts shapes like NumPy.\"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Max shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        inner = \", \".join(repr(op) for op in self.operands)\n        return f\"max({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Max.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize max: flatten nested Max, fold constants.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize max: flatten nested Max, fold constants.\"\"\"\n    from .expr import Constant\n\n    operands = []\n    const_vals = []\n\n    for op in self.operands:\n        c = op.canonicalize()\n        if isinstance(c, Max):\n            operands.extend(c.operands)\n        elif isinstance(c, Constant):\n            const_vals.append(c.value)\n        else:\n            operands.append(c)\n\n    # If we have constants, compute their max and keep it\n    if const_vals:\n        max_const = np.maximum.reduce(const_vals)\n        operands.append(Constant(max_const))\n\n    if not operands:\n        raise ValueError(\"Max must have at least one operand after canonicalization\")\n    if len(operands) == 1:\n        return operands[0]\n    return Max(*operands)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Max.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Max broadcasts shapes like NumPy.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Max broadcasts shapes like NumPy.\"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Max shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Mul","title":"<code>Mul</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise multiplication operation for symbolic expressions.</p> <p>Represents element-wise (Hadamard) multiplication of two or more expressions. Supports broadcasting following NumPy rules. Can be created using the * operator on Expr objects. For matrix multiplication, use MatMul or the @ operator.</p> <p>Attributes:</p> Name Type Description <code>factors</code> <p>List of expression operands to multiply together</p> Example <p>Define a Mul expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(3,))\nz = x * y * 2  # Creates Mul(x, y, Constant(2))\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Mul(Expr):\n    \"\"\"Element-wise multiplication operation for symbolic expressions.\n\n    Represents element-wise (Hadamard) multiplication of two or more expressions.\n    Supports broadcasting following NumPy rules. Can be created using the * operator\n    on Expr objects. For matrix multiplication, use MatMul or the @ operator.\n\n    Attributes:\n        factors: List of expression operands to multiply together\n\n    Example:\n        Define a Mul expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(3,))\n            z = x * y * 2  # Creates Mul(x, y, Constant(2))\n    \"\"\"\n\n    def __init__(self, *args):\n        \"\"\"Initialize an element-wise multiplication operation.\n\n        Args:\n            *args: Two or more expressions to multiply together\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(args) &lt; 2:\n            raise ValueError(\"Mul requires two or more operands\")\n        self.factors = [to_expr(a) for a in args]\n\n    def children(self):\n        return list(self.factors)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize multiplication: flatten, fold constants, and eliminating ones.\n\n        Returns:\n            Expr: Canonical form of the multiplication expression\n        \"\"\"\n        factors = []\n        const_vals = []\n\n        for f in self.factors:\n            c = f.canonicalize()\n            if isinstance(c, Mul):\n                factors.extend(c.factors)\n            elif isinstance(c, Constant):\n                const_vals.append(c.value)\n            else:\n                factors.append(c)\n\n        if const_vals:\n            # Multiply constants element-wise (broadcasting), not reducing with prod\n            prod = const_vals[0]\n            for val in const_vals[1:]:\n                prod = prod * val\n\n            # If prod != 1, keep it\n            # Check both scalar and array cases\n            is_identity = False\n            if isinstance(prod, np.ndarray):\n                is_identity = np.all(prod == 1)\n            else:\n                is_identity = prod == 1\n\n            if not is_identity:\n                factors.append(Constant(prod))\n\n        if not factors:\n            return Constant(np.array(1))\n        if len(factors) == 1:\n            return factors[0]\n        return Mul(*factors)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n\n        Returns:\n            tuple: The broadcasted shape of all operands\n\n        Raises:\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Mul shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        inner = \" * \".join(repr(e) for e in self.factors)\n        return f\"({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Mul.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize multiplication: flatten, fold constants, and eliminating ones.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the multiplication expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize multiplication: flatten, fold constants, and eliminating ones.\n\n    Returns:\n        Expr: Canonical form of the multiplication expression\n    \"\"\"\n    factors = []\n    const_vals = []\n\n    for f in self.factors:\n        c = f.canonicalize()\n        if isinstance(c, Mul):\n            factors.extend(c.factors)\n        elif isinstance(c, Constant):\n            const_vals.append(c.value)\n        else:\n            factors.append(c)\n\n    if const_vals:\n        # Multiply constants element-wise (broadcasting), not reducing with prod\n        prod = const_vals[0]\n        for val in const_vals[1:]:\n            prod = prod * val\n\n        # If prod != 1, keep it\n        # Check both scalar and array cases\n        is_identity = False\n        if isinstance(prod, np.ndarray):\n            is_identity = np.all(prod == 1)\n        else:\n            is_identity = prod == 1\n\n        if not is_identity:\n            factors.append(Constant(prod))\n\n    if not factors:\n        return Constant(np.array(1))\n    if len(factors) == 1:\n        return factors[0]\n    return Mul(*factors)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Mul.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check shape compatibility and compute broadcasted result shape like NumPy.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The broadcasted shape of all operands</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n\n    Returns:\n        tuple: The broadcasted shape of all operands\n\n    Raises:\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Mul shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Neg","title":"<code>Neg</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Negation operation for symbolic expressions.</p> <p>Represents element-wise negation (unary minus). Can be created using the unary - operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to negate</p> Example <p>Define a Neg expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = -x  # Creates Neg(x)\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Neg(Expr):\n    \"\"\"Negation operation for symbolic expressions.\n\n    Represents element-wise negation (unary minus). Can be created using the\n    unary - operator on Expr objects.\n\n    Attributes:\n        operand: Expression to negate\n\n    Example:\n        Define a Neg expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = -x  # Creates Neg(x)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a negation operation.\n\n        Args:\n            operand: Expression to negate\n        \"\"\"\n        self.operand = operand\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize negation: fold constant negations.\n\n        Returns:\n            Expr: Canonical form of the negation expression\n        \"\"\"\n        o = self.operand.canonicalize()\n        if isinstance(o, Constant):\n            return Constant(-o.value)\n        return Neg(o)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Negation preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"(-{self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Neg.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize negation: fold constant negations.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the negation expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize negation: fold constant negations.\n\n    Returns:\n        Expr: Canonical form of the negation expression\n    \"\"\"\n    o = self.operand.canonicalize()\n    if isinstance(o, Constant):\n        return Constant(-o.value)\n    return Neg(o)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Neg.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Negation preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Negation preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodalConstraint","title":"<code>NodalConstraint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Wrapper for constraints enforced only at specific discrete trajectory nodes.</p> <p>NodalConstraint allows selective enforcement of constraints at specific time points (nodes) in a discretized trajectory, rather than enforcing them at every node. This is useful for:</p> <ul> <li>Specifying waypoint constraints (e.g., pass through point X at node 10)</li> <li>Boundary conditions at non-standard locations</li> <li>Reducing computational cost by checking constraints less frequently</li> <li>Enforcing periodic constraints (e.g., every 5th node)</li> </ul> <p>The wrapper maintains clean separation between the constraint's mathematical definition and the specification of where it should be applied during optimization.</p> Note <p>Bare Constraint objects (without .at() or .over()) are automatically converted to NodalConstraints applied at all nodes during preprocessing.</p> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (Equality or Inequality) to enforce</p> <code>nodes</code> <p>List of integer node indices where the constraint is enforced</p> Example <p>Enforce position constraint only at nodes 0, 10, and 20:</p> <pre><code>x = State(\"x\", shape=(3,))\ntarget = [10, 5, 0]\nconstraint = (x == target).at([0, 10, 20])\n</code></pre> <p>Equivalent using NodalConstraint directly:</p> <pre><code>constraint = NodalConstraint(x == target, nodes=[0, 10, 20])\n</code></pre> <p>Periodic constraint enforcement (every 10th node):</p> <pre><code>velocity_limit = (vel &lt;= 100).at(list(range(0, 100, 10)))\n</code></pre> <p>Bare constraints are automatically applied at all nodes. These are equivalent:</p> <pre><code>constraint1 = vel &lt;= 100  # Auto-converted to all nodes\nconstraint2 = (vel &lt;= 100).at(list(range(n_nodes)))\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class NodalConstraint(Expr):\n    \"\"\"Wrapper for constraints enforced only at specific discrete trajectory nodes.\n\n    NodalConstraint allows selective enforcement of constraints at specific time points\n    (nodes) in a discretized trajectory, rather than enforcing them at every node.\n    This is useful for:\n\n    - Specifying waypoint constraints (e.g., pass through point X at node 10)\n    - Boundary conditions at non-standard locations\n    - Reducing computational cost by checking constraints less frequently\n    - Enforcing periodic constraints (e.g., every 5th node)\n\n    The wrapper maintains clean separation between the constraint's mathematical\n    definition and the specification of where it should be applied during optimization.\n\n    Note:\n        Bare Constraint objects (without .at() or .over()) are automatically converted\n        to NodalConstraints applied at all nodes during preprocessing.\n\n    Attributes:\n        constraint: The wrapped Constraint (Equality or Inequality) to enforce\n        nodes: List of integer node indices where the constraint is enforced\n\n    Example:\n        Enforce position constraint only at nodes 0, 10, and 20:\n\n            x = State(\"x\", shape=(3,))\n            target = [10, 5, 0]\n            constraint = (x == target).at([0, 10, 20])\n\n        Equivalent using NodalConstraint directly:\n\n            constraint = NodalConstraint(x == target, nodes=[0, 10, 20])\n\n        Periodic constraint enforcement (every 10th node):\n\n            velocity_limit = (vel &lt;= 100).at(list(range(0, 100, 10)))\n\n        Bare constraints are automatically applied at all nodes.\n        These are equivalent:\n\n            constraint1 = vel &lt;= 100  # Auto-converted to all nodes\n            constraint2 = (vel &lt;= 100).at(list(range(n_nodes)))\n    \"\"\"\n\n    def __init__(self, constraint: Constraint, nodes: list[int]):\n        \"\"\"Initialize a NodalConstraint.\n\n        Args:\n            constraint: The Constraint (Equality or Inequality) to enforce at specified nodes\n            nodes: List of integer node indices where the constraint should be enforced.\n                Automatically converts numpy integers to Python integers.\n\n        Raises:\n            TypeError: If constraint is not a Constraint instance\n            TypeError: If nodes is not a list\n            TypeError: If any node index is not an integer\n\n        Note:\n            Bounds checking for cross-node constraints (those containing NodeReference)\n            is performed later in the pipeline when N is known, via\n            validate_cross_node_constraint_bounds() in preprocessing.py.\n        \"\"\"\n        if not isinstance(constraint, Constraint):\n            raise TypeError(\"NodalConstraint must wrap a Constraint\")\n        if not isinstance(nodes, list):\n            raise TypeError(\"nodes must be a list of integers\")\n\n        # Convert numpy integers to Python integers\n        converted_nodes = []\n        for n in nodes:\n            if isinstance(n, np.integer):\n                converted_nodes.append(int(n))\n            elif isinstance(n, int):\n                converted_nodes.append(n)\n            else:\n                raise TypeError(\"all node indices must be integers\")\n\n        self.constraint = constraint\n        self.nodes = converted_nodes\n\n    def children(self):\n        \"\"\"Return the wrapped constraint as the only child.\n\n        Returns:\n            list: Single-element list containing the wrapped constraint\n        \"\"\"\n        return [self.constraint]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the wrapped constraint while preserving node specification.\n\n        Returns:\n            NodalConstraint: A new NodalConstraint with canonicalized inner constraint\n        \"\"\"\n        canon_constraint = self.constraint.canonicalize()\n        return NodalConstraint(canon_constraint, self.nodes)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Validate the wrapped constraint's shape.\n\n        NodalConstraint wraps a constraint without changing its computational meaning,\n        only specifying where it should be applied. Like all constraints, it produces\n        a scalar result.\n\n        Returns:\n            tuple: Empty tuple () representing scalar shape\n        \"\"\"\n        # Validate the wrapped constraint's shape\n        self.constraint.check_shape()\n\n        # NodalConstraint produces a scalar like any constraint\n        return ()\n\n    def convex(self) -&gt; \"NodalConstraint\":\n        \"\"\"Mark the underlying constraint as convex for CVXPy lowering.\n\n        Returns:\n            Self with underlying constraint's convex flag set to True (enables method chaining)\n\n        Example:\n            Mark a constraint as convex:\n                constraint = (x &lt;= 10).at([0, 5, 10]).convex()\n        \"\"\"\n        self.constraint.convex()\n        return self\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash NodalConstraint including its node list.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"NodalConstraint\")\n        # Hash the nodes list\n        for node in self.nodes:\n            hasher.update(struct.pack(\"&gt;i\", node))\n        hasher.update(b\"|\")  # Separator to distinguish node counts\n        # Hash the wrapped constraint\n        self.constraint._hash_into(hasher)\n\n    def __repr__(self):\n        \"\"\"String representation of the NodalConstraint.\n\n        Returns:\n            str: String showing the wrapped constraint and node indices\n        \"\"\"\n        return f\"NodalConstraint({self.constraint!r}, nodes={self.nodes})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodalConstraint._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash NodalConstraint including its node list.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash NodalConstraint including its node list.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(b\"NodalConstraint\")\n    # Hash the nodes list\n    for node in self.nodes:\n        hasher.update(struct.pack(\"&gt;i\", node))\n    hasher.update(b\"|\")  # Separator to distinguish node counts\n    # Hash the wrapped constraint\n    self.constraint._hash_into(hasher)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodalConstraint.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the wrapped constraint while preserving node specification.</p> <p>Returns:</p> Name Type Description <code>NodalConstraint</code> <code>Expr</code> <p>A new NodalConstraint with canonicalized inner constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the wrapped constraint while preserving node specification.\n\n    Returns:\n        NodalConstraint: A new NodalConstraint with canonicalized inner constraint\n    \"\"\"\n    canon_constraint = self.constraint.canonicalize()\n    return NodalConstraint(canon_constraint, self.nodes)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodalConstraint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the wrapped constraint's shape.</p> <p>NodalConstraint wraps a constraint without changing its computational meaning, only specifying where it should be applied. Like all constraints, it produces a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Validate the wrapped constraint's shape.\n\n    NodalConstraint wraps a constraint without changing its computational meaning,\n    only specifying where it should be applied. Like all constraints, it produces\n    a scalar result.\n\n    Returns:\n        tuple: Empty tuple () representing scalar shape\n    \"\"\"\n    # Validate the wrapped constraint's shape\n    self.constraint.check_shape()\n\n    # NodalConstraint produces a scalar like any constraint\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodalConstraint.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def children(self):\n    \"\"\"Return the wrapped constraint as the only child.\n\n    Returns:\n        list: Single-element list containing the wrapped constraint\n    \"\"\"\n    return [self.constraint]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodalConstraint.convex","title":"<code>convex() -&gt; NodalConstraint</code>","text":"<p>Mark the underlying constraint as convex for CVXPy lowering.</p> <p>Returns:</p> Type Description <code>NodalConstraint</code> <p>Self with underlying constraint's convex flag set to True (enables method chaining)</p> Example <p>Mark a constraint as convex:     constraint = (x &lt;= 10).at([0, 5, 10]).convex()</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def convex(self) -&gt; \"NodalConstraint\":\n    \"\"\"Mark the underlying constraint as convex for CVXPy lowering.\n\n    Returns:\n        Self with underlying constraint's convex flag set to True (enables method chaining)\n\n    Example:\n        Mark a constraint as convex:\n            constraint = (x &lt;= 10).at([0, 5, 10]).convex()\n    \"\"\"\n    self.constraint.convex()\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodeReference","title":"<code>NodeReference</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Reference to a variable at a specific trajectory node.</p> <p>NodeReference enables inter-node constraints by allowing you to reference the value of a state or control variable at a specific discrete time point (node) in the trajectory. This is essential for expressing temporal relationships such as:</p> <ul> <li>Rate limits and smoothness constraints</li> <li>Multi-step dependencies and recurrence relations</li> <li>Constraints coupling specific nodes</li> </ul> <p>Attributes:</p> Name Type Description <code>base</code> <p>The expression (typically a Leaf like State or Control) being referenced</p> <code>node_idx</code> <p>Trajectory node index (integer, can be negative for end-indexing)</p> Example <p>Rate limit across trajectory:</p> <pre><code>position = State(\"pos\", shape=(3,))\n\n# Create rate limit constraints for all nodes\nconstraints = [\n    (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n    for k in range(1, N)\n]\n</code></pre> <p>Multi-step dependency:</p> <pre><code>state = State(\"x\", shape=(1,))\n\n# Fibonacci-like recurrence at each node\nconstraints = [\n    (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n    for k in range(2, N)\n]\n</code></pre> <p>Coupling specific nodes:</p> <pre><code># Constrain distance between nodes 5 and 10\ncoupling = (position.at(10) - position.at(5) &lt;= threshold).at([10])\n</code></pre> Performance Note <p>Cross-node constraints use dense Jacobian storage. For details on memory usage and performance implications, see LoweredCrossNodeConstraint documentation.</p> Note <p>NodeReference is typically created via the <code>.at(k)</code> method on expressions rather than constructed directly.</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class NodeReference(Expr):\n    \"\"\"Reference to a variable at a specific trajectory node.\n\n    NodeReference enables inter-node constraints by allowing you to reference\n    the value of a state or control variable at a specific discrete time point\n    (node) in the trajectory. This is essential for expressing temporal relationships\n    such as:\n\n    - Rate limits and smoothness constraints\n    - Multi-step dependencies and recurrence relations\n    - Constraints coupling specific nodes\n\n    Attributes:\n        base: The expression (typically a Leaf like State or Control) being referenced\n        node_idx: Trajectory node index (integer, can be negative for end-indexing)\n\n    Example:\n        Rate limit across trajectory:\n\n            position = State(\"pos\", shape=(3,))\n\n            # Create rate limit constraints for all nodes\n            constraints = [\n                (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n                for k in range(1, N)\n            ]\n\n        Multi-step dependency:\n\n            state = State(\"x\", shape=(1,))\n\n            # Fibonacci-like recurrence at each node\n            constraints = [\n                (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n                for k in range(2, N)\n            ]\n\n        Coupling specific nodes:\n\n            # Constrain distance between nodes 5 and 10\n            coupling = (position.at(10) - position.at(5) &lt;= threshold).at([10])\n\n    Performance Note:\n        Cross-node constraints use dense Jacobian storage. For details on memory\n        usage and performance implications, see LoweredCrossNodeConstraint documentation.\n\n    Note:\n        NodeReference is typically created via the `.at(k)` method on expressions\n        rather than constructed directly.\n    \"\"\"\n\n    def __init__(self, base: Expr, node_idx: int):\n        \"\"\"Initialize a NodeReference.\n\n        Args:\n            base: Expression to reference at a specific node (typically a Leaf)\n            node_idx: Absolute trajectory node index (integer)\n                     Supports negative indexing (e.g., -1 for last node)\n\n        Raises:\n            TypeError: If node_idx is not an integer\n        \"\"\"\n        if not isinstance(node_idx, int):\n            raise TypeError(f\"Node index must be an integer, got {type(node_idx).__name__}\")\n\n        self.node_idx = node_idx\n        self.base = base\n\n    def children(self):\n        \"\"\"Return the base expression as the only child.\n\n        Returns:\n            list: Single-element list containing the base expression\n        \"\"\"\n        return [self.base]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize by canonicalizing the base expression.\n\n        Returns:\n            NodeReference: A new NodeReference with canonicalized base\n        \"\"\"\n        canon_base = self.base.canonicalize()\n        return NodeReference(canon_base, self.node_idx)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Return the shape of the base expression.\n\n        NodeReference doesn't change the shape of the underlying expression,\n        it just references it at a specific time point.\n\n        Returns:\n            tuple: The shape of the base expression\n        \"\"\"\n        return self.base.check_shape()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash NodeReference including its node index.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"NodeReference\")\n        # Hash the node index (signed int)\n        hasher.update(struct.pack(\"&gt;i\", self.node_idx))\n        # Hash the base expression\n        self.base._hash_into(hasher)\n\n    def __repr__(self):\n        \"\"\"String representation of the NodeReference.\n\n        Returns:\n            str: String showing the base expression and node index\n        \"\"\"\n        return f\"{self.base!r}.at({self.node_idx})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodeReference._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash NodeReference including its node index.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash NodeReference including its node index.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(b\"NodeReference\")\n    # Hash the node index (signed int)\n    hasher.update(struct.pack(\"&gt;i\", self.node_idx))\n    # Hash the base expression\n    self.base._hash_into(hasher)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodeReference.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize by canonicalizing the base expression.</p> <p>Returns:</p> Name Type Description <code>NodeReference</code> <code>Expr</code> <p>A new NodeReference with canonicalized base</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize by canonicalizing the base expression.\n\n    Returns:\n        NodeReference: A new NodeReference with canonicalized base\n    \"\"\"\n    canon_base = self.base.canonicalize()\n    return NodeReference(canon_base, self.node_idx)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodeReference.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Return the shape of the base expression.</p> <p>NodeReference doesn't change the shape of the underlying expression, it just references it at a specific time point.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The shape of the base expression</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Return the shape of the base expression.\n\n    NodeReference doesn't change the shape of the underlying expression,\n    it just references it at a specific time point.\n\n    Returns:\n        tuple: The shape of the base expression\n    \"\"\"\n    return self.base.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodeReference.children","title":"<code>children()</code>","text":"<p>Return the base expression as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the base expression</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def children(self):\n    \"\"\"Return the base expression as the only child.\n\n    Returns:\n        list: Single-element list containing the base expression\n    \"\"\"\n    return [self.base]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Norm","title":"<code>Norm</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Norm operation for symbolic expressions (reduction to scalar).</p> <p>Computes the norm of an expression according to the specified order parameter. This is a reduction operation that always produces a scalar result regardless of the input shape. Supports various norm types following NumPy/SciPy conventions.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to compute norm of</p> <code>ord</code> <p>Norm order specification (default: \"fro\" for Frobenius norm) - \"fro\": Frobenius norm (default) - \"inf\": Infinity norm - 1: L1 norm (sum of absolute values) - 2: L2 norm (Euclidean norm) - Other values as supported by the backend</p> Example <p>Define Norms:</p> <pre><code>x = Variable(\"x\", shape=(3,))\neuclidean_norm = Norm(x, ord=2)  # L2 norm, result is scalar\nA = Variable(\"A\", shape=(3, 4))\nfrobenius_norm = Norm(A)  # Frobenius norm, result is scalar\n</code></pre> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>class Norm(Expr):\n    \"\"\"Norm operation for symbolic expressions (reduction to scalar).\n\n    Computes the norm of an expression according to the specified order parameter.\n    This is a reduction operation that always produces a scalar result regardless\n    of the input shape. Supports various norm types following NumPy/SciPy conventions.\n\n    Attributes:\n        operand: Expression to compute norm of\n        ord: Norm order specification (default: \"fro\" for Frobenius norm)\n            - \"fro\": Frobenius norm (default)\n            - \"inf\": Infinity norm\n            - 1: L1 norm (sum of absolute values)\n            - 2: L2 norm (Euclidean norm)\n            - Other values as supported by the backend\n\n    Example:\n        Define Norms:\n\n            x = Variable(\"x\", shape=(3,))\n            euclidean_norm = Norm(x, ord=2)  # L2 norm, result is scalar\n            A = Variable(\"A\", shape=(3, 4))\n            frobenius_norm = Norm(A)  # Frobenius norm, result is scalar\n    \"\"\"\n\n    def __init__(self, operand, ord=\"fro\"):\n        \"\"\"Initialize a norm operation.\n\n        Args:\n            operand: Expression to compute norm of\n            ord: Norm order specification (default: \"fro\")\n        \"\"\"\n        self.operand = to_expr(operand)\n        self.ord = ord  # Can be \"fro\", \"inf\", 1, 2, etc.\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the operand but preserve the ord parameter.\"\"\"\n        canon_operand = self.operand.canonicalize()\n        return Norm(canon_operand, ord=self.ord)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Norm reduces any shape to a scalar.\"\"\"\n        # Validate that the operand has a valid shape\n        self.operand.check_shape()\n        # Norm always produces a scalar regardless of input shape\n        return ()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Norm including its ord parameter.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Norm\")\n        # Hash the ord parameter\n        hasher.update(repr(self.ord).encode())\n        # Hash the operand\n        self.operand._hash_into(hasher)\n\n    def __repr__(self):\n        return f\"norm({self.operand!r}, ord={self.ord!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Norm._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash Norm including its ord parameter.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash Norm including its ord parameter.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(b\"Norm\")\n    # Hash the ord parameter\n    hasher.update(repr(self.ord).encode())\n    # Hash the operand\n    self.operand._hash_into(hasher)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Norm.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the operand but preserve the ord parameter.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the operand but preserve the ord parameter.\"\"\"\n    canon_operand = self.operand.canonicalize()\n    return Norm(canon_operand, ord=self.ord)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Norm.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Norm reduces any shape to a scalar.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Norm reduces any shape to a scalar.\"\"\"\n    # Validate that the operand has a valid shape\n    self.operand.check_shape()\n    # Norm always produces a scalar regardless of input shape\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Or","title":"<code>Or</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Logical OR operation for disjunctive constraints.</p> <p>Represents a logical disjunction (OR) between multiple constraint expressions. This is particularly useful in STL-based trajectory optimization for expressing choices or alternatives in task specifications. The Or operation is typically relaxed using smooth approximations (e.g., LogSumExp) during optimization.</p> <p>The Or operation allows expressing constraints like:</p> <ul> <li>\"Reach either goal A OR goal B\"</li> <li>\"Avoid obstacle 1 OR obstacle 2\" (at least one must be satisfied)</li> <li>\"Use path 1 OR path 2 OR path 3\"</li> </ul> <p>During optimization, the disjunction is typically approximated using:     Or(\u03c6\u2081, \u03c6\u2082, ..., \u03c6\u2099) \u2248 LSE(\u03c6\u2081, \u03c6\u2082, ..., \u03c6\u2099) \u2265 0</p> <p>where LSE is the LogSumExp (smooth maximum) function.</p> <p>Attributes:</p> Name Type Description <code>operands</code> <p>List of expressions representing the disjunctive clauses</p> Example <p>Use Or STL operator to enforce that robot must reach either of two goal regions:</p> <pre><code>import openscvx as ox\nx = ox.State(\"x\", shape=(2,))\ngoal_a = ox.Parameter(\"goal_a\", shape=(2,), value=[1.0, 1.0])\ngoal_b = ox.Parameter(\"goal_b\", shape=(2,), value=[-1.0, -1.0])\n# Robot is within 0.5 units of either goal\nreach_a = 0.25 - ox.Norm(x - goal_a)**2\nreach_b = 0.25 - ox.Norm(x - goal_b)**2\nreach_either = ox.Or(reach_a, reach_b)\n</code></pre> Note <p>The Or operation produces a scalar result even when operands are vector expressions, as it represents a single logical proposition.</p> See Also <p>LogSumExp: Common smooth approximation for OR operations Max: Hard maximum (non-smooth alternative)</p> Source code in <code>openscvx/symbolic/expr/stl.py</code> <pre><code>class Or(Expr):\n    \"\"\"Logical OR operation for disjunctive constraints.\n\n    Represents a logical disjunction (OR) between multiple constraint expressions.\n    This is particularly useful in STL-based trajectory optimization for expressing\n    choices or alternatives in task specifications. The Or operation is typically\n    relaxed using smooth approximations (e.g., LogSumExp) during optimization.\n\n    The Or operation allows expressing constraints like:\n\n    - \"Reach either goal A OR goal B\"\n    - \"Avoid obstacle 1 OR obstacle 2\" (at least one must be satisfied)\n    - \"Use path 1 OR path 2 OR path 3\"\n\n    During optimization, the disjunction is typically approximated using:\n        Or(\u03c6\u2081, \u03c6\u2082, ..., \u03c6\u2099) \u2248 LSE(\u03c6\u2081, \u03c6\u2082, ..., \u03c6\u2099) \u2265 0\n\n    where LSE is the LogSumExp (smooth maximum) function.\n\n    Attributes:\n        operands: List of expressions representing the disjunctive clauses\n\n    Example:\n        Use Or STL operator to enforce that robot must reach either of two goal regions:\n\n            import openscvx as ox\n            x = ox.State(\"x\", shape=(2,))\n            goal_a = ox.Parameter(\"goal_a\", shape=(2,), value=[1.0, 1.0])\n            goal_b = ox.Parameter(\"goal_b\", shape=(2,), value=[-1.0, -1.0])\n            # Robot is within 0.5 units of either goal\n            reach_a = 0.25 - ox.Norm(x - goal_a)**2\n            reach_b = 0.25 - ox.Norm(x - goal_b)**2\n            reach_either = ox.Or(reach_a, reach_b)\n\n    Note:\n        The Or operation produces a scalar result even when operands are vector\n        expressions, as it represents a single logical proposition.\n\n    See Also:\n        LogSumExp: Common smooth approximation for OR operations\n        Max: Hard maximum (non-smooth alternative)\n    \"\"\"\n\n    def __init__(self, *operands):\n        \"\"\"Initialize a logical OR operation.\n\n        Args:\n            *operands: Two or more expressions to combine with logical OR.\n                      Each operand typically represents a constraint or condition.\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(operands) &lt; 2:\n            raise ValueError(\"Or requires at least two operands\")\n        self.operands = [to_expr(op) for op in operands]\n\n    def children(self):\n        return self.operands\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize by flattening nested Or expressions.\n\n        Flattens nested Or operations into a single flat Or with all clauses\n        at the same level. For example: Or(a, Or(b, c)) \u2192 Or(a, b, c).\n        Also canonicalizes all operands recursively.\n\n        Returns:\n            Expr: Canonical form of the Or expression. If only one operand\n                  remains after canonicalization, returns that operand directly.\n        \"\"\"\n        operands = []\n\n        for operand in self.operands:\n            canonicalized = operand.canonicalize()\n            if isinstance(canonicalized, Or):\n                # Flatten nested Or: Or(a, Or(b, c)) -&gt; Or(a, b, c)\n                operands.extend(canonicalized.operands)\n            else:\n                operands.append(canonicalized)\n\n        # Return simplified Or expression\n        if len(operands) == 1:\n            return operands[0]\n        return Or(*operands)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Validate operand shapes and return result shape.\n\n        Checks that all operands have compatible (broadcastable) shapes. The Or\n        operation supports broadcasting, allowing mixing of scalars and vectors.\n\n        Returns:\n            tuple: Empty tuple () indicating a scalar result, as Or represents\n                   a single logical proposition\n\n        Raises:\n            ValueError: If fewer than two operands exist\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        if len(self.operands) &lt; 2:\n            raise ValueError(\"Or requires at least two operands\")\n\n        # Validate all operands and get their shapes\n        operand_shapes = [operand.check_shape() for operand in self.operands]\n\n        # For logical operations, all operands should be broadcastable\n        # This allows mixing scalars with vectors for element-wise operations\n        try:\n            result_shape = operand_shapes[0]\n            for shape in operand_shapes[1:]:\n                result_shape = np.broadcast_shapes(result_shape, shape)\n        except ValueError as e:\n            raise ValueError(f\"Or operands not broadcastable: {operand_shapes}\") from e\n\n        # Or produces a scalar result (like constraints)\n        return ()\n\n    def __repr__(self):\n        operands_repr = \" | \".join(repr(op) for op in self.operands)\n        return f\"Or({operands_repr})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Or.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize by flattening nested Or expressions.</p> <p>Flattens nested Or operations into a single flat Or with all clauses at the same level. For example: Or(a, Or(b, c)) \u2192 Or(a, b, c). Also canonicalizes all operands recursively.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the Or expression. If only one operand   remains after canonicalization, returns that operand directly.</p> Source code in <code>openscvx/symbolic/expr/stl.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize by flattening nested Or expressions.\n\n    Flattens nested Or operations into a single flat Or with all clauses\n    at the same level. For example: Or(a, Or(b, c)) \u2192 Or(a, b, c).\n    Also canonicalizes all operands recursively.\n\n    Returns:\n        Expr: Canonical form of the Or expression. If only one operand\n              remains after canonicalization, returns that operand directly.\n    \"\"\"\n    operands = []\n\n    for operand in self.operands:\n        canonicalized = operand.canonicalize()\n        if isinstance(canonicalized, Or):\n            # Flatten nested Or: Or(a, Or(b, c)) -&gt; Or(a, b, c)\n            operands.extend(canonicalized.operands)\n        else:\n            operands.append(canonicalized)\n\n    # Return simplified Or expression\n    if len(operands) == 1:\n        return operands[0]\n    return Or(*operands)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Or.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate operand shapes and return result shape.</p> <p>Checks that all operands have compatible (broadcastable) shapes. The Or operation supports broadcasting, allowing mixing of scalars and vectors.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () indicating a scalar result, as Or represents    a single logical proposition</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two operands exist</p> <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/stl.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Validate operand shapes and return result shape.\n\n    Checks that all operands have compatible (broadcastable) shapes. The Or\n    operation supports broadcasting, allowing mixing of scalars and vectors.\n\n    Returns:\n        tuple: Empty tuple () indicating a scalar result, as Or represents\n               a single logical proposition\n\n    Raises:\n        ValueError: If fewer than two operands exist\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    if len(self.operands) &lt; 2:\n        raise ValueError(\"Or requires at least two operands\")\n\n    # Validate all operands and get their shapes\n    operand_shapes = [operand.check_shape() for operand in self.operands]\n\n    # For logical operations, all operands should be broadcastable\n    # This allows mixing scalars with vectors for element-wise operations\n    try:\n        result_shape = operand_shapes[0]\n        for shape in operand_shapes[1:]:\n            result_shape = np.broadcast_shapes(result_shape, shape)\n    except ValueError as e:\n        raise ValueError(f\"Or operands not broadcastable: {operand_shapes}\") from e\n\n    # Or produces a scalar result (like constraints)\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Parameter","title":"<code>Parameter</code>","text":"<p>               Bases: <code>Leaf</code></p> <p>Parameter that can be changed at runtime without recompilation.</p> <p>Parameters are symbolic variables with initial values that can be updated through the problem's parameter dictionary. They allow for efficient parameter sweeps without needing to recompile the optimization problem.</p> Example <p>obs_center = ox.Parameter(\"obs_center\", shape=(3,), value=np.array([1.0, 0.0, 0.0]))</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class Parameter(Leaf):\n    \"\"\"Parameter that can be changed at runtime without recompilation.\n\n    Parameters are symbolic variables with initial values that can be updated\n    through the problem's parameter dictionary. They allow for efficient\n    parameter sweeps without needing to recompile the optimization problem.\n\n    Example:\n        obs_center = ox.Parameter(\"obs_center\", shape=(3,), value=np.array([1.0, 0.0, 0.0]))\n        # Later: problem.parameters[\"obs_center\"] = new_value\n    \"\"\"\n\n    def __init__(self, name: str, shape: tuple = (), value=None):\n        \"\"\"Initialize a Parameter node.\n\n        Args:\n            name (str): Name identifier for the parameter\n            shape (tuple): Shape of the parameter (default: scalar)\n            value: Initial value for the parameter (required)\n        \"\"\"\n        super().__init__(name, shape)\n        if value is None:\n            raise ValueError(f\"Parameter '{name}' requires an initial value\")\n        self.value = np.asarray(value, dtype=float)\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Parameter by its shape only (value-invariant).\n\n        Parameters are hashed by shape only, not by value. This allows the same\n        compiled solver to be reused across parameter sweeps - only the structure\n        matters for compilation, not the actual values.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Parameter\")\n        hasher.update(str(self._shape).encode())\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Parameter--later-problemparametersobs_center-new_value","title":"Later: problem.parameters[\"obs_center\"] = new_value","text":""},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Parameter._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash Parameter by its shape only (value-invariant).</p> <p>Parameters are hashed by shape only, not by value. This allows the same compiled solver to be reused across parameter sweeps - only the structure matters for compilation, not the actual values.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash Parameter by its shape only (value-invariant).\n\n    Parameters are hashed by shape only, not by value. This allows the same\n    compiled solver to be reused across parameter sweeps - only the structure\n    matters for compilation, not the actual values.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(b\"Parameter\")\n    hasher.update(str(self._shape).encode())\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.PositivePart","title":"<code>PositivePart</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Positive part function for symbolic expressions.</p> <p>Computes max(x, 0) element-wise, effectively zeroing out negative values while preserving positive values. This is also known as the ReLU (Rectified Linear Unit) function and is commonly used as a penalty function building block in optimization.</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Expression to apply positive part function to</p> Example <p>Define a PositivePart expression:</p> <pre><code>constraint_violation = x - 10\npenalty = PositivePart(constraint_violation)  # Penalizes x &gt; 10\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class PositivePart(Expr):\n    \"\"\"Positive part function for symbolic expressions.\n\n    Computes max(x, 0) element-wise, effectively zeroing out negative values\n    while preserving positive values. This is also known as the ReLU (Rectified\n    Linear Unit) function and is commonly used as a penalty function building\n    block in optimization.\n\n    Attributes:\n        x: Expression to apply positive part function to\n\n    Example:\n        Define a PositivePart expression:\n\n            constraint_violation = x - 10\n            penalty = PositivePart(constraint_violation)  # Penalizes x &gt; 10\n    \"\"\"\n\n    def __init__(self, x):\n        \"\"\"Initialize a positive part operation.\n\n        Args:\n            x: Expression to apply positive part function to\n        \"\"\"\n        self.x = to_expr(x)\n\n    def children(self):\n        return [self.x]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        x = self.x.canonicalize()\n        return PositivePart(x)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"pos(x) = max(x, 0) preserves the shape of x.\"\"\"\n        return self.x.check_shape()\n\n    def __repr__(self):\n        return f\"pos({self.x!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.PositivePart.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>pos(x) = max(x, 0) preserves the shape of x.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"pos(x) = max(x, 0) preserves the shape of x.\"\"\"\n    return self.x.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Power","title":"<code>Power</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise power operation for symbolic expressions.</p> <p>Represents element-wise exponentiation (base ** exponent). Supports broadcasting following NumPy rules. Can be created using the ** operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>base</code> <p>Base expression</p> <code>exponent</code> <p>Exponent expression</p> Example <p>Define a Power expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = x ** 2  # Creates Power(x, Constant(2))\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Power(Expr):\n    \"\"\"Element-wise power operation for symbolic expressions.\n\n    Represents element-wise exponentiation (base ** exponent). Supports broadcasting\n    following NumPy rules. Can be created using the ** operator on Expr objects.\n\n    Attributes:\n        base: Base expression\n        exponent: Exponent expression\n\n    Example:\n        Define a Power expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = x ** 2  # Creates Power(x, Constant(2))\n    \"\"\"\n\n    def __init__(self, base, exponent):\n        \"\"\"Initialize a power operation.\n\n        Args:\n            base: Base expression\n            exponent: Exponent expression\n        \"\"\"\n        self.base = to_expr(base)\n        self.exponent = to_expr(exponent)\n\n    def children(self):\n        return [self.base, self.exponent]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize power by canonicalizing base and exponent.\n\n        Returns:\n            Expr: Canonical form of the power expression\n        \"\"\"\n        base = self.base.canonicalize()\n        exponent = self.exponent.canonicalize()\n        return Power(base, exponent)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Power shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        return f\"({self.base!r})**({self.exponent!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Power.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize power by canonicalizing base and exponent.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the power expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize power by canonicalizing base and exponent.\n\n    Returns:\n        Expr: Canonical form of the power expression\n    \"\"\"\n    base = self.base.canonicalize()\n    exponent = self.exponent.canonicalize()\n    return Power(base, exponent)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.QDCM","title":"<code>QDCM</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Quaternion to Direction Cosine Matrix (DCM) conversion.</p> <p>Converts a unit quaternion representation to a 3x3 direction cosine matrix (also known as a rotation matrix). This operation is commonly used in 6-DOF spacecraft dynamics, aircraft simulation, and robotics applications.</p> <p>The quaternion is expected in scalar-last format: [qx, qy, qz, qw] where qw is the scalar component. The resulting DCM can be used to transform vectors from one reference frame to another.</p> <p>Attributes:</p> Name Type Description <code>q</code> <p>Quaternion expression with shape (4,)</p> Example <p>Use the QDCM to rotate a vector:</p> <pre><code>import openscvx as ox\nq = ox.State(\"q\", shape=(4,))\ndcm = ox.QDCM(q)  # Creates rotation matrix, shape (3, 3)\nv_body = ox.Variable(\"v_body\", shape=(3,))\nv_inertial = dcm @ v_body\n</code></pre> Note <p>The input quaternion does not need to be normalized; the implementation automatically handles normalization during evaluation.</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>class QDCM(Expr):\n    \"\"\"Quaternion to Direction Cosine Matrix (DCM) conversion.\n\n    Converts a unit quaternion representation to a 3x3 direction cosine matrix\n    (also known as a rotation matrix). This operation is commonly used in 6-DOF\n    spacecraft dynamics, aircraft simulation, and robotics applications.\n\n    The quaternion is expected in scalar-last format: [qx, qy, qz, qw] where\n    qw is the scalar component. The resulting DCM can be used to transform vectors\n    from one reference frame to another.\n\n    Attributes:\n        q: Quaternion expression with shape (4,)\n\n    Example:\n        Use the QDCM to rotate a vector:\n\n            import openscvx as ox\n            q = ox.State(\"q\", shape=(4,))\n            dcm = ox.QDCM(q)  # Creates rotation matrix, shape (3, 3)\n            v_body = ox.Variable(\"v_body\", shape=(3,))\n            v_inertial = dcm @ v_body\n\n    Note:\n        The input quaternion does not need to be normalized; the implementation\n        automatically handles normalization during evaluation.\n    \"\"\"\n\n    def __init__(self, q):\n        \"\"\"Initialize a quaternion to DCM conversion.\n\n        Args:\n            q: Quaternion expression with shape (4,) in [qx, qy, qz, qw] format\n        \"\"\"\n        self.q = to_expr(q)\n\n    def children(self):\n        return [self.q]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        q = self.q.canonicalize()\n        return QDCM(q)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a quaternion and return DCM shape.\n\n        Returns:\n            tuple: Shape (3, 3) for the resulting direction cosine matrix\n\n        Raises:\n            ValueError: If quaternion does not have shape (4,)\n        \"\"\"\n        q_shape = self.q.check_shape()\n        if q_shape != (4,):\n            raise ValueError(f\"QDCM expects quaternion with shape (4,), got {q_shape}\")\n        return (3, 3)\n\n    def __repr__(self):\n        return f\"qdcm({self.q!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.QDCM.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a quaternion and return DCM shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (3, 3) for the resulting direction cosine matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If quaternion does not have shape (4,)</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a quaternion and return DCM shape.\n\n    Returns:\n        tuple: Shape (3, 3) for the resulting direction cosine matrix\n\n    Raises:\n        ValueError: If quaternion does not have shape (4,)\n    \"\"\"\n    q_shape = self.q.check_shape()\n    if q_shape != (4,):\n        raise ValueError(f\"QDCM expects quaternion with shape (4,), got {q_shape}\")\n    return (3, 3)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SSM","title":"<code>SSM</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Angular rate vector to 3x3 skew-symmetric matrix (cross product matrix).</p> <p>Constructs the 3x3 skew-symmetric matrix [\u03c9]x that represents the cross product operation. For any 3D vector v, the cross product \u03c9 x v can be computed as the matrix-vector product [\u03c9]x @ v.</p> The resulting matrix has the form <p>\u23a1  0  -\u03c9z   \u03c9y \u23a4 \u23a2 \u03c9z    0  -\u03c9x \u23a5 \u23a3-\u03c9y   \u03c9x    0 \u23a6</p> <p>This operation is widely used in: - Rigid body dynamics (angular momentum calculations) - DCM time derivatives: \u1e58 = [\u03c9]x @ R - Velocity kinematics in robotics - Coriolis and centrifugal acceleration terms</p> <p>Attributes:</p> Name Type Description <code>w</code> <p>Angular velocity or 3D vector expression with shape (3,)</p> Example <p>Use the SSM to compute the rotation matrix derivative:</p> <pre><code>import openscvx as ox\nomega = ox.Control(\"omega\", shape=(3,))\nR = ox.State(\"R\", shape=(3, 3))  # Direction cosine matrix\n# DCM time derivative\nR_dot = ox.SSM(omega) @ R\n</code></pre> Note <p>The skew-symmetric property ensures that [\u03c9]x\u1d40 = -[\u03c9]x, which is important for preserving orthogonality in DCM propagation.</p> See Also <p>SSMP: 4x4 skew-symmetric matrix for quaternion dynamics</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>class SSM(Expr):\n    \"\"\"Angular rate vector to 3x3 skew-symmetric matrix (cross product matrix).\n\n    Constructs the 3x3 skew-symmetric matrix [\u03c9]x that represents the cross\n    product operation. For any 3D vector v, the cross product \u03c9 x v can be\n    computed as the matrix-vector product [\u03c9]x @ v.\n\n    The resulting matrix has the form:\n        \u23a1  0  -\u03c9z   \u03c9y \u23a4\n        \u23a2 \u03c9z    0  -\u03c9x \u23a5\n        \u23a3-\u03c9y   \u03c9x    0 \u23a6\n\n    This operation is widely used in:\n    - Rigid body dynamics (angular momentum calculations)\n    - DCM time derivatives: \u1e58 = [\u03c9]x @ R\n    - Velocity kinematics in robotics\n    - Coriolis and centrifugal acceleration terms\n\n    Attributes:\n        w: Angular velocity or 3D vector expression with shape (3,)\n\n    Example:\n        Use the SSM to compute the rotation matrix derivative:\n\n            import openscvx as ox\n            omega = ox.Control(\"omega\", shape=(3,))\n            R = ox.State(\"R\", shape=(3, 3))  # Direction cosine matrix\n            # DCM time derivative\n            R_dot = ox.SSM(omega) @ R\n\n    Note:\n        The skew-symmetric property ensures that [\u03c9]x\u1d40 = -[\u03c9]x, which is\n        important for preserving orthogonality in DCM propagation.\n\n    See Also:\n        SSMP: 4x4 skew-symmetric matrix for quaternion dynamics\n    \"\"\"\n\n    def __init__(self, w):\n        \"\"\"Initialize a vector to skew-symmetric matrix conversion.\n\n        Args:\n            w: 3D vector expression with shape (3,) in [\u03c9x, \u03c9y, \u03c9z] format\n        \"\"\"\n        self.w = to_expr(w)\n\n    def children(self):\n        return [self.w]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        w = self.w.canonicalize()\n        return SSM(w)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 3D vector and return matrix shape.\n\n        Returns:\n            tuple: Shape (3, 3) for the resulting skew-symmetric matrix\n\n        Raises:\n            ValueError: If input vector does not have shape (3,)\n        \"\"\"\n        w_shape = self.w.check_shape()\n        if w_shape != (3,):\n            raise ValueError(f\"SSM expects angular velocity with shape (3,), got {w_shape}\")\n        return (3, 3)\n\n    def __repr__(self):\n        return f\"ssm({self.w!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SSM.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 3D vector and return matrix shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (3, 3) for the resulting skew-symmetric matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input vector does not have shape (3,)</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 3D vector and return matrix shape.\n\n    Returns:\n        tuple: Shape (3, 3) for the resulting skew-symmetric matrix\n\n    Raises:\n        ValueError: If input vector does not have shape (3,)\n    \"\"\"\n    w_shape = self.w.check_shape()\n    if w_shape != (3,):\n        raise ValueError(f\"SSM expects angular velocity with shape (3,), got {w_shape}\")\n    return (3, 3)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SSMP","title":"<code>SSMP</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Angular rate to 4x4 skew-symmetric matrix for quaternion dynamics.</p> <p>Constructs the 4x4 skew-symmetric matrix \u03a9(\u03c9) used in quaternion kinematic differential equations. This matrix relates angular velocity to the time derivative of the quaternion:</p> <pre><code>q\u0307 = (1/2) * \u03a9(\u03c9) @ q\n</code></pre> The resulting matrix has the form <p>\u23a1  0   \u03c9z  -\u03c9y   \u03c9x \u23a4 \u23a2-\u03c9z    0   \u03c9x   \u03c9y \u23a5 \u23a2 \u03c9y  -\u03c9x    0   \u03c9z \u23a5 \u23a3-\u03c9x  -\u03c9y  -\u03c9z    0 \u23a6</p> <p>This is particularly useful for formulating quaternion-based attitude dynamics in spacecraft and aircraft trajectory optimization problems.</p> <p>Attributes:</p> Name Type Description <code>w</code> <p>Angular velocity vector expression with shape (3,)</p> Example <p>Use the SSMP to compute the quaternion derivative:</p> <pre><code>import openscvx as ox\nomega = ox.Control(\"omega\", shape=(3,))\nq = ox.State(\"q\", shape=(4,))\n# Quaternion kinematic equation\nq_dot = 0.5 * ox.SSMP(omega) @ q\n</code></pre> See Also <p>SSM: 3x3 skew-symmetric matrix for cross product operations</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>class SSMP(Expr):\n    \"\"\"Angular rate to 4x4 skew-symmetric matrix for quaternion dynamics.\n\n    Constructs the 4x4 skew-symmetric matrix \u03a9(\u03c9) used in quaternion kinematic\n    differential equations. This matrix relates angular velocity to the time\n    derivative of the quaternion:\n\n        q\u0307 = (1/2) * \u03a9(\u03c9) @ q\n\n    The resulting matrix has the form:\n        \u23a1  0   \u03c9z  -\u03c9y   \u03c9x \u23a4\n        \u23a2-\u03c9z    0   \u03c9x   \u03c9y \u23a5\n        \u23a2 \u03c9y  -\u03c9x    0   \u03c9z \u23a5\n        \u23a3-\u03c9x  -\u03c9y  -\u03c9z    0 \u23a6\n\n    This is particularly useful for formulating quaternion-based attitude\n    dynamics in spacecraft and aircraft trajectory optimization problems.\n\n    Attributes:\n        w: Angular velocity vector expression with shape (3,)\n\n    Example:\n        Use the SSMP to compute the quaternion derivative:\n\n            import openscvx as ox\n            omega = ox.Control(\"omega\", shape=(3,))\n            q = ox.State(\"q\", shape=(4,))\n            # Quaternion kinematic equation\n            q_dot = 0.5 * ox.SSMP(omega) @ q\n\n    See Also:\n        SSM: 3x3 skew-symmetric matrix for cross product operations\n    \"\"\"\n\n    def __init__(self, w):\n        \"\"\"Initialize an angular velocity to skew-symmetric matrix conversion.\n\n        Args:\n            w: Angular velocity vector expression with shape (3,) in [\u03c9x, \u03c9y, \u03c9z] format\n        \"\"\"\n        self.w = to_expr(w)\n\n    def children(self):\n        return [self.w]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        w = self.w.canonicalize()\n        return SSMP(w)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 3D angular velocity and return matrix shape.\n\n        Returns:\n            tuple: Shape (4, 4) for the resulting skew-symmetric matrix\n\n        Raises:\n            ValueError: If angular velocity does not have shape (3,)\n        \"\"\"\n        w_shape = self.w.check_shape()\n        if w_shape != (3,):\n            raise ValueError(f\"SSMP expects angular velocity with shape (3,), got {w_shape}\")\n        return (4, 4)\n\n    def __repr__(self):\n        return f\"ssmp({self.w!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SSMP.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 3D angular velocity and return matrix shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (4, 4) for the resulting skew-symmetric matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If angular velocity does not have shape (3,)</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 3D angular velocity and return matrix shape.\n\n    Returns:\n        tuple: Shape (4, 4) for the resulting skew-symmetric matrix\n\n    Raises:\n        ValueError: If angular velocity does not have shape (3,)\n    \"\"\"\n    w_shape = self.w.check_shape()\n    if w_shape != (3,):\n        raise ValueError(f\"SSMP expects angular velocity with shape (3,), got {w_shape}\")\n    return (4, 4)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sin","title":"<code>Sin</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise sine function for symbolic expressions.</p> <p>Computes the sine of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply sine function to</p> Example <p>Define a Sin expression:</p> <pre><code>theta = Variable(\"theta\", shape=(3,))\nsin_theta = Sin(theta)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Sin(Expr):\n    \"\"\"Element-wise sine function for symbolic expressions.\n\n    Computes the sine of each element in the operand. Preserves the shape\n    of the input expression.\n\n    Attributes:\n        operand: Expression to apply sine function to\n\n    Example:\n        Define a Sin expression:\n\n            theta = Variable(\"theta\", shape=(3,))\n            sin_theta = Sin(theta)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a sine operation.\n\n        Args:\n            operand: Expression to apply sine function to\n        \"\"\"\n        self.operand = operand\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Sin(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Sin preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"(sin({self.operand!r}))\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sin.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Sin preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Sin preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SmoothReLU","title":"<code>SmoothReLU</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Smooth approximation to the ReLU (positive part) function.</p> <p>Computes a smooth, differentiable approximation to max(x, 0) using the formula: sqrt(max(x, 0)^2 + c^2) - c</p> <p>The parameter c controls the smoothness: smaller values give a sharper transition, while larger values produce a smoother approximation. As c approaches 0, this converges to the standard ReLU function.</p> <p>This is particularly useful in optimization contexts where smooth gradients are required, such as in penalty methods for constraint handling (CTCS).</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Expression to apply smooth ReLU to</p> <code>c</code> <p>Smoothing parameter (default: 1e-8)</p> Example <p>Define a smooth ReLU expression:</p> <pre><code>constraint_violation = x - 10\npenalty = SmoothReLU(constraint_violation, c=1e-6)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class SmoothReLU(Expr):\n    \"\"\"Smooth approximation to the ReLU (positive part) function.\n\n    Computes a smooth, differentiable approximation to max(x, 0) using the formula:\n    sqrt(max(x, 0)^2 + c^2) - c\n\n    The parameter c controls the smoothness: smaller values give a sharper\n    transition, while larger values produce a smoother approximation. As c\n    approaches 0, this converges to the standard ReLU function.\n\n    This is particularly useful in optimization contexts where smooth gradients\n    are required, such as in penalty methods for constraint handling (CTCS).\n\n    Attributes:\n        x: Expression to apply smooth ReLU to\n        c: Smoothing parameter (default: 1e-8)\n\n    Example:\n        Define a smooth ReLU expression:\n\n            constraint_violation = x - 10\n            penalty = SmoothReLU(constraint_violation, c=1e-6)\n    \"\"\"\n\n    def __init__(self, x, c: float = 1e-8):\n        \"\"\"Initialize a smooth ReLU operation.\n\n        Args:\n            x: Expression to apply smooth ReLU to\n            c: Smoothing parameter controlling transition sharpness (default: 1e-8)\n        \"\"\"\n        self.x = to_expr(x)\n        self.c = float(c)\n\n    def children(self):\n        return [self.x]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the operand but preserve c parameter.\"\"\"\n        x = self.x.canonicalize()\n        return SmoothReLU(x, c=self.c)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Smooth ReLU preserves the shape of x.\"\"\"\n        return self.x.check_shape()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash SmoothReLU including its c parameter.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"SmoothReLU\")\n        # Hash c as bytes\n        hasher.update(struct.pack(\"&gt;d\", self.c))\n        # Hash the operand\n        self.x._hash_into(hasher)\n\n    def __repr__(self):\n        return f\"smooth_relu({self.x!r}, c={self.c})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SmoothReLU._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash SmoothReLU including its c parameter.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash SmoothReLU including its c parameter.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(b\"SmoothReLU\")\n    # Hash c as bytes\n    hasher.update(struct.pack(\"&gt;d\", self.c))\n    # Hash the operand\n    self.x._hash_into(hasher)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SmoothReLU.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the operand but preserve c parameter.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the operand but preserve c parameter.\"\"\"\n    x = self.x.canonicalize()\n    return SmoothReLU(x, c=self.c)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SmoothReLU.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Smooth ReLU preserves the shape of x.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Smooth ReLU preserves the shape of x.\"\"\"\n    return self.x.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sqrt","title":"<code>Sqrt</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise square root function for symbolic expressions.</p> <p>Computes the square root of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply square root to</p> Example <p>Define a Sqrt expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\nsqrt_x = Sqrt(x)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Sqrt(Expr):\n    \"\"\"Element-wise square root function for symbolic expressions.\n\n    Computes the square root of each element in the operand. Preserves the\n    shape of the input expression.\n\n    Attributes:\n        operand: Expression to apply square root to\n\n    Example:\n        Define a Sqrt expression:\n\n            x = Variable(\"x\", shape=(3,))\n            sqrt_x = Sqrt(x)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a square root operation.\n\n        Args:\n            operand: Expression to apply square root to\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Sqrt(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Sqrt preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"sqrt({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sqrt.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Sqrt preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Sqrt preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Square","title":"<code>Square</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise square function for symbolic expressions.</p> <p>Computes the square (x^2) of each element in the operand. Preserves the shape of the input expression. This is more efficient than using Power(x, 2) for some optimization backends.</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Expression to square</p> Example <p>Define a Square expression:</p> <pre><code>v = Variable(\"v\", shape=(3,))\nv_squared = Square(v)  # Equivalent to v ** 2\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Square(Expr):\n    \"\"\"Element-wise square function for symbolic expressions.\n\n    Computes the square (x^2) of each element in the operand. Preserves the\n    shape of the input expression. This is more efficient than using Power(x, 2)\n    for some optimization backends.\n\n    Attributes:\n        x: Expression to square\n\n    Example:\n        Define a Square expression:\n\n            v = Variable(\"v\", shape=(3,))\n            v_squared = Square(v)  # Equivalent to v ** 2\n    \"\"\"\n\n    def __init__(self, x):\n        \"\"\"Initialize a square operation.\n\n        Args:\n            x: Expression to square\n        \"\"\"\n        self.x = to_expr(x)\n\n    def children(self):\n        return [self.x]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        x = self.x.canonicalize()\n        return Square(x)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"x^2 preserves the shape of x.\"\"\"\n        return self.x.check_shape()\n\n    def __repr__(self):\n        return f\"({self.x!r})^2\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Square.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>x^2 preserves the shape of x.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"x^2 preserves the shape of x.\"\"\"\n    return self.x.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Stack","title":"<code>Stack</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Stack expressions vertically to create a higher-dimensional array.</p> <p>Stacks a list of expressions along a new first dimension. All input expressions must have the same shape. The result has shape (num_rows, *row_shape).</p> <p>This is similar to numpy.array([row1, row2, ...]) or jax.numpy.stack(rows, axis=0).</p> <p>Attributes:</p> Name Type Description <code>rows</code> <p>List of expressions to stack, each representing a \"row\"</p> Example <p>Leverage stack to combine expressions:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(3,))\nz = Variable(\"z\", shape=(3,))\nstacked = Stack([x, y, z])  # Creates shape (3, 3)\n# Equivalent to: [[x[0], x[1], x[2]],\n#                 [y[0], y[1], y[2]],\n#                 [z[0], z[1], z[2]]]\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Stack(Expr):\n    \"\"\"Stack expressions vertically to create a higher-dimensional array.\n\n    Stacks a list of expressions along a new first dimension. All input expressions\n    must have the same shape. The result has shape (num_rows, *row_shape).\n\n    This is similar to numpy.array([row1, row2, ...]) or jax.numpy.stack(rows, axis=0).\n\n    Attributes:\n        rows: List of expressions to stack, each representing a \"row\"\n\n    Example:\n        Leverage stack to combine expressions:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(3,))\n            z = Variable(\"z\", shape=(3,))\n            stacked = Stack([x, y, z])  # Creates shape (3, 3)\n            # Equivalent to: [[x[0], x[1], x[2]],\n            #                 [y[0], y[1], y[2]],\n            #                 [z[0], z[1], z[2]]]\n    \"\"\"\n\n    def __init__(self, rows):\n        \"\"\"Initialize a stack operation.\n\n        Args:\n            rows: List of expressions to stack along a new first dimension.\n                  All expressions must have the same shape.\n        \"\"\"\n        # rows should be a list of expressions representing each row\n        self.rows = [to_expr(row) for row in rows]\n\n    def children(self):\n        return self.rows\n\n    def canonicalize(self) -&gt; \"Expr\":\n        rows = [row.canonicalize() for row in self.rows]\n        return Stack(rows)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Stack creates a 2D matrix from 1D rows.\"\"\"\n        if not self.rows:\n            raise ValueError(\"Stack requires at least one row\")\n\n        # All rows should have the same shape\n        row_shapes = [row.check_shape() for row in self.rows]\n\n        # Verify all rows have the same shape\n        first_shape = row_shapes[0]\n        for i, shape in enumerate(row_shapes[1:], 1):\n            if shape != first_shape:\n                raise ValueError(\n                    f\"Stack row {i} has shape {shape}, but row 0 has shape {first_shape}\"\n                )\n\n        # Result shape is (num_rows, *row_shape)\n        return (len(self.rows),) + first_shape\n\n    def __repr__(self):\n        rows_repr = \", \".join(repr(row) for row in self.rows)\n        return f\"Stack([{rows_repr}])\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Stack.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Stack creates a 2D matrix from 1D rows.</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Stack creates a 2D matrix from 1D rows.\"\"\"\n    if not self.rows:\n        raise ValueError(\"Stack requires at least one row\")\n\n    # All rows should have the same shape\n    row_shapes = [row.check_shape() for row in self.rows]\n\n    # Verify all rows have the same shape\n    first_shape = row_shapes[0]\n    for i, shape in enumerate(row_shapes[1:], 1):\n        if shape != first_shape:\n            raise ValueError(\n                f\"Stack row {i} has shape {shape}, but row 0 has shape {first_shape}\"\n            )\n\n    # Result shape is (num_rows, *row_shape)\n    return (len(self.rows),) + first_shape\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.State","title":"<code>State</code>","text":"<p>               Bases: <code>Variable</code></p> <p>State variable with boundary conditions for trajectory optimization.</p> <p>State represents a dynamic state variable in a trajectory optimization problem. Unlike control inputs, states evolve according to dynamics constraints and can have boundary conditions specified at the initial and final time points. Like all Variables, States also support min/max bounds and initial trajectory guesses to help guide the optimization solver toward good solutions.</p> <p>States support four types of boundary conditions:</p> <ul> <li>fixed: State value is constrained to a specific value</li> <li>free: State value is optimized within the specified bounds</li> <li>minimize: Adds a term to the objective function to minimize the state value</li> <li>maximize: Adds a term to the objective function to maximize the state value</li> </ul> <p>Each element of a multi-dimensional state can have different boundary condition types, allowing for fine-grained control over the optimization.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name identifier for this state variable</p> <code>_shape</code> <code>tuple[int, ...]</code> <p>Shape of the state vector (typically 1D like (3,) for 3D position)</p> <code>_slice</code> <code>slice | None</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <code>ndarray | None</code> <p>Minimum bounds for state variables</p> <code>_max</code> <code>ndarray | None</code> <p>Maximum bounds for state variables</p> <code>_guess</code> <code>ndarray | None</code> <p>Initial trajectory guess</p> <code>_initial</code> <code>ndarray | None</code> <p>Initial state values with boundary condition types</p> <code>initial_type</code> <code>ndarray | None</code> <p>Array of boundary condition types for initial state</p> <code>_final</code> <code>ndarray | None</code> <p>Final state values with boundary condition types</p> <code>final_type</code> <code>ndarray | None</code> <p>Array of boundary condition types for final state</p> Example <p>Scalar time state with fixed initial time, minimize final time:</p> <pre><code>time = State(\"time\", (1,))\ntime.min = [0.0]\ntime.max = [10.0]\ntime.initial = [(\"fixed\", 0.0)]\ntime.final = [(\"minimize\", 5.0)]\n</code></pre> <p>3D position state with mixed boundary conditions:</p> <pre><code>pos = State(\"pos\", (3,))\npos.min = [0, 0, 10]\npos.max = [10, 10, 200]\npos.initial = [0, (\"free\", 1), 50]  # x fixed, y free, z fixed\npos.final = [10, (\"free\", 5), (\"maximize\", 150)]  # Maximize final altitude\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>class State(Variable):\n    \"\"\"State variable with boundary conditions for trajectory optimization.\n\n    State represents a dynamic state variable in a trajectory optimization problem.\n    Unlike control inputs, states evolve according to dynamics constraints and can\n    have boundary conditions specified at the initial and final time points.\n    Like all Variables, States also support min/max bounds and initial trajectory\n    guesses to help guide the optimization solver toward good solutions.\n\n    States support four types of boundary conditions:\n\n    - **fixed**: State value is constrained to a specific value\n    - **free**: State value is optimized within the specified bounds\n    - **minimize**: Adds a term to the objective function to minimize the state value\n    - **maximize**: Adds a term to the objective function to maximize the state value\n\n    Each element of a multi-dimensional state can have different boundary condition\n    types, allowing for fine-grained control over the optimization.\n\n    Attributes:\n        name (str): Unique name identifier for this state variable\n        _shape (tuple[int, ...]): Shape of the state vector (typically 1D like (3,) for 3D position)\n        _slice (slice | None): Internal slice information for variable indexing\n        _min (np.ndarray | None): Minimum bounds for state variables\n        _max (np.ndarray | None): Maximum bounds for state variables\n        _guess (np.ndarray | None): Initial trajectory guess\n        _initial (np.ndarray | None): Initial state values with boundary condition types\n        initial_type (np.ndarray | None): Array of boundary condition types for initial state\n        _final (np.ndarray | None): Final state values with boundary condition types\n        final_type (np.ndarray | None): Array of boundary condition types for final state\n\n    Example:\n        Scalar time state with fixed initial time, minimize final time:\n\n            time = State(\"time\", (1,))\n            time.min = [0.0]\n            time.max = [10.0]\n            time.initial = [(\"fixed\", 0.0)]\n            time.final = [(\"minimize\", 5.0)]\n\n        3D position state with mixed boundary conditions:\n\n            pos = State(\"pos\", (3,))\n            pos.min = [0, 0, 10]\n            pos.max = [10, 10, 200]\n            pos.initial = [0, (\"free\", 1), 50]  # x fixed, y free, z fixed\n            pos.final = [10, (\"free\", 5), (\"maximize\", 150)]  # Maximize final altitude\n    \"\"\"\n\n    def __init__(self, name, shape):\n        \"\"\"Initialize a State object.\n\n        Args:\n            name: Name identifier for the state variable\n            shape: Shape of the state vector (typically 1D tuple)\n        \"\"\"\n        super().__init__(name, shape)\n        self._initial = None\n        self.initial_type = None\n        self._final = None\n        self.final_type = None\n        self._scaling_min = None\n        self._scaling_max = None\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash State including boundary condition types.\n\n        Extends Variable._hash_into to include the structural metadata that\n        affects the compiled problem: boundary condition types (fixed, free,\n        minimize, maximize). Values are not hashed as they are runtime parameters.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        # Hash the base Variable attributes (class name, shape, slice)\n        super()._hash_into(hasher)\n        # Hash boundary condition types (these affect constraint structure)\n        if self.initial_type is not None:\n            hasher.update(b\"initial_type:\")\n            hasher.update(str(self.initial_type.tolist()).encode())\n        if self.final_type is not None:\n            hasher.update(b\"final_type:\")\n            hasher.update(str(self.final_type.tolist()).encode())\n\n    @property\n    def min(self):\n        \"\"\"Get the minimum bounds for the state variables.\n\n        Returns:\n            Array of minimum values for each state variable element.\n\n        Example:\n            Get lower bounds:\n\n                pos = State(\"pos\", (3,))\n                pos.min = [0, 0, 10]\n                print(pos.min)  # [0. 0. 10.]\n        \"\"\"\n        return self._min\n\n    @min.setter\n    def min(self, val):\n        \"\"\"Set the minimum bounds for the state variables.\n\n        Bounds are validated against any fixed initial/final conditions to ensure\n        consistency.\n\n        Args:\n            val: Array of minimum values, must match the state shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape, or if fixed\n                boundary conditions violate the bounds\n\n        Example:\n            Set lower bounds:\n\n                pos = State(\"pos\", (3,))\n                pos.min = [0, 0, 10]\n                pos.initial = [0, 5, 15]  # Must satisfy: 0&gt;=0, 5&gt;=0, 15&gt;=10\n        \"\"\"\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(f\"Min shape {val.shape} does not match State shape {self.shape}\")\n        self._min = val\n        self._check_bounds_against_initial_final()\n\n    @property\n    def max(self):\n        \"\"\"Get the maximum bounds for the state variables.\n\n        Returns:\n            Array of maximum values for each state variable element.\n\n        Example:\n            Get upper bounds:\n\n                vel = State(\"vel\", (3,))\n                vel.max = [10, 10, 5]\n                print(vel.max)  # [10. 10. 5.]\n        \"\"\"\n        return self._max\n\n    @max.setter\n    def max(self, val):\n        \"\"\"Set the maximum bounds for the state variables.\n\n        Bounds are validated against any fixed initial/final conditions to ensure\n        consistency.\n\n        Args:\n            val: Array of maximum values, must match the state shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape, or if fixed\n                boundary conditions violate the bounds\n\n        Example:\n            Set upper bounds:\n\n                vel = State(\"vel\", (3,))\n                vel.max = [10, 10, 5]\n                vel.final = [8, 9, 4]  # Must satisfy: 8&lt;=10, 9&lt;=10, 4&lt;=5\n        \"\"\"\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(f\"Max shape {val.shape} does not match State shape {self.shape}\")\n        self._max = val\n        self._check_bounds_against_initial_final()\n\n    def _check_bounds_against_initial_final(self):\n        \"\"\"Validate that fixed boundary conditions respect min/max bounds.\n\n        This internal method is automatically called when bounds or boundary\n        conditions are set to ensure consistency.\n\n        Raises:\n            ValueError: If any fixed initial or final value violates the min/max bounds\n        \"\"\"\n        for field_name, data, types in [\n            (\"initial\", self._initial, self.initial_type),\n            (\"final\", self._final, self.final_type),\n        ]:\n            if data is None or types is None:\n                continue\n            for i, val in np.ndenumerate(data):\n                if types[i] != \"Fix\":\n                    continue\n                min_i = self._min[i] if self._min is not None else -np.inf\n                max_i = self._max[i] if self._max is not None else np.inf\n                if val &lt; min_i:\n                    raise ValueError(\n                        f\"{field_name.capitalize()} Fixed value at index {i[0]} is lower then the \"\n                        f\"min: {val} &lt; {min_i}\"\n                    )\n                if val &gt; max_i:\n                    raise ValueError(\n                        f\"{field_name.capitalize()} Fixed value at index {i[0]} is greater then \"\n                        f\"the max: {val} &gt; {max_i}\"\n                    )\n\n    @property\n    def initial(self):\n        \"\"\"Get the initial state boundary condition values.\n\n        Returns:\n            Array of initial state values (regardless of boundary condition type),\n            or None if not set.\n\n        Note:\n            Use `initial_type` to see the boundary condition types for each element.\n\n        Example:\n            Get initial state boundary conditions:\n\n                x = State(\"x\", (2,))\n                x.initial = [0, (\"free\", 1)]\n                print(x.initial)  # [0. 1.]\n                print(x.initial_type)  # ['Fix' 'Free']\n        \"\"\"\n        return self._initial\n\n    @initial.setter\n    def initial(self, arr):\n        \"\"\"Set the initial state boundary conditions.\n\n        Each element can be specified as either a simple number (defaults to \"fixed\")\n        or a tuple of (type, value) where type specifies the boundary condition.\n\n        Args:\n            arr: Array-like of initial conditions. Each element can be:\n                - A number: Defaults to fixed boundary condition at that value\n                - A tuple (type, value): Where type is one of:\n                    - \"fixed\": Constrain state to this exact value\n                    - \"free\": Let optimizer choose within bounds, initialize at value\n                    - \"minimize\": Add objective term to minimize, initialize at value\n                    - \"maximize\": Add objective term to maximize, initialize at value\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape, if boundary\n                condition type is invalid, or if fixed values violate bounds\n\n        Example:\n            Set initial state boundary conditions:\n\n                pos = State(\"pos\", (3,))\n                pos.min = [0, 0, 0]\n                pos.max = [10, 10, 10]\n                # x fixed at 0, y free (starts at 5), z fixed at 2\n                pos.initial = [0, (\"free\", 5), 2]\n\n            Can also minimize/maximize boundary values:\n\n                time = State(\"t\", (1,))\n                time.initial = [(\"minimize\", 0)]  # Minimize initial time\n        \"\"\"\n        # Convert to list first to handle mixed types properly\n        if not isinstance(arr, (list, tuple)):\n            arr = np.asarray(arr)\n            if arr.shape != self.shape:\n                raise ValueError(f\"Shape mismatch: {arr.shape} != {self.shape}\")\n            arr = arr.tolist()\n\n        # Ensure we have the right number of elements\n        if len(arr) != self.shape[0]:\n            raise ValueError(f\"Length mismatch: got {len(arr)} elements, expected {self.shape[0]}\")\n\n        self._initial = np.zeros(self.shape, dtype=float)\n        self.initial_type = np.full(self.shape, \"Fix\", dtype=object)\n\n        for i, v in enumerate(arr):\n            if isinstance(v, tuple) and len(v) == 2:\n                # Tuple API: (type, value)\n                bc_type_str, bc_value = v\n                try:\n                    bc_type = BoundaryType(bc_type_str)  # Validates the string\n                except ValueError:\n                    valid_types = [t.value for t in BoundaryType]\n                    raise ValueError(\n                        f\"Invalid boundary condition type: {bc_type_str}. \"\n                        f\"Valid types are: {valid_types}\"\n                    )\n                self._initial[i] = float(bc_value)\n                self.initial_type[i] = bc_type.value.capitalize()\n            elif isinstance(v, (int, float, np.number)):\n                # Simple number defaults to fixed\n                self._initial[i] = float(v)\n                self.initial_type[i] = \"Fix\"\n            else:\n                raise ValueError(\n                    f\"Invalid boundary condition format: {v}. \"\n                    f\"Use a number (defaults to fixed) or tuple ('type', value) \"\n                    f\"where type is 'fixed', 'free', 'minimize', or 'maximize'.\"\n                )\n\n        self._check_bounds_against_initial_final()\n\n    @property\n    def final(self):\n        \"\"\"Get the final state boundary condition values.\n\n        Returns:\n            Array of final state values (regardless of boundary condition type),\n            or None if not set.\n\n        Note:\n            Use `final_type` to see the boundary condition types for each element.\n\n        Example:\n            Get final state boundary conditions:\n\n                x = State(\"x\", (2,))\n                x.final = [10, (\"minimize\", 0)]\n                print(x.final)  # [10. 0.]\n                print(x.final_type)  # ['Fix' 'Minimize']\n        \"\"\"\n        return self._final\n\n    @final.setter\n    def final(self, arr):\n        \"\"\"Set the final state boundary conditions.\n\n        Each element can be specified as either a simple number (defaults to \"fixed\")\n        or a tuple of (type, value) where type specifies the boundary condition.\n\n        Args:\n            arr: Array-like of final conditions. Each element can be:\n                - A number: Defaults to fixed boundary condition at that value\n                - A tuple (type, value): Where type is one of:\n                    - \"fixed\": Constrain state to this exact value\n                    - \"free\": Let optimizer choose within bounds, initialize at value\n                    - \"minimize\": Add objective term to minimize, initialize at value\n                    - \"maximize\": Add objective term to maximize, initialize at value\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape, if boundary\n                condition type is invalid, or if fixed values violate bounds\n\n        Example:\n            Set final state boundary conditionis:\n\n                pos = State(\"pos\", (3,))\n                pos.min = [0, 0, 0]\n                pos.max = [10, 10, 10]\n                # x fixed at 10, y free (starts at 5), z maximize altitude\n                pos.final = [10, (\"free\", 5), (\"maximize\", 8)]\n\n            Minimize final time in time-optimal problem:\n\n                time = State(\"t\", (1,))\n                time.final = [(\"minimize\", 10)]\n        \"\"\"\n        # Convert to list first to handle mixed types properly\n        if not isinstance(arr, (list, tuple)):\n            arr = np.asarray(arr)\n            if arr.shape != self.shape:\n                raise ValueError(f\"Shape mismatch: {arr.shape} != {self.shape}\")\n            arr = arr.tolist()\n\n        # Ensure we have the right number of elements\n        if len(arr) != self.shape[0]:\n            raise ValueError(f\"Length mismatch: got {len(arr)} elements, expected {self.shape[0]}\")\n\n        self._final = np.zeros(self.shape, dtype=float)\n        self.final_type = np.full(self.shape, \"Fix\", dtype=object)\n\n        for i, v in enumerate(arr):\n            if isinstance(v, tuple) and len(v) == 2:\n                # Tuple API: (type, value)\n                bc_type_str, bc_value = v\n                try:\n                    bc_type = BoundaryType(bc_type_str)  # Validates the string\n                except ValueError:\n                    valid_types = [t.value for t in BoundaryType]\n                    raise ValueError(\n                        f\"Invalid boundary condition type: {bc_type_str}. \"\n                        f\"Valid types are: {valid_types}\"\n                    )\n                self._final[i] = float(bc_value)\n                self.final_type[i] = bc_type.value.capitalize()\n            elif isinstance(v, (int, float, np.number)):\n                # Simple number defaults to fixed\n                self._final[i] = float(v)\n                self.final_type[i] = \"Fix\"\n            else:\n                raise ValueError(\n                    f\"Invalid boundary condition format: {v}. \"\n                    f\"Use a number (defaults to fixed) or tuple ('type', value) \"\n                    f\"where type is 'fixed', 'free', 'minimize', or 'maximize'.\"\n                )\n\n        self._check_bounds_against_initial_final()\n\n    @property\n    def scaling_min(self):\n        \"\"\"Get the scaling minimum bounds for the state variables.\n\n        Returns:\n            Array of scaling minimum values for each state variable element, or None if not set.\n        \"\"\"\n        return self._scaling_min\n\n    @scaling_min.setter\n    def scaling_min(self, val):\n        \"\"\"Set the scaling minimum bounds for the state variables.\n\n        Args:\n            val: Array of scaling minimum values, must match the state shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape\n        \"\"\"\n        if val is None:\n            self._scaling_min = None\n            return\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(\n                f\"Scaling min shape {val.shape} does not match State shape {self.shape}\"\n            )\n        self._scaling_min = val\n\n    @property\n    def scaling_max(self):\n        \"\"\"Get the scaling maximum bounds for the state variables.\n\n        Returns:\n            Array of scaling maximum values for each state variable element, or None if not set.\n        \"\"\"\n        return self._scaling_max\n\n    @scaling_max.setter\n    def scaling_max(self, val):\n        \"\"\"Set the scaling maximum bounds for the state variables.\n\n        Args:\n            val: Array of scaling maximum values, must match the state shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape\n        \"\"\"\n        if val is None:\n            self._scaling_max = None\n            return\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(\n                f\"Scaling max shape {val.shape} does not match State shape {self.shape}\"\n            )\n        self._scaling_max = val\n\n    def __repr__(self):\n        \"\"\"String representation of the State object.\n\n        Returns:\n            Concise string showing the state name and shape.\n        \"\"\"\n        return f\"State('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.State.final","title":"<code>final</code>  <code>property</code> <code>writable</code>","text":"<p>Get the final state boundary condition values.</p> <p>Returns:</p> Type Description <p>Array of final state values (regardless of boundary condition type),</p> <p>or None if not set.</p> Note <p>Use <code>final_type</code> to see the boundary condition types for each element.</p> Example <p>Get final state boundary conditions:</p> <pre><code>x = State(\"x\", (2,))\nx.final = [10, (\"minimize\", 0)]\nprint(x.final)  # [10. 0.]\nprint(x.final_type)  # ['Fix' 'Minimize']\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.State.initial","title":"<code>initial</code>  <code>property</code> <code>writable</code>","text":"<p>Get the initial state boundary condition values.</p> <p>Returns:</p> Type Description <p>Array of initial state values (regardless of boundary condition type),</p> <p>or None if not set.</p> Note <p>Use <code>initial_type</code> to see the boundary condition types for each element.</p> Example <p>Get initial state boundary conditions:</p> <pre><code>x = State(\"x\", (2,))\nx.initial = [0, (\"free\", 1)]\nprint(x.initial)  # [0. 1.]\nprint(x.initial_type)  # ['Fix' 'Free']\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.State.max","title":"<code>max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the maximum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of maximum values for each state variable element.</p> Example <p>Get upper bounds:</p> <pre><code>vel = State(\"vel\", (3,))\nvel.max = [10, 10, 5]\nprint(vel.max)  # [10. 10. 5.]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.State.min","title":"<code>min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the minimum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of minimum values for each state variable element.</p> Example <p>Get lower bounds:</p> <pre><code>pos = State(\"pos\", (3,))\npos.min = [0, 0, 10]\nprint(pos.min)  # [0. 0. 10.]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.State.scaling_max","title":"<code>scaling_max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling maximum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of scaling maximum values for each state variable element, or None if not set.</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.State.scaling_min","title":"<code>scaling_min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling minimum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of scaling minimum values for each state variable element, or None if not set.</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.State._check_bounds_against_initial_final","title":"<code>_check_bounds_against_initial_final()</code>","text":"<p>Validate that fixed boundary conditions respect min/max bounds.</p> <p>This internal method is automatically called when bounds or boundary conditions are set to ensure consistency.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any fixed initial or final value violates the min/max bounds</p> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def _check_bounds_against_initial_final(self):\n    \"\"\"Validate that fixed boundary conditions respect min/max bounds.\n\n    This internal method is automatically called when bounds or boundary\n    conditions are set to ensure consistency.\n\n    Raises:\n        ValueError: If any fixed initial or final value violates the min/max bounds\n    \"\"\"\n    for field_name, data, types in [\n        (\"initial\", self._initial, self.initial_type),\n        (\"final\", self._final, self.final_type),\n    ]:\n        if data is None or types is None:\n            continue\n        for i, val in np.ndenumerate(data):\n            if types[i] != \"Fix\":\n                continue\n            min_i = self._min[i] if self._min is not None else -np.inf\n            max_i = self._max[i] if self._max is not None else np.inf\n            if val &lt; min_i:\n                raise ValueError(\n                    f\"{field_name.capitalize()} Fixed value at index {i[0]} is lower then the \"\n                    f\"min: {val} &lt; {min_i}\"\n                )\n            if val &gt; max_i:\n                raise ValueError(\n                    f\"{field_name.capitalize()} Fixed value at index {i[0]} is greater then \"\n                    f\"the max: {val} &gt; {max_i}\"\n                )\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.State._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash State including boundary condition types.</p> <p>Extends Variable._hash_into to include the structural metadata that affects the compiled problem: boundary condition types (fixed, free, minimize, maximize). Values are not hashed as they are runtime parameters.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash State including boundary condition types.\n\n    Extends Variable._hash_into to include the structural metadata that\n    affects the compiled problem: boundary condition types (fixed, free,\n    minimize, maximize). Values are not hashed as they are runtime parameters.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    # Hash the base Variable attributes (class name, shape, slice)\n    super()._hash_into(hasher)\n    # Hash boundary condition types (these affect constraint structure)\n    if self.initial_type is not None:\n        hasher.update(b\"initial_type:\")\n        hasher.update(str(self.initial_type.tolist()).encode())\n    if self.final_type is not None:\n        hasher.update(b\"final_type:\")\n        hasher.update(str(self.final_type.tolist()).encode())\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sub","title":"<code>Sub</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Subtraction operation for symbolic expressions.</p> <p>Represents element-wise subtraction (left - right). Supports broadcasting following NumPy rules. Can be created using the - operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>left</code> <p>Left-hand side expression (minuend)</p> <code>right</code> <p>Right-hand side expression (subtrahend)</p> Example <p>Define a Sub expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(3,))\nz = x - y  # Creates Sub(x, y)\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Sub(Expr):\n    \"\"\"Subtraction operation for symbolic expressions.\n\n    Represents element-wise subtraction (left - right). Supports broadcasting\n    following NumPy rules. Can be created using the - operator on Expr objects.\n\n    Attributes:\n        left: Left-hand side expression (minuend)\n        right: Right-hand side expression (subtrahend)\n\n    Example:\n        Define a Sub expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(3,))\n            z = x - y  # Creates Sub(x, y)\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\"Initialize a subtraction operation.\n\n        Args:\n            left: Expression to subtract from (minuend)\n            right: Expression to subtract (subtrahend)\n        \"\"\"\n        self.left = left\n        self.right = right\n\n    def children(self):\n        return [self.left, self.right]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize subtraction: fold constants if both sides are constants.\n\n        Returns:\n            Expr: Canonical form of the subtraction expression\n        \"\"\"\n        left = self.left.canonicalize()\n        right = self.right.canonicalize()\n        if isinstance(left, Constant) and isinstance(right, Constant):\n            return Constant(left.value - right.value)\n        return Sub(left, right)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n        Returns:\n            tuple: The broadcasted shape of all operands\n\n        Raises:\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Sub shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        return f\"({self.left!r} - {self.right!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sub.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize subtraction: fold constants if both sides are constants.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the subtraction expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize subtraction: fold constants if both sides are constants.\n\n    Returns:\n        Expr: Canonical form of the subtraction expression\n    \"\"\"\n    left = self.left.canonicalize()\n    right = self.right.canonicalize()\n    if isinstance(left, Constant) and isinstance(right, Constant):\n        return Constant(left.value - right.value)\n    return Sub(left, right)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sub.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check shape compatibility and compute broadcasted result shape like NumPy.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The broadcasted shape of all operands</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n    Returns:\n        tuple: The broadcasted shape of all operands\n\n    Raises:\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Sub shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sum","title":"<code>Sum</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Sum reduction operation for symbolic expressions.</p> <p>Sums all elements of an expression, reducing it to a scalar. This is a reduction operation that collapses all dimensions.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression whose elements will be summed</p> Example <p>Define a Sum expression::</p> <pre><code>x = ox.State(\"x\", shape=(3, 4))\ntotal = Sum(x)  # Creates Sum(x), result shape ()\n</code></pre> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>class Sum(Expr):\n    \"\"\"Sum reduction operation for symbolic expressions.\n\n    Sums all elements of an expression, reducing it to a scalar. This is a\n    reduction operation that collapses all dimensions.\n\n    Attributes:\n        operand: Expression whose elements will be summed\n\n    Example:\n        Define a Sum expression::\n\n            x = ox.State(\"x\", shape=(3, 4))\n            total = Sum(x)  # Creates Sum(x), result shape ()\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a sum reduction operation.\n\n        Args:\n            operand: Expression to sum over all elements\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize sum: canonicalize the operand.\n\n        Returns:\n            Expr: Canonical form of the sum expression\n        \"\"\"\n        operand = self.operand.canonicalize()\n        return Sum(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Sum reduces any shape to a scalar.\"\"\"\n        # Validate that the operand has a valid shape\n        self.operand.check_shape()\n        # Sum always produces a scalar regardless of input shape\n        return ()\n\n    def __repr__(self):\n        return f\"sum({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sum.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize sum: canonicalize the operand.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the sum expression</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize sum: canonicalize the operand.\n\n    Returns:\n        Expr: Canonical form of the sum expression\n    \"\"\"\n    operand = self.operand.canonicalize()\n    return Sum(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sum.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Sum reduces any shape to a scalar.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Sum reduces any shape to a scalar.\"\"\"\n    # Validate that the operand has a valid shape\n    self.operand.check_shape()\n    # Sum always produces a scalar regardless of input shape\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Tan","title":"<code>Tan</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise tangent function for symbolic expressions.</p> <p>Computes the tangent of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply tangent function to</p> Example <p>Define a Tan expression:</p> <pre><code>theta = Variable(\"theta\", shape=(3,))\ntan_theta = Tan(theta)\n</code></pre> Note <p>Tan is only supported for JAX lowering. CVXPy lowering will raise NotImplementedError since tangent is not DCP-compliant.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Tan(Expr):\n    \"\"\"Element-wise tangent function for symbolic expressions.\n\n    Computes the tangent of each element in the operand. Preserves the shape\n    of the input expression.\n\n    Attributes:\n        operand: Expression to apply tangent function to\n\n    Example:\n        Define a Tan expression:\n\n            theta = Variable(\"theta\", shape=(3,))\n            tan_theta = Tan(theta)\n\n    Note:\n        Tan is only supported for JAX lowering. CVXPy lowering will raise\n        NotImplementedError since tangent is not DCP-compliant.\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a tangent operation.\n\n        Args:\n            operand: Expression to apply tangent function to\n        \"\"\"\n        self.operand = operand\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Tan(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Tan preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"(tan({self.operand!r}))\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Tan.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Tan preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Tan preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Transpose","title":"<code>Transpose</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Matrix transpose operation for symbolic expressions.</p> <p>Transposes the last two dimensions of an expression. For matrices, this swaps rows and columns. For higher-dimensional arrays, it swaps the last two axes. Scalars and vectors are unchanged by transposition.</p> <p>The canonicalization includes an optimization that eliminates double transposes: (A.T).T simplifies to A.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to transpose</p> Example <p>Define Tranpose expressions:</p> <pre><code>A = Variable(\"A\", shape=(3, 4))\nA_T = Transpose(A)  # or A.T, result shape (4, 3)\nv = Variable(\"v\", shape=(5,))\nv_T = Transpose(v)  # result shape (5,) - vectors unchanged\n</code></pre> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>class Transpose(Expr):\n    \"\"\"Matrix transpose operation for symbolic expressions.\n\n    Transposes the last two dimensions of an expression. For matrices, this swaps\n    rows and columns. For higher-dimensional arrays, it swaps the last two axes.\n    Scalars and vectors are unchanged by transposition.\n\n    The canonicalization includes an optimization that eliminates double transposes:\n    (A.T).T simplifies to A.\n\n    Attributes:\n        operand: Expression to transpose\n\n    Example:\n        Define Tranpose expressions:\n\n            A = Variable(\"A\", shape=(3, 4))\n            A_T = Transpose(A)  # or A.T, result shape (4, 3)\n            v = Variable(\"v\", shape=(5,))\n            v_T = Transpose(v)  # result shape (5,) - vectors unchanged\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a transpose operation.\n\n        Args:\n            operand: Expression to transpose\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the operand with double transpose optimization.\"\"\"\n        operand = self.operand.canonicalize()\n\n        # Double transpose optimization: (A.T).T = A\n        if isinstance(operand, Transpose):\n            return operand.operand\n\n        return Transpose(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Matrix transpose operation swaps the last two dimensions.\"\"\"\n        operand_shape = self.operand.check_shape()\n\n        if len(operand_shape) == 0:\n            # Scalar transpose is the scalar itself\n            return ()\n        elif len(operand_shape) == 1:\n            # Vector transpose is the vector itself (row vector remains row vector)\n            return operand_shape\n        elif len(operand_shape) == 2:\n            # Matrix transpose: (m,n) -&gt; (n,m)\n            return (operand_shape[1], operand_shape[0])\n        else:\n            # Higher-dimensional array: transpose last two dimensions\n            # (..., m, n) -&gt; (..., n, m)\n            return operand_shape[:-2] + (operand_shape[-1], operand_shape[-2])\n\n    def __repr__(self):\n        return f\"({self.operand!r}).T\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Transpose.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the operand with double transpose optimization.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the operand with double transpose optimization.\"\"\"\n    operand = self.operand.canonicalize()\n\n    # Double transpose optimization: (A.T).T = A\n    if isinstance(operand, Transpose):\n        return operand.operand\n\n    return Transpose(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Transpose.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Matrix transpose operation swaps the last two dimensions.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Matrix transpose operation swaps the last two dimensions.\"\"\"\n    operand_shape = self.operand.check_shape()\n\n    if len(operand_shape) == 0:\n        # Scalar transpose is the scalar itself\n        return ()\n    elif len(operand_shape) == 1:\n        # Vector transpose is the vector itself (row vector remains row vector)\n        return operand_shape\n    elif len(operand_shape) == 2:\n        # Matrix transpose: (m,n) -&gt; (n,m)\n        return (operand_shape[1], operand_shape[0])\n    else:\n        # Higher-dimensional array: transpose last two dimensions\n        # (..., m, n) -&gt; (..., n, m)\n        return operand_shape[:-2] + (operand_shape[-1], operand_shape[-2])\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable","title":"<code>Variable</code>","text":"<p>               Bases: <code>Leaf</code></p> <p>Base class for decision variables in optimization problems.</p> <p>Variable represents decision variables (free parameters) in an optimization problem. These are values that the optimizer can adjust to minimize the objective function while satisfying constraints. Variables can have bounds (min/max) and initial guesses to guide the optimization process.</p> <p>Unlike Parameters (which are fixed values that can be changed between solves), Variables are optimized by the solver. In trajectory optimization, Variables typically represent discretized state or control trajectories.</p> Note <p>Variable is typically not instantiated directly. Instead, use the specialized subclasses State (for state variables with boundary conditions) or Control (for control inputs). These provide additional functionality specific to trajectory optimization.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the variable</p> <code>_shape</code> <code>tuple[int, ...]</code> <p>Shape of the variable as a tuple (typically 1D)</p> <code>_slice</code> <code>slice | None</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <code>ndarray | None</code> <p>Minimum bounds for each element of the variable</p> <code>_max</code> <code>ndarray | None</code> <p>Maximum bounds for each element of the variable</p> <code>_guess</code> <code>ndarray | None</code> <p>Initial guess for the variable trajectory (n_points, n_vars)</p> Example Source code in <code>openscvx/symbolic/expr/variable.py</code> <pre><code>class Variable(Leaf):\n    \"\"\"Base class for decision variables in optimization problems.\n\n    Variable represents decision variables (free parameters) in an optimization problem.\n    These are values that the optimizer can adjust to minimize the objective function\n    while satisfying constraints. Variables can have bounds (min/max) and initial guesses\n    to guide the optimization process.\n\n    Unlike Parameters (which are fixed values that can be changed between solves),\n    Variables are optimized by the solver. In trajectory optimization, Variables typically\n    represent discretized state or control trajectories.\n\n    Note:\n        Variable is typically not instantiated directly. Instead, use the specialized\n        subclasses State (for state variables with boundary conditions) or Control\n        (for control inputs). These provide additional functionality specific to\n        trajectory optimization.\n\n    Attributes:\n        name (str): Name identifier for the variable\n        _shape (tuple[int, ...]): Shape of the variable as a tuple (typically 1D)\n        _slice (slice | None): Internal slice information for variable indexing\n        _min (np.ndarray | None): Minimum bounds for each element of the variable\n        _max (np.ndarray | None): Maximum bounds for each element of the variable\n        _guess (np.ndarray | None): Initial guess for the variable trajectory (n_points, n_vars)\n\n    Example:\n            # Typically, use State or Control instead of Variable directly:\n            pos = openscvx.State(\"pos\", shape=(3,))\n            u = openscvx.Control(\"u\", shape=(2,))\n    \"\"\"\n\n    def __init__(self, name, shape):\n        \"\"\"Initialize a Variable object.\n\n        Args:\n            name: Name identifier for the variable\n            shape: Shape of the variable as a tuple (typically 1D like (3,) for 3D vector)\n        \"\"\"\n        super().__init__(name, shape)\n        self._slice = None\n        self._min = None\n        self._max = None\n        self._guess = None\n\n    def __repr__(self):\n        return f\"Var({self.name!r})\"\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Variable using its slice (canonical position, name-invariant).\n\n        Instead of hashing the variable name, we hash the _slice attribute\n        which represents the variable's canonical position in the unified\n        state/control vector. This ensures that two problems with the same\n        structure but different variable names produce the same hash.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(self.__class__.__name__.encode())\n        hasher.update(str(self._shape).encode())\n        # Hash the slice (canonical position) - this is name-invariant\n        if self._slice is not None:\n            hasher.update(f\"slice:{self._slice.start}:{self._slice.stop}\".encode())\n        else:\n            raise RuntimeError(\n                f\"Cannot hash Variable '{self.name}' without _slice attribute. \"\n                \"Hashing should only be called on preprocessed problems where \"\n                \"all Variables have been assigned canonical slice positions.\"\n            )\n\n    @property\n    def min(self):\n        \"\"\"Get the minimum bounds (lower bounds) for the variable.\n\n        Returns:\n            Array of minimum values for each element of the variable, or None if unbounded.\n\n        Example:\n                pos = Variable(\"pos\", shape=(3,))\n                pos.min = [-10, -10, 0]\n                print(pos.min)  # [-10., -10., 0.]\n        \"\"\"\n        return self._min\n\n    @min.setter\n    def min(self, arr):\n        \"\"\"Set the minimum bounds (lower bounds) for the variable.\n\n        The bounds are applied element-wise to each component of the variable.\n        Scalars will be broadcast to match the variable shape.\n\n        Args:\n            arr: Array of minimum values, must be broadcastable to shape (n,)\n                where n is the variable dimension\n\n        Raises:\n            ValueError: If the shape of arr doesn't match the variable shape\n\n        Example:\n                pos = Variable(\"pos\", shape=(3,))\n                pos.min = -10  # Broadcasts to [-10, -10, -10]\n                pos.min = [-5, -10, 0]  # Element-wise bounds\n        \"\"\"\n        arr = np.asarray(arr, dtype=float)\n        if arr.ndim != 1 or arr.shape[0] != self.shape[0]:\n            raise ValueError(\n                f\"{self.__class__.__name__} min must be 1D with shape ({self.shape[0]},), got\"\n                f\" {arr.shape}\"\n            )\n        self._min = arr\n\n    @property\n    def max(self):\n        \"\"\"Get the maximum bounds (upper bounds) for the variable.\n\n        Returns:\n            Array of maximum values for each element of the variable, or None if unbounded.\n\n        Example:\n                vel = Variable(\"vel\", shape=(3,))\n                vel.max = [10, 10, 5]\n                print(vel.max)  # [10., 10., 5.]\n        \"\"\"\n        return self._max\n\n    @max.setter\n    def max(self, arr):\n        \"\"\"Set the maximum bounds (upper bounds) for the variable.\n\n        The bounds are applied element-wise to each component of the variable.\n        Scalars will be broadcast to match the variable shape.\n\n        Args:\n            arr: Array of maximum values, must be broadcastable to shape (n,)\n                where n is the variable dimension\n\n        Raises:\n            ValueError: If the shape of arr doesn't match the variable shape\n\n        Example:\n                vel = Variable(\"vel\", shape=(3,))\n                vel.max = 10  # Broadcasts to [10, 10, 10]\n                vel.max = [15, 10, 5]  # Element-wise bounds\n        \"\"\"\n        arr = np.asarray(arr, dtype=float)\n        if arr.ndim != 1 or arr.shape[0] != self.shape[0]:\n            raise ValueError(\n                f\"{self.__class__.__name__} max must be 1D with shape ({self.shape[0]},), got\"\n                f\" {arr.shape}\"\n            )\n        self._max = arr\n\n    @property\n    def guess(self):\n        \"\"\"Get the initial guess for the variable trajectory.\n\n        The guess provides a starting point for the optimizer. A good initial guess\n        can significantly improve convergence speed and help avoid local minima.\n\n        Returns:\n            2D array of shape (n_points, n_vars) representing the variable trajectory\n            over time, or None if no guess is provided.\n\n        Example:\n                x = Variable(\"x\", shape=(2,))\n                # Linear interpolation from [0,0] to [10,10] over 50 points\n                x.guess = np.linspace([0, 0], [10, 10], 50)\n                print(x.guess.shape)  # (50, 2)\n        \"\"\"\n        return self._guess\n\n    @guess.setter\n    def guess(self, arr):\n        \"\"\"Set the initial guess for the variable trajectory.\n\n        The guess should be a 2D array where each row represents the variable value\n        at a particular time point or trajectory node.\n\n        Args:\n            arr: 2D array of shape (n_points, n_vars) where n_vars matches the\n                variable dimension. Can be fewer points than the final trajectory -\n                the solver will interpolate as needed.\n\n        Raises:\n            ValueError: If the array is not 2D or if the second dimension doesn't\n                match the variable dimension\n\n        Example:\n                pos = Variable(\"pos\", shape=(3,))\n                # Create a straight-line trajectory from origin to target\n                n_points = 50\n                pos.guess = np.linspace([0, 0, 0], [10, 5, 3], n_points)\n        \"\"\"\n        arr = np.asarray(arr, dtype=float)\n        if arr.ndim != 2:\n            raise ValueError(\n                f\"Guess must be a 2D array of shape (n_guess_points, {self.shape[0]}), got shape\"\n                f\" {arr.shape}\"\n            )\n        if arr.shape[1] != self.shape[0]:\n            raise ValueError(\n                f\"Guess must have second dimension equal to variable dimension {self.shape[0]}, got\"\n                f\" {arr.shape[1]}\"\n            )\n        self._guess = arr\n\n    def append(self, other=None, *, min=-np.inf, max=np.inf, guess=0.0):\n        \"\"\"Append a new dimension to this variable or merge with another variable.\n\n        This method extends the variable's dimension by either:\n        1. Appending another Variable object (concatenating their dimensions)\n        2. Adding a single new scalar dimension with specified bounds and guess\n\n        The bounds and guesses of both variables are concatenated appropriately.\n\n        Args:\n            other: Another Variable object to append. If None, adds a single scalar\n                dimension with the specified min/max/guess values.\n            min: Minimum bound for the new dimension (only used if other is None).\n                Defaults to -np.inf (unbounded below).\n            max: Maximum bound for the new dimension (only used if other is None).\n                Defaults to np.inf (unbounded above).\n            guess: Initial guess value for the new dimension (only used if other is None).\n                Defaults to 0.0.\n\n        Example:\n            Create a 2D variable and extend it to 3D:\n\n                pos_xy = Variable(\"pos\", shape=(2,))\n                pos_xy.min = [-10, -10]\n                pos_xy.max = [10, 10]\n                pos_xy.append(min=0, max=100)  # Add z dimension\n                print(pos_xy.shape)  # (3,)\n                print(pos_xy.min)  # [-10., -10., 0.]\n                print(pos_xy.max)  # [10., 10., 100.]\n\n            Merge two variables:\n\n                pos = Variable(\"pos\", shape=(3,))\n                vel = Variable(\"vel\", shape=(3,))\n                pos.append(vel)  # Now pos has shape (6,)\n        \"\"\"\n\n        def process_array(val, is_guess=False):\n            \"\"\"Process input array to ensure correct shape and type.\n\n            Args:\n                val: Input value to process\n                is_guess: Whether the value is a guess array\n\n            Returns:\n                Processed array with correct shape and type\n            \"\"\"\n            arr = np.asarray(val, dtype=float)\n            if is_guess:\n                return np.atleast_2d(arr)\n            return np.atleast_1d(arr)\n\n        if isinstance(other, Variable):\n            self._shape = (self.shape[0] + other.shape[0],)\n\n            if self._min is not None and other._min is not None:\n                self._min = np.concatenate([self._min, process_array(other._min)], axis=0)\n\n            if self._max is not None and other._max is not None:\n                self._max = np.concatenate([self._max, process_array(other._max)], axis=0)\n\n            if self._guess is not None and other._guess is not None:\n                self._guess = np.concatenate(\n                    [self._guess, process_array(other._guess, is_guess=True)], axis=1\n                )\n\n        else:\n            self._shape = (self.shape[0] + 1,)\n\n            if self._min is not None:\n                self._min = np.concatenate([self._min, process_array(min)], axis=0)\n\n            if self._max is not None:\n                self._max = np.concatenate([self._max, process_array(max)], axis=0)\n\n            if self._guess is not None:\n                guess_arr = process_array(guess, is_guess=True)\n                if guess_arr.shape[1] != 1:\n                    guess_arr = guess_arr.T\n                self._guess = np.concatenate([self._guess, guess_arr], axis=1)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable--typically-use-state-or-control-instead-of-variable-directly","title":"Typically, use State or Control instead of Variable directly:","text":"<p>pos = openscvx.State(\"pos\", shape=(3,)) u = openscvx.Control(\"u\", shape=(2,))</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable.guess","title":"<code>guess</code>  <code>property</code> <code>writable</code>","text":"<p>Get the initial guess for the variable trajectory.</p> <p>The guess provides a starting point for the optimizer. A good initial guess can significantly improve convergence speed and help avoid local minima.</p> <p>Returns:</p> Type Description <p>2D array of shape (n_points, n_vars) representing the variable trajectory</p> <p>over time, or None if no guess is provided.</p> Example <p>x = Variable(\"x\", shape=(2,))</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable.guess--linear-interpolation-from-00-to-1010-over-50-points","title":"Linear interpolation from [0,0] to [10,10] over 50 points","text":"<p>x.guess = np.linspace([0, 0], [10, 10], 50) print(x.guess.shape)  # (50, 2)</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable.max","title":"<code>max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the maximum bounds (upper bounds) for the variable.</p> <p>Returns:</p> Type Description <p>Array of maximum values for each element of the variable, or None if unbounded.</p> Example <p>vel = Variable(\"vel\", shape=(3,)) vel.max = [10, 10, 5] print(vel.max)  # [10., 10., 5.]</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable.min","title":"<code>min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the minimum bounds (lower bounds) for the variable.</p> <p>Returns:</p> Type Description <p>Array of minimum values for each element of the variable, or None if unbounded.</p> Example <p>pos = Variable(\"pos\", shape=(3,)) pos.min = [-10, -10, 0] print(pos.min)  # [-10., -10., 0.]</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash Variable using its slice (canonical position, name-invariant).</p> <p>Instead of hashing the variable name, we hash the _slice attribute which represents the variable's canonical position in the unified state/control vector. This ensures that two problems with the same structure but different variable names produce the same hash.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/variable.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash Variable using its slice (canonical position, name-invariant).\n\n    Instead of hashing the variable name, we hash the _slice attribute\n    which represents the variable's canonical position in the unified\n    state/control vector. This ensures that two problems with the same\n    structure but different variable names produce the same hash.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(self.__class__.__name__.encode())\n    hasher.update(str(self._shape).encode())\n    # Hash the slice (canonical position) - this is name-invariant\n    if self._slice is not None:\n        hasher.update(f\"slice:{self._slice.start}:{self._slice.stop}\".encode())\n    else:\n        raise RuntimeError(\n            f\"Cannot hash Variable '{self.name}' without _slice attribute. \"\n            \"Hashing should only be called on preprocessed problems where \"\n            \"all Variables have been assigned canonical slice positions.\"\n        )\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable.append","title":"<code>append(other=None, *, min=-np.inf, max=np.inf, guess=0.0)</code>","text":"<p>Append a new dimension to this variable or merge with another variable.</p> <p>This method extends the variable's dimension by either: 1. Appending another Variable object (concatenating their dimensions) 2. Adding a single new scalar dimension with specified bounds and guess</p> <p>The bounds and guesses of both variables are concatenated appropriately.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>Another Variable object to append. If None, adds a single scalar dimension with the specified min/max/guess values.</p> <code>None</code> <code>min</code> <p>Minimum bound for the new dimension (only used if other is None). Defaults to -np.inf (unbounded below).</p> <code>-inf</code> <code>max</code> <p>Maximum bound for the new dimension (only used if other is None). Defaults to np.inf (unbounded above).</p> <code>inf</code> <code>guess</code> <p>Initial guess value for the new dimension (only used if other is None). Defaults to 0.0.</p> <code>0.0</code> Example <p>Create a 2D variable and extend it to 3D:</p> <pre><code>pos_xy = Variable(\"pos\", shape=(2,))\npos_xy.min = [-10, -10]\npos_xy.max = [10, 10]\npos_xy.append(min=0, max=100)  # Add z dimension\nprint(pos_xy.shape)  # (3,)\nprint(pos_xy.min)  # [-10., -10., 0.]\nprint(pos_xy.max)  # [10., 10., 100.]\n</code></pre> <p>Merge two variables:</p> <pre><code>pos = Variable(\"pos\", shape=(3,))\nvel = Variable(\"vel\", shape=(3,))\npos.append(vel)  # Now pos has shape (6,)\n</code></pre> Source code in <code>openscvx/symbolic/expr/variable.py</code> <pre><code>def append(self, other=None, *, min=-np.inf, max=np.inf, guess=0.0):\n    \"\"\"Append a new dimension to this variable or merge with another variable.\n\n    This method extends the variable's dimension by either:\n    1. Appending another Variable object (concatenating their dimensions)\n    2. Adding a single new scalar dimension with specified bounds and guess\n\n    The bounds and guesses of both variables are concatenated appropriately.\n\n    Args:\n        other: Another Variable object to append. If None, adds a single scalar\n            dimension with the specified min/max/guess values.\n        min: Minimum bound for the new dimension (only used if other is None).\n            Defaults to -np.inf (unbounded below).\n        max: Maximum bound for the new dimension (only used if other is None).\n            Defaults to np.inf (unbounded above).\n        guess: Initial guess value for the new dimension (only used if other is None).\n            Defaults to 0.0.\n\n    Example:\n        Create a 2D variable and extend it to 3D:\n\n            pos_xy = Variable(\"pos\", shape=(2,))\n            pos_xy.min = [-10, -10]\n            pos_xy.max = [10, 10]\n            pos_xy.append(min=0, max=100)  # Add z dimension\n            print(pos_xy.shape)  # (3,)\n            print(pos_xy.min)  # [-10., -10., 0.]\n            print(pos_xy.max)  # [10., 10., 100.]\n\n        Merge two variables:\n\n            pos = Variable(\"pos\", shape=(3,))\n            vel = Variable(\"vel\", shape=(3,))\n            pos.append(vel)  # Now pos has shape (6,)\n    \"\"\"\n\n    def process_array(val, is_guess=False):\n        \"\"\"Process input array to ensure correct shape and type.\n\n        Args:\n            val: Input value to process\n            is_guess: Whether the value is a guess array\n\n        Returns:\n            Processed array with correct shape and type\n        \"\"\"\n        arr = np.asarray(val, dtype=float)\n        if is_guess:\n            return np.atleast_2d(arr)\n        return np.atleast_1d(arr)\n\n    if isinstance(other, Variable):\n        self._shape = (self.shape[0] + other.shape[0],)\n\n        if self._min is not None and other._min is not None:\n            self._min = np.concatenate([self._min, process_array(other._min)], axis=0)\n\n        if self._max is not None and other._max is not None:\n            self._max = np.concatenate([self._max, process_array(other._max)], axis=0)\n\n        if self._guess is not None and other._guess is not None:\n            self._guess = np.concatenate(\n                [self._guess, process_array(other._guess, is_guess=True)], axis=1\n            )\n\n    else:\n        self._shape = (self.shape[0] + 1,)\n\n        if self._min is not None:\n            self._min = np.concatenate([self._min, process_array(min)], axis=0)\n\n        if self._max is not None:\n            self._max = np.concatenate([self._max, process_array(max)], axis=0)\n\n        if self._guess is not None:\n            guess_arr = process_array(guess, is_guess=True)\n            if guess_arr.shape[1] != 1:\n                guess_arr = guess_arr.T\n            self._guess = np.concatenate([self._guess, guess_arr], axis=1)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Vstack","title":"<code>Vstack</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Vertical stacking operation for symbolic expressions.</p> <p>Concatenates expressions vertically (along rows for 2D arrays). This is analogous to numpy.vstack() or jax.numpy.vstack().</p> <p>All input expressions must have the same number of dimensions, and all dimensions except the first must match. The result concatenates along axis 0 (rows).</p> <p>Attributes:</p> Name Type Description <code>arrays</code> <p>List of expressions to stack vertically</p> Example <p>Stack vectors to create a matrix:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(3,))\nv = Vstack([x, y])  # Result shape (2, 3)\n</code></pre> <p>Stack matrices vertically:</p> <pre><code>A = Variable(\"A\", shape=(3, 4))\nB = Variable(\"B\", shape=(2, 4))\nC = Vstack([A, B])  # Result shape (5, 4)\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Vstack(Expr):\n    \"\"\"Vertical stacking operation for symbolic expressions.\n\n    Concatenates expressions vertically (along rows for 2D arrays).\n    This is analogous to numpy.vstack() or jax.numpy.vstack().\n\n    All input expressions must have the same number of dimensions, and all\n    dimensions except the first must match. The result concatenates along\n    axis 0 (rows).\n\n    Attributes:\n        arrays: List of expressions to stack vertically\n\n    Example:\n        Stack vectors to create a matrix:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(3,))\n            v = Vstack([x, y])  # Result shape (2, 3)\n\n        Stack matrices vertically:\n\n            A = Variable(\"A\", shape=(3, 4))\n            B = Variable(\"B\", shape=(2, 4))\n            C = Vstack([A, B])  # Result shape (5, 4)\n    \"\"\"\n\n    def __init__(self, arrays):\n        \"\"\"Initialize a vertical stack operation.\n\n        Args:\n            arrays: List of expressions to concatenate vertically.\n                    All must have matching dimensions except the first.\n        \"\"\"\n        self.arrays = [to_expr(arr) for arr in arrays]\n\n    def children(self):\n        return self.arrays\n\n    def canonicalize(self) -&gt; \"Expr\":\n        arrays = [arr.canonicalize() for arr in self.arrays]\n        return Vstack(arrays)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Vertical stack concatenates arrays along the first axis (rows).\"\"\"\n        if not self.arrays:\n            raise ValueError(\"Vstack requires at least one array\")\n\n        array_shapes = [arr.check_shape() for arr in self.arrays]\n\n        # All arrays must have the same number of dimensions\n        first_ndim = len(array_shapes[0])\n        for i, shape in enumerate(array_shapes[1:], 1):\n            if len(shape) != first_ndim:\n                raise ValueError(\n                    f\"Vstack array {i} has {len(shape)} dimensions, but array 0 has {first_ndim}\"\n                )\n\n        # All dimensions except the first must match\n        first_shape = array_shapes[0]\n        for i, shape in enumerate(array_shapes[1:], 1):\n            if shape[1:] != first_shape[1:]:\n                raise ValueError(\n                    f\"Vstack array {i} has trailing dimensions {shape[1:]}, \"\n                    f\"but array 0 has {first_shape[1:]}\"\n                )\n\n        # Result shape: concatenate along axis 0 (rows)\n        total_rows = sum(shape[0] for shape in array_shapes)\n        return (total_rows,) + first_shape[1:]\n\n    def __repr__(self):\n        arrays_repr = \", \".join(repr(arr) for arr in self.arrays)\n        return f\"Vstack([{arrays_repr}])\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Vstack.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Vertical stack concatenates arrays along the first axis (rows).</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Vertical stack concatenates arrays along the first axis (rows).\"\"\"\n    if not self.arrays:\n        raise ValueError(\"Vstack requires at least one array\")\n\n    array_shapes = [arr.check_shape() for arr in self.arrays]\n\n    # All arrays must have the same number of dimensions\n    first_ndim = len(array_shapes[0])\n    for i, shape in enumerate(array_shapes[1:], 1):\n        if len(shape) != first_ndim:\n            raise ValueError(\n                f\"Vstack array {i} has {len(shape)} dimensions, but array 0 has {first_ndim}\"\n            )\n\n    # All dimensions except the first must match\n    first_shape = array_shapes[0]\n    for i, shape in enumerate(array_shapes[1:], 1):\n        if shape[1:] != first_shape[1:]:\n            raise ValueError(\n                f\"Vstack array {i} has trailing dimensions {shape[1:]}, \"\n                f\"but array 0 has {first_shape[1:]}\"\n            )\n\n    # Result shape: concatenate along axis 0 (rows)\n    total_rows = sum(shape[0] for shape in array_shapes)\n    return (total_rows,) + first_shape[1:]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Fixed","title":"<code>Fixed(value)</code>","text":"<p>Create a fixed boundary condition tuple.</p> <p>This is a convenience function that returns a tuple (\"fixed\", value) which can be used to explicitly specify fixed boundary conditions for State or Time objects. Note that plain numbers default to fixed, so this is mainly for clarity.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>Fixed value for the boundary condition.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(\"fixed\", value) tuple suitable for use in State.initial, State.final, or Time.initial, Time.final.</p> Example <pre><code>pos = ox.State(\"pos\", (3,))\npos.final = [ox.Fixed(10.0), ox.Free(5.0), ox.Fixed(2.0)]\n\n# Equivalent to:\npos.final = [10.0, ox.Free(5.0), 2.0]  # Plain numbers default to fixed\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def Fixed(value):\n    \"\"\"Create a fixed boundary condition tuple.\n\n    This is a convenience function that returns a tuple (\"fixed\", value) which\n    can be used to explicitly specify fixed boundary conditions for State or Time objects.\n    Note that plain numbers default to fixed, so this is mainly for clarity.\n\n    Args:\n        value: Fixed value for the boundary condition.\n\n    Returns:\n        tuple: (\"fixed\", value) tuple suitable for use in State.initial, State.final,\n            or Time.initial, Time.final.\n\n    Example:\n        ```python\n        pos = ox.State(\"pos\", (3,))\n        pos.final = [ox.Fixed(10.0), ox.Free(5.0), ox.Fixed(2.0)]\n\n        # Equivalent to:\n        pos.final = [10.0, ox.Free(5.0), 2.0]  # Plain numbers default to fixed\n        ```\n    \"\"\"\n    return (\"fixed\", value)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Free","title":"<code>Free(guess)</code>","text":"<p>Create a free boundary condition tuple.</p> <p>This is a convenience function that returns a tuple (\"free\", guess) which can be used to specify free boundary conditions for State or Time objects.</p> <p>Parameters:</p> Name Type Description Default <code>guess</code> <p>Initial guess value for the free variable.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(\"free\", guess) tuple suitable for use in State.initial, State.final, or Time.initial, Time.final.</p> Example <pre><code>pos = ox.State(\"pos\", (3,))\npos.final = [ox.Free(5.0), ox.Free(3.0), 10]  # First two free, third fixed\n\ntime = ox.Time(\n    initial=0.0,\n    final=ox.Free(10.0),\n    min=0.0,\n    max=20.0\n)\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def Free(guess):\n    \"\"\"Create a free boundary condition tuple.\n\n    This is a convenience function that returns a tuple (\"free\", guess) which\n    can be used to specify free boundary conditions for State or Time objects.\n\n    Args:\n        guess: Initial guess value for the free variable.\n\n    Returns:\n        tuple: (\"free\", guess) tuple suitable for use in State.initial, State.final,\n            or Time.initial, Time.final.\n\n    Example:\n        ```python\n        pos = ox.State(\"pos\", (3,))\n        pos.final = [ox.Free(5.0), ox.Free(3.0), 10]  # First two free, third fixed\n\n        time = ox.Time(\n            initial=0.0,\n            final=ox.Free(10.0),\n            min=0.0,\n            max=20.0\n        )\n        ```\n    \"\"\"\n    return (\"free\", guess)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Maximize","title":"<code>Maximize(guess)</code>","text":"<p>Create a maximize boundary condition tuple.</p> <p>This is a convenience function that returns a tuple (\"maximize\", guess) which can be used to specify that a boundary value should be maximized in the objective function for State or Time objects.</p> <p>Parameters:</p> Name Type Description Default <code>guess</code> <p>Initial guess value for the variable to be maximized.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(\"maximize\", guess) tuple suitable for use in State.initial, State.final, or Time.initial, Time.final.</p> Example <pre><code>altitude = ox.State(\"altitude\", (1,))\naltitude.final = [ox.Maximize(100.0)]  # Maximize final altitude\n\ntime = ox.Time(\n    initial=ox.Maximize(0.0),  # Maximize initial time\n    final=10.0,\n    min=0.0,\n    max=20.0\n)\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def Maximize(guess):\n    \"\"\"Create a maximize boundary condition tuple.\n\n    This is a convenience function that returns a tuple (\"maximize\", guess) which\n    can be used to specify that a boundary value should be maximized in the objective\n    function for State or Time objects.\n\n    Args:\n        guess: Initial guess value for the variable to be maximized.\n\n    Returns:\n        tuple: (\"maximize\", guess) tuple suitable for use in State.initial, State.final,\n            or Time.initial, Time.final.\n\n    Example:\n        ```python\n        altitude = ox.State(\"altitude\", (1,))\n        altitude.final = [ox.Maximize(100.0)]  # Maximize final altitude\n\n        time = ox.Time(\n            initial=ox.Maximize(0.0),  # Maximize initial time\n            final=10.0,\n            min=0.0,\n            max=20.0\n        )\n        ```\n    \"\"\"\n    return (\"maximize\", guess)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Minimize","title":"<code>Minimize(guess)</code>","text":"<p>Create a minimize boundary condition tuple.</p> <p>This is a convenience function that returns a tuple (\"minimize\", guess) which can be used to specify that a boundary value should be minimized in the objective function for State or Time objects.</p> <p>Parameters:</p> Name Type Description Default <code>guess</code> <p>Initial guess value for the variable to be minimized.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(\"minimize\", guess) tuple suitable for use in State.initial, State.final, or Time.initial, Time.final.</p> Example <pre><code>time = ox.Time(\n    initial=0.0,\n    final=ox.Minimize(10.0),  # Minimize final time\n    min=0.0,\n    max=20.0\n)\n\nfuel = ox.State(\"fuel\", (1,))\nfuel.final = [ox.Minimize(0)]  # Minimize final fuel consumption\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def Minimize(guess):\n    \"\"\"Create a minimize boundary condition tuple.\n\n    This is a convenience function that returns a tuple (\"minimize\", guess) which\n    can be used to specify that a boundary value should be minimized in the objective\n    function for State or Time objects.\n\n    Args:\n        guess: Initial guess value for the variable to be minimized.\n\n    Returns:\n        tuple: (\"minimize\", guess) tuple suitable for use in State.initial, State.final,\n            or Time.initial, Time.final.\n\n    Example:\n        ```python\n        time = ox.Time(\n            initial=0.0,\n            final=ox.Minimize(10.0),  # Minimize final time\n            min=0.0,\n            max=20.0\n        )\n\n        fuel = ox.State(\"fuel\", (1,))\n        fuel.final = [ox.Minimize(0)]  # Minimize final fuel consumption\n        ```\n    \"\"\"\n    return (\"minimize\", guess)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.ctcs","title":"<code>ctcs(constraint: Constraint, penalty: str = 'squared_relu', nodes: Optional[Tuple[int, int]] = None, idx: Optional[int] = None, check_nodally: bool = False) -&gt; CTCS</code>","text":"<p>Helper function to create CTCS (Continuous-Time Constraint Satisfaction) constraints.</p> <p>This is a convenience function that creates a CTCS constraint with the same parameters as the CTCS constructor. Useful for functional-style constraint building.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>Constraint</code> <p>The Constraint to enforce continuously</p> required <code>penalty</code> <code>str</code> <p>Penalty function type ('squared_relu', 'huber', or 'smooth_relu'). Defaults to 'squared_relu'.</p> <code>'squared_relu'</code> <code>nodes</code> <code>Optional[Tuple[int, int]]</code> <p>Optional (start, end) tuple of node indices for enforcement interval. None enforces over entire trajectory.</p> <code>None</code> <code>idx</code> <code>Optional[int]</code> <p>Optional grouping index for multiple augmented states</p> <code>None</code> <code>check_nodally</code> <code>bool</code> <p>Whether to also enforce constraint at discrete nodes. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>CTCS</code> <code>CTCS</code> <p>A CTCS constraint wrapping the input constraint</p> Example <p>Using the helper function:</p> <pre><code>from openscvx.symbolic.expr.constraint import ctcs\naltitude_constraint = ctcs(\n    altitude &gt;= 10,\n    penalty=\"huber\",\n    nodes=(0, 100),\n    check_nodally=True\n)\n</code></pre> <p>Equivalent to using CTCS constructor:</p> <pre><code>altitude_constraint = CTCS(altitude &gt;= 10, penalty=\"huber\", nodes=(0, 100))\n</code></pre> <p>Also equivalent to using .over() method on constraint:</p> <pre><code>altitude_constraint = (altitude &gt;= 10).over((0, 100), penalty=\"huber\")\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def ctcs(\n    constraint: Constraint,\n    penalty: str = \"squared_relu\",\n    nodes: Optional[Tuple[int, int]] = None,\n    idx: Optional[int] = None,\n    check_nodally: bool = False,\n) -&gt; CTCS:\n    \"\"\"Helper function to create CTCS (Continuous-Time Constraint Satisfaction) constraints.\n\n    This is a convenience function that creates a CTCS constraint with the same\n    parameters as the CTCS constructor. Useful for functional-style constraint building.\n\n    Args:\n        constraint: The Constraint to enforce continuously\n        penalty: Penalty function type ('squared_relu', 'huber', or 'smooth_relu').\n            Defaults to 'squared_relu'.\n        nodes: Optional (start, end) tuple of node indices for enforcement interval.\n            None enforces over entire trajectory.\n        idx: Optional grouping index for multiple augmented states\n        check_nodally: Whether to also enforce constraint at discrete nodes.\n            Defaults to False.\n\n    Returns:\n        CTCS: A CTCS constraint wrapping the input constraint\n\n    Example:\n        Using the helper function:\n\n            from openscvx.symbolic.expr.constraint import ctcs\n            altitude_constraint = ctcs(\n                altitude &gt;= 10,\n                penalty=\"huber\",\n                nodes=(0, 100),\n                check_nodally=True\n            )\n\n        Equivalent to using CTCS constructor:\n\n            altitude_constraint = CTCS(altitude &gt;= 10, penalty=\"huber\", nodes=(0, 100))\n\n        Also equivalent to using .over() method on constraint:\n\n            altitude_constraint = (altitude &gt;= 10).over((0, 100), penalty=\"huber\")\n    \"\"\"\n    return CTCS(constraint, penalty, nodes, idx, check_nodally)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.to_expr","title":"<code>to_expr(x: Union[Expr, float, int, np.ndarray]) -&gt; Expr</code>","text":"<p>Convert a value to an Expr if it is not already one.</p> <p>This is a convenience function that wraps numeric values and arrays as Constant expressions, while leaving Expr instances unchanged. Used internally by operators to ensure operands are proper Expr objects.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[Expr, float, int, ndarray]</code> <p>Value to convert - can be an Expr, numeric scalar, or numpy array</p> required <p>Returns:</p> Type Description <code>Expr</code> <p>The input if it's already an Expr, otherwise a Constant wrapping the value</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def to_expr(x: Union[Expr, float, int, np.ndarray]) -&gt; Expr:\n    \"\"\"Convert a value to an Expr if it is not already one.\n\n    This is a convenience function that wraps numeric values and arrays as Constant\n    expressions, while leaving Expr instances unchanged. Used internally by operators\n    to ensure operands are proper Expr objects.\n\n    Args:\n        x: Value to convert - can be an Expr, numeric scalar, or numpy array\n\n    Returns:\n        The input if it's already an Expr, otherwise a Constant wrapping the value\n    \"\"\"\n    return x if isinstance(x, Expr) else Constant(np.array(x))\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.traverse","title":"<code>traverse(expr: Expr, visit: Callable[[Expr], None])</code>","text":"<p>Depth-first traversal of an expression tree.</p> <p>Visits each node in the expression tree by applying the visit function to the current node, then recursively visiting all children.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Root expression node to start traversal from</p> required <code>visit</code> <code>Callable[[Expr], None]</code> <p>Callback function applied to each node during traversal</p> required Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def traverse(expr: Expr, visit: Callable[[Expr], None]):\n    \"\"\"Depth-first traversal of an expression tree.\n\n    Visits each node in the expression tree by applying the visit function to the\n    current node, then recursively visiting all children.\n\n    Args:\n        expr: Root expression node to start traversal from\n        visit: Callback function applied to each node during traversal\n    \"\"\"\n    visit(expr)\n    for child in expr.children():\n        traverse(child, visit)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/","title":"arithmetic","text":"<p>Arithmetic operations for symbolic expressions.</p> <p>This module provides fundamental arithmetic operations that form the building blocks of symbolic expressions in openscvx. These operations are created automatically through operator overloading on Expr objects.</p> <p>Arithmetic Operations:</p> <ul> <li>Binary operations: <code>Add</code>, <code>Sub</code>, <code>Mul</code>, <code>Div</code>, <code>MatMul</code>, <code>Power</code> - Standard arithmetic</li> <li>Unary operations: <code>Neg</code> - Negation (unary minus)</li> </ul> <p>All arithmetic operations support: - Automatic canonicalization (constant folding, identity elimination, flattening) - Broadcasting following NumPy rules (except MatMul which follows linear algebra rules) - Shape checking and validation</p> Example <p>Arithmetic operations are created via operator overloading::</p> <pre><code>import openscvx as ox\n\nx = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(3,))\n\n# Element-wise operations\nz = x + y           # Creates Add(x, y)\nw = x * 2           # Creates Mul(x, Constant(2))\nneg_x = -x          # Creates Neg(x)\n\n# Matrix multiplication\nA = ox.State(\"A\", shape=(3, 3))\nb = A @ x           # Creates MatMul(A, x)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Add","title":"<code>Add</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Addition operation for symbolic expressions.</p> <p>Represents element-wise addition of two or more expressions. Supports broadcasting following NumPy rules. Can be created using the + operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>terms</code> <p>List of expression operands to add together</p> Example <p>Define an Add expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(3,))\nz = x + y + 5  # Creates Add(x, y, Constant(5))\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Add(Expr):\n    \"\"\"Addition operation for symbolic expressions.\n\n    Represents element-wise addition of two or more expressions. Supports broadcasting\n    following NumPy rules. Can be created using the + operator on Expr objects.\n\n    Attributes:\n        terms: List of expression operands to add together\n\n    Example:\n        Define an Add expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(3,))\n            z = x + y + 5  # Creates Add(x, y, Constant(5))\n    \"\"\"\n\n    def __init__(self, *args):\n        \"\"\"Initialize an addition operation.\n\n        Args:\n            *args: Two or more expressions to add together\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(args) &lt; 2:\n            raise ValueError(\"Add requires two or more operands\")\n        self.terms = [to_expr(a) for a in args]\n\n    def children(self):\n        return list(self.terms)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize addition: flatten, fold constants, and eliminate zeros.\n\n        Returns:\n            Expr: Canonical form of the addition expression\n        \"\"\"\n        terms = []\n        const_vals = []\n\n        for t in self.terms:\n            c = t.canonicalize()\n            if isinstance(c, Add):\n                terms.extend(c.terms)\n            elif isinstance(c, Constant):\n                const_vals.append(c.value)\n            else:\n                terms.append(c)\n\n        if const_vals:\n            total = sum(const_vals)\n            # If not all-zero, keep it\n            if not (isinstance(total, np.ndarray) and np.all(total == 0)):\n                terms.append(Constant(total))\n\n        if not terms:\n            return Constant(np.array(0))\n        if len(terms) == 1:\n            return terms[0]\n        return Add(*terms)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n        Returns:\n            tuple: The broadcasted shape of all operands\n\n        Raises:\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Add shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        inner = \" + \".join(repr(e) for e in self.terms)\n        return f\"({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Add.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize addition: flatten, fold constants, and eliminate zeros.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the addition expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize addition: flatten, fold constants, and eliminate zeros.\n\n    Returns:\n        Expr: Canonical form of the addition expression\n    \"\"\"\n    terms = []\n    const_vals = []\n\n    for t in self.terms:\n        c = t.canonicalize()\n        if isinstance(c, Add):\n            terms.extend(c.terms)\n        elif isinstance(c, Constant):\n            const_vals.append(c.value)\n        else:\n            terms.append(c)\n\n    if const_vals:\n        total = sum(const_vals)\n        # If not all-zero, keep it\n        if not (isinstance(total, np.ndarray) and np.all(total == 0)):\n            terms.append(Constant(total))\n\n    if not terms:\n        return Constant(np.array(0))\n    if len(terms) == 1:\n        return terms[0]\n    return Add(*terms)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Add.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check shape compatibility and compute broadcasted result shape like NumPy.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The broadcasted shape of all operands</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n    Returns:\n        tuple: The broadcasted shape of all operands\n\n    Raises:\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Add shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Div","title":"<code>Div</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise division operation for symbolic expressions.</p> <p>Represents element-wise division (left / right). Supports broadcasting following NumPy rules. Can be created using the / operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>left</code> <p>Numerator expression</p> <code>right</code> <p>Denominator expression</p> Example <p>Define a Div expression</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(3,))\nz = x / y  # Creates Div(x, y)\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Div(Expr):\n    \"\"\"Element-wise division operation for symbolic expressions.\n\n    Represents element-wise division (left / right). Supports broadcasting\n    following NumPy rules. Can be created using the / operator on Expr objects.\n\n    Attributes:\n        left: Numerator expression\n        right: Denominator expression\n\n    Example:\n        Define a Div expression\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(3,))\n            z = x / y  # Creates Div(x, y)\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\"Initialize a division operation.\n\n        Args:\n            left: Expression for the numerator\n            right: Expression for the denominator\n        \"\"\"\n        self.left = left\n        self.right = right\n\n    def children(self):\n        return [self.left, self.right]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize division: fold constants if both sides are constants.\n\n        Returns:\n            Expr: Canonical form of the division expression\n        \"\"\"\n        lhs = self.left.canonicalize()\n        rhs = self.right.canonicalize()\n        if isinstance(lhs, Constant) and isinstance(rhs, Constant):\n            return Constant(lhs.value / rhs.value)\n        return Div(lhs, rhs)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n        Returns:\n            tuple: The broadcasted shape of both operands\n\n        Raises:\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Div shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        return f\"({self.left!r} / {self.right!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Div.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize division: fold constants if both sides are constants.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the division expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize division: fold constants if both sides are constants.\n\n    Returns:\n        Expr: Canonical form of the division expression\n    \"\"\"\n    lhs = self.left.canonicalize()\n    rhs = self.right.canonicalize()\n    if isinstance(lhs, Constant) and isinstance(rhs, Constant):\n        return Constant(lhs.value / rhs.value)\n    return Div(lhs, rhs)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Div.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check shape compatibility and compute broadcasted result shape like NumPy.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The broadcasted shape of both operands</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n    Returns:\n        tuple: The broadcasted shape of both operands\n\n    Raises:\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Div shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.MatMul","title":"<code>MatMul</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Matrix multiplication operation for symbolic expressions.</p> <p>Represents matrix multiplication following standard linear algebra rules. Can be created using the @ operator on Expr objects. Handles: - Matrix @ Matrix: (m,n) @ (n,k) -&gt; (m,k) - Matrix @ Vector: (m,n) @ (n,) -&gt; (m,) - Vector @ Matrix: (m,) @ (m,n) -&gt; (n,) - Vector @ Vector: (m,) @ (m,) -&gt; scalar</p> <p>Attributes:</p> Name Type Description <code>left</code> <p>Left-hand side expression</p> <code>right</code> <p>Right-hand side expression</p> Example <p>Define a MatMul expression:</p> <pre><code>A = ox.State(\"A\", shape=(3, 4))\nx = ox.State(\"x\", shape=(4,))\ny = A @ x  # Creates MatMul(A, x), result shape (3,)\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class MatMul(Expr):\n    \"\"\"Matrix multiplication operation for symbolic expressions.\n\n    Represents matrix multiplication following standard linear algebra rules.\n    Can be created using the @ operator on Expr objects. Handles:\n    - Matrix @ Matrix: (m,n) @ (n,k) -&gt; (m,k)\n    - Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n    - Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n    - Vector @ Vector: (m,) @ (m,) -&gt; scalar\n\n    Attributes:\n        left: Left-hand side expression\n        right: Right-hand side expression\n\n    Example:\n        Define a MatMul expression:\n\n            A = ox.State(\"A\", shape=(3, 4))\n            x = ox.State(\"x\", shape=(4,))\n            y = A @ x  # Creates MatMul(A, x), result shape (3,)\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\"Initialize a matrix multiplication operation.\n\n        Args:\n            left: Left-hand side expression for matrix multiplication\n            right: Right-hand side expression for matrix multiplication\n        \"\"\"\n        self.left = left\n        self.right = right\n\n    def children(self):\n        return [self.left, self.right]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        left = self.left.canonicalize()\n        right = self.right.canonicalize()\n        return MatMul(left, right)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check matrix multiplication shape compatibility and return result shape.\"\"\"\n        L, R = self.left.check_shape(), self.right.check_shape()\n\n        # Handle different matmul cases:\n        # Matrix @ Matrix: (m,n) @ (n,k) -&gt; (m,k)\n        # Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n        # Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n        # Vector @ Vector: (m,) @ (m,) -&gt; ()\n\n        if len(L) == 0 or len(R) == 0:\n            raise ValueError(f\"MatMul requires at least 1D operands: {L} @ {R}\")\n\n        if len(L) == 1 and len(R) == 1:\n            # Vector @ Vector -&gt; scalar\n            if L[0] != R[0]:\n                raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n            return ()\n        elif len(L) == 1:\n            # Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n            if len(R) &lt; 2 or L[0] != R[-2]:\n                raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n            return R[-1:]\n        elif len(R) == 1:\n            # Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n            if len(L) &lt; 2 or L[-1] != R[0]:\n                raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n            return L[:-1]\n        else:\n            # Matrix @ Matrix: (...,m,n) @ (...,n,k) -&gt; (...,m,k)\n            if len(L) &lt; 2 or len(R) &lt; 2 or L[-1] != R[-2]:\n                raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n            return L[:-1] + (R[-1],)\n\n    def __repr__(self):\n        return f\"({self.left!r} * {self.right!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.MatMul.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check matrix multiplication shape compatibility and return result shape.</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check matrix multiplication shape compatibility and return result shape.\"\"\"\n    L, R = self.left.check_shape(), self.right.check_shape()\n\n    # Handle different matmul cases:\n    # Matrix @ Matrix: (m,n) @ (n,k) -&gt; (m,k)\n    # Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n    # Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n    # Vector @ Vector: (m,) @ (m,) -&gt; ()\n\n    if len(L) == 0 or len(R) == 0:\n        raise ValueError(f\"MatMul requires at least 1D operands: {L} @ {R}\")\n\n    if len(L) == 1 and len(R) == 1:\n        # Vector @ Vector -&gt; scalar\n        if L[0] != R[0]:\n            raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n        return ()\n    elif len(L) == 1:\n        # Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n        if len(R) &lt; 2 or L[0] != R[-2]:\n            raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n        return R[-1:]\n    elif len(R) == 1:\n        # Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n        if len(L) &lt; 2 or L[-1] != R[0]:\n            raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n        return L[:-1]\n    else:\n        # Matrix @ Matrix: (...,m,n) @ (...,n,k) -&gt; (...,m,k)\n        if len(L) &lt; 2 or len(R) &lt; 2 or L[-1] != R[-2]:\n            raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n        return L[:-1] + (R[-1],)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Mul","title":"<code>Mul</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise multiplication operation for symbolic expressions.</p> <p>Represents element-wise (Hadamard) multiplication of two or more expressions. Supports broadcasting following NumPy rules. Can be created using the * operator on Expr objects. For matrix multiplication, use MatMul or the @ operator.</p> <p>Attributes:</p> Name Type Description <code>factors</code> <p>List of expression operands to multiply together</p> Example <p>Define a Mul expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(3,))\nz = x * y * 2  # Creates Mul(x, y, Constant(2))\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Mul(Expr):\n    \"\"\"Element-wise multiplication operation for symbolic expressions.\n\n    Represents element-wise (Hadamard) multiplication of two or more expressions.\n    Supports broadcasting following NumPy rules. Can be created using the * operator\n    on Expr objects. For matrix multiplication, use MatMul or the @ operator.\n\n    Attributes:\n        factors: List of expression operands to multiply together\n\n    Example:\n        Define a Mul expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(3,))\n            z = x * y * 2  # Creates Mul(x, y, Constant(2))\n    \"\"\"\n\n    def __init__(self, *args):\n        \"\"\"Initialize an element-wise multiplication operation.\n\n        Args:\n            *args: Two or more expressions to multiply together\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(args) &lt; 2:\n            raise ValueError(\"Mul requires two or more operands\")\n        self.factors = [to_expr(a) for a in args]\n\n    def children(self):\n        return list(self.factors)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize multiplication: flatten, fold constants, and eliminating ones.\n\n        Returns:\n            Expr: Canonical form of the multiplication expression\n        \"\"\"\n        factors = []\n        const_vals = []\n\n        for f in self.factors:\n            c = f.canonicalize()\n            if isinstance(c, Mul):\n                factors.extend(c.factors)\n            elif isinstance(c, Constant):\n                const_vals.append(c.value)\n            else:\n                factors.append(c)\n\n        if const_vals:\n            # Multiply constants element-wise (broadcasting), not reducing with prod\n            prod = const_vals[0]\n            for val in const_vals[1:]:\n                prod = prod * val\n\n            # If prod != 1, keep it\n            # Check both scalar and array cases\n            is_identity = False\n            if isinstance(prod, np.ndarray):\n                is_identity = np.all(prod == 1)\n            else:\n                is_identity = prod == 1\n\n            if not is_identity:\n                factors.append(Constant(prod))\n\n        if not factors:\n            return Constant(np.array(1))\n        if len(factors) == 1:\n            return factors[0]\n        return Mul(*factors)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n\n        Returns:\n            tuple: The broadcasted shape of all operands\n\n        Raises:\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Mul shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        inner = \" * \".join(repr(e) for e in self.factors)\n        return f\"({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Mul.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize multiplication: flatten, fold constants, and eliminating ones.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the multiplication expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize multiplication: flatten, fold constants, and eliminating ones.\n\n    Returns:\n        Expr: Canonical form of the multiplication expression\n    \"\"\"\n    factors = []\n    const_vals = []\n\n    for f in self.factors:\n        c = f.canonicalize()\n        if isinstance(c, Mul):\n            factors.extend(c.factors)\n        elif isinstance(c, Constant):\n            const_vals.append(c.value)\n        else:\n            factors.append(c)\n\n    if const_vals:\n        # Multiply constants element-wise (broadcasting), not reducing with prod\n        prod = const_vals[0]\n        for val in const_vals[1:]:\n            prod = prod * val\n\n        # If prod != 1, keep it\n        # Check both scalar and array cases\n        is_identity = False\n        if isinstance(prod, np.ndarray):\n            is_identity = np.all(prod == 1)\n        else:\n            is_identity = prod == 1\n\n        if not is_identity:\n            factors.append(Constant(prod))\n\n    if not factors:\n        return Constant(np.array(1))\n    if len(factors) == 1:\n        return factors[0]\n    return Mul(*factors)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Mul.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check shape compatibility and compute broadcasted result shape like NumPy.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The broadcasted shape of all operands</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n\n    Returns:\n        tuple: The broadcasted shape of all operands\n\n    Raises:\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Mul shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Neg","title":"<code>Neg</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Negation operation for symbolic expressions.</p> <p>Represents element-wise negation (unary minus). Can be created using the unary - operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to negate</p> Example <p>Define a Neg expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = -x  # Creates Neg(x)\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Neg(Expr):\n    \"\"\"Negation operation for symbolic expressions.\n\n    Represents element-wise negation (unary minus). Can be created using the\n    unary - operator on Expr objects.\n\n    Attributes:\n        operand: Expression to negate\n\n    Example:\n        Define a Neg expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = -x  # Creates Neg(x)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a negation operation.\n\n        Args:\n            operand: Expression to negate\n        \"\"\"\n        self.operand = operand\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize negation: fold constant negations.\n\n        Returns:\n            Expr: Canonical form of the negation expression\n        \"\"\"\n        o = self.operand.canonicalize()\n        if isinstance(o, Constant):\n            return Constant(-o.value)\n        return Neg(o)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Negation preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"(-{self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Neg.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize negation: fold constant negations.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the negation expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize negation: fold constant negations.\n\n    Returns:\n        Expr: Canonical form of the negation expression\n    \"\"\"\n    o = self.operand.canonicalize()\n    if isinstance(o, Constant):\n        return Constant(-o.value)\n    return Neg(o)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Neg.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Negation preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Negation preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Power","title":"<code>Power</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise power operation for symbolic expressions.</p> <p>Represents element-wise exponentiation (base ** exponent). Supports broadcasting following NumPy rules. Can be created using the ** operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>base</code> <p>Base expression</p> <code>exponent</code> <p>Exponent expression</p> Example <p>Define a Power expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = x ** 2  # Creates Power(x, Constant(2))\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Power(Expr):\n    \"\"\"Element-wise power operation for symbolic expressions.\n\n    Represents element-wise exponentiation (base ** exponent). Supports broadcasting\n    following NumPy rules. Can be created using the ** operator on Expr objects.\n\n    Attributes:\n        base: Base expression\n        exponent: Exponent expression\n\n    Example:\n        Define a Power expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = x ** 2  # Creates Power(x, Constant(2))\n    \"\"\"\n\n    def __init__(self, base, exponent):\n        \"\"\"Initialize a power operation.\n\n        Args:\n            base: Base expression\n            exponent: Exponent expression\n        \"\"\"\n        self.base = to_expr(base)\n        self.exponent = to_expr(exponent)\n\n    def children(self):\n        return [self.base, self.exponent]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize power by canonicalizing base and exponent.\n\n        Returns:\n            Expr: Canonical form of the power expression\n        \"\"\"\n        base = self.base.canonicalize()\n        exponent = self.exponent.canonicalize()\n        return Power(base, exponent)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Power shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        return f\"({self.base!r})**({self.exponent!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Power.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize power by canonicalizing base and exponent.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the power expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize power by canonicalizing base and exponent.\n\n    Returns:\n        Expr: Canonical form of the power expression\n    \"\"\"\n    base = self.base.canonicalize()\n    exponent = self.exponent.canonicalize()\n    return Power(base, exponent)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Sub","title":"<code>Sub</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Subtraction operation for symbolic expressions.</p> <p>Represents element-wise subtraction (left - right). Supports broadcasting following NumPy rules. Can be created using the - operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>left</code> <p>Left-hand side expression (minuend)</p> <code>right</code> <p>Right-hand side expression (subtrahend)</p> Example <p>Define a Sub expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(3,))\nz = x - y  # Creates Sub(x, y)\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Sub(Expr):\n    \"\"\"Subtraction operation for symbolic expressions.\n\n    Represents element-wise subtraction (left - right). Supports broadcasting\n    following NumPy rules. Can be created using the - operator on Expr objects.\n\n    Attributes:\n        left: Left-hand side expression (minuend)\n        right: Right-hand side expression (subtrahend)\n\n    Example:\n        Define a Sub expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(3,))\n            z = x - y  # Creates Sub(x, y)\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\"Initialize a subtraction operation.\n\n        Args:\n            left: Expression to subtract from (minuend)\n            right: Expression to subtract (subtrahend)\n        \"\"\"\n        self.left = left\n        self.right = right\n\n    def children(self):\n        return [self.left, self.right]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize subtraction: fold constants if both sides are constants.\n\n        Returns:\n            Expr: Canonical form of the subtraction expression\n        \"\"\"\n        left = self.left.canonicalize()\n        right = self.right.canonicalize()\n        if isinstance(left, Constant) and isinstance(right, Constant):\n            return Constant(left.value - right.value)\n        return Sub(left, right)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n        Returns:\n            tuple: The broadcasted shape of all operands\n\n        Raises:\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Sub shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        return f\"({self.left!r} - {self.right!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Sub.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize subtraction: fold constants if both sides are constants.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the subtraction expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize subtraction: fold constants if both sides are constants.\n\n    Returns:\n        Expr: Canonical form of the subtraction expression\n    \"\"\"\n    left = self.left.canonicalize()\n    right = self.right.canonicalize()\n    if isinstance(left, Constant) and isinstance(right, Constant):\n        return Constant(left.value - right.value)\n    return Sub(left, right)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Sub.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check shape compatibility and compute broadcasted result shape like NumPy.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The broadcasted shape of all operands</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n    Returns:\n        tuple: The broadcasted shape of all operands\n\n    Raises:\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Sub shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/array/","title":"array","text":"<p>Array manipulation operations for symbolic expressions.</p> <p>This module provides operations for indexing, slicing, concatenating, and stacking symbolic expressions. These are structural operations that manipulate array shapes and combine or extract array elements, as opposed to mathematical transformations.</p> <p>Key Operations:</p> <ul> <li> <p>Indexing and Slicing:</p> <ul> <li><code>Index</code> - NumPy-style indexing and slicing to extract subarrays</li> </ul> </li> <li> <p>Concatenation:</p> <ul> <li><code>Concat</code> - Concatenate expressions along the first dimension (axis 0)</li> </ul> </li> <li> <p>Stacking:</p> <ul> <li><code>Stack</code> - Stack expressions along a new first dimension</li> <li><code>Hstack</code> - Horizontal stacking (along columns for 2D arrays)</li> <li><code>Vstack</code> - Vertical stacking (along rows for 2D arrays)</li> </ul> </li> </ul> <p>All operations follow NumPy conventions for shapes and indexing behavior, enabling familiar array manipulation patterns in symbolic optimization problems.</p> Example <p>Indexing and slicing arrays::</p> <pre><code>import openscvx as ox\n\nx = ox.State(\"x\", shape=(10,))\nfirst_half = x[0:5]      # Slice: Index(x, slice(0, 5))\nelement = x[3]           # Single element: Index(x, 3)\n\nA = ox.State(\"A\", shape=(5, 4))\nrow = A[2, :]            # Extract row\ncol = A[:, 1]            # Extract column\n</code></pre> <p>Concatenating expressions::</p> <pre><code>from openscvx.symbolic.expr.array import Concat\n\nx = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(4,))\ncombined = Concat(x, y)  # Result shape (7,)\n</code></pre> <p>Stacking to build matrices::</p> <pre><code>from openscvx.symbolic.expr.array import Stack, Hstack, Vstack\n\n# Stack vectors into a matrix\nv1 = ox.State(\"v1\", shape=(3,))\nv2 = ox.State(\"v2\", shape=(3,))\nv3 = ox.State(\"v3\", shape=(3,))\nmatrix = Stack([v1, v2, v3])  # Result shape (3, 3)\n\n# Horizontal stacking (concatenate along columns)\nA = ox.State(\"A\", shape=(3, 4))\nB = ox.State(\"B\", shape=(3, 2))\nwide = Hstack([A, B])    # Result shape (3, 6)\n\n# Vertical stacking (concatenate along rows)\nC = ox.State(\"C\", shape=(2, 4))\ntall = Vstack([A, C])    # Result shape (5, 4)\n</code></pre> <p>Building rotation matrices with stacking::</p> <pre><code>import openscvx as ox\nfrom openscvx.symbolic.expr.array import Stack, Hstack\n\ntheta = ox.Variable(\"theta\", shape=(1,))\nR = Stack([\n    Hstack([ox.Cos(theta), -ox.Sin(theta)]),\n    Hstack([ox.Sin(theta), ox.Cos(theta)])\n])  # 2D rotation matrix, shape (2, 2)\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Concat","title":"<code>Concat</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Concatenation operation for symbolic expressions.</p> <p>Concatenates a sequence of expressions along their first dimension. All inputs must have the same rank and matching dimensions except for the first dimension.</p> <p>Attributes:</p> Name Type Description <code>exprs</code> <p>Tuple of expressions to concatenate</p> Example <p>Define a Concat expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(4,))\nz = Concat(x, y)  # Creates Concat(x, y), result shape (7,)\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Concat(Expr):\n    \"\"\"Concatenation operation for symbolic expressions.\n\n    Concatenates a sequence of expressions along their first dimension. All inputs\n    must have the same rank and matching dimensions except for the first dimension.\n\n    Attributes:\n        exprs: Tuple of expressions to concatenate\n\n    Example:\n        Define a Concat expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(4,))\n            z = Concat(x, y)  # Creates Concat(x, y), result shape (7,)\n    \"\"\"\n\n    def __init__(self, *exprs: Expr):\n        \"\"\"Initialize a concatenation operation.\n\n        Args:\n            *exprs: Expressions to concatenate along the first dimension\n        \"\"\"\n        # wrap raw values as Constant if needed\n        self.exprs = [to_expr(e) for e in exprs]\n\n    def children(self):\n        return list(self.exprs)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize concatenation by canonicalizing all operands.\n\n        Returns:\n            Expr: Canonical form of the concatenation expression\n        \"\"\"\n        exprs = [e.canonicalize() for e in self.exprs]\n        return Concat(*exprs)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check concatenation shape compatibility and return result shape.\"\"\"\n        shapes = [e.check_shape() for e in self.exprs]\n        shapes = [(1,) if len(s) == 0 else s for s in shapes]\n        rank = len(shapes[0])\n        if any(len(s) != rank for s in shapes):\n            raise ValueError(f\"Concat rank mismatch: {shapes}\")\n        if any(s[1:] != shapes[0][1:] for s in shapes[1:]):\n            raise ValueError(f\"Concat non-0 dims differ: {shapes}\")\n        return (sum(s[0] for s in shapes),) + shapes[0][1:]\n\n    def __repr__(self):\n        inner = \", \".join(repr(e) for e in self.exprs)\n        return f\"Concat({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Concat.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize concatenation by canonicalizing all operands.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the concatenation expression</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize concatenation by canonicalizing all operands.\n\n    Returns:\n        Expr: Canonical form of the concatenation expression\n    \"\"\"\n    exprs = [e.canonicalize() for e in self.exprs]\n    return Concat(*exprs)\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Concat.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check concatenation shape compatibility and return result shape.</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check concatenation shape compatibility and return result shape.\"\"\"\n    shapes = [e.check_shape() for e in self.exprs]\n    shapes = [(1,) if len(s) == 0 else s for s in shapes]\n    rank = len(shapes[0])\n    if any(len(s) != rank for s in shapes):\n        raise ValueError(f\"Concat rank mismatch: {shapes}\")\n    if any(s[1:] != shapes[0][1:] for s in shapes[1:]):\n        raise ValueError(f\"Concat non-0 dims differ: {shapes}\")\n    return (sum(s[0] for s in shapes),) + shapes[0][1:]\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Hstack","title":"<code>Hstack</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Horizontal stacking operation for symbolic expressions.</p> <p>Concatenates expressions horizontally (along columns for 2D arrays). This is analogous to numpy.hstack() or jax.numpy.hstack().</p> <p>Behavior depends on input dimensionality: - 1D arrays: Concatenates along axis 0 (making a longer vector) - 2D arrays: Concatenates along axis 1 (columns), rows must match - Higher-D: Concatenates along axis 1, all other dimensions must match</p> <p>Attributes:</p> Name Type Description <code>arrays</code> <p>List of expressions to stack horizontally</p> Example <p>1D case: concatenate vectors:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(2,))\nh = Hstack([x, y])  # Result shape (5,)\n</code></pre> <p>2D case: concatenate matrices horizontally:</p> <pre><code>A = Variable(\"A\", shape=(3, 4))\nB = Variable(\"B\", shape=(3, 2))\nC = Hstack([A, B])  # Result shape (3, 6)\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Hstack(Expr):\n    \"\"\"Horizontal stacking operation for symbolic expressions.\n\n    Concatenates expressions horizontally (along columns for 2D arrays).\n    This is analogous to numpy.hstack() or jax.numpy.hstack().\n\n    Behavior depends on input dimensionality:\n    - 1D arrays: Concatenates along axis 0 (making a longer vector)\n    - 2D arrays: Concatenates along axis 1 (columns), rows must match\n    - Higher-D: Concatenates along axis 1, all other dimensions must match\n\n    Attributes:\n        arrays: List of expressions to stack horizontally\n\n    Example:\n        1D case: concatenate vectors:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(2,))\n            h = Hstack([x, y])  # Result shape (5,)\n\n        2D case: concatenate matrices horizontally:\n\n            A = Variable(\"A\", shape=(3, 4))\n            B = Variable(\"B\", shape=(3, 2))\n            C = Hstack([A, B])  # Result shape (3, 6)\n    \"\"\"\n\n    def __init__(self, arrays):\n        \"\"\"Initialize a horizontal stack operation.\n\n        Args:\n            arrays: List of expressions to concatenate horizontally\n        \"\"\"\n        self.arrays = [to_expr(arr) for arr in arrays]\n\n    def children(self):\n        return self.arrays\n\n    def canonicalize(self) -&gt; \"Expr\":\n        arrays = [arr.canonicalize() for arr in self.arrays]\n        return Hstack(arrays)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Horizontal stack concatenates arrays along the second axis (columns).\"\"\"\n        if not self.arrays:\n            raise ValueError(\"Hstack requires at least one array\")\n\n        array_shapes = [arr.check_shape() for arr in self.arrays]\n\n        # All arrays must have the same number of dimensions\n        first_ndim = len(array_shapes[0])\n        for i, shape in enumerate(array_shapes[1:], 1):\n            if len(shape) != first_ndim:\n                raise ValueError(\n                    f\"Hstack array {i} has {len(shape)} dimensions, but array 0 has {first_ndim}\"\n                )\n\n        # For 1D arrays, hstack concatenates along axis 0\n        if first_ndim == 1:\n            total_length = sum(shape[0] for shape in array_shapes)\n            return (total_length,)\n\n        # For 2D+ arrays, all dimensions except the second must match\n        first_shape = array_shapes[0]\n        for i, shape in enumerate(array_shapes[1:], 1):\n            if shape[0] != first_shape[0]:\n                raise ValueError(\n                    f\"Hstack array {i} has {shape[0]} rows, but array 0 has {first_shape[0]} rows\"\n                )\n            if shape[2:] != first_shape[2:]:\n                raise ValueError(\n                    f\"Hstack array {i} has trailing dimensions {shape[2:]}, \"\n                    f\"but array 0 has {first_shape[2:]}\"\n                )\n\n        # Result shape: concatenate along axis 1 (columns)\n        total_cols = sum(shape[1] for shape in array_shapes)\n        return (first_shape[0], total_cols) + first_shape[2:]\n\n    def __repr__(self):\n        arrays_repr = \", \".join(repr(arr) for arr in self.arrays)\n        return f\"Hstack([{arrays_repr}])\"\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Hstack.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Horizontal stack concatenates arrays along the second axis (columns).</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Horizontal stack concatenates arrays along the second axis (columns).\"\"\"\n    if not self.arrays:\n        raise ValueError(\"Hstack requires at least one array\")\n\n    array_shapes = [arr.check_shape() for arr in self.arrays]\n\n    # All arrays must have the same number of dimensions\n    first_ndim = len(array_shapes[0])\n    for i, shape in enumerate(array_shapes[1:], 1):\n        if len(shape) != first_ndim:\n            raise ValueError(\n                f\"Hstack array {i} has {len(shape)} dimensions, but array 0 has {first_ndim}\"\n            )\n\n    # For 1D arrays, hstack concatenates along axis 0\n    if first_ndim == 1:\n        total_length = sum(shape[0] for shape in array_shapes)\n        return (total_length,)\n\n    # For 2D+ arrays, all dimensions except the second must match\n    first_shape = array_shapes[0]\n    for i, shape in enumerate(array_shapes[1:], 1):\n        if shape[0] != first_shape[0]:\n            raise ValueError(\n                f\"Hstack array {i} has {shape[0]} rows, but array 0 has {first_shape[0]} rows\"\n            )\n        if shape[2:] != first_shape[2:]:\n            raise ValueError(\n                f\"Hstack array {i} has trailing dimensions {shape[2:]}, \"\n                f\"but array 0 has {first_shape[2:]}\"\n            )\n\n    # Result shape: concatenate along axis 1 (columns)\n    total_cols = sum(shape[1] for shape in array_shapes)\n    return (first_shape[0], total_cols) + first_shape[2:]\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Index","title":"<code>Index</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Indexing and slicing operation for symbolic expressions.</p> <p>Represents indexing or slicing of an expression using NumPy-style indexing. Can be created using square bracket notation on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>base</code> <p>Expression to index into</p> <code>index</code> <p>Index specification (int, slice, or tuple of indices/slices)</p> Example <p>Define an Index expression:</p> <pre><code>x = ox.State(\"x\", shape=(10,))\ny = x[0:5]  # Creates Index(x, slice(0, 5))\nz = x[3]    # Creates Index(x, 3)\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Index(Expr):\n    \"\"\"Indexing and slicing operation for symbolic expressions.\n\n    Represents indexing or slicing of an expression using NumPy-style indexing.\n    Can be created using square bracket notation on Expr objects.\n\n    Attributes:\n        base: Expression to index into\n        index: Index specification (int, slice, or tuple of indices/slices)\n\n    Example:\n        Define an Index expression:\n\n            x = ox.State(\"x\", shape=(10,))\n            y = x[0:5]  # Creates Index(x, slice(0, 5))\n            z = x[3]    # Creates Index(x, 3)\n    \"\"\"\n\n    def __init__(self, base: Expr, index: Union[int, slice, tuple]):\n        \"\"\"Initialize an indexing operation.\n\n        Args:\n            base: Expression to index into\n            index: NumPy-style index (int, slice, or tuple of indices/slices)\n        \"\"\"\n        self.base = base\n        self.index = index\n\n    def children(self):\n        return [self.base]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize index by canonicalizing the base expression.\n\n        Returns:\n            Expr: Canonical form of the indexing expression\n        \"\"\"\n        base = self.base.canonicalize()\n        return Index(base, self.index)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Compute the shape after indexing.\"\"\"\n        base_shape = self.base.check_shape()\n        dummy = np.zeros(base_shape)\n        try:\n            result = dummy[self.index]\n        except Exception as e:\n            raise ValueError(f\"Bad index {self.index} for shape {base_shape}\") from e\n        return result.shape\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Index including its index specification.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Index\")\n        # Hash the index specification (convert to string for generality)\n        hasher.update(repr(self.index).encode())\n        # Hash the base expression\n        self.base._hash_into(hasher)\n\n    def __repr__(self):\n        return f\"{self.base!r}[{self.index!r}]\"\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Index._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash Index including its index specification.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash Index including its index specification.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(b\"Index\")\n    # Hash the index specification (convert to string for generality)\n    hasher.update(repr(self.index).encode())\n    # Hash the base expression\n    self.base._hash_into(hasher)\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Index.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize index by canonicalizing the base expression.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the indexing expression</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize index by canonicalizing the base expression.\n\n    Returns:\n        Expr: Canonical form of the indexing expression\n    \"\"\"\n    base = self.base.canonicalize()\n    return Index(base, self.index)\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Index.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Compute the shape after indexing.</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Compute the shape after indexing.\"\"\"\n    base_shape = self.base.check_shape()\n    dummy = np.zeros(base_shape)\n    try:\n        result = dummy[self.index]\n    except Exception as e:\n        raise ValueError(f\"Bad index {self.index} for shape {base_shape}\") from e\n    return result.shape\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Stack","title":"<code>Stack</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Stack expressions vertically to create a higher-dimensional array.</p> <p>Stacks a list of expressions along a new first dimension. All input expressions must have the same shape. The result has shape (num_rows, *row_shape).</p> <p>This is similar to numpy.array([row1, row2, ...]) or jax.numpy.stack(rows, axis=0).</p> <p>Attributes:</p> Name Type Description <code>rows</code> <p>List of expressions to stack, each representing a \"row\"</p> Example <p>Leverage stack to combine expressions:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(3,))\nz = Variable(\"z\", shape=(3,))\nstacked = Stack([x, y, z])  # Creates shape (3, 3)\n# Equivalent to: [[x[0], x[1], x[2]],\n#                 [y[0], y[1], y[2]],\n#                 [z[0], z[1], z[2]]]\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Stack(Expr):\n    \"\"\"Stack expressions vertically to create a higher-dimensional array.\n\n    Stacks a list of expressions along a new first dimension. All input expressions\n    must have the same shape. The result has shape (num_rows, *row_shape).\n\n    This is similar to numpy.array([row1, row2, ...]) or jax.numpy.stack(rows, axis=0).\n\n    Attributes:\n        rows: List of expressions to stack, each representing a \"row\"\n\n    Example:\n        Leverage stack to combine expressions:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(3,))\n            z = Variable(\"z\", shape=(3,))\n            stacked = Stack([x, y, z])  # Creates shape (3, 3)\n            # Equivalent to: [[x[0], x[1], x[2]],\n            #                 [y[0], y[1], y[2]],\n            #                 [z[0], z[1], z[2]]]\n    \"\"\"\n\n    def __init__(self, rows):\n        \"\"\"Initialize a stack operation.\n\n        Args:\n            rows: List of expressions to stack along a new first dimension.\n                  All expressions must have the same shape.\n        \"\"\"\n        # rows should be a list of expressions representing each row\n        self.rows = [to_expr(row) for row in rows]\n\n    def children(self):\n        return self.rows\n\n    def canonicalize(self) -&gt; \"Expr\":\n        rows = [row.canonicalize() for row in self.rows]\n        return Stack(rows)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Stack creates a 2D matrix from 1D rows.\"\"\"\n        if not self.rows:\n            raise ValueError(\"Stack requires at least one row\")\n\n        # All rows should have the same shape\n        row_shapes = [row.check_shape() for row in self.rows]\n\n        # Verify all rows have the same shape\n        first_shape = row_shapes[0]\n        for i, shape in enumerate(row_shapes[1:], 1):\n            if shape != first_shape:\n                raise ValueError(\n                    f\"Stack row {i} has shape {shape}, but row 0 has shape {first_shape}\"\n                )\n\n        # Result shape is (num_rows, *row_shape)\n        return (len(self.rows),) + first_shape\n\n    def __repr__(self):\n        rows_repr = \", \".join(repr(row) for row in self.rows)\n        return f\"Stack([{rows_repr}])\"\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Stack.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Stack creates a 2D matrix from 1D rows.</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Stack creates a 2D matrix from 1D rows.\"\"\"\n    if not self.rows:\n        raise ValueError(\"Stack requires at least one row\")\n\n    # All rows should have the same shape\n    row_shapes = [row.check_shape() for row in self.rows]\n\n    # Verify all rows have the same shape\n    first_shape = row_shapes[0]\n    for i, shape in enumerate(row_shapes[1:], 1):\n        if shape != first_shape:\n            raise ValueError(\n                f\"Stack row {i} has shape {shape}, but row 0 has shape {first_shape}\"\n            )\n\n    # Result shape is (num_rows, *row_shape)\n    return (len(self.rows),) + first_shape\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Vstack","title":"<code>Vstack</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Vertical stacking operation for symbolic expressions.</p> <p>Concatenates expressions vertically (along rows for 2D arrays). This is analogous to numpy.vstack() or jax.numpy.vstack().</p> <p>All input expressions must have the same number of dimensions, and all dimensions except the first must match. The result concatenates along axis 0 (rows).</p> <p>Attributes:</p> Name Type Description <code>arrays</code> <p>List of expressions to stack vertically</p> Example <p>Stack vectors to create a matrix:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(3,))\nv = Vstack([x, y])  # Result shape (2, 3)\n</code></pre> <p>Stack matrices vertically:</p> <pre><code>A = Variable(\"A\", shape=(3, 4))\nB = Variable(\"B\", shape=(2, 4))\nC = Vstack([A, B])  # Result shape (5, 4)\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Vstack(Expr):\n    \"\"\"Vertical stacking operation for symbolic expressions.\n\n    Concatenates expressions vertically (along rows for 2D arrays).\n    This is analogous to numpy.vstack() or jax.numpy.vstack().\n\n    All input expressions must have the same number of dimensions, and all\n    dimensions except the first must match. The result concatenates along\n    axis 0 (rows).\n\n    Attributes:\n        arrays: List of expressions to stack vertically\n\n    Example:\n        Stack vectors to create a matrix:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(3,))\n            v = Vstack([x, y])  # Result shape (2, 3)\n\n        Stack matrices vertically:\n\n            A = Variable(\"A\", shape=(3, 4))\n            B = Variable(\"B\", shape=(2, 4))\n            C = Vstack([A, B])  # Result shape (5, 4)\n    \"\"\"\n\n    def __init__(self, arrays):\n        \"\"\"Initialize a vertical stack operation.\n\n        Args:\n            arrays: List of expressions to concatenate vertically.\n                    All must have matching dimensions except the first.\n        \"\"\"\n        self.arrays = [to_expr(arr) for arr in arrays]\n\n    def children(self):\n        return self.arrays\n\n    def canonicalize(self) -&gt; \"Expr\":\n        arrays = [arr.canonicalize() for arr in self.arrays]\n        return Vstack(arrays)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Vertical stack concatenates arrays along the first axis (rows).\"\"\"\n        if not self.arrays:\n            raise ValueError(\"Vstack requires at least one array\")\n\n        array_shapes = [arr.check_shape() for arr in self.arrays]\n\n        # All arrays must have the same number of dimensions\n        first_ndim = len(array_shapes[0])\n        for i, shape in enumerate(array_shapes[1:], 1):\n            if len(shape) != first_ndim:\n                raise ValueError(\n                    f\"Vstack array {i} has {len(shape)} dimensions, but array 0 has {first_ndim}\"\n                )\n\n        # All dimensions except the first must match\n        first_shape = array_shapes[0]\n        for i, shape in enumerate(array_shapes[1:], 1):\n            if shape[1:] != first_shape[1:]:\n                raise ValueError(\n                    f\"Vstack array {i} has trailing dimensions {shape[1:]}, \"\n                    f\"but array 0 has {first_shape[1:]}\"\n                )\n\n        # Result shape: concatenate along axis 0 (rows)\n        total_rows = sum(shape[0] for shape in array_shapes)\n        return (total_rows,) + first_shape[1:]\n\n    def __repr__(self):\n        arrays_repr = \", \".join(repr(arr) for arr in self.arrays)\n        return f\"Vstack([{arrays_repr}])\"\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Vstack.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Vertical stack concatenates arrays along the first axis (rows).</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Vertical stack concatenates arrays along the first axis (rows).\"\"\"\n    if not self.arrays:\n        raise ValueError(\"Vstack requires at least one array\")\n\n    array_shapes = [arr.check_shape() for arr in self.arrays]\n\n    # All arrays must have the same number of dimensions\n    first_ndim = len(array_shapes[0])\n    for i, shape in enumerate(array_shapes[1:], 1):\n        if len(shape) != first_ndim:\n            raise ValueError(\n                f\"Vstack array {i} has {len(shape)} dimensions, but array 0 has {first_ndim}\"\n            )\n\n    # All dimensions except the first must match\n    first_shape = array_shapes[0]\n    for i, shape in enumerate(array_shapes[1:], 1):\n        if shape[1:] != first_shape[1:]:\n            raise ValueError(\n                f\"Vstack array {i} has trailing dimensions {shape[1:]}, \"\n                f\"but array 0 has {first_shape[1:]}\"\n            )\n\n    # Result shape: concatenate along axis 0 (rows)\n    total_rows = sum(shape[0] for shape in array_shapes)\n    return (total_rows,) + first_shape[1:]\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/","title":"constraint","text":"<p>Specialized constraint types for trajectory optimization.</p> <p>This module provides advanced constraint specification mechanisms that extend the basic Equality and Inequality constraints. These specialized constraint types enable precise control over when and how constraints are enforced in discretized trajectory optimization problems.</p> Key constraint types <ul> <li>NodalConstraint: Enforces constraints only at specific discrete time points (nodes) along the trajectory. Useful for waypoint constraints, boundary conditions, and reducing computational cost by selective enforcement.</li> <li>CTCS (Continuous-Time Constraint Satisfaction): Guarantees strict constraint satisfaction throughout the entire continuous trajectory, not just at discrete nodes. Works by augmenting the state vector with additional states whose dynamics integrate constraint violation penalties. Essential for safety-critical applications where inter-node violations could be catastrophic.</li> </ul> Example <p>Nodal constraints for waypoints::</p> <pre><code>import openscvx as ox\n\nx = ox.State(\"x\", shape=(3,))\ntarget = [10, 5, 0]\n\n# Enforce position constraint only at specific nodes\nwaypoint_constraint = (x == target).at([0, 10, 20])\n</code></pre> <p>Continuous-time constraint for obstacle avoidance::</p> <pre><code>obstacle_center = ox.Parameter(\"obs\", shape=(2,), value=[5, 5])\nobstacle_radius = 2.0\n\n# Distance from obstacle must be &gt; radius for ALL time\ndistance = ox.Norm(x[:2] - obstacle_center)\nsafety_constraint = (distance &gt;= obstacle_radius).over((0, 100))\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CTCS","title":"<code>CTCS</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Continuous-Time Constraint Satisfaction using augmented state dynamics.</p> <p>CTCS enables strict continuous-time constraint enforcement in discretized trajectory optimization by augmenting the state vector with additional states whose dynamics are the constraint violation penalties. By constraining these augmented states to remain at zero throughout the trajectory, the original constraints are guaranteed to be satisfied continuously, not just at discrete nodes.</p> <p>How it works:</p> <ol> <li>Each constraint (in canonical form: lhs &lt;= 0) is wrapped in a penalty function</li> <li>Augmented states s_aug_i are added with dynamics: ds_aug_i/dt = sum(penalty_j(lhs_j))    for all CTCS constraints j in group i</li> <li>Each augmented state is constrained: s_aug_i(t) = 0 for all t (strictly enforced)</li> <li>Since s_aug_i integrates the penalties, s_aug_i = 0 implies all penalties in the    group are zero, which means all constraints in the group are satisfied continuously</li> </ol> <p>Grouping and augmented states:</p> <ul> <li>CTCS constraints with the same node interval are grouped into a single augmented   state by default (their penalties are summed)</li> <li>CTCS constraints with different node intervals create separate augmented states</li> <li>Using the <code>idx</code> parameter explicitly assigns constraints to specific augmented states,   allowing manual control over grouping</li> <li>Each unique group creates one augmented state named <code>_ctcs_aug_0</code>, <code>_ctcs_aug_1</code>, etc.</li> </ul> <p>This is particularly useful for:</p> <ul> <li>Path constraints that must hold throughout the entire trajectory (not just at nodes)</li> <li>Obstacle avoidance where constraint violation between nodes could be catastrophic</li> <li>State limits that should be respected continuously (e.g., altitude &gt; 0 for aircraft)</li> <li>Ensuring smooth, feasible trajectories between discretization points</li> </ul> <p>Penalty functions (applied to constraint violations):</p> <ul> <li>squared_relu: Square(PositivePart(lhs)) - smooth, differentiable (default)</li> <li>huber: Huber(PositivePart(lhs)) - less sensitive to outliers than squared</li> <li>smooth_relu: SmoothReLU(lhs) - smooth approximation of ReLU</li> </ul> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (typically Inequality) to enforce continuously</p> <code>penalty</code> <p>Penalty function type ('squared_relu', 'huber', or 'smooth_relu')</p> <code>nodes</code> <p>Optional (start, end) tuple specifying the interval for enforcement, or None to enforce over the entire trajectory</p> <code>idx</code> <p>Optional grouping index for managing multiple augmented states. CTCS constraints with the same idx and nodes are grouped together, sharing an augmented state. If None, auto-assigned based on node intervals.</p> <code>check_nodally</code> <p>Whether to also enforce the constraint at discrete nodes for additional numerical robustness (creates both continuous and nodal constraints)</p> Example <p>Single augmented state (default behavior - same node interval):</p> <pre><code>altitude = State(\"alt\", shape=(1,))\nconstraints = [\n    (altitude &gt;= 10).over((0, 10)),  # Both constraints share\n    (altitude &lt;= 1000).over((0, 10))  # one augmented state\n]\n</code></pre> <p>Multiple augmented states (different node intervals):</p> <pre><code>constraints = [\n    (altitude &gt;= 10).over((0, 5)),  # Creates _ctcs_aug_0\n    (altitude &gt;= 20).over((5, 10))  # Creates _ctcs_aug_1\n]\n</code></pre> <p>Manual grouping with idx parameter:</p> <pre><code>constraints = [\n    (altitude &gt;= 10).over((0, 10), idx=0),    # Group 0\n    (velocity &lt;= 100).over((0, 10), idx=1),   # Group 1 (separate state)\n    (altitude &lt;= 1000).over((0, 10), idx=0)   # Also group 0\n]\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class CTCS(Expr):\n    \"\"\"Continuous-Time Constraint Satisfaction using augmented state dynamics.\n\n    CTCS enables strict continuous-time constraint enforcement in discretized trajectory\n    optimization by augmenting the state vector with additional states whose dynamics\n    are the constraint violation penalties. By constraining these augmented states to remain\n    at zero throughout the trajectory, the original constraints are guaranteed to be satisfied\n    continuously, not just at discrete nodes.\n\n    **How it works:**\n\n    1. Each constraint (in canonical form: lhs &lt;= 0) is wrapped in a penalty function\n    2. Augmented states s_aug_i are added with dynamics: ds_aug_i/dt = sum(penalty_j(lhs_j))\n       for all CTCS constraints j in group i\n    3. Each augmented state is constrained: s_aug_i(t) = 0 for all t (strictly enforced)\n    4. Since s_aug_i integrates the penalties, s_aug_i = 0 implies all penalties in the\n       group are zero, which means all constraints in the group are satisfied continuously\n\n    **Grouping and augmented states:**\n\n    - CTCS constraints with the **same node interval** are grouped into a single augmented\n      state by default (their penalties are summed)\n    - CTCS constraints with **different node intervals** create separate augmented states\n    - Using the `idx` parameter explicitly assigns constraints to specific augmented states,\n      allowing manual control over grouping\n    - Each unique group creates one augmented state named `_ctcs_aug_0`, `_ctcs_aug_1`, etc.\n\n    This is particularly useful for:\n\n    - Path constraints that must hold throughout the entire trajectory (not just at nodes)\n    - Obstacle avoidance where constraint violation between nodes could be catastrophic\n    - State limits that should be respected continuously (e.g., altitude &gt; 0 for aircraft)\n    - Ensuring smooth, feasible trajectories between discretization points\n\n    **Penalty functions** (applied to constraint violations):\n\n    - **squared_relu**: Square(PositivePart(lhs)) - smooth, differentiable (default)\n    - **huber**: Huber(PositivePart(lhs)) - less sensitive to outliers than squared\n    - **smooth_relu**: SmoothReLU(lhs) - smooth approximation of ReLU\n\n    Attributes:\n        constraint: The wrapped Constraint (typically Inequality) to enforce continuously\n        penalty: Penalty function type ('squared_relu', 'huber', or 'smooth_relu')\n        nodes: Optional (start, end) tuple specifying the interval for enforcement,\n            or None to enforce over the entire trajectory\n        idx: Optional grouping index for managing multiple augmented states.\n            CTCS constraints with the same idx and nodes are grouped together, sharing\n            an augmented state. If None, auto-assigned based on node intervals.\n        check_nodally: Whether to also enforce the constraint at discrete nodes for\n            additional numerical robustness (creates both continuous and nodal constraints)\n\n    Example:\n        Single augmented state (default behavior - same node interval):\n\n            altitude = State(\"alt\", shape=(1,))\n            constraints = [\n                (altitude &gt;= 10).over((0, 10)),  # Both constraints share\n                (altitude &lt;= 1000).over((0, 10))  # one augmented state\n            ]\n\n        Multiple augmented states (different node intervals):\n\n            constraints = [\n                (altitude &gt;= 10).over((0, 5)),  # Creates _ctcs_aug_0\n                (altitude &gt;= 20).over((5, 10))  # Creates _ctcs_aug_1\n            ]\n\n        Manual grouping with idx parameter:\n\n            constraints = [\n                (altitude &gt;= 10).over((0, 10), idx=0),    # Group 0\n                (velocity &lt;= 100).over((0, 10), idx=1),   # Group 1 (separate state)\n                (altitude &lt;= 1000).over((0, 10), idx=0)   # Also group 0\n            ]\n    \"\"\"\n\n    def __init__(\n        self,\n        constraint: Constraint,\n        penalty: str = \"squared_relu\",\n        nodes: Optional[Tuple[int, int]] = None,\n        idx: Optional[int] = None,\n        check_nodally: bool = False,\n    ):\n        \"\"\"Initialize a CTCS constraint.\n\n        Args:\n            constraint: The Constraint to enforce continuously (typically an Inequality)\n            penalty: Penalty function type. Options:\n                - 'squared_relu': Square(PositivePart(lhs)) - default, smooth, differentiable\n                - 'huber': Huber(PositivePart(lhs)) - robust to outliers\n                - 'smooth_relu': SmoothReLU(lhs) - smooth ReLU approximation\n            nodes: Optional (start, end) tuple of node indices defining the enforcement interval.\n                None means enforce over the entire trajectory. Must satisfy start &lt; end.\n                CTCS constraints with the same nodes are automatically grouped together.\n            idx: Optional grouping index for multiple augmented states. Allows organizing\n                multiple CTCS constraints with separate augmented state variables.\n                If None, constraints are auto-grouped by their node intervals.\n                Explicitly setting idx allows manual control over which constraints\n                share an augmented state.\n            check_nodally: If True, also enforce the constraint at discrete nodes for\n                numerical stability (creates both continuous and nodal constraints).\n                Defaults to False.\n\n        Raises:\n            TypeError: If constraint is not a Constraint instance\n            ValueError: If nodes is not None or a 2-tuple of integers\n            ValueError: If nodes[0] &gt;= nodes[1] (invalid interval)\n        \"\"\"\n        if not isinstance(constraint, Constraint):\n            raise TypeError(\"CTCS must wrap a Constraint\")\n\n        # Validate nodes parameter for CTCS\n        if nodes is not None:\n            if not isinstance(nodes, tuple) or len(nodes) != 2:\n                raise ValueError(\n                    \"CTCS constraints must specify nodes as a tuple of (start, end) or None \"\n                    \"for all nodes\"\n                )\n            if not all(isinstance(n, int) for n in nodes):\n                raise ValueError(\"CTCS node indices must be integers\")\n            if nodes[0] &gt;= nodes[1]:\n                raise ValueError(\"CTCS node range must have start &lt; end\")\n\n        self.constraint = constraint\n        self.penalty = penalty\n        self.nodes = nodes  # (start, end) node range or None for all nodes\n        self.idx = idx  # Optional grouping index for multiple augmented states\n        # Whether to also enforce this constraint nodally for numerical stability\n        self.check_nodally = check_nodally\n\n    def children(self):\n        \"\"\"Return the wrapped constraint as the only child.\n\n        Returns:\n            list: Single-element list containing the wrapped constraint\n        \"\"\"\n        return [self.constraint]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the inner constraint while preserving CTCS parameters.\n\n        Returns:\n            CTCS: A new CTCS with canonicalized inner constraint and same parameters\n        \"\"\"\n        canon_constraint = self.constraint.canonicalize()\n        return CTCS(\n            canon_constraint,\n            penalty=self.penalty,\n            nodes=self.nodes,\n            idx=self.idx,\n            check_nodally=self.check_nodally,\n        )\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Validate the constraint and penalty expression shapes.\n\n        CTCS transforms the wrapped constraint into a penalty expression that is\n        summed (integrated) over the trajectory, always producing a scalar result.\n\n        Returns:\n            tuple: Empty tuple () representing scalar shape\n\n        Raises:\n            ValueError: If the wrapped constraint has invalid shape\n            ValueError: If the generated penalty expression is not scalar\n        \"\"\"\n        # First validate the wrapped constraint's shape\n        self.constraint.check_shape()\n\n        # Also validate the penalty expression that would be generated\n        try:\n            penalty_expr = self.penalty_expr()\n            penalty_shape = penalty_expr.check_shape()\n\n            # The penalty expression should always be scalar due to Sum wrapper\n            if penalty_shape != ():\n                raise ValueError(\n                    f\"CTCS penalty expression should be scalar, but got shape {penalty_shape}\"\n                )\n        except Exception as e:\n            # Re-raise with more context about which CTCS node failed\n            raise ValueError(f\"CTCS penalty expression validation failed: {e}\") from e\n\n        # CTCS always produces a scalar due to the Sum in penalty_expr\n        return ()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash CTCS including all its parameters.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"CTCS\")\n        # Hash penalty type\n        hasher.update(self.penalty.encode())\n        # Hash nodes interval\n        if self.nodes is not None:\n            hasher.update(struct.pack(\"&gt;ii\", self.nodes[0], self.nodes[1]))\n        else:\n            hasher.update(b\"None\")\n        # Hash idx\n        if self.idx is not None:\n            hasher.update(struct.pack(\"&gt;i\", self.idx))\n        else:\n            hasher.update(b\"None\")\n        # Hash check_nodally\n        hasher.update(b\"1\" if self.check_nodally else b\"0\")\n        # Hash the wrapped constraint\n        self.constraint._hash_into(hasher)\n\n    def over(self, interval: tuple[int, int]) -&gt; \"CTCS\":\n        \"\"\"Set or update the continuous interval for this CTCS constraint.\n\n        Args:\n            interval: Tuple of (start, end) node indices defining the enforcement interval\n\n        Returns:\n            CTCS: New CTCS constraint with the specified interval\n\n        Example:\n            Define constraint over range:\n\n                constraint = (altitude &gt;= 10).over((0, 50))\n\n            Update interval to cover different range:\n\n                constraint_updated = constraint.over((50, 100))\n        \"\"\"\n        return CTCS(\n            self.constraint,\n            penalty=self.penalty,\n            nodes=interval,\n            idx=self.idx,\n            check_nodally=self.check_nodally,\n        )\n\n    def __repr__(self):\n        \"\"\"String representation of the CTCS constraint.\n\n        Returns:\n            str: String showing constraint, penalty type, and optional parameters\n        \"\"\"\n        parts = [f\"{self.constraint!r}\", f\"penalty={self.penalty!r}\"]\n        if self.nodes is not None:\n            parts.append(f\"nodes={self.nodes}\")\n        if self.idx is not None:\n            parts.append(f\"idx={self.idx}\")\n        if self.check_nodally:\n            parts.append(f\"check_nodally={self.check_nodally}\")\n        return f\"CTCS({', '.join(parts)})\"\n\n    def penalty_expr(self) -&gt; Expr:\n        \"\"\"Build the penalty expression for this CTCS constraint.\n\n        Transforms the constraint's left-hand side (in canonical form: lhs &lt;= 0)\n        into a penalty expression using the specified penalty function. The penalty\n        is zero when the constraint is satisfied and positive when violated.\n\n        This penalty expression becomes part of the dynamics of an augmented state.\n        Multiple CTCS constraints in the same group (same idx) have their penalties\n        summed: ds_aug_i/dt = sum(penalty_j) for all j in group i. By constraining\n        s_aug_i(t) = 0 for all t, we ensure all penalties in the group are zero,\n        which strictly enforces all constraints in the group continuously.\n\n        Returns:\n            Expr: Sum of the penalty function applied to the constraint violation\n\n        Raises:\n            ValueError: If an unknown penalty type is specified\n\n        Note:\n            This method is used internally during problem compilation to create\n            augmented state dynamics. Multiple penalty expressions with the same\n            idx are summed together before being added to the dynamics vector via Concat.\n        \"\"\"\n        lhs = self.constraint.lhs\n\n        if self.penalty == \"squared_relu\":\n            from openscvx.symbolic.expr.math import PositivePart, Square\n\n            penalty = Square(PositivePart(lhs))\n        elif self.penalty == \"huber\":\n            from openscvx.symbolic.expr.math import Huber, PositivePart\n\n            penalty = Huber(PositivePart(lhs))\n        elif self.penalty == \"smooth_relu\":\n            from openscvx.symbolic.expr.math import SmoothReLU\n\n            penalty = SmoothReLU(lhs)\n        else:\n            raise ValueError(f\"Unknown penalty {self.penalty!r}\")\n\n        return Sum(penalty)\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CTCS._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash CTCS including all its parameters.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash CTCS including all its parameters.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(b\"CTCS\")\n    # Hash penalty type\n    hasher.update(self.penalty.encode())\n    # Hash nodes interval\n    if self.nodes is not None:\n        hasher.update(struct.pack(\"&gt;ii\", self.nodes[0], self.nodes[1]))\n    else:\n        hasher.update(b\"None\")\n    # Hash idx\n    if self.idx is not None:\n        hasher.update(struct.pack(\"&gt;i\", self.idx))\n    else:\n        hasher.update(b\"None\")\n    # Hash check_nodally\n    hasher.update(b\"1\" if self.check_nodally else b\"0\")\n    # Hash the wrapped constraint\n    self.constraint._hash_into(hasher)\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CTCS.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the inner constraint while preserving CTCS parameters.</p> <p>Returns:</p> Name Type Description <code>CTCS</code> <code>Expr</code> <p>A new CTCS with canonicalized inner constraint and same parameters</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the inner constraint while preserving CTCS parameters.\n\n    Returns:\n        CTCS: A new CTCS with canonicalized inner constraint and same parameters\n    \"\"\"\n    canon_constraint = self.constraint.canonicalize()\n    return CTCS(\n        canon_constraint,\n        penalty=self.penalty,\n        nodes=self.nodes,\n        idx=self.idx,\n        check_nodally=self.check_nodally,\n    )\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CTCS.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the constraint and penalty expression shapes.</p> <p>CTCS transforms the wrapped constraint into a penalty expression that is summed (integrated) over the trajectory, always producing a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the wrapped constraint has invalid shape</p> <code>ValueError</code> <p>If the generated penalty expression is not scalar</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Validate the constraint and penalty expression shapes.\n\n    CTCS transforms the wrapped constraint into a penalty expression that is\n    summed (integrated) over the trajectory, always producing a scalar result.\n\n    Returns:\n        tuple: Empty tuple () representing scalar shape\n\n    Raises:\n        ValueError: If the wrapped constraint has invalid shape\n        ValueError: If the generated penalty expression is not scalar\n    \"\"\"\n    # First validate the wrapped constraint's shape\n    self.constraint.check_shape()\n\n    # Also validate the penalty expression that would be generated\n    try:\n        penalty_expr = self.penalty_expr()\n        penalty_shape = penalty_expr.check_shape()\n\n        # The penalty expression should always be scalar due to Sum wrapper\n        if penalty_shape != ():\n            raise ValueError(\n                f\"CTCS penalty expression should be scalar, but got shape {penalty_shape}\"\n            )\n    except Exception as e:\n        # Re-raise with more context about which CTCS node failed\n        raise ValueError(f\"CTCS penalty expression validation failed: {e}\") from e\n\n    # CTCS always produces a scalar due to the Sum in penalty_expr\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CTCS.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def children(self):\n    \"\"\"Return the wrapped constraint as the only child.\n\n    Returns:\n        list: Single-element list containing the wrapped constraint\n    \"\"\"\n    return [self.constraint]\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CTCS.over","title":"<code>over(interval: tuple[int, int]) -&gt; CTCS</code>","text":"<p>Set or update the continuous interval for this CTCS constraint.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>tuple[int, int]</code> <p>Tuple of (start, end) node indices defining the enforcement interval</p> required <p>Returns:</p> Name Type Description <code>CTCS</code> <code>CTCS</code> <p>New CTCS constraint with the specified interval</p> Example <p>Define constraint over range:</p> <pre><code>constraint = (altitude &gt;= 10).over((0, 50))\n</code></pre> <p>Update interval to cover different range:</p> <pre><code>constraint_updated = constraint.over((50, 100))\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def over(self, interval: tuple[int, int]) -&gt; \"CTCS\":\n    \"\"\"Set or update the continuous interval for this CTCS constraint.\n\n    Args:\n        interval: Tuple of (start, end) node indices defining the enforcement interval\n\n    Returns:\n        CTCS: New CTCS constraint with the specified interval\n\n    Example:\n        Define constraint over range:\n\n            constraint = (altitude &gt;= 10).over((0, 50))\n\n        Update interval to cover different range:\n\n            constraint_updated = constraint.over((50, 100))\n    \"\"\"\n    return CTCS(\n        self.constraint,\n        penalty=self.penalty,\n        nodes=interval,\n        idx=self.idx,\n        check_nodally=self.check_nodally,\n    )\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CTCS.penalty_expr","title":"<code>penalty_expr() -&gt; Expr</code>","text":"<p>Build the penalty expression for this CTCS constraint.</p> <p>Transforms the constraint's left-hand side (in canonical form: lhs &lt;= 0) into a penalty expression using the specified penalty function. The penalty is zero when the constraint is satisfied and positive when violated.</p> <p>This penalty expression becomes part of the dynamics of an augmented state. Multiple CTCS constraints in the same group (same idx) have their penalties summed: ds_aug_i/dt = sum(penalty_j) for all j in group i. By constraining s_aug_i(t) = 0 for all t, we ensure all penalties in the group are zero, which strictly enforces all constraints in the group continuously.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Sum of the penalty function applied to the constraint violation</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown penalty type is specified</p> Note <p>This method is used internally during problem compilation to create augmented state dynamics. Multiple penalty expressions with the same idx are summed together before being added to the dynamics vector via Concat.</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def penalty_expr(self) -&gt; Expr:\n    \"\"\"Build the penalty expression for this CTCS constraint.\n\n    Transforms the constraint's left-hand side (in canonical form: lhs &lt;= 0)\n    into a penalty expression using the specified penalty function. The penalty\n    is zero when the constraint is satisfied and positive when violated.\n\n    This penalty expression becomes part of the dynamics of an augmented state.\n    Multiple CTCS constraints in the same group (same idx) have their penalties\n    summed: ds_aug_i/dt = sum(penalty_j) for all j in group i. By constraining\n    s_aug_i(t) = 0 for all t, we ensure all penalties in the group are zero,\n    which strictly enforces all constraints in the group continuously.\n\n    Returns:\n        Expr: Sum of the penalty function applied to the constraint violation\n\n    Raises:\n        ValueError: If an unknown penalty type is specified\n\n    Note:\n        This method is used internally during problem compilation to create\n        augmented state dynamics. Multiple penalty expressions with the same\n        idx are summed together before being added to the dynamics vector via Concat.\n    \"\"\"\n    lhs = self.constraint.lhs\n\n    if self.penalty == \"squared_relu\":\n        from openscvx.symbolic.expr.math import PositivePart, Square\n\n        penalty = Square(PositivePart(lhs))\n    elif self.penalty == \"huber\":\n        from openscvx.symbolic.expr.math import Huber, PositivePart\n\n        penalty = Huber(PositivePart(lhs))\n    elif self.penalty == \"smooth_relu\":\n        from openscvx.symbolic.expr.math import SmoothReLU\n\n        penalty = SmoothReLU(lhs)\n    else:\n        raise ValueError(f\"Unknown penalty {self.penalty!r}\")\n\n    return Sum(penalty)\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.Constraint","title":"<code>Constraint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Abstract base class for optimization constraints.</p> <p>Constraints represent relationships between expressions that must be satisfied in the optimization problem. This base class provides common functionality for both equality and inequality constraints.</p> <p>Attributes:</p> Name Type Description <code>lhs</code> <p>Left-hand side expression</p> <code>rhs</code> <p>Right-hand side expression</p> <code>is_convex</code> <p>Flag indicating if the constraint is known to be convex</p> Note <p>Constraints are canonicalized to standard form: (lhs - rhs) {op} 0</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class Constraint(Expr):\n    \"\"\"Abstract base class for optimization constraints.\n\n    Constraints represent relationships between expressions that must be satisfied\n    in the optimization problem. This base class provides common functionality for\n    both equality and inequality constraints.\n\n    Attributes:\n        lhs: Left-hand side expression\n        rhs: Right-hand side expression\n        is_convex: Flag indicating if the constraint is known to be convex\n\n    Note:\n        Constraints are canonicalized to standard form: (lhs - rhs) {op} 0\n    \"\"\"\n\n    def __init__(self, lhs: Expr, rhs: Expr):\n        \"\"\"Initialize a constraint.\n\n        Args:\n            lhs: Left-hand side expression\n            rhs: Right-hand side expression\n        \"\"\"\n        self.lhs = lhs\n        self.rhs = rhs\n        self.is_convex = False\n\n    def children(self):\n        return [self.lhs, self.rhs]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize constraint to standard form: (lhs - rhs) {op} 0.\n\n        This works for both Equality and Inequality by using type(self) to\n        construct the appropriate subclass type.\n        \"\"\"\n        diff = Sub(self.lhs, self.rhs)\n        canon_diff = diff.canonicalize()\n        new_constraint = type(self)(canon_diff, Constant(np.array(0)))\n        new_constraint.is_convex = self.is_convex  # Preserve convex flag\n        return new_constraint\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that constraint operands are broadcastable. Returns scalar shape.\"\"\"\n        L_shape = self.lhs.check_shape()\n        R_shape = self.rhs.check_shape()\n\n        # Figure out their broadcasted shape (or error if incompatible)\n        try:\n            np.broadcast_shapes(L_shape, R_shape)\n        except ValueError as e:\n            constraint_type = type(self).__name__\n            raise ValueError(f\"{constraint_type} not broadcastable: {L_shape} vs {R_shape}\") from e\n\n        # Allow vector constraints - they're interpreted element-wise\n        # Return () as constraints always produce a scalar\n        return ()\n\n    def at(self, nodes: Union[list, tuple]):\n        \"\"\"Apply this constraint only at specific discrete nodes.\n\n        Args:\n            nodes: List of node indices where the constraint should be enforced\n\n        Returns:\n            NodalConstraint wrapping this constraint with node specification\n        \"\"\"\n        if isinstance(nodes, int):\n            nodes = [nodes]\n        return NodalConstraint(self, list(nodes))\n\n    def over(\n        self,\n        interval: tuple[int, int],\n        penalty: str = \"squared_relu\",\n        idx: Optional[int] = None,\n        check_nodally: bool = False,\n    ):\n        \"\"\"Apply this constraint over a continuous interval using CTCS.\n\n        Args:\n            interval: Tuple of (start, end) node indices for the continuous interval\n            penalty: Penalty function type (\"squared_relu\", \"huber\", \"smooth_relu\")\n            idx: Optional grouping index for multiple augmented states\n            check_nodally: Whether to also enforce this constraint nodally\n\n        Returns:\n            CTCS constraint wrapping this constraint with interval specification\n        \"\"\"\n        return CTCS(self, penalty=penalty, nodes=interval, idx=idx, check_nodally=check_nodally)\n\n    def convex(self) -&gt; \"Constraint\":\n        \"\"\"Mark this constraint as convex for CVXPy lowering.\n\n        Returns:\n            Self with convex flag set to True (enables method chaining)\n        \"\"\"\n        self.is_convex = True\n        return self\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.Constraint.at","title":"<code>at(nodes: Union[list, tuple])</code>","text":"<p>Apply this constraint only at specific discrete nodes.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>Union[list, tuple]</code> <p>List of node indices where the constraint should be enforced</p> required <p>Returns:</p> Type Description <p>NodalConstraint wrapping this constraint with node specification</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def at(self, nodes: Union[list, tuple]):\n    \"\"\"Apply this constraint only at specific discrete nodes.\n\n    Args:\n        nodes: List of node indices where the constraint should be enforced\n\n    Returns:\n        NodalConstraint wrapping this constraint with node specification\n    \"\"\"\n    if isinstance(nodes, int):\n        nodes = [nodes]\n    return NodalConstraint(self, list(nodes))\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.Constraint.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize constraint to standard form: (lhs - rhs) {op} 0.</p> <p>This works for both Equality and Inequality by using type(self) to construct the appropriate subclass type.</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize constraint to standard form: (lhs - rhs) {op} 0.\n\n    This works for both Equality and Inequality by using type(self) to\n    construct the appropriate subclass type.\n    \"\"\"\n    diff = Sub(self.lhs, self.rhs)\n    canon_diff = diff.canonicalize()\n    new_constraint = type(self)(canon_diff, Constant(np.array(0)))\n    new_constraint.is_convex = self.is_convex  # Preserve convex flag\n    return new_constraint\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.Constraint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that constraint operands are broadcastable. Returns scalar shape.</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that constraint operands are broadcastable. Returns scalar shape.\"\"\"\n    L_shape = self.lhs.check_shape()\n    R_shape = self.rhs.check_shape()\n\n    # Figure out their broadcasted shape (or error if incompatible)\n    try:\n        np.broadcast_shapes(L_shape, R_shape)\n    except ValueError as e:\n        constraint_type = type(self).__name__\n        raise ValueError(f\"{constraint_type} not broadcastable: {L_shape} vs {R_shape}\") from e\n\n    # Allow vector constraints - they're interpreted element-wise\n    # Return () as constraints always produce a scalar\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.Constraint.convex","title":"<code>convex() -&gt; Constraint</code>","text":"<p>Mark this constraint as convex for CVXPy lowering.</p> <p>Returns:</p> Type Description <code>Constraint</code> <p>Self with convex flag set to True (enables method chaining)</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def convex(self) -&gt; \"Constraint\":\n    \"\"\"Mark this constraint as convex for CVXPy lowering.\n\n    Returns:\n        Self with convex flag set to True (enables method chaining)\n    \"\"\"\n    self.is_convex = True\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.Constraint.over","title":"<code>over(interval: tuple[int, int], penalty: str = 'squared_relu', idx: Optional[int] = None, check_nodally: bool = False)</code>","text":"<p>Apply this constraint over a continuous interval using CTCS.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>tuple[int, int]</code> <p>Tuple of (start, end) node indices for the continuous interval</p> required <code>penalty</code> <code>str</code> <p>Penalty function type (\"squared_relu\", \"huber\", \"smooth_relu\")</p> <code>'squared_relu'</code> <code>idx</code> <code>Optional[int]</code> <p>Optional grouping index for multiple augmented states</p> <code>None</code> <code>check_nodally</code> <code>bool</code> <p>Whether to also enforce this constraint nodally</p> <code>False</code> <p>Returns:</p> Type Description <p>CTCS constraint wrapping this constraint with interval specification</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def over(\n    self,\n    interval: tuple[int, int],\n    penalty: str = \"squared_relu\",\n    idx: Optional[int] = None,\n    check_nodally: bool = False,\n):\n    \"\"\"Apply this constraint over a continuous interval using CTCS.\n\n    Args:\n        interval: Tuple of (start, end) node indices for the continuous interval\n        penalty: Penalty function type (\"squared_relu\", \"huber\", \"smooth_relu\")\n        idx: Optional grouping index for multiple augmented states\n        check_nodally: Whether to also enforce this constraint nodally\n\n    Returns:\n        CTCS constraint wrapping this constraint with interval specification\n    \"\"\"\n    return CTCS(self, penalty=penalty, nodes=interval, idx=idx, check_nodally=check_nodally)\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CrossNodeConstraint","title":"<code>CrossNodeConstraint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>A constraint that couples specific trajectory nodes via .at(k) references.</p> <p>Unlike NodalConstraint which applies a constraint pattern at multiple nodes (via vmapping), CrossNodeConstraint is a single constraint with fixed node indices embedded in the expression via NodeReference nodes.</p> <p>CrossNodeConstraint is created automatically when a bare Constraint contains NodeReference nodes (from .at(k) calls). Users should NOT manually wrap cross-node constraints - they are auto-detected during constraint separation.</p> <p>Key differences from NodalConstraint:</p> <ul> <li>NodalConstraint: Same constraint evaluated at multiple nodes via vmapping.   Signature: (x, u, node, params) \u2192 scalar, vmapped to (N, n_x) inputs.</li> <li>CrossNodeConstraint: Single constraint coupling specific fixed nodes.   Signature: (X, U, params) \u2192 scalar, operates on full trajectory arrays.</li> </ul> <p>Lowering:</p> <ul> <li>Non-convex: Lowered to JAX with automatic differentiation for SCP linearization</li> <li>Convex: Lowered to CVXPy and solved directly by the convex solver</li> </ul> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint containing NodeReference nodes</p> Example <p>Rate limit constraint (auto-detected as CrossNodeConstraint):</p> <pre><code>position = State(\"pos\", shape=(3,))\n\n# This creates a CrossNodeConstraint automatically:\nrate_limit = position.at(5) - position.at(4) &lt;= 0.1\n\n# Mark as convex if the constraint is convex:\nrate_limit_convex = (position.at(5) - position.at(4) &lt;= 0.1).convex()\n</code></pre> <p>Creating multiple cross-node constraints with a loop:</p> <pre><code>constraints = []\nfor k in range(1, N):\n    # Each iteration creates one CrossNodeConstraint\n    rate_limit = position.at(k) - position.at(k-1) &lt;= max_step\n    constraints.append(rate_limit)\n</code></pre> Note <p>Do NOT use .at([...]) on cross-node constraints. The nodes are already specified via .at(k) inside the expression. Using .at([...]) will raise an error during constraint separation.</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class CrossNodeConstraint(Expr):\n    \"\"\"A constraint that couples specific trajectory nodes via .at(k) references.\n\n    Unlike NodalConstraint which applies a constraint pattern at multiple nodes\n    (via vmapping), CrossNodeConstraint is a single constraint with fixed node\n    indices embedded in the expression via NodeReference nodes.\n\n    CrossNodeConstraint is created automatically when a bare Constraint contains\n    NodeReference nodes (from .at(k) calls). Users should NOT manually wrap\n    cross-node constraints - they are auto-detected during constraint separation.\n\n    **Key differences from NodalConstraint:**\n\n    - **NodalConstraint**: Same constraint evaluated at multiple nodes via vmapping.\n      Signature: (x, u, node, params) \u2192 scalar, vmapped to (N, n_x) inputs.\n    - **CrossNodeConstraint**: Single constraint coupling specific fixed nodes.\n      Signature: (X, U, params) \u2192 scalar, operates on full trajectory arrays.\n\n    **Lowering:**\n\n    - **Non-convex**: Lowered to JAX with automatic differentiation for SCP linearization\n    - **Convex**: Lowered to CVXPy and solved directly by the convex solver\n\n    Attributes:\n        constraint: The wrapped Constraint containing NodeReference nodes\n\n    Example:\n        Rate limit constraint (auto-detected as CrossNodeConstraint):\n\n            position = State(\"pos\", shape=(3,))\n\n            # This creates a CrossNodeConstraint automatically:\n            rate_limit = position.at(5) - position.at(4) &lt;= 0.1\n\n            # Mark as convex if the constraint is convex:\n            rate_limit_convex = (position.at(5) - position.at(4) &lt;= 0.1).convex()\n\n        Creating multiple cross-node constraints with a loop:\n\n            constraints = []\n            for k in range(1, N):\n                # Each iteration creates one CrossNodeConstraint\n                rate_limit = position.at(k) - position.at(k-1) &lt;= max_step\n                constraints.append(rate_limit)\n\n    Note:\n        Do NOT use .at([...]) on cross-node constraints. The nodes are already\n        specified via .at(k) inside the expression. Using .at([...]) will raise\n        an error during constraint separation.\n    \"\"\"\n\n    def __init__(self, constraint: Constraint):\n        \"\"\"Initialize a CrossNodeConstraint.\n\n        Args:\n            constraint: The Constraint containing NodeReference nodes.\n                Must contain at least one NodeReference (from .at(k) calls).\n\n        Raises:\n            TypeError: If constraint is not a Constraint instance\n        \"\"\"\n        if not isinstance(constraint, Constraint):\n            raise TypeError(\"CrossNodeConstraint must wrap a Constraint\")\n\n        self.constraint = constraint\n\n    @property\n    def is_convex(self) -&gt; bool:\n        \"\"\"Whether the underlying constraint is marked as convex.\n\n        Returns:\n            bool: True if the constraint is convex, False otherwise\n        \"\"\"\n        return self.constraint.is_convex\n\n    def children(self):\n        \"\"\"Return the wrapped constraint as the only child.\n\n        Returns:\n            list: Single-element list containing the wrapped constraint\n        \"\"\"\n        return [self.constraint]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the wrapped constraint.\n\n        Returns:\n            CrossNodeConstraint: A new CrossNodeConstraint with canonicalized inner constraint\n        \"\"\"\n        canon_constraint = self.constraint.canonicalize()\n        return CrossNodeConstraint(canon_constraint)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Validate the wrapped constraint's shape.\n\n        Returns:\n            tuple: Empty tuple () representing scalar shape\n        \"\"\"\n        self.constraint.check_shape()\n        return ()\n\n    def convex(self) -&gt; \"CrossNodeConstraint\":\n        \"\"\"Mark the underlying constraint as convex for CVXPy lowering.\n\n        Returns:\n            Self with underlying constraint's convex flag set to True\n        \"\"\"\n        self.constraint.convex()\n        return self\n\n    def __repr__(self):\n        \"\"\"String representation of the CrossNodeConstraint.\n\n        Returns:\n            str: String showing the wrapped constraint\n        \"\"\"\n        return f\"CrossNodeConstraint({self.constraint!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CrossNodeConstraint.is_convex","title":"<code>is_convex: bool</code>  <code>property</code>","text":"<p>Whether the underlying constraint is marked as convex.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the constraint is convex, False otherwise</p>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CrossNodeConstraint.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the wrapped constraint.</p> <p>Returns:</p> Name Type Description <code>CrossNodeConstraint</code> <code>Expr</code> <p>A new CrossNodeConstraint with canonicalized inner constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the wrapped constraint.\n\n    Returns:\n        CrossNodeConstraint: A new CrossNodeConstraint with canonicalized inner constraint\n    \"\"\"\n    canon_constraint = self.constraint.canonicalize()\n    return CrossNodeConstraint(canon_constraint)\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CrossNodeConstraint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the wrapped constraint's shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Validate the wrapped constraint's shape.\n\n    Returns:\n        tuple: Empty tuple () representing scalar shape\n    \"\"\"\n    self.constraint.check_shape()\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CrossNodeConstraint.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def children(self):\n    \"\"\"Return the wrapped constraint as the only child.\n\n    Returns:\n        list: Single-element list containing the wrapped constraint\n    \"\"\"\n    return [self.constraint]\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CrossNodeConstraint.convex","title":"<code>convex() -&gt; CrossNodeConstraint</code>","text":"<p>Mark the underlying constraint as convex for CVXPy lowering.</p> <p>Returns:</p> Type Description <code>CrossNodeConstraint</code> <p>Self with underlying constraint's convex flag set to True</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def convex(self) -&gt; \"CrossNodeConstraint\":\n    \"\"\"Mark the underlying constraint as convex for CVXPy lowering.\n\n    Returns:\n        Self with underlying constraint's convex flag set to True\n    \"\"\"\n    self.constraint.convex()\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.Equality","title":"<code>Equality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Equality constraint for optimization problems.</p> <p>Represents an equality constraint: lhs == rhs. Can be created using the == operator on Expr objects.</p> Example <p>Define an Equality constraint:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = x == 0  # Creates Equality(x, Constant(0))\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class Equality(Constraint):\n    \"\"\"Equality constraint for optimization problems.\n\n    Represents an equality constraint: lhs == rhs. Can be created using the ==\n    operator on Expr objects.\n\n    Example:\n        Define an Equality constraint:\n\n            x = ox.State(\"x\", shape=(3,))\n            constraint = x == 0  # Creates Equality(x, Constant(0))\n    \"\"\"\n\n    def __repr__(self):\n        return f\"{self.lhs!r} == {self.rhs!r}\"\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.Inequality","title":"<code>Inequality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Inequality constraint for optimization problems.</p> <p>Represents an inequality constraint: lhs &lt;= rhs. Can be created using the &lt;= operator on Expr objects.</p> Example <p>Define an Inequality constraint:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = x &lt;= 10  # Creates Inequality(x, Constant(10))\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class Inequality(Constraint):\n    \"\"\"Inequality constraint for optimization problems.\n\n    Represents an inequality constraint: lhs &lt;= rhs. Can be created using the &lt;=\n    operator on Expr objects.\n\n    Example:\n        Define an Inequality constraint:\n\n            x = ox.State(\"x\", shape=(3,))\n            constraint = x &lt;= 10  # Creates Inequality(x, Constant(10))\n    \"\"\"\n\n    def __repr__(self):\n        return f\"{self.lhs!r} &lt;= {self.rhs!r}\"\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.NodalConstraint","title":"<code>NodalConstraint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Wrapper for constraints enforced only at specific discrete trajectory nodes.</p> <p>NodalConstraint allows selective enforcement of constraints at specific time points (nodes) in a discretized trajectory, rather than enforcing them at every node. This is useful for:</p> <ul> <li>Specifying waypoint constraints (e.g., pass through point X at node 10)</li> <li>Boundary conditions at non-standard locations</li> <li>Reducing computational cost by checking constraints less frequently</li> <li>Enforcing periodic constraints (e.g., every 5th node)</li> </ul> <p>The wrapper maintains clean separation between the constraint's mathematical definition and the specification of where it should be applied during optimization.</p> Note <p>Bare Constraint objects (without .at() or .over()) are automatically converted to NodalConstraints applied at all nodes during preprocessing.</p> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (Equality or Inequality) to enforce</p> <code>nodes</code> <p>List of integer node indices where the constraint is enforced</p> Example <p>Enforce position constraint only at nodes 0, 10, and 20:</p> <pre><code>x = State(\"x\", shape=(3,))\ntarget = [10, 5, 0]\nconstraint = (x == target).at([0, 10, 20])\n</code></pre> <p>Equivalent using NodalConstraint directly:</p> <pre><code>constraint = NodalConstraint(x == target, nodes=[0, 10, 20])\n</code></pre> <p>Periodic constraint enforcement (every 10th node):</p> <pre><code>velocity_limit = (vel &lt;= 100).at(list(range(0, 100, 10)))\n</code></pre> <p>Bare constraints are automatically applied at all nodes. These are equivalent:</p> <pre><code>constraint1 = vel &lt;= 100  # Auto-converted to all nodes\nconstraint2 = (vel &lt;= 100).at(list(range(n_nodes)))\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class NodalConstraint(Expr):\n    \"\"\"Wrapper for constraints enforced only at specific discrete trajectory nodes.\n\n    NodalConstraint allows selective enforcement of constraints at specific time points\n    (nodes) in a discretized trajectory, rather than enforcing them at every node.\n    This is useful for:\n\n    - Specifying waypoint constraints (e.g., pass through point X at node 10)\n    - Boundary conditions at non-standard locations\n    - Reducing computational cost by checking constraints less frequently\n    - Enforcing periodic constraints (e.g., every 5th node)\n\n    The wrapper maintains clean separation between the constraint's mathematical\n    definition and the specification of where it should be applied during optimization.\n\n    Note:\n        Bare Constraint objects (without .at() or .over()) are automatically converted\n        to NodalConstraints applied at all nodes during preprocessing.\n\n    Attributes:\n        constraint: The wrapped Constraint (Equality or Inequality) to enforce\n        nodes: List of integer node indices where the constraint is enforced\n\n    Example:\n        Enforce position constraint only at nodes 0, 10, and 20:\n\n            x = State(\"x\", shape=(3,))\n            target = [10, 5, 0]\n            constraint = (x == target).at([0, 10, 20])\n\n        Equivalent using NodalConstraint directly:\n\n            constraint = NodalConstraint(x == target, nodes=[0, 10, 20])\n\n        Periodic constraint enforcement (every 10th node):\n\n            velocity_limit = (vel &lt;= 100).at(list(range(0, 100, 10)))\n\n        Bare constraints are automatically applied at all nodes.\n        These are equivalent:\n\n            constraint1 = vel &lt;= 100  # Auto-converted to all nodes\n            constraint2 = (vel &lt;= 100).at(list(range(n_nodes)))\n    \"\"\"\n\n    def __init__(self, constraint: Constraint, nodes: list[int]):\n        \"\"\"Initialize a NodalConstraint.\n\n        Args:\n            constraint: The Constraint (Equality or Inequality) to enforce at specified nodes\n            nodes: List of integer node indices where the constraint should be enforced.\n                Automatically converts numpy integers to Python integers.\n\n        Raises:\n            TypeError: If constraint is not a Constraint instance\n            TypeError: If nodes is not a list\n            TypeError: If any node index is not an integer\n\n        Note:\n            Bounds checking for cross-node constraints (those containing NodeReference)\n            is performed later in the pipeline when N is known, via\n            validate_cross_node_constraint_bounds() in preprocessing.py.\n        \"\"\"\n        if not isinstance(constraint, Constraint):\n            raise TypeError(\"NodalConstraint must wrap a Constraint\")\n        if not isinstance(nodes, list):\n            raise TypeError(\"nodes must be a list of integers\")\n\n        # Convert numpy integers to Python integers\n        converted_nodes = []\n        for n in nodes:\n            if isinstance(n, np.integer):\n                converted_nodes.append(int(n))\n            elif isinstance(n, int):\n                converted_nodes.append(n)\n            else:\n                raise TypeError(\"all node indices must be integers\")\n\n        self.constraint = constraint\n        self.nodes = converted_nodes\n\n    def children(self):\n        \"\"\"Return the wrapped constraint as the only child.\n\n        Returns:\n            list: Single-element list containing the wrapped constraint\n        \"\"\"\n        return [self.constraint]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the wrapped constraint while preserving node specification.\n\n        Returns:\n            NodalConstraint: A new NodalConstraint with canonicalized inner constraint\n        \"\"\"\n        canon_constraint = self.constraint.canonicalize()\n        return NodalConstraint(canon_constraint, self.nodes)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Validate the wrapped constraint's shape.\n\n        NodalConstraint wraps a constraint without changing its computational meaning,\n        only specifying where it should be applied. Like all constraints, it produces\n        a scalar result.\n\n        Returns:\n            tuple: Empty tuple () representing scalar shape\n        \"\"\"\n        # Validate the wrapped constraint's shape\n        self.constraint.check_shape()\n\n        # NodalConstraint produces a scalar like any constraint\n        return ()\n\n    def convex(self) -&gt; \"NodalConstraint\":\n        \"\"\"Mark the underlying constraint as convex for CVXPy lowering.\n\n        Returns:\n            Self with underlying constraint's convex flag set to True (enables method chaining)\n\n        Example:\n            Mark a constraint as convex:\n                constraint = (x &lt;= 10).at([0, 5, 10]).convex()\n        \"\"\"\n        self.constraint.convex()\n        return self\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash NodalConstraint including its node list.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"NodalConstraint\")\n        # Hash the nodes list\n        for node in self.nodes:\n            hasher.update(struct.pack(\"&gt;i\", node))\n        hasher.update(b\"|\")  # Separator to distinguish node counts\n        # Hash the wrapped constraint\n        self.constraint._hash_into(hasher)\n\n    def __repr__(self):\n        \"\"\"String representation of the NodalConstraint.\n\n        Returns:\n            str: String showing the wrapped constraint and node indices\n        \"\"\"\n        return f\"NodalConstraint({self.constraint!r}, nodes={self.nodes})\"\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.NodalConstraint._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash NodalConstraint including its node list.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash NodalConstraint including its node list.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(b\"NodalConstraint\")\n    # Hash the nodes list\n    for node in self.nodes:\n        hasher.update(struct.pack(\"&gt;i\", node))\n    hasher.update(b\"|\")  # Separator to distinguish node counts\n    # Hash the wrapped constraint\n    self.constraint._hash_into(hasher)\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.NodalConstraint.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the wrapped constraint while preserving node specification.</p> <p>Returns:</p> Name Type Description <code>NodalConstraint</code> <code>Expr</code> <p>A new NodalConstraint with canonicalized inner constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the wrapped constraint while preserving node specification.\n\n    Returns:\n        NodalConstraint: A new NodalConstraint with canonicalized inner constraint\n    \"\"\"\n    canon_constraint = self.constraint.canonicalize()\n    return NodalConstraint(canon_constraint, self.nodes)\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.NodalConstraint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the wrapped constraint's shape.</p> <p>NodalConstraint wraps a constraint without changing its computational meaning, only specifying where it should be applied. Like all constraints, it produces a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Validate the wrapped constraint's shape.\n\n    NodalConstraint wraps a constraint without changing its computational meaning,\n    only specifying where it should be applied. Like all constraints, it produces\n    a scalar result.\n\n    Returns:\n        tuple: Empty tuple () representing scalar shape\n    \"\"\"\n    # Validate the wrapped constraint's shape\n    self.constraint.check_shape()\n\n    # NodalConstraint produces a scalar like any constraint\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.NodalConstraint.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def children(self):\n    \"\"\"Return the wrapped constraint as the only child.\n\n    Returns:\n        list: Single-element list containing the wrapped constraint\n    \"\"\"\n    return [self.constraint]\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.NodalConstraint.convex","title":"<code>convex() -&gt; NodalConstraint</code>","text":"<p>Mark the underlying constraint as convex for CVXPy lowering.</p> <p>Returns:</p> Type Description <code>NodalConstraint</code> <p>Self with underlying constraint's convex flag set to True (enables method chaining)</p> Example <p>Mark a constraint as convex:     constraint = (x &lt;= 10).at([0, 5, 10]).convex()</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def convex(self) -&gt; \"NodalConstraint\":\n    \"\"\"Mark the underlying constraint as convex for CVXPy lowering.\n\n    Returns:\n        Self with underlying constraint's convex flag set to True (enables method chaining)\n\n    Example:\n        Mark a constraint as convex:\n            constraint = (x &lt;= 10).at([0, 5, 10]).convex()\n    \"\"\"\n    self.constraint.convex()\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.ctcs","title":"<code>ctcs(constraint: Constraint, penalty: str = 'squared_relu', nodes: Optional[Tuple[int, int]] = None, idx: Optional[int] = None, check_nodally: bool = False) -&gt; CTCS</code>","text":"<p>Helper function to create CTCS (Continuous-Time Constraint Satisfaction) constraints.</p> <p>This is a convenience function that creates a CTCS constraint with the same parameters as the CTCS constructor. Useful for functional-style constraint building.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>Constraint</code> <p>The Constraint to enforce continuously</p> required <code>penalty</code> <code>str</code> <p>Penalty function type ('squared_relu', 'huber', or 'smooth_relu'). Defaults to 'squared_relu'.</p> <code>'squared_relu'</code> <code>nodes</code> <code>Optional[Tuple[int, int]]</code> <p>Optional (start, end) tuple of node indices for enforcement interval. None enforces over entire trajectory.</p> <code>None</code> <code>idx</code> <code>Optional[int]</code> <p>Optional grouping index for multiple augmented states</p> <code>None</code> <code>check_nodally</code> <code>bool</code> <p>Whether to also enforce constraint at discrete nodes. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>CTCS</code> <code>CTCS</code> <p>A CTCS constraint wrapping the input constraint</p> Example <p>Using the helper function:</p> <pre><code>from openscvx.symbolic.expr.constraint import ctcs\naltitude_constraint = ctcs(\n    altitude &gt;= 10,\n    penalty=\"huber\",\n    nodes=(0, 100),\n    check_nodally=True\n)\n</code></pre> <p>Equivalent to using CTCS constructor:</p> <pre><code>altitude_constraint = CTCS(altitude &gt;= 10, penalty=\"huber\", nodes=(0, 100))\n</code></pre> <p>Also equivalent to using .over() method on constraint:</p> <pre><code>altitude_constraint = (altitude &gt;= 10).over((0, 100), penalty=\"huber\")\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def ctcs(\n    constraint: Constraint,\n    penalty: str = \"squared_relu\",\n    nodes: Optional[Tuple[int, int]] = None,\n    idx: Optional[int] = None,\n    check_nodally: bool = False,\n) -&gt; CTCS:\n    \"\"\"Helper function to create CTCS (Continuous-Time Constraint Satisfaction) constraints.\n\n    This is a convenience function that creates a CTCS constraint with the same\n    parameters as the CTCS constructor. Useful for functional-style constraint building.\n\n    Args:\n        constraint: The Constraint to enforce continuously\n        penalty: Penalty function type ('squared_relu', 'huber', or 'smooth_relu').\n            Defaults to 'squared_relu'.\n        nodes: Optional (start, end) tuple of node indices for enforcement interval.\n            None enforces over entire trajectory.\n        idx: Optional grouping index for multiple augmented states\n        check_nodally: Whether to also enforce constraint at discrete nodes.\n            Defaults to False.\n\n    Returns:\n        CTCS: A CTCS constraint wrapping the input constraint\n\n    Example:\n        Using the helper function:\n\n            from openscvx.symbolic.expr.constraint import ctcs\n            altitude_constraint = ctcs(\n                altitude &gt;= 10,\n                penalty=\"huber\",\n                nodes=(0, 100),\n                check_nodally=True\n            )\n\n        Equivalent to using CTCS constructor:\n\n            altitude_constraint = CTCS(altitude &gt;= 10, penalty=\"huber\", nodes=(0, 100))\n\n        Also equivalent to using .over() method on constraint:\n\n            altitude_constraint = (altitude &gt;= 10).over((0, 100), penalty=\"huber\")\n    \"\"\"\n    return CTCS(constraint, penalty, nodes, idx, check_nodally)\n</code></pre>"},{"location":"reference/symbolic/expr/control/","title":"control","text":""},{"location":"reference/symbolic/expr/control/#openscvx.symbolic.expr.control.Control","title":"<code>Control</code>","text":"<p>               Bases: <code>Variable</code></p> <p>Control input variable for trajectory optimization problems.</p> <p>Control represents control input variables (actuator commands) in a trajectory optimization problem. Unlike State variables which evolve according to dynamics, Controls are direct decision variables that the optimizer can freely adjust (within specified bounds) at each time step to influence the system dynamics.</p> <p>Controls are conceptually similar to State variables but simpler - they don't have boundary conditions (initial/final specifications) since controls are typically not constrained at the endpoints. Like States, Controls support:</p> <ul> <li>Min/max bounds to enforce actuator limits</li> <li>Initial trajectory guesses to help the optimizer converge</li> </ul> <p>Common examples of control inputs include:</p> <ul> <li>Thrust magnitude and direction for spacecraft/rockets</li> <li>Throttle settings for engines</li> <li>Steering angles for vehicles</li> <li>Torques for robotic manipulators</li> <li>Force/acceleration commands</li> </ul> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name identifier for this control variable</p> <code>_shape</code> <code>tuple[int, ...]</code> <p>Shape of the control vector (typically 1D like (3,) for 3D thrust)</p> <code>_slice</code> <code>slice | None</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <code>ndarray | None</code> <p>Minimum bounds for each element of the control</p> <code>_max</code> <code>ndarray | None</code> <p>Maximum bounds for each element of the control</p> <code>_guess</code> <code>ndarray | None</code> <p>Initial guess for the control trajectory (n_points, n_controls)</p> Example <p>Scalar throttle control bounded [0, 1]:</p> <pre><code>throttle = Control(\"throttle\", shape=(1,))\nthrottle.min = [0.0]\nthrottle.max = [1.0]\nthrottle.guess = np.full((50, 1), 0.5)  # Start at 50% throttle\n</code></pre> <p>3D thrust vector for spacecraft:</p> <pre><code>thrust = Control(\"thrust\", shape=(3,))\nthrust.min = [-10, -10, 0]    # No downward thrust\nthrust.max = [10, 10, 50]     # Limited thrust\nthrust.guess = np.zeros((50, 3))  # Initialize with zero thrust\n</code></pre> <p>2D steering control (left/right, forward/backward):</p> <pre><code>steer = Control(\"steer\", shape=(2,))\nsteer.min = [-1, -1]\nsteer.max = [1, 1]\nsteer.guess = np.linspace([0, 0], [0, 1], 50)  # Gradual acceleration\n</code></pre> Source code in <code>openscvx/symbolic/expr/control.py</code> <pre><code>class Control(Variable):\n    \"\"\"Control input variable for trajectory optimization problems.\n\n    Control represents control input variables (actuator commands) in a trajectory\n    optimization problem. Unlike State variables which evolve according to dynamics,\n    Controls are direct decision variables that the optimizer can freely adjust\n    (within specified bounds) at each time step to influence the system dynamics.\n\n    Controls are conceptually similar to State variables but simpler - they don't\n    have boundary conditions (initial/final specifications) since controls are\n    typically not constrained at the endpoints. Like States, Controls support:\n\n    - Min/max bounds to enforce actuator limits\n    - Initial trajectory guesses to help the optimizer converge\n\n    Common examples of control inputs include:\n\n    - Thrust magnitude and direction for spacecraft/rockets\n    - Throttle settings for engines\n    - Steering angles for vehicles\n    - Torques for robotic manipulators\n    - Force/acceleration commands\n\n    Attributes:\n        name (str): Unique name identifier for this control variable\n        _shape (tuple[int, ...]): Shape of the control vector (typically 1D like (3,) for 3D thrust)\n        _slice (slice | None): Internal slice information for variable indexing\n        _min (np.ndarray | None): Minimum bounds for each element of the control\n        _max (np.ndarray | None): Maximum bounds for each element of the control\n        _guess (np.ndarray | None): Initial guess for the control trajectory (n_points, n_controls)\n\n    Example:\n        Scalar throttle control bounded [0, 1]:\n\n            throttle = Control(\"throttle\", shape=(1,))\n            throttle.min = [0.0]\n            throttle.max = [1.0]\n            throttle.guess = np.full((50, 1), 0.5)  # Start at 50% throttle\n\n        3D thrust vector for spacecraft:\n\n            thrust = Control(\"thrust\", shape=(3,))\n            thrust.min = [-10, -10, 0]    # No downward thrust\n            thrust.max = [10, 10, 50]     # Limited thrust\n            thrust.guess = np.zeros((50, 3))  # Initialize with zero thrust\n\n        2D steering control (left/right, forward/backward):\n\n            steer = Control(\"steer\", shape=(2,))\n            steer.min = [-1, -1]\n            steer.max = [1, 1]\n            steer.guess = np.linspace([0, 0], [0, 1], 50)  # Gradual acceleration\n    \"\"\"\n\n    def __init__(self, name, shape):\n        \"\"\"Initialize a Control object.\n\n        Args:\n            name: Name identifier for the control variable\n            shape: Shape of the control vector (typically 1D tuple like (3,))\n        \"\"\"\n        super().__init__(name, shape)\n        self._scaling_min = None\n        self._scaling_max = None\n\n    @property\n    def scaling_min(self):\n        \"\"\"Get the scaling minimum bounds for the control variables.\n\n        Returns:\n            Array of scaling minimum values for each control variable element, or None if not set.\n        \"\"\"\n        return self._scaling_min\n\n    @scaling_min.setter\n    def scaling_min(self, val):\n        \"\"\"Set the scaling minimum bounds for the control variables.\n\n        Args:\n            val: Array of scaling minimum values, must match the control shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the control shape\n        \"\"\"\n        if val is None:\n            self._scaling_min = None\n            return\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(\n                f\"Scaling min shape {val.shape} does not match Control shape {self.shape}\"\n            )\n        self._scaling_min = val\n\n    @property\n    def scaling_max(self):\n        \"\"\"Get the scaling maximum bounds for the control variables.\n\n        Returns:\n            Array of scaling maximum values for each control variable element, or None if not set.\n        \"\"\"\n        return self._scaling_max\n\n    @scaling_max.setter\n    def scaling_max(self, val):\n        \"\"\"Set the scaling maximum bounds for the control variables.\n\n        Args:\n            val: Array of scaling maximum values, must match the control shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the control shape\n        \"\"\"\n        if val is None:\n            self._scaling_max = None\n            return\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(\n                f\"Scaling max shape {val.shape} does not match Control shape {self.shape}\"\n            )\n        self._scaling_max = val\n\n    def __repr__(self):\n        \"\"\"String representation of the Control object.\n\n        Returns:\n            Concise string showing the control name and shape.\n        \"\"\"\n        return f\"Control('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/symbolic/expr/control/#openscvx.symbolic.expr.control.Control.scaling_max","title":"<code>scaling_max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling maximum bounds for the control variables.</p> <p>Returns:</p> Type Description <p>Array of scaling maximum values for each control variable element, or None if not set.</p>"},{"location":"reference/symbolic/expr/control/#openscvx.symbolic.expr.control.Control.scaling_min","title":"<code>scaling_min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling minimum bounds for the control variables.</p> <p>Returns:</p> Type Description <p>Array of scaling minimum values for each control variable element, or None if not set.</p>"},{"location":"reference/symbolic/expr/expr/","title":"expr","text":"<p>Core symbolic expression system for trajectory optimization.</p> <p>This module provides the foundation for openscvx's symbolic expression framework, implementing an Abstract Syntax Tree (AST) representation for mathematical expressions used in optimization problems. The expression system enables:</p> <ul> <li>Declarative problem specification: Write optimization problems using familiar     mathematical notation with operator overloading (+, -, , /, @, *, etc.)</li> <li>Automatic differentiation: Expressions are automatically differentiated during     compilation to solver-specific formats</li> <li>Shape checking: Static validation of tensor dimensions before optimization</li> <li>Canonicalization: Algebraic simplification for more efficient compilation</li> <li>Multiple backends: Expressions can be compiled to CVXPy, JAX, or custom solvers</li> </ul> Architecture <p>The expression system is built around an AST where each node is an <code>Expr</code> subclass:</p> <ul> <li>Leaf nodes: <code>Parameter</code>, <code>Variable</code>, <code>State</code>, <code>Control</code> - symbolic values</li> <li>Arithmetic operations: <code>Add</code>, <code>Sub</code>, <code>Mul</code>, <code>Div</code>, <code>MatMul</code>, <code>Power</code>, <code>Neg</code></li> <li>Array operations: <code>Index</code>, <code>Concat</code>, <code>Stack</code>, <code>Hstack</code>, <code>Vstack</code></li> <li>Linear algebra: <code>Transpose</code>, <code>Diag</code>, <code>Sum</code>, <code>Norm</code></li> <li>Constraints: <code>Equality</code>, <code>Inequality</code></li> <li>Functions: <code>Sin</code>, <code>Cos</code>, <code>Exp</code>, <code>Log</code>, <code>Sqrt</code>, etc.</li> </ul> <p>Each expression node implements:</p> <ul> <li><code>children()</code>: Returns child expressions in the AST</li> <li><code>canonicalize()</code>: Returns a simplified/normalized version</li> <li><code>check_shape()</code>: Validates and returns the output shape</li> </ul> Example <p>Creating symbolic variables and expressions::</p> <pre><code>import openscvx as ox\n\n# Define symbolic variables\nx = ox.State(\"x\", shape=(3,))\nA = ox.Parameter(\"A\", shape=(3, 3), value=np.eye(3))\n\n# Build expressions using natural syntax\nexpr = A @ x + 5\nconstraint = ox.Norm(x) &lt;= 1.0\n\n# Expressions form an AST\nprint(expr.pretty())  # Visualize the tree structure\n</code></pre> <p>Shape checking with automatic validation::</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(4,))\n\n# This will raise ValueError during shape checking\ntry:\n    expr = x + y  # Shapes (3,) and (4,) not broadcastable\n    expr.check_shape()\nexcept ValueError as e:\n    print(f\"Shape error: {e}\")\n</code></pre> <p>Algebraic canonicalization::</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nexpr = x + 0 + (1 * x)\ncanonical = expr.canonicalize()  # Simplifies to: x + x\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Constant","title":"<code>Constant</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Constant value expression.</p> <p>Represents a constant numeric value in the expression tree. Constants are automatically normalized (squeezed) upon construction to ensure consistency.</p> <p>Attributes:</p> Name Type Description <code>value</code> <p>The numpy array representing the constant value (squeezed)</p> Example <p>Define constants:</p> <pre><code>c1 = Constant(5.0)        # Scalar constant\nc2 = Constant([1, 2, 3])  # Vector constant\nc3 = to_expr(10)          # Also creates a Constant\n</code></pre> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class Constant(Expr):\n    \"\"\"Constant value expression.\n\n    Represents a constant numeric value in the expression tree. Constants are\n    automatically normalized (squeezed) upon construction to ensure consistency.\n\n    Attributes:\n        value: The numpy array representing the constant value (squeezed)\n\n    Example:\n        Define constants:\n\n            c1 = Constant(5.0)        # Scalar constant\n            c2 = Constant([1, 2, 3])  # Vector constant\n            c3 = to_expr(10)          # Also creates a Constant\n    \"\"\"\n\n    def __init__(self, value: np.ndarray):\n        \"\"\"Initialize a constant expression.\n\n        Args:\n            value: Numeric value or numpy array to wrap as a constant.\n                   Will be converted to numpy array and squeezed.\n        \"\"\"\n        # Normalize immediately upon construction to ensure consistency\n        # This ensures Constant(5.0) and Constant([5.0]) create identical objects\n        if not isinstance(value, np.ndarray):\n            value = np.array(value, dtype=float)\n        self.value = np.squeeze(value)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Constants are already in canonical form.\n\n        Returns:\n            Expr: Returns self since constants are already canonical\n        \"\"\"\n        return self\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Return the shape of this constant's value.\n\n        Returns:\n            tuple: The shape of the constant's numpy array value\n        \"\"\"\n        # Verify the invariant: constants should already be squeezed during construction\n        original_shape = self.value.shape\n        squeezed_shape = np.squeeze(self.value).shape\n        if original_shape != squeezed_shape:\n            raise ValueError(\n                f\"Constant not properly normalized: has shape {original_shape} \"\n                \"but should have shape {squeezed_shape}. \"\n                \"Constants should be squeezed during construction.\"\n            )\n        return self.value.shape\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash constant by its value.\n\n        Constants are hashed by their actual numeric value, ensuring that\n        expressions with the same constant values produce the same hash.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Constant\")\n        hasher.update(str(self.value.shape).encode())\n        hasher.update(self.value.tobytes())\n\n    def __repr__(self):\n        # Show clean representation - always show as Python values, not numpy arrays\n        if self.value.ndim == 0:\n            # Scalar: show as plain number\n            return f\"Const({self.value.item()!r})\"\n        else:\n            # Array: show as Python list for readability\n            return f\"Const({self.value.tolist()!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Constant._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash constant by its value.</p> <p>Constants are hashed by their actual numeric value, ensuring that expressions with the same constant values produce the same hash.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash constant by its value.\n\n    Constants are hashed by their actual numeric value, ensuring that\n    expressions with the same constant values produce the same hash.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(b\"Constant\")\n    hasher.update(str(self.value.shape).encode())\n    hasher.update(self.value.tobytes())\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Constant.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Constants are already in canonical form.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Returns self since constants are already canonical</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Constants are already in canonical form.\n\n    Returns:\n        Expr: Returns self since constants are already canonical\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Constant.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Return the shape of this constant's value.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The shape of the constant's numpy array value</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Return the shape of this constant's value.\n\n    Returns:\n        tuple: The shape of the constant's numpy array value\n    \"\"\"\n    # Verify the invariant: constants should already be squeezed during construction\n    original_shape = self.value.shape\n    squeezed_shape = np.squeeze(self.value).shape\n    if original_shape != squeezed_shape:\n        raise ValueError(\n            f\"Constant not properly normalized: has shape {original_shape} \"\n            \"but should have shape {squeezed_shape}. \"\n            \"Constants should be squeezed during construction.\"\n        )\n    return self.value.shape\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Expr","title":"<code>Expr</code>","text":"<p>Base class for symbolic expressions in optimization problems.</p> <p>Expr is the foundation of the symbolic expression system in openscvx. It represents nodes in an abstract syntax tree (AST) for mathematical expressions. Expressions support:</p> <ul> <li>Arithmetic operations: +, -, *, /, @, **</li> <li>Comparison operations: ==, &lt;=, &gt;=</li> <li>Indexing and slicing: []</li> <li>Transposition: .T property</li> <li>Shape checking and validation</li> <li>Canonicalization (algebraic simplification)</li> </ul> <p>All Expr subclasses implement a tree structure where each node can have child expressions accessed via the children() method.</p> <p>Attributes:</p> Name Type Description <code>__array_priority__</code> <p>Priority for operations with numpy arrays (set to 1000)</p> Note <p>When used in operations with numpy arrays, Expr objects take precedence, allowing symbolic expressions to wrap numeric values automatically.</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class Expr:\n    \"\"\"Base class for symbolic expressions in optimization problems.\n\n    Expr is the foundation of the symbolic expression system in openscvx. It represents\n    nodes in an abstract syntax tree (AST) for mathematical expressions. Expressions\n    support:\n\n    - Arithmetic operations: +, -, *, /, @, **\n    - Comparison operations: ==, &lt;=, &gt;=\n    - Indexing and slicing: []\n    - Transposition: .T property\n    - Shape checking and validation\n    - Canonicalization (algebraic simplification)\n\n    All Expr subclasses implement a tree structure where each node can have child\n    expressions accessed via the children() method.\n\n    Attributes:\n        __array_priority__: Priority for operations with numpy arrays (set to 1000)\n\n    Note:\n        When used in operations with numpy arrays, Expr objects take precedence,\n        allowing symbolic expressions to wrap numeric values automatically.\n    \"\"\"\n\n    # Give Expr objects higher priority than numpy arrays in operations\n    __array_priority__ = 1000\n\n    def __le__(self, other):\n        from .constraint import Inequality\n\n        return Inequality(self, to_expr(other))\n\n    def __ge__(self, other):\n        from .constraint import Inequality\n\n        return Inequality(to_expr(other), self)\n\n    def __eq__(self, other):\n        from .constraint import Equality\n\n        return Equality(self, to_expr(other))\n\n    def __add__(self, other):\n        from .arithmetic import Add\n\n        return Add(self, to_expr(other))\n\n    def __radd__(self, other):\n        from .arithmetic import Add\n\n        return Add(to_expr(other), self)\n\n    def __sub__(self, other):\n        from .arithmetic import Sub\n\n        return Sub(self, to_expr(other))\n\n    def __rsub__(self, other):\n        # e.g. 5 - a  \u21d2 Sub(Constant(5), a)\n        from .arithmetic import Sub\n\n        return Sub(to_expr(other), self)\n\n    def __truediv__(self, other):\n        from .arithmetic import Div\n\n        return Div(self, to_expr(other))\n\n    def __rtruediv__(self, other):\n        # e.g. 10 / a\n        from .arithmetic import Div\n\n        return Div(to_expr(other), self)\n\n    def __mul__(self, other):\n        from .arithmetic import Mul\n\n        return Mul(self, to_expr(other))\n\n    def __rmul__(self, other):\n        from .arithmetic import Mul\n\n        return Mul(to_expr(other), self)\n\n    def __matmul__(self, other):\n        from .arithmetic import MatMul\n\n        return MatMul(self, to_expr(other))\n\n    def __rmatmul__(self, other):\n        from .arithmetic import MatMul\n\n        return MatMul(to_expr(other), self)\n\n    def __rle__(self, other):\n        # other &lt;= self  =&gt;  Inequality(other, self)\n        from .constraint import Inequality\n\n        return Inequality(to_expr(other), self)\n\n    def __rge__(self, other):\n        # other &gt;= self  =&gt;  Inequality(self, other)\n        from .constraint import Inequality\n\n        return Inequality(self, to_expr(other))\n\n    def __req__(self, other):\n        # other == self  =&gt;  Equality(other, self)\n        from .constraint import Equality\n\n        return Equality(to_expr(other), self)\n\n    def __neg__(self):\n        from .arithmetic import Neg\n\n        return Neg(self)\n\n    def __pow__(self, other):\n        from .arithmetic import Power\n\n        return Power(self, to_expr(other))\n\n    def __rpow__(self, other):\n        from .arithmetic import Power\n\n        return Power(to_expr(other), self)\n\n    def __getitem__(self, idx):\n        from .array import Index\n\n        return Index(self, idx)\n\n    @property\n    def T(self):\n        \"\"\"Transpose property for matrix expressions.\n\n        Returns:\n            Transpose: A Transpose expression wrapping this expression\n\n        Example:\n            Create a transpose:\n\n                A = ox.State(\"A\", shape=(3, 4))\n                A_T = A.T  # Creates Transpose(A), result shape (4, 3)\n        \"\"\"\n        from .linalg import Transpose\n\n        return Transpose(self)\n\n    def at(self, k: int) -&gt; \"NodeReference\":\n        \"\"\"Reference this expression at a specific trajectory node.\n\n        This method enables inter-node constraints where you can reference\n        the value of an expression at different time steps. Common patterns\n        include rate limits and multi-step dependencies.\n\n        Args:\n            k: Absolute node index (integer) in the trajectory.\n               Can be positive (0, 1, 2, ...) or negative (-1 for last node).\n\n        Returns:\n            NodeReference: An expression representing this expression at node k\n\n        Example:\n            Rate limit constraint (applied across trajectory using a loop):\n\n                position = State(\"pos\", shape=(3,))\n\n                # Create rate limit for each node\n                constraints = [\n                    (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n                    for k in range(1, N)\n                ]\n\n            Multi-step dependency:\n\n                state = State(\"x\", shape=(1,))\n\n                # Fibonacci-like recurrence\n                constraints = [\n                    (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n                    for k in range(2, N)\n                ]\n\n        Performance Note:\n            Cross-node constraints use dense Jacobian storage which can be memory-intensive\n            for large N (&gt;100 nodes). See LoweredCrossNodeConstraint documentation for\n            details on memory usage and future sparse Jacobian support.\n        \"\"\"\n        return NodeReference(self, k)\n\n    def children(self):\n        \"\"\"Return the child expressions of this node.\n\n        Returns:\n            list: List of child Expr objects. Empty list for leaf nodes.\n        \"\"\"\n        return []\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"\n        Return a canonical (simplified) form of this expression.\n\n        Canonicalization performs algebraic simplifications such as:\n        - Constant folding (e.g., 2 + 3 \u2192 5)\n        - Identity elimination (e.g., x + 0 \u2192 x, x * 1 \u2192 x)\n        - Flattening nested operations (e.g., Add(Add(a, b), c) \u2192 Add(a, b, c))\n        - Algebraic rewrites (e.g., constraints to standard form)\n\n        Returns:\n            Expr: A canonical version of this expression\n\n        Raises:\n            NotImplementedError: If canonicalization is not implemented for this node type\n        \"\"\"\n        raise NotImplementedError(f\"canonicalize() not implemented for {self.__class__.__name__}\")\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"\n        Compute and validate the shape of this expression.\n\n        This method:\n        1. Recursively checks shapes of all child expressions\n        2. Validates that operations are shape-compatible (e.g., broadcasting rules)\n        3. Returns the output shape of this expression\n\n        For example:\n        - A Parameter with shape (3, 4) returns (3, 4)\n        - MatMul of (3, 4) @ (4, 5) returns (3, 5)\n        - Sum of any shape returns () (scalar)\n        - Add broadcasts shapes like NumPy\n\n        Returns:\n            tuple: The shape of this expression as a tuple of integers.\n                   Empty tuple () represents a scalar.\n\n        Raises:\n            NotImplementedError: If shape checking is not implemented for this node type\n            ValueError: If the expression has invalid shapes (e.g., incompatible dimensions)\n        \"\"\"\n        raise NotImplementedError(f\"check_shape() not implemented for {self.__class__.__name__}\")\n\n    def pretty(self, indent=0):\n        \"\"\"Generate a pretty-printed string representation of the expression tree.\n\n        Creates an indented, hierarchical view of the expression tree structure,\n        useful for debugging and visualization.\n\n        Args:\n            indent: Current indentation level (default: 0)\n\n        Returns:\n            str: Multi-line string representation of the expression tree\n\n        Example:\n            Pretty print an expression:\n\n                expr = (x + y) * z\n                print(expr.pretty())\n                # Mul\n                #   Add\n                #     State\n                #     State\n                #   State\n        \"\"\"\n        pad = \"  \" * indent\n        pad = \"  \" * indent\n        lines = [f\"{pad}{self.__class__.__name__}\"]\n        for child in self.children():\n            lines.append(child.pretty(indent + 1))\n        return \"\\n\".join(lines)\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Contribute this expression's structural identity to a hash.\n\n        This method is used to compute a structural hash of the expression tree\n        that is name-invariant (same structure = same hash regardless of variable names).\n\n        The default implementation hashes the class name and recursively hashes all\n        children. Subclasses with additional attributes (like Norm.ord, Index.index)\n        should override this to include those attributes.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        # Hash the class name to distinguish different node types\n        hasher.update(self.__class__.__name__.encode())\n        # Recursively hash all children\n        for child in self.children():\n            child._hash_into(hasher)\n\n    def structural_hash(self) -&gt; bytes:\n        \"\"\"Compute a structural hash of this expression.\n\n        Returns a hash that depends only on the mathematical structure of the\n        expression, not on variable names. Two expressions that are structurally\n        equivalent (same operations, same variable positions) will have the same hash.\n\n        Returns:\n            bytes: SHA-256 digest of the expression structure\n        \"\"\"\n        hasher = hashlib.sha256()\n        self._hash_into(hasher)\n        return hasher.digest()\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Expr.T","title":"<code>T</code>  <code>property</code>","text":"<p>Transpose property for matrix expressions.</p> <p>Returns:</p> Name Type Description <code>Transpose</code> <p>A Transpose expression wrapping this expression</p> Example <p>Create a transpose:</p> <pre><code>A = ox.State(\"A\", shape=(3, 4))\nA_T = A.T  # Creates Transpose(A), result shape (4, 3)\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Expr._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Contribute this expression's structural identity to a hash.</p> <p>This method is used to compute a structural hash of the expression tree that is name-invariant (same structure = same hash regardless of variable names).</p> <p>The default implementation hashes the class name and recursively hashes all children. Subclasses with additional attributes (like Norm.ord, Index.index) should override this to include those attributes.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Contribute this expression's structural identity to a hash.\n\n    This method is used to compute a structural hash of the expression tree\n    that is name-invariant (same structure = same hash regardless of variable names).\n\n    The default implementation hashes the class name and recursively hashes all\n    children. Subclasses with additional attributes (like Norm.ord, Index.index)\n    should override this to include those attributes.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    # Hash the class name to distinguish different node types\n    hasher.update(self.__class__.__name__.encode())\n    # Recursively hash all children\n    for child in self.children():\n        child._hash_into(hasher)\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Expr.at","title":"<code>at(k: int) -&gt; NodeReference</code>","text":"<p>Reference this expression at a specific trajectory node.</p> <p>This method enables inter-node constraints where you can reference the value of an expression at different time steps. Common patterns include rate limits and multi-step dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>Absolute node index (integer) in the trajectory. Can be positive (0, 1, 2, ...) or negative (-1 for last node).</p> required <p>Returns:</p> Name Type Description <code>NodeReference</code> <code>NodeReference</code> <p>An expression representing this expression at node k</p> Example <p>Rate limit constraint (applied across trajectory using a loop):</p> <pre><code>position = State(\"pos\", shape=(3,))\n\n# Create rate limit for each node\nconstraints = [\n    (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n    for k in range(1, N)\n]\n</code></pre> <p>Multi-step dependency:</p> <pre><code>state = State(\"x\", shape=(1,))\n\n# Fibonacci-like recurrence\nconstraints = [\n    (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n    for k in range(2, N)\n]\n</code></pre> Performance Note <p>Cross-node constraints use dense Jacobian storage which can be memory-intensive for large N (&gt;100 nodes). See LoweredCrossNodeConstraint documentation for details on memory usage and future sparse Jacobian support.</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def at(self, k: int) -&gt; \"NodeReference\":\n    \"\"\"Reference this expression at a specific trajectory node.\n\n    This method enables inter-node constraints where you can reference\n    the value of an expression at different time steps. Common patterns\n    include rate limits and multi-step dependencies.\n\n    Args:\n        k: Absolute node index (integer) in the trajectory.\n           Can be positive (0, 1, 2, ...) or negative (-1 for last node).\n\n    Returns:\n        NodeReference: An expression representing this expression at node k\n\n    Example:\n        Rate limit constraint (applied across trajectory using a loop):\n\n            position = State(\"pos\", shape=(3,))\n\n            # Create rate limit for each node\n            constraints = [\n                (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n                for k in range(1, N)\n            ]\n\n        Multi-step dependency:\n\n            state = State(\"x\", shape=(1,))\n\n            # Fibonacci-like recurrence\n            constraints = [\n                (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n                for k in range(2, N)\n            ]\n\n    Performance Note:\n        Cross-node constraints use dense Jacobian storage which can be memory-intensive\n        for large N (&gt;100 nodes). See LoweredCrossNodeConstraint documentation for\n        details on memory usage and future sparse Jacobian support.\n    \"\"\"\n    return NodeReference(self, k)\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Expr.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Return a canonical (simplified) form of this expression.</p> <p>Canonicalization performs algebraic simplifications such as: - Constant folding (e.g., 2 + 3 \u2192 5) - Identity elimination (e.g., x + 0 \u2192 x, x * 1 \u2192 x) - Flattening nested operations (e.g., Add(Add(a, b), c) \u2192 Add(a, b, c)) - Algebraic rewrites (e.g., constraints to standard form)</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>A canonical version of this expression</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If canonicalization is not implemented for this node type</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"\n    Return a canonical (simplified) form of this expression.\n\n    Canonicalization performs algebraic simplifications such as:\n    - Constant folding (e.g., 2 + 3 \u2192 5)\n    - Identity elimination (e.g., x + 0 \u2192 x, x * 1 \u2192 x)\n    - Flattening nested operations (e.g., Add(Add(a, b), c) \u2192 Add(a, b, c))\n    - Algebraic rewrites (e.g., constraints to standard form)\n\n    Returns:\n        Expr: A canonical version of this expression\n\n    Raises:\n        NotImplementedError: If canonicalization is not implemented for this node type\n    \"\"\"\n    raise NotImplementedError(f\"canonicalize() not implemented for {self.__class__.__name__}\")\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Expr.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Compute and validate the shape of this expression.</p> <p>This method: 1. Recursively checks shapes of all child expressions 2. Validates that operations are shape-compatible (e.g., broadcasting rules) 3. Returns the output shape of this expression</p> <p>For example: - A Parameter with shape (3, 4) returns (3, 4) - MatMul of (3, 4) @ (4, 5) returns (3, 5) - Sum of any shape returns () (scalar) - Add broadcasts shapes like NumPy</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The shape of this expression as a tuple of integers.    Empty tuple () represents a scalar.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If shape checking is not implemented for this node type</p> <code>ValueError</code> <p>If the expression has invalid shapes (e.g., incompatible dimensions)</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"\n    Compute and validate the shape of this expression.\n\n    This method:\n    1. Recursively checks shapes of all child expressions\n    2. Validates that operations are shape-compatible (e.g., broadcasting rules)\n    3. Returns the output shape of this expression\n\n    For example:\n    - A Parameter with shape (3, 4) returns (3, 4)\n    - MatMul of (3, 4) @ (4, 5) returns (3, 5)\n    - Sum of any shape returns () (scalar)\n    - Add broadcasts shapes like NumPy\n\n    Returns:\n        tuple: The shape of this expression as a tuple of integers.\n               Empty tuple () represents a scalar.\n\n    Raises:\n        NotImplementedError: If shape checking is not implemented for this node type\n        ValueError: If the expression has invalid shapes (e.g., incompatible dimensions)\n    \"\"\"\n    raise NotImplementedError(f\"check_shape() not implemented for {self.__class__.__name__}\")\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Expr.children","title":"<code>children()</code>","text":"<p>Return the child expressions of this node.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of child Expr objects. Empty list for leaf nodes.</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def children(self):\n    \"\"\"Return the child expressions of this node.\n\n    Returns:\n        list: List of child Expr objects. Empty list for leaf nodes.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Expr.pretty","title":"<code>pretty(indent=0)</code>","text":"<p>Generate a pretty-printed string representation of the expression tree.</p> <p>Creates an indented, hierarchical view of the expression tree structure, useful for debugging and visualization.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <p>Current indentation level (default: 0)</p> <code>0</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Multi-line string representation of the expression tree</p> Example <p>Pretty print an expression:</p> <pre><code>expr = (x + y) * z\nprint(expr.pretty())\n# Mul\n#   Add\n#     State\n#     State\n#   State\n</code></pre> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def pretty(self, indent=0):\n    \"\"\"Generate a pretty-printed string representation of the expression tree.\n\n    Creates an indented, hierarchical view of the expression tree structure,\n    useful for debugging and visualization.\n\n    Args:\n        indent: Current indentation level (default: 0)\n\n    Returns:\n        str: Multi-line string representation of the expression tree\n\n    Example:\n        Pretty print an expression:\n\n            expr = (x + y) * z\n            print(expr.pretty())\n            # Mul\n            #   Add\n            #     State\n            #     State\n            #   State\n    \"\"\"\n    pad = \"  \" * indent\n    pad = \"  \" * indent\n    lines = [f\"{pad}{self.__class__.__name__}\"]\n    for child in self.children():\n        lines.append(child.pretty(indent + 1))\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Expr.structural_hash","title":"<code>structural_hash() -&gt; bytes</code>","text":"<p>Compute a structural hash of this expression.</p> <p>Returns a hash that depends only on the mathematical structure of the expression, not on variable names. Two expressions that are structurally equivalent (same operations, same variable positions) will have the same hash.</p> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>SHA-256 digest of the expression structure</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def structural_hash(self) -&gt; bytes:\n    \"\"\"Compute a structural hash of this expression.\n\n    Returns a hash that depends only on the mathematical structure of the\n    expression, not on variable names. Two expressions that are structurally\n    equivalent (same operations, same variable positions) will have the same hash.\n\n    Returns:\n        bytes: SHA-256 digest of the expression structure\n    \"\"\"\n    hasher = hashlib.sha256()\n    self._hash_into(hasher)\n    return hasher.digest()\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Leaf","title":"<code>Leaf</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Base class for leaf nodes (terminal expressions) in the symbolic expression tree.</p> <p>Leaf nodes represent named symbolic variables that don't have child expressions. This includes Parameters, Variables, States, and Controls.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the leaf node</p> <code>_shape</code> <code>tuple</code> <p>Shape of the leaf node</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class Leaf(Expr):\n    \"\"\"\n    Base class for leaf nodes (terminal expressions) in the symbolic expression tree.\n\n    Leaf nodes represent named symbolic variables that don't have child expressions.\n    This includes Parameters, Variables, States, and Controls.\n\n    Attributes:\n        name (str): Name identifier for the leaf node\n        _shape (tuple): Shape of the leaf node\n    \"\"\"\n\n    def __init__(self, name: str, shape: tuple = ()):\n        \"\"\"Initialize a Leaf node.\n\n        Args:\n            name (str): Name identifier for the leaf node\n            shape (tuple): Shape of the leaf node\n        \"\"\"\n        super().__init__()\n        self.name = name\n        self._shape = shape\n\n    @property\n    def shape(self):\n        \"\"\"Get the shape of the leaf node.\n\n        Returns:\n            tuple: Shape of the leaf node\n        \"\"\"\n        return self._shape\n\n    def children(self):\n        \"\"\"Leaf nodes have no children.\n\n        Returns:\n            list: Empty list since leaf nodes are terminal\n        \"\"\"\n        return []\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Leaf nodes are already in canonical form.\n\n        Returns:\n            Expr: Returns self since leaf nodes are already canonical\n        \"\"\"\n        return self\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Return the shape of this leaf node.\n\n        Returns:\n            tuple: The shape of the leaf node\n        \"\"\"\n        return self._shape\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash leaf node by class name and shape.\n\n        This base implementation hashes the class name and shape. Subclasses\n        like Variable and Parameter override this to add their specific\n        canonical identifiers (_slice for Variables, value for Parameters).\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(self.__class__.__name__.encode())\n        hasher.update(str(self._shape).encode())\n\n    def __repr__(self):\n        \"\"\"String representation of the leaf node.\n\n        Returns:\n            str: A string describing the leaf node\n        \"\"\"\n        return f\"{self.__class__.__name__}('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Leaf.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Get the shape of the leaf node.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Shape of the leaf node</p>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Leaf._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash leaf node by class name and shape.</p> <p>This base implementation hashes the class name and shape. Subclasses like Variable and Parameter override this to add their specific canonical identifiers (_slice for Variables, value for Parameters).</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash leaf node by class name and shape.\n\n    This base implementation hashes the class name and shape. Subclasses\n    like Variable and Parameter override this to add their specific\n    canonical identifiers (_slice for Variables, value for Parameters).\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(self.__class__.__name__.encode())\n    hasher.update(str(self._shape).encode())\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Leaf.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Leaf nodes are already in canonical form.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Returns self since leaf nodes are already canonical</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Leaf nodes are already in canonical form.\n\n    Returns:\n        Expr: Returns self since leaf nodes are already canonical\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Leaf.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Return the shape of this leaf node.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The shape of the leaf node</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Return the shape of this leaf node.\n\n    Returns:\n        tuple: The shape of the leaf node\n    \"\"\"\n    return self._shape\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Leaf.children","title":"<code>children()</code>","text":"<p>Leaf nodes have no children.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Empty list since leaf nodes are terminal</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def children(self):\n    \"\"\"Leaf nodes have no children.\n\n    Returns:\n        list: Empty list since leaf nodes are terminal\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.NodeReference","title":"<code>NodeReference</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Reference to a variable at a specific trajectory node.</p> <p>NodeReference enables inter-node constraints by allowing you to reference the value of a state or control variable at a specific discrete time point (node) in the trajectory. This is essential for expressing temporal relationships such as:</p> <ul> <li>Rate limits and smoothness constraints</li> <li>Multi-step dependencies and recurrence relations</li> <li>Constraints coupling specific nodes</li> </ul> <p>Attributes:</p> Name Type Description <code>base</code> <p>The expression (typically a Leaf like State or Control) being referenced</p> <code>node_idx</code> <p>Trajectory node index (integer, can be negative for end-indexing)</p> Example <p>Rate limit across trajectory:</p> <pre><code>position = State(\"pos\", shape=(3,))\n\n# Create rate limit constraints for all nodes\nconstraints = [\n    (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n    for k in range(1, N)\n]\n</code></pre> <p>Multi-step dependency:</p> <pre><code>state = State(\"x\", shape=(1,))\n\n# Fibonacci-like recurrence at each node\nconstraints = [\n    (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n    for k in range(2, N)\n]\n</code></pre> <p>Coupling specific nodes:</p> <pre><code># Constrain distance between nodes 5 and 10\ncoupling = (position.at(10) - position.at(5) &lt;= threshold).at([10])\n</code></pre> Performance Note <p>Cross-node constraints use dense Jacobian storage. For details on memory usage and performance implications, see LoweredCrossNodeConstraint documentation.</p> Note <p>NodeReference is typically created via the <code>.at(k)</code> method on expressions rather than constructed directly.</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class NodeReference(Expr):\n    \"\"\"Reference to a variable at a specific trajectory node.\n\n    NodeReference enables inter-node constraints by allowing you to reference\n    the value of a state or control variable at a specific discrete time point\n    (node) in the trajectory. This is essential for expressing temporal relationships\n    such as:\n\n    - Rate limits and smoothness constraints\n    - Multi-step dependencies and recurrence relations\n    - Constraints coupling specific nodes\n\n    Attributes:\n        base: The expression (typically a Leaf like State or Control) being referenced\n        node_idx: Trajectory node index (integer, can be negative for end-indexing)\n\n    Example:\n        Rate limit across trajectory:\n\n            position = State(\"pos\", shape=(3,))\n\n            # Create rate limit constraints for all nodes\n            constraints = [\n                (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n                for k in range(1, N)\n            ]\n\n        Multi-step dependency:\n\n            state = State(\"x\", shape=(1,))\n\n            # Fibonacci-like recurrence at each node\n            constraints = [\n                (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n                for k in range(2, N)\n            ]\n\n        Coupling specific nodes:\n\n            # Constrain distance between nodes 5 and 10\n            coupling = (position.at(10) - position.at(5) &lt;= threshold).at([10])\n\n    Performance Note:\n        Cross-node constraints use dense Jacobian storage. For details on memory\n        usage and performance implications, see LoweredCrossNodeConstraint documentation.\n\n    Note:\n        NodeReference is typically created via the `.at(k)` method on expressions\n        rather than constructed directly.\n    \"\"\"\n\n    def __init__(self, base: Expr, node_idx: int):\n        \"\"\"Initialize a NodeReference.\n\n        Args:\n            base: Expression to reference at a specific node (typically a Leaf)\n            node_idx: Absolute trajectory node index (integer)\n                     Supports negative indexing (e.g., -1 for last node)\n\n        Raises:\n            TypeError: If node_idx is not an integer\n        \"\"\"\n        if not isinstance(node_idx, int):\n            raise TypeError(f\"Node index must be an integer, got {type(node_idx).__name__}\")\n\n        self.node_idx = node_idx\n        self.base = base\n\n    def children(self):\n        \"\"\"Return the base expression as the only child.\n\n        Returns:\n            list: Single-element list containing the base expression\n        \"\"\"\n        return [self.base]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize by canonicalizing the base expression.\n\n        Returns:\n            NodeReference: A new NodeReference with canonicalized base\n        \"\"\"\n        canon_base = self.base.canonicalize()\n        return NodeReference(canon_base, self.node_idx)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Return the shape of the base expression.\n\n        NodeReference doesn't change the shape of the underlying expression,\n        it just references it at a specific time point.\n\n        Returns:\n            tuple: The shape of the base expression\n        \"\"\"\n        return self.base.check_shape()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash NodeReference including its node index.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"NodeReference\")\n        # Hash the node index (signed int)\n        hasher.update(struct.pack(\"&gt;i\", self.node_idx))\n        # Hash the base expression\n        self.base._hash_into(hasher)\n\n    def __repr__(self):\n        \"\"\"String representation of the NodeReference.\n\n        Returns:\n            str: String showing the base expression and node index\n        \"\"\"\n        return f\"{self.base!r}.at({self.node_idx})\"\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.NodeReference._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash NodeReference including its node index.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash NodeReference including its node index.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(b\"NodeReference\")\n    # Hash the node index (signed int)\n    hasher.update(struct.pack(\"&gt;i\", self.node_idx))\n    # Hash the base expression\n    self.base._hash_into(hasher)\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.NodeReference.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize by canonicalizing the base expression.</p> <p>Returns:</p> Name Type Description <code>NodeReference</code> <code>Expr</code> <p>A new NodeReference with canonicalized base</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize by canonicalizing the base expression.\n\n    Returns:\n        NodeReference: A new NodeReference with canonicalized base\n    \"\"\"\n    canon_base = self.base.canonicalize()\n    return NodeReference(canon_base, self.node_idx)\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.NodeReference.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Return the shape of the base expression.</p> <p>NodeReference doesn't change the shape of the underlying expression, it just references it at a specific time point.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The shape of the base expression</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Return the shape of the base expression.\n\n    NodeReference doesn't change the shape of the underlying expression,\n    it just references it at a specific time point.\n\n    Returns:\n        tuple: The shape of the base expression\n    \"\"\"\n    return self.base.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.NodeReference.children","title":"<code>children()</code>","text":"<p>Return the base expression as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the base expression</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def children(self):\n    \"\"\"Return the base expression as the only child.\n\n    Returns:\n        list: Single-element list containing the base expression\n    \"\"\"\n    return [self.base]\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Parameter","title":"<code>Parameter</code>","text":"<p>               Bases: <code>Leaf</code></p> <p>Parameter that can be changed at runtime without recompilation.</p> <p>Parameters are symbolic variables with initial values that can be updated through the problem's parameter dictionary. They allow for efficient parameter sweeps without needing to recompile the optimization problem.</p> Example <p>obs_center = ox.Parameter(\"obs_center\", shape=(3,), value=np.array([1.0, 0.0, 0.0]))</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class Parameter(Leaf):\n    \"\"\"Parameter that can be changed at runtime without recompilation.\n\n    Parameters are symbolic variables with initial values that can be updated\n    through the problem's parameter dictionary. They allow for efficient\n    parameter sweeps without needing to recompile the optimization problem.\n\n    Example:\n        obs_center = ox.Parameter(\"obs_center\", shape=(3,), value=np.array([1.0, 0.0, 0.0]))\n        # Later: problem.parameters[\"obs_center\"] = new_value\n    \"\"\"\n\n    def __init__(self, name: str, shape: tuple = (), value=None):\n        \"\"\"Initialize a Parameter node.\n\n        Args:\n            name (str): Name identifier for the parameter\n            shape (tuple): Shape of the parameter (default: scalar)\n            value: Initial value for the parameter (required)\n        \"\"\"\n        super().__init__(name, shape)\n        if value is None:\n            raise ValueError(f\"Parameter '{name}' requires an initial value\")\n        self.value = np.asarray(value, dtype=float)\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Parameter by its shape only (value-invariant).\n\n        Parameters are hashed by shape only, not by value. This allows the same\n        compiled solver to be reused across parameter sweeps - only the structure\n        matters for compilation, not the actual values.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Parameter\")\n        hasher.update(str(self._shape).encode())\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Parameter--later-problemparametersobs_center-new_value","title":"Later: problem.parameters[\"obs_center\"] = new_value","text":""},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Parameter._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash Parameter by its shape only (value-invariant).</p> <p>Parameters are hashed by shape only, not by value. This allows the same compiled solver to be reused across parameter sweeps - only the structure matters for compilation, not the actual values.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash Parameter by its shape only (value-invariant).\n\n    Parameters are hashed by shape only, not by value. This allows the same\n    compiled solver to be reused across parameter sweeps - only the structure\n    matters for compilation, not the actual values.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(b\"Parameter\")\n    hasher.update(str(self._shape).encode())\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.to_expr","title":"<code>to_expr(x: Union[Expr, float, int, np.ndarray]) -&gt; Expr</code>","text":"<p>Convert a value to an Expr if it is not already one.</p> <p>This is a convenience function that wraps numeric values and arrays as Constant expressions, while leaving Expr instances unchanged. Used internally by operators to ensure operands are proper Expr objects.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[Expr, float, int, ndarray]</code> <p>Value to convert - can be an Expr, numeric scalar, or numpy array</p> required <p>Returns:</p> Type Description <code>Expr</code> <p>The input if it's already an Expr, otherwise a Constant wrapping the value</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def to_expr(x: Union[Expr, float, int, np.ndarray]) -&gt; Expr:\n    \"\"\"Convert a value to an Expr if it is not already one.\n\n    This is a convenience function that wraps numeric values and arrays as Constant\n    expressions, while leaving Expr instances unchanged. Used internally by operators\n    to ensure operands are proper Expr objects.\n\n    Args:\n        x: Value to convert - can be an Expr, numeric scalar, or numpy array\n\n    Returns:\n        The input if it's already an Expr, otherwise a Constant wrapping the value\n    \"\"\"\n    return x if isinstance(x, Expr) else Constant(np.array(x))\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.traverse","title":"<code>traverse(expr: Expr, visit: Callable[[Expr], None])</code>","text":"<p>Depth-first traversal of an expression tree.</p> <p>Visits each node in the expression tree by applying the visit function to the current node, then recursively visiting all children.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Root expression node to start traversal from</p> required <code>visit</code> <code>Callable[[Expr], None]</code> <p>Callback function applied to each node during traversal</p> required Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def traverse(expr: Expr, visit: Callable[[Expr], None]):\n    \"\"\"Depth-first traversal of an expression tree.\n\n    Visits each node in the expression tree by applying the visit function to the\n    current node, then recursively visiting all children.\n\n    Args:\n        expr: Root expression node to start traversal from\n        visit: Callback function applied to each node during traversal\n    \"\"\"\n    visit(expr)\n    for child in expr.children():\n        traverse(child, visit)\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/","title":"linalg","text":"<p>Linear algebra operations for symbolic expressions.</p> <p>This module provides essential linear algebra operations for matrix and vector manipulation in optimization problems. Operations follow NumPy/JAX conventions for shapes and broadcasting behavior.</p> Key Operations <ul> <li>Matrix Operations:<ul> <li><code>Transpose</code> - Matrix/tensor transposition (swaps last two dimensions)</li> <li><code>Diag</code> - Construct diagonal matrix from vector</li> </ul> </li> <li>Reductions:<ul> <li><code>Sum</code> - Sum all elements of an array (reduces to scalar)</li> <li><code>Norm</code> - Euclidean (L2) norm and other norms of vectors/matrices</li> </ul> </li> </ul> Note <p>For array manipulation operations like stacking and concatenation, see the <code>array</code> module.</p> Example <p>Matrix transposition and diagonal matrices::</p> <pre><code>import openscvx as ox\nimport numpy as np\n\n# Transpose a matrix\nA = ox.State(\"A\", shape=(3, 4))\nA_T = A.T  # Result shape (4, 3)\n\n# Create a diagonal matrix\nv = ox.State(\"v\", shape=(5,))\nD = ox.Diag(v)  # Result shape (5, 5)\n</code></pre> <p>Reduction operations::</p> <pre><code>x = ox.State(\"x\", shape=(3, 4))\n\n# Sum all elements\ntotal = ox.Sum(x)  # Result is scalar\n\n# Compute norm\nmagnitude = ox.Norm(x)  # Result is scalar\n</code></pre> <p>Computing kinetic energy with norms::</p> <pre><code>v = ox.State(\"v\", shape=(3,))  # Velocity vector\nm = 10.0  # Mass\nkinetic_energy = 0.5 * m * ox.Norm(v)**2\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Diag","title":"<code>Diag</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Diagonal matrix construction from a vector.</p> <p>Creates a square diagonal matrix from a 1D vector. The vector elements become the diagonal entries, with all off-diagonal entries set to zero. This is analogous to numpy.diag() or jax.numpy.diag().</p> Note <p>Currently only supports creating diagonal matrices from vectors. Extracting diagonals from matrices is not yet implemented.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>1D vector expression to place on the diagonal</p> Example <p>Define a Diag:</p> <pre><code>v = Variable(\"v\", shape=(3,))\nD = Diag(v)  # Creates a (3, 3) diagonal matrix\n</code></pre> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>class Diag(Expr):\n    \"\"\"Diagonal matrix construction from a vector.\n\n    Creates a square diagonal matrix from a 1D vector. The vector elements become\n    the diagonal entries, with all off-diagonal entries set to zero. This is\n    analogous to numpy.diag() or jax.numpy.diag().\n\n    Note:\n        Currently only supports creating diagonal matrices from vectors.\n        Extracting diagonals from matrices is not yet implemented.\n\n    Attributes:\n        operand: 1D vector expression to place on the diagonal\n\n    Example:\n        Define a Diag:\n\n            v = Variable(\"v\", shape=(3,))\n            D = Diag(v)  # Creates a (3, 3) diagonal matrix\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a diagonal matrix operation.\n\n        Args:\n            operand: 1D vector expression to place on the diagonal\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Diag(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Diag converts a vector (n,) to a diagonal matrix (n,n).\"\"\"\n        operand_shape = self.operand.check_shape()\n        if len(operand_shape) != 1:\n            raise ValueError(f\"Diag expects a 1D vector, got shape {operand_shape}\")\n        n = operand_shape[0]\n        return (n, n)\n\n    def __repr__(self):\n        return f\"diag({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Diag.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Diag converts a vector (n,) to a diagonal matrix (n,n).</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Diag converts a vector (n,) to a diagonal matrix (n,n).\"\"\"\n    operand_shape = self.operand.check_shape()\n    if len(operand_shape) != 1:\n        raise ValueError(f\"Diag expects a 1D vector, got shape {operand_shape}\")\n    n = operand_shape[0]\n    return (n, n)\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Norm","title":"<code>Norm</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Norm operation for symbolic expressions (reduction to scalar).</p> <p>Computes the norm of an expression according to the specified order parameter. This is a reduction operation that always produces a scalar result regardless of the input shape. Supports various norm types following NumPy/SciPy conventions.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to compute norm of</p> <code>ord</code> <p>Norm order specification (default: \"fro\" for Frobenius norm) - \"fro\": Frobenius norm (default) - \"inf\": Infinity norm - 1: L1 norm (sum of absolute values) - 2: L2 norm (Euclidean norm) - Other values as supported by the backend</p> Example <p>Define Norms:</p> <pre><code>x = Variable(\"x\", shape=(3,))\neuclidean_norm = Norm(x, ord=2)  # L2 norm, result is scalar\nA = Variable(\"A\", shape=(3, 4))\nfrobenius_norm = Norm(A)  # Frobenius norm, result is scalar\n</code></pre> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>class Norm(Expr):\n    \"\"\"Norm operation for symbolic expressions (reduction to scalar).\n\n    Computes the norm of an expression according to the specified order parameter.\n    This is a reduction operation that always produces a scalar result regardless\n    of the input shape. Supports various norm types following NumPy/SciPy conventions.\n\n    Attributes:\n        operand: Expression to compute norm of\n        ord: Norm order specification (default: \"fro\" for Frobenius norm)\n            - \"fro\": Frobenius norm (default)\n            - \"inf\": Infinity norm\n            - 1: L1 norm (sum of absolute values)\n            - 2: L2 norm (Euclidean norm)\n            - Other values as supported by the backend\n\n    Example:\n        Define Norms:\n\n            x = Variable(\"x\", shape=(3,))\n            euclidean_norm = Norm(x, ord=2)  # L2 norm, result is scalar\n            A = Variable(\"A\", shape=(3, 4))\n            frobenius_norm = Norm(A)  # Frobenius norm, result is scalar\n    \"\"\"\n\n    def __init__(self, operand, ord=\"fro\"):\n        \"\"\"Initialize a norm operation.\n\n        Args:\n            operand: Expression to compute norm of\n            ord: Norm order specification (default: \"fro\")\n        \"\"\"\n        self.operand = to_expr(operand)\n        self.ord = ord  # Can be \"fro\", \"inf\", 1, 2, etc.\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the operand but preserve the ord parameter.\"\"\"\n        canon_operand = self.operand.canonicalize()\n        return Norm(canon_operand, ord=self.ord)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Norm reduces any shape to a scalar.\"\"\"\n        # Validate that the operand has a valid shape\n        self.operand.check_shape()\n        # Norm always produces a scalar regardless of input shape\n        return ()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Norm including its ord parameter.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Norm\")\n        # Hash the ord parameter\n        hasher.update(repr(self.ord).encode())\n        # Hash the operand\n        self.operand._hash_into(hasher)\n\n    def __repr__(self):\n        return f\"norm({self.operand!r}, ord={self.ord!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Norm._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash Norm including its ord parameter.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash Norm including its ord parameter.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(b\"Norm\")\n    # Hash the ord parameter\n    hasher.update(repr(self.ord).encode())\n    # Hash the operand\n    self.operand._hash_into(hasher)\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Norm.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the operand but preserve the ord parameter.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the operand but preserve the ord parameter.\"\"\"\n    canon_operand = self.operand.canonicalize()\n    return Norm(canon_operand, ord=self.ord)\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Norm.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Norm reduces any shape to a scalar.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Norm reduces any shape to a scalar.\"\"\"\n    # Validate that the operand has a valid shape\n    self.operand.check_shape()\n    # Norm always produces a scalar regardless of input shape\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Sum","title":"<code>Sum</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Sum reduction operation for symbolic expressions.</p> <p>Sums all elements of an expression, reducing it to a scalar. This is a reduction operation that collapses all dimensions.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression whose elements will be summed</p> Example <p>Define a Sum expression::</p> <pre><code>x = ox.State(\"x\", shape=(3, 4))\ntotal = Sum(x)  # Creates Sum(x), result shape ()\n</code></pre> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>class Sum(Expr):\n    \"\"\"Sum reduction operation for symbolic expressions.\n\n    Sums all elements of an expression, reducing it to a scalar. This is a\n    reduction operation that collapses all dimensions.\n\n    Attributes:\n        operand: Expression whose elements will be summed\n\n    Example:\n        Define a Sum expression::\n\n            x = ox.State(\"x\", shape=(3, 4))\n            total = Sum(x)  # Creates Sum(x), result shape ()\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a sum reduction operation.\n\n        Args:\n            operand: Expression to sum over all elements\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize sum: canonicalize the operand.\n\n        Returns:\n            Expr: Canonical form of the sum expression\n        \"\"\"\n        operand = self.operand.canonicalize()\n        return Sum(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Sum reduces any shape to a scalar.\"\"\"\n        # Validate that the operand has a valid shape\n        self.operand.check_shape()\n        # Sum always produces a scalar regardless of input shape\n        return ()\n\n    def __repr__(self):\n        return f\"sum({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Sum.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize sum: canonicalize the operand.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the sum expression</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize sum: canonicalize the operand.\n\n    Returns:\n        Expr: Canonical form of the sum expression\n    \"\"\"\n    operand = self.operand.canonicalize()\n    return Sum(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Sum.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Sum reduces any shape to a scalar.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Sum reduces any shape to a scalar.\"\"\"\n    # Validate that the operand has a valid shape\n    self.operand.check_shape()\n    # Sum always produces a scalar regardless of input shape\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Transpose","title":"<code>Transpose</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Matrix transpose operation for symbolic expressions.</p> <p>Transposes the last two dimensions of an expression. For matrices, this swaps rows and columns. For higher-dimensional arrays, it swaps the last two axes. Scalars and vectors are unchanged by transposition.</p> <p>The canonicalization includes an optimization that eliminates double transposes: (A.T).T simplifies to A.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to transpose</p> Example <p>Define Tranpose expressions:</p> <pre><code>A = Variable(\"A\", shape=(3, 4))\nA_T = Transpose(A)  # or A.T, result shape (4, 3)\nv = Variable(\"v\", shape=(5,))\nv_T = Transpose(v)  # result shape (5,) - vectors unchanged\n</code></pre> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>class Transpose(Expr):\n    \"\"\"Matrix transpose operation for symbolic expressions.\n\n    Transposes the last two dimensions of an expression. For matrices, this swaps\n    rows and columns. For higher-dimensional arrays, it swaps the last two axes.\n    Scalars and vectors are unchanged by transposition.\n\n    The canonicalization includes an optimization that eliminates double transposes:\n    (A.T).T simplifies to A.\n\n    Attributes:\n        operand: Expression to transpose\n\n    Example:\n        Define Tranpose expressions:\n\n            A = Variable(\"A\", shape=(3, 4))\n            A_T = Transpose(A)  # or A.T, result shape (4, 3)\n            v = Variable(\"v\", shape=(5,))\n            v_T = Transpose(v)  # result shape (5,) - vectors unchanged\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a transpose operation.\n\n        Args:\n            operand: Expression to transpose\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the operand with double transpose optimization.\"\"\"\n        operand = self.operand.canonicalize()\n\n        # Double transpose optimization: (A.T).T = A\n        if isinstance(operand, Transpose):\n            return operand.operand\n\n        return Transpose(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Matrix transpose operation swaps the last two dimensions.\"\"\"\n        operand_shape = self.operand.check_shape()\n\n        if len(operand_shape) == 0:\n            # Scalar transpose is the scalar itself\n            return ()\n        elif len(operand_shape) == 1:\n            # Vector transpose is the vector itself (row vector remains row vector)\n            return operand_shape\n        elif len(operand_shape) == 2:\n            # Matrix transpose: (m,n) -&gt; (n,m)\n            return (operand_shape[1], operand_shape[0])\n        else:\n            # Higher-dimensional array: transpose last two dimensions\n            # (..., m, n) -&gt; (..., n, m)\n            return operand_shape[:-2] + (operand_shape[-1], operand_shape[-2])\n\n    def __repr__(self):\n        return f\"({self.operand!r}).T\"\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Transpose.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the operand with double transpose optimization.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the operand with double transpose optimization.\"\"\"\n    operand = self.operand.canonicalize()\n\n    # Double transpose optimization: (A.T).T = A\n    if isinstance(operand, Transpose):\n        return operand.operand\n\n    return Transpose(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Transpose.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Matrix transpose operation swaps the last two dimensions.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Matrix transpose operation swaps the last two dimensions.\"\"\"\n    operand_shape = self.operand.check_shape()\n\n    if len(operand_shape) == 0:\n        # Scalar transpose is the scalar itself\n        return ()\n    elif len(operand_shape) == 1:\n        # Vector transpose is the vector itself (row vector remains row vector)\n        return operand_shape\n    elif len(operand_shape) == 2:\n        # Matrix transpose: (m,n) -&gt; (n,m)\n        return (operand_shape[1], operand_shape[0])\n    else:\n        # Higher-dimensional array: transpose last two dimensions\n        # (..., m, n) -&gt; (..., n, m)\n        return operand_shape[:-2] + (operand_shape[-1], operand_shape[-2])\n</code></pre>"},{"location":"reference/symbolic/expr/math/","title":"math","text":"<p>Mathematical functions for symbolic expressions.</p> <p>This module provides common mathematical operations used in optimization problems, including trigonometric functions, exponential functions, and smooth approximations of non-differentiable operations. All functions are element-wise and preserve the shape of their inputs.</p> Function Categories <ul> <li>Trigonometric: <code>Sin</code>, <code>Cos</code>, <code>Tan</code> - Standard trigonometric functions</li> <li>Exponential and Roots: <code>Exp</code>, <code>Log</code>, <code>Sqrt</code>, <code>Square</code> - Exponential, logarithm, square     root, and squaring operations</li> <li>Absolute Value: <code>Abs</code> - Element-wise absolute value function</li> <li>Smooth Approximations: <code>PositivePart</code>, <code>Huber</code>, <code>SmoothReLU</code> - Smooth, differentiable     approximations of non-smooth functions like max(0, x) and absolute value</li> <li>Reductions: <code>Max</code> - Maximum over elements</li> <li>Smooth Maximum: <code>LogSumExp</code> - Log-sum-exp function, a smooth approximation to maximum</li> </ul> Example <p>Using trigonometric functions in dynamics::</p> <pre><code>import openscvx as ox\n\n# Pendulum dynamics: theta_ddot = -g/L * sin(theta)\ntheta = ox.State(\"theta\", shape=(1,))\ntheta_dot = ox.State(\"theta_dot\", shape=(1,))\ng, L = 9.81, 1.0\n\ntheta_ddot = -(g / L) * ox.Sin(theta)\n</code></pre> <p>Smooth penalty functions for constraints::</p> <pre><code># Soft constraint using smooth ReLU\nx = ox.Variable(\"x\", shape=(3,))\npenalty = ox.SmoothReLU(ox.Norm(x) - 1.0)  # Penalize norm &gt; 1\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Abs","title":"<code>Abs</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise absolute value function for symbolic expressions.</p> <p>Computes the absolute value (|x|) of each element in the operand. Preserves the shape of the input expression. The absolute value function is convex and DCP-compliant in CVXPy.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply absolute value to</p> Example <p>Define an Abs expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\nabs_x = Abs(x)  # Element-wise |x|\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Abs(Expr):\n    \"\"\"Element-wise absolute value function for symbolic expressions.\n\n    Computes the absolute value (|x|) of each element in the operand. Preserves\n    the shape of the input expression. The absolute value function is convex\n    and DCP-compliant in CVXPy.\n\n    Attributes:\n        operand: Expression to apply absolute value to\n\n    Example:\n        Define an Abs expression:\n\n            x = Variable(\"x\", shape=(3,))\n            abs_x = Abs(x)  # Element-wise |x|\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize an absolute value operation.\n\n        Args:\n            operand: Expression to apply absolute value to\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Abs(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Abs preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"abs({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Abs.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Abs preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Abs preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Cos","title":"<code>Cos</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise cosine function for symbolic expressions.</p> <p>Computes the cosine of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply cosine function to</p> Example <p>Define a Cos expression:</p> <pre><code>theta = Variable(\"theta\", shape=(3,))\ncos_theta = Cos(theta)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Cos(Expr):\n    \"\"\"Element-wise cosine function for symbolic expressions.\n\n    Computes the cosine of each element in the operand. Preserves the shape\n    of the input expression.\n\n    Attributes:\n        operand: Expression to apply cosine function to\n\n    Example:\n        Define a Cos expression:\n\n            theta = Variable(\"theta\", shape=(3,))\n            cos_theta = Cos(theta)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a cosine operation.\n\n        Args:\n            operand: Expression to apply cosine function to\n        \"\"\"\n        self.operand = operand\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Cos(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Cos preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"(cos({self.operand!r}))\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Cos.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Cos preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Cos preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Exp","title":"<code>Exp</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise exponential function for symbolic expressions.</p> <p>Computes e^x for each element in the operand, where e is Euler's number. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply exponential function to</p> Example <p>Define an Exp expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\nexp_x = Exp(x)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Exp(Expr):\n    \"\"\"Element-wise exponential function for symbolic expressions.\n\n    Computes e^x for each element in the operand, where e is Euler's number.\n    Preserves the shape of the input expression.\n\n    Attributes:\n        operand: Expression to apply exponential function to\n\n    Example:\n        Define an Exp expression:\n\n            x = Variable(\"x\", shape=(3,))\n            exp_x = Exp(x)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize an exponential operation.\n\n        Args:\n            operand: Expression to apply exponential function to\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Exp(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Exp preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"exp({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Exp.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Exp preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Exp preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Huber","title":"<code>Huber</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Huber penalty function for symbolic expressions.</p> <p>The Huber penalty is a smooth approximation to the absolute value function that is quadratic for small values (|x| &lt; delta) and linear for large values (|x| &gt;= delta). This makes it more robust to outliers than squared penalties while maintaining smoothness.</p> <p>The Huber function is defined as: - (x^2) / (2*delta)           for |x| &lt;= delta - |x| - delta/2               for |x| &gt; delta</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Expression to apply Huber penalty to</p> <code>delta</code> <p>Threshold parameter controlling the transition point (default: 0.25)</p> Example <p>Define a Huber penalty expression:</p> <pre><code>residual = y_measured - y_predicted\npenalty = Huber(residual, delta=0.5)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Huber(Expr):\n    \"\"\"Huber penalty function for symbolic expressions.\n\n    The Huber penalty is a smooth approximation to the absolute value function\n    that is quadratic for small values (|x| &lt; delta) and linear for large values\n    (|x| &gt;= delta). This makes it more robust to outliers than squared penalties\n    while maintaining smoothness.\n\n    The Huber function is defined as:\n    - (x^2) / (2*delta)           for |x| &lt;= delta\n    - |x| - delta/2               for |x| &gt; delta\n\n    Attributes:\n        x: Expression to apply Huber penalty to\n        delta: Threshold parameter controlling the transition point (default: 0.25)\n\n    Example:\n        Define a Huber penalty expression:\n\n            residual = y_measured - y_predicted\n            penalty = Huber(residual, delta=0.5)\n    \"\"\"\n\n    def __init__(self, x, delta: float = 0.25):\n        \"\"\"Initialize a Huber penalty operation.\n\n        Args:\n            x: Expression to apply Huber penalty to\n            delta: Threshold parameter for quadratic-to-linear transition (default: 0.25)\n        \"\"\"\n        self.x = to_expr(x)\n        self.delta = float(delta)\n\n    def children(self):\n        return [self.x]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the operand but preserve delta parameter.\"\"\"\n        x = self.x.canonicalize()\n        return Huber(x, delta=self.delta)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Huber penalty preserves the shape of x.\"\"\"\n        return self.x.check_shape()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Huber including its delta parameter.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Huber\")\n        # Hash delta as bytes\n        hasher.update(struct.pack(\"&gt;d\", self.delta))\n        # Hash the operand\n        self.x._hash_into(hasher)\n\n    def __repr__(self):\n        return f\"huber({self.x!r}, delta={self.delta})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Huber._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash Huber including its delta parameter.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash Huber including its delta parameter.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(b\"Huber\")\n    # Hash delta as bytes\n    hasher.update(struct.pack(\"&gt;d\", self.delta))\n    # Hash the operand\n    self.x._hash_into(hasher)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Huber.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the operand but preserve delta parameter.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the operand but preserve delta parameter.\"\"\"\n    x = self.x.canonicalize()\n    return Huber(x, delta=self.delta)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Huber.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Huber penalty preserves the shape of x.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Huber penalty preserves the shape of x.\"\"\"\n    return self.x.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Log","title":"<code>Log</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise natural logarithm function for symbolic expressions.</p> <p>Computes the natural logarithm (base e) of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply logarithm to</p> Example <p>Define a Log expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\nlog_x = Log(x)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Log(Expr):\n    \"\"\"Element-wise natural logarithm function for symbolic expressions.\n\n    Computes the natural logarithm (base e) of each element in the operand.\n    Preserves the shape of the input expression.\n\n    Attributes:\n        operand: Expression to apply logarithm to\n\n    Example:\n        Define a Log expression:\n\n            x = Variable(\"x\", shape=(3,))\n            log_x = Log(x)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a natural logarithm operation.\n\n        Args:\n            operand: Expression to apply logarithm to\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Log(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Log preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"log({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Log.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Log preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Log preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.LogSumExp","title":"<code>LogSumExp</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Log-sum-exp function for symbolic expressions.</p> <p>Computes the log-sum-exp (LSE) of multiple operands, which is a smooth, differentiable approximation to the maximum function. The log-sum-exp is defined as:</p> <pre><code>logsumexp(x\u2081, x\u2082, ..., x\u2099) = log(exp(x\u2081) + exp(x\u2082) + ... + exp(x\u2099))\n</code></pre> <p>This function is numerically stable and is commonly used in optimization as a smooth alternative to the non-differentiable maximum function. It satisfies the inequality:</p> <pre><code>max(x\u2081, x\u2082, ..., x\u2099) \u2264 logsumexp(x\u2081, x\u2082, ..., x\u2099) \u2264 max(x\u2081, x\u2082, ..., x\u2099) + log(n)\n</code></pre> <p>The log-sum-exp is convex and is particularly useful for: - Smooth approximations of maximum constraints - Soft maximum operations in neural networks - Relaxing logical OR operations in STL specifications</p> <p>Attributes:</p> Name Type Description <code>operands</code> <p>List of expressions to compute log-sum-exp over</p> Example <p>Define a LogSumExp expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(3,))\nz = Variable(\"z\", shape=(3,))\nlse = LogSumExp(x, y, z)  # Smooth approximation to max(x, y, z)\n</code></pre> <p>Use in STL relaxation:</p> <pre><code>import openscvx as ox\n# Relax: Or(\u03c6\u2081, \u03c6\u2082) using log-sum-exp\nphi1 = ox.Norm(x - goal1) - 0.5\nphi2 = ox.Norm(x - goal2) - 0.5\nrelaxed_or = LogSumExp(phi1, phi2) &gt;= 0\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class LogSumExp(Expr):\n    \"\"\"Log-sum-exp function for symbolic expressions.\n\n    Computes the log-sum-exp (LSE) of multiple operands, which is a smooth,\n    differentiable approximation to the maximum function. The log-sum-exp is\n    defined as:\n\n        logsumexp(x\u2081, x\u2082, ..., x\u2099) = log(exp(x\u2081) + exp(x\u2082) + ... + exp(x\u2099))\n\n    This function is numerically stable and is commonly used in optimization\n    as a smooth alternative to the non-differentiable maximum function. It\n    satisfies the inequality:\n\n        max(x\u2081, x\u2082, ..., x\u2099) \u2264 logsumexp(x\u2081, x\u2082, ..., x\u2099) \u2264 max(x\u2081, x\u2082, ..., x\u2099) + log(n)\n\n    The log-sum-exp is convex and is particularly useful for:\n    - Smooth approximations of maximum constraints\n    - Soft maximum operations in neural networks\n    - Relaxing logical OR operations in STL specifications\n\n    Attributes:\n        operands: List of expressions to compute log-sum-exp over\n\n    Example:\n        Define a LogSumExp expression:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(3,))\n            z = Variable(\"z\", shape=(3,))\n            lse = LogSumExp(x, y, z)  # Smooth approximation to max(x, y, z)\n\n        Use in STL relaxation:\n\n            import openscvx as ox\n            # Relax: Or(\u03c6\u2081, \u03c6\u2082) using log-sum-exp\n            phi1 = ox.Norm(x - goal1) - 0.5\n            phi2 = ox.Norm(x - goal2) - 0.5\n            relaxed_or = LogSumExp(phi1, phi2) &gt;= 0\n    \"\"\"\n\n    def __init__(self, *args):\n        \"\"\"Initialize a log-sum-exp operation.\n\n        Args:\n            *args: Two or more expressions to compute log-sum-exp over\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(args) &lt; 2:\n            raise ValueError(\"LogSumExp requires two or more operands\")\n        self.operands = [to_expr(a) for a in args]\n\n    def children(self):\n        return list(self.operands)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize log-sum-exp: flatten nested LogSumExp, fold constants.\"\"\"\n        from .expr import Constant\n\n        operands = []\n        const_vals = []\n\n        for op in self.operands:\n            c = op.canonicalize()\n            if isinstance(c, LogSumExp):\n                operands.extend(c.operands)\n            elif isinstance(c, Constant):\n                const_vals.append(c.value)\n            else:\n                operands.append(c)\n\n        # If we have constants, compute their log-sum-exp and keep it\n        if const_vals:\n            # For constants, we can compute logsumexp directly\n            # logsumexp(c1, c2, ..., cn) = log(sum(exp(ci)))\n            exp_vals = [np.exp(v) for v in const_vals]\n            lse_const = np.log(np.sum(exp_vals))\n            operands.append(Constant(lse_const))\n\n        if not operands:\n            raise ValueError(\"LogSumExp must have at least one operand after canonicalization\")\n        if len(operands) == 1:\n            return operands[0]\n        return LogSumExp(*operands)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"LogSumExp broadcasts shapes like NumPy, preserving element-wise shape.\"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"LogSumExp shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        inner = \", \".join(repr(op) for op in self.operands)\n        return f\"logsumexp({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.LogSumExp.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize log-sum-exp: flatten nested LogSumExp, fold constants.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize log-sum-exp: flatten nested LogSumExp, fold constants.\"\"\"\n    from .expr import Constant\n\n    operands = []\n    const_vals = []\n\n    for op in self.operands:\n        c = op.canonicalize()\n        if isinstance(c, LogSumExp):\n            operands.extend(c.operands)\n        elif isinstance(c, Constant):\n            const_vals.append(c.value)\n        else:\n            operands.append(c)\n\n    # If we have constants, compute their log-sum-exp and keep it\n    if const_vals:\n        # For constants, we can compute logsumexp directly\n        # logsumexp(c1, c2, ..., cn) = log(sum(exp(ci)))\n        exp_vals = [np.exp(v) for v in const_vals]\n        lse_const = np.log(np.sum(exp_vals))\n        operands.append(Constant(lse_const))\n\n    if not operands:\n        raise ValueError(\"LogSumExp must have at least one operand after canonicalization\")\n    if len(operands) == 1:\n        return operands[0]\n    return LogSumExp(*operands)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.LogSumExp.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>LogSumExp broadcasts shapes like NumPy, preserving element-wise shape.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"LogSumExp broadcasts shapes like NumPy, preserving element-wise shape.\"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"LogSumExp shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Max","title":"<code>Max</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise maximum function for symbolic expressions.</p> <p>Computes the element-wise maximum across two or more operands. Supports broadcasting following NumPy rules. During canonicalization, nested Max operations are flattened and constants are folded.</p> <p>Attributes:</p> Name Type Description <code>operands</code> <p>List of expressions to compute maximum over</p> Example <p>Define a Max expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(3,))\nmax_xy = Max(x, y, 0)  # Element-wise max(x, y, 0)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Max(Expr):\n    \"\"\"Element-wise maximum function for symbolic expressions.\n\n    Computes the element-wise maximum across two or more operands. Supports\n    broadcasting following NumPy rules. During canonicalization, nested Max\n    operations are flattened and constants are folded.\n\n    Attributes:\n        operands: List of expressions to compute maximum over\n\n    Example:\n        Define a Max expression:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(3,))\n            max_xy = Max(x, y, 0)  # Element-wise max(x, y, 0)\n    \"\"\"\n\n    def __init__(self, *args):\n        \"\"\"Initialize a maximum operation.\n\n        Args:\n            *args: Two or more expressions to compute maximum over\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(args) &lt; 2:\n            raise ValueError(\"Max requires two or more operands\")\n        self.operands = [to_expr(a) for a in args]\n\n    def children(self):\n        return list(self.operands)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize max: flatten nested Max, fold constants.\"\"\"\n        from .expr import Constant\n\n        operands = []\n        const_vals = []\n\n        for op in self.operands:\n            c = op.canonicalize()\n            if isinstance(c, Max):\n                operands.extend(c.operands)\n            elif isinstance(c, Constant):\n                const_vals.append(c.value)\n            else:\n                operands.append(c)\n\n        # If we have constants, compute their max and keep it\n        if const_vals:\n            max_const = np.maximum.reduce(const_vals)\n            operands.append(Constant(max_const))\n\n        if not operands:\n            raise ValueError(\"Max must have at least one operand after canonicalization\")\n        if len(operands) == 1:\n            return operands[0]\n        return Max(*operands)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Max broadcasts shapes like NumPy.\"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Max shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        inner = \", \".join(repr(op) for op in self.operands)\n        return f\"max({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Max.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize max: flatten nested Max, fold constants.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize max: flatten nested Max, fold constants.\"\"\"\n    from .expr import Constant\n\n    operands = []\n    const_vals = []\n\n    for op in self.operands:\n        c = op.canonicalize()\n        if isinstance(c, Max):\n            operands.extend(c.operands)\n        elif isinstance(c, Constant):\n            const_vals.append(c.value)\n        else:\n            operands.append(c)\n\n    # If we have constants, compute their max and keep it\n    if const_vals:\n        max_const = np.maximum.reduce(const_vals)\n        operands.append(Constant(max_const))\n\n    if not operands:\n        raise ValueError(\"Max must have at least one operand after canonicalization\")\n    if len(operands) == 1:\n        return operands[0]\n    return Max(*operands)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Max.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Max broadcasts shapes like NumPy.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Max broadcasts shapes like NumPy.\"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Max shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.PositivePart","title":"<code>PositivePart</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Positive part function for symbolic expressions.</p> <p>Computes max(x, 0) element-wise, effectively zeroing out negative values while preserving positive values. This is also known as the ReLU (Rectified Linear Unit) function and is commonly used as a penalty function building block in optimization.</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Expression to apply positive part function to</p> Example <p>Define a PositivePart expression:</p> <pre><code>constraint_violation = x - 10\npenalty = PositivePart(constraint_violation)  # Penalizes x &gt; 10\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class PositivePart(Expr):\n    \"\"\"Positive part function for symbolic expressions.\n\n    Computes max(x, 0) element-wise, effectively zeroing out negative values\n    while preserving positive values. This is also known as the ReLU (Rectified\n    Linear Unit) function and is commonly used as a penalty function building\n    block in optimization.\n\n    Attributes:\n        x: Expression to apply positive part function to\n\n    Example:\n        Define a PositivePart expression:\n\n            constraint_violation = x - 10\n            penalty = PositivePart(constraint_violation)  # Penalizes x &gt; 10\n    \"\"\"\n\n    def __init__(self, x):\n        \"\"\"Initialize a positive part operation.\n\n        Args:\n            x: Expression to apply positive part function to\n        \"\"\"\n        self.x = to_expr(x)\n\n    def children(self):\n        return [self.x]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        x = self.x.canonicalize()\n        return PositivePart(x)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"pos(x) = max(x, 0) preserves the shape of x.\"\"\"\n        return self.x.check_shape()\n\n    def __repr__(self):\n        return f\"pos({self.x!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.PositivePart.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>pos(x) = max(x, 0) preserves the shape of x.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"pos(x) = max(x, 0) preserves the shape of x.\"\"\"\n    return self.x.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Sin","title":"<code>Sin</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise sine function for symbolic expressions.</p> <p>Computes the sine of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply sine function to</p> Example <p>Define a Sin expression:</p> <pre><code>theta = Variable(\"theta\", shape=(3,))\nsin_theta = Sin(theta)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Sin(Expr):\n    \"\"\"Element-wise sine function for symbolic expressions.\n\n    Computes the sine of each element in the operand. Preserves the shape\n    of the input expression.\n\n    Attributes:\n        operand: Expression to apply sine function to\n\n    Example:\n        Define a Sin expression:\n\n            theta = Variable(\"theta\", shape=(3,))\n            sin_theta = Sin(theta)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a sine operation.\n\n        Args:\n            operand: Expression to apply sine function to\n        \"\"\"\n        self.operand = operand\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Sin(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Sin preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"(sin({self.operand!r}))\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Sin.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Sin preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Sin preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.SmoothReLU","title":"<code>SmoothReLU</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Smooth approximation to the ReLU (positive part) function.</p> <p>Computes a smooth, differentiable approximation to max(x, 0) using the formula: sqrt(max(x, 0)^2 + c^2) - c</p> <p>The parameter c controls the smoothness: smaller values give a sharper transition, while larger values produce a smoother approximation. As c approaches 0, this converges to the standard ReLU function.</p> <p>This is particularly useful in optimization contexts where smooth gradients are required, such as in penalty methods for constraint handling (CTCS).</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Expression to apply smooth ReLU to</p> <code>c</code> <p>Smoothing parameter (default: 1e-8)</p> Example <p>Define a smooth ReLU expression:</p> <pre><code>constraint_violation = x - 10\npenalty = SmoothReLU(constraint_violation, c=1e-6)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class SmoothReLU(Expr):\n    \"\"\"Smooth approximation to the ReLU (positive part) function.\n\n    Computes a smooth, differentiable approximation to max(x, 0) using the formula:\n    sqrt(max(x, 0)^2 + c^2) - c\n\n    The parameter c controls the smoothness: smaller values give a sharper\n    transition, while larger values produce a smoother approximation. As c\n    approaches 0, this converges to the standard ReLU function.\n\n    This is particularly useful in optimization contexts where smooth gradients\n    are required, such as in penalty methods for constraint handling (CTCS).\n\n    Attributes:\n        x: Expression to apply smooth ReLU to\n        c: Smoothing parameter (default: 1e-8)\n\n    Example:\n        Define a smooth ReLU expression:\n\n            constraint_violation = x - 10\n            penalty = SmoothReLU(constraint_violation, c=1e-6)\n    \"\"\"\n\n    def __init__(self, x, c: float = 1e-8):\n        \"\"\"Initialize a smooth ReLU operation.\n\n        Args:\n            x: Expression to apply smooth ReLU to\n            c: Smoothing parameter controlling transition sharpness (default: 1e-8)\n        \"\"\"\n        self.x = to_expr(x)\n        self.c = float(c)\n\n    def children(self):\n        return [self.x]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the operand but preserve c parameter.\"\"\"\n        x = self.x.canonicalize()\n        return SmoothReLU(x, c=self.c)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Smooth ReLU preserves the shape of x.\"\"\"\n        return self.x.check_shape()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash SmoothReLU including its c parameter.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"SmoothReLU\")\n        # Hash c as bytes\n        hasher.update(struct.pack(\"&gt;d\", self.c))\n        # Hash the operand\n        self.x._hash_into(hasher)\n\n    def __repr__(self):\n        return f\"smooth_relu({self.x!r}, c={self.c})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.SmoothReLU._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash SmoothReLU including its c parameter.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash SmoothReLU including its c parameter.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(b\"SmoothReLU\")\n    # Hash c as bytes\n    hasher.update(struct.pack(\"&gt;d\", self.c))\n    # Hash the operand\n    self.x._hash_into(hasher)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.SmoothReLU.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the operand but preserve c parameter.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the operand but preserve c parameter.\"\"\"\n    x = self.x.canonicalize()\n    return SmoothReLU(x, c=self.c)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.SmoothReLU.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Smooth ReLU preserves the shape of x.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Smooth ReLU preserves the shape of x.\"\"\"\n    return self.x.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Sqrt","title":"<code>Sqrt</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise square root function for symbolic expressions.</p> <p>Computes the square root of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply square root to</p> Example <p>Define a Sqrt expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\nsqrt_x = Sqrt(x)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Sqrt(Expr):\n    \"\"\"Element-wise square root function for symbolic expressions.\n\n    Computes the square root of each element in the operand. Preserves the\n    shape of the input expression.\n\n    Attributes:\n        operand: Expression to apply square root to\n\n    Example:\n        Define a Sqrt expression:\n\n            x = Variable(\"x\", shape=(3,))\n            sqrt_x = Sqrt(x)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a square root operation.\n\n        Args:\n            operand: Expression to apply square root to\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Sqrt(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Sqrt preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"sqrt({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Sqrt.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Sqrt preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Sqrt preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Square","title":"<code>Square</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise square function for symbolic expressions.</p> <p>Computes the square (x^2) of each element in the operand. Preserves the shape of the input expression. This is more efficient than using Power(x, 2) for some optimization backends.</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Expression to square</p> Example <p>Define a Square expression:</p> <pre><code>v = Variable(\"v\", shape=(3,))\nv_squared = Square(v)  # Equivalent to v ** 2\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Square(Expr):\n    \"\"\"Element-wise square function for symbolic expressions.\n\n    Computes the square (x^2) of each element in the operand. Preserves the\n    shape of the input expression. This is more efficient than using Power(x, 2)\n    for some optimization backends.\n\n    Attributes:\n        x: Expression to square\n\n    Example:\n        Define a Square expression:\n\n            v = Variable(\"v\", shape=(3,))\n            v_squared = Square(v)  # Equivalent to v ** 2\n    \"\"\"\n\n    def __init__(self, x):\n        \"\"\"Initialize a square operation.\n\n        Args:\n            x: Expression to square\n        \"\"\"\n        self.x = to_expr(x)\n\n    def children(self):\n        return [self.x]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        x = self.x.canonicalize()\n        return Square(x)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"x^2 preserves the shape of x.\"\"\"\n        return self.x.check_shape()\n\n    def __repr__(self):\n        return f\"({self.x!r})^2\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Square.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>x^2 preserves the shape of x.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"x^2 preserves the shape of x.\"\"\"\n    return self.x.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Tan","title":"<code>Tan</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise tangent function for symbolic expressions.</p> <p>Computes the tangent of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply tangent function to</p> Example <p>Define a Tan expression:</p> <pre><code>theta = Variable(\"theta\", shape=(3,))\ntan_theta = Tan(theta)\n</code></pre> Note <p>Tan is only supported for JAX lowering. CVXPy lowering will raise NotImplementedError since tangent is not DCP-compliant.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Tan(Expr):\n    \"\"\"Element-wise tangent function for symbolic expressions.\n\n    Computes the tangent of each element in the operand. Preserves the shape\n    of the input expression.\n\n    Attributes:\n        operand: Expression to apply tangent function to\n\n    Example:\n        Define a Tan expression:\n\n            theta = Variable(\"theta\", shape=(3,))\n            tan_theta = Tan(theta)\n\n    Note:\n        Tan is only supported for JAX lowering. CVXPy lowering will raise\n        NotImplementedError since tangent is not DCP-compliant.\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a tangent operation.\n\n        Args:\n            operand: Expression to apply tangent function to\n        \"\"\"\n        self.operand = operand\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Tan(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Tan preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"(tan({self.operand!r}))\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Tan.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Tan preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Tan preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/spatial/","title":"spatial","text":"<p>Spatial and 6-DOF utility operations for trajectory optimization.</p> <p>This module provides efficient symbolic expression nodes for common 6-DOF (six degree of freedom) operations used in aerospace and robotics applications. These operations directly map to optimized JAX implementations for high-performance evaluation.</p>"},{"location":"reference/symbolic/expr/spatial/#openscvx.symbolic.expr.spatial.QDCM","title":"<code>QDCM</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Quaternion to Direction Cosine Matrix (DCM) conversion.</p> <p>Converts a unit quaternion representation to a 3x3 direction cosine matrix (also known as a rotation matrix). This operation is commonly used in 6-DOF spacecraft dynamics, aircraft simulation, and robotics applications.</p> <p>The quaternion is expected in scalar-last format: [qx, qy, qz, qw] where qw is the scalar component. The resulting DCM can be used to transform vectors from one reference frame to another.</p> <p>Attributes:</p> Name Type Description <code>q</code> <p>Quaternion expression with shape (4,)</p> Example <p>Use the QDCM to rotate a vector:</p> <pre><code>import openscvx as ox\nq = ox.State(\"q\", shape=(4,))\ndcm = ox.QDCM(q)  # Creates rotation matrix, shape (3, 3)\nv_body = ox.Variable(\"v_body\", shape=(3,))\nv_inertial = dcm @ v_body\n</code></pre> Note <p>The input quaternion does not need to be normalized; the implementation automatically handles normalization during evaluation.</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>class QDCM(Expr):\n    \"\"\"Quaternion to Direction Cosine Matrix (DCM) conversion.\n\n    Converts a unit quaternion representation to a 3x3 direction cosine matrix\n    (also known as a rotation matrix). This operation is commonly used in 6-DOF\n    spacecraft dynamics, aircraft simulation, and robotics applications.\n\n    The quaternion is expected in scalar-last format: [qx, qy, qz, qw] where\n    qw is the scalar component. The resulting DCM can be used to transform vectors\n    from one reference frame to another.\n\n    Attributes:\n        q: Quaternion expression with shape (4,)\n\n    Example:\n        Use the QDCM to rotate a vector:\n\n            import openscvx as ox\n            q = ox.State(\"q\", shape=(4,))\n            dcm = ox.QDCM(q)  # Creates rotation matrix, shape (3, 3)\n            v_body = ox.Variable(\"v_body\", shape=(3,))\n            v_inertial = dcm @ v_body\n\n    Note:\n        The input quaternion does not need to be normalized; the implementation\n        automatically handles normalization during evaluation.\n    \"\"\"\n\n    def __init__(self, q):\n        \"\"\"Initialize a quaternion to DCM conversion.\n\n        Args:\n            q: Quaternion expression with shape (4,) in [qx, qy, qz, qw] format\n        \"\"\"\n        self.q = to_expr(q)\n\n    def children(self):\n        return [self.q]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        q = self.q.canonicalize()\n        return QDCM(q)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a quaternion and return DCM shape.\n\n        Returns:\n            tuple: Shape (3, 3) for the resulting direction cosine matrix\n\n        Raises:\n            ValueError: If quaternion does not have shape (4,)\n        \"\"\"\n        q_shape = self.q.check_shape()\n        if q_shape != (4,):\n            raise ValueError(f\"QDCM expects quaternion with shape (4,), got {q_shape}\")\n        return (3, 3)\n\n    def __repr__(self):\n        return f\"qdcm({self.q!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/spatial/#openscvx.symbolic.expr.spatial.QDCM.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a quaternion and return DCM shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (3, 3) for the resulting direction cosine matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If quaternion does not have shape (4,)</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a quaternion and return DCM shape.\n\n    Returns:\n        tuple: Shape (3, 3) for the resulting direction cosine matrix\n\n    Raises:\n        ValueError: If quaternion does not have shape (4,)\n    \"\"\"\n    q_shape = self.q.check_shape()\n    if q_shape != (4,):\n        raise ValueError(f\"QDCM expects quaternion with shape (4,), got {q_shape}\")\n    return (3, 3)\n</code></pre>"},{"location":"reference/symbolic/expr/spatial/#openscvx.symbolic.expr.spatial.SSM","title":"<code>SSM</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Angular rate vector to 3x3 skew-symmetric matrix (cross product matrix).</p> <p>Constructs the 3x3 skew-symmetric matrix [\u03c9]x that represents the cross product operation. For any 3D vector v, the cross product \u03c9 x v can be computed as the matrix-vector product [\u03c9]x @ v.</p> The resulting matrix has the form <p>\u23a1  0  -\u03c9z   \u03c9y \u23a4 \u23a2 \u03c9z    0  -\u03c9x \u23a5 \u23a3-\u03c9y   \u03c9x    0 \u23a6</p> <p>This operation is widely used in: - Rigid body dynamics (angular momentum calculations) - DCM time derivatives: \u1e58 = [\u03c9]x @ R - Velocity kinematics in robotics - Coriolis and centrifugal acceleration terms</p> <p>Attributes:</p> Name Type Description <code>w</code> <p>Angular velocity or 3D vector expression with shape (3,)</p> Example <p>Use the SSM to compute the rotation matrix derivative:</p> <pre><code>import openscvx as ox\nomega = ox.Control(\"omega\", shape=(3,))\nR = ox.State(\"R\", shape=(3, 3))  # Direction cosine matrix\n# DCM time derivative\nR_dot = ox.SSM(omega) @ R\n</code></pre> Note <p>The skew-symmetric property ensures that [\u03c9]x\u1d40 = -[\u03c9]x, which is important for preserving orthogonality in DCM propagation.</p> See Also <p>SSMP: 4x4 skew-symmetric matrix for quaternion dynamics</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>class SSM(Expr):\n    \"\"\"Angular rate vector to 3x3 skew-symmetric matrix (cross product matrix).\n\n    Constructs the 3x3 skew-symmetric matrix [\u03c9]x that represents the cross\n    product operation. For any 3D vector v, the cross product \u03c9 x v can be\n    computed as the matrix-vector product [\u03c9]x @ v.\n\n    The resulting matrix has the form:\n        \u23a1  0  -\u03c9z   \u03c9y \u23a4\n        \u23a2 \u03c9z    0  -\u03c9x \u23a5\n        \u23a3-\u03c9y   \u03c9x    0 \u23a6\n\n    This operation is widely used in:\n    - Rigid body dynamics (angular momentum calculations)\n    - DCM time derivatives: \u1e58 = [\u03c9]x @ R\n    - Velocity kinematics in robotics\n    - Coriolis and centrifugal acceleration terms\n\n    Attributes:\n        w: Angular velocity or 3D vector expression with shape (3,)\n\n    Example:\n        Use the SSM to compute the rotation matrix derivative:\n\n            import openscvx as ox\n            omega = ox.Control(\"omega\", shape=(3,))\n            R = ox.State(\"R\", shape=(3, 3))  # Direction cosine matrix\n            # DCM time derivative\n            R_dot = ox.SSM(omega) @ R\n\n    Note:\n        The skew-symmetric property ensures that [\u03c9]x\u1d40 = -[\u03c9]x, which is\n        important for preserving orthogonality in DCM propagation.\n\n    See Also:\n        SSMP: 4x4 skew-symmetric matrix for quaternion dynamics\n    \"\"\"\n\n    def __init__(self, w):\n        \"\"\"Initialize a vector to skew-symmetric matrix conversion.\n\n        Args:\n            w: 3D vector expression with shape (3,) in [\u03c9x, \u03c9y, \u03c9z] format\n        \"\"\"\n        self.w = to_expr(w)\n\n    def children(self):\n        return [self.w]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        w = self.w.canonicalize()\n        return SSM(w)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 3D vector and return matrix shape.\n\n        Returns:\n            tuple: Shape (3, 3) for the resulting skew-symmetric matrix\n\n        Raises:\n            ValueError: If input vector does not have shape (3,)\n        \"\"\"\n        w_shape = self.w.check_shape()\n        if w_shape != (3,):\n            raise ValueError(f\"SSM expects angular velocity with shape (3,), got {w_shape}\")\n        return (3, 3)\n\n    def __repr__(self):\n        return f\"ssm({self.w!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/spatial/#openscvx.symbolic.expr.spatial.SSM.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 3D vector and return matrix shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (3, 3) for the resulting skew-symmetric matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input vector does not have shape (3,)</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 3D vector and return matrix shape.\n\n    Returns:\n        tuple: Shape (3, 3) for the resulting skew-symmetric matrix\n\n    Raises:\n        ValueError: If input vector does not have shape (3,)\n    \"\"\"\n    w_shape = self.w.check_shape()\n    if w_shape != (3,):\n        raise ValueError(f\"SSM expects angular velocity with shape (3,), got {w_shape}\")\n    return (3, 3)\n</code></pre>"},{"location":"reference/symbolic/expr/spatial/#openscvx.symbolic.expr.spatial.SSMP","title":"<code>SSMP</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Angular rate to 4x4 skew-symmetric matrix for quaternion dynamics.</p> <p>Constructs the 4x4 skew-symmetric matrix \u03a9(\u03c9) used in quaternion kinematic differential equations. This matrix relates angular velocity to the time derivative of the quaternion:</p> <pre><code>q\u0307 = (1/2) * \u03a9(\u03c9) @ q\n</code></pre> The resulting matrix has the form <p>\u23a1  0   \u03c9z  -\u03c9y   \u03c9x \u23a4 \u23a2-\u03c9z    0   \u03c9x   \u03c9y \u23a5 \u23a2 \u03c9y  -\u03c9x    0   \u03c9z \u23a5 \u23a3-\u03c9x  -\u03c9y  -\u03c9z    0 \u23a6</p> <p>This is particularly useful for formulating quaternion-based attitude dynamics in spacecraft and aircraft trajectory optimization problems.</p> <p>Attributes:</p> Name Type Description <code>w</code> <p>Angular velocity vector expression with shape (3,)</p> Example <p>Use the SSMP to compute the quaternion derivative:</p> <pre><code>import openscvx as ox\nomega = ox.Control(\"omega\", shape=(3,))\nq = ox.State(\"q\", shape=(4,))\n# Quaternion kinematic equation\nq_dot = 0.5 * ox.SSMP(omega) @ q\n</code></pre> See Also <p>SSM: 3x3 skew-symmetric matrix for cross product operations</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>class SSMP(Expr):\n    \"\"\"Angular rate to 4x4 skew-symmetric matrix for quaternion dynamics.\n\n    Constructs the 4x4 skew-symmetric matrix \u03a9(\u03c9) used in quaternion kinematic\n    differential equations. This matrix relates angular velocity to the time\n    derivative of the quaternion:\n\n        q\u0307 = (1/2) * \u03a9(\u03c9) @ q\n\n    The resulting matrix has the form:\n        \u23a1  0   \u03c9z  -\u03c9y   \u03c9x \u23a4\n        \u23a2-\u03c9z    0   \u03c9x   \u03c9y \u23a5\n        \u23a2 \u03c9y  -\u03c9x    0   \u03c9z \u23a5\n        \u23a3-\u03c9x  -\u03c9y  -\u03c9z    0 \u23a6\n\n    This is particularly useful for formulating quaternion-based attitude\n    dynamics in spacecraft and aircraft trajectory optimization problems.\n\n    Attributes:\n        w: Angular velocity vector expression with shape (3,)\n\n    Example:\n        Use the SSMP to compute the quaternion derivative:\n\n            import openscvx as ox\n            omega = ox.Control(\"omega\", shape=(3,))\n            q = ox.State(\"q\", shape=(4,))\n            # Quaternion kinematic equation\n            q_dot = 0.5 * ox.SSMP(omega) @ q\n\n    See Also:\n        SSM: 3x3 skew-symmetric matrix for cross product operations\n    \"\"\"\n\n    def __init__(self, w):\n        \"\"\"Initialize an angular velocity to skew-symmetric matrix conversion.\n\n        Args:\n            w: Angular velocity vector expression with shape (3,) in [\u03c9x, \u03c9y, \u03c9z] format\n        \"\"\"\n        self.w = to_expr(w)\n\n    def children(self):\n        return [self.w]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        w = self.w.canonicalize()\n        return SSMP(w)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 3D angular velocity and return matrix shape.\n\n        Returns:\n            tuple: Shape (4, 4) for the resulting skew-symmetric matrix\n\n        Raises:\n            ValueError: If angular velocity does not have shape (3,)\n        \"\"\"\n        w_shape = self.w.check_shape()\n        if w_shape != (3,):\n            raise ValueError(f\"SSMP expects angular velocity with shape (3,), got {w_shape}\")\n        return (4, 4)\n\n    def __repr__(self):\n        return f\"ssmp({self.w!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/spatial/#openscvx.symbolic.expr.spatial.SSMP.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 3D angular velocity and return matrix shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (4, 4) for the resulting skew-symmetric matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If angular velocity does not have shape (3,)</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 3D angular velocity and return matrix shape.\n\n    Returns:\n        tuple: Shape (4, 4) for the resulting skew-symmetric matrix\n\n    Raises:\n        ValueError: If angular velocity does not have shape (3,)\n    \"\"\"\n    w_shape = self.w.check_shape()\n    if w_shape != (3,):\n        raise ValueError(f\"SSMP expects angular velocity with shape (3,), got {w_shape}\")\n    return (4, 4)\n</code></pre>"},{"location":"reference/symbolic/expr/state/","title":"state","text":""},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.BoundaryType","title":"<code>BoundaryType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of boundary condition types for state variables.</p> <p>This enum allows users to specify boundary conditions using plain strings while maintaining type safety internally. Boundary conditions control how the optimizer handles initial and final state values.</p> <p>Attributes:</p> Name Type Description <code>FIXED</code> <code>str</code> <p>State value is fixed to a specific value</p> <code>FREE</code> <code>str</code> <p>State value is free to be optimized within bounds</p> <code>MINIMIZE</code> <code>str</code> <p>Objective term to minimize the state value</p> <code>MAXIMIZE</code> <code>str</code> <p>Objective term to maximize the state value</p> Example <p>Can use either enum or string:</p> <pre><code>BoundaryType.FIXED\n\"fixed\"  # Equivalent\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>class BoundaryType(str, Enum):\n    \"\"\"Enumeration of boundary condition types for state variables.\n\n    This enum allows users to specify boundary conditions using plain strings\n    while maintaining type safety internally. Boundary conditions control how\n    the optimizer handles initial and final state values.\n\n    Attributes:\n        FIXED (str): State value is fixed to a specific value\n        FREE (str): State value is free to be optimized within bounds\n        MINIMIZE (str): Objective term to minimize the state value\n        MAXIMIZE (str): Objective term to maximize the state value\n\n    Example:\n        Can use either enum or string:\n\n            BoundaryType.FIXED\n            \"fixed\"  # Equivalent\n    \"\"\"\n\n    FIXED = \"fixed\"\n    FREE = \"free\"\n    MINIMIZE = \"minimize\"\n    MAXIMIZE = \"maximize\"\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.State","title":"<code>State</code>","text":"<p>               Bases: <code>Variable</code></p> <p>State variable with boundary conditions for trajectory optimization.</p> <p>State represents a dynamic state variable in a trajectory optimization problem. Unlike control inputs, states evolve according to dynamics constraints and can have boundary conditions specified at the initial and final time points. Like all Variables, States also support min/max bounds and initial trajectory guesses to help guide the optimization solver toward good solutions.</p> <p>States support four types of boundary conditions:</p> <ul> <li>fixed: State value is constrained to a specific value</li> <li>free: State value is optimized within the specified bounds</li> <li>minimize: Adds a term to the objective function to minimize the state value</li> <li>maximize: Adds a term to the objective function to maximize the state value</li> </ul> <p>Each element of a multi-dimensional state can have different boundary condition types, allowing for fine-grained control over the optimization.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name identifier for this state variable</p> <code>_shape</code> <code>tuple[int, ...]</code> <p>Shape of the state vector (typically 1D like (3,) for 3D position)</p> <code>_slice</code> <code>slice | None</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <code>ndarray | None</code> <p>Minimum bounds for state variables</p> <code>_max</code> <code>ndarray | None</code> <p>Maximum bounds for state variables</p> <code>_guess</code> <code>ndarray | None</code> <p>Initial trajectory guess</p> <code>_initial</code> <code>ndarray | None</code> <p>Initial state values with boundary condition types</p> <code>initial_type</code> <code>ndarray | None</code> <p>Array of boundary condition types for initial state</p> <code>_final</code> <code>ndarray | None</code> <p>Final state values with boundary condition types</p> <code>final_type</code> <code>ndarray | None</code> <p>Array of boundary condition types for final state</p> Example <p>Scalar time state with fixed initial time, minimize final time:</p> <pre><code>time = State(\"time\", (1,))\ntime.min = [0.0]\ntime.max = [10.0]\ntime.initial = [(\"fixed\", 0.0)]\ntime.final = [(\"minimize\", 5.0)]\n</code></pre> <p>3D position state with mixed boundary conditions:</p> <pre><code>pos = State(\"pos\", (3,))\npos.min = [0, 0, 10]\npos.max = [10, 10, 200]\npos.initial = [0, (\"free\", 1), 50]  # x fixed, y free, z fixed\npos.final = [10, (\"free\", 5), (\"maximize\", 150)]  # Maximize final altitude\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>class State(Variable):\n    \"\"\"State variable with boundary conditions for trajectory optimization.\n\n    State represents a dynamic state variable in a trajectory optimization problem.\n    Unlike control inputs, states evolve according to dynamics constraints and can\n    have boundary conditions specified at the initial and final time points.\n    Like all Variables, States also support min/max bounds and initial trajectory\n    guesses to help guide the optimization solver toward good solutions.\n\n    States support four types of boundary conditions:\n\n    - **fixed**: State value is constrained to a specific value\n    - **free**: State value is optimized within the specified bounds\n    - **minimize**: Adds a term to the objective function to minimize the state value\n    - **maximize**: Adds a term to the objective function to maximize the state value\n\n    Each element of a multi-dimensional state can have different boundary condition\n    types, allowing for fine-grained control over the optimization.\n\n    Attributes:\n        name (str): Unique name identifier for this state variable\n        _shape (tuple[int, ...]): Shape of the state vector (typically 1D like (3,) for 3D position)\n        _slice (slice | None): Internal slice information for variable indexing\n        _min (np.ndarray | None): Minimum bounds for state variables\n        _max (np.ndarray | None): Maximum bounds for state variables\n        _guess (np.ndarray | None): Initial trajectory guess\n        _initial (np.ndarray | None): Initial state values with boundary condition types\n        initial_type (np.ndarray | None): Array of boundary condition types for initial state\n        _final (np.ndarray | None): Final state values with boundary condition types\n        final_type (np.ndarray | None): Array of boundary condition types for final state\n\n    Example:\n        Scalar time state with fixed initial time, minimize final time:\n\n            time = State(\"time\", (1,))\n            time.min = [0.0]\n            time.max = [10.0]\n            time.initial = [(\"fixed\", 0.0)]\n            time.final = [(\"minimize\", 5.0)]\n\n        3D position state with mixed boundary conditions:\n\n            pos = State(\"pos\", (3,))\n            pos.min = [0, 0, 10]\n            pos.max = [10, 10, 200]\n            pos.initial = [0, (\"free\", 1), 50]  # x fixed, y free, z fixed\n            pos.final = [10, (\"free\", 5), (\"maximize\", 150)]  # Maximize final altitude\n    \"\"\"\n\n    def __init__(self, name, shape):\n        \"\"\"Initialize a State object.\n\n        Args:\n            name: Name identifier for the state variable\n            shape: Shape of the state vector (typically 1D tuple)\n        \"\"\"\n        super().__init__(name, shape)\n        self._initial = None\n        self.initial_type = None\n        self._final = None\n        self.final_type = None\n        self._scaling_min = None\n        self._scaling_max = None\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash State including boundary condition types.\n\n        Extends Variable._hash_into to include the structural metadata that\n        affects the compiled problem: boundary condition types (fixed, free,\n        minimize, maximize). Values are not hashed as they are runtime parameters.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        # Hash the base Variable attributes (class name, shape, slice)\n        super()._hash_into(hasher)\n        # Hash boundary condition types (these affect constraint structure)\n        if self.initial_type is not None:\n            hasher.update(b\"initial_type:\")\n            hasher.update(str(self.initial_type.tolist()).encode())\n        if self.final_type is not None:\n            hasher.update(b\"final_type:\")\n            hasher.update(str(self.final_type.tolist()).encode())\n\n    @property\n    def min(self):\n        \"\"\"Get the minimum bounds for the state variables.\n\n        Returns:\n            Array of minimum values for each state variable element.\n\n        Example:\n            Get lower bounds:\n\n                pos = State(\"pos\", (3,))\n                pos.min = [0, 0, 10]\n                print(pos.min)  # [0. 0. 10.]\n        \"\"\"\n        return self._min\n\n    @min.setter\n    def min(self, val):\n        \"\"\"Set the minimum bounds for the state variables.\n\n        Bounds are validated against any fixed initial/final conditions to ensure\n        consistency.\n\n        Args:\n            val: Array of minimum values, must match the state shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape, or if fixed\n                boundary conditions violate the bounds\n\n        Example:\n            Set lower bounds:\n\n                pos = State(\"pos\", (3,))\n                pos.min = [0, 0, 10]\n                pos.initial = [0, 5, 15]  # Must satisfy: 0&gt;=0, 5&gt;=0, 15&gt;=10\n        \"\"\"\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(f\"Min shape {val.shape} does not match State shape {self.shape}\")\n        self._min = val\n        self._check_bounds_against_initial_final()\n\n    @property\n    def max(self):\n        \"\"\"Get the maximum bounds for the state variables.\n\n        Returns:\n            Array of maximum values for each state variable element.\n\n        Example:\n            Get upper bounds:\n\n                vel = State(\"vel\", (3,))\n                vel.max = [10, 10, 5]\n                print(vel.max)  # [10. 10. 5.]\n        \"\"\"\n        return self._max\n\n    @max.setter\n    def max(self, val):\n        \"\"\"Set the maximum bounds for the state variables.\n\n        Bounds are validated against any fixed initial/final conditions to ensure\n        consistency.\n\n        Args:\n            val: Array of maximum values, must match the state shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape, or if fixed\n                boundary conditions violate the bounds\n\n        Example:\n            Set upper bounds:\n\n                vel = State(\"vel\", (3,))\n                vel.max = [10, 10, 5]\n                vel.final = [8, 9, 4]  # Must satisfy: 8&lt;=10, 9&lt;=10, 4&lt;=5\n        \"\"\"\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(f\"Max shape {val.shape} does not match State shape {self.shape}\")\n        self._max = val\n        self._check_bounds_against_initial_final()\n\n    def _check_bounds_against_initial_final(self):\n        \"\"\"Validate that fixed boundary conditions respect min/max bounds.\n\n        This internal method is automatically called when bounds or boundary\n        conditions are set to ensure consistency.\n\n        Raises:\n            ValueError: If any fixed initial or final value violates the min/max bounds\n        \"\"\"\n        for field_name, data, types in [\n            (\"initial\", self._initial, self.initial_type),\n            (\"final\", self._final, self.final_type),\n        ]:\n            if data is None or types is None:\n                continue\n            for i, val in np.ndenumerate(data):\n                if types[i] != \"Fix\":\n                    continue\n                min_i = self._min[i] if self._min is not None else -np.inf\n                max_i = self._max[i] if self._max is not None else np.inf\n                if val &lt; min_i:\n                    raise ValueError(\n                        f\"{field_name.capitalize()} Fixed value at index {i[0]} is lower then the \"\n                        f\"min: {val} &lt; {min_i}\"\n                    )\n                if val &gt; max_i:\n                    raise ValueError(\n                        f\"{field_name.capitalize()} Fixed value at index {i[0]} is greater then \"\n                        f\"the max: {val} &gt; {max_i}\"\n                    )\n\n    @property\n    def initial(self):\n        \"\"\"Get the initial state boundary condition values.\n\n        Returns:\n            Array of initial state values (regardless of boundary condition type),\n            or None if not set.\n\n        Note:\n            Use `initial_type` to see the boundary condition types for each element.\n\n        Example:\n            Get initial state boundary conditions:\n\n                x = State(\"x\", (2,))\n                x.initial = [0, (\"free\", 1)]\n                print(x.initial)  # [0. 1.]\n                print(x.initial_type)  # ['Fix' 'Free']\n        \"\"\"\n        return self._initial\n\n    @initial.setter\n    def initial(self, arr):\n        \"\"\"Set the initial state boundary conditions.\n\n        Each element can be specified as either a simple number (defaults to \"fixed\")\n        or a tuple of (type, value) where type specifies the boundary condition.\n\n        Args:\n            arr: Array-like of initial conditions. Each element can be:\n                - A number: Defaults to fixed boundary condition at that value\n                - A tuple (type, value): Where type is one of:\n                    - \"fixed\": Constrain state to this exact value\n                    - \"free\": Let optimizer choose within bounds, initialize at value\n                    - \"minimize\": Add objective term to minimize, initialize at value\n                    - \"maximize\": Add objective term to maximize, initialize at value\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape, if boundary\n                condition type is invalid, or if fixed values violate bounds\n\n        Example:\n            Set initial state boundary conditions:\n\n                pos = State(\"pos\", (3,))\n                pos.min = [0, 0, 0]\n                pos.max = [10, 10, 10]\n                # x fixed at 0, y free (starts at 5), z fixed at 2\n                pos.initial = [0, (\"free\", 5), 2]\n\n            Can also minimize/maximize boundary values:\n\n                time = State(\"t\", (1,))\n                time.initial = [(\"minimize\", 0)]  # Minimize initial time\n        \"\"\"\n        # Convert to list first to handle mixed types properly\n        if not isinstance(arr, (list, tuple)):\n            arr = np.asarray(arr)\n            if arr.shape != self.shape:\n                raise ValueError(f\"Shape mismatch: {arr.shape} != {self.shape}\")\n            arr = arr.tolist()\n\n        # Ensure we have the right number of elements\n        if len(arr) != self.shape[0]:\n            raise ValueError(f\"Length mismatch: got {len(arr)} elements, expected {self.shape[0]}\")\n\n        self._initial = np.zeros(self.shape, dtype=float)\n        self.initial_type = np.full(self.shape, \"Fix\", dtype=object)\n\n        for i, v in enumerate(arr):\n            if isinstance(v, tuple) and len(v) == 2:\n                # Tuple API: (type, value)\n                bc_type_str, bc_value = v\n                try:\n                    bc_type = BoundaryType(bc_type_str)  # Validates the string\n                except ValueError:\n                    valid_types = [t.value for t in BoundaryType]\n                    raise ValueError(\n                        f\"Invalid boundary condition type: {bc_type_str}. \"\n                        f\"Valid types are: {valid_types}\"\n                    )\n                self._initial[i] = float(bc_value)\n                self.initial_type[i] = bc_type.value.capitalize()\n            elif isinstance(v, (int, float, np.number)):\n                # Simple number defaults to fixed\n                self._initial[i] = float(v)\n                self.initial_type[i] = \"Fix\"\n            else:\n                raise ValueError(\n                    f\"Invalid boundary condition format: {v}. \"\n                    f\"Use a number (defaults to fixed) or tuple ('type', value) \"\n                    f\"where type is 'fixed', 'free', 'minimize', or 'maximize'.\"\n                )\n\n        self._check_bounds_against_initial_final()\n\n    @property\n    def final(self):\n        \"\"\"Get the final state boundary condition values.\n\n        Returns:\n            Array of final state values (regardless of boundary condition type),\n            or None if not set.\n\n        Note:\n            Use `final_type` to see the boundary condition types for each element.\n\n        Example:\n            Get final state boundary conditions:\n\n                x = State(\"x\", (2,))\n                x.final = [10, (\"minimize\", 0)]\n                print(x.final)  # [10. 0.]\n                print(x.final_type)  # ['Fix' 'Minimize']\n        \"\"\"\n        return self._final\n\n    @final.setter\n    def final(self, arr):\n        \"\"\"Set the final state boundary conditions.\n\n        Each element can be specified as either a simple number (defaults to \"fixed\")\n        or a tuple of (type, value) where type specifies the boundary condition.\n\n        Args:\n            arr: Array-like of final conditions. Each element can be:\n                - A number: Defaults to fixed boundary condition at that value\n                - A tuple (type, value): Where type is one of:\n                    - \"fixed\": Constrain state to this exact value\n                    - \"free\": Let optimizer choose within bounds, initialize at value\n                    - \"minimize\": Add objective term to minimize, initialize at value\n                    - \"maximize\": Add objective term to maximize, initialize at value\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape, if boundary\n                condition type is invalid, or if fixed values violate bounds\n\n        Example:\n            Set final state boundary conditionis:\n\n                pos = State(\"pos\", (3,))\n                pos.min = [0, 0, 0]\n                pos.max = [10, 10, 10]\n                # x fixed at 10, y free (starts at 5), z maximize altitude\n                pos.final = [10, (\"free\", 5), (\"maximize\", 8)]\n\n            Minimize final time in time-optimal problem:\n\n                time = State(\"t\", (1,))\n                time.final = [(\"minimize\", 10)]\n        \"\"\"\n        # Convert to list first to handle mixed types properly\n        if not isinstance(arr, (list, tuple)):\n            arr = np.asarray(arr)\n            if arr.shape != self.shape:\n                raise ValueError(f\"Shape mismatch: {arr.shape} != {self.shape}\")\n            arr = arr.tolist()\n\n        # Ensure we have the right number of elements\n        if len(arr) != self.shape[0]:\n            raise ValueError(f\"Length mismatch: got {len(arr)} elements, expected {self.shape[0]}\")\n\n        self._final = np.zeros(self.shape, dtype=float)\n        self.final_type = np.full(self.shape, \"Fix\", dtype=object)\n\n        for i, v in enumerate(arr):\n            if isinstance(v, tuple) and len(v) == 2:\n                # Tuple API: (type, value)\n                bc_type_str, bc_value = v\n                try:\n                    bc_type = BoundaryType(bc_type_str)  # Validates the string\n                except ValueError:\n                    valid_types = [t.value for t in BoundaryType]\n                    raise ValueError(\n                        f\"Invalid boundary condition type: {bc_type_str}. \"\n                        f\"Valid types are: {valid_types}\"\n                    )\n                self._final[i] = float(bc_value)\n                self.final_type[i] = bc_type.value.capitalize()\n            elif isinstance(v, (int, float, np.number)):\n                # Simple number defaults to fixed\n                self._final[i] = float(v)\n                self.final_type[i] = \"Fix\"\n            else:\n                raise ValueError(\n                    f\"Invalid boundary condition format: {v}. \"\n                    f\"Use a number (defaults to fixed) or tuple ('type', value) \"\n                    f\"where type is 'fixed', 'free', 'minimize', or 'maximize'.\"\n                )\n\n        self._check_bounds_against_initial_final()\n\n    @property\n    def scaling_min(self):\n        \"\"\"Get the scaling minimum bounds for the state variables.\n\n        Returns:\n            Array of scaling minimum values for each state variable element, or None if not set.\n        \"\"\"\n        return self._scaling_min\n\n    @scaling_min.setter\n    def scaling_min(self, val):\n        \"\"\"Set the scaling minimum bounds for the state variables.\n\n        Args:\n            val: Array of scaling minimum values, must match the state shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape\n        \"\"\"\n        if val is None:\n            self._scaling_min = None\n            return\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(\n                f\"Scaling min shape {val.shape} does not match State shape {self.shape}\"\n            )\n        self._scaling_min = val\n\n    @property\n    def scaling_max(self):\n        \"\"\"Get the scaling maximum bounds for the state variables.\n\n        Returns:\n            Array of scaling maximum values for each state variable element, or None if not set.\n        \"\"\"\n        return self._scaling_max\n\n    @scaling_max.setter\n    def scaling_max(self, val):\n        \"\"\"Set the scaling maximum bounds for the state variables.\n\n        Args:\n            val: Array of scaling maximum values, must match the state shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape\n        \"\"\"\n        if val is None:\n            self._scaling_max = None\n            return\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(\n                f\"Scaling max shape {val.shape} does not match State shape {self.shape}\"\n            )\n        self._scaling_max = val\n\n    def __repr__(self):\n        \"\"\"String representation of the State object.\n\n        Returns:\n            Concise string showing the state name and shape.\n        \"\"\"\n        return f\"State('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.State.final","title":"<code>final</code>  <code>property</code> <code>writable</code>","text":"<p>Get the final state boundary condition values.</p> <p>Returns:</p> Type Description <p>Array of final state values (regardless of boundary condition type),</p> <p>or None if not set.</p> Note <p>Use <code>final_type</code> to see the boundary condition types for each element.</p> Example <p>Get final state boundary conditions:</p> <pre><code>x = State(\"x\", (2,))\nx.final = [10, (\"minimize\", 0)]\nprint(x.final)  # [10. 0.]\nprint(x.final_type)  # ['Fix' 'Minimize']\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.State.initial","title":"<code>initial</code>  <code>property</code> <code>writable</code>","text":"<p>Get the initial state boundary condition values.</p> <p>Returns:</p> Type Description <p>Array of initial state values (regardless of boundary condition type),</p> <p>or None if not set.</p> Note <p>Use <code>initial_type</code> to see the boundary condition types for each element.</p> Example <p>Get initial state boundary conditions:</p> <pre><code>x = State(\"x\", (2,))\nx.initial = [0, (\"free\", 1)]\nprint(x.initial)  # [0. 1.]\nprint(x.initial_type)  # ['Fix' 'Free']\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.State.max","title":"<code>max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the maximum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of maximum values for each state variable element.</p> Example <p>Get upper bounds:</p> <pre><code>vel = State(\"vel\", (3,))\nvel.max = [10, 10, 5]\nprint(vel.max)  # [10. 10. 5.]\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.State.min","title":"<code>min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the minimum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of minimum values for each state variable element.</p> Example <p>Get lower bounds:</p> <pre><code>pos = State(\"pos\", (3,))\npos.min = [0, 0, 10]\nprint(pos.min)  # [0. 0. 10.]\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.State.scaling_max","title":"<code>scaling_max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling maximum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of scaling maximum values for each state variable element, or None if not set.</p>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.State.scaling_min","title":"<code>scaling_min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling minimum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of scaling minimum values for each state variable element, or None if not set.</p>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.State._check_bounds_against_initial_final","title":"<code>_check_bounds_against_initial_final()</code>","text":"<p>Validate that fixed boundary conditions respect min/max bounds.</p> <p>This internal method is automatically called when bounds or boundary conditions are set to ensure consistency.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any fixed initial or final value violates the min/max bounds</p> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def _check_bounds_against_initial_final(self):\n    \"\"\"Validate that fixed boundary conditions respect min/max bounds.\n\n    This internal method is automatically called when bounds or boundary\n    conditions are set to ensure consistency.\n\n    Raises:\n        ValueError: If any fixed initial or final value violates the min/max bounds\n    \"\"\"\n    for field_name, data, types in [\n        (\"initial\", self._initial, self.initial_type),\n        (\"final\", self._final, self.final_type),\n    ]:\n        if data is None or types is None:\n            continue\n        for i, val in np.ndenumerate(data):\n            if types[i] != \"Fix\":\n                continue\n            min_i = self._min[i] if self._min is not None else -np.inf\n            max_i = self._max[i] if self._max is not None else np.inf\n            if val &lt; min_i:\n                raise ValueError(\n                    f\"{field_name.capitalize()} Fixed value at index {i[0]} is lower then the \"\n                    f\"min: {val} &lt; {min_i}\"\n                )\n            if val &gt; max_i:\n                raise ValueError(\n                    f\"{field_name.capitalize()} Fixed value at index {i[0]} is greater then \"\n                    f\"the max: {val} &gt; {max_i}\"\n                )\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.State._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash State including boundary condition types.</p> <p>Extends Variable._hash_into to include the structural metadata that affects the compiled problem: boundary condition types (fixed, free, minimize, maximize). Values are not hashed as they are runtime parameters.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash State including boundary condition types.\n\n    Extends Variable._hash_into to include the structural metadata that\n    affects the compiled problem: boundary condition types (fixed, free,\n    minimize, maximize). Values are not hashed as they are runtime parameters.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    # Hash the base Variable attributes (class name, shape, slice)\n    super()._hash_into(hasher)\n    # Hash boundary condition types (these affect constraint structure)\n    if self.initial_type is not None:\n        hasher.update(b\"initial_type:\")\n        hasher.update(str(self.initial_type.tolist()).encode())\n    if self.final_type is not None:\n        hasher.update(b\"final_type:\")\n        hasher.update(str(self.final_type.tolist()).encode())\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.Fixed","title":"<code>Fixed(value)</code>","text":"<p>Create a fixed boundary condition tuple.</p> <p>This is a convenience function that returns a tuple (\"fixed\", value) which can be used to explicitly specify fixed boundary conditions for State or Time objects. Note that plain numbers default to fixed, so this is mainly for clarity.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>Fixed value for the boundary condition.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(\"fixed\", value) tuple suitable for use in State.initial, State.final, or Time.initial, Time.final.</p> Example <pre><code>pos = ox.State(\"pos\", (3,))\npos.final = [ox.Fixed(10.0), ox.Free(5.0), ox.Fixed(2.0)]\n\n# Equivalent to:\npos.final = [10.0, ox.Free(5.0), 2.0]  # Plain numbers default to fixed\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def Fixed(value):\n    \"\"\"Create a fixed boundary condition tuple.\n\n    This is a convenience function that returns a tuple (\"fixed\", value) which\n    can be used to explicitly specify fixed boundary conditions for State or Time objects.\n    Note that plain numbers default to fixed, so this is mainly for clarity.\n\n    Args:\n        value: Fixed value for the boundary condition.\n\n    Returns:\n        tuple: (\"fixed\", value) tuple suitable for use in State.initial, State.final,\n            or Time.initial, Time.final.\n\n    Example:\n        ```python\n        pos = ox.State(\"pos\", (3,))\n        pos.final = [ox.Fixed(10.0), ox.Free(5.0), ox.Fixed(2.0)]\n\n        # Equivalent to:\n        pos.final = [10.0, ox.Free(5.0), 2.0]  # Plain numbers default to fixed\n        ```\n    \"\"\"\n    return (\"fixed\", value)\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.Free","title":"<code>Free(guess)</code>","text":"<p>Create a free boundary condition tuple.</p> <p>This is a convenience function that returns a tuple (\"free\", guess) which can be used to specify free boundary conditions for State or Time objects.</p> <p>Parameters:</p> Name Type Description Default <code>guess</code> <p>Initial guess value for the free variable.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(\"free\", guess) tuple suitable for use in State.initial, State.final, or Time.initial, Time.final.</p> Example <pre><code>pos = ox.State(\"pos\", (3,))\npos.final = [ox.Free(5.0), ox.Free(3.0), 10]  # First two free, third fixed\n\ntime = ox.Time(\n    initial=0.0,\n    final=ox.Free(10.0),\n    min=0.0,\n    max=20.0\n)\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def Free(guess):\n    \"\"\"Create a free boundary condition tuple.\n\n    This is a convenience function that returns a tuple (\"free\", guess) which\n    can be used to specify free boundary conditions for State or Time objects.\n\n    Args:\n        guess: Initial guess value for the free variable.\n\n    Returns:\n        tuple: (\"free\", guess) tuple suitable for use in State.initial, State.final,\n            or Time.initial, Time.final.\n\n    Example:\n        ```python\n        pos = ox.State(\"pos\", (3,))\n        pos.final = [ox.Free(5.0), ox.Free(3.0), 10]  # First two free, third fixed\n\n        time = ox.Time(\n            initial=0.0,\n            final=ox.Free(10.0),\n            min=0.0,\n            max=20.0\n        )\n        ```\n    \"\"\"\n    return (\"free\", guess)\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.Maximize","title":"<code>Maximize(guess)</code>","text":"<p>Create a maximize boundary condition tuple.</p> <p>This is a convenience function that returns a tuple (\"maximize\", guess) which can be used to specify that a boundary value should be maximized in the objective function for State or Time objects.</p> <p>Parameters:</p> Name Type Description Default <code>guess</code> <p>Initial guess value for the variable to be maximized.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(\"maximize\", guess) tuple suitable for use in State.initial, State.final, or Time.initial, Time.final.</p> Example <pre><code>altitude = ox.State(\"altitude\", (1,))\naltitude.final = [ox.Maximize(100.0)]  # Maximize final altitude\n\ntime = ox.Time(\n    initial=ox.Maximize(0.0),  # Maximize initial time\n    final=10.0,\n    min=0.0,\n    max=20.0\n)\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def Maximize(guess):\n    \"\"\"Create a maximize boundary condition tuple.\n\n    This is a convenience function that returns a tuple (\"maximize\", guess) which\n    can be used to specify that a boundary value should be maximized in the objective\n    function for State or Time objects.\n\n    Args:\n        guess: Initial guess value for the variable to be maximized.\n\n    Returns:\n        tuple: (\"maximize\", guess) tuple suitable for use in State.initial, State.final,\n            or Time.initial, Time.final.\n\n    Example:\n        ```python\n        altitude = ox.State(\"altitude\", (1,))\n        altitude.final = [ox.Maximize(100.0)]  # Maximize final altitude\n\n        time = ox.Time(\n            initial=ox.Maximize(0.0),  # Maximize initial time\n            final=10.0,\n            min=0.0,\n            max=20.0\n        )\n        ```\n    \"\"\"\n    return (\"maximize\", guess)\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.Minimize","title":"<code>Minimize(guess)</code>","text":"<p>Create a minimize boundary condition tuple.</p> <p>This is a convenience function that returns a tuple (\"minimize\", guess) which can be used to specify that a boundary value should be minimized in the objective function for State or Time objects.</p> <p>Parameters:</p> Name Type Description Default <code>guess</code> <p>Initial guess value for the variable to be minimized.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(\"minimize\", guess) tuple suitable for use in State.initial, State.final, or Time.initial, Time.final.</p> Example <pre><code>time = ox.Time(\n    initial=0.0,\n    final=ox.Minimize(10.0),  # Minimize final time\n    min=0.0,\n    max=20.0\n)\n\nfuel = ox.State(\"fuel\", (1,))\nfuel.final = [ox.Minimize(0)]  # Minimize final fuel consumption\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def Minimize(guess):\n    \"\"\"Create a minimize boundary condition tuple.\n\n    This is a convenience function that returns a tuple (\"minimize\", guess) which\n    can be used to specify that a boundary value should be minimized in the objective\n    function for State or Time objects.\n\n    Args:\n        guess: Initial guess value for the variable to be minimized.\n\n    Returns:\n        tuple: (\"minimize\", guess) tuple suitable for use in State.initial, State.final,\n            or Time.initial, Time.final.\n\n    Example:\n        ```python\n        time = ox.Time(\n            initial=0.0,\n            final=ox.Minimize(10.0),  # Minimize final time\n            min=0.0,\n            max=20.0\n        )\n\n        fuel = ox.State(\"fuel\", (1,))\n        fuel.final = [ox.Minimize(0)]  # Minimize final fuel consumption\n        ```\n    \"\"\"\n    return (\"minimize\", guess)\n</code></pre>"},{"location":"reference/symbolic/expr/stl/","title":"stl","text":"<p>Signal Temporal Logic (STL) operations for trajectory optimization.</p> <p>This module provides symbolic expression nodes for Signal Temporal Logic (STL) operations, enabling the specification of complex temporal and logical constraints in optimization problems. STL is particularly useful for robotics and autonomous systems where tasks involve temporal reasoning.</p>"},{"location":"reference/symbolic/expr/stl/#openscvx.symbolic.expr.stl.Or","title":"<code>Or</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Logical OR operation for disjunctive constraints.</p> <p>Represents a logical disjunction (OR) between multiple constraint expressions. This is particularly useful in STL-based trajectory optimization for expressing choices or alternatives in task specifications. The Or operation is typically relaxed using smooth approximations (e.g., LogSumExp) during optimization.</p> <p>The Or operation allows expressing constraints like:</p> <ul> <li>\"Reach either goal A OR goal B\"</li> <li>\"Avoid obstacle 1 OR obstacle 2\" (at least one must be satisfied)</li> <li>\"Use path 1 OR path 2 OR path 3\"</li> </ul> <p>During optimization, the disjunction is typically approximated using:     Or(\u03c6\u2081, \u03c6\u2082, ..., \u03c6\u2099) \u2248 LSE(\u03c6\u2081, \u03c6\u2082, ..., \u03c6\u2099) \u2265 0</p> <p>where LSE is the LogSumExp (smooth maximum) function.</p> <p>Attributes:</p> Name Type Description <code>operands</code> <p>List of expressions representing the disjunctive clauses</p> Example <p>Use Or STL operator to enforce that robot must reach either of two goal regions:</p> <pre><code>import openscvx as ox\nx = ox.State(\"x\", shape=(2,))\ngoal_a = ox.Parameter(\"goal_a\", shape=(2,), value=[1.0, 1.0])\ngoal_b = ox.Parameter(\"goal_b\", shape=(2,), value=[-1.0, -1.0])\n# Robot is within 0.5 units of either goal\nreach_a = 0.25 - ox.Norm(x - goal_a)**2\nreach_b = 0.25 - ox.Norm(x - goal_b)**2\nreach_either = ox.Or(reach_a, reach_b)\n</code></pre> Note <p>The Or operation produces a scalar result even when operands are vector expressions, as it represents a single logical proposition.</p> See Also <p>LogSumExp: Common smooth approximation for OR operations Max: Hard maximum (non-smooth alternative)</p> Source code in <code>openscvx/symbolic/expr/stl.py</code> <pre><code>class Or(Expr):\n    \"\"\"Logical OR operation for disjunctive constraints.\n\n    Represents a logical disjunction (OR) between multiple constraint expressions.\n    This is particularly useful in STL-based trajectory optimization for expressing\n    choices or alternatives in task specifications. The Or operation is typically\n    relaxed using smooth approximations (e.g., LogSumExp) during optimization.\n\n    The Or operation allows expressing constraints like:\n\n    - \"Reach either goal A OR goal B\"\n    - \"Avoid obstacle 1 OR obstacle 2\" (at least one must be satisfied)\n    - \"Use path 1 OR path 2 OR path 3\"\n\n    During optimization, the disjunction is typically approximated using:\n        Or(\u03c6\u2081, \u03c6\u2082, ..., \u03c6\u2099) \u2248 LSE(\u03c6\u2081, \u03c6\u2082, ..., \u03c6\u2099) \u2265 0\n\n    where LSE is the LogSumExp (smooth maximum) function.\n\n    Attributes:\n        operands: List of expressions representing the disjunctive clauses\n\n    Example:\n        Use Or STL operator to enforce that robot must reach either of two goal regions:\n\n            import openscvx as ox\n            x = ox.State(\"x\", shape=(2,))\n            goal_a = ox.Parameter(\"goal_a\", shape=(2,), value=[1.0, 1.0])\n            goal_b = ox.Parameter(\"goal_b\", shape=(2,), value=[-1.0, -1.0])\n            # Robot is within 0.5 units of either goal\n            reach_a = 0.25 - ox.Norm(x - goal_a)**2\n            reach_b = 0.25 - ox.Norm(x - goal_b)**2\n            reach_either = ox.Or(reach_a, reach_b)\n\n    Note:\n        The Or operation produces a scalar result even when operands are vector\n        expressions, as it represents a single logical proposition.\n\n    See Also:\n        LogSumExp: Common smooth approximation for OR operations\n        Max: Hard maximum (non-smooth alternative)\n    \"\"\"\n\n    def __init__(self, *operands):\n        \"\"\"Initialize a logical OR operation.\n\n        Args:\n            *operands: Two or more expressions to combine with logical OR.\n                      Each operand typically represents a constraint or condition.\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(operands) &lt; 2:\n            raise ValueError(\"Or requires at least two operands\")\n        self.operands = [to_expr(op) for op in operands]\n\n    def children(self):\n        return self.operands\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize by flattening nested Or expressions.\n\n        Flattens nested Or operations into a single flat Or with all clauses\n        at the same level. For example: Or(a, Or(b, c)) \u2192 Or(a, b, c).\n        Also canonicalizes all operands recursively.\n\n        Returns:\n            Expr: Canonical form of the Or expression. If only one operand\n                  remains after canonicalization, returns that operand directly.\n        \"\"\"\n        operands = []\n\n        for operand in self.operands:\n            canonicalized = operand.canonicalize()\n            if isinstance(canonicalized, Or):\n                # Flatten nested Or: Or(a, Or(b, c)) -&gt; Or(a, b, c)\n                operands.extend(canonicalized.operands)\n            else:\n                operands.append(canonicalized)\n\n        # Return simplified Or expression\n        if len(operands) == 1:\n            return operands[0]\n        return Or(*operands)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Validate operand shapes and return result shape.\n\n        Checks that all operands have compatible (broadcastable) shapes. The Or\n        operation supports broadcasting, allowing mixing of scalars and vectors.\n\n        Returns:\n            tuple: Empty tuple () indicating a scalar result, as Or represents\n                   a single logical proposition\n\n        Raises:\n            ValueError: If fewer than two operands exist\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        if len(self.operands) &lt; 2:\n            raise ValueError(\"Or requires at least two operands\")\n\n        # Validate all operands and get their shapes\n        operand_shapes = [operand.check_shape() for operand in self.operands]\n\n        # For logical operations, all operands should be broadcastable\n        # This allows mixing scalars with vectors for element-wise operations\n        try:\n            result_shape = operand_shapes[0]\n            for shape in operand_shapes[1:]:\n                result_shape = np.broadcast_shapes(result_shape, shape)\n        except ValueError as e:\n            raise ValueError(f\"Or operands not broadcastable: {operand_shapes}\") from e\n\n        # Or produces a scalar result (like constraints)\n        return ()\n\n    def __repr__(self):\n        operands_repr = \" | \".join(repr(op) for op in self.operands)\n        return f\"Or({operands_repr})\"\n</code></pre>"},{"location":"reference/symbolic/expr/stl/#openscvx.symbolic.expr.stl.Or.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize by flattening nested Or expressions.</p> <p>Flattens nested Or operations into a single flat Or with all clauses at the same level. For example: Or(a, Or(b, c)) \u2192 Or(a, b, c). Also canonicalizes all operands recursively.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the Or expression. If only one operand   remains after canonicalization, returns that operand directly.</p> Source code in <code>openscvx/symbolic/expr/stl.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize by flattening nested Or expressions.\n\n    Flattens nested Or operations into a single flat Or with all clauses\n    at the same level. For example: Or(a, Or(b, c)) \u2192 Or(a, b, c).\n    Also canonicalizes all operands recursively.\n\n    Returns:\n        Expr: Canonical form of the Or expression. If only one operand\n              remains after canonicalization, returns that operand directly.\n    \"\"\"\n    operands = []\n\n    for operand in self.operands:\n        canonicalized = operand.canonicalize()\n        if isinstance(canonicalized, Or):\n            # Flatten nested Or: Or(a, Or(b, c)) -&gt; Or(a, b, c)\n            operands.extend(canonicalized.operands)\n        else:\n            operands.append(canonicalized)\n\n    # Return simplified Or expression\n    if len(operands) == 1:\n        return operands[0]\n    return Or(*operands)\n</code></pre>"},{"location":"reference/symbolic/expr/stl/#openscvx.symbolic.expr.stl.Or.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate operand shapes and return result shape.</p> <p>Checks that all operands have compatible (broadcastable) shapes. The Or operation supports broadcasting, allowing mixing of scalars and vectors.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () indicating a scalar result, as Or represents    a single logical proposition</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two operands exist</p> <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/stl.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Validate operand shapes and return result shape.\n\n    Checks that all operands have compatible (broadcastable) shapes. The Or\n    operation supports broadcasting, allowing mixing of scalars and vectors.\n\n    Returns:\n        tuple: Empty tuple () indicating a scalar result, as Or represents\n               a single logical proposition\n\n    Raises:\n        ValueError: If fewer than two operands exist\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    if len(self.operands) &lt; 2:\n        raise ValueError(\"Or requires at least two operands\")\n\n    # Validate all operands and get their shapes\n    operand_shapes = [operand.check_shape() for operand in self.operands]\n\n    # For logical operations, all operands should be broadcastable\n    # This allows mixing scalars with vectors for element-wise operations\n    try:\n        result_shape = operand_shapes[0]\n        for shape in operand_shapes[1:]:\n            result_shape = np.broadcast_shapes(result_shape, shape)\n    except ValueError as e:\n        raise ValueError(f\"Or operands not broadcastable: {operand_shapes}\") from e\n\n    # Or produces a scalar result (like constraints)\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/variable/","title":"variable","text":""},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable","title":"<code>Variable</code>","text":"<p>               Bases: <code>Leaf</code></p> <p>Base class for decision variables in optimization problems.</p> <p>Variable represents decision variables (free parameters) in an optimization problem. These are values that the optimizer can adjust to minimize the objective function while satisfying constraints. Variables can have bounds (min/max) and initial guesses to guide the optimization process.</p> <p>Unlike Parameters (which are fixed values that can be changed between solves), Variables are optimized by the solver. In trajectory optimization, Variables typically represent discretized state or control trajectories.</p> Note <p>Variable is typically not instantiated directly. Instead, use the specialized subclasses State (for state variables with boundary conditions) or Control (for control inputs). These provide additional functionality specific to trajectory optimization.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the variable</p> <code>_shape</code> <code>tuple[int, ...]</code> <p>Shape of the variable as a tuple (typically 1D)</p> <code>_slice</code> <code>slice | None</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <code>ndarray | None</code> <p>Minimum bounds for each element of the variable</p> <code>_max</code> <code>ndarray | None</code> <p>Maximum bounds for each element of the variable</p> <code>_guess</code> <code>ndarray | None</code> <p>Initial guess for the variable trajectory (n_points, n_vars)</p> Example Source code in <code>openscvx/symbolic/expr/variable.py</code> <pre><code>class Variable(Leaf):\n    \"\"\"Base class for decision variables in optimization problems.\n\n    Variable represents decision variables (free parameters) in an optimization problem.\n    These are values that the optimizer can adjust to minimize the objective function\n    while satisfying constraints. Variables can have bounds (min/max) and initial guesses\n    to guide the optimization process.\n\n    Unlike Parameters (which are fixed values that can be changed between solves),\n    Variables are optimized by the solver. In trajectory optimization, Variables typically\n    represent discretized state or control trajectories.\n\n    Note:\n        Variable is typically not instantiated directly. Instead, use the specialized\n        subclasses State (for state variables with boundary conditions) or Control\n        (for control inputs). These provide additional functionality specific to\n        trajectory optimization.\n\n    Attributes:\n        name (str): Name identifier for the variable\n        _shape (tuple[int, ...]): Shape of the variable as a tuple (typically 1D)\n        _slice (slice | None): Internal slice information for variable indexing\n        _min (np.ndarray | None): Minimum bounds for each element of the variable\n        _max (np.ndarray | None): Maximum bounds for each element of the variable\n        _guess (np.ndarray | None): Initial guess for the variable trajectory (n_points, n_vars)\n\n    Example:\n            # Typically, use State or Control instead of Variable directly:\n            pos = openscvx.State(\"pos\", shape=(3,))\n            u = openscvx.Control(\"u\", shape=(2,))\n    \"\"\"\n\n    def __init__(self, name, shape):\n        \"\"\"Initialize a Variable object.\n\n        Args:\n            name: Name identifier for the variable\n            shape: Shape of the variable as a tuple (typically 1D like (3,) for 3D vector)\n        \"\"\"\n        super().__init__(name, shape)\n        self._slice = None\n        self._min = None\n        self._max = None\n        self._guess = None\n\n    def __repr__(self):\n        return f\"Var({self.name!r})\"\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Variable using its slice (canonical position, name-invariant).\n\n        Instead of hashing the variable name, we hash the _slice attribute\n        which represents the variable's canonical position in the unified\n        state/control vector. This ensures that two problems with the same\n        structure but different variable names produce the same hash.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(self.__class__.__name__.encode())\n        hasher.update(str(self._shape).encode())\n        # Hash the slice (canonical position) - this is name-invariant\n        if self._slice is not None:\n            hasher.update(f\"slice:{self._slice.start}:{self._slice.stop}\".encode())\n        else:\n            raise RuntimeError(\n                f\"Cannot hash Variable '{self.name}' without _slice attribute. \"\n                \"Hashing should only be called on preprocessed problems where \"\n                \"all Variables have been assigned canonical slice positions.\"\n            )\n\n    @property\n    def min(self):\n        \"\"\"Get the minimum bounds (lower bounds) for the variable.\n\n        Returns:\n            Array of minimum values for each element of the variable, or None if unbounded.\n\n        Example:\n                pos = Variable(\"pos\", shape=(3,))\n                pos.min = [-10, -10, 0]\n                print(pos.min)  # [-10., -10., 0.]\n        \"\"\"\n        return self._min\n\n    @min.setter\n    def min(self, arr):\n        \"\"\"Set the minimum bounds (lower bounds) for the variable.\n\n        The bounds are applied element-wise to each component of the variable.\n        Scalars will be broadcast to match the variable shape.\n\n        Args:\n            arr: Array of minimum values, must be broadcastable to shape (n,)\n                where n is the variable dimension\n\n        Raises:\n            ValueError: If the shape of arr doesn't match the variable shape\n\n        Example:\n                pos = Variable(\"pos\", shape=(3,))\n                pos.min = -10  # Broadcasts to [-10, -10, -10]\n                pos.min = [-5, -10, 0]  # Element-wise bounds\n        \"\"\"\n        arr = np.asarray(arr, dtype=float)\n        if arr.ndim != 1 or arr.shape[0] != self.shape[0]:\n            raise ValueError(\n                f\"{self.__class__.__name__} min must be 1D with shape ({self.shape[0]},), got\"\n                f\" {arr.shape}\"\n            )\n        self._min = arr\n\n    @property\n    def max(self):\n        \"\"\"Get the maximum bounds (upper bounds) for the variable.\n\n        Returns:\n            Array of maximum values for each element of the variable, or None if unbounded.\n\n        Example:\n                vel = Variable(\"vel\", shape=(3,))\n                vel.max = [10, 10, 5]\n                print(vel.max)  # [10., 10., 5.]\n        \"\"\"\n        return self._max\n\n    @max.setter\n    def max(self, arr):\n        \"\"\"Set the maximum bounds (upper bounds) for the variable.\n\n        The bounds are applied element-wise to each component of the variable.\n        Scalars will be broadcast to match the variable shape.\n\n        Args:\n            arr: Array of maximum values, must be broadcastable to shape (n,)\n                where n is the variable dimension\n\n        Raises:\n            ValueError: If the shape of arr doesn't match the variable shape\n\n        Example:\n                vel = Variable(\"vel\", shape=(3,))\n                vel.max = 10  # Broadcasts to [10, 10, 10]\n                vel.max = [15, 10, 5]  # Element-wise bounds\n        \"\"\"\n        arr = np.asarray(arr, dtype=float)\n        if arr.ndim != 1 or arr.shape[0] != self.shape[0]:\n            raise ValueError(\n                f\"{self.__class__.__name__} max must be 1D with shape ({self.shape[0]},), got\"\n                f\" {arr.shape}\"\n            )\n        self._max = arr\n\n    @property\n    def guess(self):\n        \"\"\"Get the initial guess for the variable trajectory.\n\n        The guess provides a starting point for the optimizer. A good initial guess\n        can significantly improve convergence speed and help avoid local minima.\n\n        Returns:\n            2D array of shape (n_points, n_vars) representing the variable trajectory\n            over time, or None if no guess is provided.\n\n        Example:\n                x = Variable(\"x\", shape=(2,))\n                # Linear interpolation from [0,0] to [10,10] over 50 points\n                x.guess = np.linspace([0, 0], [10, 10], 50)\n                print(x.guess.shape)  # (50, 2)\n        \"\"\"\n        return self._guess\n\n    @guess.setter\n    def guess(self, arr):\n        \"\"\"Set the initial guess for the variable trajectory.\n\n        The guess should be a 2D array where each row represents the variable value\n        at a particular time point or trajectory node.\n\n        Args:\n            arr: 2D array of shape (n_points, n_vars) where n_vars matches the\n                variable dimension. Can be fewer points than the final trajectory -\n                the solver will interpolate as needed.\n\n        Raises:\n            ValueError: If the array is not 2D or if the second dimension doesn't\n                match the variable dimension\n\n        Example:\n                pos = Variable(\"pos\", shape=(3,))\n                # Create a straight-line trajectory from origin to target\n                n_points = 50\n                pos.guess = np.linspace([0, 0, 0], [10, 5, 3], n_points)\n        \"\"\"\n        arr = np.asarray(arr, dtype=float)\n        if arr.ndim != 2:\n            raise ValueError(\n                f\"Guess must be a 2D array of shape (n_guess_points, {self.shape[0]}), got shape\"\n                f\" {arr.shape}\"\n            )\n        if arr.shape[1] != self.shape[0]:\n            raise ValueError(\n                f\"Guess must have second dimension equal to variable dimension {self.shape[0]}, got\"\n                f\" {arr.shape[1]}\"\n            )\n        self._guess = arr\n\n    def append(self, other=None, *, min=-np.inf, max=np.inf, guess=0.0):\n        \"\"\"Append a new dimension to this variable or merge with another variable.\n\n        This method extends the variable's dimension by either:\n        1. Appending another Variable object (concatenating their dimensions)\n        2. Adding a single new scalar dimension with specified bounds and guess\n\n        The bounds and guesses of both variables are concatenated appropriately.\n\n        Args:\n            other: Another Variable object to append. If None, adds a single scalar\n                dimension with the specified min/max/guess values.\n            min: Minimum bound for the new dimension (only used if other is None).\n                Defaults to -np.inf (unbounded below).\n            max: Maximum bound for the new dimension (only used if other is None).\n                Defaults to np.inf (unbounded above).\n            guess: Initial guess value for the new dimension (only used if other is None).\n                Defaults to 0.0.\n\n        Example:\n            Create a 2D variable and extend it to 3D:\n\n                pos_xy = Variable(\"pos\", shape=(2,))\n                pos_xy.min = [-10, -10]\n                pos_xy.max = [10, 10]\n                pos_xy.append(min=0, max=100)  # Add z dimension\n                print(pos_xy.shape)  # (3,)\n                print(pos_xy.min)  # [-10., -10., 0.]\n                print(pos_xy.max)  # [10., 10., 100.]\n\n            Merge two variables:\n\n                pos = Variable(\"pos\", shape=(3,))\n                vel = Variable(\"vel\", shape=(3,))\n                pos.append(vel)  # Now pos has shape (6,)\n        \"\"\"\n\n        def process_array(val, is_guess=False):\n            \"\"\"Process input array to ensure correct shape and type.\n\n            Args:\n                val: Input value to process\n                is_guess: Whether the value is a guess array\n\n            Returns:\n                Processed array with correct shape and type\n            \"\"\"\n            arr = np.asarray(val, dtype=float)\n            if is_guess:\n                return np.atleast_2d(arr)\n            return np.atleast_1d(arr)\n\n        if isinstance(other, Variable):\n            self._shape = (self.shape[0] + other.shape[0],)\n\n            if self._min is not None and other._min is not None:\n                self._min = np.concatenate([self._min, process_array(other._min)], axis=0)\n\n            if self._max is not None and other._max is not None:\n                self._max = np.concatenate([self._max, process_array(other._max)], axis=0)\n\n            if self._guess is not None and other._guess is not None:\n                self._guess = np.concatenate(\n                    [self._guess, process_array(other._guess, is_guess=True)], axis=1\n                )\n\n        else:\n            self._shape = (self.shape[0] + 1,)\n\n            if self._min is not None:\n                self._min = np.concatenate([self._min, process_array(min)], axis=0)\n\n            if self._max is not None:\n                self._max = np.concatenate([self._max, process_array(max)], axis=0)\n\n            if self._guess is not None:\n                guess_arr = process_array(guess, is_guess=True)\n                if guess_arr.shape[1] != 1:\n                    guess_arr = guess_arr.T\n                self._guess = np.concatenate([self._guess, guess_arr], axis=1)\n</code></pre>"},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable--typically-use-state-or-control-instead-of-variable-directly","title":"Typically, use State or Control instead of Variable directly:","text":"<p>pos = openscvx.State(\"pos\", shape=(3,)) u = openscvx.Control(\"u\", shape=(2,))</p>"},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable.guess","title":"<code>guess</code>  <code>property</code> <code>writable</code>","text":"<p>Get the initial guess for the variable trajectory.</p> <p>The guess provides a starting point for the optimizer. A good initial guess can significantly improve convergence speed and help avoid local minima.</p> <p>Returns:</p> Type Description <p>2D array of shape (n_points, n_vars) representing the variable trajectory</p> <p>over time, or None if no guess is provided.</p> Example <p>x = Variable(\"x\", shape=(2,))</p>"},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable.guess--linear-interpolation-from-00-to-1010-over-50-points","title":"Linear interpolation from [0,0] to [10,10] over 50 points","text":"<p>x.guess = np.linspace([0, 0], [10, 10], 50) print(x.guess.shape)  # (50, 2)</p>"},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable.max","title":"<code>max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the maximum bounds (upper bounds) for the variable.</p> <p>Returns:</p> Type Description <p>Array of maximum values for each element of the variable, or None if unbounded.</p> Example <p>vel = Variable(\"vel\", shape=(3,)) vel.max = [10, 10, 5] print(vel.max)  # [10., 10., 5.]</p>"},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable.min","title":"<code>min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the minimum bounds (lower bounds) for the variable.</p> <p>Returns:</p> Type Description <p>Array of minimum values for each element of the variable, or None if unbounded.</p> Example <p>pos = Variable(\"pos\", shape=(3,)) pos.min = [-10, -10, 0] print(pos.min)  # [-10., -10., 0.]</p>"},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable._hash_into","title":"<code>_hash_into(hasher: hashlib._Hash) -&gt; None</code>","text":"<p>Hash Variable using its slice (canonical position, name-invariant).</p> <p>Instead of hashing the variable name, we hash the _slice attribute which represents the variable's canonical position in the unified state/control vector. This ensures that two problems with the same structure but different variable names produce the same hash.</p> <p>Parameters:</p> Name Type Description Default <code>hasher</code> <code>_Hash</code> <p>A hashlib hash object to update</p> required Source code in <code>openscvx/symbolic/expr/variable.py</code> <pre><code>def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n    \"\"\"Hash Variable using its slice (canonical position, name-invariant).\n\n    Instead of hashing the variable name, we hash the _slice attribute\n    which represents the variable's canonical position in the unified\n    state/control vector. This ensures that two problems with the same\n    structure but different variable names produce the same hash.\n\n    Args:\n        hasher: A hashlib hash object to update\n    \"\"\"\n    hasher.update(self.__class__.__name__.encode())\n    hasher.update(str(self._shape).encode())\n    # Hash the slice (canonical position) - this is name-invariant\n    if self._slice is not None:\n        hasher.update(f\"slice:{self._slice.start}:{self._slice.stop}\".encode())\n    else:\n        raise RuntimeError(\n            f\"Cannot hash Variable '{self.name}' without _slice attribute. \"\n            \"Hashing should only be called on preprocessed problems where \"\n            \"all Variables have been assigned canonical slice positions.\"\n        )\n</code></pre>"},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable.append","title":"<code>append(other=None, *, min=-np.inf, max=np.inf, guess=0.0)</code>","text":"<p>Append a new dimension to this variable or merge with another variable.</p> <p>This method extends the variable's dimension by either: 1. Appending another Variable object (concatenating their dimensions) 2. Adding a single new scalar dimension with specified bounds and guess</p> <p>The bounds and guesses of both variables are concatenated appropriately.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>Another Variable object to append. If None, adds a single scalar dimension with the specified min/max/guess values.</p> <code>None</code> <code>min</code> <p>Minimum bound for the new dimension (only used if other is None). Defaults to -np.inf (unbounded below).</p> <code>-inf</code> <code>max</code> <p>Maximum bound for the new dimension (only used if other is None). Defaults to np.inf (unbounded above).</p> <code>inf</code> <code>guess</code> <p>Initial guess value for the new dimension (only used if other is None). Defaults to 0.0.</p> <code>0.0</code> Example <p>Create a 2D variable and extend it to 3D:</p> <pre><code>pos_xy = Variable(\"pos\", shape=(2,))\npos_xy.min = [-10, -10]\npos_xy.max = [10, 10]\npos_xy.append(min=0, max=100)  # Add z dimension\nprint(pos_xy.shape)  # (3,)\nprint(pos_xy.min)  # [-10., -10., 0.]\nprint(pos_xy.max)  # [10., 10., 100.]\n</code></pre> <p>Merge two variables:</p> <pre><code>pos = Variable(\"pos\", shape=(3,))\nvel = Variable(\"vel\", shape=(3,))\npos.append(vel)  # Now pos has shape (6,)\n</code></pre> Source code in <code>openscvx/symbolic/expr/variable.py</code> <pre><code>def append(self, other=None, *, min=-np.inf, max=np.inf, guess=0.0):\n    \"\"\"Append a new dimension to this variable or merge with another variable.\n\n    This method extends the variable's dimension by either:\n    1. Appending another Variable object (concatenating their dimensions)\n    2. Adding a single new scalar dimension with specified bounds and guess\n\n    The bounds and guesses of both variables are concatenated appropriately.\n\n    Args:\n        other: Another Variable object to append. If None, adds a single scalar\n            dimension with the specified min/max/guess values.\n        min: Minimum bound for the new dimension (only used if other is None).\n            Defaults to -np.inf (unbounded below).\n        max: Maximum bound for the new dimension (only used if other is None).\n            Defaults to np.inf (unbounded above).\n        guess: Initial guess value for the new dimension (only used if other is None).\n            Defaults to 0.0.\n\n    Example:\n        Create a 2D variable and extend it to 3D:\n\n            pos_xy = Variable(\"pos\", shape=(2,))\n            pos_xy.min = [-10, -10]\n            pos_xy.max = [10, 10]\n            pos_xy.append(min=0, max=100)  # Add z dimension\n            print(pos_xy.shape)  # (3,)\n            print(pos_xy.min)  # [-10., -10., 0.]\n            print(pos_xy.max)  # [10., 10., 100.]\n\n        Merge two variables:\n\n            pos = Variable(\"pos\", shape=(3,))\n            vel = Variable(\"vel\", shape=(3,))\n            pos.append(vel)  # Now pos has shape (6,)\n    \"\"\"\n\n    def process_array(val, is_guess=False):\n        \"\"\"Process input array to ensure correct shape and type.\n\n        Args:\n            val: Input value to process\n            is_guess: Whether the value is a guess array\n\n        Returns:\n            Processed array with correct shape and type\n        \"\"\"\n        arr = np.asarray(val, dtype=float)\n        if is_guess:\n            return np.atleast_2d(arr)\n        return np.atleast_1d(arr)\n\n    if isinstance(other, Variable):\n        self._shape = (self.shape[0] + other.shape[0],)\n\n        if self._min is not None and other._min is not None:\n            self._min = np.concatenate([self._min, process_array(other._min)], axis=0)\n\n        if self._max is not None and other._max is not None:\n            self._max = np.concatenate([self._max, process_array(other._max)], axis=0)\n\n        if self._guess is not None and other._guess is not None:\n            self._guess = np.concatenate(\n                [self._guess, process_array(other._guess, is_guess=True)], axis=1\n            )\n\n    else:\n        self._shape = (self.shape[0] + 1,)\n\n        if self._min is not None:\n            self._min = np.concatenate([self._min, process_array(min)], axis=0)\n\n        if self._max is not None:\n            self._max = np.concatenate([self._max, process_array(max)], axis=0)\n\n        if self._guess is not None:\n            guess_arr = process_array(guess, is_guess=True)\n            if guess_arr.shape[1] != 1:\n                guess_arr = guess_arr.T\n            self._guess = np.concatenate([self._guess, guess_arr], axis=1)\n</code></pre>"},{"location":"reference/symbolic/lowerers/","title":"lowerers","text":"<p>Lowering backends for converting symbolic expressions to executable code.</p> <p>This package contains backend implementations that translate openscvx's symbolic expression AST into executable code for different computational frameworks. The lowering process is a compilation step that happens after symbolic problem construction but before numerical optimization.</p> Architecture <p>All lowerers in this package follow a common visitor pattern:</p> <ol> <li>Visitor Pattern: Each backend defines visitor methods for each expression    type, registered via the @visitor decorator</li> <li>Recursive Lowering: Visitors recursively lower child expressions and    compose backend-specific operations</li> <li>Centralized Dispatch: The dispatch() function routes expressions to    their registered visitor methods</li> <li>Type Safety: Each visitor is strongly typed to its backend's output format</li> </ol> Available Backends <ul> <li>jax: Lowers to JAX functions with automatic differentiation support</li> <li>cvxpy: Lowers to CVXPy expressions for disciplined convex programming</li> </ul> <p>See individual backend modules for detailed documentation and usage examples.</p> For Contributors <p>Adding a New Backend</p> <p>To add a new lowering backend:</p> <ol> <li> <p>Create a new module in this package (e.g., <code>mybackend.py</code>)</p> </li> <li> <p>Implement the visitor pattern::</p> <p>from typing import Dict, Type, Callable, Any from openscvx.symbolic.expr import Expr</p> <p>_MYBACKEND_VISITORS: Dict[Type[Expr], Callable] = {}</p> <p>def visitor(expr_cls: Type[Expr]):     '''Decorator to register visitor methods.'''     def register(fn: Callable):         _MYBACKEND_VISITORS[expr_cls] = fn         return fn     return register</p> <p>def dispatch(lowerer: Any, expr: Expr):     '''Dispatch expression to registered visitor.'''     fn = MYBACKEND_VISITORS.get(type(expr))     if fn is None:         raise NotImplementedError(             f\"{lowerer.__class_.name} has no visitor for {type(expr).name}\"         )     return fn(lowerer, expr)</p> </li> <li> <p>Create the lowerer class::</p> <p>class MyBackendLowerer:     '''Lower symbolic expressions to MyBackend format.'''</p> <pre><code>def lower(self, expr: Expr):\n    '''Main entry point for lowering.'''\n    return dispatch(self, expr)\n\n@visitor(Constant)\ndef _visit_constant(self, node: Constant):\n    # Convert to backend representation\n    return mybackend.constant(node.value)\n\n@visitor(Add)\ndef _visit_add(self, node: Add):\n    # Recursively lower and combine\n    terms = [self.lower(t) for t in node.terms]\n    return mybackend.add(*terms)\n\n# Implement visitors for all expression types...\n</code></pre> </li> <li> <p>Add convenience wrapper::</p> <p>def lower_to_mybackend(expr: Expr, **kwargs):     '''Convenience function for lowering to MyBackend.'''     lowerer = MyBackendLowerer(**kwargs)     return lowerer.lower(expr)</p> </li> <li> <p>Document thoroughly - Follow the documentation patterns in jax.py    and cvxpy.py, including module docstring, class docstring, and method    docstrings for all visitor methods.</p> </li> </ol> <p>Key Design Patterns</p> <ul> <li>Use private method names for visitors: <code>_visit_*</code> (not part of public API)</li> <li>Recursively lower child expressions using <code>self.lower()</code></li> <li>Keep visitor methods stateless when possible</li> <li>Handle edge cases (scalars, empty arrays, etc.)</li> <li>Document mathematical properties and backend-specific constraints</li> </ul> <p>Adding Support for New Expression Types</p> <p>See the \"For Contributors\" sections in the existing backend modules for detailed guidance on adding visitor methods for new expression types.</p> See Also <ul> <li>openscvx.symbolic.lower: Main lowering orchestration functions</li> <li>openscvx.symbolic.expr: Symbolic expression AST definitions</li> <li>openscvx.symbolic.lowerers.jax: JAX backend documentation and implementation</li> <li>openscvx.symbolic.lowerers.cvxpy: CVXPy backend documentation and implementation</li> </ul>"},{"location":"reference/symbolic/lowerers/cvxpy/","title":"cvxpy","text":"<p>CVXPy backend for lowering symbolic expressions to CVXPy format.</p> <p>This module implements the CVXPy lowering backend that converts symbolic expression AST nodes into CVXPy expressions for convex optimization. The lowering uses a visitor pattern where each expression type has a corresponding visitor method.</p> Architecture <p>The CVXPy lowerer follows a visitor pattern with centralized registration:</p> <ol> <li>Visitor Registration: The @visitor decorator registers handler functions    for each expression type in the _CVXPY_VISITORS dictionary</li> <li>Dispatch: The dispatch() function looks up and calls the appropriate    visitor based on the expression's type</li> <li>Recursive Lowering: Each visitor recursively lowers child expressions    and composes CVXPy operations</li> <li>Translation Only: This module only translates expressions; CVXPy itself    validates DCP (Disciplined Convex Programming) rules when the problem is    constructed/solved</li> </ol> Key Features <ul> <li>Expression Translation: Converts symbolic AST to CVXPy expression format</li> <li>Variable Management: Maps symbolic States/Controls to CVXPy variables   through a variable_map dictionary</li> <li>Parameter Support: Handles both constant parameters and CVXPy Parameters   for efficient parameter sweeps</li> <li>Constraint Generation: Produces CVXPy constraint objects from symbolic   equality and inequality expressions</li> </ul> Backend Usage <p>CVXPy lowering is used for convex constraints in the SCP subproblem. Unlike JAX lowering (which happens early during problem construction), CVXPy lowering occurs later during Problem.initialize() when CVXPy variables are available. See lower_symbolic_expressions() in symbolic/lower.py for details.</p> CVXPy Variable Mapping <p>The lowerer requires a variable_map dictionary that maps symbolic variable names to CVXPy expressions. For trajectory optimization::</p> <pre><code>variable_map = {\n    \"x\": cvxpy.Variable((n_x,)),  # State vector\n    \"u\": cvxpy.Variable((n_u,)),  # Control vector\n    \"param_name\": cvxpy.Parameter((3,)),  # Runtime parameters\n}\n</code></pre> <p>States and Controls use their slices (assigned during unification) to extract the correct portion of the unified x and u vectors.</p> Example <p>Basic usage::</p> <pre><code>import cvxpy as cp\nfrom openscvx.symbolic.lowerers.cvxpy import CvxpyLowerer\nimport openscvx as ox\n\n# Create symbolic expression\nx = ox.State(\"x\", shape=(3,))\nu = ox.Control(\"u\", shape=(2,))\nexpr = ox.Norm(x)**2 + 0.1 * ox.Norm(u)**2\n\n# Create CVXPy variables\ncvx_x = cp.Variable(3)\ncvx_u = cp.Variable(2)\n\n# Lower to CVXPy\nlowerer = CvxpyLowerer(variable_map={\"x\": cvx_x, \"u\": cvx_u})\ncvx_expr = lowerer.lower(expr)\n\n# Use in optimization problem\nprob = cp.Problem(cp.Minimize(cvx_expr), constraints=[...])\nprob.solve()\n</code></pre> <p>Constraint lowering::</p> <pre><code># Symbolic constraint\nconstraint = ox.Norm(x) &lt;= 1.0\n\n# Lower to CVXPy constraint\ncvx_constraint = lowerer.lower(constraint)\n\n# Add to problem\nprob = cp.Problem(cp.Minimize(cost), constraints=[cvx_constraint])\n</code></pre> For Contributors <p>Adding Support for New Expression Types</p> <p>To add support for a new symbolic expression type to CVXPy lowering:</p> <ol> <li> <p>Define the visitor method in CvxpyLowerer with the @visitor decorator::</p> <p>@visitor(MyNewExpr) def _visit_my_new_expr(self, node: MyNewExpr) -&gt; cp.Expression:     # Lower child expressions recursively     operand = self.lower(node.operand)</p> <pre><code># Return CVXPy expression\nreturn cp.my_operation(operand)\n</code></pre> </li> <li> <p>Key requirements:</p> <ul> <li>Use the @visitor(ExprType) decorator to register the handler</li> <li>Method name should be visit (private, lowercase, snake_case) <li>Recursively lower all child expressions using self.lower()</li> <li>Return a cp.Expression or cp.Constraint object</li> <li>Use cp.* operations for CVXPy atoms</li> <li> <p>DCP considerations:</p> <ul> <li>This module only translates; CVXPy validates DCP rules</li> <li>Document the mathematical properties in the docstring (convex, concave, affine)</li> <li>For non-DCP operations, raise NotImplementedError with helpful message</li> <li>See _visit_sin, _visit_cos, _visit_ctcs for examples</li> </ul> </li> <li> <p>Example patterns:</p> <ul> <li>Unary operation: <code>return cp.my_func(self.lower(node.operand))</code></li> <li>Binary operation: <code>return self.lower(node.left) + self.lower(node.right)</code></li> <li>Constraints: <code>return self.lower(node.lhs) &lt;= self.lower(node.rhs)</code></li> <li>Not supported: Raise NotImplementedError with guidance</li> </ul> </li> <li> <p>Testing: Ensure your visitor works with:</p> <ul> <li>Simple expressions: Direct lowering to cp.Expression</li> <li>Constraint validation: CVXPy accepts the result</li> <li>DCP checking: CVXPy's problem.solve() validates correctly</li> </ul> </li> See Also <ul> <li>lower_to_cvxpy(): Convenience wrapper for single expression lowering</li> <li>JaxLowerer: Alternative backend for non-convex constraints and dynamics</li> <li>lower_symbolic_expressions(): Main orchestrator in symbolic/lower.py</li> <li>CVXPy documentation: https://www.cvxpy.org/</li> </ul>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy._CVXPY_VISITORS","title":"<code>_CVXPY_VISITORS: Dict[Type[Expr], Callable] = {}</code>  <code>module-attribute</code>","text":"<p>Registry mapping expression types to their visitor functions.</p>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer","title":"<code>CvxpyLowerer</code>","text":"<p>CVXPy backend for lowering symbolic expressions to disciplined convex programs.</p> <p>This class implements the visitor pattern for converting symbolic expression AST nodes to CVXPy expressions and constraints. Each expression type has a corresponding visitor method decorated with @visitor that handles the lowering logic.</p> <p>The lowering process is recursive: each visitor lowers its child expressions first, then composes them into a CVXPy operation. CVXPy will validate DCP (Disciplined Convex Programming) compliance when the problem is constructed.</p> <p>Attributes:</p> Name Type Description <code>variable_map</code> <code>dict</code> <p>Dictionary mapping variable names to CVXPy expressions. Must include \"x\" for states and \"u\" for controls. May include parameter names mapped to CVXPy Parameter objects or constants.</p> Example <p>Lower an expression to CVXPy:</p> <pre><code>import cvxpy as cp\nlowerer = CvxpyLowerer(variable_map={\n    \"x\": cp.Variable(3),\n    \"u\": cp.Variable(2),\n})\nexpr = ox.Norm(x)**2 + 0.1 * ox.Norm(u)**2\ncvx_expr = lowerer.lower(expr)\n</code></pre> Note <p>The lowerer is stateful (stores variable_map) unlike JaxLowerer which is stateless. Variables must be registered before lowering expressions that reference them.</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>class CvxpyLowerer:\n    \"\"\"CVXPy backend for lowering symbolic expressions to disciplined convex programs.\n\n    This class implements the visitor pattern for converting symbolic expression\n    AST nodes to CVXPy expressions and constraints. Each expression type has a\n    corresponding visitor method decorated with @visitor that handles the lowering\n    logic.\n\n    The lowering process is recursive: each visitor lowers its child expressions\n    first, then composes them into a CVXPy operation. CVXPy will validate DCP\n    (Disciplined Convex Programming) compliance when the problem is constructed.\n\n    Attributes:\n        variable_map (dict): Dictionary mapping variable names to CVXPy expressions.\n            Must include \"x\" for states and \"u\" for controls. May include parameter\n            names mapped to CVXPy Parameter objects or constants.\n\n    Example:\n        Lower an expression to CVXPy:\n\n            import cvxpy as cp\n            lowerer = CvxpyLowerer(variable_map={\n                \"x\": cp.Variable(3),\n                \"u\": cp.Variable(2),\n            })\n            expr = ox.Norm(x)**2 + 0.1 * ox.Norm(u)**2\n            cvx_expr = lowerer.lower(expr)\n\n    Note:\n        The lowerer is stateful (stores variable_map) unlike JaxLowerer which\n        is stateless. Variables must be registered before lowering expressions\n        that reference them.\n    \"\"\"\n\n    def __init__(self, variable_map: Dict[str, cp.Expression] = None):\n        \"\"\"Initialize the CVXPy lowerer.\n\n        Args:\n            variable_map: Dictionary mapping variable names to CVXPy expressions.\n                For State/Control objects, keys should be \"x\" and \"u\" respectively.\n                For Parameter objects, keys should match their names. If None, an\n                empty dictionary is created.\n\n        Example:\n            Initialize the CVXPy lowerer with the variable map:\n\n                cvx_x = cp.Variable(3, name=\"x\")\n                cvx_u = cp.Variable(2, name=\"u\")\n                lowerer = CvxpyLowerer({\"x\": cvx_x, \"u\": cvx_u})\n        \"\"\"\n        self.variable_map = variable_map or {}\n\n    def lower(self, expr: Expr) -&gt; cp.Expression:\n        \"\"\"Lower a symbolic expression to a CVXPy expression.\n\n        Main entry point for lowering. Delegates to dispatch() which looks up\n        the appropriate visitor method based on the expression type.\n\n        Args:\n            expr: Symbolic expression to lower (any Expr subclass)\n\n        Returns:\n            CVXPy expression or constraint object. For arithmetic expressions,\n            returns cp.Expression. For Equality/Inequality, returns cp.Constraint.\n\n        Raises:\n            NotImplementedError: If no visitor exists for the expression type\n            ValueError: If required variables are not in variable_map\n\n        Example:\n            Lower an expression to a CVXPy expression:\n\n                lowerer = CvxpyLowerer(variable_map={\"x\": cvx_x, \"u\": cvx_u})\n                x = ox.State(\"x\", shape=(3,))\n                expr = ox.Norm(x)\n                cvx_expr = lowerer.lower(expr)\n        \"\"\"\n        return dispatch(self, expr)\n\n    def register_variable(self, name: str, cvx_expr: cp.Expression):\n        \"\"\"Register a CVXPy variable/expression for use in lowering.\n\n        Adds or updates a variable in the variable_map. Useful for dynamically\n        adding variables after the lowerer has been created.\n\n        Args:\n            name: Variable name (e.g., \"x\", \"u\", or parameter name)\n            cvx_expr: CVXPy expression to associate with the name\n\n        Example:\n            Register a variable:\n\n                lowerer = CvxpyLowerer()\n                lowerer.register_variable(\"x\", cp.Variable(3))\n                lowerer.register_variable(\"obs_center\", cp.Parameter(3))\n        \"\"\"\n        self.variable_map[name] = cvx_expr\n\n    @visitor(Constant)\n    def _visit_constant(self, node: Constant) -&gt; cp.Expression:\n        \"\"\"Lower a constant value to a CVXPy constant.\n\n        Wraps the constant's numpy array value in a CVXPy Constant expression.\n\n        Args:\n            node: Constant expression node\n\n        Returns:\n            CVXPy constant expression wrapping the value\n        \"\"\"\n        return cp.Constant(node.value)\n\n    @visitor(State)\n    def _visit_state(self, node: State) -&gt; cp.Expression:\n        \"\"\"Lower a state variable to a CVXPy expression.\n\n        Extracts the appropriate slice from the unified state vector \"x\" using\n        the slice assigned during unification. The \"x\" variable must exist in\n        the variable_map.\n\n        Args:\n            node: State expression node\n\n        Returns:\n            CVXPy expression representing the state slice: x[slice]\n\n        Raises:\n            ValueError: If \"x\" is not found in variable_map\n        \"\"\"\n        if \"x\" not in self.variable_map:\n            raise ValueError(\"State vector 'x' not found in variable_map.\")\n\n        cvx_var = self.variable_map[\"x\"]\n\n        # If the state has a slice assigned, apply it\n        if node._slice is not None:\n            return cvx_var[node._slice]\n        return cvx_var\n\n    @visitor(Control)\n    def _visit_control(self, node: Control) -&gt; cp.Expression:\n        \"\"\"Lower a control variable to a CVXPy expression.\n\n        Extracts the appropriate slice from the unified control vector \"u\" using\n        the slice assigned during unification. The \"u\" variable must exist in\n        the variable_map.\n\n        Args:\n            node: Control expression node\n\n        Returns:\n            CVXPy expression representing the control slice: u[slice]\n\n        Raises:\n            ValueError: If \"u\" is not found in variable_map\n        \"\"\"\n        if \"u\" not in self.variable_map:\n            raise ValueError(\"Control vector 'u' not found in variable_map.\")\n\n        cvx_var = self.variable_map[\"u\"]\n\n        # If the control has a slice assigned, apply it\n        if node._slice is not None:\n            return cvx_var[node._slice]\n        return cvx_var\n\n    @visitor(NodeReference)\n    def _visit_node_reference(self, node: \"NodeReference\") -&gt; cp.Expression:\n        \"\"\"Lower NodeReference - extract value at a specific trajectory node.\n\n        NodeReference enables cross-node constraints by referencing state/control\n        values at specific discrete time points. This requires the variable_map to\n        contain full trajectory arrays (N, n_x) or (N, n_u) rather than single-node\n        vectors.\n\n        Args:\n            node: NodeReference expression with base and node_idx\n\n        Returns:\n            CVXPy expression representing the variable at the specified node:\n            x[node_idx, slice] or u[node_idx, slice]\n\n        Raises:\n            ValueError: If the required trajectory variable is not in variable_map\n            ValueError: If the base variable has no slice assigned\n            NotImplementedError: If the base is a compound expression\n\n        Example:\n            For cross-node constraint: position.at(5) - position.at(4) &lt;= 0.1\n\n            variable_map = {\n                \"x\": cp.vstack([x_nonscaled[k] for k in range(N)]),  # (N, n_x)\n            }\n            # position.at(5) lowers to x[5, position._slice]\n\n        Note:\n            The node_idx is already resolved to an absolute integer index during\n            expression construction, so negative indices are already handled.\n        \"\"\"\n        from openscvx.symbolic.expr.control import Control\n        from openscvx.symbolic.expr.state import State\n\n        idx = node.node_idx\n\n        if isinstance(node.base, State):\n            if \"x\" not in self.variable_map:\n                raise ValueError(\n                    \"State vector 'x' not found in variable_map. \"\n                    \"For cross-node constraints, 'x' must be the full trajectory (N, n_x).\"\n                )\n\n            cvx_var = self.variable_map[\"x\"]  # Should be (N, n_x) for cross-node constraints\n\n            # Apply slice if state has one assigned\n            if node.base._slice is not None:\n                return cvx_var[idx, node.base._slice]\n            else:\n                # No slice means this is the entire unified state vector\n                return cvx_var[idx, :]\n\n        elif isinstance(node.base, Control):\n            if \"u\" not in self.variable_map:\n                raise ValueError(\n                    \"Control vector 'u' not found in variable_map. \"\n                    \"For cross-node constraints, 'u' must be the full trajectory (N, n_u).\"\n                )\n\n            cvx_var = self.variable_map[\"u\"]  # Should be (N, n_u) for cross-node constraints\n\n            # Apply slice if control has one assigned\n            if node.base._slice is not None:\n                return cvx_var[idx, node.base._slice]\n            else:\n                # No slice means this is the entire unified control vector\n                return cvx_var[idx, :]\n\n        else:\n            # Compound expression (e.g., position[0].at(5))\n            # This is more complex - would need to lower base in single-node context\n            raise NotImplementedError(\n                \"Compound expressions in NodeReference are not yet supported for CVXPy lowering. \"\n                f\"Base expression type: {type(node.base).__name__}. \"\n                \"Only State and Control NodeReferences are currently supported.\"\n            )\n\n    @visitor(CrossNodeConstraint)\n    def _visit_cross_node_constraint(self, node: CrossNodeConstraint) -&gt; cp.Constraint:\n        \"\"\"Lower CrossNodeConstraint to CVXPy constraint.\n\n        CrossNodeConstraint wraps constraints that reference multiple trajectory\n        nodes via NodeReference (e.g., rate limits like x.at(k) - x.at(k-1) &lt;= r).\n\n        For CVXPy lowering, this simply lowers the inner constraint. The NodeReference\n        nodes within the constraint will handle extracting values from the full\n        trajectory arrays (which must be provided in variable_map as \"x\" and \"u\").\n\n        Args:\n            node: CrossNodeConstraint expression wrapping the inner constraint\n\n        Returns:\n            CVXPy constraint object\n\n        Note:\n            The variable_map must contain full trajectory arrays:\n                - \"x\": (N, n_x) CVXPy expression (e.g., cp.vstack(x_nonscaled))\n                - \"u\": (N, n_u) CVXPy expression (e.g., cp.vstack(u_nonscaled))\n\n            NodeReference visitors will index into these arrays using the fixed\n            node indices baked into the expression.\n\n        Example:\n            For constraint: position.at(5) - position.at(4) &lt;= max_step\n\n            With variable_map = {\"x\": cp.vstack([x[k] for k in range(N)])}\n\n            The lowered constraint evaluates:\n                x[5, pos_slice] - x[4, pos_slice] &lt;= max_step\n        \"\"\"\n        # Simply lower the inner constraint - NodeReference handles indexing\n        return self.lower(node.constraint)\n\n    @visitor(Parameter)\n    def _visit_parameter(self, node: Parameter) -&gt; cp.Expression:\n        \"\"\"Lower a parameter to a CVXPy expression.\n\n        Parameters are looked up by name in the variable_map. They can be mapped\n        to CVXPy Parameter objects (for efficient parameter sweeps) or constants.\n\n        Args:\n            node: Parameter expression node\n\n        Returns:\n            CVXPy expression from variable_map (Parameter or constant)\n\n        Raises:\n            ValueError: If parameter name is not found in variable_map\n\n        Note:\n            For parameter sweeps without recompilation, map to cp.Parameter.\n            For fixed values, map to cp.Constant or numpy arrays.\n        \"\"\"\n        param_name = node.name\n        if param_name in self.variable_map:\n            return self.variable_map[param_name]\n        else:\n            raise ValueError(\n                f\"Parameter '{param_name}' not found in variable_map. \"\n                f\"Add it during CVXPy lowering or use cp.Parameter for parameter sweeps.\"\n            )\n\n    @visitor(Add)\n    def _visit_add(self, node: Add) -&gt; cp.Expression:\n        \"\"\"Lower addition to CVXPy expression.\n\n        Recursively lowers all terms and composes them with element-wise addition.\n        Addition is affine and always DCP-compliant.\n\n        Args:\n            node: Add expression node with multiple terms\n\n        Returns:\n            CVXPy expression representing the sum of all terms\n        \"\"\"\n        terms = [self.lower(term) for term in node.terms]\n        result = terms[0]\n        for term in terms[1:]:\n            result = result + term\n        return result\n\n    @visitor(Sub)\n    def _visit_sub(self, node: Sub) -&gt; cp.Expression:\n        \"\"\"Lower subtraction to CVXPy expression (element-wise left - right).\n\n        Subtraction is affine and always DCP-compliant.\n\n        Args:\n            node: Sub expression node\n\n        Returns:\n            CVXPy expression representing left - right\n        \"\"\"\n        left = self.lower(node.left)\n        right = self.lower(node.right)\n        return left - right\n\n    @visitor(Mul)\n    def _visit_mul(self, node: Mul) -&gt; cp.Expression:\n        \"\"\"Lower element-wise multiplication to CVXPy expression.\n\n        Element-wise multiplication is DCP-compliant when at least one operand\n        is constant. For quadratic forms, use MatMul instead.\n\n        Args:\n            node: Mul expression node with multiple factors\n\n        Returns:\n            CVXPy expression representing element-wise product\n\n        Note:\n            For convex optimization, typically one factor should be constant.\n            CVXPy will raise a DCP error if the composition violates DCP rules.\n        \"\"\"\n        factors = [self.lower(factor) for factor in node.factors]\n        result = factors[0]\n        for factor in factors[1:]:\n            result = result * factor\n        return result\n\n    @visitor(Div)\n    def _visit_div(self, node: Div) -&gt; cp.Expression:\n        \"\"\"Lower element-wise division to CVXPy expression.\n\n        Division is DCP-compliant when the denominator is constant or when\n        the numerator is constant and the denominator is concave.\n\n        Args:\n            node: Div expression node\n\n        Returns:\n            CVXPy expression representing left / right\n\n        Note:\n            CVXPy will raise a DCP error if the division violates DCP rules.\n        \"\"\"\n        left = self.lower(node.left)\n        right = self.lower(node.right)\n        return left / right\n\n    @visitor(MatMul)\n    def _visit_matmul(self, node: MatMul) -&gt; cp.Expression:\n        \"\"\"Lower matrix multiplication to CVXPy expression using @ operator.\n\n        Matrix multiplication is DCP-compliant when at least one operand is\n        constant. Used for quadratic forms like x.T @ Q @ x.\n\n        Args:\n            node: MatMul expression node\n\n        Returns:\n            CVXPy expression representing left @ right\n        \"\"\"\n        left = self.lower(node.left)\n        right = self.lower(node.right)\n        return left @ right\n\n    @visitor(Neg)\n    def _visit_neg(self, node: Neg) -&gt; cp.Expression:\n        \"\"\"Lower negation (unary minus) to CVXPy expression.\n\n        Negation preserves DCP properties (negating convex gives concave).\n\n        Args:\n            node: Neg expression node\n\n        Returns:\n            CVXPy expression representing -operand\n        \"\"\"\n        operand = self.lower(node.operand)\n        return -operand\n\n    @visitor(Sum)\n    def _visit_sum(self, node: Sum) -&gt; cp.Expression:\n        \"\"\"Lower sum reduction to CVXPy expression (sums all elements).\n\n        Sum preserves DCP properties (sum of convex is convex).\n\n        Args:\n            node: Sum expression node\n\n        Returns:\n            CVXPy scalar expression representing the sum of all elements\n        \"\"\"\n        operand = self.lower(node.operand)\n        return cp.sum(operand)\n\n    @visitor(Norm)\n    def _visit_norm(self, node: Norm) -&gt; cp.Expression:\n        \"\"\"Lower norm operation to CVXPy expression.\n\n        Norms are convex functions and commonly used in convex optimization.\n        Supports all CVXPy norm types (1, 2, inf, \"fro\", etc.).\n\n        Args:\n            node: Norm expression node with ord attribute\n\n        Returns:\n            CVXPy expression representing the norm of the operand\n\n        Note:\n            Common norms: ord=2 (Euclidean), ord=1 (Manhattan), ord=\"inf\"\n        \"\"\"\n        operand = self.lower(node.operand)\n        return cp.norm(operand, node.ord)\n\n    @visitor(Index)\n    def _visit_index(self, node: Index) -&gt; cp.Expression:\n        \"\"\"Lower indexing/slicing operation to CVXPy expression.\n\n        Indexing preserves DCP properties (indexing into convex is convex).\n\n        Args:\n            node: Index expression node\n\n        Returns:\n            CVXPy expression representing base[index]\n        \"\"\"\n        base = self.lower(node.base)\n        return base[node.index]\n\n    @visitor(Concat)\n    def _visit_concat(self, node: Concat) -&gt; cp.Expression:\n        \"\"\"Lower concatenation to CVXPy expression.\n\n        Concatenates expressions horizontally along axis 0. Scalars are\n        promoted to 1D arrays before concatenation. Preserves DCP properties.\n\n        Args:\n            node: Concat expression node\n\n        Returns:\n            CVXPy expression representing horizontal concatenation\n\n        Note:\n            Uses cp.hstack for concatenation. Scalars are reshaped to (1,).\n        \"\"\"\n        exprs = [self.lower(child) for child in node.exprs]\n        # Ensure all expressions are at least 1D for concatenation\n        exprs_1d = []\n        for expr in exprs:\n            if expr.ndim == 0:  # scalar\n                exprs_1d.append(cp.reshape(expr, (1,), order=\"C\"))\n            else:\n                exprs_1d.append(expr)\n        return cp.hstack(exprs_1d)\n\n    @visitor(Sin)\n    def _visit_sin(self, node: Sin) -&gt; cp.Expression:\n        \"\"\"Raise NotImplementedError for sine function.\n\n        Sine is not DCP-compliant in CVXPy as it is neither convex nor concave.\n\n        Args:\n            node: Sin expression node\n\n        Raises:\n            NotImplementedError: Always raised since sine is not DCP-compliant\n\n        Note:\n            For constraints involving trigonometric functions:\n            - Use piecewise-linear approximations, or\n            - Handle in the JAX dynamics/constraint layer instead of CVXPy\n        \"\"\"\n        raise NotImplementedError(\n            \"Trigonometric functions like Sin are not DCP-compliant in CVXPy. \"\n            \"Consider using piecewise-linear approximations or handle these constraints \"\n            \"in the dynamics (JAX) layer instead.\"\n        )\n\n    @visitor(Cos)\n    def _visit_cos(self, node: Cos) -&gt; cp.Expression:\n        \"\"\"Raise NotImplementedError for cosine function.\n\n        Cosine is not DCP-compliant in CVXPy as it is neither convex nor concave.\n\n        Args:\n            node: Cos expression node\n\n        Raises:\n            NotImplementedError: Always raised since cosine is not DCP-compliant\n\n        Note:\n            For constraints involving trigonometric functions:\n            - Use piecewise-linear approximations, or\n            - Handle in the JAX dynamics/constraint layer instead of CVXPy\n        \"\"\"\n        raise NotImplementedError(\n            \"Trigonometric functions like Cos are not DCP-compliant in CVXPy. \"\n            \"Consider using piecewise-linear approximations or handle these constraints \"\n            \"in the dynamics (JAX) layer instead.\"\n        )\n\n    @visitor(Tan)\n    def _visit_tan(self, node: Tan) -&gt; cp.Expression:\n        \"\"\"Raise NotImplementedError for tangent function.\n\n        Tangent is not DCP-compliant in CVXPy as it is neither convex nor concave.\n\n        Args:\n            node: Tan expression node\n\n        Raises:\n            NotImplementedError: Always raised since tangent is not DCP-compliant\n\n        Note:\n            For constraints involving trigonometric functions:\n            - Use piecewise-linear approximations, or\n            - Handle in the JAX dynamics/constraint layer instead of CVXPy\n        \"\"\"\n        raise NotImplementedError(\n            \"Trigonometric functions like Tan are not DCP-compliant in CVXPy. \"\n            \"Consider using piecewise-linear approximations or handle these constraints \"\n            \"in the dynamics (JAX) layer instead.\"\n        )\n\n    @visitor(Exp)\n    def _visit_exp(self, node: Exp) -&gt; cp.Expression:\n        \"\"\"Lower exponential function to CVXPy expression.\n\n        Exponential is a convex function and DCP-compliant when used in\n        appropriate contexts (e.g., minimizing exp(x) or constraints like\n        exp(x) &lt;= c).\n\n        Args:\n            node: Exp expression node\n\n        Returns:\n            CVXPy expression representing exp(operand)\n\n        Note:\n            Exponential is convex increasing, so it's valid in:\n            - Objective: minimize exp(x)\n            - Constraints: exp(x) &lt;= c (convex constraint)\n        \"\"\"\n        operand = self.lower(node.operand)\n        return cp.exp(operand)\n\n    @visitor(Log)\n    def _visit_log(self, node: Log) -&gt; cp.Expression:\n        \"\"\"Lower natural logarithm to CVXPy expression.\n\n        Logarithm is a concave function and DCP-compliant when used in\n        appropriate contexts (e.g., maximizing log(x) or constraints like\n        log(x) &gt;= c).\n\n        Args:\n            node: Log expression node\n\n        Returns:\n            CVXPy expression representing log(operand)\n\n        Note:\n            Logarithm is concave increasing, so it's valid in:\n            - Objective: maximize log(x)\n            - Constraints: log(x) &gt;= c (concave constraint, or equivalently c &lt;= log(x))\n        \"\"\"\n        operand = self.lower(node.operand)\n        return cp.log(operand)\n\n    @visitor(Abs)\n    def _visit_abs(self, node: Abs) -&gt; cp.Expression:\n        \"\"\"Lower absolute value to CVXPy expression.\n\n        Absolute value is a convex function and DCP-compliant when used in\n        appropriate contexts (e.g., minimizing |x| or constraints like |x| &lt;= c).\n\n        Args:\n            node: Abs expression node\n\n        Returns:\n            CVXPy expression representing |operand|\n\n        Note:\n            Absolute value is convex, so it's valid in:\n            - Objective: minimize abs(x)\n            - Constraints: abs(x) &lt;= c (convex constraint)\n        \"\"\"\n        operand = self.lower(node.operand)\n        return cp.abs(operand)\n\n    @visitor(Equality)\n    def _visit_equality(self, node: Equality) -&gt; cp.Constraint:\n        \"\"\"Lower equality constraint to CVXPy constraint (lhs == rhs).\n\n        Equality constraints require affine expressions on both sides for\n        DCP compliance.\n\n        Args:\n            node: Equality constraint node\n\n        Returns:\n            CVXPy equality constraint object\n\n        Note:\n            For DCP compliance, both lhs and rhs must be affine. CVXPy will\n            raise a DCP error if either side is non-affine.\n        \"\"\"\n        left = self.lower(node.lhs)\n        right = self.lower(node.rhs)\n        return left == right\n\n    @visitor(Inequality)\n    def _visit_inequality(self, node: Inequality) -&gt; cp.Constraint:\n        \"\"\"Lower inequality constraint to CVXPy constraint (lhs &lt;= rhs).\n\n        Inequality constraints must satisfy DCP rules: convex &lt;= concave.\n\n        Args:\n            node: Inequality constraint node\n\n        Returns:\n            CVXPy inequality constraint object\n\n        Note:\n            For DCP compliance: lhs must be convex and rhs must be concave.\n            Common form: convex_expr(x) &lt;= constant\n        \"\"\"\n        left = self.lower(node.lhs)\n        right = self.lower(node.rhs)\n        return left &lt;= right\n\n    @visitor(CTCS)\n    def _visit_ctcs(self, node: CTCS) -&gt; cp.Expression:\n        \"\"\"Raise NotImplementedError for CTCS constraints.\n\n        CTCS (Continuous-Time Constraint Satisfaction) constraints are handled\n        through dynamics augmentation using JAX, not CVXPy. They represent\n        non-convex continuous-time constraints.\n\n        Args:\n            node: CTCS constraint node\n\n        Raises:\n            NotImplementedError: Always raised since CTCS uses JAX, not CVXPy\n\n        Note:\n            CTCS constraints are lowered to JAX during dynamics augmentation.\n            They add virtual states and controls to enforce constraints over\n            continuous time intervals. See JaxLowerer.visit_ctcs() instead.\n        \"\"\"\n        raise NotImplementedError(\n            \"CTCS constraints are for continuous-time constraint satisfaction and \"\n            \"should be handled through dynamics augmentation with JAX lowering, \"\n            \"not CVXPy lowering. CTCS constraints represent non-convex dynamics \"\n            \"augmentation.\"\n        )\n\n    @visitor(PositivePart)\n    def _visit_pos(self, node: PositivePart) -&gt; cp.Expression:\n        \"\"\"Lower positive part function to CVXPy.\n\n        Computes max(x, 0), which is convex. Used in penalty methods for\n        inequality constraints.\n\n        Args:\n            node: PositivePart expression node\n\n        Returns:\n            CVXPy expression representing max(operand, 0)\n\n        Note:\n            Positive part is convex and commonly used in hinge loss and\n            penalty methods for inequality constraints.\n        \"\"\"\n        operand = self.lower(node.x)\n        return cp.maximum(operand, 0.0)\n\n    @visitor(Square)\n    def _visit_square(self, node: Square) -&gt; cp.Expression:\n        \"\"\"Lower square function to CVXPy.\n\n        Computes x^2, which is convex. Used in quadratic penalty methods\n        and least-squares objectives.\n\n        Args:\n            node: Square expression node\n\n        Returns:\n            CVXPy expression representing operand^2\n\n        Note:\n            Square is convex increasing for x &gt;= 0 and convex decreasing for\n            x &lt;= 0. It's always convex overall.\n        \"\"\"\n        operand = self.lower(node.x)\n        return cp.square(operand)\n\n    @visitor(Huber)\n    def _visit_huber(self, node: Huber) -&gt; cp.Expression:\n        \"\"\"Lower Huber penalty function to CVXPy.\n\n        Huber penalty is quadratic for small values and linear for large values,\n        providing robustness to outliers. It is convex and DCP-compliant.\n\n        The Huber function is defined as:\n        - |x| &lt;= delta: 0.5 * x^2\n        - |x| &gt; delta: delta * (|x| - 0.5 * delta)\n\n        Args:\n            node: Huber expression node with delta parameter\n\n        Returns:\n            CVXPy expression representing Huber penalty\n\n        Note:\n            Huber loss is convex and combines the benefits of squared error\n            (smooth, differentiable) and absolute error (robust to outliers).\n        \"\"\"\n        operand = self.lower(node.x)\n        return cp.huber(operand, M=node.delta)\n\n    @visitor(SmoothReLU)\n    def _visit_srelu(self, node: SmoothReLU) -&gt; cp.Expression:\n        \"\"\"Lower smooth ReLU penalty function to CVXPy.\n\n        Smooth approximation to ReLU: sqrt(max(x, 0)^2 + c^2) - c\n        Differentiable everywhere, approaches ReLU as c -&gt; 0. Convex.\n\n        Args:\n            node: SmoothReLU expression node with smoothing parameter c\n\n        Returns:\n            CVXPy expression representing smooth ReLU penalty\n\n        Note:\n            This provides a smooth, convex approximation to the ReLU function\n            max(x, 0). The parameter c controls the smoothness: smaller c gives\n            a better approximation but less smoothness.\n        \"\"\"\n        operand = self.lower(node.x)\n        c = node.c\n        # smooth_relu(x) = sqrt(max(x, 0)^2 + c^2) - c\n        pos_part = cp.maximum(operand, 0.0)\n        # For SmoothReLU, we use the 2-norm formulation\n        return cp.sqrt(cp.sum_squares(pos_part) + c**2) - c\n\n    @visitor(Sqrt)\n    def _visit_sqrt(self, node: Sqrt) -&gt; cp.Expression:\n        \"\"\"Lower square root to CVXPy expression.\n\n        Square root is concave and DCP-compliant when used appropriately\n        (e.g., maximizing sqrt(x) or constraints like sqrt(x) &gt;= c).\n\n        Args:\n            node: Sqrt expression node\n\n        Returns:\n            CVXPy expression representing sqrt(operand)\n\n        Note:\n            Square root is concave increasing for x &gt; 0. Valid in:\n            - Objective: maximize sqrt(x)\n            - Constraints: sqrt(x) &gt;= c (concave constraint)\n        \"\"\"\n        operand = self.lower(node.operand)\n        return cp.sqrt(operand)\n\n    @visitor(Max)\n    def _visit_max(self, node: Max) -&gt; cp.Expression:\n        \"\"\"Lower element-wise maximum to CVXPy expression.\n\n        Maximum is convex (pointwise max of convex functions is convex).\n\n        Args:\n            node: Max expression node with multiple operands\n\n        Returns:\n            CVXPy expression representing element-wise maximum\n\n        Note:\n            For multiple operands, chains binary maximum operations.\n            Maximum preserves convexity.\n        \"\"\"\n        operands = [self.lower(op) for op in node.operands]\n        # CVXPy's maximum can take multiple arguments\n        if len(operands) == 2:\n            return cp.maximum(operands[0], operands[1])\n        else:\n            # For more than 2 operands, chain maximum calls\n            result = cp.maximum(operands[0], operands[1])\n            for op in operands[2:]:\n                result = cp.maximum(result, op)\n            return result\n\n    @visitor(LogSumExp)\n    def _visit_logsumexp(self, node: LogSumExp) -&gt; cp.Expression:\n        \"\"\"Lower log-sum-exp to CVXPy expression.\n\n        Log-sum-exp is convex and is a smooth approximation to the maximum function.\n        CVXPy's log_sum_exp atom computes log(sum(exp(x_i))) for stacked operands.\n\n        Args:\n            node: LogSumExp expression node with multiple operands\n\n        Returns:\n            CVXPy expression representing log-sum-exp\n\n        Note:\n            Log-sum-exp is convex and DCP-compliant. It satisfies:\n            max(x\u2081, ..., x\u2099) \u2264 logsumexp(x\u2081, ..., x\u2099) \u2264 max(x\u2081, ..., x\u2099) + log(n)\n        \"\"\"\n        operands = [self.lower(op) for op in node.operands]\n\n        # CVXPy's log_sum_exp expects a stacked expression with an axis parameter\n        # For element-wise log-sum-exp, we stack along a new axis and reduce along it\n        if len(operands) == 1:\n            return operands[0]\n\n        # Stack operands along a new axis (axis 0) and compute log_sum_exp along that axis\n        stacked = cp.vstack(operands)\n        return cp.log_sum_exp(stacked, axis=0)\n\n    @visitor(Transpose)\n    def _visit_transpose(self, node: Transpose) -&gt; cp.Expression:\n        \"\"\"Lower matrix transpose to CVXPy expression.\n\n        Transpose preserves DCP properties (transpose of convex is convex).\n\n        Args:\n            node: Transpose expression node\n\n        Returns:\n            CVXPy expression representing operand.T\n        \"\"\"\n        operand = self.lower(node.operand)\n        return operand.T\n\n    @visitor(Power)\n    def _visit_power(self, node: Power) -&gt; cp.Expression:\n        \"\"\"Lower element-wise power (base**exponent) to CVXPy expression.\n\n        Power is DCP-compliant for specific exponent values:\n        - exponent &gt;= 1: convex (when base &gt;= 0)\n        - 0 &lt;= exponent &lt;= 1: concave (when base &gt;= 0)\n\n        Args:\n            node: Power expression node\n\n        Returns:\n            CVXPy expression representing base**exponent\n\n        Note:\n            CVXPy will verify DCP compliance at problem construction time.\n            Common convex cases: x^2, x^3, x^4 (even powers)\n        \"\"\"\n        base = self.lower(node.base)\n        exponent = self.lower(node.exponent)\n        return cp.power(base, exponent)\n\n    @visitor(Stack)\n    def _visit_stack(self, node: Stack) -&gt; cp.Expression:\n        \"\"\"Lower vertical stacking to CVXPy expression.\n\n        Stacks expressions vertically using cp.vstack. Preserves DCP properties.\n\n        Args:\n            node: Stack expression node with multiple rows\n\n        Returns:\n            CVXPy expression representing vertical stack of rows\n\n        Note:\n            Each row is stacked along axis 0 to create a 2D array.\n        \"\"\"\n        rows = [self.lower(row) for row in node.rows]\n        # Stack rows vertically\n        return cp.vstack(rows)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_abs","title":"<code>_visit_abs(node: Abs) -&gt; cp.Expression</code>","text":"<p>Lower absolute value to CVXPy expression.</p> <p>Absolute value is a convex function and DCP-compliant when used in appropriate contexts (e.g., minimizing |x| or constraints like |x| &lt;= c).</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Abs</code> <p>Abs expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing |operand|</p> Note <p>Absolute value is convex, so it's valid in: - Objective: minimize abs(x) - Constraints: abs(x) &lt;= c (convex constraint)</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Abs)\ndef _visit_abs(self, node: Abs) -&gt; cp.Expression:\n    \"\"\"Lower absolute value to CVXPy expression.\n\n    Absolute value is a convex function and DCP-compliant when used in\n    appropriate contexts (e.g., minimizing |x| or constraints like |x| &lt;= c).\n\n    Args:\n        node: Abs expression node\n\n    Returns:\n        CVXPy expression representing |operand|\n\n    Note:\n        Absolute value is convex, so it's valid in:\n        - Objective: minimize abs(x)\n        - Constraints: abs(x) &lt;= c (convex constraint)\n    \"\"\"\n    operand = self.lower(node.operand)\n    return cp.abs(operand)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_add","title":"<code>_visit_add(node: Add) -&gt; cp.Expression</code>","text":"<p>Lower addition to CVXPy expression.</p> <p>Recursively lowers all terms and composes them with element-wise addition. Addition is affine and always DCP-compliant.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Add</code> <p>Add expression node with multiple terms</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing the sum of all terms</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Add)\ndef _visit_add(self, node: Add) -&gt; cp.Expression:\n    \"\"\"Lower addition to CVXPy expression.\n\n    Recursively lowers all terms and composes them with element-wise addition.\n    Addition is affine and always DCP-compliant.\n\n    Args:\n        node: Add expression node with multiple terms\n\n    Returns:\n        CVXPy expression representing the sum of all terms\n    \"\"\"\n    terms = [self.lower(term) for term in node.terms]\n    result = terms[0]\n    for term in terms[1:]:\n        result = result + term\n    return result\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_concat","title":"<code>_visit_concat(node: Concat) -&gt; cp.Expression</code>","text":"<p>Lower concatenation to CVXPy expression.</p> <p>Concatenates expressions horizontally along axis 0. Scalars are promoted to 1D arrays before concatenation. Preserves DCP properties.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Concat</code> <p>Concat expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing horizontal concatenation</p> Note <p>Uses cp.hstack for concatenation. Scalars are reshaped to (1,).</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Concat)\ndef _visit_concat(self, node: Concat) -&gt; cp.Expression:\n    \"\"\"Lower concatenation to CVXPy expression.\n\n    Concatenates expressions horizontally along axis 0. Scalars are\n    promoted to 1D arrays before concatenation. Preserves DCP properties.\n\n    Args:\n        node: Concat expression node\n\n    Returns:\n        CVXPy expression representing horizontal concatenation\n\n    Note:\n        Uses cp.hstack for concatenation. Scalars are reshaped to (1,).\n    \"\"\"\n    exprs = [self.lower(child) for child in node.exprs]\n    # Ensure all expressions are at least 1D for concatenation\n    exprs_1d = []\n    for expr in exprs:\n        if expr.ndim == 0:  # scalar\n            exprs_1d.append(cp.reshape(expr, (1,), order=\"C\"))\n        else:\n            exprs_1d.append(expr)\n    return cp.hstack(exprs_1d)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_constant","title":"<code>_visit_constant(node: Constant) -&gt; cp.Expression</code>","text":"<p>Lower a constant value to a CVXPy constant.</p> <p>Wraps the constant's numpy array value in a CVXPy Constant expression.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Constant</code> <p>Constant expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy constant expression wrapping the value</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Constant)\ndef _visit_constant(self, node: Constant) -&gt; cp.Expression:\n    \"\"\"Lower a constant value to a CVXPy constant.\n\n    Wraps the constant's numpy array value in a CVXPy Constant expression.\n\n    Args:\n        node: Constant expression node\n\n    Returns:\n        CVXPy constant expression wrapping the value\n    \"\"\"\n    return cp.Constant(node.value)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_control","title":"<code>_visit_control(node: Control) -&gt; cp.Expression</code>","text":"<p>Lower a control variable to a CVXPy expression.</p> <p>Extracts the appropriate slice from the unified control vector \"u\" using the slice assigned during unification. The \"u\" variable must exist in the variable_map.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Control</code> <p>Control expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing the control slice: u[slice]</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If \"u\" is not found in variable_map</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Control)\ndef _visit_control(self, node: Control) -&gt; cp.Expression:\n    \"\"\"Lower a control variable to a CVXPy expression.\n\n    Extracts the appropriate slice from the unified control vector \"u\" using\n    the slice assigned during unification. The \"u\" variable must exist in\n    the variable_map.\n\n    Args:\n        node: Control expression node\n\n    Returns:\n        CVXPy expression representing the control slice: u[slice]\n\n    Raises:\n        ValueError: If \"u\" is not found in variable_map\n    \"\"\"\n    if \"u\" not in self.variable_map:\n        raise ValueError(\"Control vector 'u' not found in variable_map.\")\n\n    cvx_var = self.variable_map[\"u\"]\n\n    # If the control has a slice assigned, apply it\n    if node._slice is not None:\n        return cvx_var[node._slice]\n    return cvx_var\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_cos","title":"<code>_visit_cos(node: Cos) -&gt; cp.Expression</code>","text":"<p>Raise NotImplementedError for cosine function.</p> <p>Cosine is not DCP-compliant in CVXPy as it is neither convex nor concave.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Cos</code> <p>Cos expression node</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always raised since cosine is not DCP-compliant</p> Note <p>For constraints involving trigonometric functions: - Use piecewise-linear approximations, or - Handle in the JAX dynamics/constraint layer instead of CVXPy</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Cos)\ndef _visit_cos(self, node: Cos) -&gt; cp.Expression:\n    \"\"\"Raise NotImplementedError for cosine function.\n\n    Cosine is not DCP-compliant in CVXPy as it is neither convex nor concave.\n\n    Args:\n        node: Cos expression node\n\n    Raises:\n        NotImplementedError: Always raised since cosine is not DCP-compliant\n\n    Note:\n        For constraints involving trigonometric functions:\n        - Use piecewise-linear approximations, or\n        - Handle in the JAX dynamics/constraint layer instead of CVXPy\n    \"\"\"\n    raise NotImplementedError(\n        \"Trigonometric functions like Cos are not DCP-compliant in CVXPy. \"\n        \"Consider using piecewise-linear approximations or handle these constraints \"\n        \"in the dynamics (JAX) layer instead.\"\n    )\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_cross_node_constraint","title":"<code>_visit_cross_node_constraint(node: CrossNodeConstraint) -&gt; cp.Constraint</code>","text":"<p>Lower CrossNodeConstraint to CVXPy constraint.</p> <p>CrossNodeConstraint wraps constraints that reference multiple trajectory nodes via NodeReference (e.g., rate limits like x.at(k) - x.at(k-1) &lt;= r).</p> <p>For CVXPy lowering, this simply lowers the inner constraint. The NodeReference nodes within the constraint will handle extracting values from the full trajectory arrays (which must be provided in variable_map as \"x\" and \"u\").</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>CrossNodeConstraint</code> <p>CrossNodeConstraint expression wrapping the inner constraint</p> required <p>Returns:</p> Type Description <code>Constraint</code> <p>CVXPy constraint object</p> Note <p>The variable_map must contain full trajectory arrays:     - \"x\": (N, n_x) CVXPy expression (e.g., cp.vstack(x_nonscaled))     - \"u\": (N, n_u) CVXPy expression (e.g., cp.vstack(u_nonscaled))</p> <p>NodeReference visitors will index into these arrays using the fixed node indices baked into the expression.</p> Example <p>For constraint: position.at(5) - position.at(4) &lt;= max_step</p> <p>With variable_map = {\"x\": cp.vstack([x[k] for k in range(N)])}</p> <p>The lowered constraint evaluates:     x[5, pos_slice] - x[4, pos_slice] &lt;= max_step</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(CrossNodeConstraint)\ndef _visit_cross_node_constraint(self, node: CrossNodeConstraint) -&gt; cp.Constraint:\n    \"\"\"Lower CrossNodeConstraint to CVXPy constraint.\n\n    CrossNodeConstraint wraps constraints that reference multiple trajectory\n    nodes via NodeReference (e.g., rate limits like x.at(k) - x.at(k-1) &lt;= r).\n\n    For CVXPy lowering, this simply lowers the inner constraint. The NodeReference\n    nodes within the constraint will handle extracting values from the full\n    trajectory arrays (which must be provided in variable_map as \"x\" and \"u\").\n\n    Args:\n        node: CrossNodeConstraint expression wrapping the inner constraint\n\n    Returns:\n        CVXPy constraint object\n\n    Note:\n        The variable_map must contain full trajectory arrays:\n            - \"x\": (N, n_x) CVXPy expression (e.g., cp.vstack(x_nonscaled))\n            - \"u\": (N, n_u) CVXPy expression (e.g., cp.vstack(u_nonscaled))\n\n        NodeReference visitors will index into these arrays using the fixed\n        node indices baked into the expression.\n\n    Example:\n        For constraint: position.at(5) - position.at(4) &lt;= max_step\n\n        With variable_map = {\"x\": cp.vstack([x[k] for k in range(N)])}\n\n        The lowered constraint evaluates:\n            x[5, pos_slice] - x[4, pos_slice] &lt;= max_step\n    \"\"\"\n    # Simply lower the inner constraint - NodeReference handles indexing\n    return self.lower(node.constraint)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_ctcs","title":"<code>_visit_ctcs(node: CTCS) -&gt; cp.Expression</code>","text":"<p>Raise NotImplementedError for CTCS constraints.</p> <p>CTCS (Continuous-Time Constraint Satisfaction) constraints are handled through dynamics augmentation using JAX, not CVXPy. They represent non-convex continuous-time constraints.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>CTCS</code> <p>CTCS constraint node</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always raised since CTCS uses JAX, not CVXPy</p> Note <p>CTCS constraints are lowered to JAX during dynamics augmentation. They add virtual states and controls to enforce constraints over continuous time intervals. See JaxLowerer.visit_ctcs() instead.</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(CTCS)\ndef _visit_ctcs(self, node: CTCS) -&gt; cp.Expression:\n    \"\"\"Raise NotImplementedError for CTCS constraints.\n\n    CTCS (Continuous-Time Constraint Satisfaction) constraints are handled\n    through dynamics augmentation using JAX, not CVXPy. They represent\n    non-convex continuous-time constraints.\n\n    Args:\n        node: CTCS constraint node\n\n    Raises:\n        NotImplementedError: Always raised since CTCS uses JAX, not CVXPy\n\n    Note:\n        CTCS constraints are lowered to JAX during dynamics augmentation.\n        They add virtual states and controls to enforce constraints over\n        continuous time intervals. See JaxLowerer.visit_ctcs() instead.\n    \"\"\"\n    raise NotImplementedError(\n        \"CTCS constraints are for continuous-time constraint satisfaction and \"\n        \"should be handled through dynamics augmentation with JAX lowering, \"\n        \"not CVXPy lowering. CTCS constraints represent non-convex dynamics \"\n        \"augmentation.\"\n    )\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_div","title":"<code>_visit_div(node: Div) -&gt; cp.Expression</code>","text":"<p>Lower element-wise division to CVXPy expression.</p> <p>Division is DCP-compliant when the denominator is constant or when the numerator is constant and the denominator is concave.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Div</code> <p>Div expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing left / right</p> Note <p>CVXPy will raise a DCP error if the division violates DCP rules.</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Div)\ndef _visit_div(self, node: Div) -&gt; cp.Expression:\n    \"\"\"Lower element-wise division to CVXPy expression.\n\n    Division is DCP-compliant when the denominator is constant or when\n    the numerator is constant and the denominator is concave.\n\n    Args:\n        node: Div expression node\n\n    Returns:\n        CVXPy expression representing left / right\n\n    Note:\n        CVXPy will raise a DCP error if the division violates DCP rules.\n    \"\"\"\n    left = self.lower(node.left)\n    right = self.lower(node.right)\n    return left / right\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_equality","title":"<code>_visit_equality(node: Equality) -&gt; cp.Constraint</code>","text":"<p>Lower equality constraint to CVXPy constraint (lhs == rhs).</p> <p>Equality constraints require affine expressions on both sides for DCP compliance.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Equality</code> <p>Equality constraint node</p> required <p>Returns:</p> Type Description <code>Constraint</code> <p>CVXPy equality constraint object</p> Note <p>For DCP compliance, both lhs and rhs must be affine. CVXPy will raise a DCP error if either side is non-affine.</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Equality)\ndef _visit_equality(self, node: Equality) -&gt; cp.Constraint:\n    \"\"\"Lower equality constraint to CVXPy constraint (lhs == rhs).\n\n    Equality constraints require affine expressions on both sides for\n    DCP compliance.\n\n    Args:\n        node: Equality constraint node\n\n    Returns:\n        CVXPy equality constraint object\n\n    Note:\n        For DCP compliance, both lhs and rhs must be affine. CVXPy will\n        raise a DCP error if either side is non-affine.\n    \"\"\"\n    left = self.lower(node.lhs)\n    right = self.lower(node.rhs)\n    return left == right\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_exp","title":"<code>_visit_exp(node: Exp) -&gt; cp.Expression</code>","text":"<p>Lower exponential function to CVXPy expression.</p> <p>Exponential is a convex function and DCP-compliant when used in appropriate contexts (e.g., minimizing exp(x) or constraints like exp(x) &lt;= c).</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Exp</code> <p>Exp expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing exp(operand)</p> Note <p>Exponential is convex increasing, so it's valid in: - Objective: minimize exp(x) - Constraints: exp(x) &lt;= c (convex constraint)</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Exp)\ndef _visit_exp(self, node: Exp) -&gt; cp.Expression:\n    \"\"\"Lower exponential function to CVXPy expression.\n\n    Exponential is a convex function and DCP-compliant when used in\n    appropriate contexts (e.g., minimizing exp(x) or constraints like\n    exp(x) &lt;= c).\n\n    Args:\n        node: Exp expression node\n\n    Returns:\n        CVXPy expression representing exp(operand)\n\n    Note:\n        Exponential is convex increasing, so it's valid in:\n        - Objective: minimize exp(x)\n        - Constraints: exp(x) &lt;= c (convex constraint)\n    \"\"\"\n    operand = self.lower(node.operand)\n    return cp.exp(operand)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_huber","title":"<code>_visit_huber(node: Huber) -&gt; cp.Expression</code>","text":"<p>Lower Huber penalty function to CVXPy.</p> <p>Huber penalty is quadratic for small values and linear for large values, providing robustness to outliers. It is convex and DCP-compliant.</p> <p>The Huber function is defined as: - |x| &lt;= delta: 0.5 * x^2 - |x| &gt; delta: delta * (|x| - 0.5 * delta)</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Huber</code> <p>Huber expression node with delta parameter</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing Huber penalty</p> Note <p>Huber loss is convex and combines the benefits of squared error (smooth, differentiable) and absolute error (robust to outliers).</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Huber)\ndef _visit_huber(self, node: Huber) -&gt; cp.Expression:\n    \"\"\"Lower Huber penalty function to CVXPy.\n\n    Huber penalty is quadratic for small values and linear for large values,\n    providing robustness to outliers. It is convex and DCP-compliant.\n\n    The Huber function is defined as:\n    - |x| &lt;= delta: 0.5 * x^2\n    - |x| &gt; delta: delta * (|x| - 0.5 * delta)\n\n    Args:\n        node: Huber expression node with delta parameter\n\n    Returns:\n        CVXPy expression representing Huber penalty\n\n    Note:\n        Huber loss is convex and combines the benefits of squared error\n        (smooth, differentiable) and absolute error (robust to outliers).\n    \"\"\"\n    operand = self.lower(node.x)\n    return cp.huber(operand, M=node.delta)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_index","title":"<code>_visit_index(node: Index) -&gt; cp.Expression</code>","text":"<p>Lower indexing/slicing operation to CVXPy expression.</p> <p>Indexing preserves DCP properties (indexing into convex is convex).</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Index</code> <p>Index expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing base[index]</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Index)\ndef _visit_index(self, node: Index) -&gt; cp.Expression:\n    \"\"\"Lower indexing/slicing operation to CVXPy expression.\n\n    Indexing preserves DCP properties (indexing into convex is convex).\n\n    Args:\n        node: Index expression node\n\n    Returns:\n        CVXPy expression representing base[index]\n    \"\"\"\n    base = self.lower(node.base)\n    return base[node.index]\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_inequality","title":"<code>_visit_inequality(node: Inequality) -&gt; cp.Constraint</code>","text":"<p>Lower inequality constraint to CVXPy constraint (lhs &lt;= rhs).</p> <p>Inequality constraints must satisfy DCP rules: convex &lt;= concave.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Inequality</code> <p>Inequality constraint node</p> required <p>Returns:</p> Type Description <code>Constraint</code> <p>CVXPy inequality constraint object</p> Note <p>For DCP compliance: lhs must be convex and rhs must be concave. Common form: convex_expr(x) &lt;= constant</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Inequality)\ndef _visit_inequality(self, node: Inequality) -&gt; cp.Constraint:\n    \"\"\"Lower inequality constraint to CVXPy constraint (lhs &lt;= rhs).\n\n    Inequality constraints must satisfy DCP rules: convex &lt;= concave.\n\n    Args:\n        node: Inequality constraint node\n\n    Returns:\n        CVXPy inequality constraint object\n\n    Note:\n        For DCP compliance: lhs must be convex and rhs must be concave.\n        Common form: convex_expr(x) &lt;= constant\n    \"\"\"\n    left = self.lower(node.lhs)\n    right = self.lower(node.rhs)\n    return left &lt;= right\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_log","title":"<code>_visit_log(node: Log) -&gt; cp.Expression</code>","text":"<p>Lower natural logarithm to CVXPy expression.</p> <p>Logarithm is a concave function and DCP-compliant when used in appropriate contexts (e.g., maximizing log(x) or constraints like log(x) &gt;= c).</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Log</code> <p>Log expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing log(operand)</p> Note <p>Logarithm is concave increasing, so it's valid in: - Objective: maximize log(x) - Constraints: log(x) &gt;= c (concave constraint, or equivalently c &lt;= log(x))</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Log)\ndef _visit_log(self, node: Log) -&gt; cp.Expression:\n    \"\"\"Lower natural logarithm to CVXPy expression.\n\n    Logarithm is a concave function and DCP-compliant when used in\n    appropriate contexts (e.g., maximizing log(x) or constraints like\n    log(x) &gt;= c).\n\n    Args:\n        node: Log expression node\n\n    Returns:\n        CVXPy expression representing log(operand)\n\n    Note:\n        Logarithm is concave increasing, so it's valid in:\n        - Objective: maximize log(x)\n        - Constraints: log(x) &gt;= c (concave constraint, or equivalently c &lt;= log(x))\n    \"\"\"\n    operand = self.lower(node.operand)\n    return cp.log(operand)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_logsumexp","title":"<code>_visit_logsumexp(node: LogSumExp) -&gt; cp.Expression</code>","text":"<p>Lower log-sum-exp to CVXPy expression.</p> <p>Log-sum-exp is convex and is a smooth approximation to the maximum function. CVXPy's log_sum_exp atom computes log(sum(exp(x_i))) for stacked operands.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>LogSumExp</code> <p>LogSumExp expression node with multiple operands</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing log-sum-exp</p> Note <p>Log-sum-exp is convex and DCP-compliant. It satisfies: max(x\u2081, ..., x\u2099) \u2264 logsumexp(x\u2081, ..., x\u2099) \u2264 max(x\u2081, ..., x\u2099) + log(n)</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(LogSumExp)\ndef _visit_logsumexp(self, node: LogSumExp) -&gt; cp.Expression:\n    \"\"\"Lower log-sum-exp to CVXPy expression.\n\n    Log-sum-exp is convex and is a smooth approximation to the maximum function.\n    CVXPy's log_sum_exp atom computes log(sum(exp(x_i))) for stacked operands.\n\n    Args:\n        node: LogSumExp expression node with multiple operands\n\n    Returns:\n        CVXPy expression representing log-sum-exp\n\n    Note:\n        Log-sum-exp is convex and DCP-compliant. It satisfies:\n        max(x\u2081, ..., x\u2099) \u2264 logsumexp(x\u2081, ..., x\u2099) \u2264 max(x\u2081, ..., x\u2099) + log(n)\n    \"\"\"\n    operands = [self.lower(op) for op in node.operands]\n\n    # CVXPy's log_sum_exp expects a stacked expression with an axis parameter\n    # For element-wise log-sum-exp, we stack along a new axis and reduce along it\n    if len(operands) == 1:\n        return operands[0]\n\n    # Stack operands along a new axis (axis 0) and compute log_sum_exp along that axis\n    stacked = cp.vstack(operands)\n    return cp.log_sum_exp(stacked, axis=0)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_matmul","title":"<code>_visit_matmul(node: MatMul) -&gt; cp.Expression</code>","text":"<p>Lower matrix multiplication to CVXPy expression using @ operator.</p> <p>Matrix multiplication is DCP-compliant when at least one operand is constant. Used for quadratic forms like x.T @ Q @ x.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>MatMul</code> <p>MatMul expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing left @ right</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(MatMul)\ndef _visit_matmul(self, node: MatMul) -&gt; cp.Expression:\n    \"\"\"Lower matrix multiplication to CVXPy expression using @ operator.\n\n    Matrix multiplication is DCP-compliant when at least one operand is\n    constant. Used for quadratic forms like x.T @ Q @ x.\n\n    Args:\n        node: MatMul expression node\n\n    Returns:\n        CVXPy expression representing left @ right\n    \"\"\"\n    left = self.lower(node.left)\n    right = self.lower(node.right)\n    return left @ right\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_max","title":"<code>_visit_max(node: Max) -&gt; cp.Expression</code>","text":"<p>Lower element-wise maximum to CVXPy expression.</p> <p>Maximum is convex (pointwise max of convex functions is convex).</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Max</code> <p>Max expression node with multiple operands</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing element-wise maximum</p> Note <p>For multiple operands, chains binary maximum operations. Maximum preserves convexity.</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Max)\ndef _visit_max(self, node: Max) -&gt; cp.Expression:\n    \"\"\"Lower element-wise maximum to CVXPy expression.\n\n    Maximum is convex (pointwise max of convex functions is convex).\n\n    Args:\n        node: Max expression node with multiple operands\n\n    Returns:\n        CVXPy expression representing element-wise maximum\n\n    Note:\n        For multiple operands, chains binary maximum operations.\n        Maximum preserves convexity.\n    \"\"\"\n    operands = [self.lower(op) for op in node.operands]\n    # CVXPy's maximum can take multiple arguments\n    if len(operands) == 2:\n        return cp.maximum(operands[0], operands[1])\n    else:\n        # For more than 2 operands, chain maximum calls\n        result = cp.maximum(operands[0], operands[1])\n        for op in operands[2:]:\n            result = cp.maximum(result, op)\n        return result\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_mul","title":"<code>_visit_mul(node: Mul) -&gt; cp.Expression</code>","text":"<p>Lower element-wise multiplication to CVXPy expression.</p> <p>Element-wise multiplication is DCP-compliant when at least one operand is constant. For quadratic forms, use MatMul instead.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Mul</code> <p>Mul expression node with multiple factors</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing element-wise product</p> Note <p>For convex optimization, typically one factor should be constant. CVXPy will raise a DCP error if the composition violates DCP rules.</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Mul)\ndef _visit_mul(self, node: Mul) -&gt; cp.Expression:\n    \"\"\"Lower element-wise multiplication to CVXPy expression.\n\n    Element-wise multiplication is DCP-compliant when at least one operand\n    is constant. For quadratic forms, use MatMul instead.\n\n    Args:\n        node: Mul expression node with multiple factors\n\n    Returns:\n        CVXPy expression representing element-wise product\n\n    Note:\n        For convex optimization, typically one factor should be constant.\n        CVXPy will raise a DCP error if the composition violates DCP rules.\n    \"\"\"\n    factors = [self.lower(factor) for factor in node.factors]\n    result = factors[0]\n    for factor in factors[1:]:\n        result = result * factor\n    return result\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_neg","title":"<code>_visit_neg(node: Neg) -&gt; cp.Expression</code>","text":"<p>Lower negation (unary minus) to CVXPy expression.</p> <p>Negation preserves DCP properties (negating convex gives concave).</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Neg</code> <p>Neg expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing -operand</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Neg)\ndef _visit_neg(self, node: Neg) -&gt; cp.Expression:\n    \"\"\"Lower negation (unary minus) to CVXPy expression.\n\n    Negation preserves DCP properties (negating convex gives concave).\n\n    Args:\n        node: Neg expression node\n\n    Returns:\n        CVXPy expression representing -operand\n    \"\"\"\n    operand = self.lower(node.operand)\n    return -operand\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_node_reference","title":"<code>_visit_node_reference(node: NodeReference) -&gt; cp.Expression</code>","text":"<p>Lower NodeReference - extract value at a specific trajectory node.</p> <p>NodeReference enables cross-node constraints by referencing state/control values at specific discrete time points. This requires the variable_map to contain full trajectory arrays (N, n_x) or (N, n_u) rather than single-node vectors.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>NodeReference</code> <p>NodeReference expression with base and node_idx</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing the variable at the specified node:</p> <code>Expression</code> <p>x[node_idx, slice] or u[node_idx, slice]</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the required trajectory variable is not in variable_map</p> <code>ValueError</code> <p>If the base variable has no slice assigned</p> <code>NotImplementedError</code> <p>If the base is a compound expression</p> Example <p>For cross-node constraint: position.at(5) - position.at(4) &lt;= 0.1</p> <p>variable_map = {     \"x\": cp.vstack([x_nonscaled[k] for k in range(N)]),  # (N, n_x) }</p> Note <p>The node_idx is already resolved to an absolute integer index during expression construction, so negative indices are already handled.</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(NodeReference)\ndef _visit_node_reference(self, node: \"NodeReference\") -&gt; cp.Expression:\n    \"\"\"Lower NodeReference - extract value at a specific trajectory node.\n\n    NodeReference enables cross-node constraints by referencing state/control\n    values at specific discrete time points. This requires the variable_map to\n    contain full trajectory arrays (N, n_x) or (N, n_u) rather than single-node\n    vectors.\n\n    Args:\n        node: NodeReference expression with base and node_idx\n\n    Returns:\n        CVXPy expression representing the variable at the specified node:\n        x[node_idx, slice] or u[node_idx, slice]\n\n    Raises:\n        ValueError: If the required trajectory variable is not in variable_map\n        ValueError: If the base variable has no slice assigned\n        NotImplementedError: If the base is a compound expression\n\n    Example:\n        For cross-node constraint: position.at(5) - position.at(4) &lt;= 0.1\n\n        variable_map = {\n            \"x\": cp.vstack([x_nonscaled[k] for k in range(N)]),  # (N, n_x)\n        }\n        # position.at(5) lowers to x[5, position._slice]\n\n    Note:\n        The node_idx is already resolved to an absolute integer index during\n        expression construction, so negative indices are already handled.\n    \"\"\"\n    from openscvx.symbolic.expr.control import Control\n    from openscvx.symbolic.expr.state import State\n\n    idx = node.node_idx\n\n    if isinstance(node.base, State):\n        if \"x\" not in self.variable_map:\n            raise ValueError(\n                \"State vector 'x' not found in variable_map. \"\n                \"For cross-node constraints, 'x' must be the full trajectory (N, n_x).\"\n            )\n\n        cvx_var = self.variable_map[\"x\"]  # Should be (N, n_x) for cross-node constraints\n\n        # Apply slice if state has one assigned\n        if node.base._slice is not None:\n            return cvx_var[idx, node.base._slice]\n        else:\n            # No slice means this is the entire unified state vector\n            return cvx_var[idx, :]\n\n    elif isinstance(node.base, Control):\n        if \"u\" not in self.variable_map:\n            raise ValueError(\n                \"Control vector 'u' not found in variable_map. \"\n                \"For cross-node constraints, 'u' must be the full trajectory (N, n_u).\"\n            )\n\n        cvx_var = self.variable_map[\"u\"]  # Should be (N, n_u) for cross-node constraints\n\n        # Apply slice if control has one assigned\n        if node.base._slice is not None:\n            return cvx_var[idx, node.base._slice]\n        else:\n            # No slice means this is the entire unified control vector\n            return cvx_var[idx, :]\n\n    else:\n        # Compound expression (e.g., position[0].at(5))\n        # This is more complex - would need to lower base in single-node context\n        raise NotImplementedError(\n            \"Compound expressions in NodeReference are not yet supported for CVXPy lowering. \"\n            f\"Base expression type: {type(node.base).__name__}. \"\n            \"Only State and Control NodeReferences are currently supported.\"\n        )\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_node_reference--positionat5-lowers-to-x5-position_slice","title":"position.at(5) lowers to x[5, position._slice]","text":""},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_norm","title":"<code>_visit_norm(node: Norm) -&gt; cp.Expression</code>","text":"<p>Lower norm operation to CVXPy expression.</p> <p>Norms are convex functions and commonly used in convex optimization. Supports all CVXPy norm types (1, 2, inf, \"fro\", etc.).</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Norm</code> <p>Norm expression node with ord attribute</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing the norm of the operand</p> Note <p>Common norms: ord=2 (Euclidean), ord=1 (Manhattan), ord=\"inf\"</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Norm)\ndef _visit_norm(self, node: Norm) -&gt; cp.Expression:\n    \"\"\"Lower norm operation to CVXPy expression.\n\n    Norms are convex functions and commonly used in convex optimization.\n    Supports all CVXPy norm types (1, 2, inf, \"fro\", etc.).\n\n    Args:\n        node: Norm expression node with ord attribute\n\n    Returns:\n        CVXPy expression representing the norm of the operand\n\n    Note:\n        Common norms: ord=2 (Euclidean), ord=1 (Manhattan), ord=\"inf\"\n    \"\"\"\n    operand = self.lower(node.operand)\n    return cp.norm(operand, node.ord)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_parameter","title":"<code>_visit_parameter(node: Parameter) -&gt; cp.Expression</code>","text":"<p>Lower a parameter to a CVXPy expression.</p> <p>Parameters are looked up by name in the variable_map. They can be mapped to CVXPy Parameter objects (for efficient parameter sweeps) or constants.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Parameter</code> <p>Parameter expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression from variable_map (Parameter or constant)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If parameter name is not found in variable_map</p> Note <p>For parameter sweeps without recompilation, map to cp.Parameter. For fixed values, map to cp.Constant or numpy arrays.</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Parameter)\ndef _visit_parameter(self, node: Parameter) -&gt; cp.Expression:\n    \"\"\"Lower a parameter to a CVXPy expression.\n\n    Parameters are looked up by name in the variable_map. They can be mapped\n    to CVXPy Parameter objects (for efficient parameter sweeps) or constants.\n\n    Args:\n        node: Parameter expression node\n\n    Returns:\n        CVXPy expression from variable_map (Parameter or constant)\n\n    Raises:\n        ValueError: If parameter name is not found in variable_map\n\n    Note:\n        For parameter sweeps without recompilation, map to cp.Parameter.\n        For fixed values, map to cp.Constant or numpy arrays.\n    \"\"\"\n    param_name = node.name\n    if param_name in self.variable_map:\n        return self.variable_map[param_name]\n    else:\n        raise ValueError(\n            f\"Parameter '{param_name}' not found in variable_map. \"\n            f\"Add it during CVXPy lowering or use cp.Parameter for parameter sweeps.\"\n        )\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_pos","title":"<code>_visit_pos(node: PositivePart) -&gt; cp.Expression</code>","text":"<p>Lower positive part function to CVXPy.</p> <p>Computes max(x, 0), which is convex. Used in penalty methods for inequality constraints.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>PositivePart</code> <p>PositivePart expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing max(operand, 0)</p> Note <p>Positive part is convex and commonly used in hinge loss and penalty methods for inequality constraints.</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(PositivePart)\ndef _visit_pos(self, node: PositivePart) -&gt; cp.Expression:\n    \"\"\"Lower positive part function to CVXPy.\n\n    Computes max(x, 0), which is convex. Used in penalty methods for\n    inequality constraints.\n\n    Args:\n        node: PositivePart expression node\n\n    Returns:\n        CVXPy expression representing max(operand, 0)\n\n    Note:\n        Positive part is convex and commonly used in hinge loss and\n        penalty methods for inequality constraints.\n    \"\"\"\n    operand = self.lower(node.x)\n    return cp.maximum(operand, 0.0)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_power","title":"<code>_visit_power(node: Power) -&gt; cp.Expression</code>","text":"<p>Lower element-wise power (base**exponent) to CVXPy expression.</p> <p>Power is DCP-compliant for specific exponent values: - exponent &gt;= 1: convex (when base &gt;= 0) - 0 &lt;= exponent &lt;= 1: concave (when base &gt;= 0)</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Power</code> <p>Power expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing base**exponent</p> Note <p>CVXPy will verify DCP compliance at problem construction time. Common convex cases: x^2, x^3, x^4 (even powers)</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Power)\ndef _visit_power(self, node: Power) -&gt; cp.Expression:\n    \"\"\"Lower element-wise power (base**exponent) to CVXPy expression.\n\n    Power is DCP-compliant for specific exponent values:\n    - exponent &gt;= 1: convex (when base &gt;= 0)\n    - 0 &lt;= exponent &lt;= 1: concave (when base &gt;= 0)\n\n    Args:\n        node: Power expression node\n\n    Returns:\n        CVXPy expression representing base**exponent\n\n    Note:\n        CVXPy will verify DCP compliance at problem construction time.\n        Common convex cases: x^2, x^3, x^4 (even powers)\n    \"\"\"\n    base = self.lower(node.base)\n    exponent = self.lower(node.exponent)\n    return cp.power(base, exponent)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_sin","title":"<code>_visit_sin(node: Sin) -&gt; cp.Expression</code>","text":"<p>Raise NotImplementedError for sine function.</p> <p>Sine is not DCP-compliant in CVXPy as it is neither convex nor concave.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Sin</code> <p>Sin expression node</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always raised since sine is not DCP-compliant</p> Note <p>For constraints involving trigonometric functions: - Use piecewise-linear approximations, or - Handle in the JAX dynamics/constraint layer instead of CVXPy</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Sin)\ndef _visit_sin(self, node: Sin) -&gt; cp.Expression:\n    \"\"\"Raise NotImplementedError for sine function.\n\n    Sine is not DCP-compliant in CVXPy as it is neither convex nor concave.\n\n    Args:\n        node: Sin expression node\n\n    Raises:\n        NotImplementedError: Always raised since sine is not DCP-compliant\n\n    Note:\n        For constraints involving trigonometric functions:\n        - Use piecewise-linear approximations, or\n        - Handle in the JAX dynamics/constraint layer instead of CVXPy\n    \"\"\"\n    raise NotImplementedError(\n        \"Trigonometric functions like Sin are not DCP-compliant in CVXPy. \"\n        \"Consider using piecewise-linear approximations or handle these constraints \"\n        \"in the dynamics (JAX) layer instead.\"\n    )\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_sqrt","title":"<code>_visit_sqrt(node: Sqrt) -&gt; cp.Expression</code>","text":"<p>Lower square root to CVXPy expression.</p> <p>Square root is concave and DCP-compliant when used appropriately (e.g., maximizing sqrt(x) or constraints like sqrt(x) &gt;= c).</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Sqrt</code> <p>Sqrt expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing sqrt(operand)</p> Note <p>Square root is concave increasing for x &gt; 0. Valid in: - Objective: maximize sqrt(x) - Constraints: sqrt(x) &gt;= c (concave constraint)</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Sqrt)\ndef _visit_sqrt(self, node: Sqrt) -&gt; cp.Expression:\n    \"\"\"Lower square root to CVXPy expression.\n\n    Square root is concave and DCP-compliant when used appropriately\n    (e.g., maximizing sqrt(x) or constraints like sqrt(x) &gt;= c).\n\n    Args:\n        node: Sqrt expression node\n\n    Returns:\n        CVXPy expression representing sqrt(operand)\n\n    Note:\n        Square root is concave increasing for x &gt; 0. Valid in:\n        - Objective: maximize sqrt(x)\n        - Constraints: sqrt(x) &gt;= c (concave constraint)\n    \"\"\"\n    operand = self.lower(node.operand)\n    return cp.sqrt(operand)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_square","title":"<code>_visit_square(node: Square) -&gt; cp.Expression</code>","text":"<p>Lower square function to CVXPy.</p> <p>Computes x^2, which is convex. Used in quadratic penalty methods and least-squares objectives.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Square</code> <p>Square expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing operand^2</p> Note <p>Square is convex increasing for x &gt;= 0 and convex decreasing for x &lt;= 0. It's always convex overall.</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Square)\ndef _visit_square(self, node: Square) -&gt; cp.Expression:\n    \"\"\"Lower square function to CVXPy.\n\n    Computes x^2, which is convex. Used in quadratic penalty methods\n    and least-squares objectives.\n\n    Args:\n        node: Square expression node\n\n    Returns:\n        CVXPy expression representing operand^2\n\n    Note:\n        Square is convex increasing for x &gt;= 0 and convex decreasing for\n        x &lt;= 0. It's always convex overall.\n    \"\"\"\n    operand = self.lower(node.x)\n    return cp.square(operand)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_srelu","title":"<code>_visit_srelu(node: SmoothReLU) -&gt; cp.Expression</code>","text":"<p>Lower smooth ReLU penalty function to CVXPy.</p> <p>Smooth approximation to ReLU: sqrt(max(x, 0)^2 + c^2) - c Differentiable everywhere, approaches ReLU as c -&gt; 0. Convex.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>SmoothReLU</code> <p>SmoothReLU expression node with smoothing parameter c</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing smooth ReLU penalty</p> Note <p>This provides a smooth, convex approximation to the ReLU function max(x, 0). The parameter c controls the smoothness: smaller c gives a better approximation but less smoothness.</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(SmoothReLU)\ndef _visit_srelu(self, node: SmoothReLU) -&gt; cp.Expression:\n    \"\"\"Lower smooth ReLU penalty function to CVXPy.\n\n    Smooth approximation to ReLU: sqrt(max(x, 0)^2 + c^2) - c\n    Differentiable everywhere, approaches ReLU as c -&gt; 0. Convex.\n\n    Args:\n        node: SmoothReLU expression node with smoothing parameter c\n\n    Returns:\n        CVXPy expression representing smooth ReLU penalty\n\n    Note:\n        This provides a smooth, convex approximation to the ReLU function\n        max(x, 0). The parameter c controls the smoothness: smaller c gives\n        a better approximation but less smoothness.\n    \"\"\"\n    operand = self.lower(node.x)\n    c = node.c\n    # smooth_relu(x) = sqrt(max(x, 0)^2 + c^2) - c\n    pos_part = cp.maximum(operand, 0.0)\n    # For SmoothReLU, we use the 2-norm formulation\n    return cp.sqrt(cp.sum_squares(pos_part) + c**2) - c\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_stack","title":"<code>_visit_stack(node: Stack) -&gt; cp.Expression</code>","text":"<p>Lower vertical stacking to CVXPy expression.</p> <p>Stacks expressions vertically using cp.vstack. Preserves DCP properties.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Stack</code> <p>Stack expression node with multiple rows</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing vertical stack of rows</p> Note <p>Each row is stacked along axis 0 to create a 2D array.</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Stack)\ndef _visit_stack(self, node: Stack) -&gt; cp.Expression:\n    \"\"\"Lower vertical stacking to CVXPy expression.\n\n    Stacks expressions vertically using cp.vstack. Preserves DCP properties.\n\n    Args:\n        node: Stack expression node with multiple rows\n\n    Returns:\n        CVXPy expression representing vertical stack of rows\n\n    Note:\n        Each row is stacked along axis 0 to create a 2D array.\n    \"\"\"\n    rows = [self.lower(row) for row in node.rows]\n    # Stack rows vertically\n    return cp.vstack(rows)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_state","title":"<code>_visit_state(node: State) -&gt; cp.Expression</code>","text":"<p>Lower a state variable to a CVXPy expression.</p> <p>Extracts the appropriate slice from the unified state vector \"x\" using the slice assigned during unification. The \"x\" variable must exist in the variable_map.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>State</code> <p>State expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing the state slice: x[slice]</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If \"x\" is not found in variable_map</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(State)\ndef _visit_state(self, node: State) -&gt; cp.Expression:\n    \"\"\"Lower a state variable to a CVXPy expression.\n\n    Extracts the appropriate slice from the unified state vector \"x\" using\n    the slice assigned during unification. The \"x\" variable must exist in\n    the variable_map.\n\n    Args:\n        node: State expression node\n\n    Returns:\n        CVXPy expression representing the state slice: x[slice]\n\n    Raises:\n        ValueError: If \"x\" is not found in variable_map\n    \"\"\"\n    if \"x\" not in self.variable_map:\n        raise ValueError(\"State vector 'x' not found in variable_map.\")\n\n    cvx_var = self.variable_map[\"x\"]\n\n    # If the state has a slice assigned, apply it\n    if node._slice is not None:\n        return cvx_var[node._slice]\n    return cvx_var\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_sub","title":"<code>_visit_sub(node: Sub) -&gt; cp.Expression</code>","text":"<p>Lower subtraction to CVXPy expression (element-wise left - right).</p> <p>Subtraction is affine and always DCP-compliant.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Sub</code> <p>Sub expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing left - right</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Sub)\ndef _visit_sub(self, node: Sub) -&gt; cp.Expression:\n    \"\"\"Lower subtraction to CVXPy expression (element-wise left - right).\n\n    Subtraction is affine and always DCP-compliant.\n\n    Args:\n        node: Sub expression node\n\n    Returns:\n        CVXPy expression representing left - right\n    \"\"\"\n    left = self.lower(node.left)\n    right = self.lower(node.right)\n    return left - right\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_sum","title":"<code>_visit_sum(node: Sum) -&gt; cp.Expression</code>","text":"<p>Lower sum reduction to CVXPy expression (sums all elements).</p> <p>Sum preserves DCP properties (sum of convex is convex).</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Sum</code> <p>Sum expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy scalar expression representing the sum of all elements</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Sum)\ndef _visit_sum(self, node: Sum) -&gt; cp.Expression:\n    \"\"\"Lower sum reduction to CVXPy expression (sums all elements).\n\n    Sum preserves DCP properties (sum of convex is convex).\n\n    Args:\n        node: Sum expression node\n\n    Returns:\n        CVXPy scalar expression representing the sum of all elements\n    \"\"\"\n    operand = self.lower(node.operand)\n    return cp.sum(operand)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_tan","title":"<code>_visit_tan(node: Tan) -&gt; cp.Expression</code>","text":"<p>Raise NotImplementedError for tangent function.</p> <p>Tangent is not DCP-compliant in CVXPy as it is neither convex nor concave.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Tan</code> <p>Tan expression node</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always raised since tangent is not DCP-compliant</p> Note <p>For constraints involving trigonometric functions: - Use piecewise-linear approximations, or - Handle in the JAX dynamics/constraint layer instead of CVXPy</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Tan)\ndef _visit_tan(self, node: Tan) -&gt; cp.Expression:\n    \"\"\"Raise NotImplementedError for tangent function.\n\n    Tangent is not DCP-compliant in CVXPy as it is neither convex nor concave.\n\n    Args:\n        node: Tan expression node\n\n    Raises:\n        NotImplementedError: Always raised since tangent is not DCP-compliant\n\n    Note:\n        For constraints involving trigonometric functions:\n        - Use piecewise-linear approximations, or\n        - Handle in the JAX dynamics/constraint layer instead of CVXPy\n    \"\"\"\n    raise NotImplementedError(\n        \"Trigonometric functions like Tan are not DCP-compliant in CVXPy. \"\n        \"Consider using piecewise-linear approximations or handle these constraints \"\n        \"in the dynamics (JAX) layer instead.\"\n    )\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer._visit_transpose","title":"<code>_visit_transpose(node: Transpose) -&gt; cp.Expression</code>","text":"<p>Lower matrix transpose to CVXPy expression.</p> <p>Transpose preserves DCP properties (transpose of convex is convex).</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Transpose</code> <p>Transpose expression node</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression representing operand.T</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>@visitor(Transpose)\ndef _visit_transpose(self, node: Transpose) -&gt; cp.Expression:\n    \"\"\"Lower matrix transpose to CVXPy expression.\n\n    Transpose preserves DCP properties (transpose of convex is convex).\n\n    Args:\n        node: Transpose expression node\n\n    Returns:\n        CVXPy expression representing operand.T\n    \"\"\"\n    operand = self.lower(node.operand)\n    return operand.T\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer.lower","title":"<code>lower(expr: Expr) -&gt; cp.Expression</code>","text":"<p>Lower a symbolic expression to a CVXPy expression.</p> <p>Main entry point for lowering. Delegates to dispatch() which looks up the appropriate visitor method based on the expression type.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Symbolic expression to lower (any Expr subclass)</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression or constraint object. For arithmetic expressions,</p> <code>Expression</code> <p>returns cp.Expression. For Equality/Inequality, returns cp.Constraint.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If no visitor exists for the expression type</p> <code>ValueError</code> <p>If required variables are not in variable_map</p> Example <p>Lower an expression to a CVXPy expression:</p> <pre><code>lowerer = CvxpyLowerer(variable_map={\"x\": cvx_x, \"u\": cvx_u})\nx = ox.State(\"x\", shape=(3,))\nexpr = ox.Norm(x)\ncvx_expr = lowerer.lower(expr)\n</code></pre> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>def lower(self, expr: Expr) -&gt; cp.Expression:\n    \"\"\"Lower a symbolic expression to a CVXPy expression.\n\n    Main entry point for lowering. Delegates to dispatch() which looks up\n    the appropriate visitor method based on the expression type.\n\n    Args:\n        expr: Symbolic expression to lower (any Expr subclass)\n\n    Returns:\n        CVXPy expression or constraint object. For arithmetic expressions,\n        returns cp.Expression. For Equality/Inequality, returns cp.Constraint.\n\n    Raises:\n        NotImplementedError: If no visitor exists for the expression type\n        ValueError: If required variables are not in variable_map\n\n    Example:\n        Lower an expression to a CVXPy expression:\n\n            lowerer = CvxpyLowerer(variable_map={\"x\": cvx_x, \"u\": cvx_u})\n            x = ox.State(\"x\", shape=(3,))\n            expr = ox.Norm(x)\n            cvx_expr = lowerer.lower(expr)\n    \"\"\"\n    return dispatch(self, expr)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer.register_variable","title":"<code>register_variable(name: str, cvx_expr: cp.Expression)</code>","text":"<p>Register a CVXPy variable/expression for use in lowering.</p> <p>Adds or updates a variable in the variable_map. Useful for dynamically adding variables after the lowerer has been created.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Variable name (e.g., \"x\", \"u\", or parameter name)</p> required <code>cvx_expr</code> <code>Expression</code> <p>CVXPy expression to associate with the name</p> required Example <p>Register a variable:</p> <pre><code>lowerer = CvxpyLowerer()\nlowerer.register_variable(\"x\", cp.Variable(3))\nlowerer.register_variable(\"obs_center\", cp.Parameter(3))\n</code></pre> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>def register_variable(self, name: str, cvx_expr: cp.Expression):\n    \"\"\"Register a CVXPy variable/expression for use in lowering.\n\n    Adds or updates a variable in the variable_map. Useful for dynamically\n    adding variables after the lowerer has been created.\n\n    Args:\n        name: Variable name (e.g., \"x\", \"u\", or parameter name)\n        cvx_expr: CVXPy expression to associate with the name\n\n    Example:\n        Register a variable:\n\n            lowerer = CvxpyLowerer()\n            lowerer.register_variable(\"x\", cp.Variable(3))\n            lowerer.register_variable(\"obs_center\", cp.Parameter(3))\n    \"\"\"\n    self.variable_map[name] = cvx_expr\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.dispatch","title":"<code>dispatch(lowerer: Any, expr: Expr)</code>","text":"<p>Dispatch an expression to its registered visitor function.</p> <p>Looks up the visitor function for the expression's type and calls it. This is the core of the visitor pattern implementation.</p> <p>Parameters:</p> Name Type Description Default <code>lowerer</code> <code>Any</code> <p>The CvxpyLowerer instance (provides context for visitor methods)</p> required <code>expr</code> <code>Expr</code> <p>The expression node to lower</p> required <p>Returns:</p> Type Description <p>The result of calling the visitor function (CVXPy expression or constraint)</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If no visitor is registered for the expression type</p> Example <p>Dispatch an expression to lower it:</p> <pre><code>lowerer = CvxpyLowerer(variable_map={...})\nexpr = Add(x, y)\ncvx_expr = dispatch(lowerer, expr)  # Calls visit_add\n</code></pre> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>def dispatch(lowerer: Any, expr: Expr):\n    \"\"\"Dispatch an expression to its registered visitor function.\n\n    Looks up the visitor function for the expression's type and calls it.\n    This is the core of the visitor pattern implementation.\n\n    Args:\n        lowerer: The CvxpyLowerer instance (provides context for visitor methods)\n        expr: The expression node to lower\n\n    Returns:\n        The result of calling the visitor function (CVXPy expression or constraint)\n\n    Raises:\n        NotImplementedError: If no visitor is registered for the expression type\n\n    Example:\n        Dispatch an expression to lower it:\n\n            lowerer = CvxpyLowerer(variable_map={...})\n            expr = Add(x, y)\n            cvx_expr = dispatch(lowerer, expr)  # Calls visit_add\n    \"\"\"\n    fn = _CVXPY_VISITORS.get(type(expr))\n    if fn is None:\n        raise NotImplementedError(\n            f\"{lowerer.__class__.__name__!r} has no visitor for {type(expr).__name__}\"\n        )\n    return fn(lowerer, expr)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.lower_to_cvxpy","title":"<code>lower_to_cvxpy(expr: Expr, variable_map: Dict[str, cp.Expression] = None) -&gt; cp.Expression</code>","text":"<p>Lower symbolic expression to CVXPy expression or constraint.</p> <p>Convenience wrapper that creates a CvxpyLowerer and lowers a single symbolic expression to a CVXPy expression. The result can be used in CVXPy optimization problems.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Symbolic expression to lower (any Expr subclass)</p> required <code>variable_map</code> <code>Dict[str, Expression]</code> <p>Dictionary mapping variable names to CVXPy expressions. Must include \"x\" for states and \"u\" for controls. May include parameter names mapped to CVXPy Parameters or constants.</p> <code>None</code> <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression for arithmetic expressions (Add, Mul, Norm, etc.)</p> <code>Expression</code> <p>or CVXPy constraint for constraint expressions (Equality, Inequality)</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the expression type is not supported (e.g., Sin, Cos, CTCS)</p> <code>ValueError</code> <p>If required variables are missing from variable_map</p> Example <p>Basic expression lowering::</p> <pre><code>import cvxpy as cp\nimport openscvx as ox\n\n# Create CVXPy variables\ncvx_x = cp.Variable(3, name=\"x\")\ncvx_u = cp.Variable(2, name=\"u\")\n\n# Create symbolic expression\nx = ox.State(\"x\", shape=(3,))\nu = ox.Control(\"u\", shape=(2,))\nexpr = ox.Norm(x)**2 + 0.1 * ox.Norm(u)**2\n\n# Lower to CVXPy\ncvx_expr = lower_to_cvxpy(expr, {\"x\": cvx_x, \"u\": cvx_u})\n\n# Use in optimization problem\nprob = cp.Problem(cp.Minimize(cvx_expr))\nprob.solve()\n</code></pre> <p>Constraint lowering::</p> <pre><code># Symbolic constraint\nconstraint = ox.Norm(x) &lt;= 1.0\n\n# Lower to CVXPy constraint\ncvx_constraint = lower_to_cvxpy(constraint, {\"x\": cvx_x, \"u\": cvx_u})\n\n# Use in problem\nprob = cp.Problem(cp.Minimize(cost), constraints=[cvx_constraint])\n</code></pre> See Also <ul> <li>CvxpyLowerer: The underlying lowerer class</li> <li>lower_to_jax(): Convenience wrapper for JAX lowering</li> <li>lower_symbolic_expressions(): Main orchestrator in symbolic/lower.py</li> </ul> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>def lower_to_cvxpy(expr: Expr, variable_map: Dict[str, cp.Expression] = None) -&gt; cp.Expression:\n    \"\"\"Lower symbolic expression to CVXPy expression or constraint.\n\n    Convenience wrapper that creates a CvxpyLowerer and lowers a single\n    symbolic expression to a CVXPy expression. The result can be used in\n    CVXPy optimization problems.\n\n    Args:\n        expr: Symbolic expression to lower (any Expr subclass)\n        variable_map: Dictionary mapping variable names to CVXPy expressions.\n            Must include \"x\" for states and \"u\" for controls. May include\n            parameter names mapped to CVXPy Parameters or constants.\n\n    Returns:\n        CVXPy expression for arithmetic expressions (Add, Mul, Norm, etc.)\n        or CVXPy constraint for constraint expressions (Equality, Inequality)\n\n    Raises:\n        NotImplementedError: If the expression type is not supported (e.g., Sin, Cos, CTCS)\n        ValueError: If required variables are missing from variable_map\n\n    Example:\n        Basic expression lowering::\n\n            import cvxpy as cp\n            import openscvx as ox\n\n            # Create CVXPy variables\n            cvx_x = cp.Variable(3, name=\"x\")\n            cvx_u = cp.Variable(2, name=\"u\")\n\n            # Create symbolic expression\n            x = ox.State(\"x\", shape=(3,))\n            u = ox.Control(\"u\", shape=(2,))\n            expr = ox.Norm(x)**2 + 0.1 * ox.Norm(u)**2\n\n            # Lower to CVXPy\n            cvx_expr = lower_to_cvxpy(expr, {\"x\": cvx_x, \"u\": cvx_u})\n\n            # Use in optimization problem\n            prob = cp.Problem(cp.Minimize(cvx_expr))\n            prob.solve()\n\n        Constraint lowering::\n\n            # Symbolic constraint\n            constraint = ox.Norm(x) &lt;= 1.0\n\n            # Lower to CVXPy constraint\n            cvx_constraint = lower_to_cvxpy(constraint, {\"x\": cvx_x, \"u\": cvx_u})\n\n            # Use in problem\n            prob = cp.Problem(cp.Minimize(cost), constraints=[cvx_constraint])\n\n    See Also:\n        - CvxpyLowerer: The underlying lowerer class\n        - lower_to_jax(): Convenience wrapper for JAX lowering\n        - lower_symbolic_expressions(): Main orchestrator in symbolic/lower.py\n    \"\"\"\n    lowerer = CvxpyLowerer(variable_map)\n    return lowerer.lower(expr)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.visitor","title":"<code>visitor(expr_cls: Type[Expr])</code>","text":"<p>Decorator to register a visitor function for an expression type.</p> <p>This decorator registers a visitor method to handle a specific expression type during CVXPy lowering. The decorated function is stored in _CVXPY_VISITORS and will be called by dispatch() when lowering that expression type.</p> <p>Parameters:</p> Name Type Description Default <code>expr_cls</code> <code>Type[Expr]</code> <p>The Expr subclass this visitor handles (e.g., Add, Mul, Norm)</p> required <p>Returns:</p> Type Description <p>Decorator function that registers the visitor and returns it unchanged</p> Example <p>Register a function as the visitor for the Add expression:</p> <pre><code>@visitor(Add)\ndef _visit_add(self, node: Add):\n    # Lower addition to CVXPy\n    ...\n</code></pre> Note <p>Multiple expression types can share a visitor by stacking decorators::</p> <pre><code>@visitor(Equality)\n@visitor(Inequality)\ndef _visit_constraint(self, node: Constraint):\n    # Handle both equality and inequality\n    ...\n</code></pre> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>def visitor(expr_cls: Type[Expr]):\n    \"\"\"Decorator to register a visitor function for an expression type.\n\n    This decorator registers a visitor method to handle a specific expression\n    type during CVXPy lowering. The decorated function is stored in _CVXPY_VISITORS\n    and will be called by dispatch() when lowering that expression type.\n\n    Args:\n        expr_cls: The Expr subclass this visitor handles (e.g., Add, Mul, Norm)\n\n    Returns:\n        Decorator function that registers the visitor and returns it unchanged\n\n    Example:\n        Register a function as the visitor for the Add expression:\n\n            @visitor(Add)\n            def _visit_add(self, node: Add):\n                # Lower addition to CVXPy\n                ...\n\n    Note:\n        Multiple expression types can share a visitor by stacking decorators::\n\n            @visitor(Equality)\n            @visitor(Inequality)\n            def _visit_constraint(self, node: Constraint):\n                # Handle both equality and inequality\n                ...\n    \"\"\"\n\n    def register(fn: Callable[[Any, Expr], cp.Expression]):\n        _CVXPY_VISITORS[expr_cls] = fn\n        return fn\n\n    return register\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/","title":"jax","text":"<p>JAX backend for lowering symbolic expressions to executable functions.</p> <p>This module implements the JAX lowering backend that converts symbolic expression AST nodes into JAX functions with automatic differentiation support. The lowering uses a visitor pattern where each expression type has a corresponding visitor method.</p> Architecture <p>The JAX lowerer follows a visitor pattern with centralized registration:</p> <ol> <li>Visitor Registration: The @visitor decorator registers handler functions    for each expression type in the _JAX_VISITORS dictionary</li> <li>Dispatch: The dispatch() function looks up and calls the appropriate    visitor based on the expression's type</li> <li>Recursive Lowering: Each visitor recursively lowers child expressions    and composes JAX operations</li> <li>Standardized Signature: All lowered functions have signature    (x, u, node, params) -&gt; result for uniformity</li> </ol> Key Features <ul> <li>Automatic Differentiation: Lowered functions can be differentiated using   JAX's jacfwd/jacrev for computing Jacobians</li> <li>JIT Compilation: All functions are JAX-traceable and JIT-compatible</li> <li>Functional Closures: Each visitor returns a closure that captures   necessary constants and child functions</li> <li>Broadcasting: Supports NumPy-style broadcasting through jnp operations</li> </ul> Lowered Function Signature <p>All lowered functions have a uniform signature::</p> <pre><code>f(x, u, node, params) -&gt; result\n</code></pre> <p>Where:</p> <ul> <li>x: State vector (jnp.ndarray)</li> <li>u: Control vector (jnp.ndarray)</li> <li>node: Node index for time-varying behavior (scalar or array)</li> <li>params: Dictionary of parameter values (dict[str, Any])</li> <li>result: JAX array (scalar, vector, or matrix)</li> </ul> Example <p>Basic usage::</p> <pre><code>from openscvx.symbolic.lowerers.jax import JaxLowerer\nimport openscvx as ox\n\n# Create symbolic expression\nx = ox.State(\"x\", shape=(3,))\nu = ox.Control(\"u\", shape=(2,))\nexpr = ox.Norm(x)**2 + 0.1 * ox.Norm(u)**2\n\n# Lower to JAX\nlowerer = JaxLowerer()\nf = lowerer.lower(expr)\n\n# Evaluate\nimport jax.numpy as jnp\nx_val = jnp.array([1.0, 2.0, 3.0])\nu_val = jnp.array([0.5, 0.5])\nresult = f(x_val, u_val, node=0, params={})\n\n# Differentiate\nfrom jax import jacfwd\ndf_dx = jacfwd(f, argnums=0)\ngradient = df_dx(x_val, u_val, node=0, params={})\n</code></pre> For Contributors <p>Adding Support for New Expression Types</p> <p>To add support for a new symbolic expression type to JAX lowering:</p> <ol> <li> <p>Define the visitor method in JaxLowerer with the @visitor decorator::</p> <p>@visitor(MyNewExpr) def _visit_my_new_expr(self, node: MyNewExpr):     # Lower child expressions recursively     operand_fn = self.lower(node.operand)</p> <pre><code># Return a closure with signature (x, u, node, params) -&gt; result\nreturn lambda x, u, node, params: jnp.my_operation(\n    operand_fn(x, u, node, params)\n)\n</code></pre> </li> <li> <p>Key requirements:</p> <ul> <li>Use the @visitor(ExprType) decorator to register the handler</li> <li>Method name should be visit (private, lowercase, snake_case) <li>Recursively lower all child expressions using self.lower()</li> <li>Return a closure with signature (x, u, node, params) -&gt; jax_array</li> <li>Use jnp.* operations (not np.*) for JAX traceability</li> <li>Ensure the result is JAX-differentiable (avoid Python control flow)</li> <li> <p>Example patterns:</p> <ul> <li>Unary operation: Lower operand, apply jnp function</li> <li>Binary operation: Lower both operands, combine with jnp operation</li> <li>N-ary operation: Lower all operands, reduce or combine them</li> <li>Conditional logic: Use jax.lax.cond for branching (see _visit_ctcs)</li> </ul> </li> <li> <p>Testing: Ensure your visitor works with:</p> <ul> <li>JAX JIT compilation: jax.jit(lowered_fn)</li> <li>Automatic differentiation: jax.jacfwd(lowered_fn, argnums=0)</li> <li>Vectorization: jax.vmap(lowered_fn)</li> </ul> </li> See Also <ul> <li>lower_to_jax(): Convenience wrapper in symbolic/lower.py</li> <li>CVXPyLowerer: Alternative backend for convex constraints</li> <li>dispatch(): Core dispatch function for visitor pattern</li> </ul>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax._JAX_VISITORS","title":"<code>_JAX_VISITORS: Dict[Type[Expr], Callable] = {}</code>  <code>module-attribute</code>","text":"<p>Registry mapping expression types to their visitor functions.</p>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer","title":"<code>JaxLowerer</code>","text":"<p>JAX backend for lowering symbolic expressions to executable functions.</p> <p>This class implements the visitor pattern for converting symbolic expression AST nodes to JAX functions. Each expression type has a corresponding visitor method decorated with @visitor that handles the lowering logic.</p> <p>The lowering process is recursive: each visitor lowers its child expressions first, then composes them into a JAX operation. All lowered functions have a standardized signature (x, u, node, params) -&gt; result.</p> Example <p>Set up the JaxLowerer and lower an expression to a JAX function:</p> <pre><code>lowerer = JaxLowerer()\nexpr = ox.Norm(x)**2 + 0.1 * ox.Norm(u)**2\nf = lowerer.lower(expr)\nresult = f(x_val, u_val, node=0, params={})\n</code></pre> Note <p>The lowerer is stateless and can be reused for multiple expressions. All visitor methods are instance methods to maintain a clean interface, but they don't modify instance state.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>class JaxLowerer:\n    \"\"\"JAX backend for lowering symbolic expressions to executable functions.\n\n    This class implements the visitor pattern for converting symbolic expression\n    AST nodes to JAX functions. Each expression type has a corresponding visitor\n    method decorated with @visitor that handles the lowering logic.\n\n    The lowering process is recursive: each visitor lowers its child expressions\n    first, then composes them into a JAX operation. All lowered functions have\n    a standardized signature (x, u, node, params) -&gt; result.\n\n    Attributes:\n        None (stateless lowerer - all state is in the expression tree)\n\n    Example:\n        Set up the JaxLowerer and lower an expression to a JAX function:\n\n            lowerer = JaxLowerer()\n            expr = ox.Norm(x)**2 + 0.1 * ox.Norm(u)**2\n            f = lowerer.lower(expr)\n            result = f(x_val, u_val, node=0, params={})\n\n    Note:\n        The lowerer is stateless and can be reused for multiple expressions.\n        All visitor methods are instance methods to maintain a clean interface,\n        but they don't modify instance state.\n    \"\"\"\n\n    def lower(self, expr: Expr):\n        \"\"\"Lower a symbolic expression to a JAX function.\n\n        Main entry point for lowering. Delegates to dispatch() which looks up\n        the appropriate visitor method based on the expression type.\n\n        Args:\n            expr: Symbolic expression to lower (any Expr subclass)\n\n        Returns:\n            JAX function with signature (x, u, node, params) -&gt; result\n\n        Raises:\n            NotImplementedError: If no visitor exists for the expression type\n            ValueError: If the expression is malformed (e.g., State without slice)\n\n        Example:\n            Lower an expression to a JAX function:\n\n                lowerer = JaxLowerer()\n                x = ox.State(\"x\", shape=(3,))\n                expr = ox.Norm(x)\n                f = lowerer.lower(expr)\n                # f is now callable\n        \"\"\"\n        return dispatch(self, expr)\n\n    @visitor(Constant)\n    def _visit_constant(self, node: Constant):\n        \"\"\"Lower a constant value to a JAX function.\n\n        Captures the constant value and returns a function that always returns it.\n        Scalar constants are squeezed to ensure they're true scalars, not (1,) arrays.\n\n        Args:\n            node: Constant expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; constant_value\n        \"\"\"\n        # capture the constant value once\n        value = jnp.array(node.value)\n        # For scalar constants (single element arrays), squeeze to scalar\n        # This prevents (1,) shapes in constraint residuals\n        if value.size == 1:\n            value = value.squeeze()\n        return lambda x, u, node, params: value\n\n    @visitor(State)\n    def _visit_state(self, node: State):\n        \"\"\"Lower a state variable to a JAX function.\n\n        Extracts the appropriate slice from the unified state vector x using\n        the slice assigned during unification.\n\n        Args:\n            node: State expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; x[slice]\n\n        Raises:\n            ValueError: If the state has no slice assigned (unification not run)\n        \"\"\"\n        sl = node._slice\n        if sl is None:\n            raise ValueError(f\"State {node.name!r} has no slice assigned\")\n        return lambda x, u, node, params: x[sl]\n\n    @visitor(Control)\n    def _visit_control(self, node: Control):\n        \"\"\"Lower a control variable to a JAX function.\n\n        Extracts the appropriate slice from the unified control vector u using\n        the slice assigned during unification.\n\n        Args:\n            node: Control expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; u[slice]\n\n        Raises:\n            ValueError: If the control has no slice assigned (unification not run)\n        \"\"\"\n        sl = node._slice\n        if sl is None:\n            raise ValueError(f\"Control {node.name!r} has no slice assigned\")\n        return lambda x, u, node, params: u[sl]\n\n    @visitor(Parameter)\n    def _visit_parameter(self, node: Parameter):\n        \"\"\"Lower a parameter to a JAX function.\n\n        Parameters are looked up by name in the params dictionary at evaluation time,\n        allowing runtime parameter updates without recompilation.\n\n        Args:\n            node: Parameter expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; params[name]\n        \"\"\"\n        param_name = node.name\n        return lambda x, u, node, params: jnp.array(params[param_name])\n\n    @visitor(Add)\n    def _visit_add(self, node: Add):\n        \"\"\"Lower addition to JAX function.\n\n        Recursively lowers all terms and composes them with element-wise addition.\n        Supports broadcasting following NumPy/JAX rules.\n\n        Args:\n            node: Add expression node with multiple terms\n\n        Returns:\n            Function (x, u, node, params) -&gt; sum of all terms\n        \"\"\"\n        fs = [self.lower(term) for term in node.terms]\n\n        def fn(x, u, node, params):\n            acc = fs[0](x, u, node, params)\n            for f in fs[1:]:\n                acc = acc + f(x, u, node, params)\n            return acc\n\n        return fn\n\n    @visitor(Sub)\n    def _visit_sub(self, node: Sub):\n        \"\"\"Lower subtraction to JAX function (element-wise left - right).\"\"\"\n        fL = self.lower(node.left)\n        fR = self.lower(node.right)\n        return lambda x, u, node, params: fL(x, u, node, params) - fR(x, u, node, params)\n\n    @visitor(Mul)\n    def _visit_mul(self, node: Mul):\n        \"\"\"Lower element-wise multiplication to JAX function (Hadamard product).\"\"\"\n        fs = [self.lower(factor) for factor in node.factors]\n\n        def fn(x, u, node, params):\n            acc = fs[0](x, u, node, params)\n            for f in fs[1:]:\n                acc = acc * f(x, u, node, params)\n            return acc\n\n        return fn\n\n    @visitor(Div)\n    def _visit_div(self, node: Div):\n        \"\"\"Lower element-wise division to JAX function.\"\"\"\n        fL = self.lower(node.left)\n        fR = self.lower(node.right)\n        return lambda x, u, node, params: fL(x, u, node, params) / fR(x, u, node, params)\n\n    @visitor(MatMul)\n    def _visit_matmul(self, node: MatMul):\n        \"\"\"Lower matrix multiplication to JAX function using jnp.matmul.\"\"\"\n        fL = self.lower(node.left)\n        fR = self.lower(node.right)\n        return lambda x, u, node, params: jnp.matmul(fL(x, u, node, params), fR(x, u, node, params))\n\n    @visitor(Neg)\n    def _visit_neg(self, node: Neg):\n        \"\"\"Lower negation (unary minus) to JAX function.\"\"\"\n        fO = self.lower(node.operand)\n        return lambda x, u, node, params: -fO(x, u, node, params)\n\n    @visitor(Sum)\n    def _visit_sum(self, node: Sum):\n        \"\"\"Lower sum reduction to JAX function (sums all elements).\"\"\"\n        f = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.sum(f(x, u, node, params))\n\n    @visitor(Norm)\n    def _visit_norm(self, node: Norm):\n        \"\"\"Lower norm operation to JAX function.\n\n        Converts symbolic norm to jnp.linalg.norm with appropriate ord parameter.\n        Handles string ord values like \"inf\", \"-inf\", \"fro\".\n\n        Args:\n            node: Norm expression node with ord attribute\n\n        Returns:\n            Function (x, u, node, params) -&gt; norm of operand\n        \"\"\"\n        f = self.lower(node.operand)\n        ord_val = node.ord\n\n        # Convert string ord values to appropriate JAX values\n        if ord_val == \"inf\":\n            ord_val = jnp.inf\n        elif ord_val == \"-inf\":\n            ord_val = -jnp.inf\n        elif ord_val == \"fro\":\n            # For vectors, Frobenius norm is the same as 2-norm\n            ord_val = None  # Default is 2-norm\n\n        return lambda x, u, node, params: jnp.linalg.norm(f(x, u, node, params), ord=ord_val)\n\n    @visitor(Index)\n    def _visit_index(self, node: Index):\n        \"\"\"Lower indexing/slicing operation to JAX function.\"\"\"\n        # lower the \"base\" expr into a fn(x,u,node), then index it\n        f_base = self.lower(node.base)\n        idx = node.index\n        return lambda x, u, node, params: jnp.atleast_1d(f_base(x, u, node, params))[idx]\n\n    @visitor(Concat)\n    def _visit_concat(self, node: Concat):\n        \"\"\"Lower concatenation to JAX function (concatenates along axis 0).\"\"\"\n        # lower each child\n        fn_list = [self.lower(child) for child in node.exprs]\n\n        # wrapper that promotes scalars to 1-D and concatenates\n        def concat_fn(x, u, node, params):\n            parts = [jnp.atleast_1d(fn(x, u, node, params)) for fn in fn_list]\n            return jnp.concatenate(parts, axis=0)\n\n        return concat_fn\n\n    @visitor(Sin)\n    def _visit_sin(self, node: Sin):\n        \"\"\"Lower sine function to JAX function.\"\"\"\n        fO = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.sin(fO(x, u, node, params))\n\n    @visitor(Cos)\n    def _visit_cos(self, node: Cos):\n        \"\"\"Lower cosine function to JAX function.\"\"\"\n        fO = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.cos(fO(x, u, node, params))\n\n    @visitor(Tan)\n    def _visit_tan(self, node: Tan):\n        \"\"\"Lower tangent function to JAX function.\"\"\"\n        fO = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.tan(fO(x, u, node, params))\n\n    @visitor(Exp)\n    def _visit_exp(self, node: Exp):\n        \"\"\"Lower exponential function to JAX function.\"\"\"\n        fO = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.exp(fO(x, u, node, params))\n\n    @visitor(Log)\n    def _visit_log(self, node: Log):\n        \"\"\"Lower natural logarithm to JAX function.\"\"\"\n        fO = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.log(fO(x, u, node, params))\n\n    @visitor(Abs)\n    def _visit_abs(self, node: Abs):\n        \"\"\"Lower absolute value to JAX function.\"\"\"\n        fO = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.abs(fO(x, u, node, params))\n\n    @visitor(Equality)\n    @visitor(Inequality)\n    def _visit_constraint(self, node: Constraint):\n        \"\"\"Lower constraint to residual function.\n\n        Both equality (lhs == rhs) and inequality (lhs &lt;= rhs) constraints are\n        lowered to their residual form: lhs - rhs. The constraint is satisfied\n        when the residual equals zero (equality) or is non-positive (inequality).\n\n        Args:\n            node: Equality or Inequality constraint node\n\n        Returns:\n            Function (x, u, node, params) -&gt; lhs - rhs (constraint residual)\n\n        Note:\n            The returned residual is used in penalty methods and Lagrangian terms.\n            For equality: residual should be 0\n            For inequality: residual should be &lt;= 0\n        \"\"\"\n        fL = self.lower(node.lhs)\n        fR = self.lower(node.rhs)\n        return lambda x, u, node, params: fL(x, u, node, params) - fR(x, u, node, params)\n\n    # TODO: (norrisg) CTCS is playing 2 roles here: both as a constraint wrapper and as the penalty\n    # expression w/ conditional logic. Consider adding conditional logic as separate AST nodes.\n    # Then, CTCS remains a wrapper and we just wrap the penalty expression with the conditional\n    # logic when we lower it.\n    @visitor(CTCS)\n    def _visit_ctcs(self, node: CTCS):\n        \"\"\"Lower CTCS (Continuous-Time Constraint Satisfaction) to JAX function.\n\n        CTCS constraints use penalty methods to enforce constraints over continuous\n        time intervals. The lowered function includes conditional logic to activate\n        the penalty only within the specified node interval.\n\n        Args:\n            node: CTCS constraint node with penalty expression and optional node range\n\n        Returns:\n            Function (x, u, current_node, params) -&gt; penalty value or 0\n\n        Note:\n            Uses jax.lax.cond for JAX-traceable conditional evaluation. The penalty\n            is active only when current_node is in [start_node, end_node).\n            If no node range is specified, the penalty is always active.\n\n        See Also:\n            - CTCS: The symbolic CTCS constraint class\n            - penalty functions: PositivePart, Huber, SmoothReLU\n        \"\"\"\n        # Lower the penalty expression (which includes the constraint residual)\n        penalty_expr_fn = self.lower(node.penalty_expr())\n\n        def ctcs_fn(x, u, current_node, params):\n            # Check if constraint is active at this node\n            if node.nodes is not None:\n                start_node, end_node = node.nodes\n                # Extract scalar value from current_node (which may be array or scalar)\n                # Keep as JAX array for tracing compatibility\n                node_scalar = jnp.atleast_1d(current_node)[0]\n                is_active = (start_node &lt;= node_scalar) &amp; (node_scalar &lt; end_node)\n\n                # Use jax.lax.cond for conditional evaluation\n                return cond(\n                    is_active,\n                    lambda _: penalty_expr_fn(x, u, current_node, params),\n                    lambda _: 0.0,\n                    operand=None,\n                )\n            else:\n                # Always active if no node range specified\n                return penalty_expr_fn(x, u, current_node, params)\n\n        return ctcs_fn\n\n    @visitor(PositivePart)\n    def _visit_pos(self, node):\n        \"\"\"Lower positive part function to JAX.\n\n        Computes max(x, 0), used in penalty methods for inequality constraints.\n\n        Args:\n            node: PositivePart expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; max(operand, 0)\n        \"\"\"\n        f = self.lower(node.x)\n        return lambda x, u, node, params: jnp.maximum(f(x, u, node, params), 0.0)\n\n    @visitor(Square)\n    def _visit_square(self, node):\n        \"\"\"Lower square function to JAX.\n\n        Computes x^2 element-wise. Used in quadratic penalty methods.\n\n        Args:\n            node: Square expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; operand^2\n        \"\"\"\n        f = self.lower(node.x)\n        return lambda x, u, node, params: f(x, u, node, params) * f(x, u, node, params)\n\n    @visitor(Huber)\n    def _visit_huber(self, node):\n        \"\"\"Lower Huber penalty function to JAX.\n\n        Huber penalty is quadratic for small values and linear for large values:\n        - |x| &lt;= delta: 0.5 * x^2\n        - |x| &gt; delta: delta * (|x| - 0.5 * delta)\n\n        Args:\n            node: Huber expression node with delta parameter\n\n        Returns:\n            Function (x, u, node, params) -&gt; Huber penalty\n        \"\"\"\n        f = self.lower(node.x)\n        delta = node.delta\n        return lambda x, u, node, params: jnp.where(\n            jnp.abs(f(x, u, node, params)) &lt;= delta,\n            0.5 * f(x, u, node, params) ** 2,\n            delta * (jnp.abs(f(x, u, node, params)) - 0.5 * delta),\n        )\n\n    @visitor(SmoothReLU)\n    def _visit_srelu(self, node):\n        \"\"\"Lower smooth ReLU penalty function to JAX.\n\n        Smooth approximation to ReLU: sqrt(max(x, 0)^2 + c^2) - c\n        Differentiable everywhere, approaches ReLU as c -&gt; 0.\n\n        Args:\n            node: SmoothReLU expression node with smoothing parameter c\n\n        Returns:\n            Function (x, u, node, params) -&gt; smooth ReLU penalty\n        \"\"\"\n        f = self.lower(node.x)\n        c = node.c\n        # smooth_relu(pos(x)) = sqrt(pos(x)^2 + c^2) - c ; here f already includes pos inside node\n        return (\n            lambda x, u, node, params: jnp.sqrt(jnp.maximum(f(x, u, node, params), 0.0) ** 2 + c**2)\n            - c\n        )\n\n    @visitor(NodalConstraint)\n    def _visit_nodal_constraint(self, node: NodalConstraint):\n        \"\"\"Lower a NodalConstraint by lowering its underlying constraint.\n\n        NodalConstraint is a wrapper that specifies which nodes a constraint\n        applies to. The lowering just unwraps and lowers the inner constraint.\n\n        Args:\n            node: NodalConstraint wrapper\n\n        Returns:\n            Function from lowering the wrapped constraint expression\n        \"\"\"\n        return self.lower(node.constraint)\n\n    @visitor(Sqrt)\n    def _visit_sqrt(self, node: Sqrt):\n        \"\"\"Lower square root to JAX function.\"\"\"\n        f = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.sqrt(f(x, u, node, params))\n\n    @visitor(Max)\n    def _visit_max(self, node: Max):\n        \"\"\"Lower element-wise maximum to JAX function.\"\"\"\n        fs = [self.lower(op) for op in node.operands]\n\n        def fn(x, u, node, params):\n            values = [f(x, u, node, params) for f in fs]\n            # jnp.maximum can take multiple arguments\n            result = values[0]\n            for val in values[1:]:\n                result = jnp.maximum(result, val)\n            return result\n\n        return fn\n\n    @visitor(LogSumExp)\n    def _visit_logsumexp(self, node: LogSumExp):\n        \"\"\"Lower log-sum-exp to JAX function.\n\n        Computes log(sum(exp(x_i))) for multiple operands, which is a smooth\n        approximation to the maximum function. Uses JAX's numerically stable\n        logsumexp implementation. Performs element-wise log-sum-exp with\n        broadcasting support.\n        \"\"\"\n        fs = [self.lower(op) for op in node.operands]\n\n        def fn(x, u, node, params):\n            values = [f(x, u, node, params) for f in fs]\n            # Broadcast all values to the same shape, then stack along new axis\n            # and compute logsumexp along that axis for element-wise operation\n            broadcasted = jnp.broadcast_arrays(*values)\n            stacked = jnp.stack(list(broadcasted), axis=0)\n            return logsumexp(stacked, axis=0)\n\n        return fn\n\n    @visitor(Transpose)\n    def _visit_transpose(self, node: Transpose):\n        \"\"\"Lower matrix transpose to JAX function.\"\"\"\n        f = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.transpose(f(x, u, node, params))\n\n    @visitor(Power)\n    def _visit_power(self, node: Power):\n        \"\"\"Lower element-wise power (base**exponent) to JAX function.\"\"\"\n        fB = self.lower(node.base)\n        fE = self.lower(node.exponent)\n        return lambda x, u, node, params: jnp.power(fB(x, u, node, params), fE(x, u, node, params))\n\n    @visitor(Stack)\n    def _visit_stack(self, node: Stack):\n        \"\"\"Lower vertical stacking to JAX function (stack along axis 0).\"\"\"\n        row_fns = [self.lower(row) for row in node.rows]\n\n        def stack_fn(x, u, node, params):\n            rows = [jnp.atleast_1d(fn(x, u, node, params)) for fn in row_fns]\n            return jnp.stack(rows, axis=0)\n\n        return stack_fn\n\n    @visitor(Hstack)\n    def _visit_hstack(self, node: Hstack):\n        \"\"\"Lower horizontal stacking to JAX function.\"\"\"\n        array_fns = [self.lower(arr) for arr in node.arrays]\n\n        def hstack_fn(x, u, node, params):\n            arrays = [jnp.atleast_1d(fn(x, u, node, params)) for fn in array_fns]\n            return jnp.hstack(arrays)\n\n        return hstack_fn\n\n    @visitor(Vstack)\n    def _visit_vstack(self, node: Vstack):\n        \"\"\"Lower vertical stacking to JAX function.\"\"\"\n        array_fns = [self.lower(arr) for arr in node.arrays]\n\n        def vstack_fn(x, u, node, params):\n            arrays = [jnp.atleast_1d(fn(x, u, node, params)) for fn in array_fns]\n            return jnp.vstack(arrays)\n\n        return vstack_fn\n\n    @visitor(QDCM)\n    def _visit_qdcm(self, node: QDCM):\n        \"\"\"Lower quaternion to direction cosine matrix (DCM) conversion.\n\n        Converts a unit quaternion [q0, q1, q2, q3] to a 3x3 rotation matrix.\n        Used in 6-DOF spacecraft and robotics applications.\n\n        The quaternion is normalized before conversion to ensure a valid rotation\n        matrix. The DCM is computed using the standard quaternion-to-DCM formula.\n\n        Args:\n            node: QDCM expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; 3x3 rotation matrix\n\n        Note:\n            Quaternion convention: [w, x, y, z] where w is the scalar part\n        \"\"\"\n        f = self.lower(node.q)\n\n        def qdcm_fn(x, u, node, params):\n            q = f(x, u, node, params)\n            # Normalize the quaternion\n            q_norm = jnp.sqrt(q[0] ** 2 + q[1] ** 2 + q[2] ** 2 + q[3] ** 2)\n            w, qx, qy, qz = q / q_norm\n            # Convert to direction cosine matrix\n            return jnp.array(\n                [\n                    [1 - 2 * (qy**2 + qz**2), 2 * (qx * qy - qz * w), 2 * (qx * qz + qy * w)],\n                    [2 * (qx * qy + qz * w), 1 - 2 * (qx**2 + qz**2), 2 * (qy * qz - qx * w)],\n                    [2 * (qx * qz - qy * w), 2 * (qy * qz + qx * w), 1 - 2 * (qx**2 + qy**2)],\n                ]\n            )\n\n        return qdcm_fn\n\n    @visitor(SSMP)\n    def _visit_ssmp(self, node: SSMP):\n        \"\"\"Lower skew-symmetric matrix for quaternion dynamics (4x4).\n\n        Creates a 4x4 skew-symmetric matrix from angular velocity vector for\n        quaternion kinematic propagation: q_dot = 0.5 * SSMP(omega) @ q\n\n        The SSMP matrix is used in quaternion kinematics to compute quaternion\n        derivatives from angular velocity vectors.\n\n        Args:\n            node: SSMP expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; 4x4 skew-symmetric matrix\n\n        Note:\n            For angular velocity w = [x, y, z], returns:\n            [[0, -x, -y, -z],\n             [x,  0,  z, -y],\n             [y, -z,  0,  x],\n             [z,  y, -x,  0]]\n        \"\"\"\n        f = self.lower(node.w)\n\n        def ssmp_fn(x, u, node, params):\n            w = f(x, u, node, params)\n            wx, wy, wz = w[0], w[1], w[2]\n            return jnp.array(\n                [\n                    [0, -wx, -wy, -wz],\n                    [wx, 0, wz, -wy],\n                    [wy, -wz, 0, wx],\n                    [wz, wy, -wx, 0],\n                ]\n            )\n\n        return ssmp_fn\n\n    @visitor(SSM)\n    def _visit_ssm(self, node: SSM):\n        \"\"\"Lower skew-symmetric matrix for cross product (3x3).\n\n        Creates a 3x3 skew-symmetric matrix from a vector such that\n        SSM(a) @ b = a x b (cross product).\n\n        The SSM is the matrix representation of the cross product operator,\n        allowing cross products to be computed as matrix-vector multiplication.\n\n        Args:\n            node: SSM expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; 3x3 skew-symmetric matrix\n\n        Note:\n            For vector w = [x, y, z], returns:\n            [[ 0, -z,  y],\n             [ z,  0, -x],\n             [-y,  x,  0]]\n        \"\"\"\n        f = self.lower(node.w)\n\n        def ssm_fn(x, u, node, params):\n            w = f(x, u, node, params)\n            wx, wy, wz = w[0], w[1], w[2]\n            return jnp.array([[0, -wz, wy], [wz, 0, -wx], [-wy, wx, 0]])\n\n        return ssm_fn\n\n    @visitor(Diag)\n    def _visit_diag(self, node: Diag):\n        \"\"\"Lower diagonal matrix construction to JAX function.\"\"\"\n        f = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.diag(f(x, u, node, params))\n\n    @visitor(Or)\n    def _visit_or(self, node: Or):\n        \"\"\"Lower STL disjunction (Or) to JAX using STLJax library.\n\n        Converts a symbolic Or constraint to an STLJax Or formula for handling\n        disjunctive task specifications. Each operand becomes an STLJax predicate.\n\n        Args:\n            node: Or expression node with multiple operands\n\n        Returns:\n            Function (x, u, node, params) -&gt; STL robustness value\n\n        Note:\n            Uses STLJax library for signal temporal logic evaluation. The returned\n            function computes the robustness metric for the disjunction, which is\n            positive when at least one operand is satisfied.\n\n        Example:\n            Used for task specifications like \"reach goal A OR goal B\"::\n\n                goal_A = ox.Norm(x - target_A) &lt;= 1.0\n                goal_B = ox.Norm(x - target_B) &lt;= 1.0\n                task = ox.Or(goal_A, goal_B)\n\n        See Also:\n            - stljax.formula.Or: Underlying STLJax implementation\n            - STL robustness: Quantitative measure of constraint satisfaction\n        \"\"\"\n        from stljax.formula import Or as STLOr\n        from stljax.formula import Predicate\n\n        # Lower each operand to get their functions\n        operand_fns = [self.lower(operand) for operand in node.operands]\n\n        # Return a function that evaluates the STLJax Or\n        def or_fn(x, u, node, params):\n            # Create STLJax predicates for each operand with current params\n            predicates = []\n            for i, operand_fn in enumerate(operand_fns):\n                # Create a predicate function that captures the current params\n                def make_pred_fn(fn):\n                    return lambda x: fn(x, None, None, params)\n\n                pred_fn = make_pred_fn(operand_fn)\n                predicates.append(Predicate(f\"pred_{i}\", pred_fn))\n\n            # Create and evaluate STLJax Or formula\n            stl_or = STLOr(*predicates)\n            return stl_or(x)\n\n        return or_fn\n\n    @visitor(NodeReference)\n    def _visit_node_reference(self, node: NodeReference):\n        \"\"\"Lower NodeReference - extract value at a specific trajectory node.\n\n        NodeReference extracts a state/control value at a specific node from the\n        full trajectory arrays. The node index is baked into the lowered function.\n\n        Args:\n            node: NodeReference expression with base and node_idx (integer)\n\n        Returns:\n            Function (x, u, node_param, params) that extracts from trajectory\n                - x, u: Full trajectories (N, n_x) and (N, n_u)\n                - node_param: Unused (kept for signature compatibility)\n                - params: Problem parameters\n\n        Example:\n            position.at(5) lowers to a function that extracts x[5, position_slice]\n            position.at(k-1) where k=7 lowers to extract x[6, position_slice]\n        \"\"\"\n        from openscvx.symbolic.expr.control import Control\n        from openscvx.symbolic.expr.state import State\n\n        # Node index is baked into the expression at construction time\n        fixed_idx = node.node_idx\n\n        if isinstance(node.base, State):\n            sl = node.base._slice\n            if sl is None:\n                raise ValueError(f\"State {node.base.name!r} has no slice assigned\")\n\n            def state_node_fn(x, u, node_param, params):\n                return x[fixed_idx, sl]\n\n            return state_node_fn\n\n        elif isinstance(node.base, Control):\n            sl = node.base._slice\n            if sl is None:\n                raise ValueError(f\"Control {node.base.name!r} has no slice assigned\")\n\n            def control_node_fn(x, u, node_param, params):\n                return u[fixed_idx, sl]\n\n            return control_node_fn\n\n        else:\n            # Compound expression (e.g., position[0].at(5))\n            base_fn = self.lower(node.base)\n\n            def compound_node_fn(x, u, node_param, params):\n                # Extract single-node slices and evaluate base expression\n                x_single = x[fixed_idx] if len(x.shape) &gt; 1 else x\n                u_single = u[fixed_idx] if len(u.shape) &gt; 1 else u\n                return base_fn(x_single, u_single, fixed_idx, params)\n\n            return compound_node_fn\n\n    @visitor(CrossNodeConstraint)\n    def _visit_cross_node_constraint(self, node: CrossNodeConstraint):\n        \"\"\"Lower CrossNodeConstraint to trajectory-level function.\n\n        CrossNodeConstraint wraps constraints that reference multiple trajectory\n        nodes via NodeReference (e.g., rate limits like x.at(k) - x.at(k-1) &lt;= r).\n\n        Unlike regular nodal constraints which have signature (x, u, node, params)\n        and are vmapped across nodes, cross-node constraints operate on full\n        trajectory arrays and return a scalar residual.\n\n        Args:\n            node: CrossNodeConstraint expression wrapping the inner constraint\n\n        Returns:\n            Function with signature (X, U, params) -&gt; scalar residual\n                - X: Full state trajectory, shape (N, n_x)\n                - U: Full control trajectory, shape (N, n_u)\n                - params: Dictionary of problem parameters\n                - Returns: Scalar constraint residual (g &lt;= 0 convention)\n\n        Note:\n            The inner constraint is lowered first (producing a function with the\n            standard (x, u, node, params) signature), then wrapped to provide the\n            trajectory-level (X, U, params) signature. The `node` parameter is\n            unused since NodeReference nodes have fixed indices baked in.\n\n        Example:\n            For constraint: position.at(5) - position.at(4) &lt;= max_step\n\n            The lowered function evaluates:\n                X[5, pos_slice] - X[4, pos_slice] - max_step\n\n            And returns a scalar residual.\n        \"\"\"\n        # Lower the inner constraint expression\n        inner_fn = self.lower(node.constraint)\n\n        # Wrap to provide trajectory-level signature\n        # The `node` parameter is unused for cross-node constraints since\n        # NodeReference nodes have fixed indices baked in at construction time\n        def trajectory_constraint(X, U, params):\n            return inner_fn(X, U, 0, params)\n\n        return trajectory_constraint\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_abs","title":"<code>_visit_abs(node: Abs)</code>","text":"<p>Lower absolute value to JAX function.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Abs)\ndef _visit_abs(self, node: Abs):\n    \"\"\"Lower absolute value to JAX function.\"\"\"\n    fO = self.lower(node.operand)\n    return lambda x, u, node, params: jnp.abs(fO(x, u, node, params))\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_add","title":"<code>_visit_add(node: Add)</code>","text":"<p>Lower addition to JAX function.</p> <p>Recursively lowers all terms and composes them with element-wise addition. Supports broadcasting following NumPy/JAX rules.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Add</code> <p>Add expression node with multiple terms</p> required <p>Returns:</p> Type Description <p>Function (x, u, node, params) -&gt; sum of all terms</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Add)\ndef _visit_add(self, node: Add):\n    \"\"\"Lower addition to JAX function.\n\n    Recursively lowers all terms and composes them with element-wise addition.\n    Supports broadcasting following NumPy/JAX rules.\n\n    Args:\n        node: Add expression node with multiple terms\n\n    Returns:\n        Function (x, u, node, params) -&gt; sum of all terms\n    \"\"\"\n    fs = [self.lower(term) for term in node.terms]\n\n    def fn(x, u, node, params):\n        acc = fs[0](x, u, node, params)\n        for f in fs[1:]:\n            acc = acc + f(x, u, node, params)\n        return acc\n\n    return fn\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_concat","title":"<code>_visit_concat(node: Concat)</code>","text":"<p>Lower concatenation to JAX function (concatenates along axis 0).</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Concat)\ndef _visit_concat(self, node: Concat):\n    \"\"\"Lower concatenation to JAX function (concatenates along axis 0).\"\"\"\n    # lower each child\n    fn_list = [self.lower(child) for child in node.exprs]\n\n    # wrapper that promotes scalars to 1-D and concatenates\n    def concat_fn(x, u, node, params):\n        parts = [jnp.atleast_1d(fn(x, u, node, params)) for fn in fn_list]\n        return jnp.concatenate(parts, axis=0)\n\n    return concat_fn\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_constant","title":"<code>_visit_constant(node: Constant)</code>","text":"<p>Lower a constant value to a JAX function.</p> <p>Captures the constant value and returns a function that always returns it. Scalar constants are squeezed to ensure they're true scalars, not (1,) arrays.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Constant</code> <p>Constant expression node</p> required <p>Returns:</p> Type Description <p>Function (x, u, node, params) -&gt; constant_value</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Constant)\ndef _visit_constant(self, node: Constant):\n    \"\"\"Lower a constant value to a JAX function.\n\n    Captures the constant value and returns a function that always returns it.\n    Scalar constants are squeezed to ensure they're true scalars, not (1,) arrays.\n\n    Args:\n        node: Constant expression node\n\n    Returns:\n        Function (x, u, node, params) -&gt; constant_value\n    \"\"\"\n    # capture the constant value once\n    value = jnp.array(node.value)\n    # For scalar constants (single element arrays), squeeze to scalar\n    # This prevents (1,) shapes in constraint residuals\n    if value.size == 1:\n        value = value.squeeze()\n    return lambda x, u, node, params: value\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_constraint","title":"<code>_visit_constraint(node: Constraint)</code>","text":"<p>Lower constraint to residual function.</p> <p>Both equality (lhs == rhs) and inequality (lhs &lt;= rhs) constraints are lowered to their residual form: lhs - rhs. The constraint is satisfied when the residual equals zero (equality) or is non-positive (inequality).</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Constraint</code> <p>Equality or Inequality constraint node</p> required <p>Returns:</p> Type Description <p>Function (x, u, node, params) -&gt; lhs - rhs (constraint residual)</p> Note <p>The returned residual is used in penalty methods and Lagrangian terms. For equality: residual should be 0 For inequality: residual should be &lt;= 0</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Equality)\n@visitor(Inequality)\ndef _visit_constraint(self, node: Constraint):\n    \"\"\"Lower constraint to residual function.\n\n    Both equality (lhs == rhs) and inequality (lhs &lt;= rhs) constraints are\n    lowered to their residual form: lhs - rhs. The constraint is satisfied\n    when the residual equals zero (equality) or is non-positive (inequality).\n\n    Args:\n        node: Equality or Inequality constraint node\n\n    Returns:\n        Function (x, u, node, params) -&gt; lhs - rhs (constraint residual)\n\n    Note:\n        The returned residual is used in penalty methods and Lagrangian terms.\n        For equality: residual should be 0\n        For inequality: residual should be &lt;= 0\n    \"\"\"\n    fL = self.lower(node.lhs)\n    fR = self.lower(node.rhs)\n    return lambda x, u, node, params: fL(x, u, node, params) - fR(x, u, node, params)\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_control","title":"<code>_visit_control(node: Control)</code>","text":"<p>Lower a control variable to a JAX function.</p> <p>Extracts the appropriate slice from the unified control vector u using the slice assigned during unification.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Control</code> <p>Control expression node</p> required <p>Returns:</p> Type Description <p>Function (x, u, node, params) -&gt; u[slice]</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the control has no slice assigned (unification not run)</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Control)\ndef _visit_control(self, node: Control):\n    \"\"\"Lower a control variable to a JAX function.\n\n    Extracts the appropriate slice from the unified control vector u using\n    the slice assigned during unification.\n\n    Args:\n        node: Control expression node\n\n    Returns:\n        Function (x, u, node, params) -&gt; u[slice]\n\n    Raises:\n        ValueError: If the control has no slice assigned (unification not run)\n    \"\"\"\n    sl = node._slice\n    if sl is None:\n        raise ValueError(f\"Control {node.name!r} has no slice assigned\")\n    return lambda x, u, node, params: u[sl]\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_cos","title":"<code>_visit_cos(node: Cos)</code>","text":"<p>Lower cosine function to JAX function.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Cos)\ndef _visit_cos(self, node: Cos):\n    \"\"\"Lower cosine function to JAX function.\"\"\"\n    fO = self.lower(node.operand)\n    return lambda x, u, node, params: jnp.cos(fO(x, u, node, params))\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_cross_node_constraint","title":"<code>_visit_cross_node_constraint(node: CrossNodeConstraint)</code>","text":"<p>Lower CrossNodeConstraint to trajectory-level function.</p> <p>CrossNodeConstraint wraps constraints that reference multiple trajectory nodes via NodeReference (e.g., rate limits like x.at(k) - x.at(k-1) &lt;= r).</p> <p>Unlike regular nodal constraints which have signature (x, u, node, params) and are vmapped across nodes, cross-node constraints operate on full trajectory arrays and return a scalar residual.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>CrossNodeConstraint</code> <p>CrossNodeConstraint expression wrapping the inner constraint</p> required <p>Returns:</p> Type Description <p>Function with signature (X, U, params) -&gt; scalar residual - X: Full state trajectory, shape (N, n_x) - U: Full control trajectory, shape (N, n_u) - params: Dictionary of problem parameters - Returns: Scalar constraint residual (g &lt;= 0 convention)</p> Note <p>The inner constraint is lowered first (producing a function with the standard (x, u, node, params) signature), then wrapped to provide the trajectory-level (X, U, params) signature. The <code>node</code> parameter is unused since NodeReference nodes have fixed indices baked in.</p> Example <p>For constraint: position.at(5) - position.at(4) &lt;= max_step</p> <p>The lowered function evaluates:     X[5, pos_slice] - X[4, pos_slice] - max_step</p> <p>And returns a scalar residual.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(CrossNodeConstraint)\ndef _visit_cross_node_constraint(self, node: CrossNodeConstraint):\n    \"\"\"Lower CrossNodeConstraint to trajectory-level function.\n\n    CrossNodeConstraint wraps constraints that reference multiple trajectory\n    nodes via NodeReference (e.g., rate limits like x.at(k) - x.at(k-1) &lt;= r).\n\n    Unlike regular nodal constraints which have signature (x, u, node, params)\n    and are vmapped across nodes, cross-node constraints operate on full\n    trajectory arrays and return a scalar residual.\n\n    Args:\n        node: CrossNodeConstraint expression wrapping the inner constraint\n\n    Returns:\n        Function with signature (X, U, params) -&gt; scalar residual\n            - X: Full state trajectory, shape (N, n_x)\n            - U: Full control trajectory, shape (N, n_u)\n            - params: Dictionary of problem parameters\n            - Returns: Scalar constraint residual (g &lt;= 0 convention)\n\n    Note:\n        The inner constraint is lowered first (producing a function with the\n        standard (x, u, node, params) signature), then wrapped to provide the\n        trajectory-level (X, U, params) signature. The `node` parameter is\n        unused since NodeReference nodes have fixed indices baked in.\n\n    Example:\n        For constraint: position.at(5) - position.at(4) &lt;= max_step\n\n        The lowered function evaluates:\n            X[5, pos_slice] - X[4, pos_slice] - max_step\n\n        And returns a scalar residual.\n    \"\"\"\n    # Lower the inner constraint expression\n    inner_fn = self.lower(node.constraint)\n\n    # Wrap to provide trajectory-level signature\n    # The `node` parameter is unused for cross-node constraints since\n    # NodeReference nodes have fixed indices baked in at construction time\n    def trajectory_constraint(X, U, params):\n        return inner_fn(X, U, 0, params)\n\n    return trajectory_constraint\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_ctcs","title":"<code>_visit_ctcs(node: CTCS)</code>","text":"<p>Lower CTCS (Continuous-Time Constraint Satisfaction) to JAX function.</p> <p>CTCS constraints use penalty methods to enforce constraints over continuous time intervals. The lowered function includes conditional logic to activate the penalty only within the specified node interval.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>CTCS</code> <p>CTCS constraint node with penalty expression and optional node range</p> required <p>Returns:</p> Type Description <p>Function (x, u, current_node, params) -&gt; penalty value or 0</p> Note <p>Uses jax.lax.cond for JAX-traceable conditional evaluation. The penalty is active only when current_node is in [start_node, end_node). If no node range is specified, the penalty is always active.</p> See Also <ul> <li>CTCS: The symbolic CTCS constraint class</li> <li>penalty functions: PositivePart, Huber, SmoothReLU</li> </ul> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(CTCS)\ndef _visit_ctcs(self, node: CTCS):\n    \"\"\"Lower CTCS (Continuous-Time Constraint Satisfaction) to JAX function.\n\n    CTCS constraints use penalty methods to enforce constraints over continuous\n    time intervals. The lowered function includes conditional logic to activate\n    the penalty only within the specified node interval.\n\n    Args:\n        node: CTCS constraint node with penalty expression and optional node range\n\n    Returns:\n        Function (x, u, current_node, params) -&gt; penalty value or 0\n\n    Note:\n        Uses jax.lax.cond for JAX-traceable conditional evaluation. The penalty\n        is active only when current_node is in [start_node, end_node).\n        If no node range is specified, the penalty is always active.\n\n    See Also:\n        - CTCS: The symbolic CTCS constraint class\n        - penalty functions: PositivePart, Huber, SmoothReLU\n    \"\"\"\n    # Lower the penalty expression (which includes the constraint residual)\n    penalty_expr_fn = self.lower(node.penalty_expr())\n\n    def ctcs_fn(x, u, current_node, params):\n        # Check if constraint is active at this node\n        if node.nodes is not None:\n            start_node, end_node = node.nodes\n            # Extract scalar value from current_node (which may be array or scalar)\n            # Keep as JAX array for tracing compatibility\n            node_scalar = jnp.atleast_1d(current_node)[0]\n            is_active = (start_node &lt;= node_scalar) &amp; (node_scalar &lt; end_node)\n\n            # Use jax.lax.cond for conditional evaluation\n            return cond(\n                is_active,\n                lambda _: penalty_expr_fn(x, u, current_node, params),\n                lambda _: 0.0,\n                operand=None,\n            )\n        else:\n            # Always active if no node range specified\n            return penalty_expr_fn(x, u, current_node, params)\n\n    return ctcs_fn\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_diag","title":"<code>_visit_diag(node: Diag)</code>","text":"<p>Lower diagonal matrix construction to JAX function.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Diag)\ndef _visit_diag(self, node: Diag):\n    \"\"\"Lower diagonal matrix construction to JAX function.\"\"\"\n    f = self.lower(node.operand)\n    return lambda x, u, node, params: jnp.diag(f(x, u, node, params))\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_div","title":"<code>_visit_div(node: Div)</code>","text":"<p>Lower element-wise division to JAX function.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Div)\ndef _visit_div(self, node: Div):\n    \"\"\"Lower element-wise division to JAX function.\"\"\"\n    fL = self.lower(node.left)\n    fR = self.lower(node.right)\n    return lambda x, u, node, params: fL(x, u, node, params) / fR(x, u, node, params)\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_exp","title":"<code>_visit_exp(node: Exp)</code>","text":"<p>Lower exponential function to JAX function.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Exp)\ndef _visit_exp(self, node: Exp):\n    \"\"\"Lower exponential function to JAX function.\"\"\"\n    fO = self.lower(node.operand)\n    return lambda x, u, node, params: jnp.exp(fO(x, u, node, params))\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_hstack","title":"<code>_visit_hstack(node: Hstack)</code>","text":"<p>Lower horizontal stacking to JAX function.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Hstack)\ndef _visit_hstack(self, node: Hstack):\n    \"\"\"Lower horizontal stacking to JAX function.\"\"\"\n    array_fns = [self.lower(arr) for arr in node.arrays]\n\n    def hstack_fn(x, u, node, params):\n        arrays = [jnp.atleast_1d(fn(x, u, node, params)) for fn in array_fns]\n        return jnp.hstack(arrays)\n\n    return hstack_fn\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_huber","title":"<code>_visit_huber(node)</code>","text":"<p>Lower Huber penalty function to JAX.</p> <p>Huber penalty is quadratic for small values and linear for large values: - |x| &lt;= delta: 0.5 * x^2 - |x| &gt; delta: delta * (|x| - 0.5 * delta)</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <p>Huber expression node with delta parameter</p> required <p>Returns:</p> Type Description <p>Function (x, u, node, params) -&gt; Huber penalty</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Huber)\ndef _visit_huber(self, node):\n    \"\"\"Lower Huber penalty function to JAX.\n\n    Huber penalty is quadratic for small values and linear for large values:\n    - |x| &lt;= delta: 0.5 * x^2\n    - |x| &gt; delta: delta * (|x| - 0.5 * delta)\n\n    Args:\n        node: Huber expression node with delta parameter\n\n    Returns:\n        Function (x, u, node, params) -&gt; Huber penalty\n    \"\"\"\n    f = self.lower(node.x)\n    delta = node.delta\n    return lambda x, u, node, params: jnp.where(\n        jnp.abs(f(x, u, node, params)) &lt;= delta,\n        0.5 * f(x, u, node, params) ** 2,\n        delta * (jnp.abs(f(x, u, node, params)) - 0.5 * delta),\n    )\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_index","title":"<code>_visit_index(node: Index)</code>","text":"<p>Lower indexing/slicing operation to JAX function.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Index)\ndef _visit_index(self, node: Index):\n    \"\"\"Lower indexing/slicing operation to JAX function.\"\"\"\n    # lower the \"base\" expr into a fn(x,u,node), then index it\n    f_base = self.lower(node.base)\n    idx = node.index\n    return lambda x, u, node, params: jnp.atleast_1d(f_base(x, u, node, params))[idx]\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_log","title":"<code>_visit_log(node: Log)</code>","text":"<p>Lower natural logarithm to JAX function.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Log)\ndef _visit_log(self, node: Log):\n    \"\"\"Lower natural logarithm to JAX function.\"\"\"\n    fO = self.lower(node.operand)\n    return lambda x, u, node, params: jnp.log(fO(x, u, node, params))\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_logsumexp","title":"<code>_visit_logsumexp(node: LogSumExp)</code>","text":"<p>Lower log-sum-exp to JAX function.</p> <p>Computes log(sum(exp(x_i))) for multiple operands, which is a smooth approximation to the maximum function. Uses JAX's numerically stable logsumexp implementation. Performs element-wise log-sum-exp with broadcasting support.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(LogSumExp)\ndef _visit_logsumexp(self, node: LogSumExp):\n    \"\"\"Lower log-sum-exp to JAX function.\n\n    Computes log(sum(exp(x_i))) for multiple operands, which is a smooth\n    approximation to the maximum function. Uses JAX's numerically stable\n    logsumexp implementation. Performs element-wise log-sum-exp with\n    broadcasting support.\n    \"\"\"\n    fs = [self.lower(op) for op in node.operands]\n\n    def fn(x, u, node, params):\n        values = [f(x, u, node, params) for f in fs]\n        # Broadcast all values to the same shape, then stack along new axis\n        # and compute logsumexp along that axis for element-wise operation\n        broadcasted = jnp.broadcast_arrays(*values)\n        stacked = jnp.stack(list(broadcasted), axis=0)\n        return logsumexp(stacked, axis=0)\n\n    return fn\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_matmul","title":"<code>_visit_matmul(node: MatMul)</code>","text":"<p>Lower matrix multiplication to JAX function using jnp.matmul.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(MatMul)\ndef _visit_matmul(self, node: MatMul):\n    \"\"\"Lower matrix multiplication to JAX function using jnp.matmul.\"\"\"\n    fL = self.lower(node.left)\n    fR = self.lower(node.right)\n    return lambda x, u, node, params: jnp.matmul(fL(x, u, node, params), fR(x, u, node, params))\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_max","title":"<code>_visit_max(node: Max)</code>","text":"<p>Lower element-wise maximum to JAX function.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Max)\ndef _visit_max(self, node: Max):\n    \"\"\"Lower element-wise maximum to JAX function.\"\"\"\n    fs = [self.lower(op) for op in node.operands]\n\n    def fn(x, u, node, params):\n        values = [f(x, u, node, params) for f in fs]\n        # jnp.maximum can take multiple arguments\n        result = values[0]\n        for val in values[1:]:\n            result = jnp.maximum(result, val)\n        return result\n\n    return fn\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_mul","title":"<code>_visit_mul(node: Mul)</code>","text":"<p>Lower element-wise multiplication to JAX function (Hadamard product).</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Mul)\ndef _visit_mul(self, node: Mul):\n    \"\"\"Lower element-wise multiplication to JAX function (Hadamard product).\"\"\"\n    fs = [self.lower(factor) for factor in node.factors]\n\n    def fn(x, u, node, params):\n        acc = fs[0](x, u, node, params)\n        for f in fs[1:]:\n            acc = acc * f(x, u, node, params)\n        return acc\n\n    return fn\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_neg","title":"<code>_visit_neg(node: Neg)</code>","text":"<p>Lower negation (unary minus) to JAX function.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Neg)\ndef _visit_neg(self, node: Neg):\n    \"\"\"Lower negation (unary minus) to JAX function.\"\"\"\n    fO = self.lower(node.operand)\n    return lambda x, u, node, params: -fO(x, u, node, params)\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_nodal_constraint","title":"<code>_visit_nodal_constraint(node: NodalConstraint)</code>","text":"<p>Lower a NodalConstraint by lowering its underlying constraint.</p> <p>NodalConstraint is a wrapper that specifies which nodes a constraint applies to. The lowering just unwraps and lowers the inner constraint.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>NodalConstraint</code> <p>NodalConstraint wrapper</p> required <p>Returns:</p> Type Description <p>Function from lowering the wrapped constraint expression</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(NodalConstraint)\ndef _visit_nodal_constraint(self, node: NodalConstraint):\n    \"\"\"Lower a NodalConstraint by lowering its underlying constraint.\n\n    NodalConstraint is a wrapper that specifies which nodes a constraint\n    applies to. The lowering just unwraps and lowers the inner constraint.\n\n    Args:\n        node: NodalConstraint wrapper\n\n    Returns:\n        Function from lowering the wrapped constraint expression\n    \"\"\"\n    return self.lower(node.constraint)\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_node_reference","title":"<code>_visit_node_reference(node: NodeReference)</code>","text":"<p>Lower NodeReference - extract value at a specific trajectory node.</p> <p>NodeReference extracts a state/control value at a specific node from the full trajectory arrays. The node index is baked into the lowered function.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>NodeReference</code> <p>NodeReference expression with base and node_idx (integer)</p> required <p>Returns:</p> Type Description <p>Function (x, u, node_param, params) that extracts from trajectory - x, u: Full trajectories (N, n_x) and (N, n_u) - node_param: Unused (kept for signature compatibility) - params: Problem parameters</p> Example <p>position.at(5) lowers to a function that extracts x[5, position_slice] position.at(k-1) where k=7 lowers to extract x[6, position_slice]</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(NodeReference)\ndef _visit_node_reference(self, node: NodeReference):\n    \"\"\"Lower NodeReference - extract value at a specific trajectory node.\n\n    NodeReference extracts a state/control value at a specific node from the\n    full trajectory arrays. The node index is baked into the lowered function.\n\n    Args:\n        node: NodeReference expression with base and node_idx (integer)\n\n    Returns:\n        Function (x, u, node_param, params) that extracts from trajectory\n            - x, u: Full trajectories (N, n_x) and (N, n_u)\n            - node_param: Unused (kept for signature compatibility)\n            - params: Problem parameters\n\n    Example:\n        position.at(5) lowers to a function that extracts x[5, position_slice]\n        position.at(k-1) where k=7 lowers to extract x[6, position_slice]\n    \"\"\"\n    from openscvx.symbolic.expr.control import Control\n    from openscvx.symbolic.expr.state import State\n\n    # Node index is baked into the expression at construction time\n    fixed_idx = node.node_idx\n\n    if isinstance(node.base, State):\n        sl = node.base._slice\n        if sl is None:\n            raise ValueError(f\"State {node.base.name!r} has no slice assigned\")\n\n        def state_node_fn(x, u, node_param, params):\n            return x[fixed_idx, sl]\n\n        return state_node_fn\n\n    elif isinstance(node.base, Control):\n        sl = node.base._slice\n        if sl is None:\n            raise ValueError(f\"Control {node.base.name!r} has no slice assigned\")\n\n        def control_node_fn(x, u, node_param, params):\n            return u[fixed_idx, sl]\n\n        return control_node_fn\n\n    else:\n        # Compound expression (e.g., position[0].at(5))\n        base_fn = self.lower(node.base)\n\n        def compound_node_fn(x, u, node_param, params):\n            # Extract single-node slices and evaluate base expression\n            x_single = x[fixed_idx] if len(x.shape) &gt; 1 else x\n            u_single = u[fixed_idx] if len(u.shape) &gt; 1 else u\n            return base_fn(x_single, u_single, fixed_idx, params)\n\n        return compound_node_fn\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_norm","title":"<code>_visit_norm(node: Norm)</code>","text":"<p>Lower norm operation to JAX function.</p> <p>Converts symbolic norm to jnp.linalg.norm with appropriate ord parameter. Handles string ord values like \"inf\", \"-inf\", \"fro\".</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Norm</code> <p>Norm expression node with ord attribute</p> required <p>Returns:</p> Type Description <p>Function (x, u, node, params) -&gt; norm of operand</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Norm)\ndef _visit_norm(self, node: Norm):\n    \"\"\"Lower norm operation to JAX function.\n\n    Converts symbolic norm to jnp.linalg.norm with appropriate ord parameter.\n    Handles string ord values like \"inf\", \"-inf\", \"fro\".\n\n    Args:\n        node: Norm expression node with ord attribute\n\n    Returns:\n        Function (x, u, node, params) -&gt; norm of operand\n    \"\"\"\n    f = self.lower(node.operand)\n    ord_val = node.ord\n\n    # Convert string ord values to appropriate JAX values\n    if ord_val == \"inf\":\n        ord_val = jnp.inf\n    elif ord_val == \"-inf\":\n        ord_val = -jnp.inf\n    elif ord_val == \"fro\":\n        # For vectors, Frobenius norm is the same as 2-norm\n        ord_val = None  # Default is 2-norm\n\n    return lambda x, u, node, params: jnp.linalg.norm(f(x, u, node, params), ord=ord_val)\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_or","title":"<code>_visit_or(node: Or)</code>","text":"<p>Lower STL disjunction (Or) to JAX using STLJax library.</p> <p>Converts a symbolic Or constraint to an STLJax Or formula for handling disjunctive task specifications. Each operand becomes an STLJax predicate.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Or</code> <p>Or expression node with multiple operands</p> required <p>Returns:</p> Type Description <p>Function (x, u, node, params) -&gt; STL robustness value</p> Note <p>Uses STLJax library for signal temporal logic evaluation. The returned function computes the robustness metric for the disjunction, which is positive when at least one operand is satisfied.</p> Example <p>Used for task specifications like \"reach goal A OR goal B\"::</p> <pre><code>goal_A = ox.Norm(x - target_A) &lt;= 1.0\ngoal_B = ox.Norm(x - target_B) &lt;= 1.0\ntask = ox.Or(goal_A, goal_B)\n</code></pre> See Also <ul> <li>stljax.formula.Or: Underlying STLJax implementation</li> <li>STL robustness: Quantitative measure of constraint satisfaction</li> </ul> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Or)\ndef _visit_or(self, node: Or):\n    \"\"\"Lower STL disjunction (Or) to JAX using STLJax library.\n\n    Converts a symbolic Or constraint to an STLJax Or formula for handling\n    disjunctive task specifications. Each operand becomes an STLJax predicate.\n\n    Args:\n        node: Or expression node with multiple operands\n\n    Returns:\n        Function (x, u, node, params) -&gt; STL robustness value\n\n    Note:\n        Uses STLJax library for signal temporal logic evaluation. The returned\n        function computes the robustness metric for the disjunction, which is\n        positive when at least one operand is satisfied.\n\n    Example:\n        Used for task specifications like \"reach goal A OR goal B\"::\n\n            goal_A = ox.Norm(x - target_A) &lt;= 1.0\n            goal_B = ox.Norm(x - target_B) &lt;= 1.0\n            task = ox.Or(goal_A, goal_B)\n\n    See Also:\n        - stljax.formula.Or: Underlying STLJax implementation\n        - STL robustness: Quantitative measure of constraint satisfaction\n    \"\"\"\n    from stljax.formula import Or as STLOr\n    from stljax.formula import Predicate\n\n    # Lower each operand to get their functions\n    operand_fns = [self.lower(operand) for operand in node.operands]\n\n    # Return a function that evaluates the STLJax Or\n    def or_fn(x, u, node, params):\n        # Create STLJax predicates for each operand with current params\n        predicates = []\n        for i, operand_fn in enumerate(operand_fns):\n            # Create a predicate function that captures the current params\n            def make_pred_fn(fn):\n                return lambda x: fn(x, None, None, params)\n\n            pred_fn = make_pred_fn(operand_fn)\n            predicates.append(Predicate(f\"pred_{i}\", pred_fn))\n\n        # Create and evaluate STLJax Or formula\n        stl_or = STLOr(*predicates)\n        return stl_or(x)\n\n    return or_fn\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_parameter","title":"<code>_visit_parameter(node: Parameter)</code>","text":"<p>Lower a parameter to a JAX function.</p> <p>Parameters are looked up by name in the params dictionary at evaluation time, allowing runtime parameter updates without recompilation.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Parameter</code> <p>Parameter expression node</p> required <p>Returns:</p> Type Description <p>Function (x, u, node, params) -&gt; params[name]</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Parameter)\ndef _visit_parameter(self, node: Parameter):\n    \"\"\"Lower a parameter to a JAX function.\n\n    Parameters are looked up by name in the params dictionary at evaluation time,\n    allowing runtime parameter updates without recompilation.\n\n    Args:\n        node: Parameter expression node\n\n    Returns:\n        Function (x, u, node, params) -&gt; params[name]\n    \"\"\"\n    param_name = node.name\n    return lambda x, u, node, params: jnp.array(params[param_name])\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_pos","title":"<code>_visit_pos(node)</code>","text":"<p>Lower positive part function to JAX.</p> <p>Computes max(x, 0), used in penalty methods for inequality constraints.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <p>PositivePart expression node</p> required <p>Returns:</p> Type Description <p>Function (x, u, node, params) -&gt; max(operand, 0)</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(PositivePart)\ndef _visit_pos(self, node):\n    \"\"\"Lower positive part function to JAX.\n\n    Computes max(x, 0), used in penalty methods for inequality constraints.\n\n    Args:\n        node: PositivePart expression node\n\n    Returns:\n        Function (x, u, node, params) -&gt; max(operand, 0)\n    \"\"\"\n    f = self.lower(node.x)\n    return lambda x, u, node, params: jnp.maximum(f(x, u, node, params), 0.0)\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_power","title":"<code>_visit_power(node: Power)</code>","text":"<p>Lower element-wise power (base**exponent) to JAX function.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Power)\ndef _visit_power(self, node: Power):\n    \"\"\"Lower element-wise power (base**exponent) to JAX function.\"\"\"\n    fB = self.lower(node.base)\n    fE = self.lower(node.exponent)\n    return lambda x, u, node, params: jnp.power(fB(x, u, node, params), fE(x, u, node, params))\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_qdcm","title":"<code>_visit_qdcm(node: QDCM)</code>","text":"<p>Lower quaternion to direction cosine matrix (DCM) conversion.</p> <p>Converts a unit quaternion [q0, q1, q2, q3] to a 3x3 rotation matrix. Used in 6-DOF spacecraft and robotics applications.</p> <p>The quaternion is normalized before conversion to ensure a valid rotation matrix. The DCM is computed using the standard quaternion-to-DCM formula.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>QDCM</code> <p>QDCM expression node</p> required <p>Returns:</p> Type Description <p>Function (x, u, node, params) -&gt; 3x3 rotation matrix</p> Note <p>Quaternion convention: [w, x, y, z] where w is the scalar part</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(QDCM)\ndef _visit_qdcm(self, node: QDCM):\n    \"\"\"Lower quaternion to direction cosine matrix (DCM) conversion.\n\n    Converts a unit quaternion [q0, q1, q2, q3] to a 3x3 rotation matrix.\n    Used in 6-DOF spacecraft and robotics applications.\n\n    The quaternion is normalized before conversion to ensure a valid rotation\n    matrix. The DCM is computed using the standard quaternion-to-DCM formula.\n\n    Args:\n        node: QDCM expression node\n\n    Returns:\n        Function (x, u, node, params) -&gt; 3x3 rotation matrix\n\n    Note:\n        Quaternion convention: [w, x, y, z] where w is the scalar part\n    \"\"\"\n    f = self.lower(node.q)\n\n    def qdcm_fn(x, u, node, params):\n        q = f(x, u, node, params)\n        # Normalize the quaternion\n        q_norm = jnp.sqrt(q[0] ** 2 + q[1] ** 2 + q[2] ** 2 + q[3] ** 2)\n        w, qx, qy, qz = q / q_norm\n        # Convert to direction cosine matrix\n        return jnp.array(\n            [\n                [1 - 2 * (qy**2 + qz**2), 2 * (qx * qy - qz * w), 2 * (qx * qz + qy * w)],\n                [2 * (qx * qy + qz * w), 1 - 2 * (qx**2 + qz**2), 2 * (qy * qz - qx * w)],\n                [2 * (qx * qz - qy * w), 2 * (qy * qz + qx * w), 1 - 2 * (qx**2 + qy**2)],\n            ]\n        )\n\n    return qdcm_fn\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_sin","title":"<code>_visit_sin(node: Sin)</code>","text":"<p>Lower sine function to JAX function.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Sin)\ndef _visit_sin(self, node: Sin):\n    \"\"\"Lower sine function to JAX function.\"\"\"\n    fO = self.lower(node.operand)\n    return lambda x, u, node, params: jnp.sin(fO(x, u, node, params))\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_sqrt","title":"<code>_visit_sqrt(node: Sqrt)</code>","text":"<p>Lower square root to JAX function.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Sqrt)\ndef _visit_sqrt(self, node: Sqrt):\n    \"\"\"Lower square root to JAX function.\"\"\"\n    f = self.lower(node.operand)\n    return lambda x, u, node, params: jnp.sqrt(f(x, u, node, params))\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_square","title":"<code>_visit_square(node)</code>","text":"<p>Lower square function to JAX.</p> <p>Computes x^2 element-wise. Used in quadratic penalty methods.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <p>Square expression node</p> required <p>Returns:</p> Type Description <p>Function (x, u, node, params) -&gt; operand^2</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Square)\ndef _visit_square(self, node):\n    \"\"\"Lower square function to JAX.\n\n    Computes x^2 element-wise. Used in quadratic penalty methods.\n\n    Args:\n        node: Square expression node\n\n    Returns:\n        Function (x, u, node, params) -&gt; operand^2\n    \"\"\"\n    f = self.lower(node.x)\n    return lambda x, u, node, params: f(x, u, node, params) * f(x, u, node, params)\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_srelu","title":"<code>_visit_srelu(node)</code>","text":"<p>Lower smooth ReLU penalty function to JAX.</p> <p>Smooth approximation to ReLU: sqrt(max(x, 0)^2 + c^2) - c Differentiable everywhere, approaches ReLU as c -&gt; 0.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <p>SmoothReLU expression node with smoothing parameter c</p> required <p>Returns:</p> Type Description <p>Function (x, u, node, params) -&gt; smooth ReLU penalty</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(SmoothReLU)\ndef _visit_srelu(self, node):\n    \"\"\"Lower smooth ReLU penalty function to JAX.\n\n    Smooth approximation to ReLU: sqrt(max(x, 0)^2 + c^2) - c\n    Differentiable everywhere, approaches ReLU as c -&gt; 0.\n\n    Args:\n        node: SmoothReLU expression node with smoothing parameter c\n\n    Returns:\n        Function (x, u, node, params) -&gt; smooth ReLU penalty\n    \"\"\"\n    f = self.lower(node.x)\n    c = node.c\n    # smooth_relu(pos(x)) = sqrt(pos(x)^2 + c^2) - c ; here f already includes pos inside node\n    return (\n        lambda x, u, node, params: jnp.sqrt(jnp.maximum(f(x, u, node, params), 0.0) ** 2 + c**2)\n        - c\n    )\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_ssm","title":"<code>_visit_ssm(node: SSM)</code>","text":"<p>Lower skew-symmetric matrix for cross product (3x3).</p> <p>Creates a 3x3 skew-symmetric matrix from a vector such that SSM(a) @ b = a x b (cross product).</p> <p>The SSM is the matrix representation of the cross product operator, allowing cross products to be computed as matrix-vector multiplication.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>SSM</code> <p>SSM expression node</p> required <p>Returns:</p> Type Description <p>Function (x, u, node, params) -&gt; 3x3 skew-symmetric matrix</p> Note <p>For vector w = [x, y, z], returns: [[ 0, -z,  y],  [ z,  0, -x],  [-y,  x,  0]]</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(SSM)\ndef _visit_ssm(self, node: SSM):\n    \"\"\"Lower skew-symmetric matrix for cross product (3x3).\n\n    Creates a 3x3 skew-symmetric matrix from a vector such that\n    SSM(a) @ b = a x b (cross product).\n\n    The SSM is the matrix representation of the cross product operator,\n    allowing cross products to be computed as matrix-vector multiplication.\n\n    Args:\n        node: SSM expression node\n\n    Returns:\n        Function (x, u, node, params) -&gt; 3x3 skew-symmetric matrix\n\n    Note:\n        For vector w = [x, y, z], returns:\n        [[ 0, -z,  y],\n         [ z,  0, -x],\n         [-y,  x,  0]]\n    \"\"\"\n    f = self.lower(node.w)\n\n    def ssm_fn(x, u, node, params):\n        w = f(x, u, node, params)\n        wx, wy, wz = w[0], w[1], w[2]\n        return jnp.array([[0, -wz, wy], [wz, 0, -wx], [-wy, wx, 0]])\n\n    return ssm_fn\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_ssmp","title":"<code>_visit_ssmp(node: SSMP)</code>","text":"<p>Lower skew-symmetric matrix for quaternion dynamics (4x4).</p> <p>Creates a 4x4 skew-symmetric matrix from angular velocity vector for quaternion kinematic propagation: q_dot = 0.5 * SSMP(omega) @ q</p> <p>The SSMP matrix is used in quaternion kinematics to compute quaternion derivatives from angular velocity vectors.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>SSMP</code> <p>SSMP expression node</p> required <p>Returns:</p> Type Description <p>Function (x, u, node, params) -&gt; 4x4 skew-symmetric matrix</p> Note <p>For angular velocity w = [x, y, z], returns: [[0, -x, -y, -z],  [x,  0,  z, -y],  [y, -z,  0,  x],  [z,  y, -x,  0]]</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(SSMP)\ndef _visit_ssmp(self, node: SSMP):\n    \"\"\"Lower skew-symmetric matrix for quaternion dynamics (4x4).\n\n    Creates a 4x4 skew-symmetric matrix from angular velocity vector for\n    quaternion kinematic propagation: q_dot = 0.5 * SSMP(omega) @ q\n\n    The SSMP matrix is used in quaternion kinematics to compute quaternion\n    derivatives from angular velocity vectors.\n\n    Args:\n        node: SSMP expression node\n\n    Returns:\n        Function (x, u, node, params) -&gt; 4x4 skew-symmetric matrix\n\n    Note:\n        For angular velocity w = [x, y, z], returns:\n        [[0, -x, -y, -z],\n         [x,  0,  z, -y],\n         [y, -z,  0,  x],\n         [z,  y, -x,  0]]\n    \"\"\"\n    f = self.lower(node.w)\n\n    def ssmp_fn(x, u, node, params):\n        w = f(x, u, node, params)\n        wx, wy, wz = w[0], w[1], w[2]\n        return jnp.array(\n            [\n                [0, -wx, -wy, -wz],\n                [wx, 0, wz, -wy],\n                [wy, -wz, 0, wx],\n                [wz, wy, -wx, 0],\n            ]\n        )\n\n    return ssmp_fn\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_stack","title":"<code>_visit_stack(node: Stack)</code>","text":"<p>Lower vertical stacking to JAX function (stack along axis 0).</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Stack)\ndef _visit_stack(self, node: Stack):\n    \"\"\"Lower vertical stacking to JAX function (stack along axis 0).\"\"\"\n    row_fns = [self.lower(row) for row in node.rows]\n\n    def stack_fn(x, u, node, params):\n        rows = [jnp.atleast_1d(fn(x, u, node, params)) for fn in row_fns]\n        return jnp.stack(rows, axis=0)\n\n    return stack_fn\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_state","title":"<code>_visit_state(node: State)</code>","text":"<p>Lower a state variable to a JAX function.</p> <p>Extracts the appropriate slice from the unified state vector x using the slice assigned during unification.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>State</code> <p>State expression node</p> required <p>Returns:</p> Type Description <p>Function (x, u, node, params) -&gt; x[slice]</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the state has no slice assigned (unification not run)</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(State)\ndef _visit_state(self, node: State):\n    \"\"\"Lower a state variable to a JAX function.\n\n    Extracts the appropriate slice from the unified state vector x using\n    the slice assigned during unification.\n\n    Args:\n        node: State expression node\n\n    Returns:\n        Function (x, u, node, params) -&gt; x[slice]\n\n    Raises:\n        ValueError: If the state has no slice assigned (unification not run)\n    \"\"\"\n    sl = node._slice\n    if sl is None:\n        raise ValueError(f\"State {node.name!r} has no slice assigned\")\n    return lambda x, u, node, params: x[sl]\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_sub","title":"<code>_visit_sub(node: Sub)</code>","text":"<p>Lower subtraction to JAX function (element-wise left - right).</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Sub)\ndef _visit_sub(self, node: Sub):\n    \"\"\"Lower subtraction to JAX function (element-wise left - right).\"\"\"\n    fL = self.lower(node.left)\n    fR = self.lower(node.right)\n    return lambda x, u, node, params: fL(x, u, node, params) - fR(x, u, node, params)\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_sum","title":"<code>_visit_sum(node: Sum)</code>","text":"<p>Lower sum reduction to JAX function (sums all elements).</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Sum)\ndef _visit_sum(self, node: Sum):\n    \"\"\"Lower sum reduction to JAX function (sums all elements).\"\"\"\n    f = self.lower(node.operand)\n    return lambda x, u, node, params: jnp.sum(f(x, u, node, params))\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_tan","title":"<code>_visit_tan(node: Tan)</code>","text":"<p>Lower tangent function to JAX function.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Tan)\ndef _visit_tan(self, node: Tan):\n    \"\"\"Lower tangent function to JAX function.\"\"\"\n    fO = self.lower(node.operand)\n    return lambda x, u, node, params: jnp.tan(fO(x, u, node, params))\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_transpose","title":"<code>_visit_transpose(node: Transpose)</code>","text":"<p>Lower matrix transpose to JAX function.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Transpose)\ndef _visit_transpose(self, node: Transpose):\n    \"\"\"Lower matrix transpose to JAX function.\"\"\"\n    f = self.lower(node.operand)\n    return lambda x, u, node, params: jnp.transpose(f(x, u, node, params))\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer._visit_vstack","title":"<code>_visit_vstack(node: Vstack)</code>","text":"<p>Lower vertical stacking to JAX function.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>@visitor(Vstack)\ndef _visit_vstack(self, node: Vstack):\n    \"\"\"Lower vertical stacking to JAX function.\"\"\"\n    array_fns = [self.lower(arr) for arr in node.arrays]\n\n    def vstack_fn(x, u, node, params):\n        arrays = [jnp.atleast_1d(fn(x, u, node, params)) for fn in array_fns]\n        return jnp.vstack(arrays)\n\n    return vstack_fn\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer.lower","title":"<code>lower(expr: Expr)</code>","text":"<p>Lower a symbolic expression to a JAX function.</p> <p>Main entry point for lowering. Delegates to dispatch() which looks up the appropriate visitor method based on the expression type.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Symbolic expression to lower (any Expr subclass)</p> required <p>Returns:</p> Type Description <p>JAX function with signature (x, u, node, params) -&gt; result</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If no visitor exists for the expression type</p> <code>ValueError</code> <p>If the expression is malformed (e.g., State without slice)</p> Example <p>Lower an expression to a JAX function:</p> <pre><code>lowerer = JaxLowerer()\nx = ox.State(\"x\", shape=(3,))\nexpr = ox.Norm(x)\nf = lowerer.lower(expr)\n# f is now callable\n</code></pre> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>def lower(self, expr: Expr):\n    \"\"\"Lower a symbolic expression to a JAX function.\n\n    Main entry point for lowering. Delegates to dispatch() which looks up\n    the appropriate visitor method based on the expression type.\n\n    Args:\n        expr: Symbolic expression to lower (any Expr subclass)\n\n    Returns:\n        JAX function with signature (x, u, node, params) -&gt; result\n\n    Raises:\n        NotImplementedError: If no visitor exists for the expression type\n        ValueError: If the expression is malformed (e.g., State without slice)\n\n    Example:\n        Lower an expression to a JAX function:\n\n            lowerer = JaxLowerer()\n            x = ox.State(\"x\", shape=(3,))\n            expr = ox.Norm(x)\n            f = lowerer.lower(expr)\n            # f is now callable\n    \"\"\"\n    return dispatch(self, expr)\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.dispatch","title":"<code>dispatch(lowerer: Any, expr: Expr)</code>","text":"<p>Dispatch an expression to its registered visitor function.</p> <p>Looks up the visitor function for the expression's type and calls it. This is the core of the visitor pattern implementation.</p> <p>Parameters:</p> Name Type Description Default <code>lowerer</code> <code>Any</code> <p>The JaxLowerer instance (provides context for visitor methods)</p> required <code>expr</code> <code>Expr</code> <p>The expression node to lower</p> required <p>Returns:</p> Type Description <p>The result of calling the visitor function (typically a JAX callable)</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If no visitor is registered for the expression type</p> Example <p>Dispatch an expression to lower it to a JAX function:</p> <pre><code>lowerer = JaxLowerer()\nexpr = Add(x, y)\nfn = dispatch(lowerer, expr)  # Calls visit_add\n</code></pre> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>def dispatch(lowerer: Any, expr: Expr):\n    \"\"\"Dispatch an expression to its registered visitor function.\n\n    Looks up the visitor function for the expression's type and calls it.\n    This is the core of the visitor pattern implementation.\n\n    Args:\n        lowerer: The JaxLowerer instance (provides context for visitor methods)\n        expr: The expression node to lower\n\n    Returns:\n        The result of calling the visitor function (typically a JAX callable)\n\n    Raises:\n        NotImplementedError: If no visitor is registered for the expression type\n\n    Example:\n        Dispatch an expression to lower it to a JAX function:\n\n            lowerer = JaxLowerer()\n            expr = Add(x, y)\n            fn = dispatch(lowerer, expr)  # Calls visit_add\n    \"\"\"\n    fn = _JAX_VISITORS.get(type(expr))\n    if fn is None:\n        raise NotImplementedError(\n            f\"{lowerer.__class__.__name__!r} has no visitor for {type(expr).__name__}\"\n        )\n    return fn(lowerer, expr)\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.visitor","title":"<code>visitor(expr_cls: Type[Expr])</code>","text":"<p>Decorator to register a visitor function for an expression type.</p> <p>This decorator registers a visitor method to handle a specific expression type during JAX lowering. The decorated function is stored in _JAX_VISITORS and will be called by dispatch() when lowering that expression type.</p> <p>Parameters:</p> Name Type Description Default <code>expr_cls</code> <code>Type[Expr]</code> <p>The Expr subclass this visitor handles (e.g., Add, Mul, Norm)</p> required <p>Returns:</p> Type Description <p>Decorator function that registers the visitor and returns it unchanged</p> Example <p>Register a visitor function for the Add expression:</p> <pre><code>@visitor(Add)\ndef _visit_add(self, node: Add):\n    # Lower addition to JAX\n    ...\n</code></pre> Note <p>Multiple expression types can share a visitor by stacking decorators::</p> <pre><code>@visitor(Equality)\n@visitor(Inequality)\ndef _visit_constraint(self, node: Constraint):\n    # Handle both equality and inequality\n    ...\n</code></pre> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>def visitor(expr_cls: Type[Expr]):\n    \"\"\"Decorator to register a visitor function for an expression type.\n\n    This decorator registers a visitor method to handle a specific expression\n    type during JAX lowering. The decorated function is stored in _JAX_VISITORS\n    and will be called by dispatch() when lowering that expression type.\n\n    Args:\n        expr_cls: The Expr subclass this visitor handles (e.g., Add, Mul, Norm)\n\n    Returns:\n        Decorator function that registers the visitor and returns it unchanged\n\n    Example:\n        Register a visitor function for the Add expression:\n\n            @visitor(Add)\n            def _visit_add(self, node: Add):\n                # Lower addition to JAX\n                ...\n\n    Note:\n        Multiple expression types can share a visitor by stacking decorators::\n\n            @visitor(Equality)\n            @visitor(Inequality)\n            def _visit_constraint(self, node: Constraint):\n                # Handle both equality and inequality\n                ...\n    \"\"\"\n\n    def register(fn: Callable[[Any, Expr], Callable]):\n        _JAX_VISITORS[expr_cls] = fn\n        return fn\n\n    return register\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":"<p>Utility functions for caching, printing, and output formatting.</p> <p>This module provides utilities for OpenSCvx.</p>"},{"location":"reference/utils/#openscvx.utils.calculate_cost_from_boundaries","title":"<code>calculate_cost_from_boundaries(x: np.ndarray, initial_type: np.ndarray, final_type: np.ndarray) -&gt; float</code>","text":"<p>Calculate cost from boundary condition objectives.</p> <p>This function computes the total cost contribution from state boundary conditions marked as \"Minimize\" or \"Maximize\" at initial and final times.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>State trajectory array of shape (N, n_states)</p> required <code>initial_type</code> <code>ndarray</code> <p>Array of boundary condition types for initial states</p> required <code>final_type</code> <code>ndarray</code> <p>Array of boundary condition types for final states</p> required <p>Returns:</p> Type Description <code>float</code> <p>Total cost from minimize/maximize boundary conditions</p> Example Source code in <code>openscvx/utils/utils.py</code> <pre><code>def calculate_cost_from_boundaries(\n    x: np.ndarray, initial_type: np.ndarray, final_type: np.ndarray\n) -&gt; float:\n    \"\"\"Calculate cost from boundary condition objectives.\n\n    This function computes the total cost contribution from state boundary conditions\n    marked as \"Minimize\" or \"Maximize\" at initial and final times.\n\n    Args:\n        x: State trajectory array of shape (N, n_states)\n        initial_type: Array of boundary condition types for initial states\n        final_type: Array of boundary condition types for final states\n\n    Returns:\n        Total cost from minimize/maximize boundary conditions\n\n    Example:\n        &gt;&gt;&gt; # State with final time to minimize\n        &gt;&gt;&gt; x = np.array([[0.0, 5.0], [10.0, 20.0]])  # 2 nodes, 2 states\n        &gt;&gt;&gt; initial_type = np.array([\"Fix\", \"Free\"])\n        &gt;&gt;&gt; final_type = np.array([\"Minimize\", \"Free\"])\n        &gt;&gt;&gt; cost = calculate_cost_from_boundaries(x, initial_type, final_type)\n        &gt;&gt;&gt; cost  # Returns x[-1, 0] = 10.0\n    \"\"\"\n    cost = 0.0\n\n    # Add costs from initial boundary conditions\n    for i, bc_type in enumerate(initial_type):\n        if bc_type == \"Minimize\":\n            cost += x[0, i]\n        elif bc_type == \"Maximize\":\n            cost -= x[0, i]\n\n    # Add costs from final boundary conditions\n    for i, bc_type in enumerate(final_type):\n        if bc_type == \"Minimize\":\n            cost += x[-1, i]\n        elif bc_type == \"Maximize\":\n            cost -= x[-1, i]\n\n    return cost\n</code></pre>"},{"location":"reference/utils/#openscvx.utils.calculate_cost_from_boundaries--state-with-final-time-to-minimize","title":"State with final time to minimize","text":"<p>x = np.array([[0.0, 5.0], [10.0, 20.0]])  # 2 nodes, 2 states initial_type = np.array([\"Fix\", \"Free\"]) final_type = np.array([\"Minimize\", \"Free\"]) cost = calculate_cost_from_boundaries(x, initial_type, final_type) cost  # Returns x[-1, 0] = 10.0</p>"},{"location":"reference/utils/#openscvx.utils.gen_vertices","title":"<code>gen_vertices(center, radii)</code>","text":"<p>Obtains the vertices of the gate.</p> Source code in <code>openscvx/utils/utils.py</code> <pre><code>def gen_vertices(center, radii):\n    \"\"\"\n    Obtains the vertices of the gate.\n    \"\"\"\n    vertices = []\n    vertices.append(center + rot @ [radii[0], 0, radii[2]])\n    vertices.append(center + rot @ [-radii[0], 0, radii[2]])\n    vertices.append(center + rot @ [-radii[0], 0, -radii[2]])\n    vertices.append(center + rot @ [radii[0], 0, -radii[2]])\n    return vertices\n</code></pre>"},{"location":"reference/utils/#openscvx.utils.generate_orthogonal_unit_vectors","title":"<code>generate_orthogonal_unit_vectors(vectors=None)</code>","text":"<p>Generates 3 orthogonal unit vectors to model the axis of the ellipsoid via QR decomposition</p> <p>vectors (np.ndarray): Optional, axes of the ellipsoid to be orthonormalized.                         If none specified generates randomly.</p> <p>Returns: np.ndarray: A 3x3 matrix where each column is a unit vector.</p> Source code in <code>openscvx/utils/utils.py</code> <pre><code>def generate_orthogonal_unit_vectors(vectors=None):\n    \"\"\"\n    Generates 3 orthogonal unit vectors to model the axis of the ellipsoid via QR decomposition\n\n    Parameters:\n    vectors (np.ndarray): Optional, axes of the ellipsoid to be orthonormalized.\n                            If none specified generates randomly.\n\n    Returns:\n    np.ndarray: A 3x3 matrix where each column is a unit vector.\n    \"\"\"\n    if vectors is None:\n        # Create a random key\n        key = jax.random.PRNGKey(0)\n\n        # Generate a 3x3 array of random numbers uniformly distributed between 0 and 1\n        vectors = jax.random.uniform(key, (3, 3))\n    Q, _ = jnp.linalg.qr(vectors)\n    return Q\n</code></pre>"},{"location":"reference/utils/cache/","title":"cache","text":"<p>Cache management for compiled solvers.</p> <p>This module provides utilities for managing the cache directory where compiled JAX solvers are stored. The cache location follows platform conventions:</p> <ul> <li>Linux: <code>~/.cache/openscvx/</code></li> <li>macOS: <code>~/Library/Caches/openscvx/</code></li> <li>Windows: <code>%LOCALAPPDATA%/openscvx/Cache/</code></li> </ul> <p>The cache location can be overridden by setting the <code>OPENSCVX_CACHE_DIR</code> environment variable.</p> Example <p>Get the cache directory::</p> <pre><code>import openscvx as ox\nprint(ox.get_cache_dir())  # /home/user/.cache/openscvx\n</code></pre> <p>Clear all cached solvers::</p> <pre><code>import openscvx as ox\nox.clear_cache()\n</code></pre> <p>Check cache size::</p> <pre><code>import openscvx as ox\nsize_mb = ox.get_cache_size() / (1024 * 1024)\nprint(f\"Cache size: {size_mb:.1f} MB\")\n</code></pre>"},{"location":"reference/utils/cache/#openscvx.utils.cache.clear_cache","title":"<code>clear_cache() -&gt; int</code>","text":"<p>Clear all cached compiled solvers.</p> <p>Removes all files in the cache directory. The directory itself is preserved but emptied.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of files deleted</p> Example <p>Clear the cache::</p> <pre><code>import openscvx as ox\ndeleted = ox.clear_cache()\nprint(f\"Deleted {deleted} cached files\")\n</code></pre> Source code in <code>openscvx/utils/cache.py</code> <pre><code>def clear_cache() -&gt; int:\n    \"\"\"Clear all cached compiled solvers.\n\n    Removes all files in the cache directory. The directory itself is\n    preserved but emptied.\n\n    Returns:\n        Number of files deleted\n\n    Example:\n        Clear the cache::\n\n            import openscvx as ox\n            deleted = ox.clear_cache()\n            print(f\"Deleted {deleted} cached files\")\n    \"\"\"\n    cache_dir = get_cache_dir()\n    if not cache_dir.exists():\n        return 0\n\n    count = 0\n    for item in cache_dir.iterdir():\n        if item.is_file():\n            item.unlink()\n            count += 1\n        elif item.is_dir():\n            shutil.rmtree(item)\n            count += 1\n\n    return count\n</code></pre>"},{"location":"reference/utils/cache/#openscvx.utils.cache.get_cache_dir","title":"<code>get_cache_dir() -&gt; Path</code>","text":"<p>Get the cache directory for compiled solvers.</p> <p>The cache location is determined in the following order: 1. <code>OPENSCVX_CACHE_DIR</code> environment variable (if set) 2. Platform-specific default:    - Linux: <code>~/.cache/openscvx/</code>    - macOS: <code>~/Library/Caches/openscvx/</code>    - Windows: <code>%LOCALAPPDATA%/openscvx/Cache/</code></p> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the cache directory (may not exist yet)</p> Source code in <code>openscvx/utils/cache.py</code> <pre><code>def get_cache_dir() -&gt; Path:\n    \"\"\"Get the cache directory for compiled solvers.\n\n    The cache location is determined in the following order:\n    1. ``OPENSCVX_CACHE_DIR`` environment variable (if set)\n    2. Platform-specific default:\n       - Linux: ``~/.cache/openscvx/``\n       - macOS: ``~/Library/Caches/openscvx/``\n       - Windows: ``%LOCALAPPDATA%/openscvx/Cache/``\n\n    Returns:\n        Path to the cache directory (may not exist yet)\n    \"\"\"\n    # Check environment variable override\n    env_dir = os.environ.get(\"OPENSCVX_CACHE_DIR\")\n    if env_dir:\n        return Path(env_dir)\n\n    # Platform-specific defaults\n    if sys.platform == \"darwin\":\n        # macOS: ~/Library/Caches/openscvx/\n        return Path.home() / \"Library\" / \"Caches\" / \"openscvx\"\n    elif sys.platform == \"win32\":\n        # Windows: %LOCALAPPDATA%/openscvx/Cache/\n        local_app_data = os.environ.get(\"LOCALAPPDATA\")\n        if local_app_data:\n            return Path(local_app_data) / \"openscvx\" / \"Cache\"\n        else:\n            # Fallback if LOCALAPPDATA not set\n            return Path.home() / \"AppData\" / \"Local\" / \"openscvx\" / \"Cache\"\n    else:\n        # Linux and others: follow XDG Base Directory Specification\n        xdg_cache = os.environ.get(\"XDG_CACHE_HOME\")\n        if xdg_cache:\n            return Path(xdg_cache) / \"openscvx\"\n        else:\n            return Path.home() / \".cache\" / \"openscvx\"\n</code></pre>"},{"location":"reference/utils/cache/#openscvx.utils.cache.get_cache_size","title":"<code>get_cache_size() -&gt; int</code>","text":"<p>Get the total size of the cache in bytes.</p> <p>Returns:</p> Type Description <code>int</code> <p>Total size of all files in the cache directory in bytes.</p> <code>int</code> <p>Returns 0 if the cache directory doesn't exist.</p> Example <p>Check cache size in megabytes::</p> <pre><code>import openscvx as ox\nsize_mb = ox.get_cache_size() / (1024 * 1024)\nprint(f\"Cache size: {size_mb:.1f} MB\")\n</code></pre> Source code in <code>openscvx/utils/cache.py</code> <pre><code>def get_cache_size() -&gt; int:\n    \"\"\"Get the total size of the cache in bytes.\n\n    Returns:\n        Total size of all files in the cache directory in bytes.\n        Returns 0 if the cache directory doesn't exist.\n\n    Example:\n        Check cache size in megabytes::\n\n            import openscvx as ox\n            size_mb = ox.get_cache_size() / (1024 * 1024)\n            print(f\"Cache size: {size_mb:.1f} MB\")\n    \"\"\"\n    cache_dir = get_cache_dir()\n    if not cache_dir.exists():\n        return 0\n\n    total = 0\n    for item in cache_dir.rglob(\"*\"):\n        if item.is_file():\n            total += item.stat().st_size\n\n    return total\n</code></pre>"},{"location":"reference/utils/caching/","title":"caching","text":""},{"location":"reference/utils/caching/#openscvx.utils.caching.get_solver_cache_paths","title":"<code>get_solver_cache_paths(symbolic_problem: SymbolicProblem, dt: float, total_time: float, cache_dir: Optional[Path] = None) -&gt; Tuple[Path, Path]</code>","text":"<p>Generate cache file paths using symbolic AST hashing.</p> <p>This function computes a hash based on the symbolic structure of the problem, which is more stable than hashing lowered JAX code. Two problems with the same mathematical structure will produce the same hash, regardless of variable names.</p> <p>Parameters:</p> Name Type Description Default <code>symbolic_problem</code> <code>SymbolicProblem</code> <p>The preprocessed SymbolicProblem</p> required <code>dt</code> <code>float</code> <p>Time step for propagation</p> required <code>total_time</code> <code>float</code> <p>Total simulation time</p> required <code>cache_dir</code> <code>Optional[Path]</code> <p>Directory to store cached solvers. If None, uses the default cache directory (see :func:<code>openscvx.get_cache_dir</code>).</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Path, Path]</code> <p>Tuple of (discretization_solver_path, propagation_solver_path)</p> Source code in <code>openscvx/utils/caching.py</code> <pre><code>def get_solver_cache_paths(\n    symbolic_problem: \"SymbolicProblem\",\n    dt: float,\n    total_time: float,\n    cache_dir: Optional[Path] = None,\n) -&gt; Tuple[Path, Path]:\n    \"\"\"Generate cache file paths using symbolic AST hashing.\n\n    This function computes a hash based on the symbolic structure of the problem,\n    which is more stable than hashing lowered JAX code. Two problems with the same\n    mathematical structure will produce the same hash, regardless of variable names.\n\n    Args:\n        symbolic_problem: The preprocessed SymbolicProblem\n        dt: Time step for propagation\n        total_time: Total simulation time\n        cache_dir: Directory to store cached solvers. If None, uses the default\n            cache directory (see :func:`openscvx.get_cache_dir`).\n\n    Returns:\n        Tuple of (discretization_solver_path, propagation_solver_path)\n    \"\"\"\n    from openscvx.symbolic.hashing import hash_symbolic_problem\n\n    # Get the structural hash of the symbolic problem\n    problem_hash = hash_symbolic_problem(symbolic_problem)\n\n    # Include runtime config in the hash\n    final_hasher = hashlib.sha256()\n    final_hasher.update(problem_hash.encode())\n    final_hasher.update(f\"dt:{dt}\".encode())\n    final_hasher.update(f\"total_time:{total_time}\".encode())\n    final_hash = final_hasher.hexdigest()[:32]\n\n    solver_dir = cache_dir if cache_dir is not None else get_cache_dir()\n    solver_dir.mkdir(parents=True, exist_ok=True)\n\n    dis_solver_file = solver_dir / f\"compiled_discretization_solver_{final_hash}.jax\"\n    prop_solver_file = solver_dir / f\"compiled_propagation_solver_{final_hash}.jax\"\n\n    return dis_solver_file, prop_solver_file\n</code></pre>"},{"location":"reference/utils/caching/#openscvx.utils.caching.load_or_compile_discretization_solver","title":"<code>load_or_compile_discretization_solver(discretization_solver: callable, cache_file: Path, params: Dict[str, Any], n_discretization_nodes: int, n_states: int, n_controls: int, save_compiled: bool = False, debug: bool = False) -&gt; callable</code>","text":"<p>Load discretization solver from cache or compile and cache it.</p> <p>Parameters:</p> Name Type Description Default <code>discretization_solver</code> <code>callable</code> <p>The solver function to compile</p> required <code>cache_file</code> <code>Path</code> <p>Path to cache file</p> required <code>params</code> <code>Dict[str, Any]</code> <p>Parameters dictionary</p> required <code>n_discretization_nodes</code> <code>int</code> <p>Number of discretization nodes</p> required <code>n_states</code> <code>int</code> <p>Number of state variables</p> required <code>n_controls</code> <code>int</code> <p>Number of control variables</p> required <code>save_compiled</code> <code>bool</code> <p>Whether to save/load compiled solvers</p> <code>False</code> <code>debug</code> <code>bool</code> <p>Whether in debug mode (skip compilation)</p> <code>False</code> <p>Returns:</p> Type Description <code>callable</code> <p>Compiled discretization solver</p> Source code in <code>openscvx/utils/caching.py</code> <pre><code>def load_or_compile_discretization_solver(\n    discretization_solver: callable,\n    cache_file: Path,\n    params: Dict[str, Any],\n    n_discretization_nodes: int,\n    n_states: int,\n    n_controls: int,\n    save_compiled: bool = False,\n    debug: bool = False,\n) -&gt; callable:\n    \"\"\"Load discretization solver from cache or compile and cache it.\n\n    Args:\n        discretization_solver: The solver function to compile\n        cache_file: Path to cache file\n        params: Parameters dictionary\n        n_discretization_nodes: Number of discretization nodes\n        n_states: Number of state variables\n        n_controls: Number of control variables\n        save_compiled: Whether to save/load compiled solvers\n        debug: Whether in debug mode (skip compilation)\n\n    Returns:\n        Compiled discretization solver\n    \"\"\"\n    if debug:\n        return discretization_solver\n\n    if save_compiled:\n        try:\n            with open(cache_file, \"rb\") as f:\n                serial_dis = f.read()\n            compiled_solver = export.deserialize(serial_dis)\n            print(\"\u2713 Loaded existing discretization solver\")\n            return compiled_solver\n        except FileNotFoundError:\n            print(\"Compiling discretization solver...\")\n\n    else:\n        print(\"Compiling discretization solver (not saving/loading from disk)...\")\n\n    # Pass parameters as a single dictionary\n    compiled_solver = export.export(jax.jit(discretization_solver))(\n        np.ones((n_discretization_nodes, n_states)),\n        np.ones((n_discretization_nodes, n_controls)),\n        params,\n    )\n\n    if save_compiled:\n        with open(cache_file, \"wb\") as f:\n            f.write(compiled_solver.serialize())\n        print(\"\u2713 Discretization solver compiled and saved\")\n\n    return compiled_solver\n</code></pre>"},{"location":"reference/utils/caching/#openscvx.utils.caching.load_or_compile_propagation_solver","title":"<code>load_or_compile_propagation_solver(propagation_solver: callable, cache_file: Path, params: Dict[str, Any], n_states_prop: int, n_controls: int, max_tau_len: int, save_compiled: bool = False) -&gt; callable</code>","text":"<p>Load propagation solver from cache or compile and cache it.</p> <p>Parameters:</p> Name Type Description Default <code>propagation_solver</code> <code>callable</code> <p>The solver function to compile</p> required <code>cache_file</code> <code>Path</code> <p>Path to cache file</p> required <code>params</code> <code>Dict[str, Any]</code> <p>Parameters dictionary</p> required <code>n_states_prop</code> <code>int</code> <p>Number of propagation state variables</p> required <code>n_controls</code> <code>int</code> <p>Number of control variables</p> required <code>max_tau_len</code> <code>int</code> <p>Maximum tau length for propagation</p> required <code>save_compiled</code> <code>bool</code> <p>Whether to save/load compiled solvers</p> <code>False</code> <p>Returns:</p> Type Description <code>callable</code> <p>Compiled propagation solver</p> Source code in <code>openscvx/utils/caching.py</code> <pre><code>def load_or_compile_propagation_solver(\n    propagation_solver: callable,\n    cache_file: Path,\n    params: Dict[str, Any],\n    n_states_prop: int,\n    n_controls: int,\n    max_tau_len: int,\n    save_compiled: bool = False,\n) -&gt; callable:\n    \"\"\"Load propagation solver from cache or compile and cache it.\n\n    Args:\n        propagation_solver: The solver function to compile\n        cache_file: Path to cache file\n        params: Parameters dictionary\n        n_states_prop: Number of propagation state variables\n        n_controls: Number of control variables\n        max_tau_len: Maximum tau length for propagation\n        save_compiled: Whether to save/load compiled solvers\n\n    Returns:\n        Compiled propagation solver\n    \"\"\"\n    if save_compiled:\n        try:\n            with open(cache_file, \"rb\") as f:\n                serial_prop = f.read()\n            compiled_solver = export.deserialize(serial_prop)\n            print(\"\u2713 Loaded existing propagation solver\")\n            return compiled_solver\n        except FileNotFoundError:\n            print(\"Compiling propagation solver...\")\n\n    else:\n        print(\"Compiling propagation solver (not saving/loading from disk)...\")\n\n    # Pass parameters as a single dictionary\n    compiled_solver = export.export(jax.jit(propagation_solver))(\n        np.ones(n_states_prop),  # x_0\n        (0.0, 0.0),  # time span\n        np.ones((1, n_controls)),  # controls_current\n        np.ones((1, n_controls)),  # controls_next\n        np.ones((1, 1)),  # tau_0\n        np.ones((1, 1)).astype(\"int\"),  # segment index\n        0,  # idx_s_stop\n        np.ones((max_tau_len,)),  # save_time (tau_cur_padded)\n        np.ones((max_tau_len,), dtype=bool),  # mask_padded (boolean mask)\n        params,  # additional parameters as dict\n    )\n\n    if save_compiled:\n        with open(cache_file, \"wb\") as f:\n            f.write(compiled_solver.serialize())\n        print(\"\u2713 Propagation solver compiled and saved\")\n\n    return compiled_solver\n</code></pre>"},{"location":"reference/utils/caching/#openscvx.utils.caching.prime_propagation_solver","title":"<code>prime_propagation_solver(propagation_solver: callable, params: Dict[str, Any], settings) -&gt; None</code>","text":"<p>Prime the propagation solver with a test call to ensure it works.</p> <p>Parameters:</p> Name Type Description Default <code>propagation_solver</code> <code>callable</code> <p>Compiled propagation solver</p> required <code>params</code> <code>Dict[str, Any]</code> <p>Parameters dictionary</p> required <code>settings</code> <p>Settings configuration object</p> required Source code in <code>openscvx/utils/caching.py</code> <pre><code>def prime_propagation_solver(\n    propagation_solver: callable, params: Dict[str, Any], settings\n) -&gt; None:\n    \"\"\"Prime the propagation solver with a test call to ensure it works.\n\n    Args:\n        propagation_solver: Compiled propagation solver\n        params: Parameters dictionary\n        settings: Settings configuration object\n    \"\"\"\n    try:\n        x_0 = np.ones(settings.sim.x_prop.initial.shape, dtype=settings.sim.x_prop.initial.dtype)\n        tau_grid = (0.0, 1.0)\n        controls_current = np.ones((1, settings.sim.u.shape[0]), dtype=settings.sim.u.guess.dtype)\n        controls_next = np.ones((1, settings.sim.u.shape[0]), dtype=settings.sim.u.guess.dtype)\n        tau_init = np.array([[0.0]], dtype=np.float64)\n        node = np.array([[0]], dtype=np.int64)\n        idx_s_stop = settings.sim.time_dilation_slice.stop\n        save_time = np.ones((settings.prp.max_tau_len,), dtype=np.float64)\n        mask_padded = np.ones((settings.prp.max_tau_len,), dtype=bool)\n        # Create dummy params dict with same structure\n        dummy_params = {\n            name: np.ones_like(value) if hasattr(value, \"shape\") else float(value)\n            for name, value in params.items()\n        }\n        propagation_solver.call(\n            x_0,\n            tau_grid,\n            controls_current,\n            controls_next,\n            tau_init,\n            node,\n            idx_s_stop,\n            save_time,\n            mask_padded,\n            dummy_params,\n        )\n    except Exception as e:\n        print(f\"[Initialization] Priming propagation_solver.call failed: {e}\")\n</code></pre>"},{"location":"reference/utils/printing/","title":"printing","text":""},{"location":"reference/utils/printing/#openscvx.utils.printing.print_problem_summary","title":"<code>print_problem_summary(settings, lowered)</code>","text":"<p>Print the problem summary box.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <p>Configuration settings containing problem information</p> required <code>lowered</code> <p>LoweredProblem from lower_symbolic_problem()</p> required Source code in <code>openscvx/utils/printing.py</code> <pre><code>def print_problem_summary(settings, lowered):\n    \"\"\"\n    Print the problem summary box.\n\n    Args:\n        settings: Configuration settings containing problem information\n        lowered: LoweredProblem from lower_symbolic_problem()\n    \"\"\"\n    n_nodal_convex = len(lowered.cvxpy_constraints.constraints)\n    n_nodal_nonconvex = len(lowered.jax_constraints.nodal)\n    n_ctcs = len(lowered.jax_constraints.ctcs)\n    n_augmented = settings.sim.n_states - settings.sim.true_state_slice.stop\n\n    # Count CVXPy variables, parameters, and constraints\n    from openscvx.solvers import optimal_control_problem\n\n    try:\n        # Build OCP using LoweredProblem\n        prob = optimal_control_problem(settings, lowered)\n\n        # Get the actual problem size information like CVXPy verbose output\n        n_cvx_variables = sum(var.size for var in prob.variables())\n        n_cvx_parameters = sum(param.size for param in prob.parameters())\n        n_cvx_constraints = sum(constraint.size for constraint in prob.constraints)\n    except Exception:\n        # Fallback if problem construction fails\n        n_cvx_variables = 0\n        n_cvx_parameters = 0\n        n_cvx_constraints = 0\n\n    # Get JAX backend information\n    jax_backend = jax.devices()[0].platform.upper()\n    jax_version = jax.__version__\n\n    # Build weights string conditionally\n    if isinstance(settings.scp.lam_vc, np.ndarray):\n        lam_vc_str = f\"\u03bb_vc=matrix({settings.scp.lam_vc.shape})\"\n    else:\n        lam_vc_str = f\"\u03bb_vc={settings.scp.lam_vc:4.1f}\"\n    weights_parts = [\n        f\"\u03bb_cost={settings.scp.lam_cost:4.1f}\",\n        f\"\u03bb_tr={settings.scp.w_tr:4.1f}\",\n        lam_vc_str,\n    ]\n\n    # Add \u03bb_vb only if there are nodal nonconvex constraints\n    if n_nodal_nonconvex &gt; 0:\n        weights_parts.append(f\"\u03bb_vb={settings.scp.lam_vb:4.1f}\")\n\n    weights_str = \", \".join(weights_parts)\n\n    lines = [\n        \"Problem Summary\",\n        (\n            f\"Dimensions: {settings.sim.n_states} states ({n_augmented} aug),\"\n            f\" {settings.sim.n_controls} controls, {settings.scp.n} nodes\"\n        ),\n        f\"Constraints: {n_nodal_convex} conv, {n_nodal_nonconvex} nonconv, {n_ctcs} ctcs\",\n        (\n            f\"Subproblem: {n_cvx_variables} vars, {n_cvx_parameters} params,\"\n            f\" {n_cvx_constraints} constraints\"\n        ),\n        f\"Weights: {weights_str}\",\n        f\"CVX Solver: {settings.cvx.solver}, Discretization Solver: {settings.dis.solver}\",\n        f\"JAX Backend: {jax_backend} (v{jax_version})\",\n    ]\n\n    print_summary_box(lines, \"Problem Summary\")\n</code></pre>"},{"location":"reference/utils/printing/#openscvx.utils.printing.print_results_summary","title":"<code>print_results_summary(result: OptimizationResults, timing_post, timing_init, timing_solve)</code>","text":"<p>Print the results summary box.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>OptimizationResults</code> <p>Optimization results object</p> required <code>timing_post</code> <code>float</code> <p>Post-processing time</p> required <code>timing_init</code> <code>float</code> <p>Initialization time</p> required <code>timing_solve</code> <code>float</code> <p>Solve time</p> required Source code in <code>openscvx/utils/printing.py</code> <pre><code>def print_results_summary(result: OptimizationResults, timing_post, timing_init, timing_solve):\n    \"\"\"\n    Print the results summary box.\n\n    Args:\n        result (OptimizationResults): Optimization results object\n        timing_post (float): Post-processing time\n        timing_init (float): Initialization time\n        timing_solve (float): Solve time\n    \"\"\"\n    cost = result.get(\"cost\", 0.0)\n    ctcs_violation = result.get(\"ctcs_violation\", 0.0)\n\n    # Convert numpy arrays to scalars for formatting\n    if hasattr(cost, \"item\"):\n        cost = cost.item()\n\n    # Handle CTCS violation - display as 1D array\n    if hasattr(ctcs_violation, \"size\"):\n        if ctcs_violation.size == 1:\n            ctcs_violation_str = f\"[{ctcs_violation.item():.2e}]\"\n        else:\n            # Display as 1D array\n            ctcs_violation_str = f\"[{', '.join([f'{v:.2e}' for v in ctcs_violation])}]\"\n    else:\n        ctcs_violation_str = f\"[{ctcs_violation:.2e}]\"\n\n    # Calculate total computation time\n    total_time = (timing_init or 0.0) + (timing_solve or 0.0) + timing_post\n\n    lines = [\n        \"Results Summary\",\n        f\"Cost: {cost:.6f}\",\n        f\"CTCS Constraint Violation: {ctcs_violation_str}\",\n        f\"Preprocessing Time: {timing_init or 0.0:.3f}s\",\n        f\"Main Solve Time: {timing_solve or 0.0:.3f}s\",\n        f\"Post-processing Time: {timing_post:.3f}s\",\n        f\"Total Computation Time: {total_time:.3f}s\",\n    ]\n\n    print_summary_box(lines, \"Results Summary\")\n</code></pre>"},{"location":"reference/utils/printing/#openscvx.utils.printing.print_summary_box","title":"<code>print_summary_box(lines, title='Summary')</code>","text":"<p>Print a centered summary box with the given lines.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list</code> <p>List of strings to display in the box</p> required <code>title</code> <code>str</code> <p>Title for the box (default: \"Summary\")</p> <code>'Summary'</code> Source code in <code>openscvx/utils/printing.py</code> <pre><code>def print_summary_box(lines, title=\"Summary\"):\n    \"\"\"\n    Print a centered summary box with the given lines.\n\n    Args:\n        lines (list): List of strings to display in the box\n        title (str): Title for the box (default: \"Summary\")\n    \"\"\"\n    # Find the longest line (excluding the title which will be handled separately)\n    content_lines = lines[1:] if len(lines) &gt; 1 else []\n    max_content_width = max(len(line) for line in content_lines) if content_lines else 0\n    title_width = len(title)\n\n    # Box width should accommodate both title and content\n    box_width = max(max_content_width, title_width) + 4  # Add padding for the box borders\n\n    # Center with respect to the 89-character horizontal lines in io.py\n    total_width = 89\n    if box_width &lt;= total_width:\n        indent = (total_width - box_width) // 2\n    else:\n        # If box is wider than 89 chars, use a smaller fixed indentation\n        indent = 2\n\n    # Print the box with dynamic width and centering\n    print(f\"\\n{' ' * indent}\u256d{'\u2500' * box_width}\u256e\")\n    print(f\"{' ' * indent}\u2502 {title:^{box_width - 2}} \u2502\")\n    print(f\"{' ' * indent}\u251c{'\u2500' * box_width}\u2524\")\n    for line in content_lines:\n        print(f\"{' ' * indent}\u2502 {line:&lt;{box_width - 2}} \u2502\")\n    print(f\"{' ' * indent}\u2570{'\u2500' * box_width}\u256f\\n\")\n</code></pre>"},{"location":"reference/utils/profiling/","title":"profiling","text":""},{"location":"reference/utils/profiling/#openscvx.utils.profiling.profiling_end","title":"<code>profiling_end(pr: Optional[cProfile.Profile], identifier: str)</code>","text":"<p>Stop profiling and save results with timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>pr</code> <code>Optional[Profile]</code> <p>Profile object from profiling_start, or None.</p> required <code>identifier</code> <code>str</code> <p>Identifier for the profiling session (e.g., \"solve\", \"initialize\").</p> required Source code in <code>openscvx/utils/profiling.py</code> <pre><code>def profiling_end(pr: \"Optional[cProfile.Profile]\", identifier: str):\n    \"\"\"Stop profiling and save results with timestamp.\n\n    Args:\n        pr: Profile object from profiling_start, or None.\n        identifier: Identifier for the profiling session (e.g., \"solve\", \"initialize\").\n    \"\"\"\n    if pr is not None:\n        pr.disable()\n        # Save results so it can be visualized with snakeviz\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        pr.dump_stats(f\"profiling/{timestamp}_{identifier}.prof\")\n</code></pre>"},{"location":"reference/utils/profiling/#openscvx.utils.profiling.profiling_start","title":"<code>profiling_start(profiling_enabled: bool) -&gt; Optional[cProfile.Profile]</code>","text":"<p>Start profiling if enabled.</p> <p>Parameters:</p> Name Type Description Default <code>profiling_enabled</code> <code>bool</code> <p>Whether to enable profiling.</p> required <p>Returns:</p> Type Description <code>Optional[Profile]</code> <p>Profile object if enabled, None otherwise.</p> Source code in <code>openscvx/utils/profiling.py</code> <pre><code>def profiling_start(profiling_enabled: bool) -&gt; \"Optional[cProfile.Profile]\":\n    \"\"\"Start profiling if enabled.\n\n    Args:\n        profiling_enabled: Whether to enable profiling.\n\n    Returns:\n        Profile object if enabled, None otherwise.\n    \"\"\"\n    if profiling_enabled:\n        import cProfile\n\n        pr = cProfile.Profile()\n        pr.enable()\n        return pr\n    return None\n</code></pre>"},{"location":"reference/utils/utils/","title":"utils","text":""},{"location":"reference/utils/utils/#openscvx.utils.utils.calculate_cost_from_boundaries","title":"<code>calculate_cost_from_boundaries(x: np.ndarray, initial_type: np.ndarray, final_type: np.ndarray) -&gt; float</code>","text":"<p>Calculate cost from boundary condition objectives.</p> <p>This function computes the total cost contribution from state boundary conditions marked as \"Minimize\" or \"Maximize\" at initial and final times.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>State trajectory array of shape (N, n_states)</p> required <code>initial_type</code> <code>ndarray</code> <p>Array of boundary condition types for initial states</p> required <code>final_type</code> <code>ndarray</code> <p>Array of boundary condition types for final states</p> required <p>Returns:</p> Type Description <code>float</code> <p>Total cost from minimize/maximize boundary conditions</p> Example Source code in <code>openscvx/utils/utils.py</code> <pre><code>def calculate_cost_from_boundaries(\n    x: np.ndarray, initial_type: np.ndarray, final_type: np.ndarray\n) -&gt; float:\n    \"\"\"Calculate cost from boundary condition objectives.\n\n    This function computes the total cost contribution from state boundary conditions\n    marked as \"Minimize\" or \"Maximize\" at initial and final times.\n\n    Args:\n        x: State trajectory array of shape (N, n_states)\n        initial_type: Array of boundary condition types for initial states\n        final_type: Array of boundary condition types for final states\n\n    Returns:\n        Total cost from minimize/maximize boundary conditions\n\n    Example:\n        &gt;&gt;&gt; # State with final time to minimize\n        &gt;&gt;&gt; x = np.array([[0.0, 5.0], [10.0, 20.0]])  # 2 nodes, 2 states\n        &gt;&gt;&gt; initial_type = np.array([\"Fix\", \"Free\"])\n        &gt;&gt;&gt; final_type = np.array([\"Minimize\", \"Free\"])\n        &gt;&gt;&gt; cost = calculate_cost_from_boundaries(x, initial_type, final_type)\n        &gt;&gt;&gt; cost  # Returns x[-1, 0] = 10.0\n    \"\"\"\n    cost = 0.0\n\n    # Add costs from initial boundary conditions\n    for i, bc_type in enumerate(initial_type):\n        if bc_type == \"Minimize\":\n            cost += x[0, i]\n        elif bc_type == \"Maximize\":\n            cost -= x[0, i]\n\n    # Add costs from final boundary conditions\n    for i, bc_type in enumerate(final_type):\n        if bc_type == \"Minimize\":\n            cost += x[-1, i]\n        elif bc_type == \"Maximize\":\n            cost -= x[-1, i]\n\n    return cost\n</code></pre>"},{"location":"reference/utils/utils/#openscvx.utils.utils.calculate_cost_from_boundaries--state-with-final-time-to-minimize","title":"State with final time to minimize","text":"<p>x = np.array([[0.0, 5.0], [10.0, 20.0]])  # 2 nodes, 2 states initial_type = np.array([\"Fix\", \"Free\"]) final_type = np.array([\"Minimize\", \"Free\"]) cost = calculate_cost_from_boundaries(x, initial_type, final_type) cost  # Returns x[-1, 0] = 10.0</p>"},{"location":"reference/utils/utils/#openscvx.utils.utils.gen_vertices","title":"<code>gen_vertices(center, radii)</code>","text":"<p>Obtains the vertices of the gate.</p> Source code in <code>openscvx/utils/utils.py</code> <pre><code>def gen_vertices(center, radii):\n    \"\"\"\n    Obtains the vertices of the gate.\n    \"\"\"\n    vertices = []\n    vertices.append(center + rot @ [radii[0], 0, radii[2]])\n    vertices.append(center + rot @ [-radii[0], 0, radii[2]])\n    vertices.append(center + rot @ [-radii[0], 0, -radii[2]])\n    vertices.append(center + rot @ [radii[0], 0, -radii[2]])\n    return vertices\n</code></pre>"},{"location":"reference/utils/utils/#openscvx.utils.utils.generate_orthogonal_unit_vectors","title":"<code>generate_orthogonal_unit_vectors(vectors=None)</code>","text":"<p>Generates 3 orthogonal unit vectors to model the axis of the ellipsoid via QR decomposition</p> <p>vectors (np.ndarray): Optional, axes of the ellipsoid to be orthonormalized.                         If none specified generates randomly.</p> <p>Returns: np.ndarray: A 3x3 matrix where each column is a unit vector.</p> Source code in <code>openscvx/utils/utils.py</code> <pre><code>def generate_orthogonal_unit_vectors(vectors=None):\n    \"\"\"\n    Generates 3 orthogonal unit vectors to model the axis of the ellipsoid via QR decomposition\n\n    Parameters:\n    vectors (np.ndarray): Optional, axes of the ellipsoid to be orthonormalized.\n                            If none specified generates randomly.\n\n    Returns:\n    np.ndarray: A 3x3 matrix where each column is a unit vector.\n    \"\"\"\n    if vectors is None:\n        # Create a random key\n        key = jax.random.PRNGKey(0)\n\n        # Generate a 3x3 array of random numbers uniformly distributed between 0 and 1\n        vectors = jax.random.uniform(key, (3, 3))\n    Q, _ = jnp.linalg.qr(vectors)\n    return Q\n</code></pre>"}]}