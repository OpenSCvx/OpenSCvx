{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"OpenSCvx","text":"<p>Welcome to OpenSCvx.</p>"},{"location":"citation/","title":"Citation","text":"<p>If you use OpenSCvx in your research, please cite the following works:</p>"},{"location":"citation/#primary-citation","title":"Primary Citation","text":"<pre><code>@ARTICLE{hayner2025los,\n        author={Hayner, Christopher R. and Carson III, John M. and A\u00e7\u0131kme\u015fe, Beh\u00e7et and Leung, Karen},\n        journal={IEEE Robotics and Automation Letters}, \n        title={Continuous-Time Line-of-Sight Constrained Trajectory Planning for 6-Degree of Freedom Systems}, \n        year={2025},\n        volume={},\n        number={},\n        pages={1-8},\n        keywords={Robot sensing systems;Vectors;Vehicle dynamics;Line-of-sight propagation;Trajectory planning;Trajectory optimization;Quadrotors;Nonlinear dynamical systems;Heuristic algorithms;Convergence;Constrained Motion Planning;Optimization and Optimal Control;Aerial Systems: Perception and Autonomy},\n        doi={10.1109/LRA.2025.3545299}}\n</code></pre>"},{"location":"citation/#methodological-foundation","title":"Methodological Foundation","text":"<pre><code>@misc{elango2024ctscvx,\n      title={Successive Convexification for Trajectory Optimization with Continuous-Time Constraint Satisfaction}, \n      author={Purnanand Elango and Dayou Luo and Abhinav G. Kamath and Samet Uzun and Taewan Kim and Beh\u00e7et A\u00e7\u0131kme\u015fe},\n      year={2024},\n      eprint={2404.16826},\n      archivePrefix={arXiv},\n      primaryClass={math.OC},\n      url={https://arxiv.org/abs/2404.16826}, \n}\n</code></pre>"},{"location":"citation/#solver-technology","title":"Solver Technology","text":"<pre><code>@misc{chari2025qoco,\n  title = {QOCO: A Quadratic Objective Conic Optimizer with Custom Solver Generation},\n  author = {Chari, Govind M and A{\\c{c}}{\\i}kme{\\c{s}}e, Beh{\\c{c}}et},\n  year = {2025},\n  eprint = {2503.12658},\n  archiveprefix = {arXiv},\n  primaryclass = {math.OC},\n}\n</code></pre>"},{"location":"citation/#acknowledgments","title":"Acknowledgments","text":"<p>This work was supported by a NASA Space Technology Graduate Research Opportunity and the Office of Naval Research under grant N00014-17-1-2433. The authors would like to acknowledge Natalia Pavlasek, Samuel Buckner, Abhi Kamath, Govind Chari, and Purnanand Elango as well as the other Autonomous Controls Laboratory members, for their many helpful discussions and support throughout this work. </p>"},{"location":"examples/","title":"Examples","text":"<p>OpenSCvx comes with a comprehensive set of examples demonstrating various trajectory optimization problems. These examples are located in the <code>examples/</code> folder and cover different applications and complexity levels.</p>"},{"location":"examples/#running-examples","title":"Running Examples","text":"<p>See <code>examples/params/</code> folder for several example trajectory optimization problems. To run a problem simply run any of the examples directly, for example:</p> <pre><code>python3 examples/params/brachistochrone.py\n</code></pre> <p>and adjust the plotting as needed.</p>"},{"location":"examples/#example-categories","title":"Example Categories","text":""},{"location":"examples/#abstract-problems","title":"Abstract Problems","text":"<ul> <li>Brachistochrone: Classic minimum-time problem with gravity</li> <li>3DoF Rocket Landing: Rocket landing with fuel optimization</li> </ul>"},{"location":"examples/#drone-applications","title":"Drone Applications","text":"<ul> <li>Obstacle Avoidance: 6DoF drone navigating around obstacles</li> <li>Line-of-Sight Guidance: Drone maintaining line-of-sight to keypoints while passing through gates</li> <li>Cinema View Planning: Camera drone planning for cinematic shots</li> <li>Drone Racing: High-speed racing through gates</li> </ul>"},{"location":"examples/#ground-vehicle-applications","title":"Ground Vehicle Applications","text":"<ul> <li>Dubins Car: Simple 2D vehicle with turning constraints</li> <li>Dubins Car with Waypoints: Navigation through multiple waypoints</li> </ul>"},{"location":"examples/#real-time-applications","title":"Real-time Applications","text":"<ul> <li>Real-time Drone Racing: Live optimization during flight</li> <li>Real-time Obstacle Avoidance: Dynamic obstacle avoidance</li> </ul>"},{"location":"examples/#creating-your-own-problems","title":"Creating Your Own Problems","text":"<p>Check out the problem definitions inside <code>examples/params</code> to see how to define your own problems. Each example demonstrates:</p> <ul> <li>State and control variable definition</li> <li>Dynamics specification</li> <li>Constraint formulation</li> <li>Problem instantiation and solving</li> <li>Results visualization</li> </ul>"},{"location":"examples/#example-structure","title":"Example Structure","text":"<p>Most examples follow this structure:</p> <ol> <li>Imports: Import necessary OpenSCvx modules</li> <li>Problem Setup: Define parameters, state, and control variables</li> <li>Dynamics: Specify the system dynamics</li> <li>Constraints: Define path and boundary constraints</li> <li>Problem Instantiation: Create and configure the Problem</li> <li>Solving: Run the optimization</li> <li>Visualization: Plot and analyze results</li> </ol>"},{"location":"examples/#performance-tips","title":"Performance Tips","text":"<ul> <li>Start with simpler examples to understand the workflow</li> <li>Use the provided initial guesses as starting points</li> <li>Adjust SCP weights based on your specific problem</li> <li>Consider using CVXPYGen for faster performance on smaller problems </li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>OpenSCvx is a JAX-based Python library for trajectory optimization using Successive Convexification (SCvx). It provides a simple interface for formulating and solving trajectory optimization problems with continuous-time constraint satisfaction.</p> <p>Important</p> <p>The library is currently in beta testing. Please report any issues on the GitHub repository.</p>"},{"location":"getting-started/#key-features","title":"Key Features","text":"<ul> <li>JAX-based: Automatic differentiation, vectorization, and compilation</li> <li>Continuous-time constraints: Support for path constraints that must be satisfied at all times</li> <li>Successive Convexification: Robust optimization algorithm for non-convex problems</li> <li>Multiple constraint types: Continuous-time, nodal, and boundary constraints</li> <li>Interactive visualization: 3D plotting and real-time optimization visualization</li> <li>Code generation: Automatic C++ code generation for optimization problems</li> <li>Faster solver performance through compiled code for smaller problems</li> <li>Support for customized solver backends like QOCOGen</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>You can install OpenSCvx using pip or uv. For the most common use case, which includes support for interactive plotting and code generation, you can install the library with the <code>gui</code> and <code>cvxpygen</code> extras:</p> <pre><code>pip install openscvx[gui,cvxpygen]\n# or with uv\nuv pip install openscvx[gui,cvxpygen]\n</code></pre> <p>If you only need the core library without the optional features, you can run:</p> <pre><code>pip install openscvx\n# or with uv\nuv pip install openscvx\n</code></pre>"},{"location":"getting-started/#development-version-nightly","title":"Development Version (Nightly)","text":"<p>To install the latest development version (nightly) from PyPI:</p> <pre><code>pip install --pre openscvx[gui,cvxpygen]\n# or with uv\nuv pip install --pre openscvx[gui,cvxpygen]\n</code></pre> <p>Or for just the core library:</p> <pre><code>pip install --pre openscvx\n# or with uv\nuv pip install --pre openscvx\n</code></pre> <p>Pre-release Versions</p> <p>The <code>--pre</code> flag tells pip/uv to install pre-release versions (e.g., <code>1.2.4.dev3</code>). These nightly builds contain the latest features and bug fixes but may be less stable than official releases.</p>"},{"location":"getting-started/#local-development","title":"Local Development","text":"<p>For local development, you can clone the repository and install it in editable mode:</p> <pre><code># Clone the repo\ngit clone https://github.com/haynec/OpenSCvx.git\ncd OpenSCvx\n\n# Install in editable mode with all optional dependencies\npip install -e \".[gui,cvxpygen]\"\n# or with uv\nuv pip install -e \".[gui,cvxpygen]\"\n</code></pre>"},{"location":"getting-started/#dependencies","title":"Dependencies","text":"<p>OpenSCvx has a few optional dependency groups:</p> <p>The core dependencies are installed automatically with <code>openscvx</code>:</p> <ul> <li><code>cvxpy</code> - for convex optimization</li> <li><code>jax</code> - for fast linear algebra, automatic differentiation, and vectorization</li> <li><code>numpy</code> - for numerical operations</li> <li><code>diffrax</code> - for automatic differentiation</li> <li><code>termcolor</code> - for colored terminal output</li> <li> <p><code>plotly</code> - for basic interactive 3D plotting</p> </li> <li> <p><code>gui</code>: For interactive 3D plotting and real-time visualization. This includes:</p> <ul> <li><code>pyqtgraph</code> - for realtime 3D plotting</li> <li><code>PyQt5</code> - for GUI</li> <li><code>scipy</code> - for spatial operations</li> <li><code>PyOpenGL</code> - for 3D plotting</li> <li><code>PyOpenGL_accelerate</code> (optional, for speed) - for 3D plotting</li> </ul> </li> <li> <p><code>cvxpygen</code>: For C++ code generation, enabling faster solver performance on smaller problems. This includes:</p> <ul> <li><code>cvxpygen</code> - for C++ code generation</li> <li><code>qocogen</code> - fast SOCP solver</li> </ul> </li> </ul>"},{"location":"getting-started/#local-development_1","title":"Local Development","text":"<p>For setting up a local development environment, we recommend using Conda to manage environments.</p> Via Conda  1.  Clone the repository:     <pre><code>git clone https://github.com/haynec/OpenSCvx.git\ncd OpenSCvx\n</code></pre> 2.  Create and activate a conda environment with Python:     <pre><code>conda create -n openscvx python&gt;=3.9\nconda activate openscvx\n</code></pre> 3.  Install the package in editable mode with all optional dependencies:     <pre><code>pip install -e \".[gui,cvxpygen]\"\n</code></pre> Via uv  1.  Prerequisites: Install [uv](https://docs.astral.sh/uv/getting-started/installation/) 2.  Clone the repository:     <pre><code>git clone https://github.com/haynec/OpenSCvx.git\ncd OpenSCvx\n</code></pre> 3.  Create and activate a virtual environment:     <pre><code>uv venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n</code></pre> 4.  Install the package in editable mode with all optional dependencies:     <pre><code>uv pip install -e \".[gui,cvxpygen]\"\n</code></pre> Via pip and venv  1.  Clone the repository:     <pre><code>git clone https://github.com/haynec/OpenSCvx.git\ncd OpenSCvx\n</code></pre> 2.  Create and activate a virtual environment:     <pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre> 3.  Install the package in editable mode with all optional dependencies:     <pre><code>pip install -e \".[gui,cvxpygen]\"\n</code></pre>"},{"location":"getting-started/#quick-example","title":"Quick Example","text":"<p>Here's a simple example to get you started with OpenSCvx. This demonstrates a minimum-time problem where a vehicle moves from the origin to a target position:</p> <pre><code>import numpy as np\nimport openscvx as ox\nfrom openscvx import Problem\n\n# Define state variables\nposition = ox.State(\"position\", shape=(2,))  # 2D position [x, y]\nposition.min = np.array([-10.0, -10.0])\nposition.max = np.array([10.0, 10.0])\nposition.initial = np.array([0.0, 0.0])\nposition.final = np.array([5.0, 5.0])\n\n# Define control variables\nvelocity = ox.Control(\"velocity\", shape=(2,))  # Velocity [vx, vy]\nvelocity.min = np.array([-2.0, -2.0])\nvelocity.max = np.array([2.0, 2.0])\n\n# Set initial guesses\nposition.guess = np.linspace(position.initial, position.final, 20)\nvelocity.guess = np.repeat(\n    np.expand_dims(np.array([1.0, 1.0]), axis=0), 20, axis=0\n)\n\n# Collect states and controls\nstates = [position]\ncontrols = [velocity]\n\n# Define dynamics using symbolic expressions\ndynamics = {\n    \"position\": velocity,  # position derivative is velocity\n}\n\n# Define time (minimize final time)\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", 5.0),  # Minimize final time with initial guess of 5.0\n    min=0.0,\n    max=10.0,\n)\n\n# Create the problem\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=[],\n    N=20,\n)\n\n# Solve the problem\nproblem.initialize()\nresult = problem.solve()\nresult = problem.post_process(result)\n\n# Access results\nprint(f\"Converged: {result.converged}\")\nprint(f\"Optimal time: {result.t_final:.3f}\")\nprint(f\"Final position: {result.trajectory['position'][-1]}\")\nprint(f\"Total cost: {result.cost:.3f}\")\n</code></pre> <p>Note</p> <p>This is a basic example. For more complex problems, see the Examples section.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Examples: Explore the comprehensive set of example problems</li> <li>Basic Problem Setup: Learn how to set up your first optimization problem</li> <li>Advanced Problem Setup: Learn how to set up a more complex optimization problem</li> <li>API Reference: Detailed documentation of all classes and functions</li> <li>Citation: Information for citing OpenSCvx in your research</li> </ul>"},{"location":"Overview/constraint_reformulation/","title":"Isoperimetric Constraint Reformulation","text":"<p>Warning</p> <p>This page is still under development .</p> <p> </p>"},{"location":"Overview/control_parameterization/","title":"Control Parameterization","text":"<p>Warning</p> <p>This page is still under development .</p>"},{"location":"Overview/discretization/","title":"Exact Discretization","text":"<p>Warning</p> <p>This page is still under development .</p> dVdt.py<pre><code>def dVdt(self,\n             tau: float,\n             V: jnp.ndarray,\n             u_cur: np.ndarray,\n             u_next: np.ndarray\n             ) -&gt; jnp.ndarray:\n        \"\"\"\n        Computes the time derivative of the augmented state vector for the system for a sequence of states.\n\n        Parameters:\n        tau (float): Current time.\n        V (np.ndarray): Sequence of augmented state vectors.\n        u_cur (np.ndarray): Sequence of current control inputs.\n        u_next (np.ndarray): Sequence of next control inputs.\n        A: Function that computes the Jacobian of the system dynamics with respect to the state.\n        B: Function that computes the Jacobian of the system dynamics with respect to the control input.\n        obstacles: List of obstacles in the environment.\n        params (dict): Parameters of the system.\n\n        Returns:\n        np.ndarray: Time derivatives of the augmented state vectors.\n        \"\"\"\n\n        # Extract the number of states and controls from the parameters\n        n_x = self.params.sim.n_states\n        n_u = self.params.sim.n_controls\n\n        # Unflatten V\n        V = V.reshape(-1, self.i5)\n\n        # Compute the interpolation factor based on the discretization type\n        if self.params.dis.dis_type == 'ZOH':\n            beta = 0.\n        elif self.params.dis.dis_type == 'FOH':\n            beta = (tau) * self.params.scp.n\n        alpha = 1 - beta\n\n        # Interpolate the control input\n        u = u_cur + beta * (u_next - u_cur)\n        s = u[:,-1]\n\n        # Initialize the augmented Jacobians\n        dfdx = jnp.zeros((V.shape[0], n_x, n_x))\n        dfdu = jnp.zeros((V.shape[0], n_x, n_u))\n\n        # Ensure x_seq and u have the same batch size\n        x = V[:,:self.params.sim.n_states]\n        u = u[:x.shape[0]]\n\n        # Compute the nonlinear propagation term\n        f = self.params.dyn.state_dot(x, u[:,:-1])\n        F = s[:, None] * f\n\n        # Evaluate the State Jacobian\n        dfdx = self.params.dyn.A(x, u[:,:-1])\n        sdfdx = s[:, None, None] * dfdx\n\n        # Evaluate the Control Jacobian\n        dfdu_veh = self.params.dyn.B(x, u[:,:-1])\n        dfdu = dfdu.at[:, :, :-1].set(s[:, None, None] * dfdu_veh)\n        dfdu = dfdu.at[:, :, -1].set(f)\n\n        # Compute the defect\n        z = F - jnp.einsum('ijk,ik-&gt;ij', sdfdx, x) - jnp.einsum('ijk,ik-&gt;ij', dfdu, u)\n\n        # Stack up the results into the augmented state vector\n        dVdt = jnp.zeros_like(V)\n        dVdt = dVdt.at[:, self.i0:self.i1].set(F)\n        dVdt = dVdt.at[:, self.i1:self.i2].set(jnp.matmul(sdfdx, V[:, self.i1:self.i2].reshape(-1, n_x, n_x)).reshape(-1, n_x * n_x))\n        dVdt = dVdt.at[:, self.i2:self.i3].set((jnp.matmul(sdfdx, V[:, self.i2:self.i3].reshape(-1, n_x, n_u)) + dfdu * alpha).reshape(-1, n_x * n_u))\n        dVdt = dVdt.at[:, self.i3:self.i4].set((jnp.matmul(sdfdx, V[:, self.i3:self.i4].reshape(-1, n_x, n_u)) + dfdu * beta).reshape(-1, n_x * n_u))\n        dVdt = dVdt.at[:, self.i4:self.i5].set((jnp.matmul(sdfdx, V[:, self.i4:self.i5].reshape(-1, n_x)[..., None]).squeeze(-1) + z).reshape(-1, n_x))\n        return dVdt.flatten()\n</code></pre>"},{"location":"Overview/ocp/","title":"Optimal Control Problem","text":"<p>Warning</p> <p>This page is still under development .</p> <p>The underlying convex subproblem is posed in the following general form. </p> <p><pre><code>def OptimalControlProblem(params: Config):\n</code></pre> The problem is defined as a function that takes in a <code>Config</code> object, which contains all the necessary parameters for the problem. The function returns a <code>cvxpy.Problem</code> object that can be solved using various solvers.</p>"},{"location":"Overview/ocp/#variable-and-parameter-definition","title":"Variable and Parameter Definition","text":"<p>The state, constrol and additional parameters are defined as follows:</p> <pre><code>w_tr = cp.Parameter(nonneg = True, name='w_tr')       # Weight on the Trust Region\nlam_cost = cp.Parameter(nonneg=True, name='lam_cost') # Weight on the Nonlinear Cost\n\nx = cp.Variable((params.scp.n, params.sim.n_states), name='x')   # State\ndx = cp.Variable((params.scp.n, params.sim.n_states), name='dx') # State Trust Region\nx_bar = cp.Parameter((params.scp.n, params.sim.n_states), name='x_bar') # Previous SCP State\n\n\nu = cp.Variable((params.scp.n, params.sim.n_controls), name='u')   # Control\ndu = cp.Variable((params.scp.n, params.sim.n_controls), name='du') # Control Trust Region\nu_bar = cp.Parameter((params.scp.n, params.sim.n_controls), name='u_bar') # Previous SCP Control\n</code></pre>"},{"location":"Overview/ocp/#scaling-definitions","title":"Scaling Definitions","text":"<p>The state and control are scaled using the following affine transformations:</p> \\[ \\begin{align*} \\tilde{x} &amp;= S_x x + c_x, \\\\ \\tilde{u} &amp;= S_u u + c_u, \\end{align*} \\] <p>where \\(\\tilde{x}\\) and \\(\\tilde{u}\\) are the unscaled state and control. The diagonal scalaing matrices, \\(S_x\\) and \\(S_u\\), are given by:</p> \\[ \\begin{align*} S_\\Box &amp;= \\mathrm{diag}\\left(\\mathrm{max}\\left(1, \\frac{\\mathrm{abs}(\\Box_\\min - \\Box_\\max)}{2}\\right)\\right) \\\\ c_\\Box &amp;= \\frac{\\Box_\\max + \\Box_\\min}{2} \\end{align*} \\] <p>These are instantiated in the optimal control problem as follows:</p> <pre><code># Affine Scaling for State\nS_x = params.sim.S_x\ninv_S_x = params.sim.inv_S_x\nc_x = params.sim.c_x\n</code></pre>"},{"location":"Overview/ocp/#discretized-dynamic-parameters","title":"Discretized Dynamic Parameters","text":"<p>The discretized dynamics matrices are defined as follows:</p> <pre><code># Discretized Augmented Dynamics Constraints\nA_d = cp.Parameter((params.scp.n - 1, params.sim.n_states, params.sim.n_states)), name='A_d')\nB_d = cp.Parameter((params.scp.n - 1, params.sim.n_states, params.sim.n_controls), name='B_d')\nC_d = cp.Parameter((params.scp.n - 1, params.sim.n_states, params.sim.n_controls), name='C_d')\nz_d = cp.Parameter((params.scp.n - 1, params.sim.n_states), name='z_d') # Nonlinear Propagation Defect\nnu  = cp.Variable((params.scp.n - 1, params.sim.n_states), name='nu')  # Virtual Control Slack Variable\n</code></pre>"},{"location":"Overview/ocp/#nodal-constraints","title":"Nodal Constraints","text":"<p>The nonconvex nodal parameters and variables are instantiated using the following code:</p> <pre><code># Linearized Nonconvex Nodal Constraints\n    if params.sim.constraints_nodal:\n        g = []\n        grad_g_x = []\n        grad_g_u = []\n        nu_vb = []\n        for idx_ncvx, constraint in enumerate(params.sim.constraints_nodal):\n            if not constraint.convex:\n                g.append(cp.Parameter(params.scp.n, name = 'g_' + str(idx_ncvx)))\n                grad_g_x.append(cp.Parameter((params.scp.n, params.sim.n_states), name='grad_g_x_' + str(idx_ncvx)))\n                grad_g_u.append(cp.Parameter((params.scp.n, params.sim.n_controls), name='grad_g_u_' + str(idx_ncvx)))\n                nu_vb.append(cp.Variable(params.scp.n, name='nu_vb_' + str(idx_ncvx))) # Virtual Control for VB\n</code></pre> <pre><code>def OptimalControlProblem(params: Config):\n    ########################\n    # VARIABLES &amp; PARAMETERS\n    ########################\n\n    # Parameters\n    w_tr = cp.Parameter(nonneg = True, name='w_tr')\n    lam_cost = cp.Parameter(nonneg=True, name='lam_cost')\n\n    # State\n    x = cp.Variable((params.scp.n, params.sim.n_states), name='x') \n    dx = cp.Variable((params.scp.n, params.sim.n_states), name='dx') # State Trust Region\n    x_bar = cp.Parameter((params.scp.n, params.sim.n_states), name='x_bar') # Previous SCP State\n\n    # Affine Scaling for State\n    S_x = params.sim.S_x\n    inv_S_x = params.sim.inv_S_x\n    c_x = params.sim.c_x\n\n    # Control\n    u = cp.Variable((params.scp.n, params.sim.n_controls), name='u') \n    du = cp.Variable((params.scp.n, params.sim.n_controls), name='du') # Control Trust Region\n    u_bar = cp.Parameter((params.scp.n, params.sim.n_controls), name='u_bar') # Previous SCP Control\n\n    # Affine Scaling for Control\n    S_u = params.sim.S_u\n    inv_S_u = params.sim.inv_S_u\n    c_u = params.sim.c_u\n\n    # Discretized Augmented Dynamics Constraints\n    A_d = cp.Parameter((params.scp.n - 1, params.sim.n_states, params.sim.n_states), name='A_d')\n    B_d = cp.Parameter((params.scp.n - 1, params.sim.n_states, params.sim.n_controls), name='B_d')\n    C_d = cp.Parameter((params.scp.n - 1, params.sim.n_states, params.sim.n_controls), name='C_d')\n    z_d = cp.Parameter((params.scp.n - 1, params.sim.n_states), name='z_d')\n    nu  = cp.Variable((params.scp.n - 1, params.sim.n_states), name='nu') # Virtual Control\n\n    # Linearized Nonconvex Nodal Constraints\n    if params.sim.constraints_nodal:\n        g = []\n        grad_g_x = []\n        grad_g_u = []\n        nu_vb = []\n        for idx_ncvx, constraint in enumerate(params.sim.constraints_nodal):\n            if not constraint.convex:\n                g.append(cp.Parameter(params.scp.n, name = 'g_' + str(idx_ncvx)))\n                grad_g_x.append(cp.Parameter((params.scp.n, params.sim.n_states), name='grad_g_x_' + str(idx_ncvx)))\n                grad_g_u.append(cp.Parameter((params.scp.n, params.sim.n_controls), name='grad_g_u_' + str(idx_ncvx)))\n                nu_vb.append(cp.Variable(params.scp.n, name='nu_vb_' + str(idx_ncvx))) # Virtual Control for VB\n\n    # Applying the affine scaling to state and control\n    x_nonscaled = []\n    u_nonscaled = []\n    for k in range(params.scp.n):\n        x_nonscaled.append(S_x @ x[k] + c_x)\n        u_nonscaled.append(S_u @ u[k] + c_u)\n\n    constr = []\n    cost = lam_cost * 0\n\n    #############\n    # CONSTRAINTS\n    #############\n    idx_ncvx = 0\n    if params.sim.constraints_nodal:\n        for constraint in params.sim.constraints_nodal:\n            if constraint.nodes is None:\n                nodes = range(params.scp.n)\n            else:\n                nodes = constraint.nodes\n\n            if constraint.convex:\n                constr += [constraint(x_nonscaled[node], u_nonscaled[node]) for node in nodes]\n\n            elif not constraint.convex:\n                constr += [((g[idx_ncvx][node] + grad_g_x[idx_ncvx][node] @ dx[node] + grad_g_u[idx_ncvx][node] @ du[node])) == nu_vb[idx_ncvx][node] for node in nodes]\n                idx_ncvx += 1\n\n    for i in range(params.sim.idx_x_true.start, params.sim.idx_x_true.stop):\n        if params.sim.initial_state.type[i] == 'Fix':\n            constr += [x_nonscaled[0][i] == params.sim.initial_state.value[i]]  # Initial Boundary Conditions\n        if params.sim.final_state.type[i] == 'Fix':\n            constr += [x_nonscaled[-1][i] == params.sim.final_state.value[i]]   # Final Boundary Conditions\n        if params.sim.initial_state.type[i] == 'Minimize':\n            cost += lam_cost * x_nonscaled[0][i]\n        if params.sim.final_state.type[i] == 'Minimize':\n            cost += lam_cost * x_nonscaled[-1][i]\n        if params.sim.initial_state.type[i] == 'Maximize':\n            cost += lam_cost * x_nonscaled[0][i]\n        if params.sim.final_state.type[i] == 'Maximize':\n            cost += lam_cost * x_nonscaled[-1][i]\n\n    if params.scp.uniform_time_grid:\n        constr += [x_nonscaled[i][params.sim.idx_t] - x_nonscaled[i-1][params.sim.idx_t] == x_nonscaled[i-1][params.sim.idx_t] - x_nonscaled[i-2][params.sim.idx_t] for i in range(2, params.scp.n)] # Uniform Time Step\n\n    constr += [0 == la.inv(S_x) @ (x_nonscaled[i] - x_bar[i] - dx[i]) for i in range(params.scp.n)] # State Error\n    constr += [0 == la.inv(S_u) @ (u_nonscaled[i] - u_bar[i] - du[i]) for i in range(params.scp.n)] # Control Error\n\n    constr += [x_nonscaled[i] == \\\n                      A_d[i-1] @ x_nonscaled[i-1] \\\n                    + B_d[i-1] @ u_nonscaled[i-1] \\\n                    + C_d[i-1] @ u_nonscaled[i] \\\n                    + z_d[i-1] \\\n                    + nu[i-1] for i in range(1, params.scp.n)] # Dynamics Constraint\n\n    constr += [u_nonscaled[i] &lt;= params.sim.max_control for i in range(params.scp.n)]\n    constr += [u_nonscaled[i] &gt;= params.sim.min_control for i in range(params.scp.n)] # Control Constraints\n\n    constr += [x_nonscaled[i][params.sim.idx_x_true] &lt;= params.sim.max_state[params.sim.idx_x_true] for i in range(params.scp.n)]\n    constr += [x_nonscaled[i][params.sim.idx_x_true] &gt;= params.sim.min_state[params.sim.idx_x_true] for i in range(params.scp.n)] # State Constraints (Also implemented in CTCS but included for numerical stability)\n\n    ########\n    # COSTS\n    ########\n\n    inv = block([[inv_S_x, np.zeros((S_x.shape[0], S_u.shape[1]))], [np.zeros((S_u.shape[0], S_x.shape[1])), inv_S_u]])\n    cost += sum(w_tr * cp.sum_squares(inv @ cp.hstack((dx[i], du[i]))) for i in range(params.scp.n))  # Trust Region Cost\n    cost += sum(params.scp.lam_vc * cp.sum(cp.abs(nu[i-1])) for i in range(1, params.scp.n)) # Virtual Control Slack\n\n    idx_ncvx = 0\n    if params.sim.constraints_nodal:\n        for constraint in params.sim.constraints_nodal:\n            if not constraint.convex:\n                cost += params.scp.lam_vb * cp.sum(cp.pos(nu_vb[idx_ncvx]))\n                idx_ncvx += 1\n\n    for idx, nodes in zip(np.arange(params.sim.idx_y.start, params.sim.idx_y.stop), params.sim.ctcs_node_intervals):  \n        if nodes[0] == 0:\n            start_idx = 1\n        else:\n            start_idx = nodes[0]\n        constr += [cp.abs(x_nonscaled[i][idx] - x_nonscaled[i-1][idx]) &lt;= params.sim.max_state[idx] for i in range(start_idx, nodes[1])]\n        constr += [x_nonscaled[0][idx] == 0]\n\n\n    #########\n    # PROBLEM\n    #########\n    prob = cp.Problem(cp.Minimize(cost), constr)\n    if params.cvx.cvxpygen:\n        # Check to see if solver directory exists\n        if not os.path.exists('solver'):\n            cpg.generate_code(prob, solver = params.cvx.solver, code_dir='solver', wrapper = True)\n        else:\n            # Prompt the use to indicate if they wish to overwrite the solver directory or use the existing compiled solver\n            overwrite = input(\"Solver directory already exists. Overwrite? (y/n): \")\n            if overwrite.lower() == 'y':\n                cpg.generate_code(prob, solver = params.cvx.solver, code_dir='solver', wrapper = True)\n            else:\n                pass\n    return prob\n</code></pre>"},{"location":"Overview/scvx/","title":"What is Succesive Convexification?","text":"<p>Warning</p> <p>This page is still under development .</p> <p>Successive Convexification is an approach to solve infinite dimensional nonconvex trajectory optimization problems. It works by successively convexifying or linearizing a problem and solving the convex subproblem. The solution to the convex subproblem is then used to update the original problem, and the process is repeated until convergence.</p> <p> </p>"},{"location":"Overview/scvx/#problem-formulation","title":"Problem Formulation","text":"<p>In this repository, the user will likely find it most useful specify there problem in the Mayer Form order to take full advantage of the features of this repo, but not worry this is quite easy.</p> \\[ \\begin{align} \\min_{x,u}\\ &amp;L_{f}(x(t_f)), \\\\ \\mathrm{s.t.}\\ &amp;\\dot{x}(t) = f(t, x(t),u(t)) &amp; \\forall t\\in[t_i, t_f], \\\\ &amp; g(t,x(t),u(t)) \\leq 0_{n_g} &amp; \\forall t\\in[t_i, t_f],\\\\ &amp; h(t,x(t),u(t)) = 0_{n_h} &amp; \\forall t\\in[t_i, t_f],\\\\ &amp; P(t_i, x(t_i), t_f, x(t_f)) = 0_{n_P} , \\\\ &amp; Q(t_i, x(t_i), t_f, x(t_f)) = 0_{n_Q} , \\\\ \\end{align} \\] <p>Lets break down whats happening here. The first line, \\(L_{f}(x(t_f))\\), is specifying a terminal cost as a function of state. The second is describing the nonlinear dynamics of the system, \\(\\dot{x}(t) = f(t, x(t),u(t))\\) where \\(x\\) and \\(u\\) are the system state and control respectively. The third and fourth lines are describing the inequality, \\(g(t,x(t),u(t)) \\leq 0_{n_g}\\),  and equality, \\(h(t,x(t),u(t)) = 0_{n_h}\\), constraints on the system respectively. Finally, the initial and terminal inequality and equality constraints are specified by \\(P(t_i, x(t_i), t_f, x(t_f)) = 0_{n_P}\\) and \\(Q(t_i, x(t_i), t_f, x(t_f)) = 0_{n_Q}\\) respectively.</p>"},{"location":"Overview/time_dilation/","title":"Time Dilation","text":"<p>Warning</p> <p>This page is still under development .</p>"},{"location":"UnderTheHood/lowering_architecture/","title":"Lowering Architecture","text":"<p>This document explains how OpenSCvx converts symbolic problem definitions into executable code for optimization.</p>"},{"location":"UnderTheHood/lowering_architecture/#the-big-picture","title":"The Big Picture","text":"<p>OpenSCvx separates trajectory optimization into four phases:</p> <ol> <li>Preprocessing \u2014 Validate inputs, augment dynamics, categorize constraints</li> <li>Lowering \u2014 Convert symbolic expressions to JAX/CVXPy code</li> <li>Solving \u2014 Run the SCP (Sequential Convex Programming) loop</li> <li>Post-processing \u2014 Propagate results, compute metrics</li> </ol> <p>This document focuses on Phase 2: Lowering.</p>"},{"location":"UnderTheHood/lowering_architecture/#why-lowering","title":"Why Lowering?","text":"<p>When you define a problem in OpenSCvx, you write symbolic expressions:</p> <pre><code>position = ox.State(\"pos\", shape=(3,))\nvelocity = ox.State(\"vel\", shape=(3,))\nthrust = ox.Control(\"thrust\", shape=(3,))\n\ndynamics = {\"pos\": velocity, \"vel\": thrust / mass - gravity}\nconstraints = [ox.Norm(thrust) &lt;= max_thrust]\n</code></pre> <p>These symbolic expressions form an AST (Abstract Syntax Tree). The lowering phase walks this AST and generates:</p> <ul> <li>JAX functions for dynamics and non-convex constraints (with automatic differentiation for Jacobians)</li> <li>CVXPy expressions for convex constraints (used directly in the convex subproblem)</li> </ul>"},{"location":"UnderTheHood/lowering_architecture/#pipeline-overview","title":"Pipeline Overview","text":"<pre><code>SymbolicProblem                         LoweredProblem\n(AST representation)                    (executable code)\n        \u2502                                      \u2502\n        \u2502     lower_symbolic_problem()         \u2502\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2502                                      \u2502\n   dynamics  \u2500\u2500\u2500\u2500\u2500\u2500\u25ba  JAX: f(x,u) \u2192 dx/dt      \u2502\n   (symbolic)         JAX: A = df/dx           \u2502\n                      JAX: B = df/du           \u2502\n        \u2502                                      \u2502\n   non-convex  \u2500\u2500\u2500\u2500\u25ba  JAX: g(x,u) \u2192 residual   \u2502\n   constraints        JAX: \u2207g_x, \u2207g_u          \u2502\n        \u2502                                      \u2502\n   convex      \u2500\u2500\u2500\u2500\u25ba  CVXPy constraint objects \u2502\n   constraints        (added directly to OCP)  \u2502\n        \u2502                                      \u2502\n   states,     \u2500\u2500\u2500\u2500\u25ba  UnifiedState/Control     \u2502\n   controls           (aggregated vectors)     \u2502\n        \u2502                                      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"UnderTheHood/lowering_architecture/#key-data-structures","title":"Key Data Structures","text":""},{"location":"UnderTheHood/lowering_architecture/#input-symbolicproblem","title":"Input: <code>SymbolicProblem</code>","text":"<p>After preprocessing, all symbolic definitions are collected into a <code>SymbolicProblem</code>:</p> <pre><code>@dataclass\nclass SymbolicProblem:\n    dynamics: Expr              # Symbolic dx/dt = f(x, u)\n    states: List[State]         # All state variables (including augmented)\n    controls: List[Control]     # All control variables (including virtual)\n    constraints: ConstraintSet  # Categorized constraints\n    parameters: dict            # User-defined parameters\n    N: int                      # Discretization nodes\n    # ... plus propagation variants\n</code></pre>"},{"location":"UnderTheHood/lowering_architecture/#output-loweredproblem","title":"Output: <code>LoweredProblem</code>","text":"<p>Lowering produces a <code>LoweredProblem</code> containing everything needed for optimization:</p> <pre><code>@dataclass\nclass LoweredProblem:\n    # JAX dynamics (callable functions with Jacobians)\n    dynamics: Dynamics           # f, A=df/dx, B=df/du\n    dynamics_prop: Dynamics      # For forward propagation\n\n    # Lowered constraints (by backend)\n    jax_constraints: LoweredJaxConstraints\n    cvxpy_constraints: LoweredCvxpyConstraints\n\n    # Unified state/control interfaces\n    x_unified: UnifiedState      # Aggregates all states into one vector\n    u_unified: UnifiedControl    # Aggregates all controls into one vector\n\n    # CVXPy optimization variables\n    ocp_vars: OCPVariables       # x, u, dx, du, nu, etc.\n    cvxpy_params: dict           # User parameters as cp.Parameter\n</code></pre>"},{"location":"UnderTheHood/lowering_architecture/#constraint-routing","title":"Constraint Routing","text":"<p>Constraints take different paths based on convexity:</p> Constraint Type Backend How It's Used in SCP Non-convex nodal JAX Linearized at each iteration: <code>g(x\u0304) + \u2207g\u00b7\u03b4x \u2264 0</code> Non-convex cross-node JAX Same, but references multiple trajectory nodes Convex nodal CVXPy Added directly to QP subproblem Convex cross-node CVXPy Same, with <code>NodeReference</code> indexing CTCS JAX Continuous-time via augmented dynamics"},{"location":"UnderTheHood/lowering_architecture/#jax-lowered-constraints","title":"JAX-Lowered Constraints","text":"<p>Non-convex constraints become JAX functions with gradients:</p> <pre><code>@dataclass\nclass LoweredJaxConstraints:\n    nodal: List[LoweredNodalConstraint]      # func, grad_g_x, grad_g_u\n    cross_node: List[LoweredCrossNodeConstraint]  # func, grad_g_X, grad_g_U\n    ctcs: List[CTCS]                         # Handled via dynamics augmentation\n</code></pre>"},{"location":"UnderTheHood/lowering_architecture/#cvxpy-lowered-constraints","title":"CVXPy-Lowered Constraints","text":"<p>Convex constraints become CVXPy constraint objects:</p> <pre><code>@dataclass\nclass LoweredCvxpyConstraints:\n    constraints: List[cp.Constraint]  # Added directly to OCP\n</code></pre>"},{"location":"UnderTheHood/lowering_architecture/#design-principles","title":"Design Principles","text":""},{"location":"UnderTheHood/lowering_architecture/#immutability","title":"Immutability","text":"<p>Lowering never mutates inputs. The original <code>SymbolicProblem</code> remains unchanged; a new <code>LoweredProblem</code> is returned. This enables:</p> <ul> <li>Inspecting symbolic expressions after lowering</li> <li>Reusing the same symbolic problem for multiple configurations</li> <li>Easier debugging and testing</li> </ul>"},{"location":"UnderTheHood/lowering_architecture/#type-separation","title":"Type Separation","text":"<p>Symbolic and lowered representations use distinct types:</p> <ul> <li><code>NodalConstraint</code> (symbolic) vs <code>LoweredNodalConstraint</code> (JAX functions)</li> <li><code>ConstraintSet</code> (symbolic) vs <code>LoweredJaxConstraints</code> / <code>LoweredCvxpyConstraints</code></li> </ul> <p>This prevents accidentally mixing AST nodes with executable code.</p>"},{"location":"UnderTheHood/lowering_architecture/#backend-independence","title":"Backend Independence","text":"<p>JAX lowering has no dependency on: - <code>N</code> (number of nodes) - Scaling matrices - CVXPy</p> <p>This means JAX-lowered dynamics and constraints could be used with alternative solvers.</p>"},{"location":"UnderTheHood/lowering_architecture/#further-reading","title":"Further Reading","text":"<ul> <li><code>openscvx/symbolic/lower.py</code> \u2014 Main lowering implementation</li> <li><code>openscvx/lowered/</code> \u2014 Dataclass definitions</li> <li><code>openscvx/symbolic/lowerers/jax.py</code> \u2014 JAX visitor implementation</li> <li><code>openscvx/symbolic/lowerers/cvxpy.py</code> \u2014 CVXPy visitor implementation</li> </ul>"},{"location":"UnderTheHood/vectorization_and_vmapping/","title":"Vectorization and Vmapping Across Decision Nodes","text":"<p>This page explains how OpenSCvx internally processes symbolic problem definitions into vectorized JAX computations. After symbolic preprocessing and augmentation (which you've likely seen in basic usage), the library creates unified state/control vectors and applies JAX's <code>vmap</code> to evaluate dynamics and non-convex constraints across decision nodes in parallel.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#processing-pipeline","title":"Processing Pipeline","text":"<p>The transformation from symbolic expressions to vectorized execution happens in several stages:</p> <ol> <li>Symbolic Preprocessing: Augmentation with time state, CTCS states, and time dilation (covered in basic usage)</li> <li>Unification: Individual State/Control objects combined into monolithic vectors</li> <li>JAX Lowering: Symbolic expressions compiled to executable JAX functions (dynamics and non-convex constraints)</li> <li>Vectorization: <code>vmap</code> applied to batch dynamics and constraint computations across decision nodes</li> </ol> <p>Understanding this pipeline is useful for performance optimization, debugging shape mismatches, and extending the library.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#stage-1-symbolic-problem-definition","title":"Stage 1: Symbolic Problem Definition","text":"<p>Starting from a typical problem definition with individual states and controls:</p> <pre><code>import openscvx as ox\nimport numpy as np\n\n# Individual state components\nposition = ox.State(\"position\", shape=(2,))\nvelocity = ox.State(\"velocity\", shape=(1,))\n\n# Control\ntheta = ox.Control(\"theta\", shape=(1,))\n\n# Dynamics per state\ndynamics = {\n    \"position\": ox.Concat(velocity[0] * ox.Sin(theta[0]), -velocity[0] * ox.Cos(theta[0])),\n    \"velocity\": 9.81 * ox.Cos(theta[0]),\n}\n</code></pre> <p>At this stage, each state/control is independent with its own shape, and dynamics are symbolic expressions without any notion of batching or decision nodes.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#stage-2-symbolic-preprocessing-and-augmentation","title":"Stage 2: Symbolic Preprocessing and Augmentation","text":"<p>During <code>Problem</code> construction (in <code>preprocess_symbolic_problem</code>), the symbolic problem is augmented:</p> <pre><code>problem = Problem(\n    dynamics=dynamics,\n    states=[position, velocity],\n    controls=[theta],\n    N=10,\n    time=ox.Time(initial=0.0, final=2.0),\n)\n</code></pre> <p>Internally, additional states and controls are added: - Time state (if not user-provided) - CTCS augmented states for path constraints - Time dilation control for time-optimal problems</p> <p>After augmentation: <code>states_aug = [position, velocity, time, ...]</code> and <code>controls_aug = [theta, _time_dilation]</code>, with corresponding dynamics for all augmented states.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#stage-3-unification","title":"Stage 3: Unification","text":"<p>The augmented states and controls are combined into unified vectors (in <code>lower_symbolic_expressions</code>):</p> <pre><code>x_unified: UnifiedState = unify_states(states_aug)\nu_unified: UnifiedControl = unify_controls(controls_aug)\n</code></pre> <p>The unification process (in <code>openscvx/symbolic/unified.py</code>) sorts variables (user-defined first, then augmented), concatenates properties (bounds, guesses, etc.), and assigns each State/Control a slice for indexing into the unified vector.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#unified-vector-shapes","title":"Unified Vector Shapes","text":"<p>For a problem with <code>N</code> decision nodes:</p> <pre><code>x_unified.shape = (n_x,)          # Sum of all state dimensions\nu_unified.shape = (n_u,)          # Sum of all control dimensions\nx_unified.guess.shape = (N, n_x)  # State trajectory\nu_unified.guess.shape = (N, n_u)  # Control trajectory\n</code></pre> <p>Concrete example (brachistochrone with N=10, no CTCS constraints): <pre><code>x_unified.shape = (4,)        # position(2) + velocity(1) + time(1)\nu_unified.shape = (2,)        # theta(1) + _time_dilation(1)\nx_unified.guess.shape = (10, 4)\nu_unified.guess.shape = (10, 2)\n</code></pre></p> <p>Each original State/Control retains a slice for extraction: <pre><code>position._slice = slice(0, 2)\nvelocity._slice = slice(2, 3)\ntime._slice = slice(3, 4)\n\n# Extract during evaluation:\nposition_value = x_unified[position._slice]  # (2,)\n</code></pre></p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#stage-4-jax-lowering","title":"Stage 4: JAX Lowering","text":"<p>Symbolic expressions for dynamics and non-convex constraints are converted to executable JAX functions (in <code>openscvx/symbolic/lower.py</code>). Convex constraints are lowered to CVXPy separately.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#dynamics-lowering","title":"Dynamics Lowering","text":"<pre><code># Convert symbolic dynamics to JAX function\ndyn_fn = lower_to_jax(dynamics_aug)\n\n# Create Dynamics object with Jacobians\ndynamics_augmented = Dynamics(\n    f=dyn_fn,                      # State derivative function\n    A=jacfwd(dyn_fn, argnums=0),   # Jacobian df/dx\n    B=jacfwd(dyn_fn, argnums=1),   # Jacobian df/du\n)\n</code></pre> <p>Dynamics Function Signature (Before Vmap):</p> <pre><code>def f(x: Array, u: Array, node: int, params: dict) -&gt; Array:\n    \"\"\"Compute state derivative at a single decision node.\n\n    Args:\n        x: State vector at this node, shape (n_x,)\n        u: Control vector at this node, shape (n_u,)\n        node: Node index (0 to N-1), used for time-varying behavior\n        params: Dictionary of problem parameters\n\n    Returns:\n        State derivative dx/dt, shape (n_x,)\n    \"\"\"\n    ...\n</code></pre> <p>Jacobians have similar signatures:</p> <pre><code>A(x, u, node, params) -&gt; Array[n_x, n_x]  # df/dx\nB(x, u, node, params) -&gt; Array[n_x, n_u]  # df/du\n</code></pre>"},{"location":"UnderTheHood/vectorization_and_vmapping/#non-convex-constraint-lowering","title":"Non-Convex Constraint Lowering","text":"<p>Non-convex nodal constraints that are to be lowered to JAX follow the same pattern:</p> <pre><code># Convert symbolic constraint expressions to JAX functions\nconstraints_nodal_fns = lower_to_jax(constraints_nodal)\n\n# Create LoweredNodalConstraint objects with Jacobians\nfor i, fn in enumerate(constraints_nodal_fns):\n    constraint = LoweredNodalConstraint(\n        func=fn,                          # Constraint function\n        grad_g_x=jacfwd(fn, argnums=0),  # Jacobian dg/dx\n        grad_g_u=jacfwd(fn, argnums=1),  # Jacobian dg/du\n        nodes=constraints_nodal[i].nodes, # Node indices where constraint applies\n    )\n</code></pre> <p>Constraint Function Signature (Before Vmap):</p> <pre><code>def g(x: Array, u: Array, node: int, params: dict) -&gt; float:\n    \"\"\"Evaluate constraint at a single decision node.\n\n    Args:\n        x: State vector at this node, shape (n_x,)\n        u: Control vector at this node, shape (n_u,)\n        node: Node index, used for time-varying constraints\n        params: Dictionary of problem parameters\n\n    Returns:\n        Constraint value (scalar)\n    \"\"\"\n    ...\n</code></pre> <p>Constraint Jacobians:</p> <pre><code>grad_g_x(x, u, node, params) -&gt; Array[n_x]  # dg/dx\ngrad_g_u(x, u, node, params) -&gt; Array[n_u]  # dg/du\n</code></pre>"},{"location":"UnderTheHood/vectorization_and_vmapping/#cross-node-constraint-lowering","title":"Cross-Node Constraint Lowering","text":"<p>Cross-node constraints couple variables across multiple trajectory nodes. Unlike regular nodal constraints that evaluate at single nodes, cross-node constraints require access to the full trajectory.</p> <p>Key Signature Difference:</p> Constraint Type Signature Vectorization Regular Nodal <code>(x, u, node, params) \u2192 scalar</code> vmapped across nodes Cross-Node <code>(X, U, params) \u2192 scalar</code> operates on full trajectory <p>Cross-node constraints are represented by the <code>CrossNodeConstraint</code> expression type and lowered via a dedicated visitor (<code>JaxLowerer._visit_cross_node_constraint</code> in <code>openscvx/symbolic/lowerers/jax.py</code>). The visitor wraps the inner constraint to provide the trajectory-level signature.</p> <p>Cross-Node Constraint Function Signature:</p> <pre><code>def g_cross(X: Array, U: Array, params: dict) -&gt; scalar:\n    \"\"\"Evaluate single cross-node constraint.\n\n    Args:\n        X: Full state trajectory, shape (N, n_x)\n        U: Full control trajectory, shape (N, n_u)\n        params: Dictionary of problem parameters\n\n    Returns:\n        Scalar constraint residual\n    \"\"\"\n    ...\n</code></pre> <p>Cross-Node Constraint Jacobians:</p> <pre><code>grad_g_X(X, U, params) -&gt; Array[N, n_x]  # dg/dX - Jacobian wrt all states\ngrad_g_U(X, U, params) -&gt; Array[N, n_u]  # dg/dU - Jacobian wrt all controls\n</code></pre> <p>Jacobian Sparsity: These Jacobians are stored as dense <code>(N, n_x)</code> and <code>(N, n_u)</code> arrays but are typically very sparse. A constraint coupling nodes <code>k</code> and <code>k-1</code> only has non-zero derivatives at rows <code>k</code> and <code>k-1</code>; all other rows are zero.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#stage-5-vectorization-with-vmap","title":"Stage 5: Vectorization with Vmap","text":"<p>Finally, both dynamics and constraints are vectorized to operate on decision nodes simultaneously. This enables efficient parallel evaluation on GPU/TPU hardware.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#dynamics-vectorization","title":"Dynamics Vectorization","text":"<p>Dynamics functions are vmapped to process all intervals in parallel (in <code>Problem.initialize</code>):</p> <pre><code># Vectorize dynamics functions across decision nodes\nself.dynamics_augmented.f = jax.vmap(\n    self.dynamics_augmented.f,\n    in_axes=(0, 0, 0, None)\n)\nself.dynamics_augmented.A = jax.vmap(\n    self.dynamics_augmented.A,\n    in_axes=(0, 0, 0, None)\n)\nself.dynamics_augmented.B = jax.vmap(\n    self.dynamics_augmented.B,\n    in_axes=(0, 0, 0, None)\n)\n</code></pre> <p>Dynamics Vmap Configuration: <code>in_axes=(0, 0, 0, None)</code></p> <p>This means: - Axis 0 of x: Batch over states at different intervals - Axis 0 of u: Batch over controls at different intervals - Axis 0 of node: Batch over node indices - None for params: Shared parameters (not batched)</p> <p>Dynamics Signature (After Vmap):</p> <pre><code>def f_vmapped(x_batch: Array, u_batch: Array, nodes: Array, params: dict) -&gt; Array:\n    \"\"\"Compute state derivatives at all intervals simultaneously.\n\n    Args:\n        x_batch: States at interval starts, shape (N-1, n_x)\n        u_batch: Controls at interval starts, shape (N-1, n_u)\n        nodes: Node indices, shape (N-1,) - typically jnp.arange(0, N-1)\n        params: Dictionary of problem parameters (shared across all nodes)\n\n    Returns:\n        State derivatives at all intervals, shape (N-1, n_x)\n    \"\"\"\n    ...\n</code></pre> <p>Jacobians after vmap:</p> <pre><code>A_vmapped(x_batch, u_batch, nodes, params) -&gt; Array[N-1, n_x, n_x]\nB_vmapped(x_batch, u_batch, nodes, params) -&gt; Array[N-1, n_x, n_u]\n</code></pre> <p>Why N-1 instead of N?</p> <p>Trajectory discretization operates on intervals between consecutive decision nodes: - N decision nodes: Including initial and final states (e.g., nodes 0, 1, 2, ..., 9 for N=10) - N-1 intervals: Between consecutive nodes (e.g., intervals [0\u21921], [1\u21922], ..., [8\u21929] for N=10) - Dynamics evaluation: At the start of each interval, giving N-1 evaluations</p> <p>This is why vmapped dynamics process batches of size <code>(N-1, ...)</code> rather than <code>(N, ...)</code>.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#constraint-vectorization","title":"Constraint Vectorization","text":"<p>Non-convex nodal constraints are also vectorized, but with a key difference (in <code>lower_symbolic_expressions</code>):</p> <pre><code># Vectorize constraint functions (during JAX lowering)\nconstraint = LoweredNodalConstraint(\n    func=jax.vmap(fn, in_axes=(0, 0, None, None)),\n    grad_g_x=jax.vmap(jacfwd(fn, argnums=0), in_axes=(0, 0, None, None)),\n    grad_g_u=jax.vmap(jacfwd(fn, argnums=1), in_axes=(0, 0, None, None)),\n    nodes=constraint.nodes,  # List of specific node indices where constraint applies\n)\n</code></pre> <p>Constraint Vmap Configuration: <code>in_axes=(0, 0, None, None)</code></p> <p>Note the key difference from dynamics: - Axis 0 of x: Batch over states - Axis 0 of u: Batch over controls - None for node: Node index is not batched (same value for all evaluations in a batch) - None for params: Shared parameters (not batched)</p> <p>Why the difference? Constraints are only evaluated at specific nodes (e.g., a collision avoidance constraint might only apply at nodes [2, 5, 7]). The constraint is vmapped to handle multiple constraint evaluations in parallel, but each evaluation receives the same <code>node</code> value since it's evaluating the same logical constraint at potentially different states/controls.</p> <p>Constraint Signature (After Vmap):</p> <pre><code>def g_vmapped(x_batch: Array, u_batch: Array, node: int, params: dict) -&gt; Array:\n    \"\"\"Evaluate constraint at multiple state/control pairs simultaneously.\n\n    Args:\n        x_batch: State vectors, shape (batch_size, n_x)\n        u_batch: Control vectors, shape (batch_size, n_u)\n        node: Single node index (broadcast to all evaluations)\n        params: Dictionary of problem parameters (shared across all evaluations)\n\n    Returns:\n        Constraint values, shape (batch_size,)\n    \"\"\"\n    ...\n</code></pre> <p>Constraint Jacobians after vmap:</p> <pre><code>grad_g_x_vmapped(x_batch, u_batch, node, params) -&gt; Array[batch_size, n_x]\ngrad_g_u_vmapped(x_batch, u_batch, node, params) -&gt; Array[batch_size, n_u]\n</code></pre> <p>When constraints are evaluated in practice:</p> <pre><code># Extract states/controls at nodes where constraint applies\nx_batch = x[constraint.nodes]  # Shape: (len(nodes), n_x)\nu_batch = u[constraint.nodes]  # Shape: (len(nodes), n_u)\n\n# Evaluate constraint at all specified nodes\ng_values = constraint.func(x_batch, u_batch, node_idx, params)  # Shape: (len(nodes),)\n</code></pre>"},{"location":"UnderTheHood/vectorization_and_vmapping/#cross-node-constraint-vectorization","title":"Cross-Node Constraint Vectorization","text":"<p>Cross-node constraints are not vmapped because they already operate on full trajectory arrays. Each <code>CrossNodeConstraint</code> is a single constraint with fixed node indices baked into the expression via <code>NodeReference</code> nodes.</p> <p>Key Difference from Regular Constraints:</p> Aspect Regular Nodal Constraints Cross-Node Constraints Input Shape Single-node vectors <code>(n_x,)</code>, <code>(n_u,)</code> Full trajectories <code>(N, n_x)</code>, <code>(N, n_u)</code> Vectorization <code>jax.vmap</code> with <code>in_axes=(0, 0, None, None)</code> No vmap (already trajectory-level) Output Scalar per evaluation Scalar per constraint Jacobian Shape <code>(n_x,)</code>, <code>(n_u,)</code> per node <code>(N, n_x)</code>, <code>(N, n_u)</code> per constraint <p>Evaluation: During SCP iterations, each cross-node constraint receives the full trajectory arrays and returns a scalar residual:</p> <pre><code># Each LoweredCrossNodeConstraint operates on full trajectories\nresidual = constraint.func(X, U, params)      # scalar\ngrad_X = constraint.grad_g_X(X, U, params)    # (N, n_x) - sparse, mostly zeros\ngrad_U = constraint.grad_g_U(X, U, params)    # (N, n_u) - sparse, mostly zeros\n</code></pre> <p>The Jacobians are dense arrays but exhibit sparsity patterns determined by which nodes the constraint couples.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#usage-in-discretization","title":"Usage in Discretization","text":"<p>The vmapped dynamics functions are called during discretization (in <code>calculate_discretization</code>):</p> <pre><code># Setup batch inputs\nx = V[:, :n_x]                          # Shape: (N-1, n_x) - States at interval starts\nu = u[: x.shape[0]]                     # Shape: (N-1, n_u) - Controls (includes time dilation)\nnodes = jnp.arange(0, N-1)              # Shape: (N-1,) - Node indices\n\n# Extract time dilation (last control dimension)\ns = u[:, -1]                            # Shape: (N-1,) - Time dilation values\n\n# Call vmapped dynamics - evaluates all intervals in parallel\n# Note: dynamics receive u[:, :-1] (vehicle controls only, excluding time dilation)\nf = state_dot(x, u[:, :-1], nodes, params)  # Shape: (N-1, n_x)\ndfdx = A(x, u[:, :-1], nodes, params)       # Shape: (N-1, n_x, n_x)\ndfdu_veh = B(x, u[:, :-1], nodes, params)   # Shape: (N-1, n_x, n_u-1)\n\n# Build full control Jacobian including time dilation\ndfdu = jnp.zeros((x.shape[0], n_x, n_u))\ndfdu = dfdu.at[:, :, :-1].set(s[:, None, None] * dfdu_veh)  # Vehicle control derivatives\ndfdu = dfdu.at[:, :, -1].set(f)                              # Time dilation derivative = f\n</code></pre> <p>Why exclude time dilation from dynamics? Time dilation is a meta-control that scales the entire dynamics (used for time-optimal problems). The actual vehicle dynamics are defined without it, and time dilation is applied as a scaling factor during discretization. This is why <code>n_u-1</code> appears in the vehicle dynamics Jacobians.</p> <p>Example with N=10: This single call evaluates dynamics at all 9 intervals simultaneously, leveraging JAX's efficient vectorization on GPU/TPU.</p>"},{"location":"UnderTheHood/vectorization_and_vmapping/#shape-summary-table","title":"Shape Summary Table","text":"<p>Here's a complete reference for shapes at each stage, shown with symbolic dimensions (<code>N</code>, <code>n_x</code>, <code>n_u</code>) and a concrete example:</p> Stage Variable Symbolic Shape Concrete Example (N=10, n_x=4, n_u=2) User Definition <code>position</code> <code>(2,)</code> <code>(2,)</code> - Single 2D position vector <code>velocity</code> <code>(1,)</code> <code>(1,)</code> - Single scalar velocity <code>theta</code> <code>(1,)</code> <code>(1,)</code> - Single scalar control After Augmentation <code>states_aug</code> List of States [position, velocity, time] (3 states) <code>controls_aug</code> List of Controls [theta, _time_dilation] (2 controls) After Unification <code>x_unified.shape</code> <code>(n_x,)</code> <code>(4,)</code> - position(2) + velocity(1) + time(1) <code>u_unified.shape</code> <code>(n_u,)</code> <code>(2,)</code> - theta(1) + _time_dilation(1) <code>x_unified.guess</code> <code>(N, n_x)</code> <code>(10, 4)</code> - States at 10 nodes <code>u_unified.guess</code> <code>(N, n_u)</code> <code>(10, 2)</code> - Controls at 10 nodes <code>position._slice</code> <code>slice(0, 2)</code> <code>slice(0, 2)</code> - Extract position <code>velocity._slice</code> <code>slice(2, 3)</code> <code>slice(2, 3)</code> - Extract velocity <code>time._slice</code> <code>slice(3, 4)</code> <code>slice(3, 4)</code> - Extract time JAX Functions (Pre-Vmap) Dynamics: <code>f(x, u, node, params)</code> Input: <code>(n_x,), (n_u,), scalar, dict</code> Input: <code>(4,), (2,), scalar, dict</code> Output: <code>(n_x,)</code> Output: <code>(4,)</code> - Single state derivative <code>A(x, u, node, params)</code> Output: <code>(n_x, n_x)</code> Output: <code>(4, 4)</code> - Jacobian df/dx <code>B(x, u, node, params)</code> Output: <code>(n_x, n_u)</code> Output: <code>(4, 2)</code> - Jacobian df/du Constraints: <code>g(x, u, node, params)</code> Input: <code>(n_x,), (n_u,), scalar, dict</code> Input: <code>(4,), (2,), scalar, dict</code> Output: <code>scalar</code> Output: <code>scalar</code> - Single constraint value <code>grad_g_x(x, u, node, params)</code> Output: <code>(n_x,)</code> Output: <code>(4,)</code> - Gradient dg/dx <code>grad_g_u(x, u, node, params)</code> Output: <code>(n_u,)</code> Output: <code>(2,)</code> - Gradient dg/du JAX Functions (Post-Vmap) Dynamics: <code>f(x, u, nodes, params)</code> Input: <code>(N-1, n_x), (N-1, n_u), (N-1,), dict</code> Input: <code>(9, 4), (9, 2), (9,), dict</code> Output: <code>(N-1, n_x)</code> Output: <code>(9, 4)</code> - Derivatives at 9 intervals <code>A(x, u, nodes, params)</code> Output: <code>(N-1, n_x, n_x)</code> Output: <code>(9, 4, 4)</code> - Jacobians at 9 intervals <code>B(x, u, nodes, params)</code> Output: <code>(N-1, n_x, n_u)</code> Output: <code>(9, 4, 2)</code> - Jacobians at 9 intervals Constraints: <code>g(x, u, node, params)</code> Input: <code>(M, n_x), (M, n_u), scalar, dict</code> Input: <code>(3, 4), (3, 2), scalar, dict</code> Output: <code>(M,)</code> Output: <code>(3,)</code> - M=3 constraint evaluations <code>grad_g_x(x, u, node, params)</code> Output: <code>(M, n_x)</code> Output: <code>(3, 4)</code> - Gradients at M nodes <code>grad_g_u(x, u, node, params)</code> Output: <code>(M, n_u)</code> Output: <code>(3, 2)</code> - Gradients at M nodes Cross-Node Constraints: <code>g_cross(X, U, params)</code> Input: <code>(N, n_x), (N, n_u), dict</code> Input: <code>(10, 4), (10, 2), dict</code> Output: <code>scalar</code> Output: <code>scalar</code> - Single constraint <code>grad_g_X(X, U, params)</code> Output: <code>(N, n_x)</code> Output: <code>(10, 4)</code> - Trajectory Jacobian <code>grad_g_U(X, U, params)</code> Output: <code>(N, n_u)</code> Output: <code>(10, 2)</code> - Trajectory Jacobian Note: Jacobians are dense but sparse Sparsity: Typically only 2-3 rows non-zero"},{"location":"UnderTheHood/vectorization_and_vmapping/#performance-implications","title":"Performance Implications","text":"<p>Why This Architecture?</p> <ol> <li>GPU/TPU Acceleration: Vmapping enables SIMD parallelism across nodes for both dynamics and constraints</li> <li>JIT Compilation: JAX compiles vmapped functions once, not per-node</li> <li>Automatic Differentiation: Jacobians and gradients computed automatically via <code>jacfwd</code></li> <li>Reduced Python Overhead: Single JAX call instead of Python loops for evaluation</li> </ol>"},{"location":"UnderTheHood/vectorization_and_vmapping/#implementation-files-reference","title":"Implementation Files Reference","text":"File Function/Class Purpose <code>openscvx/problem.py</code> <code>Problem.__init__</code> Orchestrates preprocessing pipeline <code>openscvx/symbolic/builder.py</code> <code>preprocess_symbolic_problem</code> Augments states/controls/dynamics <code>openscvx/symbolic/lower.py</code> <code>lower_symbolic_expressions</code> Unification and JAX lowering for dynamics/constraints <code>openscvx/symbolic/unified.py</code> <code>unify_states</code>, <code>unify_controls</code> Combines individual variables into unified vectors <code>openscvx/problem.py</code> <code>initialize</code> Applies vmap to dynamics <code>openscvx/discretization.py</code> <code>dVdt</code>, <code>calculate_discretization</code> Uses vmapped dynamics <code>openscvx/constraints/lowered.py</code> <code>LoweredNodalConstraint</code> Container for vmapped nodal constraints <code>openscvx/constraints/cross_node.py</code> <code>LoweredCrossNodeConstraint</code> Container for trajectory-level cross-node constraints <code>openscvx/symbolic/expr/constraint.py</code> <code>CrossNodeConstraint</code> Expression type for cross-node constraints <code>openscvx/symbolic/expr/expr.py</code> <code>NodeReference</code> Expression for referencing specific trajectory nodes <code>openscvx/symbolic/lowerers/jax.py</code> <code>JaxLowerer._visit_cross_node_constraint</code> Lowers CrossNodeConstraint to trajectory-level function <code>openscvx/symbolic/lowerers/jax.py</code> <code>JaxLowerer._visit_node_reference</code> Lowers NodeReference to JAX array indexing <code>openscvx/ocp.py</code> <code>create_cvxpy_variables</code> Creates CVXPy variables including cross-node parameters <code>openscvx/ptr.py</code> <code>PTR_subproblem</code> Updates constraint parameters during SCP iterations"},{"location":"UnderTheHood/vectorization_and_vmapping/#advanced-accessing-unified-vectors","title":"Advanced: Accessing Unified Vectors","text":"<p>During problem setup, you can access the unified objects:</p> <pre><code>problem = Problem(...)\nproblem.initialize()\n\n# Access unified state/control objects\nx_unified = problem.x_unified\nu_unified = problem.u_unified\n\nprint(f\"Total state dimension: {x_unified.shape[0]}\")\nprint(f\"Total control dimension: {u_unified.shape[0]}\")\n\n# Access individual state slices\nfor state in problem.states:\n    print(f\"{state.name}: slice {state._slice}\")\n</code></pre>"},{"location":"UnderTheHood/vectorization_and_vmapping/#common-developer-pitfalls","title":"Common Developer Pitfalls","text":"<ol> <li>Confusing nodes vs intervals: Discretization operates on N-1 intervals between N nodes, so vmapped dynamics have batch size <code>(N-1, ...)</code>, while constraints evaluate at specific nodes (batch size M where M = number of nodes where constraint applies)</li> <li>Forgetting augmented dimensions: <code>n_x</code> and <code>n_u</code> include auto-added states/controls (time, CTCS augmented states, time dilation)</li> <li>Parameter mutability: The <code>params</code> dict is shared across all evaluations - don't modify it during dynamics or constraint evaluation</li> <li>Node index usage: The <code>node</code> parameter enables time-varying behavior (e.g., time-dependent constraints), not for indexing into trajectory arrays</li> <li>Constraint vs dynamics vmap axes: Constraints use <code>in_axes=(0, 0, None, None)</code> (node not batched), while dynamics use <code>in_axes=(0, 0, 0, None)</code> (node batched across intervals)</li> <li>Cross-node constraint signature: Regular nodal constraints use <code>(x, u, node, params)</code> while cross-node constraints use <code>(X, U, params)</code> with full trajectory inputs</li> <li>Cross-node Jacobian memory: Cross-node Jacobians have shape <code>(N, n_x)</code> stored densely but are typically very sparse (most rows are zero). Be aware of memory usage for large N</li> </ol>"},{"location":"UnderTheHood/vectorization_and_vmapping/#see-also","title":"See Also","text":"<ul> <li>Basic Problem Setup - How to define problems</li> <li>API: State - State class documentation</li> <li>API: Control - Control class documentation</li> <li>API: Problem - Main problem class</li> <li>Discretization - How discretization works in OpenSCvx</li> </ul>"},{"location":"Usage/advanced_problem_setup/","title":"Advanced Problem Setup","text":""},{"location":"Usage/advanced_problem_setup/#using-parameters-in-dynamics-and-constraints","title":"Using Parameters in Dynamics and Constraints","text":"<p>OpenSCvx allows you to define symbolic parameters that can be used in both dynamics and constraints. Parameters enable flexible, reusable problem definitions and can be updated at runtime without recompiling.</p>"},{"location":"Usage/advanced_problem_setup/#example-3dof-rocket-landing-with-parameters","title":"Example: 3DoF Rocket Landing with Parameters","text":"<pre><code>import numpy as np\nimport openscvx as ox\n\n# Define parameters for physical constants\ng_e = 9.807  # Gravitational acceleration on Earth (m/s^2)\n\n# Create symbolic parameters\nI_sp = ox.Parameter(\"I_sp\", value=225.0)\ng = ox.Parameter(\"g\", value=3.7114)\ntheta = ox.Parameter(\"theta\", value=27 * np.pi / 180)\n\n# Define states\nposition = ox.State(\"position\", shape=(3,))\nvelocity = ox.State(\"velocity\", shape=(3,))\nmass = ox.State(\"mass\", shape=(1,))\n\n# Define control\nthrust = ox.Control(\"thrust\", shape=(3,))\n\n# Use parameters in dynamics\ng_vec = np.array([0, 0, 1], dtype=np.float64) * g\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": thrust / mass[0] - g_vec,\n    \"mass\": -ox.linalg.Norm(thrust) / (I_sp * g_e * ox.Cos(theta)),\n}\n</code></pre> <p>Parameters are automatically detected and handled by the problem - no need to manually collect or pass them.</p>"},{"location":"Usage/advanced_problem_setup/#using-parameters-in-constraints","title":"Using Parameters in Constraints","text":"<p>Parameters can be used in constraints just like in dynamics:</p> <pre><code># Define obstacle parameters\nobs_center = ox.Parameter(\"obs_center\", shape=(3,), value=np.array([100, 100, 50]))\nobs_radius = ox.Parameter(\"obs_radius\", value=50.0)\n\n# Use in continuous constraint\ndiff = position - obs_center\nconstraints.append(\n    ox.ctcs(diff.T @ diff &gt;= obs_radius**2)\n)\n\n# Use in discrete constraint\nconstraints.append(\n    (ox.linalg.Norm(position - obs_center) &gt;= obs_radius).at([10])\n)\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#updating-parameters-at-runtime","title":"Updating Parameters at Runtime","text":"<p>Parameters can be updated between solves without recompiling:</p> <pre><code># Initial solve\nproblem.initialize()\nresults = problem.solve()\n\n# Update parameter values\nproblem.parameters[\"obs_center\"] = np.array([150, 150, 60])\nproblem.parameters[\"obs_radius\"] = 60.0\n\n# Resolve with new parameter values (no recompilation needed)\nresults = problem.solve()\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#ctcs-constraints-advanced-options","title":"CTCS Constraints: Advanced Options","text":"<p>CTCS (Continuous-Time Constraint Satisfaction) constraints are enforced over continuous intervals using penalty functions.</p>"},{"location":"Usage/advanced_problem_setup/#penalty-function","title":"Penalty Function","text":"<p>You can specify a penalty function using the <code>penalty</code> argument. Built-in options include:</p> <ul> <li><code>squared_relu</code> (default) - \\(\\max(0, g)^2\\)</li> <li><code>huber</code> - \\(\\begin{cases} \\frac{1}{2} g^2 &amp; \\text{if } |g| \\leq \\delta \\\\ \\delta (|g| - \\frac{1}{2}\\delta) &amp; \\text{otherwise} \\end{cases}\\)</li> <li><code>smooth_relu</code> - \\(\\|\\max(0, g)+c\\|-c\\)</li> </ul> <p>Example:</p> <pre><code>constraints.append(\n    ox.ctcs(ox.linalg.Norm(position[:2]) &lt;= 10.0, penalty=\"huber\")\n)\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#node-specific-regions","title":"Node-Specific Regions","text":"<p>To enforce a constraint only over a portion of the trajectory, use the <code>.over()</code> method:</p> <pre><code># Enforce constraint between nodes 3 and 8\nconstraint = (ox.linalg.Norm(position[:2]) &lt;= 10.0).over(\n    interval=(3, 8),\n    penalty=\"squared_relu\"\n)\nconstraints.append(constraint)\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#multiple-augmented-states","title":"Multiple Augmented States","text":"<p>To associate different constraints with different augmented states, use the <code>idx</code> argument:</p> <pre><code># Box constraints use augmented state 0\nconstraints.extend([\n    ox.ctcs(position &lt;= position.max, idx=0),\n    ox.ctcs(position.min &lt;= position, idx=0),\n])\n\n# Thrust magnitude constraints use augmented state 1\nconstraints.extend([\n    ox.ctcs(rho_min &lt;= ox.linalg.Norm(thrust), idx=1),\n    ox.ctcs(ox.linalg.Norm(thrust) &lt;= rho_max, idx=1),\n])\n\n# Thrust pointing constraint uses augmented state 2\nconstraints.append(\n    ox.ctcs(np.cos(theta_max) &lt;= thrust[2] / ox.linalg.Norm(thrust), idx=2)\n)\n</code></pre> <p>This allows different constraints to use separate virtual control and augmented state variables, which can improve convergence.</p>"},{"location":"Usage/advanced_problem_setup/#nodal-constraints-advanced-options","title":"Nodal Constraints: Advanced Options","text":"<p>Nodal constraints are enforced at specific discrete nodes in the trajectory.</p>"},{"location":"Usage/advanced_problem_setup/#convex-and-nonconvex-constraints","title":"Convex and Nonconvex Constraints","text":"<p>For convex constraints, use the <code>.convex()</code> method:</p> <pre><code># Convex constraint - waypoint at node 10\ntarget = np.array([100, 100, 50])\nconstraints.append(\n    (ox.linalg.Norm(position - target, ord=\"inf\") &lt;= 1.0).convex().at([10])\n)\n\n# Convex constraint - altitude limit at node 15\nconstraints.append(\n    (position[2] &gt;= 10.0).convex().at([15])\n)\n</code></pre> <p>For nonconvex constraints, simply use the constraint without <code>.convex()</code>:</p> <pre><code># Nonconvex constraint\nconstraints.append(\n    (velocity.T @ velocity &lt;= v_max**2).at([5, 10, 15])\n)\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#node-specification","title":"Node Specification","text":"<p>Use the <code>.at()</code> method to specify which nodes enforce the constraint:</p> <pre><code># Single node\nconstraints.append((position[2] &gt;= 0).at([0]))\n\n# Multiple nodes\nconstraints.append((ox.linalg.Norm(velocity) &lt;= v_max).at([5, 10, 15, 20]))\n\n# Final node\nconstraints.append((velocity == np.array([0, 0, 0])).at([n-1]))\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#combining-with-ctcs","title":"Combining with CTCS","text":"<p>You can enforce a constraint both continuously and at specific nodes:</p> <pre><code># Enforce continuously with CTCS\nconstraint = ox.linalg.Norm(position - target) &gt;= safe_distance\n\n# Also check nodally (optional, for verification)\nconstraints.append(\n    constraint.over(interval=(0, n-1), check_nodally=True)\n)\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#solver-settings","title":"Solver Settings","text":"<p>OpenSCvx provides extensive configuration options for tuning solver behavior.</p>"},{"location":"Usage/advanced_problem_setup/#scp-algorithm-settings","title":"SCP Algorithm Settings","text":"<pre><code># Trust region settings\nproblem.settings.scp.w_tr = 2e0                  # Trust region weight\nproblem.settings.scp.w_tr_adapt = 1.04           # Trust region adaptation factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e2  # Maximum trust region scaling\n\n# Cost and virtual control weights\nproblem.settings.scp.lam_cost = 2.5e-1           # Weight on the cost objective\nproblem.settings.scp.lam_vc = 1.2e0              # Weight on virtual control\nproblem.settings.scp.lam_vb = 1e0                # Virtual buffer weight (for nonconvex nodal constraints)\n\n# Convergence tolerances\nproblem.settings.scp.ep_tr = 1e-3                # Trust region tolerance\nproblem.settings.scp.ep_vc = 1e-8                # Virtual control tolerance\n\n# Cost relaxation\nproblem.settings.scp.cost_drop = 10              # Iteration to start relaxing cost\nproblem.settings.scp.cost_relax = 0.8            # Cost relaxation factor\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#convex-solver-settings","title":"Convex Solver Settings","text":"<pre><code># Choose convex solver\nproblem.settings.cvx.solver = \"CLARABEL\"  # Options: \"CLARABEL\", \"ECOS\", \"SCS\", \"MOSEK\"\n\n# Solver-specific arguments\nproblem.settings.cvx.solver_args = {\n    \"enforce_dpp\": True,  # Data Parallel Processing for CLARABEL\n}\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#integration-settings","title":"Integration Settings","text":"<pre><code># Propagation time step\nproblem.settings.prp.dt = 0.01\n\n# Integration method\nproblem.settings.dis.solver = \"Dopri8\"  # Options: \"Dopri5\", \"Dopri8\", \"Tsit5\", etc.\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#compilation-and-caching","title":"Compilation and Caching","text":"<pre><code># Save compiled JAX functions for faster subsequent runs\nproblem.settings.sim.save_compiled = True\n</code></pre>"},{"location":"Usage/api/","title":"API","text":"<p>Warning</p> <p>This page is still under development .</p>"},{"location":"Usage/api/#constraints","title":"Constraints","text":"<p>Constraints in openscvx are created using symbolic expressions with comparison operators (<code>==</code>, <code>&lt;=</code>, <code>&gt;=</code>). By default, constraints are enforced at discrete nodes along the trajectory (nodal constraints). The symbolic expression system provides two specialized constraint wrappers for precise control over when and how constraints are enforced.</p>"},{"location":"Usage/api/#basic-constraints","title":"Basic Constraints","text":"<p>All basic constraints are automatically enforced at all discrete nodes unless wrapped with <code>.at()</code> or <code>.over()</code>.</p>"},{"location":"Usage/api/#equality","title":"Equality","text":""},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.Equality","title":"<code>openscvx.symbolic.expr.constraint.Equality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Equality constraint for optimization problems.</p> <p>Represents an equality constraint: lhs == rhs. Can be created using the == operator on Expr objects.</p> Example <p>Define an Equality constraint:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = x == 0  # Creates Equality(x, Constant(0))\n</code></pre>"},{"location":"Usage/api/#inequality","title":"Inequality","text":""},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.Inequality","title":"<code>openscvx.symbolic.expr.constraint.Inequality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Inequality constraint for optimization problems.</p> <p>Represents an inequality constraint: lhs &lt;= rhs. Can be created using the &lt;= operator on Expr objects.</p> Example <p>Define an Inequality constraint:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = x &lt;= 10  # Creates Inequality(x, Constant(10))\n</code></pre>"},{"location":"Usage/api/#specialized-constraint-wrappers","title":"Specialized Constraint Wrappers","text":""},{"location":"Usage/api/#nodalconstraint","title":"NodalConstraint","text":"<p>NodalConstraint allows selective enforcement of constraints at specific time points (nodes) in a discretized trajectory. Created using the <code>.at()</code> method on constraints. Note: Bare constraints without <code>.at()</code> or <code>.over()</code> are automatically converted to NodalConstraints applied at all nodes.</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint","title":"<code>openscvx.symbolic.expr.constraint.NodalConstraint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Wrapper for constraints enforced only at specific discrete trajectory nodes.</p> <p>NodalConstraint allows selective enforcement of constraints at specific time points (nodes) in a discretized trajectory, rather than enforcing them at every node. This is useful for:</p> <ul> <li>Specifying waypoint constraints (e.g., pass through point X at node 10)</li> <li>Boundary conditions at non-standard locations</li> <li>Reducing computational cost by checking constraints less frequently</li> <li>Enforcing periodic constraints (e.g., every 5th node)</li> </ul> <p>The wrapper maintains clean separation between the constraint's mathematical definition and the specification of where it should be applied during optimization.</p> Note <p>Bare Constraint objects (without .at() or .over()) are automatically converted to NodalConstraints applied at all nodes during preprocessing.</p> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (Equality or Inequality) to enforce</p> <code>nodes</code> <p>List of integer node indices where the constraint is enforced</p> Example <p>Enforce position constraint only at nodes 0, 10, and 20:</p> <pre><code>x = State(\"x\", shape=(3,))\ntarget = [10, 5, 0]\nconstraint = (x == target).at([0, 10, 20])\n</code></pre> <p>Equivalent using NodalConstraint directly:</p> <pre><code>constraint = NodalConstraint(x == target, nodes=[0, 10, 20])\n</code></pre> <p>Periodic constraint enforcement (every 10th node):</p> <pre><code>velocity_limit = (vel &lt;= 100).at(list(range(0, 100, 10)))\n</code></pre> <p>Bare constraints are automatically applied at all nodes. These are equivalent:</p> <pre><code>constraint1 = vel &lt;= 100  # Auto-converted to all nodes\nconstraint2 = (vel &lt;= 100).at(list(range(n_nodes)))\n</code></pre>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint.__init__","title":"<code>__init__(constraint: Constraint, nodes: list[int])</code>","text":"<p>Initialize a NodalConstraint.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>Constraint</code> <p>The Constraint (Equality or Inequality) to enforce at specified nodes</p> required <code>nodes</code> <code>list[int]</code> <p>List of integer node indices where the constraint should be enforced. Automatically converts numpy integers to Python integers.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If constraint is not a Constraint instance</p> <code>TypeError</code> <p>If nodes is not a list</p> <code>TypeError</code> <p>If any node index is not an integer</p> Note <p>Bounds checking for cross-node constraints (those containing NodeReference) is performed later in the pipeline when N is known, via validate_cross_node_constraint_bounds() in preprocessing.py.</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the wrapped constraint while preserving node specification.</p> <p>Returns:</p> Name Type Description <code>NodalConstraint</code> <code>Expr</code> <p>A new NodalConstraint with canonicalized inner constraint</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the wrapped constraint's shape.</p> <p>NodalConstraint wraps a constraint without changing its computational meaning, only specifying where it should be applied. Like all constraints, it produces a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint.convex","title":"<code>convex() -&gt; NodalConstraint</code>","text":"<p>Mark the underlying constraint as convex for CVXPy lowering.</p> <p>Returns:</p> Type Description <code>NodalConstraint</code> <p>Self with underlying constraint's convex flag set to True (enables method chaining)</p> Example <p>Mark a constraint as convex:     constraint = (x &lt;= 10).at([0, 5, 10]).convex()</p>"},{"location":"Usage/api/#ctcs-continuous-time-constraint-satisfaction","title":"CTCS (Continuous-Time Constraint Satisfaction)","text":"<p>CTCS guarantees strict constraint satisfaction throughout the entire continuous trajectory, not just at discrete nodes. It works by augmenting the state vector with additional states whose dynamics integrate constraint violation penalties. Created using the <code>.over()</code> method on constraints.</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS","title":"<code>openscvx.symbolic.expr.constraint.CTCS</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Continuous-Time Constraint Satisfaction using augmented state dynamics.</p> <p>CTCS enables strict continuous-time constraint enforcement in discretized trajectory optimization by augmenting the state vector with additional states whose dynamics are the constraint violation penalties. By constraining these augmented states to remain at zero throughout the trajectory, the original constraints are guaranteed to be satisfied continuously, not just at discrete nodes.</p> <p>How it works:</p> <ol> <li>Each constraint (in canonical form: lhs &lt;= 0) is wrapped in a penalty function</li> <li>Augmented states s_aug_i are added with dynamics: ds_aug_i/dt = sum(penalty_j(lhs_j))    for all CTCS constraints j in group i</li> <li>Each augmented state is constrained: s_aug_i(t) = 0 for all t (strictly enforced)</li> <li>Since s_aug_i integrates the penalties, s_aug_i = 0 implies all penalties in the    group are zero, which means all constraints in the group are satisfied continuously</li> </ol> <p>Grouping and augmented states:</p> <ul> <li>CTCS constraints with the same node interval are grouped into a single augmented   state by default (their penalties are summed)</li> <li>CTCS constraints with different node intervals create separate augmented states</li> <li>Using the <code>idx</code> parameter explicitly assigns constraints to specific augmented states,   allowing manual control over grouping</li> <li>Each unique group creates one augmented state named <code>_ctcs_aug_0</code>, <code>_ctcs_aug_1</code>, etc.</li> </ul> <p>This is particularly useful for:</p> <ul> <li>Path constraints that must hold throughout the entire trajectory (not just at nodes)</li> <li>Obstacle avoidance where constraint violation between nodes could be catastrophic</li> <li>State limits that should be respected continuously (e.g., altitude &gt; 0 for aircraft)</li> <li>Ensuring smooth, feasible trajectories between discretization points</li> </ul> <p>Penalty functions (applied to constraint violations):</p> <ul> <li>squared_relu: Square(PositivePart(lhs)) - smooth, differentiable (default)</li> <li>huber: Huber(PositivePart(lhs)) - less sensitive to outliers than squared</li> <li>smooth_relu: SmoothReLU(lhs) - smooth approximation of ReLU</li> </ul> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (typically Inequality) to enforce continuously</p> <code>penalty</code> <p>Penalty function type ('squared_relu', 'huber', or 'smooth_relu')</p> <code>nodes</code> <p>Optional (start, end) tuple specifying the interval for enforcement, or None to enforce over the entire trajectory</p> <code>idx</code> <p>Optional grouping index for managing multiple augmented states. CTCS constraints with the same idx and nodes are grouped together, sharing an augmented state. If None, auto-assigned based on node intervals.</p> <code>check_nodally</code> <p>Whether to also enforce the constraint at discrete nodes for additional numerical robustness (creates both continuous and nodal constraints)</p> Example <p>Single augmented state (default behavior - same node interval):</p> <pre><code>altitude = State(\"alt\", shape=(1,))\nconstraints = [\n    (altitude &gt;= 10).over((0, 10)),  # Both constraints share\n    (altitude &lt;= 1000).over((0, 10))  # one augmented state\n]\n</code></pre> <p>Multiple augmented states (different node intervals):</p> <pre><code>constraints = [\n    (altitude &gt;= 10).over((0, 5)),  # Creates _ctcs_aug_0\n    (altitude &gt;= 20).over((5, 10))  # Creates _ctcs_aug_1\n]\n</code></pre> <p>Manual grouping with idx parameter:</p> <pre><code>constraints = [\n    (altitude &gt;= 10).over((0, 10), idx=0),    # Group 0\n    (velocity &lt;= 100).over((0, 10), idx=1),   # Group 1 (separate state)\n    (altitude &lt;= 1000).over((0, 10), idx=0)   # Also group 0\n]\n</code></pre>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS.__init__","title":"<code>__init__(constraint: Constraint, penalty: str = 'squared_relu', nodes: Optional[Tuple[int, int]] = None, idx: Optional[int] = None, check_nodally: bool = False)</code>","text":"<p>Initialize a CTCS constraint.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>Constraint</code> <p>The Constraint to enforce continuously (typically an Inequality)</p> required <code>penalty</code> <code>str</code> <p>Penalty function type. Options: - 'squared_relu': Square(PositivePart(lhs)) - default, smooth, differentiable - 'huber': Huber(PositivePart(lhs)) - robust to outliers - 'smooth_relu': SmoothReLU(lhs) - smooth ReLU approximation</p> <code>'squared_relu'</code> <code>nodes</code> <code>Optional[Tuple[int, int]]</code> <p>Optional (start, end) tuple of node indices defining the enforcement interval. None means enforce over the entire trajectory. Must satisfy start &lt; end. CTCS constraints with the same nodes are automatically grouped together.</p> <code>None</code> <code>idx</code> <code>Optional[int]</code> <p>Optional grouping index for multiple augmented states. Allows organizing multiple CTCS constraints with separate augmented state variables. If None, constraints are auto-grouped by their node intervals. Explicitly setting idx allows manual control over which constraints share an augmented state.</p> <code>None</code> <code>check_nodally</code> <code>bool</code> <p>If True, also enforce the constraint at discrete nodes for numerical stability (creates both continuous and nodal constraints). Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If constraint is not a Constraint instance</p> <code>ValueError</code> <p>If nodes is not None or a 2-tuple of integers</p> <code>ValueError</code> <p>If nodes[0] &gt;= nodes[1] (invalid interval)</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the inner constraint while preserving CTCS parameters.</p> <p>Returns:</p> Name Type Description <code>CTCS</code> <code>Expr</code> <p>A new CTCS with canonicalized inner constraint and same parameters</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the constraint and penalty expression shapes.</p> <p>CTCS transforms the wrapped constraint into a penalty expression that is summed (integrated) over the trajectory, always producing a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the wrapped constraint has invalid shape</p> <code>ValueError</code> <p>If the generated penalty expression is not scalar</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS.over","title":"<code>over(interval: tuple[int, int]) -&gt; CTCS</code>","text":"<p>Set or update the continuous interval for this CTCS constraint.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>tuple[int, int]</code> <p>Tuple of (start, end) node indices defining the enforcement interval</p> required <p>Returns:</p> Name Type Description <code>CTCS</code> <code>CTCS</code> <p>New CTCS constraint with the specified interval</p> Example <p>Define constraint over range:</p> <pre><code>constraint = (altitude &gt;= 10).over((0, 50))\n</code></pre> <p>Update interval to cover different range:</p> <pre><code>constraint_updated = constraint.over((50, 100))\n</code></pre>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS.penalty_expr","title":"<code>penalty_expr() -&gt; Expr</code>","text":"<p>Build the penalty expression for this CTCS constraint.</p> <p>Transforms the constraint's left-hand side (in canonical form: lhs &lt;= 0) into a penalty expression using the specified penalty function. The penalty is zero when the constraint is satisfied and positive when violated.</p> <p>This penalty expression becomes part of the dynamics of an augmented state. Multiple CTCS constraints in the same group (same idx) have their penalties summed: ds_aug_i/dt = sum(penalty_j) for all j in group i. By constraining s_aug_i(t) = 0 for all t, we ensure all penalties in the group are zero, which strictly enforces all constraints in the group continuously.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Sum of the penalty function applied to the constraint violation</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown penalty type is specified</p> Note <p>This method is used internally during problem compilation to create augmented state dynamics. Multiple penalty expressions with the same idx are summed together before being added to the dynamics vector via Concat.</p>"},{"location":"Usage/api/#integrators","title":"Integrators","text":""},{"location":"Usage/api/#rk45integrator","title":"RK45Integrator","text":""},{"location":"Usage/api/#openscvx.integrators.solve_ivp_rk45","title":"<code>openscvx.integrators.solve_ivp_rk45(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, is_not_compiled: bool = False)</code>","text":"<p>Solve an initial-value ODE problem using fixed-step RK45 integration.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code>.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of output time points. Defaults to 50.</p> <code>50</code> <code>is_not_compiled</code> <code>bool</code> <p>If True, use Python loop instead of JAX <code>lax.fori_loop</code>. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Array of shape (num_substeps, state_dim) with solution at each time.</p>"},{"location":"Usage/api/#openscvx.integrators.rk45_step","title":"<code>openscvx.integrators.rk45_step(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], t: jnp.ndarray, y: jnp.ndarray, h: float, *args) -&gt; jnp.ndarray</code>","text":"<p>Perform a single RK45 (Runge-Kutta-Fehlberg) integration step.</p> <p>This implements the classic Dorman-Prince coefficients for an explicit 4(5) method, returning the fourth-order estimate.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>t</code> <code>ndarray</code> <p>Current time.</p> required <code>y</code> <code>ndarray</code> <p>Current state vector.</p> required <code>h</code> <code>float</code> <p>Step size.</p> required <code>*args</code> <p>Additional arguments passed to <code>f</code>.</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: Next state estimate at t + h.</p>"},{"location":"Usage/api/#diffrax-integrators","title":"Diffrax Integrators","text":""},{"location":"Usage/api/#openscvx.integrators.solve_ivp_diffrax","title":"<code>openscvx.integrators.solve_ivp_diffrax(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; f(t, y, *args).</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>solver_name</code> is not in SOLVER_MAP.</p>"},{"location":"Usage/api/#openscvx.integrators.solve_ivp_diffrax_prop","title":"<code>openscvx.integrators.solve_ivp_diffrax_prop(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None, save_time: jnp.ndarray = None, mask: jnp.ndarray = None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver. This function is specifically designed for use in the context of trajectory optimization and handles the nonlinear single-shot propagation of state variables in undilated time.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <code>save_time</code> <code>ndarray</code> <p>Time points at which to evaluate the solution. Must be provided for export compatibility.</p> <code>None</code> <code>mask</code> <code>ndarray</code> <p>Boolean mask for the save_time points.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:     ValueError: If <code>solver_name</code> is not in SOLVER_MAP or if save_time is not provided.</p>"},{"location":"Usage/api/#problem","title":"Problem","text":""},{"location":"Usage/api/#openscvx.problem.Problem.__init__","title":"<code>openscvx.problem.Problem.__init__(dynamics: dict, constraints: List[Union[Constraint, CTCS]], states: List[State], controls: List[Control], N: int, time: Time, *, dynamics_prop: Optional[dict] = None, states_prop: Optional[List[State]] = None, algebraic_prop: Optional[dict] = None, licq_min=0.0, licq_max=0.0001, time_dilation_factor_min=0.3, time_dilation_factor_max=3.0, byof: Optional[ByofSpec] = None)</code>","text":"<p>The primary class in charge of compiling and exporting the solvers.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>dict</code> <p>Dictionary mapping state names to their dynamics expressions. Each key should be a state name, and each value should be an Expr representing the derivative of that state.</p> required <code>constraints</code> <code>List[Union[CTCSConstraint, NodalConstraint]]</code> <p>List of constraints decorated with @ctcs or @nodal</p> required <code>states</code> <code>List[State]</code> <p>List of State objects representing the state variables. May optionally include a State named \"time\" (see time parameter below).</p> required <code>controls</code> <code>List[Control]</code> <p>List of Control objects representing the control variables</p> required <code>N</code> <code>int</code> <p>Number of segments in the trajectory</p> required <code>time</code> <code>Time</code> <p>Time configuration object with initial, final, min, max. Required. If including a \"time\" state in states, the Time object will be ignored and time properties should be set on the time State object instead.</p> required <code>dynamics_prop</code> <code>dict</code> <p>Dictionary mapping EXTRA state names to their dynamics expressions for propagation. Only specify additional states beyond optimization states (e.g., {\"distance\": speed}). Do NOT duplicate optimization state dynamics here.</p> <code>None</code> <code>states_prop</code> <code>List[State]</code> <p>List of EXTRA State objects for propagation only. Only specify additional states beyond optimization states. Used with dynamics_prop.</p> <code>None</code> <code>algebraic_prop</code> <code>dict</code> <p>Dictionary mapping names to symbolic expressions for outputs evaluated (not integrated) during propagation.</p> <code>None</code> <code>licq_min</code> <p>Minimum LICQ constraint value</p> <code>0.0</code> <code>licq_max</code> <p>Maximum LICQ constraint value</p> <code>0.0001</code> <code>time_dilation_factor_min</code> <p>Minimum time dilation factor</p> <code>0.3</code> <code>time_dilation_factor_max</code> <p>Maximum time dilation factor</p> <code>3.0</code> <code>byof</code> <code>Optional[ByofSpec]</code> <p>Expert mode only. Raw JAX functions to bypass symbolic layer. See :class:<code>openscvx.expert.ByofSpec</code> for detailed documentation.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Note <p>There are two approaches for handling time: 1. Auto-create (simple): Don't include \"time\" in states, provide Time object 2. User-provided (for time-dependent constraints): Include \"time\" State in states and    in dynamics dict, don't provide Time object</p>"},{"location":"Usage/api/#scpconfig","title":"ScpConfig","text":""},{"location":"Usage/api/#openscvx.config.ScpConfig.__init__","title":"<code>openscvx.config.ScpConfig.__init__(n: Optional[int] = None, k_max: int = 200, w_tr: float = 1.0, lam_vc: float = 1.0, ep_tr: float = 0.0001, ep_vb: float = 0.0001, ep_vc: float = 1e-08, lam_cost: float = 0.0, lam_vb: float = 0.0, uniform_time_grid: bool = False, cost_drop: int = -1, cost_relax: float = 1.0, w_tr_adapt: float = 1.0, w_tr_max: Optional[float] = None, w_tr_max_scaling_factor: Optional[float] = None)</code>","text":"<p>Configuration class for Sequential Convex Programming (SCP).</p> <p>This class defines the parameters used to configure the SCP solver. You will very likely need to modify the weights for your problem. Please refer to my guide here for more information.</p> <p>Attributes:</p> Name Type Description <code>n</code> <code>int</code> <p>The number of discretization nodes. Defaults to <code>None</code>.</p> <code>k_max</code> <code>int</code> <p>The maximum number of SCP iterations. Defaults to 200.</p> <code>w_tr</code> <code>float</code> <p>The trust region weight. Defaults to 1.0.</p> <code>lam_vc</code> <code>float</code> <p>The penalty weight for virtual control. Defaults to 1.0.</p> <code>ep_tr</code> <code>float</code> <p>The trust region convergence tolerance. Defaults to 1e-4.</p> <code>ep_vb</code> <code>float</code> <p>The boundary constraint convergence tolerance. Defaults to 1e-4.</p> <code>ep_vc</code> <code>float</code> <p>The virtual constraint convergence tolerance. Defaults to 1e-8.</p> <code>lam_cost</code> <code>float</code> <p>The weight for original cost. Defaults to 0.0.</p> <code>lam_vb</code> <code>float</code> <p>The weight for virtual buffer. This is only used if there are nonconvex nodal constraints present. Defaults to 0.0.</p> <code>uniform_time_grid</code> <code>bool</code> <p>Whether to use a uniform time grid. Defaults to <code>False</code>.</p> <code>cost_drop</code> <code>int</code> <p>The number of iterations to allow for cost stagnation before termination. Defaults to -1 (disabled).</p> <code>cost_relax</code> <code>float</code> <p>The relaxation factor for cost reduction. Defaults to 1.0.</p> <code>w_tr_adapt</code> <code>float</code> <p>The adaptation factor for the trust region weight. Defaults to 1.0.</p> <code>w_tr_max</code> <code>float</code> <p>The maximum allowable trust region weight. Defaults to <code>None</code>.</p> <code>w_tr_max_scaling_factor</code> <code>float</code> <p>The scaling factor for the maximum trust region weight. Defaults to <code>None</code>.</p>"},{"location":"Usage/api/#discretizationconfig","title":"DiscretizationConfig","text":""},{"location":"Usage/api/#openscvx.config.DiscretizationConfig.__init__","title":"<code>openscvx.config.DiscretizationConfig.__init__(dis_type: str = 'FOH', custom_integrator: bool = False, solver: str = 'Tsit5', args: Optional[dict] = None, atol: float = 0.001, rtol: float = 1e-06)</code>","text":"<p>Configuration class for discretization settings.</p> <p>This class defines the parameters required for discretizing system dynamics.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>dis_type</code> <code>str</code> <p>The type of discretization to use (e.g., \"FOH\" for First-Order Hold). Defaults to \"FOH\".</p> <code>'FOH'</code> <code>custom_integrator</code> <code>bool</code> <p>This enables our custom fixed-step RK45 algorithm. This tends to be faster than Diffrax but unless you're going for speed, it's recommended to stick with Diffrax for robustness and other solver options. Defaults to False.</p> <code>False</code> <code>solver</code> <code>str</code> <p>Not used if custom_integrator is enabled. Any choice of solver in Diffrax is valid, please refer here, How to Choose a Solver. Defaults to \"Tsit5\".</p> <code>'Tsit5'</code> <p>Other arguments: These arguments are less frequently used, and for most purposes you shouldn't need to understand these.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Dict</code> <p>Additional arguments to pass to the solver which can be found here. Defaults to an empty dictionary.</p> <code>None</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for the solver. Defaults to 1e-3.</p> <code>0.001</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for the solver. Defaults to 1e-6.</p> <code>1e-06</code>"},{"location":"Usage/api/#propagationconfig","title":"PropagationConfig","text":""},{"location":"Usage/api/#openscvx.config.PropagationConfig.__init__","title":"<code>openscvx.config.PropagationConfig.__init__(inter_sample: int = 30, dt: float = 0.01, solver: str = 'Dopri8', max_tau_len: int = 1000, args: Optional[dict] = None, atol: float = 0.001, rtol: float = 1e-06)</code>","text":"<p>Configuration class for propagation settings.</p> <p>This class defines the parameters required for propagating the nonlinear system dynamics using the optimal control sequence.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Other arguments: The solver should likely not be changed as it is a high accuracy 8th-order Runge-Kutta method.</p> <p>Parameters:</p> Name Type Description Default <code>inter_sample</code> <code>int</code> <p>How dense the propagation within multishot discretization should be. Defaults to 30.</p> <code>30</code> <code>dt</code> <code>float</code> <p>The time step for propagation. Defaults to 0.1.</p> <code>0.01</code> <code>solver</code> <code>str</code> <p>The numerical solver to use for propagation (e.g., \"Dopri8\"). Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>max_tau_len</code> <code>int</code> <p>The maximum length of the time vector for propagation. Defaults to 1000.</p> <code>1000</code> <code>args</code> <code>Dict</code> <p>Additional arguments to pass to the solver. Defaults to an empty dictionary.</p> <code>None</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for the solver. Defaults to 1e-3.</p> <code>0.001</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for the solver. Defaults to 1e-6.</p> <code>1e-06</code>"},{"location":"Usage/api/#simconfig","title":"SimConfig","text":""},{"location":"Usage/api/#openscvx.config.SimConfig.__init__","title":"<code>openscvx.config.SimConfig.__init__(x: UnifiedState, x_prop: UnifiedState, u: UnifiedControl, total_time: float, save_compiled: bool = False, ctcs_node_intervals: Optional[list] = None, n_states: Optional[int] = None, n_states_prop: Optional[int] = None, n_controls: Optional[int] = None)</code>","text":"<p>Configuration class for simulation settings.</p> <p>This class defines the parameters required for simulating a trajectory optimization problem.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>State</code> <p>State object, must have .min and .max attributes for bounds.</p> required <code>x_prop</code> <code>State</code> <p>Propagation state object, must have .min and .max attributes for bounds.</p> required <code>u</code> <code>Control</code> <p>Control object, must have .min and .max attributes for bounds.</p> required <code>total_time</code> <code>float</code> <p>The total simulation time.</p> required <code>idx_x_true</code> <code>slice</code> <p>Slice for true state indices.</p> required <code>idx_x_true_prop</code> <code>slice</code> <p>Slice for true propagation state indices.</p> required <code>idx_u_true</code> <code>slice</code> <p>Slice for true control indices.</p> required <code>idx_t</code> <code>slice</code> <p>Slice for time index.</p> required <code>idx_y</code> <code>slice</code> <p>Slice for constraint violation indices.</p> required <code>idx_y_prop</code> <code>slice</code> <p>Slice for propagation constraint violation indices.</p> required <code>idx_s</code> <code>slice</code> <p>Slice for time dilation index.</p> required <code>save_compiled</code> <code>bool</code> <p>If True, save and reuse compiled solver functions. Defaults to False.</p> <code>False</code> <code>ctcs_node_intervals</code> <code>list</code> <p>Node intervals for CTCS constraints.</p> <code>None</code> <code>n_states</code> <code>int</code> <p>The number of state variables. Defaults to <code>None</code> (inferred from x.max).</p> <code>None</code> <code>n_states_prop</code> <code>int</code> <p>The number of propagation state variables. Defaults to <code>None</code> (inferred from x_prop.max).</p> <code>None</code> <code>n_controls</code> <code>int</code> <p>The number of control variables. Defaults to <code>None</code> (inferred from u.max).</p> <code>None</code> Note <p>You can specify custom scaling for specific states/controls using the <code>scaling_min</code> and <code>scaling_max</code> attributes on State, Control, and Time objects. If not set, the default min/max bounds will be used for scaling.</p>"},{"location":"Usage/api/#convexsolverconfig","title":"ConvexSolverConfig","text":""},{"location":"Usage/api/#openscvx.config.ConvexSolverConfig.__init__","title":"<code>openscvx.config.ConvexSolverConfig.__init__(solver: str = 'QOCO', solver_args: Optional[dict] = None, cvxpygen: bool = False, cvxpygen_override: bool = False)</code>","text":"<p>Configuration class for convex solver settings.</p> <p>This class defines the parameters required for configuring a convex solver.</p> <p>These are the arguments most commonly used day-to-day. Generally I have found QOCO to be the most performant of the CVXPY solvers for these types of problems (I do have a bias as the author is from my group) and can handle up to SOCP's. CLARABEL is also a great option with feasibility checking and can handle a few more problem types. CVXPYGen is also great if your problem isn't too large. I have found qocogen to be the most performant of the CVXPYGen solvers.</p> <p>Parameters:</p> Name Type Description Default <code>solver</code> <code>str</code> <p>The name of the CVXPY solver to use. A list of options can be found here. Defaults to \"QOCO\".</p> <code>'QOCO'</code> <code>solver_args</code> <code>dict</code> <p>Ensure you are using the correct arguments for your solver as they are not all common. Additional arguments to configure the solver, such as tolerances. Defaults to {\"abstol\": 1e-6, \"reltol\": 1e-9}.</p> <code>None</code> <code>cvxpygen</code> <code>bool</code> <p>Whether to enable CVXPY code generation for the solver. Defaults to False.</p> <code>False</code>"},{"location":"Usage/api/#devconfig","title":"DevConfig","text":""},{"location":"Usage/api/#openscvx.config.DevConfig.__init__","title":"<code>openscvx.config.DevConfig.__init__(profiling: bool = False, debug: bool = False, printing: bool = True)</code>","text":"<p>Configuration class for development settings.</p> <p>This class defines the parameters used for development and debugging purposes.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>profiling</code> <code>bool</code> <p>Whether to enable profiling for performance analysis. Defaults to False.</p> <code>False</code> <code>debug</code> <code>bool</code> <p>Disables all precompilation so you can place breakpoints and inspect values. Defaults to False.</p> <code>False</code> <code>printing</code> <code>bool</code> <p>Whether to enable printing during development. Defaults to True.</p> <code>True</code>"},{"location":"Usage/api_constraints/","title":"Constraints","text":"<p>Constraints in openscvx are created using symbolic expressions with comparison operators (<code>==</code>, <code>&lt;=</code>, <code>&gt;=</code>). By default, constraints are enforced at discrete nodes along the trajectory (nodal constraints). The symbolic expression system provides two specialized constraint wrappers for precise control over when and how constraints are enforced.</p>"},{"location":"Usage/api_constraints/#basic-constraints","title":"Basic Constraints","text":"<p>All basic constraints are automatically enforced at all discrete nodes unless wrapped with <code>.at()</code> or <code>.over()</code>.</p>"},{"location":"Usage/api_constraints/#equality","title":"Equality","text":""},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.Equality","title":"<code>openscvx.symbolic.expr.constraint.Equality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Equality constraint for optimization problems.</p> <p>Represents an equality constraint: lhs == rhs. Can be created using the == operator on Expr objects.</p> Example <p>Define an Equality constraint:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = x == 0  # Creates Equality(x, Constant(0))\n</code></pre>"},{"location":"Usage/api_constraints/#inequality","title":"Inequality","text":""},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.Inequality","title":"<code>openscvx.symbolic.expr.constraint.Inequality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Inequality constraint for optimization problems.</p> <p>Represents an inequality constraint: lhs &lt;= rhs. Can be created using the &lt;= operator on Expr objects.</p> Example <p>Define an Inequality constraint:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = x &lt;= 10  # Creates Inequality(x, Constant(10))\n</code></pre>"},{"location":"Usage/api_constraints/#specialized-constraint-wrappers","title":"Specialized Constraint Wrappers","text":""},{"location":"Usage/api_constraints/#nodalconstraint","title":"NodalConstraint","text":"<p>NodalConstraint allows selective enforcement of constraints at specific time points (nodes) in a discretized trajectory. Created using the <code>.at()</code> method on constraints. Note: Bare constraints without <code>.at()</code> or <code>.over()</code> are automatically converted to NodalConstraints applied at all nodes.</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint","title":"<code>openscvx.symbolic.expr.constraint.NodalConstraint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Wrapper for constraints enforced only at specific discrete trajectory nodes.</p> <p>NodalConstraint allows selective enforcement of constraints at specific time points (nodes) in a discretized trajectory, rather than enforcing them at every node. This is useful for:</p> <ul> <li>Specifying waypoint constraints (e.g., pass through point X at node 10)</li> <li>Boundary conditions at non-standard locations</li> <li>Reducing computational cost by checking constraints less frequently</li> <li>Enforcing periodic constraints (e.g., every 5th node)</li> </ul> <p>The wrapper maintains clean separation between the constraint's mathematical definition and the specification of where it should be applied during optimization.</p> Note <p>Bare Constraint objects (without .at() or .over()) are automatically converted to NodalConstraints applied at all nodes during preprocessing.</p> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (Equality or Inequality) to enforce</p> <code>nodes</code> <p>List of integer node indices where the constraint is enforced</p> Example <p>Enforce position constraint only at nodes 0, 10, and 20:</p> <pre><code>x = State(\"x\", shape=(3,))\ntarget = [10, 5, 0]\nconstraint = (x == target).at([0, 10, 20])\n</code></pre> <p>Equivalent using NodalConstraint directly:</p> <pre><code>constraint = NodalConstraint(x == target, nodes=[0, 10, 20])\n</code></pre> <p>Periodic constraint enforcement (every 10th node):</p> <pre><code>velocity_limit = (vel &lt;= 100).at(list(range(0, 100, 10)))\n</code></pre> <p>Bare constraints are automatically applied at all nodes. These are equivalent:</p> <pre><code>constraint1 = vel &lt;= 100  # Auto-converted to all nodes\nconstraint2 = (vel &lt;= 100).at(list(range(n_nodes)))\n</code></pre>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint.__init__","title":"<code>__init__(constraint: Constraint, nodes: list[int])</code>","text":"<p>Initialize a NodalConstraint.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>Constraint</code> <p>The Constraint (Equality or Inequality) to enforce at specified nodes</p> required <code>nodes</code> <code>list[int]</code> <p>List of integer node indices where the constraint should be enforced. Automatically converts numpy integers to Python integers.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If constraint is not a Constraint instance</p> <code>TypeError</code> <p>If nodes is not a list</p> <code>TypeError</code> <p>If any node index is not an integer</p> Note <p>Bounds checking for cross-node constraints (those containing NodeReference) is performed later in the pipeline when N is known, via validate_cross_node_constraint_bounds() in preprocessing.py.</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the wrapped constraint while preserving node specification.</p> <p>Returns:</p> Name Type Description <code>NodalConstraint</code> <code>Expr</code> <p>A new NodalConstraint with canonicalized inner constraint</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the wrapped constraint's shape.</p> <p>NodalConstraint wraps a constraint without changing its computational meaning, only specifying where it should be applied. Like all constraints, it produces a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint.convex","title":"<code>convex() -&gt; NodalConstraint</code>","text":"<p>Mark the underlying constraint as convex for CVXPy lowering.</p> <p>Returns:</p> Type Description <code>NodalConstraint</code> <p>Self with underlying constraint's convex flag set to True (enables method chaining)</p> Example <p>Mark a constraint as convex:     constraint = (x &lt;= 10).at([0, 5, 10]).convex()</p>"},{"location":"Usage/api_constraints/#ctcs-continuous-time-constraint-satisfaction","title":"CTCS (Continuous-Time Constraint Satisfaction)","text":"<p>CTCS guarantees strict constraint satisfaction throughout the entire continuous trajectory, not just at discrete nodes. It works by augmenting the state vector with additional states whose dynamics integrate constraint violation penalties. Created using the <code>.over()</code> method on constraints.</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS","title":"<code>openscvx.symbolic.expr.constraint.CTCS</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Continuous-Time Constraint Satisfaction using augmented state dynamics.</p> <p>CTCS enables strict continuous-time constraint enforcement in discretized trajectory optimization by augmenting the state vector with additional states whose dynamics are the constraint violation penalties. By constraining these augmented states to remain at zero throughout the trajectory, the original constraints are guaranteed to be satisfied continuously, not just at discrete nodes.</p> <p>How it works:</p> <ol> <li>Each constraint (in canonical form: lhs &lt;= 0) is wrapped in a penalty function</li> <li>Augmented states s_aug_i are added with dynamics: ds_aug_i/dt = sum(penalty_j(lhs_j))    for all CTCS constraints j in group i</li> <li>Each augmented state is constrained: s_aug_i(t) = 0 for all t (strictly enforced)</li> <li>Since s_aug_i integrates the penalties, s_aug_i = 0 implies all penalties in the    group are zero, which means all constraints in the group are satisfied continuously</li> </ol> <p>Grouping and augmented states:</p> <ul> <li>CTCS constraints with the same node interval are grouped into a single augmented   state by default (their penalties are summed)</li> <li>CTCS constraints with different node intervals create separate augmented states</li> <li>Using the <code>idx</code> parameter explicitly assigns constraints to specific augmented states,   allowing manual control over grouping</li> <li>Each unique group creates one augmented state named <code>_ctcs_aug_0</code>, <code>_ctcs_aug_1</code>, etc.</li> </ul> <p>This is particularly useful for:</p> <ul> <li>Path constraints that must hold throughout the entire trajectory (not just at nodes)</li> <li>Obstacle avoidance where constraint violation between nodes could be catastrophic</li> <li>State limits that should be respected continuously (e.g., altitude &gt; 0 for aircraft)</li> <li>Ensuring smooth, feasible trajectories between discretization points</li> </ul> <p>Penalty functions (applied to constraint violations):</p> <ul> <li>squared_relu: Square(PositivePart(lhs)) - smooth, differentiable (default)</li> <li>huber: Huber(PositivePart(lhs)) - less sensitive to outliers than squared</li> <li>smooth_relu: SmoothReLU(lhs) - smooth approximation of ReLU</li> </ul> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (typically Inequality) to enforce continuously</p> <code>penalty</code> <p>Penalty function type ('squared_relu', 'huber', or 'smooth_relu')</p> <code>nodes</code> <p>Optional (start, end) tuple specifying the interval for enforcement, or None to enforce over the entire trajectory</p> <code>idx</code> <p>Optional grouping index for managing multiple augmented states. CTCS constraints with the same idx and nodes are grouped together, sharing an augmented state. If None, auto-assigned based on node intervals.</p> <code>check_nodally</code> <p>Whether to also enforce the constraint at discrete nodes for additional numerical robustness (creates both continuous and nodal constraints)</p> Example <p>Single augmented state (default behavior - same node interval):</p> <pre><code>altitude = State(\"alt\", shape=(1,))\nconstraints = [\n    (altitude &gt;= 10).over((0, 10)),  # Both constraints share\n    (altitude &lt;= 1000).over((0, 10))  # one augmented state\n]\n</code></pre> <p>Multiple augmented states (different node intervals):</p> <pre><code>constraints = [\n    (altitude &gt;= 10).over((0, 5)),  # Creates _ctcs_aug_0\n    (altitude &gt;= 20).over((5, 10))  # Creates _ctcs_aug_1\n]\n</code></pre> <p>Manual grouping with idx parameter:</p> <pre><code>constraints = [\n    (altitude &gt;= 10).over((0, 10), idx=0),    # Group 0\n    (velocity &lt;= 100).over((0, 10), idx=1),   # Group 1 (separate state)\n    (altitude &lt;= 1000).over((0, 10), idx=0)   # Also group 0\n]\n</code></pre>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS.__init__","title":"<code>__init__(constraint: Constraint, penalty: str = 'squared_relu', nodes: Optional[Tuple[int, int]] = None, idx: Optional[int] = None, check_nodally: bool = False)</code>","text":"<p>Initialize a CTCS constraint.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>Constraint</code> <p>The Constraint to enforce continuously (typically an Inequality)</p> required <code>penalty</code> <code>str</code> <p>Penalty function type. Options: - 'squared_relu': Square(PositivePart(lhs)) - default, smooth, differentiable - 'huber': Huber(PositivePart(lhs)) - robust to outliers - 'smooth_relu': SmoothReLU(lhs) - smooth ReLU approximation</p> <code>'squared_relu'</code> <code>nodes</code> <code>Optional[Tuple[int, int]]</code> <p>Optional (start, end) tuple of node indices defining the enforcement interval. None means enforce over the entire trajectory. Must satisfy start &lt; end. CTCS constraints with the same nodes are automatically grouped together.</p> <code>None</code> <code>idx</code> <code>Optional[int]</code> <p>Optional grouping index for multiple augmented states. Allows organizing multiple CTCS constraints with separate augmented state variables. If None, constraints are auto-grouped by their node intervals. Explicitly setting idx allows manual control over which constraints share an augmented state.</p> <code>None</code> <code>check_nodally</code> <code>bool</code> <p>If True, also enforce the constraint at discrete nodes for numerical stability (creates both continuous and nodal constraints). Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If constraint is not a Constraint instance</p> <code>ValueError</code> <p>If nodes is not None or a 2-tuple of integers</p> <code>ValueError</code> <p>If nodes[0] &gt;= nodes[1] (invalid interval)</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the inner constraint while preserving CTCS parameters.</p> <p>Returns:</p> Name Type Description <code>CTCS</code> <code>Expr</code> <p>A new CTCS with canonicalized inner constraint and same parameters</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the constraint and penalty expression shapes.</p> <p>CTCS transforms the wrapped constraint into a penalty expression that is summed (integrated) over the trajectory, always producing a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the wrapped constraint has invalid shape</p> <code>ValueError</code> <p>If the generated penalty expression is not scalar</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS.over","title":"<code>over(interval: tuple[int, int]) -&gt; CTCS</code>","text":"<p>Set or update the continuous interval for this CTCS constraint.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>tuple[int, int]</code> <p>Tuple of (start, end) node indices defining the enforcement interval</p> required <p>Returns:</p> Name Type Description <code>CTCS</code> <code>CTCS</code> <p>New CTCS constraint with the specified interval</p> Example <p>Define constraint over range:</p> <pre><code>constraint = (altitude &gt;= 10).over((0, 50))\n</code></pre> <p>Update interval to cover different range:</p> <pre><code>constraint_updated = constraint.over((50, 100))\n</code></pre>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS.penalty_expr","title":"<code>penalty_expr() -&gt; Expr</code>","text":"<p>Build the penalty expression for this CTCS constraint.</p> <p>Transforms the constraint's left-hand side (in canonical form: lhs &lt;= 0) into a penalty expression using the specified penalty function. The penalty is zero when the constraint is satisfied and positive when violated.</p> <p>This penalty expression becomes part of the dynamics of an augmented state. Multiple CTCS constraints in the same group (same idx) have their penalties summed: ds_aug_i/dt = sum(penalty_j) for all j in group i. By constraining s_aug_i(t) = 0 for all t, we ensure all penalties in the group are zero, which strictly enforces all constraints in the group continuously.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Sum of the penalty function applied to the constraint violation</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown penalty type is specified</p> Note <p>This method is used internally during problem compilation to create augmented state dynamics. Multiple penalty expressions with the same idx are summed together before being added to the dynamics vector via Concat.</p>"},{"location":"Usage/api_control/","title":"Control","text":"<p>Control represents control input variables (actuator commands) in a trajectory optimization problem. Unlike State variables which evolve according to dynamics, Controls are direct decision variables that the optimizer can freely adjust (within specified bounds) at each time step to influence the system dynamics.</p> <p>Controls support min/max bounds to enforce actuator limits and initial trajectory guesses to help the optimizer converge.</p>"},{"location":"Usage/api_control/#openscvx.symbolic.expr.control.Control","title":"<code>openscvx.symbolic.expr.control.Control</code>","text":"<p>               Bases: <code>Variable</code></p> <p>Control input variable for trajectory optimization problems.</p> <p>Control represents control input variables (actuator commands) in a trajectory optimization problem. Unlike State variables which evolve according to dynamics, Controls are direct decision variables that the optimizer can freely adjust (within specified bounds) at each time step to influence the system dynamics.</p> <p>Controls are conceptually similar to State variables but simpler - they don't have boundary conditions (initial/final specifications) since controls are typically not constrained at the endpoints. Like States, Controls support:</p> <ul> <li>Min/max bounds to enforce actuator limits</li> <li>Initial trajectory guesses to help the optimizer converge</li> </ul> <p>Common examples of control inputs include:</p> <ul> <li>Thrust magnitude and direction for spacecraft/rockets</li> <li>Throttle settings for engines</li> <li>Steering angles for vehicles</li> <li>Torques for robotic manipulators</li> <li>Force/acceleration commands</li> </ul> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name identifier for this control variable</p> <code>_shape</code> <code>tuple[int, ...]</code> <p>Shape of the control vector (typically 1D like (3,) for 3D thrust)</p> <code>_slice</code> <code>slice | None</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <code>ndarray | None</code> <p>Minimum bounds for each element of the control</p> <code>_max</code> <code>ndarray | None</code> <p>Maximum bounds for each element of the control</p> <code>_guess</code> <code>ndarray | None</code> <p>Initial guess for the control trajectory (n_points, n_controls)</p> Example <p>Scalar throttle control bounded [0, 1]:</p> <pre><code>throttle = Control(\"throttle\", shape=(1,))\nthrottle.min = [0.0]\nthrottle.max = [1.0]\nthrottle.guess = np.full((50, 1), 0.5)  # Start at 50% throttle\n</code></pre> <p>3D thrust vector for spacecraft:</p> <pre><code>thrust = Control(\"thrust\", shape=(3,))\nthrust.min = [-10, -10, 0]    # No downward thrust\nthrust.max = [10, 10, 50]     # Limited thrust\nthrust.guess = np.zeros((50, 3))  # Initialize with zero thrust\n</code></pre> <p>2D steering control (left/right, forward/backward):</p> <pre><code>steer = Control(\"steer\", shape=(2,))\nsteer.min = [-1, -1]\nsteer.max = [1, 1]\nsteer.guess = np.linspace([0, 0], [0, 1], 50)  # Gradual acceleration\n</code></pre>"},{"location":"Usage/api_control/#openscvx.symbolic.expr.control.Control.scaling_max","title":"<code>scaling_max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling maximum bounds for the control variables.</p> <p>Returns:</p> Type Description <p>Array of scaling maximum values for each control variable element, or None if not set.</p>"},{"location":"Usage/api_control/#openscvx.symbolic.expr.control.Control.scaling_min","title":"<code>scaling_min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling minimum bounds for the control variables.</p> <p>Returns:</p> Type Description <p>Array of scaling minimum values for each control variable element, or None if not set.</p>"},{"location":"Usage/api_control/#openscvx.symbolic.expr.control.Control.__init__","title":"<code>__init__(name, shape)</code>","text":"<p>Initialize a Control object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name identifier for the control variable</p> required <code>shape</code> <p>Shape of the control vector (typically 1D tuple like (3,))</p> required"},{"location":"Usage/api_integrators/","title":"Integrators","text":""},{"location":"Usage/api_integrators/#rk45integrator","title":"RK45Integrator","text":""},{"location":"Usage/api_integrators/#openscvx.integrators.solve_ivp_rk45","title":"<code>openscvx.integrators.solve_ivp_rk45(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, is_not_compiled: bool = False)</code>","text":"<p>Solve an initial-value ODE problem using fixed-step RK45 integration.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code>.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of output time points. Defaults to 50.</p> <code>50</code> <code>is_not_compiled</code> <code>bool</code> <p>If True, use Python loop instead of JAX <code>lax.fori_loop</code>. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Array of shape (num_substeps, state_dim) with solution at each time.</p>"},{"location":"Usage/api_integrators/#openscvx.integrators.rk45_step","title":"<code>openscvx.integrators.rk45_step(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], t: jnp.ndarray, y: jnp.ndarray, h: float, *args) -&gt; jnp.ndarray</code>","text":"<p>Perform a single RK45 (Runge-Kutta-Fehlberg) integration step.</p> <p>This implements the classic Dorman-Prince coefficients for an explicit 4(5) method, returning the fourth-order estimate.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>t</code> <code>ndarray</code> <p>Current time.</p> required <code>y</code> <code>ndarray</code> <p>Current state vector.</p> required <code>h</code> <code>float</code> <p>Step size.</p> required <code>*args</code> <p>Additional arguments passed to <code>f</code>.</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: Next state estimate at t + h.</p>"},{"location":"Usage/api_integrators/#diffrax-integrators","title":"Diffrax Integrators","text":""},{"location":"Usage/api_integrators/#openscvx.integrators.solve_ivp_diffrax","title":"<code>openscvx.integrators.solve_ivp_diffrax(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; f(t, y, *args).</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>solver_name</code> is not in SOLVER_MAP.</p>"},{"location":"Usage/api_integrators/#openscvx.integrators.solve_ivp_diffrax_prop","title":"<code>openscvx.integrators.solve_ivp_diffrax_prop(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None, save_time: jnp.ndarray = None, mask: jnp.ndarray = None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver. This function is specifically designed for use in the context of trajectory optimization and handles the nonlinear single-shot propagation of state variables in undilated time.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <code>save_time</code> <code>ndarray</code> <p>Time points at which to evaluate the solution. Must be provided for export compatibility.</p> <code>None</code> <code>mask</code> <code>ndarray</code> <p>Boolean mask for the save_time points.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:     ValueError: If <code>solver_name</code> is not in SOLVER_MAP or if save_time is not provided.</p>"},{"location":"Usage/api_state/","title":"State","text":"<p>State represents a dynamic state variable in a trajectory optimization problem. Unlike control inputs, states evolve according to dynamics constraints and can have boundary conditions specified at the initial and final time points. Like all Variables, States also support min/max bounds and initial trajectory guesses to help guide the optimization solver toward good solutions.</p>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State","title":"<code>openscvx.symbolic.expr.state.State</code>","text":"<p>               Bases: <code>Variable</code></p> <p>State variable with boundary conditions for trajectory optimization.</p> <p>State represents a dynamic state variable in a trajectory optimization problem. Unlike control inputs, states evolve according to dynamics constraints and can have boundary conditions specified at the initial and final time points. Like all Variables, States also support min/max bounds and initial trajectory guesses to help guide the optimization solver toward good solutions.</p> <p>States support four types of boundary conditions:</p> <ul> <li>fixed: State value is constrained to a specific value</li> <li>free: State value is optimized within the specified bounds</li> <li>minimize: Adds a term to the objective function to minimize the state value</li> <li>maximize: Adds a term to the objective function to maximize the state value</li> </ul> <p>Each element of a multi-dimensional state can have different boundary condition types, allowing for fine-grained control over the optimization.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name identifier for this state variable</p> <code>_shape</code> <code>tuple[int, ...]</code> <p>Shape of the state vector (typically 1D like (3,) for 3D position)</p> <code>_slice</code> <code>slice | None</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <code>ndarray | None</code> <p>Minimum bounds for state variables</p> <code>_max</code> <code>ndarray | None</code> <p>Maximum bounds for state variables</p> <code>_guess</code> <code>ndarray | None</code> <p>Initial trajectory guess</p> <code>_initial</code> <code>ndarray | None</code> <p>Initial state values with boundary condition types</p> <code>initial_type</code> <code>ndarray | None</code> <p>Array of boundary condition types for initial state</p> <code>_final</code> <code>ndarray | None</code> <p>Final state values with boundary condition types</p> <code>final_type</code> <code>ndarray | None</code> <p>Array of boundary condition types for final state</p> Example <p>Scalar time state with fixed initial time, minimize final time:</p> <pre><code>time = State(\"time\", (1,))\ntime.min = [0.0]\ntime.max = [10.0]\ntime.initial = [(\"fixed\", 0.0)]\ntime.final = [(\"minimize\", 5.0)]\n</code></pre> <p>3D position state with mixed boundary conditions:</p> <pre><code>pos = State(\"pos\", (3,))\npos.min = [0, 0, 10]\npos.max = [10, 10, 200]\npos.initial = [0, (\"free\", 1), 50]  # x fixed, y free, z fixed\npos.final = [10, (\"free\", 5), (\"maximize\", 150)]  # Maximize final altitude\n</code></pre>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State.final","title":"<code>final</code>  <code>property</code> <code>writable</code>","text":"<p>Get the final state boundary condition values.</p> <p>Returns:</p> Type Description <p>Array of final state values (regardless of boundary condition type),</p> <p>or None if not set.</p> Note <p>Use <code>final_type</code> to see the boundary condition types for each element.</p> Example <p>Get final state boundary conditions:</p> <pre><code>x = State(\"x\", (2,))\nx.final = [10, (\"minimize\", 0)]\nprint(x.final)  # [10. 0.]\nprint(x.final_type)  # ['Fix' 'Minimize']\n</code></pre>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State.initial","title":"<code>initial</code>  <code>property</code> <code>writable</code>","text":"<p>Get the initial state boundary condition values.</p> <p>Returns:</p> Type Description <p>Array of initial state values (regardless of boundary condition type),</p> <p>or None if not set.</p> Note <p>Use <code>initial_type</code> to see the boundary condition types for each element.</p> Example <p>Get initial state boundary conditions:</p> <pre><code>x = State(\"x\", (2,))\nx.initial = [0, (\"free\", 1)]\nprint(x.initial)  # [0. 1.]\nprint(x.initial_type)  # ['Fix' 'Free']\n</code></pre>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State.max","title":"<code>max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the maximum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of maximum values for each state variable element.</p> Example <p>Get upper bounds:</p> <pre><code>vel = State(\"vel\", (3,))\nvel.max = [10, 10, 5]\nprint(vel.max)  # [10. 10. 5.]\n</code></pre>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State.min","title":"<code>min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the minimum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of minimum values for each state variable element.</p> Example <p>Get lower bounds:</p> <pre><code>pos = State(\"pos\", (3,))\npos.min = [0, 0, 10]\nprint(pos.min)  # [0. 0. 10.]\n</code></pre>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State.scaling_max","title":"<code>scaling_max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling maximum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of scaling maximum values for each state variable element, or None if not set.</p>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State.scaling_min","title":"<code>scaling_min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling minimum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of scaling minimum values for each state variable element, or None if not set.</p>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State.__init__","title":"<code>__init__(name, shape)</code>","text":"<p>Initialize a State object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name identifier for the state variable</p> required <code>shape</code> <p>Shape of the state vector (typically 1D tuple)</p> required"},{"location":"Usage/api_state/#boundary-conditions","title":"Boundary Conditions","text":"<p>States support four types of boundary conditions at initial and final time points. Each element of a multi-dimensional state can have different boundary condition types. Boundary conditions are specified using either a simple number (defaults to \"fixed\") or a tuple of (type, value).</p>"},{"location":"Usage/api_state/#boundarytype-enum","title":"BoundaryType Enum","text":""},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.BoundaryType","title":"<code>openscvx.symbolic.expr.state.BoundaryType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of boundary condition types for state variables.</p> <p>This enum allows users to specify boundary conditions using plain strings while maintaining type safety internally. Boundary conditions control how the optimizer handles initial and final state values.</p> <p>Attributes:</p> Name Type Description <code>FIXED</code> <code>str</code> <p>State value is fixed to a specific value</p> <code>FREE</code> <code>str</code> <p>State value is free to be optimized within bounds</p> <code>MINIMIZE</code> <code>str</code> <p>Objective term to minimize the state value</p> <code>MAXIMIZE</code> <code>str</code> <p>Objective term to maximize the state value</p> Example <p>Can use either enum or string:</p> <pre><code>BoundaryType.FIXED\n\"fixed\"  # Equivalent\n</code></pre>"},{"location":"Usage/api_state/#boundary-condition-types","title":"Boundary Condition Types","text":"<ul> <li>fixed: State value is constrained to a specific value (use plain number or tuple <code>(\"fixed\", value)</code>)</li> <li>free: State value is optimized within bounds, initialized at the given value (use tuple <code>(\"free\", value)</code>)</li> <li>minimize: Adds objective term to minimize the state value (use tuple <code>(\"minimize\", value)</code>)</li> <li>maximize: Adds objective term to maximize the state value (use tuple <code>(\"maximize\", value)</code>)</li> </ul>"},{"location":"Usage/api_trajoptproblem/","title":"Problem","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.problem.Problem.__init__","title":"<code>openscvx.problem.Problem.__init__(dynamics: dict, constraints: List[Union[Constraint, CTCS]], states: List[State], controls: List[Control], N: int, time: Time, *, dynamics_prop: Optional[dict] = None, states_prop: Optional[List[State]] = None, algebraic_prop: Optional[dict] = None, licq_min=0.0, licq_max=0.0001, time_dilation_factor_min=0.3, time_dilation_factor_max=3.0, byof: Optional[ByofSpec] = None)</code>","text":"<p>The primary class in charge of compiling and exporting the solvers.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>dict</code> <p>Dictionary mapping state names to their dynamics expressions. Each key should be a state name, and each value should be an Expr representing the derivative of that state.</p> required <code>constraints</code> <code>List[Union[CTCSConstraint, NodalConstraint]]</code> <p>List of constraints decorated with @ctcs or @nodal</p> required <code>states</code> <code>List[State]</code> <p>List of State objects representing the state variables. May optionally include a State named \"time\" (see time parameter below).</p> required <code>controls</code> <code>List[Control]</code> <p>List of Control objects representing the control variables</p> required <code>N</code> <code>int</code> <p>Number of segments in the trajectory</p> required <code>time</code> <code>Time</code> <p>Time configuration object with initial, final, min, max. Required. If including a \"time\" state in states, the Time object will be ignored and time properties should be set on the time State object instead.</p> required <code>dynamics_prop</code> <code>dict</code> <p>Dictionary mapping EXTRA state names to their dynamics expressions for propagation. Only specify additional states beyond optimization states (e.g., {\"distance\": speed}). Do NOT duplicate optimization state dynamics here.</p> <code>None</code> <code>states_prop</code> <code>List[State]</code> <p>List of EXTRA State objects for propagation only. Only specify additional states beyond optimization states. Used with dynamics_prop.</p> <code>None</code> <code>algebraic_prop</code> <code>dict</code> <p>Dictionary mapping names to symbolic expressions for outputs evaluated (not integrated) during propagation.</p> <code>None</code> <code>licq_min</code> <p>Minimum LICQ constraint value</p> <code>0.0</code> <code>licq_max</code> <p>Maximum LICQ constraint value</p> <code>0.0001</code> <code>time_dilation_factor_min</code> <p>Minimum time dilation factor</p> <code>0.3</code> <code>time_dilation_factor_max</code> <p>Maximum time dilation factor</p> <code>3.0</code> <code>byof</code> <code>Optional[ByofSpec]</code> <p>Expert mode only. Raw JAX functions to bypass symbolic layer. See :class:<code>openscvx.expert.ByofSpec</code> for detailed documentation.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Note <p>There are two approaches for handling time: 1. Auto-create (simple): Don't include \"time\" in states, provide Time object 2. User-provided (for time-dependent constraints): Include \"time\" State in states and    in dynamics dict, don't provide Time object</p>"},{"location":"Usage/api_trajoptproblem/#scpconfig","title":"ScpConfig","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.config.ScpConfig.__init__","title":"<code>openscvx.config.ScpConfig.__init__(n: Optional[int] = None, k_max: int = 200, w_tr: float = 1.0, lam_vc: float = 1.0, ep_tr: float = 0.0001, ep_vb: float = 0.0001, ep_vc: float = 1e-08, lam_cost: float = 0.0, lam_vb: float = 0.0, uniform_time_grid: bool = False, cost_drop: int = -1, cost_relax: float = 1.0, w_tr_adapt: float = 1.0, w_tr_max: Optional[float] = None, w_tr_max_scaling_factor: Optional[float] = None)</code>","text":"<p>Configuration class for Sequential Convex Programming (SCP).</p> <p>This class defines the parameters used to configure the SCP solver. You will very likely need to modify the weights for your problem. Please refer to my guide here for more information.</p> <p>Attributes:</p> Name Type Description <code>n</code> <code>int</code> <p>The number of discretization nodes. Defaults to <code>None</code>.</p> <code>k_max</code> <code>int</code> <p>The maximum number of SCP iterations. Defaults to 200.</p> <code>w_tr</code> <code>float</code> <p>The trust region weight. Defaults to 1.0.</p> <code>lam_vc</code> <code>float</code> <p>The penalty weight for virtual control. Defaults to 1.0.</p> <code>ep_tr</code> <code>float</code> <p>The trust region convergence tolerance. Defaults to 1e-4.</p> <code>ep_vb</code> <code>float</code> <p>The boundary constraint convergence tolerance. Defaults to 1e-4.</p> <code>ep_vc</code> <code>float</code> <p>The virtual constraint convergence tolerance. Defaults to 1e-8.</p> <code>lam_cost</code> <code>float</code> <p>The weight for original cost. Defaults to 0.0.</p> <code>lam_vb</code> <code>float</code> <p>The weight for virtual buffer. This is only used if there are nonconvex nodal constraints present. Defaults to 0.0.</p> <code>uniform_time_grid</code> <code>bool</code> <p>Whether to use a uniform time grid. Defaults to <code>False</code>.</p> <code>cost_drop</code> <code>int</code> <p>The number of iterations to allow for cost stagnation before termination. Defaults to -1 (disabled).</p> <code>cost_relax</code> <code>float</code> <p>The relaxation factor for cost reduction. Defaults to 1.0.</p> <code>w_tr_adapt</code> <code>float</code> <p>The adaptation factor for the trust region weight. Defaults to 1.0.</p> <code>w_tr_max</code> <code>float</code> <p>The maximum allowable trust region weight. Defaults to <code>None</code>.</p> <code>w_tr_max_scaling_factor</code> <code>float</code> <p>The scaling factor for the maximum trust region weight. Defaults to <code>None</code>.</p>"},{"location":"Usage/api_trajoptproblem/#discretizationconfig","title":"DiscretizationConfig","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.config.DiscretizationConfig.__init__","title":"<code>openscvx.config.DiscretizationConfig.__init__(dis_type: str = 'FOH', custom_integrator: bool = False, solver: str = 'Tsit5', args: Optional[dict] = None, atol: float = 0.001, rtol: float = 1e-06)</code>","text":"<p>Configuration class for discretization settings.</p> <p>This class defines the parameters required for discretizing system dynamics.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>dis_type</code> <code>str</code> <p>The type of discretization to use (e.g., \"FOH\" for First-Order Hold). Defaults to \"FOH\".</p> <code>'FOH'</code> <code>custom_integrator</code> <code>bool</code> <p>This enables our custom fixed-step RK45 algorithm. This tends to be faster than Diffrax but unless you're going for speed, it's recommended to stick with Diffrax for robustness and other solver options. Defaults to False.</p> <code>False</code> <code>solver</code> <code>str</code> <p>Not used if custom_integrator is enabled. Any choice of solver in Diffrax is valid, please refer here, How to Choose a Solver. Defaults to \"Tsit5\".</p> <code>'Tsit5'</code> <p>Other arguments: These arguments are less frequently used, and for most purposes you shouldn't need to understand these.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Dict</code> <p>Additional arguments to pass to the solver which can be found here. Defaults to an empty dictionary.</p> <code>None</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for the solver. Defaults to 1e-3.</p> <code>0.001</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for the solver. Defaults to 1e-6.</p> <code>1e-06</code>"},{"location":"Usage/api_trajoptproblem/#propagationconfig","title":"PropagationConfig","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.config.PropagationConfig.__init__","title":"<code>openscvx.config.PropagationConfig.__init__(inter_sample: int = 30, dt: float = 0.01, solver: str = 'Dopri8', max_tau_len: int = 1000, args: Optional[dict] = None, atol: float = 0.001, rtol: float = 1e-06)</code>","text":"<p>Configuration class for propagation settings.</p> <p>This class defines the parameters required for propagating the nonlinear system dynamics using the optimal control sequence.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Other arguments: The solver should likely not be changed as it is a high accuracy 8th-order Runge-Kutta method.</p> <p>Parameters:</p> Name Type Description Default <code>inter_sample</code> <code>int</code> <p>How dense the propagation within multishot discretization should be. Defaults to 30.</p> <code>30</code> <code>dt</code> <code>float</code> <p>The time step for propagation. Defaults to 0.1.</p> <code>0.01</code> <code>solver</code> <code>str</code> <p>The numerical solver to use for propagation (e.g., \"Dopri8\"). Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>max_tau_len</code> <code>int</code> <p>The maximum length of the time vector for propagation. Defaults to 1000.</p> <code>1000</code> <code>args</code> <code>Dict</code> <p>Additional arguments to pass to the solver. Defaults to an empty dictionary.</p> <code>None</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for the solver. Defaults to 1e-3.</p> <code>0.001</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for the solver. Defaults to 1e-6.</p> <code>1e-06</code>"},{"location":"Usage/api_trajoptproblem/#simconfig","title":"SimConfig","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.config.SimConfig.__init__","title":"<code>openscvx.config.SimConfig.__init__(x: UnifiedState, x_prop: UnifiedState, u: UnifiedControl, total_time: float, save_compiled: bool = False, ctcs_node_intervals: Optional[list] = None, n_states: Optional[int] = None, n_states_prop: Optional[int] = None, n_controls: Optional[int] = None)</code>","text":"<p>Configuration class for simulation settings.</p> <p>This class defines the parameters required for simulating a trajectory optimization problem.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>State</code> <p>State object, must have .min and .max attributes for bounds.</p> required <code>x_prop</code> <code>State</code> <p>Propagation state object, must have .min and .max attributes for bounds.</p> required <code>u</code> <code>Control</code> <p>Control object, must have .min and .max attributes for bounds.</p> required <code>total_time</code> <code>float</code> <p>The total simulation time.</p> required <code>idx_x_true</code> <code>slice</code> <p>Slice for true state indices.</p> required <code>idx_x_true_prop</code> <code>slice</code> <p>Slice for true propagation state indices.</p> required <code>idx_u_true</code> <code>slice</code> <p>Slice for true control indices.</p> required <code>idx_t</code> <code>slice</code> <p>Slice for time index.</p> required <code>idx_y</code> <code>slice</code> <p>Slice for constraint violation indices.</p> required <code>idx_y_prop</code> <code>slice</code> <p>Slice for propagation constraint violation indices.</p> required <code>idx_s</code> <code>slice</code> <p>Slice for time dilation index.</p> required <code>save_compiled</code> <code>bool</code> <p>If True, save and reuse compiled solver functions. Defaults to False.</p> <code>False</code> <code>ctcs_node_intervals</code> <code>list</code> <p>Node intervals for CTCS constraints.</p> <code>None</code> <code>n_states</code> <code>int</code> <p>The number of state variables. Defaults to <code>None</code> (inferred from x.max).</p> <code>None</code> <code>n_states_prop</code> <code>int</code> <p>The number of propagation state variables. Defaults to <code>None</code> (inferred from x_prop.max).</p> <code>None</code> <code>n_controls</code> <code>int</code> <p>The number of control variables. Defaults to <code>None</code> (inferred from u.max).</p> <code>None</code> Note <p>You can specify custom scaling for specific states/controls using the <code>scaling_min</code> and <code>scaling_max</code> attributes on State, Control, and Time objects. If not set, the default min/max bounds will be used for scaling.</p>"},{"location":"Usage/api_trajoptproblem/#convexsolverconfig","title":"ConvexSolverConfig","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.config.ConvexSolverConfig.__init__","title":"<code>openscvx.config.ConvexSolverConfig.__init__(solver: str = 'QOCO', solver_args: Optional[dict] = None, cvxpygen: bool = False, cvxpygen_override: bool = False)</code>","text":"<p>Configuration class for convex solver settings.</p> <p>This class defines the parameters required for configuring a convex solver.</p> <p>These are the arguments most commonly used day-to-day. Generally I have found QOCO to be the most performant of the CVXPY solvers for these types of problems (I do have a bias as the author is from my group) and can handle up to SOCP's. CLARABEL is also a great option with feasibility checking and can handle a few more problem types. CVXPYGen is also great if your problem isn't too large. I have found qocogen to be the most performant of the CVXPYGen solvers.</p> <p>Parameters:</p> Name Type Description Default <code>solver</code> <code>str</code> <p>The name of the CVXPY solver to use. A list of options can be found here. Defaults to \"QOCO\".</p> <code>'QOCO'</code> <code>solver_args</code> <code>dict</code> <p>Ensure you are using the correct arguments for your solver as they are not all common. Additional arguments to configure the solver, such as tolerances. Defaults to {\"abstol\": 1e-6, \"reltol\": 1e-9}.</p> <code>None</code> <code>cvxpygen</code> <code>bool</code> <p>Whether to enable CVXPY code generation for the solver. Defaults to False.</p> <code>False</code>"},{"location":"Usage/api_trajoptproblem/#devconfig","title":"DevConfig","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.config.DevConfig.__init__","title":"<code>openscvx.config.DevConfig.__init__(profiling: bool = False, debug: bool = False, printing: bool = True)</code>","text":"<p>Configuration class for development settings.</p> <p>This class defines the parameters used for development and debugging purposes.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>profiling</code> <code>bool</code> <p>Whether to enable profiling for performance analysis. Defaults to False.</p> <code>False</code> <code>debug</code> <code>bool</code> <p>Disables all precompilation so you can place breakpoints and inspect values. Defaults to False.</p> <code>False</code> <code>printing</code> <code>bool</code> <p>Whether to enable printing during development. Defaults to True.</p> <code>True</code>"},{"location":"Usage/api_variable/","title":"Variable","text":""},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable","title":"<code>openscvx.symbolic.expr.variable.Variable</code>","text":"<p>               Bases: <code>Leaf</code></p> <p>Base class for decision variables in optimization problems.</p> <p>Variable represents decision variables (free parameters) in an optimization problem. These are values that the optimizer can adjust to minimize the objective function while satisfying constraints. Variables can have bounds (min/max) and initial guesses to guide the optimization process.</p> <p>Unlike Parameters (which are fixed values that can be changed between solves), Variables are optimized by the solver. In trajectory optimization, Variables typically represent discretized state or control trajectories.</p> Note <p>Variable is typically not instantiated directly. Instead, use the specialized subclasses State (for state variables with boundary conditions) or Control (for control inputs). These provide additional functionality specific to trajectory optimization.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the variable</p> <code>_shape</code> <code>tuple[int, ...]</code> <p>Shape of the variable as a tuple (typically 1D)</p> <code>_slice</code> <code>slice | None</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <code>ndarray | None</code> <p>Minimum bounds for each element of the variable</p> <code>_max</code> <code>ndarray | None</code> <p>Maximum bounds for each element of the variable</p> <code>_guess</code> <code>ndarray | None</code> <p>Initial guess for the variable trajectory (n_points, n_vars)</p> Example"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable--typically-use-state-or-control-instead-of-variable-directly","title":"Typically, use State or Control instead of Variable directly:","text":"<p>pos = openscvx.State(\"pos\", shape=(3,)) u = openscvx.Control(\"u\", shape=(2,))</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.guess","title":"<code>guess</code>  <code>property</code> <code>writable</code>","text":"<p>Get the initial guess for the variable trajectory.</p> <p>The guess provides a starting point for the optimizer. A good initial guess can significantly improve convergence speed and help avoid local minima.</p> <p>Returns:</p> Type Description <p>2D array of shape (n_points, n_vars) representing the variable trajectory</p> <p>over time, or None if no guess is provided.</p> Example <p>x = Variable(\"x\", shape=(2,))</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.guess--linear-interpolation-from-00-to-1010-over-50-points","title":"Linear interpolation from [0,0] to [10,10] over 50 points","text":"<p>x.guess = np.linspace([0, 0], [10, 10], 50) print(x.guess.shape)  # (50, 2)</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.max","title":"<code>max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the maximum bounds (upper bounds) for the variable.</p> <p>Returns:</p> Type Description <p>Array of maximum values for each element of the variable, or None if unbounded.</p> Example <p>vel = Variable(\"vel\", shape=(3,)) vel.max = [10, 10, 5] print(vel.max)  # [10., 10., 5.]</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.min","title":"<code>min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the minimum bounds (lower bounds) for the variable.</p> <p>Returns:</p> Type Description <p>Array of minimum values for each element of the variable, or None if unbounded.</p> Example <p>pos = Variable(\"pos\", shape=(3,)) pos.min = [-10, -10, 0] print(pos.min)  # [-10., -10., 0.]</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.slice","title":"<code>slice</code>  <code>property</code>","text":"<p>Get the slice indexing this variable in the unified state/control vector.</p> <p>After preprocessing, each variable is assigned a canonical position in the unified optimization vector. This property returns the slice object that extracts this variable's values from the unified vector.</p> <p>This is particularly useful for expert users working with byof (bring-your-own functions) who need to manually index into the unified x and u vectors.</p> <p>Returns:</p> Name Type Description <code>slice</code> <p>Slice object for indexing into unified vector, or None if the variable hasn't been preprocessed yet.</p> Example <p>velocity = ox.State(\"velocity\", shape=(3,))</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.slice--after-problem-construction","title":"... after Problem construction ...","text":"<p>print(velocity.slice)  # slice(2, 5) (for example)</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.slice--use-in-byof-functions","title":"Use in byof functions","text":"<p>def my_constraint(x, u, node, params):     vel = x[velocity.slice]  # Extract velocity from unified state     return jnp.sum(vel**2) - 100  # |v|^2 &lt;= 100</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.__init__","title":"<code>__init__(name, shape)</code>","text":"<p>Initialize a Variable object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name identifier for the variable</p> required <code>shape</code> <p>Shape of the variable as a tuple (typically 1D like (3,) for 3D vector)</p> required"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.append","title":"<code>append(other=None, *, min=-np.inf, max=np.inf, guess=0.0)</code>","text":"<p>Append a new dimension to this variable or merge with another variable.</p> <p>This method extends the variable's dimension by either: 1. Appending another Variable object (concatenating their dimensions) 2. Adding a single new scalar dimension with specified bounds and guess</p> <p>The bounds and guesses of both variables are concatenated appropriately.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>Another Variable object to append. If None, adds a single scalar dimension with the specified min/max/guess values.</p> <code>None</code> <code>min</code> <p>Minimum bound for the new dimension (only used if other is None). Defaults to -np.inf (unbounded below).</p> <code>-inf</code> <code>max</code> <p>Maximum bound for the new dimension (only used if other is None). Defaults to np.inf (unbounded above).</p> <code>inf</code> <code>guess</code> <p>Initial guess value for the new dimension (only used if other is None). Defaults to 0.0.</p> <code>0.0</code> Example <p>Create a 2D variable and extend it to 3D:</p> <pre><code>pos_xy = Variable(\"pos\", shape=(2,))\npos_xy.min = [-10, -10]\npos_xy.max = [10, 10]\npos_xy.append(min=0, max=100)  # Add z dimension\nprint(pos_xy.shape)  # (3,)\nprint(pos_xy.min)  # [-10., -10., 0.]\nprint(pos_xy.max)  # [10., 10., 100.]\n</code></pre> <p>Merge two variables:</p> <pre><code>pos = Variable(\"pos\", shape=(3,))\nvel = Variable(\"vel\", shape=(3,))\npos.append(vel)  # Now pos has shape (6,)\n</code></pre>"},{"location":"Usage/basic_problem_setup/","title":"Basic Problem Setup","text":"<p>Here we will cover all the necessary elements to setup your problem along with some tips and best practices to get the most out of the package.</p>"},{"location":"Usage/basic_problem_setup/#imports","title":"Imports","text":"<p>First, import OpenSCvx:</p> <pre><code>import numpy as np\nimport jax.numpy as jnp\nimport openscvx as ox\nfrom openscvx import Problem\n</code></pre>"},{"location":"Usage/basic_problem_setup/#state-specification","title":"State Specification","text":"<p>States are defined as individual symbolic variables. Each state component gets its own <code>ox.State</code> object:</p> <pre><code># Create state variables\nposition = ox.State(\"position\", shape=(3,))\nvelocity = ox.State(\"velocity\", shape=(3,))\n\n# Set bounds for each state\nposition.min = np.array([-10, -10, 0])\nposition.max = np.array([10, 10, 20])\n\nvelocity.min = np.array([-5, -5, -5])\nvelocity.max = np.array([5, 5, 5])\n\n# Set initial conditions\nposition.initial = np.array([0, 0, 1])\nvelocity.initial = np.array([0, 0, 0])\n\n# Set final conditions (can use tuples for free/minimize/maximize)\nposition.final = np.array([5, 5, 1])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Set initial guess for SCP (shape: (n_nodes, state_shape))\nposition.guess = np.linspace(position.initial, position.final, n_nodes)\nvelocity.guess = np.zeros((n_nodes, 3))\n\n# Collect all states into a list\nstates = [position, velocity]\n</code></pre> <p>The boundary condition options use tuple syntax:</p> <ul> <li>Fixed value: <code>value</code> or <code>(\"fixed\", value)</code></li> <li>Free variable: <code>(\"free\", guess)</code> - Can be optimized within bounds</li> <li>Minimize: <code>(\"minimize\", guess)</code> - Variable to be minimized</li> <li>Maximize: <code>(\"maximize\", guess)</code> - Variable to be maximized</li> </ul>"},{"location":"Usage/basic_problem_setup/#control-specification","title":"Control Specification","text":"<p>Controls are also defined as individual symbolic variables:</p> <pre><code># Create control variables\nthrust = ox.Control(\"thrust\", shape=(3,))\n\n# Set bounds\nthrust.min = np.array([0, 0, 0])\nthrust.max = np.array([10, 10, 10])\n\n# Set initial guess for SCP (shape: (n_nodes, control_shape))\nthrust.guess = np.repeat(\n    np.expand_dims(np.array([0, 0, 5]), axis=0),\n    n_nodes, axis=0\n)\n\n# Collect all controls into a list\ncontrols = [thrust]\n</code></pre>"},{"location":"Usage/basic_problem_setup/#dynamics","title":"Dynamics","text":"<p>Dynamics are defined as a dictionary mapping state names to their time derivatives using symbolic expressions:</p> <pre><code># Physical parameters\nm = 1.0  # Mass\ng = -9.81  # Gravity\n\n# Define dynamics using symbolic expressions\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": thrust / m + np.array([0, 0, g]),\n}\n</code></pre> <p>The symbolic expressions support standard Python operators: - Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code> - Matrix multiplication: <code>@</code> - Comparisons: <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code> - Indexing: <code>[...]</code> - Transpose: <code>.T</code></p> <p>Common symbolic functions include: - <code>ox.linalg.Norm()</code>: Vector/matrix norms - <code>ox.linalg.Diag()</code>: Diagonal matrices - <code>ox.spatial.QDCM()</code>: Quaternion to DCM - <code>ox.spatial.SSM()</code>: Skew-symmetric matrix - <code>ox.spatial.SSMP()</code>: Skew-symmetric matrix product</p> <p>Note</p> <p>Under the hood, symbolic expressions are compiled using JAX, so use <code>jax.numpy</code> for numerical constants and functions when needed.</p>"},{"location":"Usage/basic_problem_setup/#time-definition","title":"Time Definition","text":"<p>Define a <code>Time</code> object:</p> <pre><code># Fixed time horizon\ntime = ox.Time(\n    initial=0.0,\n    final=10.0,\n    min=0.0,\n    max=10.0,\n)\n\n# Minimum time problem\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", 10.0),  # Minimize final time with initial guess of 10.0\n    min=0.0,\n    max=20.0,\n)\n</code></pre>"},{"location":"Usage/basic_problem_setup/#costs","title":"Costs","text":"<p>You can choose states to minimize or maximize using the tuple syntax in boundary conditions:</p> <pre><code># Minimize a state component at the final time\nenergy = ox.State(\"energy\", shape=())\nenergy.final = (\"minimize\", 0.0)\n\n# Maximize a state component\nreward = ox.State(\"reward\", shape=())\nreward.final = (\"maximize\", 100.0)\n</code></pre>"},{"location":"Usage/basic_problem_setup/#constraints","title":"Constraints","text":"<p>Constraints are created using symbolic expressions with comparison operators.</p>"},{"location":"Usage/basic_problem_setup/#continuous-constraints","title":"Continuous Constraints","text":"<p>Continuous constraints are enforced over time intervals using <code>ox.ctcs()</code>:</p> <pre><code># Box constraints on states\nconstraints = []\nfor state in states:\n    constraints.extend([\n        ox.ctcs(state &lt;= state.max),\n        ox.ctcs(state.min &lt;= state)\n    ])\n\n# Custom path constraints\nmax_speed = 10.0\nconstraints.append(ox.ctcs(ox.linalg.Norm(velocity) &lt;= max_speed))\n\n# Obstacle avoidance (distance &gt;= safe_distance)\nobstacle_center = ox.Parameter(\"obs_center\", shape=(3,), value=np.array([5, 5, 5]))\nsafe_distance = 2.0\ndiff = position - obstacle_center\nconstraints.append(ox.ctcs(diff.T @ diff &gt;= safe_distance**2))\n</code></pre>"},{"location":"Usage/basic_problem_setup/#discrete-constraints","title":"Discrete Constraints","text":"<p>Discrete constraints are enforced at specific nodes using the <code>.at()</code> method:</p> <pre><code># Waypoint constraint at node 10\ntarget = np.array([5, 5, 5])\nconstraints.append(\n    (position == target).at([10])\n)\n\n# Constraint at multiple nodes\nconstraints.append(\n    (ox.linalg.Norm(velocity) &lt;= 1.0).at([0, 5, 10])\n)\n\n# Convex constraints can be marked for better performance\nconstraints.append(\n    (position[2] &gt;= 0).convex().at([15])\n)\n</code></pre>"},{"location":"Usage/basic_problem_setup/#parameters","title":"Parameters","text":"<p>Parameters allow values to be updated at runtime without recompiling:</p> <pre><code># Create parameters\nobs_center = ox.Parameter(\"obs_center\", shape=(3,), value=np.array([1.0, 2.0, 3.0]))\nobs_radius = ox.Parameter(\"obs_radius\", shape=(), value=0.5)\n\n# Use in constraints\ndiff = position - obs_center\nconstraints.append(\n    ox.ctcs(diff.T @ diff &gt;= obs_radius**2)\n)\n\n# Update parameter values later\n# problem.parameters[\"obs_center\"] = new_center_value\n</code></pre>"},{"location":"Usage/basic_problem_setup/#initial-guess","title":"Initial Guess","text":"<p>While not strictly necessary for the initial guess to be dynamically feasible or satisfy constraints, a good guess helps the solver converge faster and avoid local minima.</p> <p>For state trajectories, linear interpolation is a good starting point:</p> <pre><code>position.guess = np.linspace(position.initial, position.final, n_nodes)\nvelocity.guess = np.zeros((n_nodes, 3))\n</code></pre> <p>For control trajectories, use constant values:</p> <pre><code>thrust.guess = np.repeat(\n    np.expand_dims(np.array([0, 0, 5]), axis=0),\n    n_nodes, axis=0\n)\n</code></pre>"},{"location":"Usage/basic_problem_setup/#problem-instantiation","title":"Problem Instantiation","text":"<p>Instantiate the problem with all components:</p> <pre><code>problem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n_nodes,\n)\n</code></pre>"},{"location":"Usage/basic_problem_setup/#configure-scp-weights","title":"Configure SCP Weights","text":"<p>The weights are used to scale the cost, trust region, and dynamic feasibility. A good place to start is to set <code>lam_cost = 0</code>, <code>lam_vc = 1E1</code> and <code>w_tr = 1E0</code>. Then you can slowly increase the cost weight and decrease the trust region weight until you find a good balance.</p> <pre><code>problem.settings.scp.w_tr = 1E0      # Weight on the Trust Region\nproblem.settings.scp.lam_cost = 0E0  # Weight on the Cost\nproblem.settings.scp.lam_vc = 1E1    # Weight on the Virtual Control Objective\n</code></pre> <p>If you have nonconvex nodal constraints then you will also need to include <code>problem.settings.scp.lam_vb = 1E0</code>.</p>"},{"location":"Usage/basic_problem_setup/#running-the-problem","title":"Running the Problem","text":"<p>To solve the trajectory optimization problem:</p> <ol> <li> <p>Initialize the problem:    <pre><code>problem.initialize()\n</code></pre></p> </li> <li> <p>Solve the problem:    <pre><code>results = problem.solve()\n</code></pre></p> </li> <li> <p>Post-process the solution:    <pre><code>results = problem.post_process(results)\n</code></pre></p> </li> <li> <p>Access the solution:    <pre><code># Extract state and control trajectories\nposition_trajectory = results[\"position\"]\nvelocity_trajectory = results[\"velocity\"]\nthrust_trajectory = results[\"thrust\"]\ntime_vector = results[\"time\"]\n</code></pre></p> </li> </ol>"},{"location":"Usage/tutorial_6dof_los_guidance/","title":"6DoF Line-of-Sight Guidance","text":"<p>Awesome! Now that we have a basic understanding of how to use OpenSCvx, let's solve a more complex problem. In this example we will be solving a 6DoF line-of-sight guidance problem. This example comes from a RA-L paper of mine which you can find here. The problem is more complex than the previous example, but demonstrates the power of OpenSCvx's symbolic expression layer.</p> <p>In this problem, it is still a minimum time problem, but now there are 10 gates in which the drone must pass through in a predefined sequence while maintaining a line-of-sight to several key points throughout the entire trajectory. The problem can be expressed as follows:</p> \\[ \\begin{align} \\min_{x,u, t}\\ &amp;t_f, \\\\ \\mathrm{s.t.}\\ &amp;\\dot{x}(t) = f(t, x(t),u(t)) &amp; \\forall t\\in[t_i, t_f], \\\\ &amp; \\lVert A_{\\mathrm{cone}} C(q_{\\mathcal{S}\\to\\mathcal{B}})C(q_{\\mathcal{B}\\to\\mathcal{I}}(t))(r^{\\mathrm{kp},i}_{\\mathcal{I}} - r_{\\mathcal{I}}(t))\\rVert_\\rho - c^\\top C(q_{\\mathcal{S}\\to\\mathcal{B}})C(q_{\\mathcal{B}\\to\\mathcal{I}}(t))(r^{\\mathrm{kp}, i}_{\\mathcal{I}} - r_{\\mathcal{I}}(t)) \\leq 0 &amp; \\forall i \\in [0, N_\\mathrm{kp}], \\forall t\\in[t_i, t_f],\\\\ &amp; \\lVert A_{\\mathrm{gate}} (r(t_i) - r^{i}_{\\mathrm{gate}})\\rVert_\\infty \\leq 1 &amp; \\forall i\\in[0, N_\\mathrm{gates}],\\\\ &amp; x(t) \\leq x_{\\mathrm{max}}, x(t) \\geq x_{\\mathrm{min}} &amp; \\forall t\\in[t_i, t_f],\\\\ &amp; u(t) \\leq u_{\\mathrm{max}}, u(t) \\geq u_{\\mathrm{min}} &amp; \\forall t\\in[t_i, t_f],\\\\ &amp; x(0) = x_\\mathrm{init}, \\\\ &amp; p(t_f) = p_\\mathrm{terminal}, \\\\ \\end{align} \\] <p>where the state vector is the same as before, \\(x = \\begin{bmatrix} p^\\top &amp; v^\\top &amp; q^\\top &amp; w^\\top \\end{bmatrix}^\\top\\). The control vector is also quite famaliar, \\(u = \\begin{bmatrix}f^\\top &amp; \\tau^\\top \\end{bmatrix}^\\top\\). The function \\(f(t, x(t),u(t))\\) describes the dynamics of the drone. </p>"},{"location":"Usage/tutorial_6dof_los_guidance/#los-contraint-formulation","title":"LoS Contraint Formulation","text":"<p>The constraints are where things get a little more interesting. First we have the line of sight (LoS) constraint. I find it easiest to internally break it down into the following two components,</p> <ol> <li> <p>A transformation component which take the location of a keypoint in the inertial frame, \\(r^{\\mathrm{kp},i}_{\\mathcal{I}}\\), and expresses it in the sensor frame, \\(r^{\\mathrm{kp},i}_{\\mathcal{S}}\\), as follows,</p> \\[ r^{\\mathrm{kp},i}_{\\mathcal{S}} = C(q_{\\mathcal{S}\\to\\mathcal{B}})C(q_{\\mathcal{B}\\to\\mathcal{I}}(t))(r^{\\mathrm{kp},i}_{\\mathcal{I}} - r_{\\mathcal{I}}(t))\\] </li> <li> <p>A norm cone component expressed as follows,</p> \\[\\lVert A_{\\mathrm{C}} r^{\\mathrm{kp},i}_{\\mathcal{S}}\\rVert_\\rho \\leq c^\\top r^{\\mathrm{kp},i}_{\\mathcal{S}}\\] </li> </ol> <p>The long expression for the LoS constraint is obtained by simply plugging the first expression into the second. </p>"},{"location":"Usage/tutorial_6dof_los_guidance/#gate-constraint-formulation","title":"Gate Constraint Formulation","text":"<p>The gate constraints are a little more straightforward and are notably convex.</p> \\[\\lVert A_{\\mathrm{gate}} (r(t_i) - r^{i}_{\\mathrm{gate}})\\rVert_\\infty \\leq 1\\] <p>The gate itself is assumed to be square, hence the \\(\\infty\\)-norm but the user could certinaly choose a different norm. The only complication is that they are not path constraints, meaning I only want to enforce them at one single time instant as opposed to the entire trajecory and to make matters worse, the time instant is not known a priori. One could fix this but that would very likely lead to non-optimal solutions with respect to minimum time. </p>"},{"location":"Usage/tutorial_6dof_los_guidance/#imports","title":"Imports","text":"<p>You'll need to import a few libraries to get started. The following code will import the necessary libraries for the example:</p> <pre><code>import numpy as np\nimport numpy.linalg as la\nimport jax.numpy as jnp\n\nimport openscvx as ox\nfrom openscvx import Problem\nfrom openscvx.utils import rot, gen_vertices\n</code></pre> <p>Note how we import <code>openscvx as ox</code> - this gives us access to the symbolic expression system including <code>ox.State</code>, <code>ox.Control</code>, <code>ox.Parameter</code>, and symbolic operations.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#problem-definition","title":"Problem Definition","text":"<p>Lets first define the number of discretization nodes and an initial guess for ToF.</p> <pre><code>n = 33            # Number of discretization nodes\ntotal_time = 40.0 # Initial ToF Guess for the simulation\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#state-definition","title":"State Definition","text":"<p>With the new symbolic expression layer, we define each state component separately as a symbolic variable. Each state can have bounds, initial conditions, and final conditions specified as attributes.</p> <pre><code># Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 100, 50])\nposition.min = np.array([-200.0, -100, 15])\nposition.initial = np.array([10.0, 0, 20])\nposition.final = [10.0, 0, 20]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Collect all states into a list\nstates = [position, velocity, attitude, angular_velocity]\n</code></pre> <p>The <code>(\"free\", value)</code> tuple syntax indicates that a boundary condition is not fixed - the optimizer is free to choose the value, with <code>value</code> serving as an initial guess.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#control-definition","title":"Control Definition","text":"<p>Similar to states, we define control components as symbolic variables:</p> <pre><code># Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\nthrust_force.guess = np.repeat(np.array([[0.0, 0, 10]]), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n# Collect all controls into a list\ncontrols = [thrust_force, torque]\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#problem-parameters","title":"Problem Parameters","text":"<p>We will need to define a few parameters to describe the gates, sensor and keypoints for the problem.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#sensor-paramters","title":"Sensor Paramters","text":"<p>Here we define the parameters we'll use to model the sensor with as follows,</p> <pre><code>alpha_x = 6.0                                        # Angle for the x-axis of Sensor Cone\nalpha_y = 6.0                                        # Angle for the y-axis of Sensor Cone\nA_cone = np.diag([1 / np.tan(np.pi / alpha_x),\n                  1 / np.tan(np.pi / alpha_y),\n                  0,])                               # Conic Matrix in Sensor Frame\nc = jnp.array([0, 0, 1])                             # Boresight Vector in Sensor Frame\nnorm_type = 2                                        # Norm Type\nR_sb = jnp.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])  # Rotation Matrix from Sensor to Body Frame\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#gate-parameters","title":"Gate Parameters","text":"<p>Here we define the parameters we'll use to model the gates with as follows,</p> <pre><code>def gen_vertices(center, radii):\n    \"\"\"\n    Obtains the vertices of the gate.\n    \"\"\"\n    vertices = []\n    vertices.append(center + rot @ [radii[0], 0, radii[2]])\n    vertices.append(center + rot @ [-radii[0], 0, radii[2]])\n    vertices.append(center + rot @ [-radii[0], 0, -radii[2]])\n    vertices.append(center + rot @ [radii[0], 0, -radii[2]])\n    return vertices\n\n\nn_gates = 10                              # Number of gates\ngate_centers = [                          # Center of the gates\n    np.array([ 59.436,  0.0000, 20.0000]),\n    np.array([ 92.964, -23.750, 25.5240]),\n    np.array([ 92.964, -29.274, 20.0000]),\n    np.array([ 92.964, -23.750, 20.0000]),\n    np.array([130.150, -23.750, 20.0000]),\n    np.array([152.400, -73.152, 20.0000]),\n    np.array([ 92.964, -75.080, 20.0000]),\n    np.array([ 92.964, -68.556, 20.0000]),\n    np.array([ 59.436, -81.358, 20.0000]),\n    np.array([ 22.250, -42.672, 20.0000]),\n]\n\nradii = np.array([2.5, 1e-4, 2.5])                 # Radii of the gates\nA_gate = rot @ np.diag(1 / radii) @ rot.T\nA_gate_cen = []\nfor center in gate_centers:\n    center[0] = center[0] + 2.5\n    center[2] = center[2] + 2.5\n    A_gate_cen.append(A_gate @ center)             # Premultiplying A_gate @ center to ensure OCP is DPP compliant\nn_per_gate = 3                                     # Number of nodes between each gate\ngate_nodes = np.arange(n_per_gate, n, n_per_gate)  # Which node to enforce the gate constraint\nvertices = []\nfor center in gate_centers:\n    vertices.append(gen_vertices(center, radii))\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#keypoint-parameters","title":"Keypoint Parameters","text":"<p>We can randomly generate some keypoints for the drone to observe. The keypoints are assumed to be in the inertial frame and can be generated as follows,</p> <pre><code>n_subs = 10                          # Number of keypoints\ninit_poses = []\nnp.random.seed(0)\nfor i in range(n_subs):\n    init_pose = np.array([100.0, -60.0, 20.0])\n    init_pose[:2] = init_pose[:2] + np.random.random(2) * 20.0\n    init_poses.append(init_pose)\n\ninit_poses = init_poses\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#dynamics","title":"Dynamics","text":"<p>With the symbolic expression layer, we can define dynamics using natural mathematical notation. The dynamics are expressed as a dictionary mapping state names to their time derivatives as symbolic expressions:</p> <pre><code># Physical parameters\nm = 1.0  # Mass of the drone\ng_const = -9.18  # Gravity constant\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of inertia\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n                + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv) @ (\n        torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity\n    ),\n}\n</code></pre> <p>The symbolic expressions use: - <code>ox.linalg.Norm()</code>: Compute vector norms - <code>ox.linalg.Diag()</code>: Create diagonal matrices - <code>ox.spatial.QDCM()</code>: Quaternion to direction cosine matrix - <code>ox.spatial.SSMP()</code>: Skew-symmetric matrix product - <code>ox.spatial.SSM()</code>: Skew-symmetric matrix - Standard operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>@</code> (matrix multiplication) </p>"},{"location":"Usage/tutorial_6dof_los_guidance/#constraints","title":"Constraints","text":"<p>In this problem, we have both continuous constraints (enforced over intervals) and discrete constraints (enforced at specific nodes). The symbolic expression layer makes constraint definition intuitive and readable.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#continuous-constraints","title":"Continuous Constraints","text":"<p>First, we define a symbolic function for the line-of-sight (LoS) constraint:</p> <pre><code>def g_vp(p_s_I, x_pos, x_quat):\n    \"\"\"Symbolic sensor visibility constraint function.\"\"\"\n    p_s_s = R_sb @ ox.spatial.QDCM(x_quat).T @ (p_s_I - x_pos)\n    return ox.linalg.Norm(A_cone @ p_s_s, ord=norm_type) - (c.T @ p_s_s)\n</code></pre> <p>Now we can create constraints using symbolic expressions and the convenient <code>ox.ctcs()</code> wrapper:</p> <pre><code>constraints = []\n\n# Add box constraints for all states\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add visibility constraints using symbolic expressions\nfor pose in init_poses:\n    constraints.append(ox.ctcs(g_vp(pose, position, attitude) &lt;= 0.0))\n</code></pre> <p>The <code>ox.ctcs()</code> function wraps a symbolic constraint expression and applies Continuous-Time Constraint Satisfaction (CTCS), which handles path constraints that must be satisfied over continuous intervals.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#discrete-constraints","title":"Discrete Constraints","text":"<p>Gate constraints are only enforced at specific nodes in the trajectory. We use the <code>.at()</code> method to specify which nodes:</p> <pre><code># Add gate constraints using symbolic expressions\nfor node, cen in zip(gate_nodes, A_gate_cen):\n    A_gate_const = A_gate\n    cen_const = cen\n\n    # Gate constraint: ||A @ pos - c||_inf &lt;= 1\n    gate_constraint = (\n        (ox.linalg.Norm(A_gate_const @ position - cen_const, ord=\"inf\") &lt;= 1.0)\n        .convex()\n        .at([node])\n    )\n    constraints.append(gate_constraint)\n</code></pre> <p>The <code>.convex()</code> method marks the constraint as convex for the solver, and <code>.at([node])</code> specifies that this constraint is only enforced at a specific discrete node.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#initial-guess","title":"Initial Guess","text":"<p>For complex problems, we need a sophisticated initial guess. We interpolate positions through each gate and compute attitudes to point the sensor at the keypoints:</p> <pre><code># Initialize position guess - linear interpolation through gates\nposition_bar = np.linspace(position.initial, position.final, n)\ni = 0\norigins = [position.initial]\nends = []\nfor center in gate_centers:\n    origins.append(center)\n    ends.append(center)\nends.append(position.final)\ngate_idx = 0\nfor _ in range(n_gates + 1):\n    for k in range(n // (n_gates + 1)):\n        position_bar[i] = origins[gate_idx] + (k / (n // (n_gates + 1))) * (\n            ends[gate_idx] - origins[gate_idx]\n        )\n        i += 1\n    gate_idx += 1\n\n# Modify attitude to point sensor at targets\nR_sb = jnp.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\nb = R_sb @ np.array([0, 1, 0])\nattitude_bar = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\n\nfor k in range(n):\n    # Average keypoint positions\n    kp = np.mean(init_poses, axis=0)\n    a = kp - position_bar[k]\n\n    # Compute quaternion to align sensor with relative position vector\n    q_xyz = np.cross(b, a)\n    q_w = np.sqrt(la.norm(a) ** 2 + la.norm(b) ** 2) + np.dot(a, b)\n    q_no_norm = np.hstack((q_w, q_xyz))\n    q = q_no_norm / la.norm(q_no_norm)\n    attitude_bar[k] = q\n\n# Set all guesses\nposition.guess = position_bar\nvelocity.guess = np.zeros((n, 3))\nattitude.guess = attitude_bar\nangular_velocity.guess = np.zeros((n, 3))\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#time-definition","title":"Time Definition","text":"<p>For minimum-time problems, we define a <code>Time</code> object:</p> <pre><code>time = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),  # Minimize final time with initial guess\n    min=0.0,\n    max=total_time,\n)\n</code></pre> <p>The <code>(\"minimize\", total_time)</code> tuple indicates that final time is a decision variable to be minimized, with <code>total_time</code> as the initial guess.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#problem-instantiation","title":"Problem Instantiation","text":"<p>Now we instantiate the <code>Problem</code> with our symbolic expressions:</p> <pre><code>problem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#additional-parameters","title":"Additional Parameters","text":"<p>We can define the PTR weights and other parameters as follows.</p> <p>Tip</p> <p>Tuning is probably one of the hardest things to do when working with these type of algorithms. There are some approaches to automate this process (which will soon be included in OpenSCvx once they are published). A good place to start is to set <code>lam_cost = 0</code>, <code>lam_vc = 1E1</code> and <code>w_tr = 1E0</code>. Then you can slowly increase the cost weight and decrease the trust region weight until you find a good balance.</p> <pre><code>problem.settings.scp.w_tr = 2e0                     # Weight on the Trust Reigon\nproblem.settings.scp.lam_cost = 1e-1                # Weight on the Cost\nproblem.settings.scp.lam_vc = 1e1                   # Weight on the Virtual Control\nproblem.settings.scp.ep_tr = 1e-3                   # Trust Region Tolerance\nproblem.settings.scp.ep_vc = 1e-8                   # Virtual Control Tolerance\nproblem.settings.scp.cost_drop = 10                 # SCP iteration to relax cost weight\nproblem.settings.scp.cost_relax = 0.8               # Minimal Time Relaxation Factor\nproblem.settings.scp.w_tr_adapt = 1.4               # Trust Region Adaptation Factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e2  # Maximum Trust Region Weight\n</code></pre> <p>Let's also set some propagation parameters:</p> <pre><code>problem.settings.prp.dt = 0.1  # Time step of the nonlinear propagation\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#plotting","title":"Plotting","text":"<p>We generally leave plotting up to users as it's application-specific. Here we package relevant information into a dictionary for later visualization:</p> <pre><code>plotting_dict = {\n    \"vertices\": vertices,\n    \"n_subs\": n_subs,\n    \"alpha_x\": alpha_x,\n    \"alpha_y\": alpha_y,\n    \"R_sb\": R_sb,\n    \"init_poses\": init_poses,\n    \"norm_type\": norm_type,\n}\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#running-the-simulation","title":"Running the Simulation","text":"<p>To run the simulation, follow these steps:</p> <ol> <li> <p>Initialize the problem:    <pre><code>problem.initialize()\n</code></pre></p> </li> <li> <p>Solve the problem:    <pre><code>results = problem.solve()\n</code></pre></p> </li> <li> <p>Post-process the solution for verification and plotting:    <pre><code>results = problem.post_process(results)\nresults.update(plotting_dict)\n</code></pre></p> </li> <li> <p>Visualize the results:    <pre><code>from examples.plotting import plot_animation\nplot_animation(results, problem.settings).show()\n</code></pre></p> </li> </ol>"},{"location":"Usage/tutorial_6dof_los_guidance/#key-takeaways","title":"Key Takeaways","text":"<p>This example demonstrates the power of OpenSCvx's symbolic expression layer:</p> <ol> <li> <p>Declarative Problem Definition: States, controls, and dynamics are defined using natural mathematical notation with symbolic expressions.</p> </li> <li> <p>Operator Overloading: Standard Python operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>@</code>, <code>&lt;=</code>, <code>==</code>) work directly on symbolic expressions, making code readable and intuitive.</p> </li> <li> <p>Automatic Differentiation: The symbolic layer automatically handles differentiation during compilation to solver-specific formats.</p> </li> <li> <p>Flexible Constraint Specification: Continuous constraints use <code>ox.ctcs()</code>, while discrete constraints use <code>.at([nodes])</code> - both work seamlessly with symbolic expressions.</p> </li> <li> <p>Shape Safety: The expression system validates tensor dimensions before optimization, catching errors early.</p> </li> </ol>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/","title":"6DoF Obstacle Avoidance","text":"<p>This example demonstrates how to use OpenSCvx to solve a trajectory optimization problem in which a drone will navigate around obstacles to fly from point A to point B in minimum time. We will solve this problem in 6DoF, meaning there is 6 degrees of freedom in the problem, mainly 3 translational and 3 rotational degrees. Mathematically we can express this problem as the following,</p> \\[ \\begin{align} \\min_{x,u, t}\\ &amp;t_f, \\\\ \\mathrm{s.t.}\\ &amp;\\dot{x}(t) = f(t, x(t),u(t)) &amp; \\forall t\\in[t_i, t_f], \\\\ &amp; 1- (p(t) - p^i_{\\mathrm{obs}})^\\top A^i_\\mathrm{obs} (r(t) - r^i_{\\mathrm{obs}}) \\leq 0  &amp; \\forall t\\in[t_i, t_f], \\forall i\\in[0, N_\\mathrm{obs}],\\\\ &amp; x(t) \\leq x_{\\mathrm{max}}, x(t) \\geq x_{\\mathrm{min}} &amp; \\forall t\\in[t_i, t_f],\\\\ &amp; u(t) \\leq u_{\\mathrm{max}}, u(t) \\geq u_{\\mathrm{min}} &amp; \\forall t\\in[t_i, t_f],\\\\ &amp; x(0) = x_\\mathrm{init}, \\\\ &amp; p(t_f) = p_\\mathrm{terminal}, \\\\ \\end{align} \\] <p>where the state vector \\(x\\) is expressed as  \\(x = \\begin{bmatrix} r^\\top &amp; v^\\top &amp; q^\\top &amp; w^\\top \\end{bmatrix}^\\top\\). \\(p\\) denotes the position of the drone, \\(v\\) is the velocity, \\(q\\) is the quaternion, \\(w\\) is the angular velocity. The control vector \\(u\\) is expressed as \\(u = \\begin{bmatrix}f^\\top &amp; \\tau^\\top \\end{bmatrix}^\\top\\). Here \\(f\\) is the force in the body frame and \\(\\tau\\) is the torque of the body frame relative to the inertial frame. The function \\(f(t, x(t),u(t))\\) describes the dynamics of the drone. The term \\(1- (r(t) - r^i_{\\mathrm{obs}})^\\top A^i_\\mathrm{obs} (r(t) - r^i_{\\mathrm{obs}})\\) describes the obstacle avoidance constraints for \\(N_\\mathrm{obs}\\) number of obstacles, where \\(A_\\mathrm{obs}\\) is a positive definite matrix that describes the shape of the obstacle.</p>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#imports","title":"Imports","text":"<p>You'll need to import a few libraries to get started:</p> <pre><code>import numpy as np\nimport jax.numpy as jnp\n\nimport openscvx as ox\nfrom openscvx import Problem\nfrom openscvx.utils import generate_orthogonal_unit_vectors\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#problem-definition","title":"Problem Definition","text":"<p>Lets first define the number of discretization nodes and an initial guess for ToF.</p> <pre><code>n = 6             # Number of discretization nodes\ntotal_time = 4.0  # Initial ToF Guess for the simulation\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#state-definition","title":"State Definition","text":"<p>We define each state component separately as a symbolic variable:</p> <pre><code># Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 10, 20])\nposition.min = np.array([-200.0, -100, 0])\nposition.initial = np.array([10.0, 0, 2])\nposition.final = [-10.0, 0, 2]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Collect all states into a list\nstates = [position, velocity, attitude, angular_velocity]\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#control-definition","title":"Control Definition","text":"<p>Similarly, we define control components as symbolic variables:</p> <pre><code># Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\ninitial_control = np.array([0.0, 0.0, thrust_force.max[2]])\nthrust_force.guess = np.repeat(np.expand_dims(initial_control, axis=0), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n# Collect all controls into a list\ncontrols = [thrust_force, torque]\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#dynamics","title":"Dynamics","text":"<p>To describe the dynamics of the drone, lets first introduce some notation to describe in what frame quantities are being represented in. A quantity expressed in the frame \\(\\mathcal{A}\\) is denoted by the subscript \\(\\Box_{\\mathcal{A}}\\). To parameterize the attitude of frame \\(\\mathcal{B}\\) with respect to frame \\(\\mathcal{A}\\), the unit quaternion, \\(q_{\\mathcal{A} \\to \\mathcal{B}} \\in \\mathcal{S}^3\\) where \\(\\mathcal{S}^3\\subset\\mathbb{R}^4\\) is the unit 3-sphere, is used. Here the inertial and body frames are denoted by \\(\\mathcal{I}\\) and \\(\\mathcal{B}\\) respectively. The dynamics of the drone can be expressed as follows:</p> \\[ \\begin{align*}     % \\label{eq:6dof_def}     &amp; \\dot{r}_\\mathcal{I}(t) = v_\\mathcal{I}(t),\\\\     &amp; \\dot{v}_\\mathcal{I}(t) = \\frac{1}{m}\\left(C(q_{\\mathcal{B \\to I}}(t)) f_{ \\mathcal{B}}(t)\\right) + g_{\\mathcal{I}},\\\\     &amp; \\dot{q}_{\\mathcal{I}\\to \\mathcal{B}} = \\frac{1}{2} \\Omega(\\omega_\\mathcal{B}(t))  q_{\\mathcal{I \\to B}}(t),\\\\     &amp; \\dot{\\omega}_\\mathcal{B}(t) =  J_{\\mathcal{B}}^{-1} \\left(M_{\\mathcal{B}}(t) - \\left[\\omega_\\mathcal{B}(t)\\times\\right]J_{\\mathcal{B}} \\omega_\\mathcal{B}(t) \\right), \\end{align*}  \\] <p>where the operator \\(C:\\mathcal{S}^3\\mapsto SO(3)\\) represents the direction cosine matrix (DCM), where \\(SO(3)\\) denotes the special orthogonal group.</p> <p>For a vector \\(\\xi \\in \\mathbb{R}^3\\), the skew-symmetric operators \\(\\Omega(\\xi)\\) and \\([\\xi \\times]\\) are defined as follows:</p> \\[ \\begin{align} [\\xi \\times] = \\begin{bmatrix} 0 &amp; -\\xi_3 &amp; \\xi_2 \\\\ \\xi_2 &amp; 0 &amp; -\\xi_1 \\\\ -\\xi_2 &amp; \\xi_1 &amp; 0 \\end{bmatrix}, \\ \\Omega(\\xi) = \\begin{bmatrix} 0 &amp; -\\xi_1 &amp; \\xi_2 &amp; \\xi_3 \\\\ \\xi_1 &amp; 0 &amp; \\xi_3 &amp; -\\xi_2 \\\\ \\xi_2 &amp; -\\xi_3 &amp; 0 &amp; \\xi_1 \\\\ \\xi_3 &amp; \\xi_2 &amp; -\\xi_1 &amp; 0 \\end{bmatrix} \\end{align} \\] <p>OpenSCvx provides symbolic functions for these operations. We can express the dynamics as a dictionary mapping state names to their derivatives:</p> <pre><code># Physical parameters\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of inertia\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n                + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv) @ (\n        torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity\n    ),\n}\n</code></pre> <p>The symbolic functions used here are: - <code>ox.linalg.Norm()</code>: Compute vector norms - <code>ox.linalg.Diag()</code>: Create diagonal matrices - <code>ox.spatial.QDCM()</code>: Quaternion to direction cosine matrix (DCM) - <code>ox.spatial.SSMP()</code>: Skew-symmetric matrix product \\(\\Omega(\\xi)\\) - <code>ox.spatial.SSM()</code>: Skew-symmetric matrix \\([\\xi \\times]\\)</p>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#constraints","title":"Constraints","text":"<p>First, let's define the obstacle parameters. We'll use ellipsoidal obstacles parameterized by positive definite matrices:</p> <pre><code>A_obs = []\nradius = []\naxes = []\n\n# Default values for the obstacle centers\nobstacle_center_positions = [\n    np.array([-5.1, 0.1, 2]),\n    np.array([0.1, 0.1, 2]),\n    np.array([5.1, 0.1, 2]),\n]\n\n# Define obstacle centers as parameters for runtime updates\nobstacle_centers = [\n    ox.Parameter(\"obstacle_center_1\", shape=(3,), value=obstacle_center_positions[0]),\n    ox.Parameter(\"obstacle_center_2\", shape=(3,), value=obstacle_center_positions[1]),\n    ox.Parameter(\"obstacle_center_3\", shape=(3,), value=obstacle_center_positions[2]),\n]\n\n# Randomly generate obstacle shapes\nnp.random.seed(0)\nfor _ in obstacle_center_positions:\n    ax = generate_orthogonal_unit_vectors()\n    axes.append(generate_orthogonal_unit_vectors())\n    rad = np.random.rand(3) + 0.1 * np.ones(3)\n    radius.append(rad)\n    A_obs.append(ax @ np.diag(rad**2) @ ax.T)\n</code></pre> <p>Now we can create constraints using symbolic expressions:</p> <pre><code># Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add obstacle constraints using symbolic expressions\nfor center, A in zip(obstacle_centers, A_obs):\n    A_const = A\n\n    # Obstacle constraint: (pos - center)^T @ A @ (pos - center) &gt;= 1\n    diff = position - center\n    obstacle_constraint = ox.ctcs(1.0 &lt;= diff.T @ A_const @ diff)\n    constraints.append(obstacle_constraint)\n</code></pre> <p>The <code>ox.ctcs()</code> function applies Continuous-Time Constraint Satisfaction, ensuring the constraints are satisfied over continuous intervals, not just at discrete nodes. Note that <code>ox.Parameter()</code> allows obstacle centers to be updated at runtime without recompiling the problem.</p>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#initial-guess","title":"Initial Guess","text":"<p>We set initial guesses for the state and control trajectories:</p> <pre><code># Set initial guesses\nposition.guess = np.linspace(position.initial, position.final, n)\nvelocity.guess = np.linspace(velocity.initial, [0, 0, 0], n)\nattitude.guess = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\nangular_velocity.guess = np.zeros((n, 3))\n</code></pre> <p>Tip</p> <p>The Penalized Trust Region method does not require the initial guess to be dynamically feasible or satisfy constraints. However, a guess close to the solution reduces iterations and improves numerical stability. Linear interpolation for states and constant values for controls are good starting points.</p>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#time-definition","title":"Time Definition","text":"<p>For minimum-time problems, we define a <code>Time</code> object:</p> <pre><code>time = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#problem-instantiation","title":"Problem Instantiation","text":"<p>Now we instantiate the <code>Problem</code>:</p> <pre><code>problem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#additional-parameters","title":"Additional Parameters","text":"<p>We can configure solver parameters for better performance:</p> <pre><code>problem.settings.prp.dt = 0.01                   # Time step of the nonlinear propagation\nproblem.settings.scp.lam_vb = 1e0                # Virtual buffer weight\nproblem.settings.scp.w_tr_adapt = 1.8            # Trust region adaptation factor\nproblem.settings.scp.w_tr = 1e1                  # Trust region weight\nproblem.settings.scp.lam_cost = 1e1              # Weight on the cost\nproblem.settings.scp.lam_vc = 1e2                # Weight on virtual control\nproblem.settings.scp.cost_drop = 4               # SCP iteration to relax cost\nproblem.settings.scp.cost_relax = 0.5            # Cost relaxation factor\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#plotting","title":"Plotting","text":"<p>We package relevant information for visualization:</p> <pre><code>plotting_dict = {\n    \"obstacles_centers\": obstacle_center_positions,\n    \"obstacles_axes\": axes,\n    \"obstacles_radii\": radius,\n}\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#running-the-simulation","title":"Running the Simulation","text":"<p>To run the simulation, follow these steps:</p> <ol> <li> <p>Initialize the problem:    <pre><code>problem.initialize()\n</code></pre></p> </li> <li> <p>Solve the problem:    <pre><code>results = problem.solve()\n</code></pre></p> </li> <li> <p>Post-process the solution for verification and plotting:    <pre><code>results = problem.post_process(results)\nresults.update(plotting_dict)\n</code></pre></p> </li> <li> <p>Visualize the results:    <pre><code>from examples.plotting import plot_animation\nplot_animation(results, problem.settings).show()\n</code></pre></p> </li> </ol>"},{"location":"Usage/tutorials/","title":"Tutorials","text":"<p>This section provides step-by-step tutorials for using OpenSCvx to solve trajectory optimization problems. Each tutorial includes a Google Colab notebook for interactive learning.</p>"},{"location":"Usage/tutorials/#getting-started","title":"Getting Started","text":"<p>If you're new to OpenSCvx, we recommend:</p> <ol> <li>Start with the Basic Problem Setup guide</li> <li>Work through the 6DoF Obstacle Avoidance tutorial</li> <li>Progress to the Line-of-Sight Guidance tutorial for advanced concepts</li> <li>Explore the Examples section for additional problems</li> </ol>"},{"location":"Usage/tutorials/#available-tutorials","title":"Available Tutorials","text":""},{"location":"Usage/tutorials/#6dof-obstacle-avoidance","title":"6DoF Obstacle Avoidance","text":"<p>Learn how to solve a minimum-time trajectory optimization problem for a 6-degree-of-freedom drone navigating around obstacles. This tutorial covers:</p> <ul> <li>State and control variable definition</li> <li>6DoF dynamics with quaternions</li> <li>Obstacle avoidance constraints</li> <li>Continuous-time constraint satisfaction</li> <li>Problem instantiation and solving</li> </ul>"},{"location":"Usage/tutorials/#6dof-line-of-sight-guidance","title":"6DoF Line-of-Sight Guidance","text":"<p>Solve a complex trajectory optimization problem involving gate navigation and line-of-sight constraints. This advanced tutorial demonstrates:</p> <ul> <li>Multi-gate navigation with sequence constraints</li> <li>Line-of-sight guidance constraints</li> <li>Mixed continuous and discrete constraints</li> <li>Advanced initial guess generation</li> <li>SCP parameter tuning</li> </ul>"},{"location":"Usage/tutorials/#interactive-learning","title":"Interactive Learning","text":"<p>Each tutorial includes a Google Colab notebook that you can run interactively without setting up a local environment. The notebooks contain the complete code examples and allow you to experiment with parameters and see results in real-time.</p>"},{"location":"examples/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Abstract<ul> <li>3DoF Pdg</li> <li>Brachistochrone</li> </ul> </li> <li>Arm<ul> <li>Three Link Arm</li> </ul> </li> <li>Car<ul> <li>Dubins Car</li> <li>Dubins Car Disjoint</li> <li>Dubins Car Stljax</li> </ul> </li> <li>Drone<ul> <li>Cinema Vp</li> <li>Cinema Vp Realtime Base</li> <li>Dr Double Integrator</li> <li>Dr Vp</li> <li>Dr Vp Nodal</li> <li>Dr Vp Polytope</li> <li>Drone Racing</li> <li>Obstacle Avoidance</li> <li>Obstacle Avoidance Nodal</li> <li>Obstacle Avoidance Realtime Base</li> <li>Obstacle Avoidance Vmap</li> </ul> </li> <li>Realtime<ul> <li>Cinema Vp Realtime</li> <li>Drone Racing Realtime</li> <li>Dubins Car Realtime</li> <li>Obstacle Avoidance Realtime</li> </ul> </li> <li>Spacecraft<ul> <li>Proxops Cw</li> </ul> </li> </ul>"},{"location":"examples/abstract/3DoF_pdg/","title":"3DoF Pdg","text":"<p>3-DOF Powered Descent Guidance (PDG) for planetary landing.</p> <p>This example demonstrates optimal trajectory generation for a rocket performing powered descent guidance, similar to SpaceX Falcon 9 or Blue Origin landings. The problem includes:</p> <ul> <li>3D position and velocity dynamics</li> <li>Fuel-optimal mass minimization</li> <li>Thrust magnitude and pointing constraints</li> <li>Glideslope constraint for safe landing approach</li> </ul> <p>File: <code>examples/abstract/3DoF_pdg.py</code></p> <pre><code>import os\nimport sys\n\nimport numpy as np\n\n# Add grandparent directory to path to import examples.plotting\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nimport openscvx as ox\nfrom examples.plotting_viser import (\n    create_pdg_animated_plotting_server,\n    create_scp_animated_plotting_server,\n)\nfrom openscvx import Problem\nfrom openscvx.plotting import plot_controls, plot_projections_2d, plot_states, plot_vector_norm\n\nn = 10\ntotal_time = 95.0  # Total simulation time\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nv_max = 500 * 1e3 / 3600  # Maximum velocity in m/s (800 km/h converted to m/s)\nposition.max = np.array([3000, 3000, 3000])\nposition.min = np.array([-3000, -3000, 0])\nposition.initial = np.array([2000, 0, 1500])\nposition.final = np.array([0, 0, 0])\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([v_max, v_max, v_max])\nvelocity.min = np.array([-v_max, -v_max, -v_max])\nvelocity.initial = np.array([80, 30, -75])\nvelocity.final = np.array([0, 0, 0])\n\nmass = ox.State(\"mass\", shape=(1,))  # Vehicle mass\nmass.max = np.array([1905])\nmass.min = np.array([1505])\nmass.initial = np.array([1905])\nmass.final = [(\"maximize\", 1690)]\nmass.scaling_min = np.array([1690])\n# mass.scaling_max = np.array([1700])\n\n# Define control\nthrust = ox.Control(\"thrust\", shape=(3,))  # Thrust force vector [Tx, Ty, Tz]\n\nT_bar = 3.1 * 1e3\nT1 = 0.3 * T_bar\nT2 = 0.8 * T_bar\nn_eng = 6\n\n# Set bounds on control\nthrust.min = n_eng * np.array([-T_bar, -T_bar, -T_bar])\nthrust.max = n_eng * np.array([T_bar, T_bar, T_bar])\n\n# Set initial control guess\nthrust.guess = np.repeat(np.expand_dims(np.array([0, 0, n_eng * (T2) / 2]), axis=0), n, axis=0)\n\n# Define list of all states and controls\nstates = [position, velocity, mass]\ncontrols = [thrust]\n\n\n# Define Parameters for physical constants\ng_e = 9.807  # Gravitational acceleration on Earth in m/s^2\n\n# Create parameters for the problem\nI_sp = ox.Parameter(\"I_sp\", value=225.0)\ng = ox.Parameter(\"g\", value=3.7114)\ntheta = ox.Parameter(\"theta\", value=27 * np.pi / 180)\n\n# These will be computed symbolically in constraints\nrho_min = n_eng * T1 * np.cos(theta.value)  # Minimum thrust-to-weight ratio\nrho_max = n_eng * T2 * np.cos(theta.value)  # Maximum thrust-to-weight ratio\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend(\n        [\n            ox.ctcs(state &lt;= state.max, idx=0),\n            ox.ctcs(state.min &lt;= state, idx=0),\n        ]\n    )\n\n# Thrust magnitude constraints\nconstraints.extend(\n    [\n        ox.ctcs(rho_min &lt;= ox.linalg.Norm(thrust), idx=1),\n        ox.ctcs(ox.linalg.Norm(thrust) &lt;= rho_max, idx=1),\n    ]\n)\n\n# Thrust pointing constraint (thrust cant angle)\nconstraints.append(\n    ox.ctcs(np.cos((180 - 40 * np.pi / 180)) &lt;= thrust[2] / ox.linalg.Norm(thrust), idx=2)\n)\n\n# Glideslope constraint\nconstraints.append(\n    ox.ctcs(ox.linalg.Norm(position[:2]) &lt;= np.tan(86 * np.pi / 180) * position[2], idx=3)\n)\n\n\n# Define dynamics as dictionary mapping state names to their derivatives\ng_vec = np.array([0, 0, 1], dtype=np.float64) * g  # Gravitational acceleration vector\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": thrust / mass[0] - g_vec,\n    \"mass\": -ox.linalg.Norm(thrust) / (I_sp * g_e * ox.Cos(theta)),\n}\n\n# Build the problem\ntime = ox.Time(\n    initial=0.0,\n    final=(\"free\", total_time),\n    min=0.0,\n    max=1e2,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n\n# Set solver parameters\nproblem.settings.scp.k_max = 500\nproblem.settings.scp.w_tr_adapt = 1.04\nproblem.settings.scp.w_tr = 6e-1\nproblem.settings.scp.lam_cost = 4e-1\nproblem.settings.scp.lam_vc = 1.5e0\n\n# problem.settings.scp.uniform_time_grid = True\n\nproblem.settings.dis.dis_type = \"ZOH\"\n\nproblem.settings.dis.solver = \"Dopri8\"\n\nproblem.settings.cvx.solver = \"CLARABEL\"\nproblem.settings.cvx.solver_args = {\"enforce_dpp\": True}\n\n\nplotting_dict = {\n    \"rho_min\": rho_min,\n    \"rho_max\": rho_max,\n    \"glideslope_angle_deg\": 86.0,\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n    results.update(plotting_dict)\n\n    plot_states(results, [\"position\", \"velocity\"]).show()\n    plot_controls(results, [\"thrust\"]).show()\n    plot_vector_norm(results, \"thrust\", bounds=(rho_min, rho_max)).show()\n    plot_projections_2d(results, velocity_var_name=\"velocity\").show()\n\n    # Create PDG trajectory visualization\n    # scene_scale=100 brings 2000m scale down to ~20m for viser\n    traj_server = create_pdg_animated_plotting_server(\n        results,\n        thrust_key=\"thrust\",\n        glideslope_angle_deg=86.0,\n        scene_scale=100.0,\n    )\n\n    # Create SCP iteration visualization\n    scp_server = create_scp_animated_plotting_server(\n        results,\n        frame_duration_ms=200,\n        scene_scale=100.0,\n    )\n\n    # Keep servers running\n    traj_server.sleep_forever()\n</code></pre>"},{"location":"examples/abstract/brachistochrone/","title":"Brachistochrone","text":"<p>Brachistochrone problem: finding the fastest descent path.</p> <p>This classic calculus of variations problem finds the curve of fastest descent between two points under gravity. The solution demonstrates time-optimal trajectory generation with:</p> <ul> <li>2D position dynamics</li> <li>Speed dynamics under gravitational acceleration</li> <li>Angle control subject to bounds</li> <li>Minimal time objective</li> </ul> <p>File: <code>examples/abstract/brachistochrone.py</code></p> <pre><code>import os\nimport sys\n\nimport jax.numpy as jnp\nimport numpy as np\n\n# Add grandparent directory to path to import examples.plotting\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nimport openscvx as ox\nfrom examples.plotting import (\n    plot_brachistochrone_position,\n    plot_brachistochrone_velocity,\n)\nfrom openscvx import Problem\n\nn = 2\ntotal_time = 2.0\ng = 9.81\n\n# Define state components\nposition = ox.State(\"position\", shape=(2,))  # 2D position [x, y]\nposition.max = np.array([10.0, 10.0])\nposition.min = np.array([0.0, 0.0])\nposition.initial = np.array([0.0, 10.0])\nposition.final = [10.0, 5.0]\n\nvelocity = ox.State(\"velocity\", shape=(1,))  # Scalar speed\nvelocity.max = np.array([10.0])\nvelocity.min = np.array([0.0])\nvelocity.initial = np.array([0.0])\nvelocity.final = [(\"free\", 10.0)]\n\n# Define control\ntheta = ox.Control(\"theta\", shape=(1,))  # Angle from vertical\ntheta.max = np.array([100.5 * jnp.pi / 180])\ntheta.min = np.array([0.0])\ntheta.guess = np.linspace(5 * jnp.pi / 180, 100.5 * jnp.pi / 180, n).reshape(-1, 1)\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity]\ncontrols = [theta]\n\n# Define dynamics as dictionary mapping state names to their derivatives\ndynamics = {\n    \"position\": ox.Concat(\n        velocity[0] * ox.Sin(theta[0]),  # x_dot\n        -velocity[0] * ox.Cos(theta[0]),  # y_dot\n    ),\n    \"velocity\": g * ox.Cos(theta[0]),\n}\n\n# Generate box constraints for all states\nconstraint_exprs = []\nfor state in states:\n    constraint_exprs.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraint_exprs,\n    N=n,\n    licq_max=1e-8,\n)\n\nproblem.settings.prp.dt = 0.01\n\n# problem.settings.cvx.solver = \"qocogen\"\n# problem.settings.cvx.cvxpygen = True\nproblem.settings.cvx.solver_args = {\"abstol\": 1e-6, \"reltol\": 1e-9}\n\nproblem.settings.scp.w_tr = 1e1  # Weight on the Trust Reigon\nproblem.settings.scp.lam_cost = 1e0  # Weight on the Minimal Time Objective\nproblem.settings.scp.lam_vc = 1e1  # Weight on the Virtual Control Objective\nproblem.settings.scp.uniform_time_grid = True\n\nproblem.settings.sim.save_compiled = False\n\nplotting_dict = {}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update(plotting_dict)\n\n    plot_brachistochrone_position(results).show()\n    plot_brachistochrone_velocity(results).show()\n</code></pre>"},{"location":"examples/arm/three_link_arm/","title":"Three Link Arm","text":"<p>3-link robotic arm with Product of Exponentials forward kinematics.</p> <p>This example demonstrates trajectory optimization for a 3-link spatial arm using Lie algebra operations for forward kinematics. The problem includes:</p> <ul> <li>3 revolute joints with angle and velocity states</li> <li>Product of Exponentials (PoE) forward kinematics using SE3Exp</li> <li>End-effector position tracking objective</li> <li>Joint torque control inputs</li> </ul> <p>The PoE formula computes forward kinematics as:     T_ee(q) = exp(\u03be\u2081q\u2081) @ exp(\u03be\u2082q\u2082) @ exp(\u03be\u2083q\u2083) @ T_home</p> <p>where \u03be\u1d62 are the screw axes and T_home is the end-effector pose at q=0.</p> <p>Requires jaxlie: pip install openscvx[lie]</p> <p>File: <code>examples/arm/three_link_arm.py</code></p> <pre><code>import os\nimport sys\n\nimport numpy as np\n\n# Add grandparent directory to path to import examples.plotting\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nimport openscvx as ox\nfrom openscvx import Problem\nfrom openscvx.plotting import plot_scp_iterations\n\n# =============================================================================\n# Robot Parameters\n# =============================================================================\n\n# Link lengths (meters)\nL1 = 0.4  # Base to shoulder\nL2 = 0.3  # Shoulder to elbow\nL3 = 0.2  # Elbow to end-effector\n\n# Joint inertias (simplified, kg*m^2)\ninertia = np.array([0.05, 0.03, 0.01])\n\n# Number of discretization nodes\nn = 3\ntotal_time = 2.0\n\n# =============================================================================\n# Screw Axes for Product of Exponentials\n# =============================================================================\n# Each screw axis \u03be = [v; \u03c9] where:\n#   \u03c9 = unit rotation axis\n#   v = -\u03c9 \u00d7 q (q = point on the axis)\n#\n# Robot configuration at home (q=0):\n#   - Joint 1: z-rotation at origin\n#   - Joint 2: y-rotation at height L1\n#   - Joint 3: y-rotation at height L1, reach L2 in x\n\n# Screw axes as rows of a 3x6 matrix\nscrew_axes = np.array(\n    [\n        [0.0, 0.0, 0.0, 0.0, 0.0, 1.0],  # Joint 1: z-rotation at origin\n        [-L1, 0.0, 0.0, 0.0, 1.0, 0.0],  # Joint 2: y-rotation at [0, 0, L1]\n        [-L1, 0.0, L2, 0.0, 1.0, 0.0],  # Joint 3: y-rotation at [L2, 0, L1]\n    ]\n)\n\n# Home configuration: end-effector at [L2+L3, 0, L1] with identity rotation\nT_home = np.array(\n    [\n        [1.0, 0.0, 0.0, L2 + L3],\n        [0.0, 1.0, 0.0, 0.0],\n        [0.0, 0.0, 1.0, L1],\n        [0.0, 0.0, 0.0, 1.0],\n    ]\n)\n\n# =============================================================================\n# States\n# =============================================================================\n\n# Joint angles (3,)\nangle = ox.State(\"angle\", shape=(3,))\nangle.max = np.array([np.pi, np.pi / 2, np.pi])\nangle.min = np.array([-np.pi, -np.pi / 2, -np.pi])\nangle.initial = np.array([0.0, 0.0, 0.0])\nangle.final = [(\"free\", 0.0), (\"free\", 0.0), (\"free\", 0.0)]\n\n# Joint velocities (3,)\nvelocity = ox.State(\"velocity\", shape=(3,))\nvelocity.max = np.array([5.0, 5.0, 5.0])\nvelocity.min = np.array([-5.0, -5.0, -5.0])\nvelocity.initial = np.array([0.0, 0.0, 0.0])\nvelocity.final = np.array([0.0, 0.0, 0.0])\n\nstates = [angle, velocity]\n\n# =============================================================================\n# Controls\n# =============================================================================\n\n# Joint torques (3,)\ntorque = ox.Control(\"torque\", shape=(3,))\ntorque.max = np.array([10.0, 5.0, 2.0])\ntorque.min = np.array([-10.0, -5.0, -2.0])\n\ncontrols = [torque]\n\n# =============================================================================\n# Forward Kinematics using Product of Exponentials\n# =============================================================================\n# T_ee(q) = exp(\u03be\u2081q\u2081) @ exp(\u03be\u2082q\u2082) @ exp(\u03be\u2083q\u2083) @ T_home\n\n# Symbolic screw axis expressions scaled by joint angles\nxi_1 = ox.Constant(screw_axes[0])\nxi_2 = ox.Constant(screw_axes[1])\nxi_3 = ox.Constant(screw_axes[2])\n\ntwist_1 = xi_1 * angle[0]\ntwist_2 = xi_2 * angle[1]\ntwist_3 = xi_3 * angle[2]\n\n# Exponential maps for each joint\nT_01 = ox.lie.SE3Exp(twist_1)  # 4x4 transform\nT_12 = ox.lie.SE3Exp(twist_2)\nT_23 = ox.lie.SE3Exp(twist_3)\n\n# Chain the transforms: T_ee = T_01 @ T_12 @ T_23 @ T_home\nT_0_home = ox.Constant(T_home)\nT_ee = T_01 @ T_12 @ T_23 @ T_0_home\n\n# Extract end-effector position from homogeneous transform\np_ee = ox.Concat(T_ee[0, 3], T_ee[1, 3], T_ee[2, 3])\n\n# =============================================================================\n# Dynamics (simplified second-order)\n# =============================================================================\n# Using simplified dynamics: I * qdd = tau\n#\n# Note: Full manipulator dynamics M(q)q\u0308 + C(q,q\u0307)q\u0307 + G(q) = \u03c4 are not needed\n# here. This example demonstrates the Lie algebra functionality (SE3Exp for\n# Product of Exponentials FK), which is independent of the dynamics model.\n\nI_inv = ox.Constant(1.0 / inertia)\n\ndynamics = {\n    \"angle\": velocity,\n    \"velocity\": I_inv * torque,  # Element-wise: qdd_i = tau_i / I_i\n}\n\n# =============================================================================\n# Constraints\n# =============================================================================\n\n# Target end-effector position\ntarget = ox.Parameter(\"target\", shape=(3,), value=np.array([0.3, 0.3, 0.5]))\n\n# Box constraints\nconstraints = []\nfor state in states:\n    constraints.extend(\n        [\n            ox.ctcs(state &lt;= state.max),\n            ox.ctcs(state.min &lt;= state),\n        ]\n    )\n\n# End-effector target constraint at final node (commented out for debugging)\nee_tolerance = 0.01  # 1cm tolerance\nee_target_constraint = (ox.linalg.Norm(p_ee - target, ord=2) &lt;= ee_tolerance).at([n - 1])\nconstraints.append(ee_target_constraint)\n\n# =============================================================================\n# Initial Guesses\n# =============================================================================\n\nnp.random.seed(42)  # For reproducibility\n# Terminal angles that reach the target (from workspace analysis)\nq_terminal = np.deg2rad([47.8, -38.6, 62.4])\nangle.guess = np.linspace(angle.initial, q_terminal, n)\nvelocity.guess = np.zeros((n, 3))\ntorque.guess = np.zeros((n, 3))\n\n# =============================================================================\n# Problem Setup\n# =============================================================================\n\ntime = ox.Time(\n    initial=0.0,\n    final=total_time,\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n\n# Solver settings\nproblem.settings.prp.dt = 0.01\nproblem.settings.scp.w_tr = 1e1\nproblem.settings.scp.lam_cost = 1e2\nproblem.settings.scp.lam_vc = 1e1\nproblem.settings.scp.lam_vb = 1e2\n\nif __name__ == \"__main__\":\n    print(\"3-Link Arm Trajectory Optimization with Product of Exponentials FK\")\n    print(\"=\" * 60)\n    print(f\"Link lengths: L1={L1}m, L2={L2}m, L3={L3}m\")\n    print(f\"Home EE position: [{L2 + L3:.2f}, 0.00, {L1:.2f}]\")\n    print(f\"Target position: {target.value}\")\n    print()\n\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    # Extract final joint angles\n    final_q = results.trajectory[\"angle\"][-1]\n\n    print()\n    print(\"Results:\")\n    print(\n        f\"Final joint angles [deg]: q1={np.rad2deg(final_q[0]):.1f}, \"\n        f\"q2={np.rad2deg(final_q[1]):.1f}, q3={np.rad2deg(final_q[2]):.1f}\"\n    )\n\n    # Compute final EE position (using jaxlie for verification)\n    import jaxlie\n\n    def compute_ee_position(q_vals):\n        T1 = jaxlie.SE3.exp(screw_axes[0] * q_vals[0]).as_matrix()\n        T2 = jaxlie.SE3.exp(screw_axes[1] * q_vals[1]).as_matrix()\n        T3 = jaxlie.SE3.exp(screw_axes[2] * q_vals[2]).as_matrix()\n        T_final = T1 @ T2 @ T3 @ T_home\n        return T_final[:3, 3]\n\n    plot_scp_iterations(results).show()\n\n    tgt = target.value\n    final_ee = compute_ee_position(final_q)\n    error = np.linalg.norm(final_ee - tgt)\n\n    print(f\"Final EE position: [{final_ee[0]:.3f}, {final_ee[1]:.3f}, {final_ee[2]:.3f}]\")\n    print(f\"Target position:   [{tgt[0]:.3f}, {tgt[1]:.3f}, {tgt[2]:.3f}]\")\n    print(f\"Position error:    {error:.4f} m\")\n</code></pre>"},{"location":"examples/car/dubins_car/","title":"Dubins Car","text":"<p>Dubins car path planning with obstacle avoidance.</p> <p>This example demonstrates minimum-time path planning for a Dubins car (car-like vehicle with minimum turning radius) navigating around a circular obstacle. The problem includes:</p> <ul> <li>2D position and heading dynamics</li> <li>Speed and angular rate control inputs</li> <li>Circular obstacle avoidance constraint</li> <li>Minimal time objective with free final heading</li> <li>Parameter updates for multiple scenarios</li> </ul> <p>File: <code>examples/car/dubins_car.py</code></p> <pre><code>import os\nimport sys\n\nimport jax.numpy as jnp\nimport numpy as np\n\n# Add grandparent directory to path to import examples.plotting\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nimport openscvx as ox\nfrom examples.plotting import plot_dubins_car\nfrom openscvx import Problem\n\nn = 8\ntotal_time = 1.2  # Total simulation time\n\n# Define state components\nposition = ox.State(\"position\", shape=(2,))  # 2D position [x, y]\nposition.min = np.array([-5.0, -5.0])\nposition.max = np.array([5.0, 5.0])\nposition.initial = np.array([0, -2])\nposition.final = np.array([0, 2])\n\ntheta = ox.State(\"theta\", shape=(1,))  # Heading angle\ntheta.min = np.array([-2 * jnp.pi])\ntheta.max = np.array([2 * jnp.pi])\ntheta.initial = np.array([0])\ntheta.final = [ox.Free(0)]\n\n# Define control components\nspeed = ox.Control(\"speed\", shape=(1,))  # Forward speed\nspeed.min = np.array([0])\nspeed.max = np.array([10])\nspeed.guess = np.zeros((n, 1))\n\nangular_rate = ox.Control(\"angular_rate\", shape=(1,))  # Angular velocity\nangular_rate.min = np.array([-5])\nangular_rate.max = np.array([5])\nangular_rate.guess = np.zeros((n, 1))\n\n# Define list of all states and controls\nstates = [position, theta]\ncontrols = [speed, angular_rate]\n\n# Define Parameters with initial values for obstacle radius and center\nobs_center = ox.Parameter(\"obs_center\", shape=(2,), value=np.array([-2.01, 0.0]))\nobs_radius = ox.Parameter(\"obs_radius\", shape=(), value=1.0)\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add obstacle avoidance constraint\nconstraints.append(ox.ctcs(obs_radius &lt;= ox.linalg.Norm(position - obs_center)))\n\n\n# Define dynamics as dictionary mapping state names to their derivatives\ndynamics = {\n    \"position\": ox.Concat(\n        speed[0] * ox.Sin(theta[0]),  # x_dot\n        speed[0] * ox.Cos(theta[0]),  # y_dot\n    ),\n    \"theta\": angular_rate[0],\n}\n\n\n# Build the problem (parameters auto-collected from Parameter objects)\ntime = ox.Time(\n    initial=0.0,\n    final=ox.Minimize(total_time),\n    min=0.0,\n    max=20,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n    licq_max=1e-8,\n    time_dilation_factor_min=0.02,\n)\n\n# Set solver parameters\nproblem.settings.prp.dt = 0.01\n# problem.settings.scp.w_tr_adapt = 1.3\nproblem.settings.scp.w_tr = 1e0\nproblem.settings.scp.lam_cost = 4e1\nproblem.settings.scp.lam_vc = 1e3\nproblem.settings.scp.uniform_time_grid = True\n\n# Enable CLI printing for optimization iterations\nproblem.settings.dev.printing = True\n\n# problem.settings.cvx.cvxpygen = True\n# problem.settings.cvx.solver = \"qocogen\"\nproblem.settings.cvx.solver_args = {}\n# problem.settings.cvx.cvxpygen_override = True\n\n\nplotting_dict = {\n    \"obs_radius\": problem.parameters[\"obs_radius\"],\n    \"obs_center\": problem.parameters[\"obs_center\"],\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n    results.update(plotting_dict)\n\n    plot_dubins_car(results, problem.settings).show()\n\n    # Second run with different parameters\n    problem.parameters[\"obs_center\"] = np.array([0.5, 0.0])\n    total_time = 0.7  # Adjust total time for second run\n    problem.settings.scp.lam_cost = 1e-1  # Disable minimal time objective for second run\n    problem.settings.scp.w_tr = 1e0\n    problem.settings.scp.lam_vc = 1e2  # Adjust virtual control weight\n    position.guess = np.linspace([0, -2], [0, 2], n)\n    theta.guess = np.zeros((n, 1))\n    speed.guess = np.zeros((n, 1))\n    angular_rate.guess = np.zeros((n, 1))\n\n    plotting_dict[\"obs_center\"] = np.array([0.5, 0.0])\n\n    results = problem.solve()\n    results = problem.post_process()\n    results.update(plotting_dict)\n    plot_dubins_car(results, problem.settings).show()\n</code></pre>"},{"location":"examples/car/dubins_car_disjoint/","title":"Dubins Car Disjoint","text":"<p>Dubins car with disjoint waypoint visiting constraints.</p> <p>This example demonstrates a Dubins car that must visit one of two waypoints using a smooth max approximation for the disjoint constraint. The problem includes:</p> <ul> <li>2D position and heading dynamics</li> <li>Disjoint waypoint visiting requirement (visit wp1 OR wp2)</li> <li>Smooth max approximation for non-convex OR constraint</li> <li>Loop closure constraint requiring similar start/end positions</li> <li>Minimal time objective</li> </ul> <p>File: <code>examples/car/dubins_car_disjoint.py</code></p> <pre><code>import os\nimport sys\n\nimport jax.numpy as jnp\nimport numpy as np\n\n# Add grandparent directory to path to import examples.plotting\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nimport openscvx as ox\nfrom examples.plotting import plot_dubins_car_disjoint\nfrom openscvx import Problem\n\nn = 8\ntotal_time = 6.0  # Total simulation time\n\n# Define state components\nposition = ox.State(\"position\", shape=(2,))  # 2D position [x, y]\nposition.min = np.array([-5.0, -5.0])\nposition.max = np.array([5.0, 5.0])\nposition.initial = np.array([0, -2])\nposition.final = [ox.Free(0), ox.Free(-1.5)]\nposition.guess = np.linspace(position.initial, [0, 2], n)\n\ntheta = ox.State(\"theta\", shape=(1,))  # Heading angle\ntheta.min = np.array([-2 * jnp.pi])\ntheta.max = np.array([2 * jnp.pi])\ntheta.initial = np.array([0])\ntheta.final = [(\"free\", 0)]\n\n# Define control components\nspeed = ox.Control(\"speed\", shape=(1,))  # Forward speed\nspeed.min = np.array([0])\nspeed.max = np.array([10])\nspeed.guess = np.zeros((n, 1))\n\nangular_rate = ox.Control(\"angular_rate\", shape=(1,))  # Angular velocity\nangular_rate.min = np.array([-5])\nangular_rate.max = np.array([5])\nangular_rate.guess = np.zeros((n, 1))\n\n# Define list of all states and controls\nstates = [position, theta]\ncontrols = [speed, angular_rate]\n# Define Parameters for wp radius and center\nwp1_center = ox.Parameter(\"wp1_center\", shape=(2,), value=np.array([-2.1, 0.0]))\nwp1_radius = ox.Parameter(\"wp1_radius\", shape=(), value=0.5)\nwp2_center = ox.Parameter(\"wp2_center\", shape=(2,), value=np.array([1.9, 0.0]))\nwp2_radius = ox.Parameter(\"wp2_radius\", shape=(), value=0.5)\n\n# Define dynamics as dictionary mapping state names to their derivatives\ndynamics = {\n    \"position\": ox.Concat(\n        speed[0] * ox.Sin(theta[0]),  # x_dot\n        speed[0] * ox.Cos(theta[0]),  # y_dot\n    ),\n    \"theta\": angular_rate[0],\n}\n\n\n# Create symbolic visit waypoint OR constraint\ndef create_visit_wp_OR_expr():\n    # Visit wp1 or wp2 using smooth max\n    d1 = ox.linalg.Norm(position - wp1_center)\n    d2 = ox.linalg.Norm(position - wp2_center)\n    v1 = wp1_radius - d1\n    v2 = wp2_radius - d2\n    alpha = 10.0  # smoothing parameter; higher = closer to max\n    smooth_max = (1.0 / alpha) * ox.Log(ox.Exp(alpha * v1) + ox.Exp(alpha * v2))\n    return -smooth_max\n\n\nvisit_wp_expr = create_visit_wp_OR_expr()\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Visit waypoint constraints using smooth max\nconstraints.append(ox.ctcs(visit_wp_expr &lt;= 0.0).over((3, 5)))\n\nconstraints.append((ox.linalg.Norm(position.at(0) - position.at(-1)) &lt;= 1.0).convex())\n\n# Build the problem\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=20,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n# Set solver parameters\nproblem.settings.prp.dt = 0.01\nproblem.settings.scp.w_tr_adapt = 1.1\nproblem.settings.scp.w_tr = 1e0\nproblem.settings.scp.lam_cost = 1e-1\nproblem.settings.scp.lam_vc = 6e2\nproblem.settings.scp.uniform_time_grid = True\nplotting_dict = {\n    \"wp1_radius\": problem.parameters[\"wp1_radius\"],\n    \"wp1_center\": problem.parameters[\"wp1_center\"],\n    \"wp2_radius\": problem.parameters[\"wp2_radius\"],\n    \"wp2_center\": problem.parameters[\"wp2_center\"],\n}\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n    results.update(plotting_dict)\n    plot_dubins_car_disjoint(results, problem.settings).show()\n</code></pre>"},{"location":"examples/car/dubins_car_stljax/","title":"Dubins Car Stljax","text":"<p>Dubins car with Signal Temporal Logic (STL) constraints using stljax.</p> <p>This example demonstrates a Dubins car with temporal logic specifications using the stljax library for STL constraint formulation. The problem includes:</p> <ul> <li>2D position and heading dynamics with time state</li> <li>STL specification for waypoint visiting (visit wp1 OR wp2)</li> <li>Temporal constraints on when waypoints must be visited</li> <li>Integration with stljax library for formal specifications</li> <li>Requires: pip install stljax</li> </ul> <p>File: <code>examples/car/dubins_car_stljax.py</code></p> <pre><code>import os\nimport sys\n\nimport jax.numpy as jnp\nimport numpy as np\n\n# Add grandparent directory to path to import examples.plotting\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nimport openscvx as ox\nfrom examples.plotting import plot_dubins_car_disjoint\nfrom openscvx import Problem\n\n# NOTE: This example requires the 'stljax' package.\n# You can install it via pip:\n#     pip install stljax\nn = 8\ntotal_time = 6.0  # Total simulation time\n\n# Define state components\nposition = ox.State(\"position\", shape=(2,))  # 2D position [x, y]\nposition.min = np.array([-5.0, -5.0])\nposition.max = np.array([5.0, 5.0])\nposition.initial = np.array([0, -2])\nposition.final = np.array([0, 2])\n\ntheta = ox.State(\"theta\", shape=(1,))  # Heading angle\ntheta.min = np.array([-2 * jnp.pi])\ntheta.max = np.array([2 * jnp.pi])\ntheta.initial = np.array([0])\ntheta.final = [(\"free\", 0)]\n\n# Define control components\nspeed = ox.Control(\"speed\", shape=(1,))  # Forward speed\nspeed.min = np.array([0])\nspeed.max = np.array([10])\nspeed.guess = np.zeros((n, 1))\n\nangular_rate = ox.Control(\"angular_rate\", shape=(1,))  # Angular velocity\nangular_rate.min = np.array([-5])\nangular_rate.max = np.array([5])\nangular_rate.guess = np.zeros((n, 1))\n\n# Define time state (needed for time-dependent constraints)\ntime = ox.State(\"time\", shape=(1,))\ntime.max = np.array([10])\ntime.min = np.array([0.0])\ntime.initial = np.array([0.0])\ntime.final = [ox.Minimize(total_time)]\n\n\n# Define list of all states and controls\nstates = [position, theta, time]\ncontrols = [speed, angular_rate]\n# Define Parameters for wp radius and center\nwp1_center = ox.Parameter(\"wp1_center\", shape=(2,), value=np.array([-2.1, 0.0]))\nwp1_radius = ox.Parameter(\"wp1_radius\", shape=(), value=0.5)\nwp2_center = ox.Parameter(\"wp2_center\", shape=(2,), value=np.array([2.09999, 0.0]))\nwp2_radius = ox.Parameter(\"wp2_radius\", shape=(), value=0.5)\n\n\n# Define dynamics as dictionary mapping state names to their derivatives\ndynamics = {\n    \"position\": ox.Concat(\n        speed[0] * ox.Sin(theta[0]),  # x_dot\n        speed[0] * ox.Cos(theta[0]),  # y_dot\n    ),\n    \"theta\": angular_rate[0],\n    \"time\": 1.0,\n}\n\n# Create symbolic expressions for waypoint predicates\nwp1_pred = wp1_radius - ox.linalg.Norm(position - wp1_center)\nwp2_pred = wp2_radius - ox.linalg.Norm(position - wp2_center)\n\n# Create symbolic OR expression using the new Or node\nvisit_wp_or_expr = ox.stl.Or(wp1_pred, wp2_pred)\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Visit waypoint constraints using symbolic Or\nconstraints.append(ox.ctcs(-visit_wp_or_expr &lt;= 0.0).over((3, 5)))\n\n# Build the problem\ntime_config = ox.Time(\n    initial=0.0,\n    final=total_time,\n    min=0.0,\n    max=10,\n)\n\nconstraints.append((time.at(5) - time.at(3) == 1.23).convex())\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time_config,\n    constraints=constraints,\n    N=n,\n)\n# Set solver parameters\nproblem.settings.prp.dt = 0.01\nproblem.settings.scp.w_tr_adapt = 1.1\nproblem.settings.scp.w_tr = 1e0\nproblem.settings.scp.lam_cost = 1e-1\nproblem.settings.scp.lam_vc = 6e2\nproblem.settings.scp.uniform_time_grid = True\n# Extract parameter values from problem.parameters (not Parameter objects)\nplotting_dict = {\n    \"wp1_center\": problem.parameters.get(\"wp1_center\", None),\n    \"wp1_radius\": problem.parameters.get(\"wp1_radius\", None),\n    \"wp2_center\": problem.parameters.get(\"wp2_center\", None),\n    \"wp2_radius\": problem.parameters.get(\"wp2_radius\", None),\n}\n\n# Only add waypoints that are actually defined\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n    results.update(plotting_dict)\n    plot_dubins_car_disjoint(results, problem.settings).show()\n</code></pre>"},{"location":"examples/drone/cinema_vp/","title":"Cinema Vp","text":"<p>Cinematic viewpoint planning for aerial filming.</p> <p>This example demonstrates optimal trajectory planning for a quadrotor performing aerial cinematography with viewpoint constraints. The problem includes:</p> <ul> <li>6-DOF dynamics with fuel consumption tracking</li> <li>Continuous field-of-view (FOV) constraints to keep moving target in view</li> <li>Sensor pointing constraints using camera cone geometry</li> <li>Fuel-optimal trajectory generation</li> <li>Attitude planning to maintain visual coverage</li> </ul> <p>File: <code>examples/drone/cinema_vp.py</code></p> <pre><code>import os\nimport sys\n\nimport jax.numpy as jnp\nimport numpy as np\nimport numpy.linalg as la\n\n# Add grandparent directory to path to import examples.plotting\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nimport openscvx as ox\nfrom examples.plotting_viser import (\n    create_animated_plotting_server,\n    create_scp_animated_plotting_server,\n)\nfrom openscvx import Problem\nfrom openscvx.utils import get_kp_pose\n\nn = 12  # Number of Nodes\ntotal_time = 40.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 100, 50])\nposition.min = np.array([-100.0, -100, -10])\nposition.initial = np.array([8.0, -0.2, 2.2])\nposition.final = [(\"free\", -10.0), (\"free\", 0), (\"free\", 2)]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nfuel = ox.State(\"fuel\", shape=(1,))  # Fuel consumption\nfuel.max = np.array([2000])\nfuel.min = np.array([0])\nfuel.initial = np.array([0])\nfuel.final = [(\"minimize\", 0)]\n\n# Define time state (needed for time-dependent constraints)\ntime = ox.State(\"time\", shape=(1,))\ntime.max = np.array([total_time])\ntime.min = np.array([0.0])\ntime.initial = np.array([0.0])\ntime.final = np.array([total_time])\n\n# Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\nthrust_force.guess = np.repeat(np.array([[0.0, 0, 10]]), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\ninit_pose = np.array([13.0, 0.0, 2.0])\nmin_range = 4.0\nmax_range = 16.0\n\n### View Planning Params ###\nn_subs = 1  # Number of Subjects\nalpha_x = 6.0  # Angle for the x-axis of Sensor Cone\nalpha_y = 8.0  # Angle for the y-axis of Sensor Cone\nA_cone = np.diag(\n    [\n        1 / np.tan(np.pi / alpha_x),\n        1 / np.tan(np.pi / alpha_y),\n        0,\n    ]\n)  # Conic Matrix in Sensor Frame\nc = jnp.array([0, 0, 1])  # Boresight Vector in Sensor Frame\nnorm_type = \"inf\"\nR_sb = jnp.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\n\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity, attitude, angular_velocity, fuel, time]\ncontrols = [thrust_force, torque]\n\n\n# Create symbolic dynamics\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\n# Concatenate all controls for fuel calculation\nall_controls = ox.Concat(thrust_force, torque)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n    + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv)\n    @ (torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity),\n    \"fuel\": ox.linalg.Norm(all_controls),\n    \"time\": 1.0,  # Real time derivative\n}\n\n\n# Symbolic implementation of get_kp_pose function\ndef get_kp_pose_symbolic(t_expr, init_pose):\n    loop_time = 40.0\n    loop_radius = 20.0\n\n    # Convert the trajectory parameters to symbolic constants\n    loop_time_const = loop_time\n    loop_radius_const = loop_radius\n    two_pi_const = 2 * np.pi\n    init_pose_const = init_pose\n    half_const = 0.5\n\n    # Compute symbolic trajectory: t_angle = t / loop_time * (2 * pi)\n    t_angle = t_expr / loop_time_const * two_pi_const\n\n    # x = loop_radius * sin(t_angle)\n    x_pos = loop_radius_const * ox.Sin(t_angle)\n\n    # y = x * cos(t_angle)\n    y_pos = x_pos * ox.Cos(t_angle)\n\n    # z = 0.5 * x * sin(t_angle)\n    z_pos = half_const * x_pos * ox.Sin(t_angle)\n\n    # Stack into position vector and add initial pose\n    kp_trajectory = ox.Concat(x_pos, y_pos, z_pos) + init_pose_const\n    return kp_trajectory\n\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Get the symbolic keypoint pose based on time\nkp_pose_symbolic = get_kp_pose_symbolic(time[0], init_pose)\n\n# View planning constraint using symbolic keypoint pose\np_s_s = R_sb @ ox.spatial.QDCM(attitude).T @ (kp_pose_symbolic - position)\nvp_constraint = np.sqrt(2e1) * (ox.linalg.Norm(A_cone @ p_s_s, ord=norm_type) - (c.T @ p_s_s))\n\n# Range constraints using symbolic keypoint pose\nmin_range_constraint = min_range - ox.linalg.Norm(kp_pose_symbolic - position)\nmax_range_constraint = ox.linalg.Norm(kp_pose_symbolic - position) - max_range\n\nconstraints.extend(\n    [\n        ox.ctcs(vp_constraint &lt;= 0.0),\n        ox.ctcs(min_range_constraint &lt;= 0.0),\n        ox.ctcs(max_range_constraint &lt;= 0.0),\n    ]\n)\n\n\n# Initialize initial guess (will be modified by symbolic trajectory)\n# Extract final values from tuples (position.final has free values, use their default guesses)\nposition_final_values = np.array(\n    [\n        position.final[0][1] if isinstance(position.final[0], tuple) else position.final[0],\n        position.final[1][1] if isinstance(position.final[1], tuple) else position.final[1],\n        position.final[2][1] if isinstance(position.final[2], tuple) else position.final[2],\n    ]\n)\nposition_bar = np.linspace(position.initial, position_final_values, n)\nvelocity_bar = np.zeros((n, 3))  # Velocity is free at final, start with zeros\nattitude_bar = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\nangular_velocity_bar = np.zeros((n, 3))\nfuel_bar = np.zeros((n, 1))  # Fuel starts at 0 and is minimized\n\n# Time guess for trajectory computation\ntime_bar = np.linspace(0, total_time, n)\n\n# Modify position to follow offset from keypoint trajectory\nposition_bar = get_kp_pose(time_bar, init_pose) + np.array([-5, 0.2, 0.2])\n\n# Modify attitude to point sensor at targets\nb = R_sb @ np.array([0, 1, 0])\nfor k in range(n):\n    kp = get_kp_pose(time_bar[k], init_pose)\n    a = kp - position_bar[k]\n    # Determine the direction cosine matrix that aligns the z-axis of the sensor frame with the\n    # relative position vector\n    q_xyz = np.cross(b, a)\n    q_w = np.sqrt(la.norm(a) ** 2 + la.norm(b) ** 2) + np.dot(a, b)\n    q_no_norm = np.hstack((q_w, q_xyz))\n    q = q_no_norm / la.norm(q_no_norm)\n    attitude_bar[k] = q\n\n# Set all guesses\nposition.guess = position_bar\nvelocity.guess = velocity_bar\nattitude.guess = attitude_bar\nangular_velocity.guess = angular_velocity_bar\nfuel.guess = fuel_bar\n\ntime_config = ox.Time(\n    initial=0.0,\n    final=total_time,\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time_config,\n    constraints=constraints,\n    N=n,\n    licq_max=1e-8,\n)\n\n\nproblem.settings.scp.w_tr = 4e0  # Weight on the Trust Reigon\nproblem.settings.scp.lam_cost = 1e-2  # Weight on the Minimal Fuel Objective\nproblem.settings.scp.lam_vc = 1e1  # Weight on the Virtual Control Objective\n\nproblem.settings.scp.ep_tr = 1e-6  # Trust Region Tolerance\nproblem.settings.scp.ep_vb = 1e-4  # Virtual Control Tolerance\nproblem.settings.scp.ep_vc = 1e-8  # Virtual Control Tolerance for CTCS\nproblem.settings.scp.w_tr_adapt = 1.3  # Trust Region Adaptation Factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e3  # Maximum Trust Region Weight\n\nplotting_dict = {\n    \"n_subs\": n_subs,\n    \"alpha_x\": alpha_x,\n    \"alpha_y\": alpha_y,\n    \"R_sb\": R_sb,\n    \"norm_type\": norm_type,\n    \"min_range\": min_range,\n    \"max_range\": max_range,\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    # Compute moving target trajectory using the post-processed time array\n    traj_time = results.trajectory[\"time\"].flatten()\n    target_trajectory = np.asarray(get_kp_pose(traj_time, init_pose))\n    plotting_dict[\"init_poses\"] = [target_trajectory]  # List of target trajectories\n\n    results.update(plotting_dict)\n\n    # Create both visualization servers (viser auto-assigns ports)\n    traj_server = create_animated_plotting_server(\n        results,\n        thrust_key=\"thrust_force\",\n        viewcone_scale=10.0,\n    )\n    scp_server = create_scp_animated_plotting_server(\n        results,\n        attitude_stride=3,\n        frame_duration_ms=200,\n    )\n\n    # Keep both servers running\n    traj_server.sleep_forever()\n</code></pre>"},{"location":"examples/drone/cinema_vp_realtime_base/","title":"Cinema Vp Realtime Base","text":"<p>Base problem setup for real-time cinematic viewpoint planning.</p> <p>This module defines the base optimization problem for real-time aerial cinematography, designed to be imported by interactive visualization examples. The problem includes:</p> <ul> <li>6-DOF dynamics with parametric target positions</li> <li>Field-of-view constraints for visual tracking</li> <li>Sensor cone constraints for camera pointing</li> <li>Configured for real-time re-optimization with moving targets</li> </ul> <p>File: <code>examples/drone/cinema_vp_realtime_base.py</code></p> <pre><code>import os\nimport sys\n\nimport jax.numpy as jnp\nimport numpy as np\nimport numpy.linalg as la\n\n# Add grandparent directory to path to import examples.plotting\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nimport openscvx as ox\nfrom openscvx import Problem\n\nn = 12  # Number of Nodes\ntotal_time = 40.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 100, 50])\nposition.min = np.array([-100.0, -100, -10])\nposition.initial = np.array([8.0, -0.2, 2.2])\nposition.final = [(\"free\", -10.0), (\"free\", 0), (\"free\", 2)]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nfuel = ox.State(\"fuel\", shape=(1,))  # Fuel consumption\nfuel.max = np.array([2000])\nfuel.min = np.array([0])\nfuel.initial = np.array([0])\nfuel.final = [(\"minimize\", 0)]\n\n# Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\nthrust_force.guess = np.repeat(np.array([[0.0, 0, 10]]), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n# Initial keypoint position (will be controlled by user in realtime)\ninitial_kp_pose = np.array([13.0, 0.0, 2.0])\nmin_range = 4.0\nmax_range = 16.0\n\n### View Planning Params ###\nn_subs = 1  # Number of Subjects\nalpha_x = 6.0  # Angle for the x-axis of Sensor Cone\nalpha_y = 8.0  # Angle for the y-axis of Sensor Cone\nA_cone = np.diag(\n    [\n        1 / np.tan(np.pi / alpha_x),\n        1 / np.tan(np.pi / alpha_y),\n        0,\n    ]\n)  # Conic Matrix in Sensor Frame\nc = jnp.array([0, 0, 1])  # Boresight Vector in Sensor Frame\nnorm_type = \"inf\"\nR_sb = jnp.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\n\n# Define keypoint position as a parameter (can be updated in realtime)\nkp_pose = ox.Parameter(\"kp_pose\", shape=(3,), value=initial_kp_pose)\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity, attitude, angular_velocity, fuel]\ncontrols = [thrust_force, torque]\n\n# Create symbolic dynamics\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\n# Concatenate all controls for fuel calculation\nall_controls = ox.Concat(thrust_force, torque)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n    + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv)\n    @ (torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity),\n    \"fuel\": ox.linalg.Norm(all_controls),\n}\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# View planning constraint using parameter keypoint pose\np_s_s = R_sb @ ox.spatial.QDCM(attitude).T @ (kp_pose - position)\nvp_constraint = np.sqrt(2e1) * (ox.linalg.Norm(A_cone @ p_s_s, ord=norm_type) - (c.T @ p_s_s))\n\n# Range constraints using parameter keypoint pose\nmin_range_constraint = min_range - ox.linalg.Norm(kp_pose - position)\nmax_range_constraint = ox.linalg.Norm(kp_pose - position) - max_range\n\nconstraints.extend(\n    [\n        ox.ctcs(vp_constraint &lt;= 0.0),\n        ox.ctcs(min_range_constraint &lt;= 0.0),\n        ox.ctcs(max_range_constraint &lt;= 0.0),\n    ]\n)\n\n# Initialize initial guess\nposition_final_values = np.array(\n    [\n        position.final[0][1] if isinstance(position.final[0], tuple) else position.final[0],\n        position.final[1][1] if isinstance(position.final[1], tuple) else position.final[1],\n        position.final[2][1] if isinstance(position.final[2], tuple) else position.final[2],\n    ]\n)\nposition_bar = np.linspace(position.initial, position_final_values, n)\nvelocity_bar = np.zeros((n, 3))\nattitude_bar = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\nangular_velocity_bar = np.zeros((n, 3))\nfuel_bar = np.zeros((n, 1))\n\n# Modify position to follow offset from keypoint\n# Create array of positions, all offset from keypoint\noffset = np.array([-5, 0.2, 0.2])\nposition_bar = np.tile(initial_kp_pose + offset, (n, 1))\n\n# Modify attitude to point sensor at keypoint\nb = R_sb @ np.array([0, 1, 0])\nfor k in range(n):\n    a = initial_kp_pose - position_bar[k]\n    # Determine the direction cosine matrix that aligns the z-axis of the sensor frame with the\n    # relative position vector\n    q_xyz = np.cross(b, a)\n    q_w = np.sqrt(la.norm(a) ** 2 + la.norm(b) ** 2) + np.dot(a, b)\n    q_no_norm = np.hstack((q_w, q_xyz))\n    q = q_no_norm / la.norm(q_no_norm)\n    attitude_bar[k] = q\n\n# Set all guesses\nposition.guess = position_bar\nvelocity.guess = velocity_bar\nattitude.guess = attitude_bar\nangular_velocity.guess = angular_velocity_bar\nfuel.guess = fuel_bar\n\ntime_config = ox.Time(\n    initial=0.0,\n    final=total_time,\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time_config,\n    constraints=constraints,\n    N=n,\n    licq_max=1e-8,\n)\n\nproblem.settings.scp.w_tr = 4e0  # Weight on the Trust Region\nproblem.settings.scp.lam_cost = 1e-2  # Weight on the Minimal Fuel Objective\nproblem.settings.scp.lam_vc = 1e1  # Weight on the Virtual Control Objective\n\nproblem.settings.scp.ep_tr = 1e-6  # Trust Region Tolerance\nproblem.settings.scp.ep_vb = 1e-4  # Virtual Control Tolerance\nproblem.settings.scp.ep_vc = 1e-8  # Virtual Control Tolerance for CTCS\nproblem.settings.scp.w_tr_adapt = 1.3  # Trust Region Adaptation Factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e3  # Maximum Trust Region Weight\n\nplotting_dict = {\n    \"n_subs\": n_subs,\n    \"alpha_x\": alpha_x,\n    \"alpha_y\": alpha_y,\n    \"R_sb\": R_sb,\n    \"init_poses\": initial_kp_pose,\n    \"norm_type\": norm_type,\n    \"min_range\": min_range,\n    \"max_range\": max_range,\n    \"moving_subject\": False,  # Not moving in realtime version\n    \"kp_pose\": kp_pose,\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update(plotting_dict)\n</code></pre>"},{"location":"examples/drone/dr_double_integrator/","title":"Dr Double Integrator","text":"<p>Simplified drone racing using double integrator dynamics.</p> <p>This example demonstrates time-optimal racing through gates using simplified double integrator (point mass) dynamics instead of full 6-DOF dynamics. The problem includes:</p> <ul> <li>3-DOF point mass dynamics (position and velocity only)</li> <li>Direct force control inputs (no attitude dynamics)</li> <li>Sequential gate passage constraints</li> <li>Minimal time objective</li> <li>Loop closure constraint</li> </ul> <p>File: <code>examples/drone/dr_double_integrator.py</code></p> <pre><code>import os\nimport sys\n\nimport jax.numpy as jnp\nimport numpy as np\n\n# Add grandparent directory to path to import examples.plotting\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nimport openscvx as ox\nfrom examples.plotting_viser import (\n    create_animated_plotting_server,\n    create_scp_animated_plotting_server,\n)\nfrom openscvx import Problem\nfrom openscvx.utils import gen_vertices, rot\n\nn = 22  # Number of Nodes\ntotal_time = 24.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 100, 50])\nposition.min = np.array([-200.0, -100, 15])\nposition.initial = np.array([10.0, 0, 20])\nposition.final = [10.0, 0, 20]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Define control\nforce = ox.Control(\"force\", shape=(3,))  # Control forces [fx, fy, fz]\nf_max = 4.179446268 * 9.81\nforce.max = np.array([f_max, f_max, f_max])\nforce.min = np.array([-f_max, -f_max, -f_max])\ninitial_control = np.array([0.0, 0, 10])\nforce.guess = np.repeat(initial_control[np.newaxis, :], n, axis=0)\n\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n\n### Gate Parameters ###\nn_gates = 10\ngate_centers = [\n    np.array([59.436, 0.000, 20.0000]),\n    np.array([92.964, -23.750, 25.5240]),\n    np.array([92.964, -29.274, 20.0000]),\n    np.array([92.964, -23.750, 20.0000]),\n    np.array([130.150, -23.750, 20.0000]),\n    np.array([152.400, -73.152, 20.0000]),\n    np.array([92.964, -75.080, 20.0000]),\n    np.array([92.964, -68.556, 20.0000]),\n    np.array([59.436, -81.358, 20.0000]),\n    np.array([22.250, -42.672, 20.0000]),\n]\n\nradii = np.array([2.5, 1e-4, 2.5])\nA_gate = rot @ np.diag(1 / radii) @ rot.T\nA_gate_cen = []\nfor center in gate_centers:\n    center[0] = center[0] + 2.5\n    center[2] = center[2] + 2.5\n    A_gate_cen.append(A_gate @ center)\nnodes_per_gate = 2\ngate_nodes = np.arange(nodes_per_gate, n, nodes_per_gate)\nvertices = []\nfor center in gate_centers:\n    vertices.append(gen_vertices(center, radii))\n### End Gate Parameters ###\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity]\ncontrols = [force]\n\n# Generate box constraints for all states\nconstraint_exprs = []\nfor state in states:\n    constraint_exprs.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add gate constraints\nfor node, cen in zip(gate_nodes, A_gate_cen):\n    A_gate_const = A_gate\n    c_const = cen\n    gate_constraint = (\n        (ox.linalg.Norm(A_gate_const @ position - c_const, ord=\"inf\") &lt;= np.array([1.0]))\n        .convex()\n        .at([node])\n    )\n    constraint_exprs.append(gate_constraint)\n\n\n# Define dynamics as dictionary mapping state names to their derivatives\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1 / m) * force + np.array([0, 0, g_const], dtype=np.float64),\n}\n\n\nposition_bar = np.linspace(position.initial, position.final, n)\n\ni = 0\norigins = [position.initial]\nends = []\nfor center in gate_centers:\n    origins.append(center)\n    ends.append(center)\nends.append(position.final)\ngate_idx = 0\nfor _ in range(n_gates + 1):\n    for k in range(n // (n_gates + 1)):\n        position_bar[i] = origins[gate_idx] + (k / (n // (n_gates + 1))) * (\n            ends[gate_idx] - origins[gate_idx]\n        )\n        i += 1\n    gate_idx += 1\n\nposition.guess = position_bar\n\nt = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=t,\n    constraints=constraint_exprs,\n    N=n,\n)\n\nproblem.settings.prp.dt = 0.01\nproblem.settings.dis.custom_integrator = True\n\nproblem.settings.scp.w_tr = 2e0  # Weight on the Trust Reigon\nproblem.settings.scp.lam_cost = 1e-1  # 0e-1,  # Weight on the Minimal Time Objective\nproblem.settings.scp.lam_vc = (\n    1e1  # 1e1,  # Weight on the Virtual Control Objective (not including CTCS Augmentation)\n)\nproblem.settings.scp.ep_tr = 1e-3  # Trust Region Tolerance\nproblem.settings.scp.ep_vb = 1e-4  # Virtual Control Tolerance\nproblem.settings.scp.ep_vc = 1e-8  # Virtual Control Tolerance for CTCS\nproblem.settings.scp.cost_drop = 10  # SCP iteration to relax minimal final time objective\nproblem.settings.scp.cost_relax = 0.8  # Minimal Time Relaxation Factor\nproblem.settings.scp.w_tr_adapt = 1.4  # Trust Region Adaptation Factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e2  # Maximum Trust Region Weight\n\nplotting_dict = {\"vertices\": vertices}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update(plotting_dict)\n\n    # Create both visualization servers (viser auto-assigns ports)\n    traj_server = create_animated_plotting_server(\n        results,\n        thrust_key=\"force\",\n        viewcone_scale=10.0,\n    )\n    scp_server = create_scp_animated_plotting_server(\n        results,\n        attitude_stride=3,\n        frame_duration_ms=200,\n    )\n\n    # Keep both servers running\n    traj_server.sleep_forever()\n</code></pre>"},{"location":"examples/drone/dr_vp/","title":"Dr Vp","text":"<p>Drone racing with continuous viewpoint constraints.</p> <p>This example combines drone racing through gates with camera viewpoint constraints to maintain visual contact with reference targets. The problem includes:</p> <ul> <li>6-DOF rigid body dynamics (position, velocity, attitude quaternion, angular velocity)</li> <li>Sequential gate passage constraints</li> <li>Attitude planning for simultaneous gate navigation and visual tracking</li> <li>Continuous sensor visibility constraints to keep targets in FOV</li> <li>Minimal time objective</li> </ul> <p>File: <code>examples/drone/dr_vp.py</code></p> <pre><code>import os\nimport sys\n\nimport jax.numpy as jnp\nimport numpy as np\nimport numpy.linalg as la\n\n# Add grandparent directory to path to import examples.plotting\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nimport openscvx as ox\nfrom examples.plotting_viser import (\n    create_animated_plotting_server,\n    create_scp_animated_plotting_server,\n)\nfrom openscvx import Problem\nfrom openscvx.utils import gen_vertices, rot\n\nn = 33  # Number of Nodes\ntotal_time = 40.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 100, 50])\nposition.min = np.array([-200.0, -100, 15])\nposition.initial = np.array([10.0, 0, 20])\nposition.final = [10.0, 0, 20]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\nthrust_force.guess = np.repeat(np.array([[0.0, 0, 10]]), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n\n### Sensor Params ###\nalpha_x = 6.0  # Angle for the x-axis of Sensor Cone\nalpha_y = 6.0  # Angle for the y-axis of Sensor Cone\nA_cone = np.diag(\n    [\n        1 / np.tan(np.pi / alpha_x),\n        1 / np.tan(np.pi / alpha_y),\n        0,\n    ]\n)  # Conic Matrix in Sensor Frame\nc = jnp.array([0, 0, 1])  # Boresight Vector in Sensor Frame\nnorm_type = 2  # Norm Type\nR_sb = jnp.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\n### End Sensor Params ###\n\n\n### Gate Parameters ###\nn_gates = 10\ngate_centers = [\n    np.array([59.436, 0.0000, 20.0000]),\n    np.array([92.964, -23.750, 25.5240]),\n    np.array([92.964, -29.274, 20.0000]),\n    np.array([92.964, -23.750, 20.0000]),\n    np.array([130.150, -23.750, 20.0000]),\n    np.array([152.400, -73.152, 20.0000]),\n    np.array([92.964, -75.080, 20.0000]),\n    np.array([92.964, -68.556, 20.0000]),\n    np.array([59.436, -81.358, 20.0000]),\n    np.array([22.250, -42.672, 20.0000]),\n]\n\nradii = np.array([2.5, 1e-4, 2.5])\nA_gate = rot @ np.diag(1 / radii) @ rot.T\nA_gate_cen = []\nfor center in gate_centers:\n    center[0] = center[0] + 2.5\n    center[2] = center[2] + 2.5\n    A_gate_cen.append(A_gate @ center)\nnodes_per_gate = 3\ngate_nodes = np.arange(nodes_per_gate, n, nodes_per_gate)\nvertices = []\nfor center in gate_centers:\n    vertices.append(gen_vertices(center, radii))\n### End Gate Parameters ###\n\nn_subs = 10\nnp.random.seed(0)\ninit_poses = np.array(\n    [\n        [100.0 + np.random.random() * 20.0, -60.0 + np.random.random() * 20.0, 20.0]\n        for _ in range(n_subs)\n    ]\n)  # Shape: (n_subs, 3)\n\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity, attitude, angular_velocity]\ncontrols = [thrust_force, torque]\n\n\n# Symbolic sensor visibility constraint function\ndef g_vp(p_s_I, x_pos, x_quat):\n    p_s_s = R_sb @ ox.spatial.QDCM(x_quat).T @ (p_s_I - x_pos)\n    return ox.linalg.Norm(A_cone @ p_s_s, ord=norm_type) - (c.T @ p_s_s)\n\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add visibility constraints using Vmap for parallel evaluation\n# Single CTCS constraint with vectorized evaluation over all target poses\nvisibility_constraint = ox.ctcs(\n    ox.Vmap(\n        lambda pose: g_vp(pose, position, attitude),\n        batch=init_poses,\n    )\n    &lt;= 0.0\n)\nconstraints.append(visibility_constraint)\n\n# Add gate constraints using symbolic expressions\nfor node, cen in zip(gate_nodes, A_gate_cen):\n    A_gate_const = A_gate\n    cen_const = cen\n\n    # Gate constraint: ||A @ pos - c||_inf &lt;= 1\n    gate_constraint = (\n        (ox.linalg.Norm(A_gate_const @ position - cen_const, ord=\"inf\") &lt;= 1.0).convex().at([node])\n    )\n    constraints.append(gate_constraint)\n\n\n# Create symbolic dynamics\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n    + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv)\n    @ (torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity),\n}\n\n\n# Initialize initial guess (will be modified by gate logic)\nposition_bar = np.linspace(position.initial, position.final, n)\nvelocity_bar = np.zeros((n, 3))\nattitude_bar = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\nangular_velocity_bar = np.zeros((n, 3))\n\n# Modify position to go through gates\ni = 0\norigins = [position.initial]\nends = []\nfor center in gate_centers:\n    origins.append(center)\n    ends.append(center)\nends.append(position.final)\ngate_idx = 0\nfor _ in range(n_gates + 1):\n    for k in range(n // (n_gates + 1)):\n        position_bar[i] = origins[gate_idx] + (k / (n // (n_gates + 1))) * (\n            ends[gate_idx] - origins[gate_idx]\n        )\n        i += 1\n    gate_idx += 1\n\n# Modify attitude to point sensor at targets\nR_sb = R_sb  # Sensor to body frame\nb = R_sb @ np.array([0, 1, 0])\nmean_target = np.mean(init_poses, axis=0)  # Average target position\nfor k in range(n):\n    a = mean_target - position_bar[k]\n    # Determine the direction cosine matrix that aligns the z-axis of the sensor frame with the\n    # relative position vector\n    q_xyz = np.cross(b, a)\n    q_w = np.sqrt(la.norm(a) ** 2 + la.norm(b) ** 2) + np.dot(a, b)\n    q_no_norm = np.hstack((q_w, q_xyz))\n    q = q_no_norm / la.norm(q_no_norm)\n    attitude_bar[k] = q\n\n# Set all guesses\nposition.guess = position_bar\nvelocity.guess = velocity_bar\nattitude.guess = attitude_bar\nangular_velocity.guess = angular_velocity_bar\n\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n\nproblem.settings.prp.dt = 0.01\n\n\nproblem.settings.scp.w_tr = 2e0  # Weight on the Trust Reigon\nproblem.settings.scp.lam_cost = 1e-1  # 0e-1,  # Weight on the Minimal Time Objective\nproblem.settings.scp.lam_vc = (\n    1e2  # 1e1,  # Weight on the Virtual Control Objective (not including CTCS Augmentation)\n)\nproblem.settings.scp.ep_tr = 1e-3  # Trust Region Tolerance\nproblem.settings.scp.ep_vb = 1e-4  # Virtual Control Tolerance\nproblem.settings.scp.ep_vc = 1e-8  # Virtual Control Tolerance\nproblem.settings.scp.cost_drop = 10  # SCP iteration to relax minimal final time objective\nproblem.settings.scp.cost_relax = 0.8  # Minimal Time Relaxation Factor\nproblem.settings.scp.w_tr_adapt = 1.4  # Trust Region Adaptation Factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e2  # Maximum Trust Region Weight\n\nplotting_dict = {\n    \"vertices\": vertices,\n    \"n_subs\": n_subs,\n    \"alpha_x\": alpha_x,\n    \"alpha_y\": alpha_y,\n    \"R_sb\": R_sb,\n    \"init_poses\": init_poses,\n    \"norm_type\": norm_type,\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update(plotting_dict)\n\n    # Create both visualization servers (viser auto-assigns ports)\n    traj_server = create_animated_plotting_server(\n        results,\n        thrust_key=\"thrust_force\",\n        viewcone_scale=10.0,\n        show_control_plot=\"thrust_force\",\n        show_control_norm_plot=\"thrust_force\",\n    )\n    scp_server = create_scp_animated_plotting_server(\n        results,\n        attitude_stride=3,\n        frame_duration_ms=200,\n    )\n\n    # Keep both servers running\n    traj_server.sleep_forever()\n</code></pre>"},{"location":"examples/drone/dr_vp_nodal/","title":"Dr Vp Nodal","text":"<p>Drone racing with nodal viewpoint constraints.</p> <p>This example demonstrates drone racing through gates with sensor visibility constraints applied at all nodes. The problem includes:</p> <ul> <li>6-DOF rigid-body dynamics (position, velocity, attitude quaternion, angular velocity)</li> <li>Sequential gate passage constraints</li> <li>Attitude planning for simultaneous gate navigation and visual tracking</li> <li>Nodal sensor visibility constraints throughout trajectory</li> <li>Minimal time objective</li> </ul> <p>File: <code>examples/drone/dr_vp_nodal.py</code></p> <pre><code>import os\nimport sys\n\nimport jax.numpy as jnp\nimport numpy as np\nimport numpy.linalg as la\n\n# Add grandparent directory to path to import examples.plotting\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nimport openscvx as ox\nfrom examples.plotting_viser import (\n    create_animated_plotting_server,\n    create_scp_animated_plotting_server,\n)\nfrom openscvx import Problem\nfrom openscvx.utils import gen_vertices, rot\n\nn = 33  # Number of Nodes\ntotal_time = 30.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 100, 50])\nposition.min = np.array([-200.0, -100, 15])\nposition.initial = np.array([10.0, 0, 20])\nposition.final = [10.0, 0, 20]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\nthrust_force.guess = np.repeat(np.array([[0.0, 0, 10]]), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n\n### Sensor Params ###\nalpha_x = 4.0  # Angle for the x-axis of Sensor Cone\nalpha_y = 4.0  # Angle for the y-axis of Sensor Cone\nA_cone = np.diag(\n    [\n        1 / np.tan(np.pi / alpha_x),\n        1 / np.tan(np.pi / alpha_y),\n        0,\n    ]\n)  # Conic Matrix in Sensor Frame\nc = jnp.array([0, 0, 1])  # Boresight Vector in Sensor Frame\nnorm_type = 2  # Norm Type\nR_sb = jnp.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\n### End Sensor Params ###\n\n\n### Gate Parameters ###\nn_gates = 10\ngate_centers = [\n    np.array([59.436, 0.0000, 20.0000]),\n    np.array([92.964, -23.750, 25.5240]),\n    np.array([92.964, -29.274, 20.0000]),\n    np.array([92.964, -23.750, 20.0000]),\n    np.array([130.150, -23.750, 20.0000]),\n    np.array([152.400, -73.152, 20.0000]),\n    np.array([92.964, -75.080, 20.0000]),\n    np.array([92.964, -68.556, 20.0000]),\n    np.array([59.436, -81.358, 20.0000]),\n    np.array([22.250, -42.672, 20.0000]),\n]\n\nradii = np.array([2.5, 1e-4, 2.5])\nA_gate = rot @ np.diag(1 / radii) @ rot.T\nA_gate_cen = []\nfor center in gate_centers:\n    center[0] = center[0] + 2.5\n    center[2] = center[2] + 2.5\n    A_gate_cen.append(A_gate @ center)\nnodes_per_gate = 3\ngate_nodes = np.arange(nodes_per_gate, n, nodes_per_gate)\nvertices = []\nfor center in gate_centers:\n    vertices.append(gen_vertices(center, radii))\n### End Gate Parameters ###\n\nn_subs = 10\nnp.random.seed(5)\ninit_poses = np.array(\n    [\n        [100.0 + np.random.random() * 20.0, -70.0 + np.random.random() * 20.0, 20.0]\n        for _ in range(n_subs)\n    ]\n)  # Shape: (n_subs, 3)\n\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity, attitude, angular_velocity]\ncontrols = [thrust_force, torque]\n\n\n# Symbolic sensor visibility constraint function\ndef g_vp(p_s_I, x_pos, x_quat):\n    p_s_s = R_sb @ ox.spatial.QDCM(x_quat).T @ (p_s_I - x_pos)\n    return ox.linalg.Norm(A_cone @ p_s_s, ord=norm_type) - (c.T @ p_s_s)\n\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add visibility constraints using Vmap for parallel evaluation\n# Single nodal constraint with vectorized evaluation over all target poses\nvisibility_constraint = (\n    ox.Vmap(\n        lambda pose: g_vp(pose, position, attitude),\n        batch=init_poses,\n    )\n    &lt;= 0.0\n)\nconstraints.append(visibility_constraint)\n\n# Add gate constraints using symbolic expressions\nfor node, cen in zip(gate_nodes, A_gate_cen):\n    A_gate_const = A_gate\n    cen_const = cen\n\n    # Gate constraint: ||A @ pos - c||_inf &lt;= 1\n    gate_constraint = (\n        (ox.linalg.Norm(A_gate_const @ position - cen_const, ord=\"inf\") &lt;= 1.0).convex().at([node])\n    )\n    constraints.append(gate_constraint)\n\n\n# Define dynamics\nm = 1.0  # Mass of the drone\ng_const = -9.81\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n    + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv)\n    @ (torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity),\n}\n\n\n# Initialize initial guess (will be modified by gate logic)\nposition_bar = np.linspace(position.initial, position.final, n)\nvelocity_bar = np.zeros((n, 3))\nattitude_bar = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\nangular_velocity_bar = np.zeros((n, 3))\n\n# Modify position to go through gates\ni = 0\norigins = [position.initial]\nends = []\nfor center in gate_centers:\n    origins.append(center)\n    ends.append(center)\nends.append(position.final)\ngate_idx = 0\nfor _ in range(n_gates + 1):\n    for k in range(n // (n_gates + 1)):\n        position_bar[i] = origins[gate_idx] + (k / (n // (n_gates + 1))) * (\n            ends[gate_idx] - origins[gate_idx]\n        )\n        i += 1\n    gate_idx += 1\n\n# Modify attitude to point sensor at targets\nR_sb = R_sb  # Sensor to body frame\nb = R_sb @ np.array([0, 1, 0])\nmean_target = np.mean(init_poses, axis=0)  # Average target position\nfor k in range(n):\n    a = mean_target - position_bar[k]\n    # Determine the direction cosine matrix that aligns the z-axis of the sensor frame with the\n    # relative position vector\n    q_xyz = np.cross(b, a)\n    q_w = np.sqrt(la.norm(a) ** 2 + la.norm(b) ** 2) + np.dot(a, b)\n    q_no_norm = np.hstack((q_w, q_xyz))\n    q = q_no_norm / la.norm(q_no_norm)\n    attitude_bar[k] = q\n\n# Set all guesses\nposition.guess = position_bar\nvelocity.guess = velocity_bar\nattitude.guess = attitude_bar\nangular_velocity.guess = angular_velocity_bar\n\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n\nproblem.settings.prp.dt = 0.1\n\nproblem.settings.scp.w_tr = 8e1  # Weight on the Trust Reigon\nproblem.settings.scp.lam_cost = 2e1  # Weight on the Minimal Time Objective\nproblem.settings.scp.lam_vc = (\n    1e2  # Weight on the Virtual Control Objective (not including CTCS Augmentation)\n)\nproblem.settings.scp.lam_vb = (\n    4e0  # Weight on the Virtual Control Objective (not including CTCS Augmentation)\n)\nproblem.settings.scp.ep_tr = 1e-3  # Trust Region Tolerance\nproblem.settings.scp.ep_vb = 1e-4  # Virtual Control Tolerance\nproblem.settings.scp.ep_vc = 1e-8  # Virtual Control Tolerance\nproblem.settings.scp.cost_drop = 10  # SCP iteration to relax minimal final time objective\nproblem.settings.scp.cost_relax = 0.8  # Minimal Time Relaxation Factor\nproblem.settings.scp.w_tr_adapt = 1.05  # Trust Region Adaptation Factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e2  # Maximum Trust Region Weight\n\nplotting_dict = {\n    \"vertices\": vertices,\n    \"n_subs\": n_subs,\n    \"alpha_x\": alpha_x,\n    \"alpha_y\": alpha_y,\n    \"R_sb\": R_sb,\n    \"init_poses\": init_poses,\n    \"norm_type\": norm_type,\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update_plotting_data(**plotting_dict)\n\n    # Create both visualization servers (viser auto-assigns ports)\n    traj_server = create_animated_plotting_server(\n        results,\n        thrust_key=\"thrust_force\",\n        show_control_plot=\"thrust_force\",\n        show_control_norm_plot=\"thrust_force\",\n        viewcone_scale=10.0,\n    )\n    scp_server = create_scp_animated_plotting_server(\n        results,\n        attitude_stride=3,\n        frame_duration_ms=200,\n    )\n\n    # Keep both servers running\n    traj_server.sleep_forever()\n</code></pre>"},{"location":"examples/drone/dr_vp_polytope/","title":"Dr Vp Polytope","text":"<p>Drone racing with continuous viewpoint constraints using polytope target arrangement.</p> <p>This example demonstrates drone racing through polytope (polyhedron-shaped) gates with sensor visibility constraints. The problem includes:</p> <ul> <li>6-DOF rigid body dynamics (position, velocity, attitude quaternion, angular velocity)</li> <li>Sequential gate passage constraints</li> <li>Attitude planning for simultaneous gate navigation and visual tracking</li> <li>Continuous sensor visibility constraints to keep targets in FOV</li> <li>Viewplanning targets are arranged in a polytope</li> <li>Minimal time objective</li> </ul> <p>File: <code>examples/drone/dr_vp_polytope.py</code></p> <pre><code>import os\nimport sys\n\nimport jax.numpy as jnp\nimport numpy as np\nimport numpy.linalg as la\n\n# Add grandparent directory to path to import examples.plotting\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nimport openscvx as ox\nfrom examples.plotting_viser import (\n    create_animated_plotting_server,\n    create_scp_animated_plotting_server,\n)\nfrom openscvx import Problem\nfrom openscvx.utils import gen_vertices, rot\n\nn = 33  # Number of Nodes\ntotal_time = 30.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 100, 50])\nposition.min = np.array([-200.0, -100, 15])\nposition.initial = np.array([10.0, 0, 20])\nposition.final = [10.0, 0, 20]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\nthrust_force.guess = np.repeat(np.array([[0.0, 0, 10]]), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n\n### Sensor Params ###\nalpha_x = 6.0  # Angle for the x-axis of Sensor Cone\nalpha_y = 6.0  # Angle for the y-axis of Sensor Cone\nA_cone = np.diag(\n    [\n        1 / np.tan(np.pi / alpha_x),\n        1 / np.tan(np.pi / alpha_y),\n        0,\n    ]\n)  # Conic Matrix in Sensor Frame\nc = jnp.array([0, 0, 1])  # Boresight Vector in Sensor Frame\nnorm_type = 2  # Norm Type\nR_sb = jnp.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\n### End Sensor Params ###\n\nn_subs = 10\npolytope_point = np.array(\n    [\n        [95.38, -54.62, 15.38],\n        [95.38, -54.62, 24.62],\n        [95.38, -45.38, 15.38],\n        [95.38, -45.38, 24.62],\n        [104.62, -54.62, 15.38],\n        [104.62, -54.62, 24.62],\n        [104.62, -45.38, 15.38],\n        [104.62, -45.38, 24.62],\n        [100.00, -52.85, 12.53],\n        [100.00, -52.85, 27.47],\n        [100.00, -47.15, 12.53],\n        [100.00, -47.15, 27.47],\n        [97.15, -57.47, 20.00],\n        [97.15, -42.53, 20.00],\n        [102.85, -57.47, 20.00],\n        [102.85, -42.53, 20.00],\n        [92.53, -50.00, 17.15],\n        [92.53, -50.00, 22.85],\n        [107.47, -50.00, 17.15],\n        [107.47, -50.00, 22.85],\n    ]\n)\ninit_poses = polytope_point  # Shape: (20, 3)\n### Gate Parameters ###\nn_gates = 10\ngate_centers = [\n    np.array([59.436, 0.0000, 20.0000]),\n    np.array([92.964, -23.750, 25.5240]),\n    np.array([92.964, -29.274, 20.0000]),\n    np.array([92.964, -23.750, 20.0000]),\n    np.array([130.150, -23.750, 20.0000]),\n    np.array([152.400, -73.152, 20.0000]),\n    np.array([92.964, -75.080, 20.0000]),\n    np.array([92.964, -68.556, 20.0000]),\n    np.array([59.436, -81.358, 20.0000]),\n    np.array([22.250, -42.672, 20.0000]),\n]\nradii = np.array([2.5, 1e-4, 2.5])\nA_gate = rot @ np.diag(1 / radii) @ rot.T\nA_gate_cen = []\nfor center in gate_centers:\n    center[0] = center[0] + 2.5\n    center[2] = center[2] + 2.5\n    A_gate_cen.append(A_gate @ center)\nnodes_per_gate = 3\ngate_nodes = np.arange(nodes_per_gate, n, nodes_per_gate)\nvertices = []\nfor center in gate_centers:\n    vertices.append(gen_vertices(center, radii))\n\n\n### End Gate Parameters ###\n\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity, attitude, angular_velocity]\ncontrols = [thrust_force, torque]\n\n\n# Symbolic sensor visibility constraint function\ndef g_vp(p_s_I, x_pos, x_quat):\n    p_s_s = R_sb @ ox.spatial.QDCM(x_quat).T @ (p_s_I - x_pos)\n    return ox.linalg.Norm(A_cone @ p_s_s, ord=norm_type) - (c.T @ p_s_s)\n\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add visibility constraints using Vmap for parallel evaluation\n# Single CTCS constraint with vectorized evaluation over all polytope points\nvisibility_constraint = ox.ctcs(\n    ox.Vmap(\n        lambda pose: g_vp(pose, position, attitude),\n        batch=init_poses,\n    )\n    &lt;= 0.0\n)\nconstraints.append(visibility_constraint)\n\n# Add gate constraints using symbolic expressions\nfor node, cen in zip(gate_nodes, A_gate_cen):\n    A_gate_const = A_gate\n    cen_const = cen\n\n    # Gate constraint: ||A @ pos - c||_inf &lt;= 1\n    gate_constraint = (\n        (ox.linalg.Norm(A_gate_const @ position - cen_const, ord=\"inf\") &lt;= 1.0).convex().at([node])\n    )\n    constraints.append(gate_constraint)\n\n\n# Create symbolic dynamics\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n    + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv)\n    @ (torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity),\n}\n\n\n# Initialize initial guess (will be modified by gate logic)\nposition_bar = np.linspace(position.initial, position.final, n)\nvelocity_bar = np.zeros((n, 3))\nattitude_bar = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\nangular_velocity_bar = np.zeros((n, 3))\n\n# Modify position to go through gates\ni = 0\norigins = [position.initial]\nends = []\nfor center in gate_centers:\n    origins.append(center)\n    ends.append(center)\nends.append(position.final)\ngate_idx = 0\nfor _ in range(n_gates + 1):\n    for k in range(n // (n_gates + 1)):\n        position_bar[i] = origins[gate_idx] + (k / (n // (n_gates + 1))) * (\n            ends[gate_idx] - origins[gate_idx]\n        )\n        i += 1\n    gate_idx += 1\n\n# Modify attitude to point sensor at targets\nR_sb = R_sb  # Sensor to body frame\nb = R_sb @ np.array([0, 1, 0])\nmean_target = np.mean(init_poses, axis=0)  # Average target position\nfor k in range(n):\n    a = mean_target - position_bar[k]\n    # Determine the direction cosine matrix that aligns the z-axis of the sensor frame with the\n    # relative position vector\n    q_xyz = np.cross(b, a)\n    q_w = np.sqrt(la.norm(a) ** 2 + la.norm(b) ** 2) + np.dot(a, b)\n    q_no_norm = np.hstack((q_w, q_xyz))\n    q = q_no_norm / la.norm(q_no_norm)\n    attitude_bar[k] = q\n\n# Set all guesses\nposition.guess = position_bar\nvelocity.guess = velocity_bar\nattitude.guess = attitude_bar\nangular_velocity.guess = angular_velocity_bar\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n\nproblem.settings.prp.dt = 0.01\n\nproblem.settings.scp.k_max = 50\nproblem.settings.scp.w_tr = 2e0  # 2e0,  # Weight on the Trust Reigon\nproblem.settings.scp.lam_cost = 2e-1  # 0e-1,  # Weight on the Minimal Time Objective\nproblem.settings.scp.lam_vc = (\n    1e1  # 1e1,  # Weight on the Virtual Control Objective (not including CTCS Augmentation)\n)\nproblem.settings.scp.ep_tr = 1e-5  # Trust Region Tolerance\nproblem.settings.scp.ep_vb = 1e-4  # Virtual Control Tolerance\nproblem.settings.scp.ep_vc = 1e-8  # Virtual Control Tolerance for CTCS\nproblem.settings.scp.cost_drop = 10  # SCP iteration to relax minimal final time objective\nproblem.settings.scp.cost_relax = 0.8  # Minimal Time Relaxation Factor\nproblem.settings.scp.w_tr_adapt = 1.2  # Trust Region Adaptation Factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e2  # Maximum Trust Region Weight\nplotting_dict = {\n    \"vertices\": vertices,\n    \"n_subs\": n_subs,\n    \"alpha_x\": alpha_x,\n    \"alpha_y\": alpha_y,\n    \"R_sb\": R_sb,\n    \"init_poses\": init_poses,\n    \"norm_type\": norm_type,\n}\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n    results.update(plotting_dict)\n\n    # Create both visualization servers (viser auto-assigns ports)\n    traj_server = create_animated_plotting_server(\n        results,\n        thrust_key=\"thrust_force\",\n        viewcone_scale=10.0,\n        show_control_plot=\"thrust_force\",\n        show_control_norm_plot=\"thrust_force\",\n    )\n    scp_server = create_scp_animated_plotting_server(\n        results,\n        attitude_stride=3,\n        frame_duration_ms=200,\n    )\n\n    # Keep both servers running\n    traj_server.sleep_forever()\n</code></pre>"},{"location":"examples/drone/drone_racing/","title":"Drone Racing","text":"<p>6-DOF quadrotor racing through sequential gates.</p> <p>This example demonstrates time-optimal trajectory planning for a quadrotor racing through a series of gates in a specified order. The problem includes:</p> <ul> <li>6-DOF rigid body dynamics (position, velocity, attitude quaternion, angular velocity)</li> <li>Nodal constraints enforcing gate traversal at sequential nodes</li> <li>Minimal time objective</li> <li>Loop closure (start equals end position)</li> </ul> <p>File: <code>examples/drone/drone_racing.py</code></p> <pre><code>import os\nimport sys\n\nimport jax.numpy as jnp\nimport numpy as np\n\n# Add grandparent directory to path to import examples.plotting\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nimport openscvx as ox\nfrom examples.plotting_viser import (\n    create_animated_plotting_server,\n    create_scp_animated_plotting_server,\n)\nfrom openscvx import Problem\nfrom openscvx.utils import gen_vertices, rot\n\nn = 22  # Number of Nodes\ntotal_time = 24.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 100, 200])\nposition.min = np.array([-200.0, -100, 15])\nposition.initial = np.array([10.0, 0, 20])\nposition.final = [10.0, 0, 20]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\nthrust_force.guess = np.repeat(np.array([[0.0, 0, 10]]), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n\n### Gate Parameters ###\nn_gates = 10\n\n# Initialize gate centers\ninitial_gate_centers = [\n    np.array([59.436, 0.000, 20.0000]),\n    np.array([92.964, -23.750, 25.5240]),\n    np.array([92.964, -29.274, 20.0000]),\n    np.array([92.964, -23.750, 20.0000]),\n    np.array([130.150, -23.750, 20.0000]),\n    np.array([152.400, -73.152, 20.0000]),\n    np.array([92.964, -75.080, 20.0000]),\n    np.array([92.964, -68.556, 20.0000]),\n    np.array([59.436, -81.358, 20.0000]),\n    np.array([22.250, -42.672, 20.0000]),\n]\n\n# Set initial values for gate center parameters and A_gate_c_params\nradii = np.array([2.5, 1e-4, 2.5])\nA_gate = rot @ np.diag(1 / radii) @ rot.T\n\n# Create modified centers (matching original behavior exactly)\nmodified_centers = []\nfor center in initial_gate_centers:\n    modified_center = center.copy()\n    modified_center[0] = modified_center[0] + 2.5\n    modified_center[2] = modified_center[2] + 2.5\n    modified_centers.append(modified_center)\n\n# Create symbolic parameters for each gate center with initial values\nA_gate_const = A_gate\ngate_center_params = []\nfor i, modified_center in enumerate(modified_centers):\n    # Create a Parameter with initial value\n    param = ox.Parameter(f\"gate_{i}_center\", shape=(3,), value=modified_center)\n    gate_center_params.append(param)\n\nnodes_per_gate = 2\ngate_nodes = np.arange(nodes_per_gate, n, nodes_per_gate)\nvertices = []\nfor modified_center in modified_centers:  # Use modified centers for vertices\n    vertices.append(gen_vertices(modified_center, radii))\n### End Gate Parameters ###\n\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity, attitude, angular_velocity]\ncontrols = [thrust_force, torque]\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add gate constraints\nfor node, gate_center_param in zip(gate_nodes, gate_center_params):\n    # Symbolically compute A_gate @ position - A_gate @ gate_center\n    gate_constraint = (\n        (\n            ox.linalg.Norm(A_gate_const @ position - A_gate_const @ gate_center_param, ord=\"inf\")\n            &lt;= 1.0\n        )\n        .convex()\n        .at([node])\n    )\n    constraints.append(gate_constraint)\n\n\n# Define symbolic utility functions\ndef symbolic_qdcm(q):\n    \"\"\"Quaternion to Direction Cosine Matrix conversion using symbolic expressions\"\"\"\n    # Normalize quaternion\n    q_norm = ox.Sqrt(ox.Sum(q * q))\n    q_normalized = q / q_norm\n\n    w, x, y, z = q_normalized[0], q_normalized[1], q_normalized[2], q_normalized[3]\n\n    # Create DCM elements and assemble into 3x3 matrix\n    return ox.Block(\n        [\n            [1.0 - 2.0 * (y * y + z * z), 2.0 * (x * y - z * w), 2.0 * (x * z + y * w)],\n            [2.0 * (x * y + z * w), 1.0 - 2.0 * (x * x + z * z), 2.0 * (y * z - x * w)],\n            [2.0 * (x * z - y * w), 2.0 * (y * z + x * w), 1.0 - 2.0 * (x * x + y * y)],\n        ]\n    )\n\n\ndef symbolic_ssmp(w):\n    \"\"\"Angular rate to 4x4 skew symmetric matrix for quaternion dynamics\"\"\"\n    x, y, z = w[0], w[1], w[2]\n\n    return ox.Block(\n        [\n            [0.0, -x, -y, -z],\n            [x, 0.0, z, -y],\n            [y, -z, 0.0, x],\n            [z, y, -x, 0.0],\n        ]\n    )\n\n\ndef symbolic_ssm(w):\n    \"\"\"Angular rate to 3x3 skew symmetric matrix\"\"\"\n    x, y, z = w[0], w[1], w[2]\n\n    return ox.Block(\n        [\n            [0.0, -z, y],\n            [z, 0.0, -x],\n            [-y, x, 0.0],\n        ]\n    )\n\n\ndef symbolic_diag(v):\n    \"\"\"Create diagonal matrix from vector\"\"\"\n    if len(v) == 3:\n        return ox.Block(\n            [\n                [v[0], 0.0, 0.0],\n                [0.0, v[1], 0.0],\n                [0.0, 0.0, v[2]],\n            ]\n        )\n    else:\n        raise NotImplementedError(\"Only 3x3 diagonal matrices supported\")\n\n\n# Create symbolic dynamics\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Option 1: Full symbolic dynamics (more flexible but potentially slower)\n# r_dot = velocity\n# v_dot = (Constant(1.0 / m)) * symbolic_qdcm(attitude) @ thrust_force + Constant(\n#     np.array([0, 0, g_const], dtype=np.float64)\n# )\n# q_dot = Constant(0.5) * symbolic_ssmp(angular_velocity) @ attitude\n# J_b_inv = Constant(1.0 / J_b)\n# J_b_diag = symbolic_diag([Constant(J_b[0]), Constant(J_b[1]), Constant(J_b[2])])\n# w_dot = symbolic_diag([J_b_inv[0], J_b_inv[1], J_b_inv[2]]) @ (\n#     torque - symbolic_ssm(angular_velocity) @ J_b_diag @ angular_velocity\n# )\n\n# Option 2: Efficient dynamics using direct JAX lowering (better performance)\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n    + ox.Constant(np.array([0, 0, g_const], dtype=np.float64)),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv)\n    @ (torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity),\n}\n\n\n# Generate initial guess for position trajectory through gates\nposition_bar = np.linspace(position.initial, position.final, n)\n\ni = 0\norigins = [position.initial]\nends = []\nfor center in modified_centers:  # Use modified centers for initial guess\n    origins.append(center)\n    ends.append(center)\nends.append(position.final)\ngate_idx = 0\nfor _ in range(n_gates + 1):\n    for k in range(n // (n_gates + 1)):\n        position_bar[i] = origins[gate_idx] + (k / (n // (n_gates + 1))) * (\n            ends[gate_idx] - origins[gate_idx]\n        )\n        i += 1\n    gate_idx += 1\n\nposition.guess = position_bar\n\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n    # licq_max=1E-8\n)\n\nproblem.settings.prp.dt = 0.01\n\nproblem.settings.scp.w_tr = 2e0  # Weight on the Trust Reigon\nproblem.settings.scp.lam_cost = 1e-1  # 0e-1,  # Weight on the Minimal Time Objective\nproblem.settings.scp.lam_vc = (\n    1e1  # 1e1,  # Weight on the Virtual Control Objective (not including CTCS Augmentation)\n)\nproblem.settings.scp.ep_tr = 1e-3  # Trust Region Tolerance\nproblem.settings.scp.ep_vb = 1e-4  # Virtual Control Tolerance\nproblem.settings.scp.ep_vc = 1e-8  # Virtual Control Tolerance for CTCS\n# problem.settings.scp.cost_drop = 10  # SCP iteration to relax minimal final time objective\n# problem.settings.scp.cost_relax = 0.8  # Minimal Time Relaxation Factor\nproblem.settings.scp.w_tr_adapt = 1.4  # Trust Region Adaptation Factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e2  # Maximum Trust Region Weight\n\nplotting_dict = {\n    \"vertices\": vertices,\n    \"gate_centers\": modified_centers,\n    \"A_gate\": A_gate_const,\n    \"A_gate_c_params\": [A_gate @ center for center in modified_centers],\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update(plotting_dict)\n\n    # Create both visualization servers (viser auto-assigns ports)\n    traj_server = create_animated_plotting_server(\n        results,\n        thrust_key=\"thrust_force\",\n        viewcone_scale=10.0,\n        show_control_plot=\"thrust_force\",\n        show_control_norm_plot=\"thrust_force\",\n    )\n    scp_server = create_scp_animated_plotting_server(\n        results,\n        attitude_stride=3,\n        frame_duration_ms=200,\n    )\n\n    # Keep both servers running\n    traj_server.sleep_forever()\n</code></pre>"},{"location":"examples/drone/obstacle_avoidance/","title":"Obstacle Avoidance","text":"<p>6-DOF quadrotor obstacle avoidance with ellipsoidal obstacles.</p> <p>This example demonstrates optimal trajectory planning for a quadrotor navigating through multiple ellipsoidal obstacles which are enforced in continuous time. The problem includes:</p> <ul> <li>6-DOF rigid body dynamics (position, velocity, attitude quaternion, angular velocity)</li> <li>Thrust force and torque control inputs</li> <li>Continuous ellipsoidal obstacle avoidance constraints</li> <li>Minimal time objective</li> </ul> <p>File: <code>examples/drone/obstacle_avoidance.py</code></p> <pre><code>import os\nimport sys\n\nimport jax.numpy as jnp\nimport numpy as np\n\n# Add grandparent directory to path to import examples.plotting\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nimport openscvx as ox\nfrom examples.plotting_viser import (\n    create_animated_plotting_server,\n    create_scp_animated_plotting_server,\n)\nfrom openscvx import Problem\nfrom openscvx.utils import generate_orthogonal_unit_vectors\n\nn = 6\ntotal_time = 4.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 10, 20])\nposition.min = np.array([-200.0, -100, 0])\nposition.initial = np.array([10.0, 0, 2])\nposition.final = [-10.0, 0, 2]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\ninitial_control = np.array([0.0, 0.0, thrust_force.max[2]])\nthrust_force.guess = np.repeat(np.expand_dims(initial_control, axis=0), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity, attitude, angular_velocity]\ncontrols = [thrust_force, torque]\n\n\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n    + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv)\n    @ (torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity),\n}\n\n\nA_obs = []\nradius = []\naxes = []\n\n# Default values for the obstacle centers\nobstacle_center_positions = [\n    np.array([-5.1, 0.1, 2]),\n    np.array([0.1, 0.1, 2]),\n    np.array([5.1, 0.1, 2]),\n]\n\n# Define obstacle centers as parameters for runtime updates\nobstacle_centers = [\n    ox.Parameter(\"obstacle_center_1\", shape=(3,), value=obstacle_center_positions[0]),\n    ox.Parameter(\"obstacle_center_2\", shape=(3,), value=obstacle_center_positions[1]),\n    ox.Parameter(\"obstacle_center_3\", shape=(3,), value=obstacle_center_positions[2]),\n]\n\nnp.random.seed(0)\nfor _ in obstacle_center_positions:\n    ax = generate_orthogonal_unit_vectors()\n    axes.append(generate_orthogonal_unit_vectors())\n    rad = np.random.rand(3) + 0.1 * np.ones(3)\n    radius.append(rad)\n    A_obs.append(ax @ np.diag(rad**2) @ ax.T)\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add obstacle constraints using symbolic expressions\nfor center, A in zip(obstacle_centers, A_obs):\n    A_const = A\n\n    # Obstacle constraint: (pos - center)^T @ A @ (pos - center) &gt;= 1\n    diff = position - center\n    obstacle_constraint = ox.ctcs(1.0 &lt;= diff.T @ A_const @ diff)\n    constraints.append(obstacle_constraint)\n\n\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n\nproblem.settings.prp.dt = 0.001\nproblem.settings.scp.lam_vb = 1e0\nproblem.settings.scp.w_tr_adapt = 1.8\nproblem.settings.scp.w_tr = 1e1\nproblem.settings.scp.lam_cost = 1e1  # Weight on the Nonlinear Cost\nproblem.settings.scp.lam_vc = 1e2  # Weight on the Virtual Control Objective\nproblem.settings.scp.cost_drop = 4  # SCP iteration to relax minimal final time objective\nproblem.settings.scp.cost_relax = 0.5  # Minimal Time Relaxation Factor\n\nplotting_dict = {\n    \"obstacles_centers\": obstacle_center_positions,\n    \"obstacles_axes\": axes,\n    \"obstacles_radii\": radius,\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update(plotting_dict)\n\n    # Create both visualization servers (viser auto-assigns ports)\n    traj_server = create_animated_plotting_server(\n        results,\n        thrust_key=\"thrust_force\",\n        viewcone_scale=10.0,\n    )\n    scp_server = create_scp_animated_plotting_server(\n        results,\n        attitude_stride=3,\n        frame_duration_ms=200,\n    )\n\n    # Keep both servers running\n    traj_server.sleep_forever()\n</code></pre>"},{"location":"examples/drone/obstacle_avoidance_nodal/","title":"Obstacle Avoidance Nodal","text":"<p>6-DOF quadrotor obstacle avoidance with nodal constraints.</p> <p>This example demonstrates optimal trajectory planning for a quadrotor with obstacle avoidance constraints applied at specific nodes. The problem includes:</p> <ul> <li>6-DOF rigid body dynamics (position, velocity, attitude quaternion, angular velocity)</li> <li>Thrust force and torque control inputs</li> <li>Nodal obstacle avoidance constraints at specific trajectory points</li> <li>Minimal time objective</li> </ul> <p>File: <code>examples/drone/obstacle_avoidance_nodal.py</code></p> <pre><code>import os\nimport sys\n\nimport jax.numpy as jnp\nimport numpy as np\n\n# Add grandparent directory to path to import examples.plotting\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nimport openscvx as ox\nfrom examples.plotting_viser import (\n    create_animated_plotting_server,\n    create_scp_animated_plotting_server,\n)\nfrom openscvx import Problem\nfrom openscvx.utils import generate_orthogonal_unit_vectors\n\nn = 6\ntotal_time = 4.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 10, 20])\nposition.min = np.array([-200.0, -100, 0])\nposition.initial = np.array([10.0, 0, 2])\nposition.final = [-10.0, 0, 2]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\ninitial_control = np.array([0.0, 0.0, 50.0])\nthrust_force.guess = np.repeat(np.expand_dims(initial_control, axis=0), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity, attitude, angular_velocity]\ncontrols = [thrust_force, torque]\n\n\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n    + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv)\n    @ (torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity),\n}\n\n\nA_obs = []\nradius = []\naxes = []\n\n# Default values for the obstacle centers\nobstacle_center_positions = [\n    np.array([-5.1, 0.1, 2]),\n    np.array([0.1, 0.1, 2]),\n    np.array([5.1, 0.1, 2]),\n]\n\n# Define obstacle centers as parameters for runtime updates\nobstacle_centers = [\n    ox.Parameter(\"obstacle_center_1\", shape=(3,), value=obstacle_center_positions[0]),\n    ox.Parameter(\"obstacle_center_2\", shape=(3,), value=obstacle_center_positions[1]),\n    ox.Parameter(\"obstacle_center_3\", shape=(3,), value=obstacle_center_positions[2]),\n]\n\nnp.random.seed(0)\nfor _ in obstacle_center_positions:\n    ax = generate_orthogonal_unit_vectors()\n    axes.append(generate_orthogonal_unit_vectors())\n    rad = np.random.rand(3) + 0.1 * np.ones(3)\n    radius.append(rad)\n    A_obs.append(ax @ np.diag(rad**2) @ ax.T)\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add obstacle constraints using symbolic expressions (as nodal constraints)\nfor center, A in zip(obstacle_centers, A_obs):\n    A_const = A\n\n    # Obstacle constraint: (pos - center)^T @ A @ (pos - center) &gt;= 1\n    diff = position - center\n    obstacle_constraint = 1.0 &lt;= diff.T @ A_const @ diff\n    constraints.append(obstacle_constraint)\n\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n\nproblem.settings.prp.dt = 0.01\nproblem.settings.scp.lam_vb = 1e0\nproblem.settings.scp.cost_drop = 4  # SCP iteration to relax minimal final time objective\nproblem.settings.scp.cost_relax = 0.5  # Minimal Time Relaxation Factor\n\nplotting_dict = {\n    \"obstacles_centers\": obstacle_center_positions,\n    \"obstacles_axes\": axes,\n    \"obstacles_radii\": radius,\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update(plotting_dict)\n\n    # Create both visualization servers (viser auto-assigns ports)\n    traj_server = create_animated_plotting_server(\n        results,\n        thrust_key=\"thrust_force\",\n        viewcone_scale=10.0,\n    )\n    scp_server = create_scp_animated_plotting_server(\n        results,\n        attitude_stride=3,\n        frame_duration_ms=200,\n    )\n\n    # Keep both servers running\n    traj_server.sleep_forever()\n</code></pre>"},{"location":"examples/drone/obstacle_avoidance_realtime_base/","title":"Obstacle Avoidance Realtime Base","text":"<p>Base problem setup for real-time 6-DOF obstacle avoidance.</p> <p>This module defines the base optimization problem for real-time quadrotor obstacle avoidance, designed to be imported by interactive visualization examples. The problem includes:</p> <ul> <li>6-DOF dynamics (position, velocity, attitude quaternion, angular velocity)</li> <li>Parametric obstacle positions for runtime updates</li> <li>Ellipsoidal obstacle avoidance constraints</li> <li>Configured for real-time re-optimization</li> </ul> <p>File: <code>examples/drone/obstacle_avoidance_realtime_base.py</code></p> <pre><code>import os\nimport sys\n\nimport jax.numpy as jnp\nimport numpy as np\n\n# Add grandparent directory to path to import examples.plotting\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nimport openscvx as ox\nfrom examples.plotting_viser import (\n    create_animated_plotting_server,\n    create_scp_animated_plotting_server,\n)\nfrom openscvx import Problem\nfrom openscvx.utils import generate_orthogonal_unit_vectors\n\nn = 6\ntotal_time = 4.0  # Total time for the simulation\n\n# Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 10, 20])\nposition.min = np.array([-200.0, -100, 0])\nposition.initial = np.array([10.0, 0, 2])\nposition.final = np.array([-10.0, 0, 2])\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\ninitial_control = np.array([0.0, 0.0, thrust_force.max[2]])\nthrust_force.guess = np.repeat(np.expand_dims(initial_control, axis=0), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n\n# Define list of all states (needed for Problem and constraints)\nstates = [position, velocity, attitude, angular_velocity]\ncontrols = [thrust_force, torque]\n\n\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of Inertia of the drone\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n    + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv)\n    @ (torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity),\n}\n\n\nA_obs = []\nradius = []\naxes = []\n\n# Default values for the obstacle centers\nobstacle_center_positions = [\n    np.array([-5.1, 0.1, 2]),\n    np.array([0.1, 0.1, 2]),\n    np.array([5.1, 0.1, 2]),\n]\n\n# Define obstacle centers as parameters for runtime updates\nobstacle_centers = [\n    ox.Parameter(\"obstacle_center_1\", shape=(3,), value=obstacle_center_positions[0]),\n    ox.Parameter(\"obstacle_center_2\", shape=(3,), value=obstacle_center_positions[1]),\n    ox.Parameter(\"obstacle_center_3\", shape=(3,), value=obstacle_center_positions[2]),\n]\n\nnp.random.seed(0)\nfor _ in obstacle_center_positions:\n    ax = generate_orthogonal_unit_vectors()\n    axes.append(generate_orthogonal_unit_vectors())\n    rad = np.random.rand(3) + 0.1 * np.ones(3)\n    radius.append(rad)\n    A_obs.append(ax @ np.diag(rad**2) @ ax.T)\n\n# Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add obstacle constraints using symbolic expressions\nfor center, A in zip(obstacle_centers, A_obs):\n    A_const = A\n\n    # Obstacle constraint: (pos - center)^T @ A @ (pos - center) &gt;= 1\n    diff = position - center\n    obstacle_constraint = ox.ctcs(1.0 &lt;= diff.T @ A_const @ diff)\n    constraints.append(obstacle_constraint)\n\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n    time_dilation_factor_min=0.2,\n)\n\nproblem.settings.scp.w_tr_adapt = 1\nproblem.settings.scp.w_tr = 4e0\nproblem.settings.scp.lam_cost = 4e-2  # Weight on the Nonlinear Cost\nproblem.settings.scp.lam_vc = 1e2  # Weight on the Virtual Control Objective\nproblem.settings.prp.dt = 0.01\n\nplotting_dict = {\n    \"obstacles_centers\": obstacle_center_positions,\n    \"obstacles_axes\": axes,\n    \"obstacles_radii\": radius,\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    results.update(plotting_dict)\n\n    # Create both visualization servers (viser auto-assigns ports)\n    traj_server = create_animated_plotting_server(\n        results,\n        thrust_key=\"thrust_force\",\n        viewcone_scale=10.0,\n    )\n    scp_server = create_scp_animated_plotting_server(\n        results,\n        attitude_stride=3,\n        frame_duration_ms=200,\n    )\n\n    # Keep both servers running\n    traj_server.sleep_forever()\n</code></pre>"},{"location":"examples/drone/obstacle_avoidance_vmap/","title":"Obstacle Avoidance Vmap","text":"<p>Double integrator obstacle avoidance with Vmap for parallel constraint evaluation.</p> <p>This example demonstrates using ox.Vmap directly in constraints for data-parallel obstacle avoidance with numerous spherical obstacles.</p> <p>The approach:</p> <ol> <li>Stack all obstacle centers into a single array</li> <li>Use Vmap directly in the constraint to compute distances in parallel</li> <li>The vector-valued constraint is enforced element-wise</li> </ol> <p>Compare with:   - obstacle_avoidance.py (manual loop over 3 obstacles)</p> <p>File: <code>examples/drone/obstacle_avoidance_vmap.py</code></p> <pre><code>import os\nimport sys\n\nimport numpy as np\n\n# Add grandparent directory to path to import examples.plotting\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nimport openscvx as ox\nfrom examples.plotting_viser import (\n    create_animated_plotting_server,\n    create_scp_animated_plotting_server,\n)\nfrom openscvx import Problem\n\nn = 6  # Number of nodes\ntotal_time = 10.0  # Total time for the simulation\n\n# =============================================================================\n# State and Control Definitions\n# =============================================================================\n\n# 3D position\nposition = ox.State(\"position\", shape=(3,))\nposition.max = np.array([15.0, 15.0, 15.0])\nposition.min = np.array([-15.0, -15.0, 0.0])\nposition.initial = np.array([-10.0, -10.0, 2.0])\nposition.final = np.array([10.0, 10.0, 2.0])\n\n# 3D velocity\nvelocity = ox.State(\"velocity\", shape=(3,))\nvelocity.max = np.array([10.0, 10.0, 10.0])\nvelocity.min = np.array([-10.0, -10.0, -10.0])\nvelocity.initial = np.array([0.0, 0.0, 0.0])\nvelocity.final = [(\"free\", 0.0), (\"free\", 0.0), (\"free\", 0.0)]\n\n# Control force\nforce = ox.Control(\"force\", shape=(3,))\nf_max = 20.0\nforce.max = np.array([f_max, f_max, f_max])\nforce.min = np.array([-f_max, -f_max, -f_max])\n\n# Physical parameters\nm = 1.0  # Mass\ng = -9.81  # Gravity\n\n# =============================================================================\n# Obstacle Configuration (3D grid)\n# =============================================================================\n\nobstacle_radius_min, obstacle_radius_max = 1.0, 2.5\n\n# Generate obstacle positions in a 3D grid pattern between start and goal\nnp.random.seed(42)\nobstacle_centers = []\n\n# Tweak number of obstacles by changing the grid sizes\nn_rows = 4\nn_cols = 4\nn_lays = 4\n\n# Create a 3D field of obstacles: rows (x) x columns (y) x layers (z)\nfor i in range(n_rows):\n    for j in range(n_cols):\n        for k in range(n_lays):\n            # Base grid position\n            x = -6.0 + i * 6.0\n            y = -7.5 + j * 5.0\n            z = 1.0 + k * 2.5  # Layers at z = 1.0, 3.5, 6.0\n            # Add some randomness\n            x += np.random.uniform(-1.0, 1.0)\n            y += np.random.uniform(-1.0, 1.0)\n            z += np.random.uniform(-0.5, 0.5)\n            obstacle_centers.append([x, y, z])\n\nn_obstacles = len(obstacle_centers)  # 36 obstacles\n\nobstacle_centers = np.array(obstacle_centers)  # Shape: (n_obstacles, 3)\nobstacle_radii = np.random.uniform(obstacle_radius_min, obstacle_radius_max, size=n_obstacles)\n\nprint(f\"Created {n_obstacles} obstacles\")\nprint(f\"Obstacle centers shape: {obstacle_centers.shape}\")\n\n# =============================================================================\n# Dynamics (simple double integrator)\n# =============================================================================\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * force + np.array([0.0, 0.0, g]),\n}\n\n# =============================================================================\n# Constraints\n# =============================================================================\n\nstates = [position, velocity]\ncontrols = [force]\n\nconstraints = []\n\n# Box constraints on states\nfor state in states:\n    constraints.extend(\n        [\n            ox.ctcs(state &lt;= state.max),\n            ox.ctcs(state.min &lt;= state),\n        ]\n    )\n\n# Box constraints on controls\nconstraints.extend(\n    [\n        force &lt;= force.max,\n        force.min &lt;= force,\n    ]\n)\n\n# =============================================================================\n# Obstacle Avoidance\n# =============================================================================\n# Two approaches are shown below for benchmarking. Comment/uncomment to toggle.\n\n# --- APPROACH 1: Vmap (single constraint, vectorized) ---\n# - Single CTCS constraint with vectorized evaluation\n# - Vmap computes distance to all obstacles in parallel\n\nobstacle_avoidance = ox.ctcs(\n    obstacle_radii\n    &lt;= ox.Vmap(\n        lambda obs_center: ox.linalg.Norm(position - obs_center),\n        batch=obstacle_centers,\n    )\n)\nconstraints.append(obstacle_avoidance)\n\n# --- APPROACH 2: Individual constraints (loop, no vmap) ---\n# - Creates n_obstacles separate CTCS constraints\n# - Each constraint is lowered and traced independently\n\n# for i in range(n_obstacles):\n#     obs_center = obstacle_centers[i]\n#     radius = obstacle_radii[i]\n#     obstacle_constraint = ox.ctcs(\n#         radius &lt;= ox.linalg.Norm(position - obs_center)\n#     )\n#     constraints.append(obstacle_constraint)\n\n# =============================================================================\n# Initial Guesses\n# =============================================================================\n\nstraight_line = np.linspace(position.initial, position.final, n)\nposition.guess = straight_line\nvelocity.guess = np.zeros((n, 3))\nforce.guess = np.tile([0.0, 0.0, -m * g], (n, 1))  # Hover thrust\n\n# =============================================================================\n# Problem Setup\n# =============================================================================\n\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n\n# SCP settings\nproblem.settings.prp.dt = 0.01\nproblem.settings.scp.w_tr = 5e0\nproblem.settings.scp.lam_cost = 1e0\nproblem.settings.scp.lam_vc = 1e2\nproblem.settings.scp.ep_tr = 1e-3\nproblem.settings.scp.ep_vb = 1e-4\nproblem.settings.scp.ep_vc = 1e-8\nproblem.settings.scp.cost_drop = 5\nproblem.settings.scp.cost_relax = 0.7\nproblem.settings.scp.w_tr_adapt = 1.5\n\n# =============================================================================\n# Solve and Visualize\n# =============================================================================\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n\n    # Store obstacle info for visualization\n    results.update(\n        {\n            \"obstacles_centers\": [c for c in obstacle_centers],\n            \"obstacles_radii\": [[1 / r, 1 / r, 1 / r] for r in obstacle_radii],\n            \"obstacles_axes\": [np.eye(3) for _ in range(n_obstacles)],\n        }\n    )\n\n    # Create viser visualization servers\n    traj_server = create_animated_plotting_server(\n        results,\n        thrust_key=\"force\",\n        viewcone_scale=5.0,\n    )\n    scp_server = create_scp_animated_plotting_server(\n        results,\n        attitude_stride=3,\n        frame_duration_ms=200,\n    )\n\n    # Keep servers running\n    traj_server.sleep_forever()\n</code></pre>"},{"location":"examples/realtime/cinema_vp_realtime/","title":"Cinema Vp Realtime","text":"<p>Interactive real-time visualization for cinematic viewpoint planning using Viser.</p> <p>This module provides a web-based GUI for interactively solving and visualizing the cinematic viewpoint planning trajectory optimization problem in real-time.</p> <p>Run this script and open the displayed URL in your browser.</p> <p>File: <code>examples/realtime/cinema_vp_realtime.py</code></p> <pre><code>import os\nimport sys\nimport threading\nimport time\n\nimport matplotlib\nimport numpy as np\nimport viser\nfrom scipy.spatial.transform import Rotation as R\n\n# Get viridis colormap without pyplot (avoids potential backend issues)\n_viridis_cmap = matplotlib.colormaps[\"viridis\"]\n\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nfrom examples.drone.cinema_vp_realtime_base import (\n    kp_pose,\n    plotting_dict,\n    problem,\n)\nfrom examples.plotting_viser import (\n    build_scp_step_results,\n    compute_velocity_colors_realtime,\n    extract_multishoot_trajectory,\n    format_metrics_markdown,\n    get_print_queue_data,\n)\n\n# Initialize the problem\nproblem.initialize()\n\n\ndef _generate_viewcone_vertices(\n    half_angle_x: float,\n    half_angle_y: float | None,\n    scale: float,\n    norm_type: float | str,\n    n_segments: int = 32,\n) -&gt; np.ndarray:\n    \"\"\"Generate viewcone vertices in sensor frame (apex at origin, looking along +Z).\"\"\"\n    if half_angle_y is None:\n        half_angle_y = half_angle_x\n\n    # Compute extent at z=scale\n    tan_x = np.tan(half_angle_x)\n    tan_y = np.tan(half_angle_y)\n\n    # Generate points around the cone base depending on norm type\n    theta = np.linspace(0, 2 * np.pi, n_segments, endpoint=False)\n\n    # Convert norm_type to numeric value\n    if norm_type == \"inf\" or norm_type == np.inf:\n        p = np.inf\n    else:\n        p = float(norm_type)\n\n    # Generate unit vectors on the p-norm ball\n    if p == np.inf:\n        # Square cross-section\n        # Use parametric form for a square\n        t = theta / (2 * np.pi) * 4  # 0 to 4\n        unit_x = np.zeros_like(t)\n        unit_y = np.zeros_like(t)\n        for i, ti in enumerate(t):\n            if ti &lt; 1:\n                unit_x[i] = 1.0\n                unit_y[i] = ti * 2 - 1\n            elif ti &lt; 2:\n                unit_x[i] = 1 - (ti - 1) * 2\n                unit_y[i] = 1.0\n            elif ti &lt; 3:\n                unit_x[i] = -1.0\n                unit_y[i] = 1 - (ti - 2) * 2\n            else:\n                unit_x[i] = -1 + (ti - 3) * 2\n                unit_y[i] = -1.0\n    else:\n        # p-norm ball: |x|^p + |y|^p = 1\n        cos_t = np.cos(theta)\n        sin_t = np.sin(theta)\n        # Superellipse parametric form\n        r = (np.abs(cos_t) ** p + np.abs(sin_t) ** p) ** (-1.0 / p)\n        unit_x = r * cos_t\n        unit_y = r * sin_t\n\n    # Scale by tan values and cone depth\n    x = unit_x * tan_x * scale\n    y = unit_y * tan_y * scale\n    z = np.full_like(x, scale)\n\n    # Apex at origin\n    apex = np.array([[0.0, 0.0, 0.0]])\n    base_points = np.stack([x, y, z], axis=1)\n\n    return np.vstack([apex, base_points])\n\n\ndef _generate_viewcone_faces(n_base_verts: int) -&gt; np.ndarray:\n    \"\"\"Generate triangle faces for viewcone (fan from apex).\"\"\"\n    faces = []\n    for i in range(n_base_verts):\n        next_i = (i + 1) % n_base_verts\n        # Face: apex (0), current base vertex (i+1), next base vertex (next_i+1)\n        faces.append([0, i + 1, next_i + 1])\n    return np.array(faces, dtype=np.uint32)\n\n\ndef _quaternion_to_rotation_matrix(q: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Convert quaternion [w, x, y, z] to rotation matrix.\"\"\"\n    r = R.from_quat([q[1], q[2], q[3], q[0]])  # scipy uses [x, y, z, w]\n    return r.as_matrix()\n\n\ndef create_realtime_server(\n    optimization_problem,\n    keypoint_param,\n    plot_dict: dict,\n) -&gt; viser.ViserServer:\n    \"\"\"Create a viser server for real-time cinematic viewpoint trajectory optimization.\n\n    Args:\n        optimization_problem: The OpenSCvx Problem instance\n        keypoint_param: The keypoint position parameter object\n        plot_dict: Dictionary containing visualization parameters (R_sb, alpha_x, etc.)\n\n    Returns:\n        ViserServer instance\n    \"\"\"\n    server = viser.ViserServer()\n    server.gui.configure_theme(dark_mode=True)\n\n    # Extract plotting parameters\n    alpha_x = plot_dict.get(\"alpha_x\", 6.0)\n    alpha_y = plot_dict.get(\"alpha_y\", 8.0)\n    R_sb = np.array(plot_dict.get(\"R_sb\", np.eye(3)))\n    norm_type = plot_dict.get(\"norm_type\", \"inf\")\n\n    # Compute half-angles in radians\n    half_angle_x = np.pi / alpha_x\n    half_angle_y = np.pi / alpha_y\n\n    # =========================================================================\n    # Scene Setup\n    # =========================================================================\n\n    # Grid\n    server.scene.add_grid(\n        \"/grid\",\n        width=50,\n        height=50,\n        position=(0.0, 0.0, 0.0),\n    )\n\n    # Origin frame\n    server.scene.add_frame(\n        \"/origin\",\n        wxyz=(1.0, 0.0, 0.0, 0.0),\n        position=(0.0, 0.0, 0.0),\n        axes_length=1.0,\n    )\n\n    # Trajectory point cloud (initially empty)\n    trajectory_handle = server.scene.add_point_cloud(\n        \"/trajectory\",\n        points=np.zeros((1, 3), dtype=np.float32),\n        colors=(255, 255, 0),\n        point_size=0.2,\n    )\n\n    # Keypoint marker (red sphere)\n    initial_kp = keypoint_param.value\n    keypoint_handle = server.scene.add_icosphere(\n        \"/keypoint\",\n        radius=0.3,\n        color=(255, 0, 0),\n        position=tuple(initial_kp),\n    )\n\n    # Line-of-sight visualization (line from drone to keypoint)\n    los_handle = server.scene.add_line_segments(\n        \"/line_of_sight\",\n        points=np.zeros((1, 2, 3), dtype=np.float32),\n        colors=(255, 255, 0),  # Yellow\n        line_width=2.0,\n    )\n\n    # Drone body frame axes (will be updated with attitude)\n    axis_handles = []\n    axis_colors = [(255, 0, 0), (0, 255, 0), (0, 0, 255)]  # RGB for XYZ\n    for i, color in enumerate(axis_colors):\n        handle = server.scene.add_line_segments(\n            f\"/drone_axes/axis_{i}\",\n            points=np.zeros((1, 2, 3), dtype=np.float32),\n            colors=color,\n            line_width=3.0,\n        )\n        axis_handles.append(handle)\n\n    # View cone mesh (initially invisible, will be created on first update)\n    viewcone_handle = {\"mesh\": None, \"base_vertices\": None}\n\n    # Pre-compute viewcone base geometry in sensor frame\n    viewcone_scale = 10.0\n    viewcone_base_vertices = _generate_viewcone_vertices(\n        half_angle_x, half_angle_y, viewcone_scale, norm_type, n_segments=32\n    )\n    viewcone_faces = _generate_viewcone_faces(len(viewcone_base_vertices) - 1)\n    viewcone_handle[\"base_vertices\"] = viewcone_base_vertices\n\n    # Create initial viewcone mesh\n    cmap = matplotlib.colormaps[\"viridis\"]\n    rgb = cmap(0.4)[:3]\n    viewcone_color = tuple(int(c * 255) for c in rgb)\n\n    viewcone_handle[\"mesh\"] = server.scene.add_mesh_simple(\n        \"/viewcone\",\n        vertices=viewcone_base_vertices.astype(np.float32),\n        faces=viewcone_faces,\n        color=viewcone_color,\n        wireframe=False,\n        opacity=0.4,\n    )\n\n    # Keypoint draggable transform control\n    keypoint_drag_handle = server.scene.add_transform_controls(\n        \"/keypoint_drag\",\n        position=tuple(initial_kp),\n        scale=2.0,\n        disable_rotations=True,\n        visible=True,\n    )\n\n    # =========================================================================\n    # Shared State\n    # =========================================================================\n\n    state = {\n        \"running\": True,\n        \"reset_requested\": False,\n    }\n\n    # =========================================================================\n    # GUI Controls\n    # =========================================================================\n\n    # --- Optimization Metrics ---\n    with server.gui.add_folder(\"Optimization Metrics\"):\n        metrics_text = server.gui.add_markdown(\n            \"\"\"**Iteration:** 0\n**J_tr:** 0.00E+00\n**J_vb:** 0.00E+00\n**J_vc:** 0.00E+00\n**Objective:** 0.00E+00\n**Dis Time:** 0.0ms\n**Solve Time:** 0.0ms\n**Status:** --\"\"\"\n        )\n\n    # --- Optimization Weights ---\n    with server.gui.add_folder(\"Optimization Weights\"):\n        lam_cost_input = server.gui.add_number(\n            \"lambda_cost\",\n            initial_value=optimization_problem.settings.scp.lam_cost,\n            min=1e-6,\n            max=1e6,\n            step=0.01,\n        )\n        lam_tr_input = server.gui.add_number(\n            \"lambda_tr (w_tr)\",\n            initial_value=optimization_problem.settings.scp.w_tr,\n            min=1e-6,\n            max=1e6,\n            step=0.1,\n        )\n\n        @lam_cost_input.on_update\n        def _(_) -&gt; None:\n            optimization_problem.settings.scp.lam_cost = lam_cost_input.value\n\n        @lam_tr_input.on_update\n        def _(_) -&gt; None:\n            optimization_problem.settings.scp.w_tr = lam_tr_input.value\n\n    # --- Problem Control ---\n    with server.gui.add_folder(\"Problem Control\"):\n        reset_button = server.gui.add_button(\"Reset Problem\")\n\n        @reset_button.on_click\n        def _(_) -&gt; None:\n            state[\"reset_requested\"] = True\n            print(\"Problem reset requested\")\n\n    # --- Keypoint Position Controls ---\n    with server.gui.add_folder(\"Keypoint Position (Line-of-Sight Target)\"):\n        server.gui.add_markdown(\"*Drag the control in 3D view or use inputs below*\")\n\n        kp_vector_input = server.gui.add_vector3(\n            \"Position\",\n            initial_value=tuple(initial_kp),\n            step=0.5,\n        )\n\n        reset_kp_button = server.gui.add_button(\"Reset Keypoint\")\n\n        @reset_kp_button.on_click\n        def _(_) -&gt; None:\n            original = plot_dict.get(\"init_poses\", np.array([13.0, 0.0, 2.0]))\n            kp_vector_input.value = tuple(original)\n            keypoint_param.value = np.array(original)\n            optimization_problem.parameters[\"kp_pose\"] = np.array(original)\n            keypoint_drag_handle.position = tuple(original)\n            keypoint_handle.position = tuple(original)\n            print(\"Keypoint reset to initial position\")\n\n        # Callback for GUI vector3 input -&gt; update params and scene objects\n        @kp_vector_input.on_update\n        def _(_) -&gt; None:\n            new_pos = np.array(kp_vector_input.value)\n            keypoint_param.value = new_pos\n            optimization_problem.parameters[\"kp_pose\"] = new_pos\n            keypoint_drag_handle.position = tuple(new_pos)\n            keypoint_handle.position = tuple(new_pos)\n\n    # Wire up drag handle callback\n    @keypoint_drag_handle.on_update\n    def _(_) -&gt; None:\n        new_pos = np.array(keypoint_drag_handle.position)\n        keypoint_param.value = new_pos\n        optimization_problem.parameters[\"kp_pose\"] = new_pos\n        kp_vector_input.value = tuple(new_pos)\n        keypoint_handle.position = tuple(new_pos)\n\n    # =========================================================================\n    # Helper Functions\n    # =========================================================================\n\n    def update_metrics(results: dict) -&gt; None:\n        \"\"\"Update the metrics markdown display.\"\"\"\n        metrics_text.content = format_metrics_markdown(results)\n\n    def update_trajectory_and_drone(V_multi_shoot: np.ndarray, x_traj: np.ndarray) -&gt; None:\n        \"\"\"Update trajectory visualization and drone pose.\"\"\"\n        try:\n            n_x = optimization_problem.settings.sim.n_states\n            n_u = optimization_problem.settings.sim.n_controls\n\n            positions, velocities = extract_multishoot_trajectory(V_multi_shoot, n_x, n_u)\n\n            if len(positions) &gt; 0:\n                colors = compute_velocity_colors_realtime(velocities, _viridis_cmap)\n                trajectory_handle.points = positions\n                trajectory_handle.colors = colors\n\n                # Update line-of-sight (from last position to keypoint)\n                current_kp = optimization_problem.parameters[\"kp_pose\"]\n                last_pos = positions[-1]\n                los_points = np.array([[last_pos, current_kp]], dtype=np.float32)\n                los_handle.points = los_points\n\n            # Update drone axes and viewcone using x_traj (state trajectory)\n            if x_traj is not None and len(x_traj) &gt; 0 and x_traj.shape[1] &gt;= 10:\n                # Get last position and attitude\n                last_pos = x_traj[-1, :3]\n                att = x_traj[-1, 6:10]  # Quaternion [qw, qx, qy, qz]\n\n                # Convert quaternion to rotation matrix\n                rotmat = _quaternion_to_rotation_matrix(att)\n\n                # Draw body frame axes (x=red, y=green, z=blue)\n                axes_length = 2.0\n                axes = axes_length * np.eye(3)\n                axes_rot = rotmat @ axes\n\n                for k in range(3):\n                    axis_pts = np.array([[last_pos, last_pos + axes_rot[:, k]]], dtype=np.float32)\n                    axis_handles[k].points = axis_pts\n\n                # Update viewcone mesh\n                if (\n                    viewcone_handle[\"mesh\"] is not None\n                    and viewcone_handle[\"base_vertices\"] is not None\n                ):\n                    # Sensor-to-body rotation\n                    R_sensor_to_body = R_sb.T\n\n                    # Full transform: sensor -&gt; body -&gt; world\n                    R_sensor_to_world = rotmat @ R_sensor_to_body\n\n                    # Transform vertices and translate to position\n                    base_verts = viewcone_handle[\"base_vertices\"]\n                    world_vertices = (R_sensor_to_world @ base_verts.T).T + last_pos\n                    viewcone_handle[\"mesh\"].vertices = world_vertices.astype(np.float32)\n\n        except Exception as e:\n            print(f\"Trajectory update error: {e}\")\n\n    # =========================================================================\n    # Optimization Worker\n    # =========================================================================\n\n    def optimization_loop() -&gt; None:\n        \"\"\"Background thread running continuous optimization.\"\"\"\n        iteration = 0\n\n        while state[\"running\"]:\n            try:\n                # Check for reset request\n                if state[\"reset_requested\"]:\n                    optimization_problem.reset()\n                    state[\"reset_requested\"] = False\n                    iteration = 0\n                    print(\"Problem reset to initial conditions\")\n\n                # Run one SCP step\n                start_time = time.time()\n                step_result = optimization_problem.step()\n                solve_time_ms = (time.time() - start_time) * 1000\n\n                # Build results dict\n                results = build_scp_step_results(step_result, solve_time_ms)\n                results.update(get_print_queue_data(optimization_problem))\n\n                # Update visualizations (viser is thread-safe)\n                update_metrics(results)\n\n                # Update trajectory from V_history\n                if optimization_problem.state.V_history:\n                    V_multi_shoot = np.array(optimization_problem.state.V_history[-1])\n                    x_traj = np.array(optimization_problem.state.x)\n                    update_trajectory_and_drone(V_multi_shoot, x_traj)\n\n                iteration += 1\n                time.sleep(0.05)  # Small delay to avoid overwhelming\n\n            except Exception as e:\n                print(f\"Optimization error: {e}\")\n                time.sleep(1.0)\n\n    # Start optimization in background thread\n    opt_thread = threading.Thread(target=optimization_loop, daemon=True)\n    opt_thread.start()\n\n    return server\n\n\nif __name__ == \"__main__\":\n    print(\"Creating viser server for Cinema Viewpoint Planning Real-time Optimization...\")\n    print(\"Open the URL shown below in your browser\\n\")\n\n    server = create_realtime_server(problem, kp_pose, plotting_dict)\n    server.sleep_forever()\n</code></pre>"},{"location":"examples/realtime/drone_racing_realtime/","title":"Drone Racing Realtime","text":"<p>Interactive real-time visualization for drone racing using Viser.</p> <p>This module provides a web-based GUI for interactively solving and visualizing the drone racing trajectory optimization problem in real-time.</p> <p>Run this script and open the displayed URL in your browser.</p> <p>File: <code>examples/realtime/drone_racing_realtime.py</code></p> <pre><code>import os\nimport sys\nimport threading\nimport time\n\nimport matplotlib\nimport numpy as np\nimport viser\n\n# Get viridis colormap without pyplot (avoids potential backend issues)\n_viridis_cmap = matplotlib.colormaps[\"viridis\"]\n\n# Add grandparent directory to path to import examples\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nfrom examples.drone.drone_racing import (\n    gate_center_params,\n    initial_gate_centers,\n    problem,\n)\nfrom examples.plotting_viser import (\n    build_scp_step_results,\n    compute_velocity_colors_realtime,\n    extract_multishoot_trajectory,\n    format_metrics_markdown,\n    get_print_queue_data,\n)\nfrom openscvx.utils import gen_vertices\n\n# Initialize the problem\nproblem.initialize()\n\n\ndef create_realtime_server(\n    optimization_problem,\n    gate_params: list,\n    initial_centers: list,\n    n_gates: int = 10,\n) -&gt; viser.ViserServer:\n    \"\"\"Create a viser server for real-time trajectory optimization visualization.\n\n    Args:\n        optimization_problem: The OpenSCvx Problem instance\n        gate_params: List of gate center parameter objects\n        initial_centers: List of initial gate center positions\n        n_gates: Number of gates\n\n    Returns:\n        ViserServer instance\n    \"\"\"\n    server = viser.ViserServer()\n    server.gui.configure_theme(dark_mode=True)\n\n    # =========================================================================\n    # Scene Setup\n    # =========================================================================\n\n    # Grid\n    server.scene.add_grid(\n        \"/grid\",\n        width=200,\n        height=100,\n        position=(100.0, -50.0, 0.0),\n    )\n\n    # Origin frame\n    server.scene.add_frame(\n        \"/origin\",\n        wxyz=(1.0, 0.0, 0.0, 0.0),\n        position=(0.0, 0.0, 0.0),\n        axes_length=1.0,\n    )\n\n    # Trajectory point cloud (initially empty)\n    trajectory_handle = server.scene.add_point_cloud(\n        \"/trajectory\",\n        points=np.zeros((1, 3), dtype=np.float32),\n        colors=(255, 255, 0),\n        point_size=0.3,\n    )\n\n    # Gate line segments (visual only)\n    gate_handles = []\n    for i in range(n_gates):\n        handle = server.scene.add_line_segments(\n            f\"/gates/gate_{i}\",\n            points=np.zeros((4, 2, 3), dtype=np.float32),\n            colors=(255, 165, 0),  # Orange, matching non-realtime plots\n            line_width=3.0,\n        )\n        gate_handles.append(handle)\n\n    # Clickable spheres at gate centers (for selection)\n    gate_click_targets = []\n    for i in range(n_gates):\n        initial_pos = gate_params[i].value\n        click_target = server.scene.add_icosphere(\n            f\"/gates/click_target_{i}\",\n            radius=0.5,\n            color=(255, 165, 0),  # Orange, matching gate color\n            position=tuple(initial_pos),\n        )\n        gate_click_targets.append(click_target)\n\n    # Gate transform controls (draggable gizmos)\n    gate_drag_handles = []\n    for i in range(n_gates):\n        initial_pos = gate_params[i].value\n        drag_handle = server.scene.add_transform_controls(\n            f\"/gates/drag_{i}\",\n            position=tuple(initial_pos),\n            scale=3.0,\n            disable_rotations=True,  # Gates only need translation\n            visible=False,  # Hidden by default\n        )\n        gate_drag_handles.append(drag_handle)\n\n    # Track currently selected gate\n    selected_gate = {\"index\": None}\n\n    def select_gate(gate_idx: int | None) -&gt; None:\n        \"\"\"Select a gate and show its transform control, hiding others.\"\"\"\n        # Hide previously selected\n        if selected_gate[\"index\"] is not None:\n            gate_drag_handles[selected_gate[\"index\"]].visible = False\n            gate_handles[selected_gate[\"index\"]].colors = (255, 165, 0)  # Orange\n            gate_click_targets[selected_gate[\"index\"]].color = (255, 165, 0)\n\n        # Show newly selected\n        if gate_idx is not None:\n            gate_drag_handles[gate_idx].visible = True\n            gate_handles[gate_idx].colors = (255, 200, 0)  # Yellow/orange highlight\n            gate_click_targets[gate_idx].color = (255, 200, 0)  # Highlight click target\n            selected_gate[\"index\"] = gate_idx\n        else:\n            selected_gate[\"index\"] = None\n\n    # Add click handlers to clickable spheres\n    def make_gate_click_handler(gate_idx: int):\n        @gate_click_targets[gate_idx].on_click\n        def _(_) -&gt; None:\n            # Toggle: click selected gate again to deselect\n            if selected_gate[\"index\"] == gate_idx:\n                select_gate(None)\n            else:\n                select_gate(gate_idx)\n\n        return _\n\n    for i in range(n_gates):\n        make_gate_click_handler(i)\n\n    # =========================================================================\n    # Shared State\n    # =========================================================================\n\n    state = {\n        \"running\": True,\n        \"reset_requested\": False,\n    }\n\n    # =========================================================================\n    # GUI Controls\n    # =========================================================================\n\n    # --- Optimization Metrics ---\n    with server.gui.add_folder(\"Optimization Metrics\"):\n        metrics_text = server.gui.add_markdown(\n            \"\"\"**Iteration:** 0\n**J_tr:** 0.00E+00\n**J_vb:** 0.00E+00\n**J_vc:** 0.00E+00\n**Objective:** 0.00E+00\n**Dis Time:** 0.0ms\n**Solve Time:** 0.0ms\n**Status:** --\"\"\"\n        )\n\n    # --- Optimization Weights ---\n    with server.gui.add_folder(\"Optimization Weights\"):\n        lam_cost_input = server.gui.add_number(\n            \"\u03bb_cost\",\n            initial_value=optimization_problem.settings.scp.lam_cost,\n            min=1e-6,\n            max=1e6,\n            step=0.1,\n        )\n        lam_tr_input = server.gui.add_number(\n            \"\u03bb_tr (w_tr)\",\n            initial_value=optimization_problem.settings.scp.w_tr,\n            min=1e-6,\n            max=1e6,\n            step=0.1,\n        )\n\n        @lam_cost_input.on_update\n        def _(_) -&gt; None:\n            optimization_problem.settings.scp.lam_cost = lam_cost_input.value\n\n        @lam_tr_input.on_update\n        def _(_) -&gt; None:\n            optimization_problem.settings.scp.w_tr = lam_tr_input.value\n\n    # --- Problem Control ---\n    with server.gui.add_folder(\"Problem Control\"):\n        reset_button = server.gui.add_button(\"Reset Problem\")\n\n        @reset_button.on_click\n        def _(_) -&gt; None:\n            state[\"reset_requested\"] = True\n            print(\"Problem reset requested\")\n\n    # --- Gate Controls ---\n    gate_vector_inputs = []\n    with server.gui.add_folder(\"Gate Positions\", expand_by_default=False):\n        server.gui.add_markdown(\"*Click a gate in 3D view to select and drag it*\")\n\n        reset_gates_button = server.gui.add_button(\"Reset All Gates\")\n\n        @reset_gates_button.on_click\n        def _(_) -&gt; None:\n            # Deselect any selected gate\n            select_gate(None)\n            for i, vec_input in enumerate(gate_vector_inputs):\n                original = initial_centers[i]\n                vec_input.value = tuple(original)\n                gate_params[i].value = np.array(original)\n                optimization_problem.parameters[gate_params[i].name] = np.array(original)\n                # Also update drag handle and click target positions\n                gate_drag_handles[i].position = tuple(original)\n                gate_click_targets[i].position = tuple(original)\n            print(\"Gates reset to initial positions\")\n\n        for i in range(n_gates):\n            initial_pos = gate_params[i].value\n            vec_input = server.gui.add_vector3(\n                f\"Gate {i + 1}\",\n                initial_value=tuple(initial_pos),\n                step=1.0,\n            )\n            gate_vector_inputs.append(vec_input)\n\n            # Callback for GUI vector3 input -&gt; update params and scene objects\n            def make_gate_gui_callback(gate_idx: int, input_handle):\n                @input_handle.on_update\n                def _(_) -&gt; None:\n                    new_center = np.array(input_handle.value)\n                    gate_params[gate_idx].value = new_center\n                    optimization_problem.parameters[gate_params[gate_idx].name] = new_center\n                    # Sync drag handle and click target positions\n                    gate_drag_handles[gate_idx].position = tuple(new_center)\n                    gate_click_targets[gate_idx].position = tuple(new_center)\n\n                return _\n\n            make_gate_gui_callback(i, vec_input)\n\n    # Wire up drag handle callbacks (must be done after gate_vector_inputs is populated)\n    def make_drag_callback(gate_idx: int, drag_handle):\n        @drag_handle.on_update\n        def _(_) -&gt; None:\n            new_center = np.array(drag_handle.position)\n            gate_params[gate_idx].value = new_center\n            optimization_problem.parameters[gate_params[gate_idx].name] = new_center\n            # Sync GUI vector3 input and click target\n            gate_vector_inputs[gate_idx].value = tuple(new_center)\n            gate_click_targets[gate_idx].position = tuple(new_center)\n\n        return _\n\n    for i in range(n_gates):\n        make_drag_callback(i, gate_drag_handles[i])\n\n    # =========================================================================\n    # Helper Functions\n    # =========================================================================\n\n    def update_metrics(results: dict) -&gt; None:\n        \"\"\"Update the metrics markdown display.\"\"\"\n        metrics_text.content = format_metrics_markdown(results)\n\n    def update_trajectory(V_multi_shoot: np.ndarray) -&gt; None:\n        \"\"\"Update the trajectory point cloud from multi-shoot data.\"\"\"\n        try:\n            n_x = optimization_problem.settings.sim.n_states\n            n_u = optimization_problem.settings.sim.n_controls\n\n            positions, velocities = extract_multishoot_trajectory(V_multi_shoot, n_x, n_u)\n\n            if len(positions) &gt; 0:\n                colors = compute_velocity_colors_realtime(velocities, _viridis_cmap)\n                trajectory_handle.points = positions\n                trajectory_handle.colors = colors\n\n        except Exception as e:\n            print(f\"Trajectory update error: {e}\")\n\n    def update_gates() -&gt; None:\n        \"\"\"Update gate visualizations based on current gate parameters.\"\"\"\n        radii = np.array([2.5, 1e-4, 2.5])\n        for i, handle in enumerate(gate_handles):\n            center = gate_params[i].value\n            if center is not None:\n                vertices = gen_vertices(center, radii)\n                # Create line segments for closed polygon (4 edges)\n                edges = np.array(\n                    [\n                        [vertices[0], vertices[1]],\n                        [vertices[1], vertices[2]],\n                        [vertices[2], vertices[3]],\n                        [vertices[3], vertices[0]],\n                    ],\n                    dtype=np.float32,\n                )\n                handle.points = edges\n\n    # =========================================================================\n    # Optimization Worker\n    # =========================================================================\n\n    def optimization_loop() -&gt; None:\n        \"\"\"Background thread running continuous optimization.\"\"\"\n        iteration = 0\n\n        while state[\"running\"]:\n            try:\n                # Check for reset request\n                if state[\"reset_requested\"]:\n                    optimization_problem.reset()\n                    state[\"reset_requested\"] = False\n                    iteration = 0\n                    print(\"Problem reset to initial conditions\")\n\n                # Run one SCP step\n                start_time = time.time()\n                step_result = optimization_problem.step()\n                solve_time_ms = (time.time() - start_time) * 1000\n\n                # Build results dict\n                results = build_scp_step_results(step_result, solve_time_ms)\n                results.update(get_print_queue_data(optimization_problem))\n\n                # Update visualizations (viser is thread-safe)\n                update_metrics(results)\n                update_gates()\n\n                # Update trajectory from V_history\n                if optimization_problem.state.V_history:\n                    V_multi_shoot = np.array(optimization_problem.state.V_history[-1])\n                    update_trajectory(V_multi_shoot)\n\n                iteration += 1\n                time.sleep(0.05)  # Small delay to avoid overwhelming\n\n            except Exception as e:\n                print(f\"Optimization error: {e}\")\n                time.sleep(1.0)\n\n    # Start the optimization thread\n    opt_thread = threading.Thread(target=optimization_loop, daemon=True)\n    opt_thread.start()\n\n    return server\n\n\nif __name__ == \"__main__\":\n    print(\"Starting Drone Racing Real-time Optimization (Viser)\")\n    print(\"Open the URL shown below in your browser\\n\")\n\n    server = create_realtime_server(\n        optimization_problem=problem,\n        gate_params=gate_center_params,\n        initial_centers=initial_gate_centers,\n        n_gates=10,\n    )\n\n    server.sleep_forever()\n</code></pre>"},{"location":"examples/realtime/dubins_car_realtime/","title":"Dubins Car Realtime","text":"<p>Interactive real-time visualization for Dubins car path planning.</p> <p>This module provides a PyQt5-based GUI for interactively solving and visualizing the Dubins car trajectory optimization problem in real-time.</p> <p>File: <code>examples/realtime/dubins_car_realtime.py</code></p> <pre><code>import os\nimport sys\nimport threading\n\nimport numpy as np\nimport pyqtgraph as pg\nfrom PyQt5.QtCore import Qt, QTimer\nfrom PyQt5.QtWidgets import (\n    QApplication,\n    QGraphicsEllipseItem,\n    QGroupBox,\n    QHBoxLayout,\n    QLabel,\n    QLineEdit,\n    QPushButton,\n    QVBoxLayout,\n    QWidget,\n)\n\nsys.path.append(os.path.join(os.path.dirname(__file__), \"..\"))\n\nfrom car.dubins_car import (\n    # --- Import your problem setup ---\n    plotting_dict,\n    problem,\n)\n\n# --- Shared state for plotting ---\nrunning = {\"stop\": False}\nreset_requested = {\"reset\": False}\nlatest_results = {\"results\": None}\nnew_result_event = threading.Event()\n\n\n# --- Key press handler for obstacle movement ---\ndef on_key(event):\n    step = 0.1\n    if event.key == \"up\":\n        problem.parameters[\"obs_center\"][1] += step\n    elif event.key == \"down\":\n        problem.parameters[\"obs_center\"][1] -= step\n    elif event.key == \"left\":\n        problem.parameters[\"obs_center\"][0] -= step\n    elif event.key == \"right\":\n        problem.parameters[\"obs_center\"][0] += step\n    elif event.key == \"escape\":\n        running[\"stop\"] = True\n\n\n# --- Optimization loop to run in background thread ---\ndef optimization_loop():\n    problem.initialize()\n    print(\"Optimization loop started...\")\n    iteration = 0\n    try:\n        while not running[\"stop\"]:\n            # Check if reset was requested\n            if reset_requested[\"reset\"]:\n                problem.reset()\n                reset_requested[\"reset\"] = False\n                iteration = 0\n                print(\"Problem reset to initial conditions\")\n\n            # Perform a single SCP step (automatically warm-starts from previous iteration)\n            print(f\"Starting iteration {iteration}...\")\n            step_result = problem.step()\n            iteration += 1\n\n            # Build results dict for visualization\n            results = {\n                \"iter\": step_result[\"scp_k\"] - 1,  # Display iteration (0-indexed)\n                \"J_tr\": step_result[\"scp_J_tr\"],\n                \"J_vb\": step_result[\"scp_J_vb\"],\n                \"J_vc\": step_result[\"scp_J_vc\"],\n                \"converged\": step_result[\"converged\"],\n                \"V_multi_shoot\": problem.state.V_history[-1] if problem.state.V_history else [],\n                \"x\": problem.state.x,  # Current state trajectory\n                \"u\": problem.state.u,  # Current control trajectory\n            }\n\n            # Get timing from the print queue (emitted data)\n            try:\n                if hasattr(problem, \"print_queue\") and not problem.print_queue.empty():\n                    # Get the latest emitted data\n                    emitted_data = problem.print_queue.get_nowait()\n                    results[\"dis_time\"] = emitted_data.get(\"dis_time\", 0.0)\n                    results[\"solve_time\"] = emitted_data.get(\"subprop_time\", 0.0)\n                    results[\"prob_stat\"] = emitted_data.get(\"prob_stat\", \"--\")\n                    results[\"cost\"] = emitted_data.get(\"cost\", 0.0)\n                else:\n                    results[\"dis_time\"] = 0.0\n                    results[\"solve_time\"] = 0.0\n                    results[\"prob_stat\"] = \"--\"\n                    results[\"cost\"] = 0.0\n            except Exception:\n                results[\"dis_time\"] = 0.0\n                results[\"solve_time\"] = 0.0\n                results[\"prob_stat\"] = \"--\"\n                results[\"cost\"] = 0.0\n\n            # Print iteration info to CLI\n            print(\n                f\"Iteration {iteration}: J_tr={results['J_tr']:.2e}, J_vb={results['J_vb']:.2e}, \"\n                f\"J_vc={results['J_vc']:.2e}, Cost={results['cost']:.2e}, \"\n                f\"Status={results['prob_stat']}\"\n            )\n\n            results.update(plotting_dict)\n            latest_results[\"results\"] = results\n            new_result_event.set()\n            # Check for convergence to optionally stop\n            # if results['converged']:\n            #     print(\"Converged!\")\n            #     # maybe sleep or stop here\n    except KeyboardInterrupt:\n        running[\"stop\"] = True\n        print(\"Stopped by user.\")\n    except Exception as e:\n        print(f\"Error in optimization loop: {e}\")\n        import traceback\n\n        traceback.print_exc()\n        running[\"stop\"] = True\n\n\nclass ObstaclePlotWidget(pg.PlotWidget):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.dragging = False\n\n    def keyPressEvent(self, event):\n        step = 0.1\n        if event.key() == Qt.Key_Up:\n            problem.parameters[\"obs_center\"][1] += step\n        elif event.key() == Qt.Key_Down:\n            problem.parameters[\"obs_center\"][1] -= step\n        elif event.key() == Qt.Key_Left:\n            problem.parameters[\"obs_center\"][0] -= step\n        elif event.key() == Qt.Key_Right:\n            problem.parameters[\"obs_center\"][0] += step\n        elif event.key() == Qt.Key_Escape:\n            running[\"stop\"] = True\n        super().keyPressEvent(event)\n\n    def mousePressEvent(self, event):\n        pos = self.plotItem.vb.mapSceneToView(event.pos())\n        mouse_x, mouse_y = pos.x(), pos.y()\n        dx = mouse_x - problem.parameters[\"obs_center\"][0]\n        dy = mouse_y - problem.parameters[\"obs_center\"][1]\n        if dx**2 + dy**2 &lt;= problem.parameters[\"obs_radius\"] ** 2:\n            self.dragging = True\n            # Do NOT call super() if starting drag (prevents plot pan)\n        else:\n            super().mousePressEvent(event)\n\n    def mouseMoveEvent(self, event):\n        if self.dragging:\n            pos = self.plotItem.vb.mapSceneToView(event.pos())\n            problem.parameters[\"obs_center\"][0] = pos.x()\n            problem.parameters[\"obs_center\"][1] = pos.y()\n            # Do NOT call super() if dragging (prevents plot pan)\n        else:\n            super().mouseMoveEvent(event)\n\n    def mouseReleaseEvent(self, event):\n        if self.dragging:\n            self.dragging = False\n            # Do NOT call super() if ending drag (prevents plot pan)\n        else:\n            super().mouseReleaseEvent(event)\n\n\ndef on_lam_cost_changed(input_widget):\n    \"\"\"Handle lambda cost input changes\"\"\"\n    # Extract the new value from the input widget\n    new_value = input_widget.text()\n    try:\n        # Convert the new value to a float\n        lam_cost_value = float(new_value)\n        problem.settings.scp.lam_cost = lam_cost_value\n        # Update the display with scientific notation\n        input_widget.setText(f\"{lam_cost_value:.2E}\")\n    except ValueError:\n        print(\"Invalid input. Please enter a valid number.\")\n\n\ndef on_lam_tr_changed(input_widget):\n    \"\"\"Handle lambda trust region input changes\"\"\"\n    # Extract the new value from the input widget\n    new_value = input_widget.text()\n    try:\n        # Convert the new value to a float\n        lam_tr_value = float(new_value)\n        problem.settings.scp.w_tr = lam_tr_value\n        # Update the display with scientific notation\n        input_widget.setText(f\"{lam_tr_value:.2E}\")\n    except ValueError:\n        print(\"Invalid input. Please enter a valid number.\")\n\n\ndef on_reset_clicked():\n    \"\"\"Handle reset button click\"\"\"\n    reset_requested[\"reset\"] = True\n    print(\"Problem reset requested\")\n\n\ndef update_optimization_metrics(results, labels_dict):\n    \"\"\"Update the optimization metrics display\"\"\"\n    if results is None:\n        return\n    # Extract metrics from results\n    iter_num = results.get(\"iter\", 0)\n    j_tr = results.get(\"J_tr\", 0.0)\n    j_vb = results.get(\"J_vb\", 0.0)\n    j_vc = results.get(\"J_vc\", 0.0)\n    cost = results.get(\"cost\", 0.0)\n    status = results.get(\"prob_stat\", \"--\")\n    # Get timing information (these would need to be tracked separately)\n    dis_time = results.get(\"dis_time\", 0.0)\n    solve_time = results.get(\"solve_time\", 0.0)\n    # Update labels\n    labels_dict[\"iter_label\"].setText(f\"Iteration: {iter_num}\")\n    labels_dict[\"j_tr_label\"].setText(f\"J_tr: {j_tr:.2E}\")\n    labels_dict[\"j_vb_label\"].setText(f\"J_vb: {j_vb:.2E}\")\n    labels_dict[\"j_vc_label\"].setText(f\"J_vc: {j_vc:.2E}\")\n    labels_dict[\"objective_label\"].setText(f\"Objective: {cost:.2E}\")\n    labels_dict[\"lam_cost_display_label\"].setText(f\"\u03bb_cost: {problem.settings.scp.lam_cost:.2E}\")\n    labels_dict[\"dis_time_label\"].setText(f\"Dis Time: {dis_time:.1f}ms\")\n    labels_dict[\"solve_time_label\"].setText(f\"Solve Time: {solve_time:.1f}ms\")\n    labels_dict[\"status_label\"].setText(f\"Status: {status}\")\n\n\ndef plot_thread_func():\n    # Initialize PyQtGraph\n    app = QApplication.instance()\n    if app is None:\n        app = QApplication([])\n    # Create main window\n    main_widget = QWidget()\n    main_widget.setWindowTitle(\"Dubins Car Real-time Trajectory\")\n    main_layout = QHBoxLayout()\n    main_widget.setLayout(main_layout)\n    # Create plot window using the custom widget\n    plot_widget = ObstaclePlotWidget()\n    plot_widget.setLabel(\"left\", \"Y Position\")\n    plot_widget.setLabel(\"bottom\", \"X Position\")\n    # Create control panel\n    control_panel = QWidget()\n    control_layout = QVBoxLayout()\n    control_panel.setLayout(control_layout)\n    # Title\n    title = QLabel(\"Dubins Car Control\")\n    title.setStyleSheet(\"font-weight: bold; font-size: 14px;\")\n    control_layout.addWidget(title)\n    # Optimization Metrics Display\n    metrics_group = QGroupBox(\"Optimization Metrics\")\n    metrics_layout = QVBoxLayout()\n    metrics_group.setLayout(metrics_layout)\n    # Create labels for each metric\n    iter_label = QLabel(\"Iteration: 0\")\n    j_tr_label = QLabel(\"J_tr: 0.00E+00\")\n    j_vb_label = QLabel(\"J_vb: 0.00E+00\")\n    j_vc_label = QLabel(\"J_vc: 0.00E+00\")\n    objective_label = QLabel(\"Objective: 0.00E+00\")\n    lam_cost_display_label = QLabel(f\"\u03bb_cost: {problem.settings.scp.lam_cost:.2E}\")\n    dis_time_label = QLabel(\"Dis Time: 0.0ms\")\n    solve_time_label = QLabel(\"Solve Time: 0.0ms\")\n    status_label = QLabel(\"Status: --\")\n    # Style the labels\n    for label in [\n        iter_label,\n        j_tr_label,\n        j_vb_label,\n        j_vc_label,\n        objective_label,\n        lam_cost_display_label,\n        dis_time_label,\n        solve_time_label,\n        status_label,\n    ]:\n        label.setStyleSheet(\"font-family: monospace; font-size: 11px; padding: 2px;\")\n        metrics_layout.addWidget(label)\n    # Create labels dictionary for metrics update\n    labels_dict = {\n        \"iter_label\": iter_label,\n        \"j_tr_label\": j_tr_label,\n        \"j_vb_label\": j_vb_label,\n        \"j_vc_label\": j_vc_label,\n        \"objective_label\": objective_label,\n        \"lam_cost_display_label\": lam_cost_display_label,\n        \"dis_time_label\": dis_time_label,\n        \"solve_time_label\": solve_time_label,\n        \"status_label\": status_label,\n    }\n    control_layout.addWidget(metrics_group)\n    # Optimization Weights\n    weights_group = QGroupBox(\"Optimization Weights\")\n    weights_layout = QVBoxLayout()\n    weights_group.setLayout(weights_layout)\n    # Lambda cost input - Input on left, label on right\n    lam_cost_layout = QHBoxLayout()\n    lam_cost_input = QLineEdit()\n    lam_cost_input.setText(f\"{problem.settings.scp.lam_cost:.2E}\")\n    lam_cost_input.setFixedWidth(80)\n    lam_cost_input.returnPressed.connect(lambda: on_lam_cost_changed(lam_cost_input))\n    lam_cost_label = QLabel(\"\u03bb_cost:\")\n    lam_cost_label.setAlignment(Qt.AlignLeft)\n    lam_cost_layout.addWidget(lam_cost_input)\n    lam_cost_layout.addWidget(lam_cost_label)\n    lam_cost_layout.addStretch()  # Push everything to the left\n    weights_layout.addLayout(lam_cost_layout)\n    # Lambda trust region input - Input on left, label on right\n    lam_tr_layout = QHBoxLayout()\n    lam_tr_input = QLineEdit()\n    lam_tr_input.setText(f\"{problem.settings.scp.w_tr:.2E}\")\n    lam_tr_input.setFixedWidth(80)\n    lam_tr_input.returnPressed.connect(lambda: on_lam_tr_changed(lam_tr_input))\n    lam_tr_label = QLabel(\"\u03bb_tr:\")\n    lam_tr_label.setAlignment(Qt.AlignLeft)\n    lam_tr_layout.addWidget(lam_tr_input)\n    lam_tr_layout.addWidget(lam_tr_label)\n    lam_tr_layout.addStretch()  # Push everything to the left\n    weights_layout.addLayout(lam_tr_layout)\n    control_layout.addWidget(weights_group)\n    # Problem Control\n    problem_control_group = QGroupBox(\"Problem Control\")\n    problem_control_layout = QVBoxLayout()\n    problem_control_group.setLayout(problem_control_layout)\n    reset_problem_button = QPushButton(\"Reset Problem\")\n    reset_problem_button.clicked.connect(lambda: on_reset_clicked())\n    problem_control_layout.addWidget(reset_problem_button)\n    control_layout.addWidget(problem_control_group)\n    control_layout.addStretch()\n    # Add widgets to main layout\n    main_layout.addWidget(plot_widget, stretch=3)\n    main_layout.addWidget(control_panel, stretch=1)\n    main_widget.resize(800, 600)\n    main_widget.show()\n    # Create scatter plot item for trajectory\n    traj_scatter = pg.ScatterPlotItem(pen=None, symbol=\"o\", size=5, brush=\"b\")\n    plot_widget.addItem(traj_scatter)\n    # Create circle for obstacle with true radius\n    obs_circle = QGraphicsEllipseItem(\n        problem.parameters[\"obs_center\"][0] - problem.parameters[\"obs_radius\"],\n        problem.parameters[\"obs_center\"][1] - problem.parameters[\"obs_radius\"],\n        problem.parameters[\"obs_radius\"] * 2,\n        problem.parameters[\"obs_radius\"] * 2,\n    )\n    obs_circle.setPen(pg.mkPen(\"g\", width=2))\n    obs_circle.setBrush(pg.mkBrush(0, 255, 0, 60))\n    plot_widget.addItem(obs_circle)\n    # Set initial plot limits\n    plot_widget.setXRange(-2, 2)\n    plot_widget.setYRange(-2, 2)\n    # Update timer\n    timer = QTimer()\n\n    def update_plot():\n        if latest_results[\"results\"] is not None:\n            try:\n                V_multi_shoot = np.array(latest_results[\"results\"][\"V_multi_shoot\"])\n                n_x = problem.settings.sim.n_states\n                n_u = problem.settings.sim.n_controls\n                i1 = n_x\n                i2 = i1 + n_x * n_x\n                i3 = i2 + n_x * n_u\n                i4 = i3 + n_x * n_u\n                all_pos_segments = []\n                for i_node in range(V_multi_shoot.shape[1]):\n                    node_data = V_multi_shoot[:, i_node]\n                    segments_for_node = node_data.reshape(-1, i4)\n                    pos_segments = segments_for_node[:, :2]\n                    all_pos_segments.append(pos_segments)\n                if all_pos_segments:\n                    full_traj = np.vstack(all_pos_segments)\n                    traj_scatter.setData(full_traj[:, 0], full_traj[:, 1])\n                # Update obstacle circle position\n                obs_circle.setRect(\n                    problem.parameters[\"obs_center\"][0] - problem.parameters[\"obs_radius\"],\n                    problem.parameters[\"obs_center\"][1] - problem.parameters[\"obs_radius\"],\n                    problem.parameters[\"obs_radius\"] * 2,\n                    problem.parameters[\"obs_radius\"] * 2,\n                )\n                # Update optimization metrics display\n                update_optimization_metrics(latest_results[\"results\"], labels_dict)\n            except Exception as e:\n                print(f\"Plot update error: {e}\")\n                if \"x\" in latest_results[\"results\"]:\n                    x_traj = latest_results[\"results\"][\"x\"]  # Now a numpy array\n                    traj_scatter.setData(x_traj[:, 0], x_traj[:, 1])\n\n    timer.timeout.connect(update_plot)\n    timer.start(50)\n    app.exec_()\n\n\nif __name__ == \"__main__\":\n    # Start optimization thread\n    opt_thread = threading.Thread(target=optimization_loop)\n    opt_thread.daemon = True\n    opt_thread.start()\n    # Start plotting in main thread\n    plot_thread_func()\n</code></pre>"},{"location":"examples/realtime/obstacle_avoidance_realtime/","title":"Obstacle Avoidance Realtime","text":"<p>Interactive real-time visualization for drone obstacle avoidance using Viser.</p> <p>This module provides a web-based GUI for interactively solving and visualizing the drone obstacle avoidance trajectory optimization problem in real-time.</p> <p>Run this script and open the displayed URL in your browser.</p> <p>File: <code>examples/realtime/obstacle_avoidance_realtime.py</code></p> <pre><code>import os\nimport sys\nimport threading\nimport time\n\nimport matplotlib\nimport numpy as np\nimport viser\n\n# Get viridis colormap without pyplot (avoids potential backend issues)\n_viridis_cmap = matplotlib.colormaps[\"viridis\"]\n\n# Add grandparent directory to path to import examples\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nfrom examples.drone.obstacle_avoidance_realtime_base import (\n    obstacle_centers,\n    plotting_dict,\n    problem,\n)\nfrom examples.plotting_viser import (\n    build_scp_step_results,\n    compute_velocity_colors_realtime,\n    extract_multishoot_trajectory,\n    format_metrics_markdown,\n    get_print_queue_data,\n)\n\n# Initialize the problem\nproblem.initialize()\n\n\ndef create_realtime_server(\n    optimization_problem,\n    obstacle_params: list,\n    initial_centers: list,\n    initial_radii: list[float],\n    n_obstacles: int = 3,\n) -&gt; viser.ViserServer:\n    \"\"\"Create a viser server for real-time obstacle avoidance visualization.\n\n    Args:\n        optimization_problem: The OpenSCvx Problem instance\n        obstacle_params: List of obstacle center parameter objects\n        initial_centers: List of initial obstacle center positions\n        initial_radii: List of initial radii for each obstacle (scalar)\n        n_obstacles: Number of obstacles\n\n    Returns:\n        ViserServer instance\n    \"\"\"\n    server = viser.ViserServer()\n    server.gui.configure_theme(dark_mode=True)\n\n    # =========================================================================\n    # Scene Setup\n    # =========================================================================\n\n    # Grid\n    server.scene.add_grid(\n        \"/grid\",\n        width=30,\n        height=30,\n        position=(0.0, 0.0, 0.0),\n    )\n\n    # Origin frame\n    server.scene.add_frame(\n        \"/origin\",\n        wxyz=(1.0, 0.0, 0.0, 0.0),\n        position=(0.0, 0.0, 0.0),\n        axes_length=1.0,\n    )\n\n    # Trajectory point cloud (initially empty)\n    trajectory_handle = server.scene.add_point_cloud(\n        \"/trajectory\",\n        points=np.zeros((1, 3), dtype=np.float32),\n        colors=(255, 255, 0),\n        point_size=0.3,\n    )\n\n    # Obstacle icospheres\n    obstacle_handles = []\n    for i in range(n_obstacles):\n        center = obstacle_params[i].value\n        handle = server.scene.add_icosphere(\n            f\"/obstacles/sphere_{i}\",\n            radius=initial_radii[i],\n            color=(100, 255, 100),  # Green\n            position=tuple(center),\n        )\n        obstacle_handles.append(handle)\n\n    # Obstacle transform controls (draggable gizmos)\n    obstacle_drag_handles = []\n    for i in range(n_obstacles):\n        initial_pos = obstacle_params[i].value\n        drag_handle = server.scene.add_transform_controls(\n            f\"/obstacles/drag_{i}\",\n            position=tuple(initial_pos),\n            scale=1.5,\n            disable_rotations=True,  # Obstacles only need translation\n            visible=False,  # Hidden by default\n        )\n        obstacle_drag_handles.append(drag_handle)\n\n    # Track currently selected obstacle\n    selected_obstacle = {\"index\": None}\n\n    def select_obstacle(obs_idx: int | None) -&gt; None:\n        \"\"\"Select an obstacle and show its transform control, hiding others.\"\"\"\n        # Hide previously selected\n        if selected_obstacle[\"index\"] is not None:\n            obstacle_drag_handles[selected_obstacle[\"index\"]].visible = False\n            obstacle_handles[selected_obstacle[\"index\"]].color = (100, 255, 100)\n\n        # Show newly selected\n        if obs_idx is not None:\n            obstacle_drag_handles[obs_idx].visible = True\n            obstacle_handles[obs_idx].color = (150, 255, 150)  # Highlight\n            selected_obstacle[\"index\"] = obs_idx\n        else:\n            selected_obstacle[\"index\"] = None\n\n    # Add click handlers to obstacle icospheres\n    def make_obstacle_click_handler(obs_idx: int):\n        @obstacle_handles[obs_idx].on_click\n        def _(_) -&gt; None:\n            # Toggle: click selected obstacle again to deselect\n            if selected_obstacle[\"index\"] == obs_idx:\n                select_obstacle(None)\n            else:\n                select_obstacle(obs_idx)\n\n        return _\n\n    for i in range(n_obstacles):\n        make_obstacle_click_handler(i)\n\n    # =========================================================================\n    # Shared State\n    # =========================================================================\n\n    state = {\n        \"running\": True,\n        \"reset_requested\": False,\n    }\n\n    # =========================================================================\n    # GUI Controls\n    # =========================================================================\n\n    # --- Optimization Metrics ---\n    with server.gui.add_folder(\"Optimization Metrics\"):\n        metrics_text = server.gui.add_markdown(\n            \"\"\"**Iteration:** 0\n**J_tr:** 0.00E+00\n**J_vb:** 0.00E+00\n**J_vc:** 0.00E+00\n**Objective:** 0.00E+00\n**Dis Time:** 0.0ms\n**Solve Time:** 0.0ms\n**Status:** --\"\"\"\n        )\n\n    # --- Optimization Weights ---\n    with server.gui.add_folder(\"Optimization Weights\"):\n        lam_cost_input = server.gui.add_number(\n            \"\u03bb_cost\",\n            initial_value=optimization_problem.settings.scp.lam_cost,\n            min=1e-6,\n            max=1e6,\n            step=0.01,\n        )\n        lam_tr_input = server.gui.add_number(\n            \"\u03bb_tr (w_tr)\",\n            initial_value=optimization_problem.settings.scp.w_tr,\n            min=1e-6,\n            max=1e6,\n            step=0.1,\n        )\n\n        @lam_cost_input.on_update\n        def _(_) -&gt; None:\n            optimization_problem.settings.scp.lam_cost = lam_cost_input.value\n\n        @lam_tr_input.on_update\n        def _(_) -&gt; None:\n            optimization_problem.settings.scp.w_tr = lam_tr_input.value\n\n    # --- Problem Control ---\n    with server.gui.add_folder(\"Problem Control\"):\n        reset_button = server.gui.add_button(\"Reset Problem\")\n\n        @reset_button.on_click\n        def _(_) -&gt; None:\n            state[\"reset_requested\"] = True\n            print(\"Problem reset requested\")\n\n    # --- Obstacle Controls ---\n    obstacle_vector_inputs = []\n    with server.gui.add_folder(\"Obstacle Positions\", expand_by_default=False):\n        server.gui.add_markdown(\"*Click an obstacle in 3D view to select and drag it*\")\n\n        reset_obstacles_button = server.gui.add_button(\"Reset All Obstacles\")\n\n        @reset_obstacles_button.on_click\n        def _(_) -&gt; None:\n            # Deselect any selected obstacle\n            select_obstacle(None)\n            for i, vec_input in enumerate(obstacle_vector_inputs):\n                original = initial_centers[i]\n                vec_input.value = tuple(original)\n                obstacle_params[i].value = np.array(original)\n                param_name = f\"obstacle_center_{i + 1}\"\n                optimization_problem.parameters[param_name] = np.array(original)\n                # Update drag handle and obstacle positions\n                obstacle_drag_handles[i].position = tuple(original)\n                obstacle_handles[i].position = tuple(original)\n            print(\"Obstacles reset to initial positions\")\n\n        for i in range(n_obstacles):\n            initial_pos = obstacle_params[i].value\n            vec_input = server.gui.add_vector3(\n                f\"Obstacle {i + 1}\",\n                initial_value=tuple(initial_pos),\n                step=0.5,\n            )\n            obstacle_vector_inputs.append(vec_input)\n\n            # Callback for GUI vector3 input -&gt; update params and scene objects\n            def make_obstacle_gui_callback(obs_idx: int, input_handle):\n                @input_handle.on_update\n                def _(_) -&gt; None:\n                    new_center = np.array(input_handle.value)\n                    obstacle_params[obs_idx].value = new_center\n                    param_name = f\"obstacle_center_{obs_idx + 1}\"\n                    optimization_problem.parameters[param_name] = new_center\n                    # Sync drag handle and obstacle positions\n                    obstacle_drag_handles[obs_idx].position = tuple(new_center)\n                    obstacle_handles[obs_idx].position = tuple(new_center)\n\n                return _\n\n            make_obstacle_gui_callback(i, vec_input)\n\n    # Wire up drag handle callbacks (must be done after obstacle_vector_inputs is populated)\n    def make_drag_callback(obs_idx: int, drag_handle):\n        @drag_handle.on_update\n        def _(_) -&gt; None:\n            new_center = np.array(drag_handle.position)\n            obstacle_params[obs_idx].value = new_center\n            param_name = f\"obstacle_center_{obs_idx + 1}\"\n            optimization_problem.parameters[param_name] = new_center\n            # Sync GUI vector3 input and obstacle position\n            obstacle_vector_inputs[obs_idx].value = tuple(new_center)\n            obstacle_handles[obs_idx].position = tuple(new_center)\n\n        return _\n\n    for i in range(n_obstacles):\n        make_drag_callback(i, obstacle_drag_handles[i])\n\n    # =========================================================================\n    # Helper Functions\n    # =========================================================================\n\n    def update_metrics(results: dict) -&gt; None:\n        \"\"\"Update the metrics markdown display.\"\"\"\n        metrics_text.content = format_metrics_markdown(results)\n\n    def update_trajectory(V_multi_shoot: np.ndarray) -&gt; None:\n        \"\"\"Update the trajectory point cloud from multi-shoot data.\"\"\"\n        try:\n            n_x = optimization_problem.settings.sim.n_states\n            n_u = optimization_problem.settings.sim.n_controls\n\n            positions, velocities = extract_multishoot_trajectory(V_multi_shoot, n_x, n_u)\n\n            if len(positions) &gt; 0:\n                colors = compute_velocity_colors_realtime(velocities, _viridis_cmap)\n                trajectory_handle.points = positions\n                trajectory_handle.colors = colors\n\n        except Exception as e:\n            print(f\"Trajectory update error: {e}\")\n\n    def update_obstacles() -&gt; None:\n        \"\"\"Update obstacle visualizations based on current obstacle parameters.\"\"\"\n        for i, handle in enumerate(obstacle_handles):\n            center = obstacle_params[i].value\n            if center is not None:\n                handle.position = tuple(center)\n\n    # =========================================================================\n    # Optimization Worker\n    # =========================================================================\n\n    def optimization_loop() -&gt; None:\n        \"\"\"Background thread running continuous optimization.\"\"\"\n        iteration = 0\n\n        while state[\"running\"]:\n            try:\n                # Check for reset request\n                if state[\"reset_requested\"]:\n                    optimization_problem.reset()\n                    state[\"reset_requested\"] = False\n                    iteration = 0\n                    print(\"Problem reset to initial conditions\")\n\n                # Run one SCP step\n                start_time = time.time()\n                step_result = optimization_problem.step()\n                solve_time_ms = (time.time() - start_time) * 1000\n\n                # Build results dict\n                results = build_scp_step_results(step_result, solve_time_ms)\n                results.update(get_print_queue_data(optimization_problem))\n\n                # Update visualizations (viser is thread-safe)\n                update_metrics(results)\n                update_obstacles()\n\n                # Update trajectory from V_history\n                if optimization_problem.state.V_history:\n                    V_multi_shoot = np.array(optimization_problem.state.V_history[-1])\n                    update_trajectory(V_multi_shoot)\n\n                iteration += 1\n                time.sleep(0.05)  # Small delay to avoid overwhelming\n\n            except Exception as e:\n                print(f\"Optimization error: {e}\")\n                time.sleep(1.0)\n\n    # Start optimization thread\n    opt_thread = threading.Thread(target=optimization_loop, daemon=True)\n    opt_thread.start()\n\n    return server\n\n\nif __name__ == \"__main__\":\n    # Get initial obstacle centers from plotting_dict\n    initial_obstacle_centers = [center.copy() for center in plotting_dict[\"obstacles_centers\"]]\n\n    # Compute radii from ellipsoid parameters\n    initial_radii = []\n    for rad in plotting_dict[\"obstacles_radii\"]:\n        effective_radii = 1.0 / np.array(rad)\n        sphere_radius = float(np.min(effective_radii))  # Use smallest extent\n        initial_radii.append(sphere_radius)\n\n    # Create the viser server\n    server = create_realtime_server(\n        optimization_problem=problem,\n        obstacle_params=obstacle_centers,\n        initial_centers=initial_obstacle_centers,\n        initial_radii=initial_radii,\n        n_obstacles=3,\n    )\n\n    print(\"Viser server started. Open the URL in your browser.\")\n    server.sleep_forever()\n</code></pre>"},{"location":"examples/spacecraft/proxops_cw/","title":"Proxops Cw","text":"<p>Proximity Operations (ProxOps) using Clohessy-Wiltshire dynamics.</p> <p>This example demonstrates optimal trajectory generation for spacecraft proximity operations and docking using the Clohessy-Wiltshire (CW) equations for relative motion in a circular orbit. See Clohessy-Wiltshire equations for further details. The problem includes:</p> <ul> <li>3D relative position and velocity dynamics (CW equations)</li> <li>Fuel-optimal control (minimize delta-v)</li> <li>Thrust magnitude constraints</li> <li>Approach cone constraint for safe docking corridor</li> <li>Final docking at target (origin)</li> </ul> <p>The CW frame convention:</p> <ul> <li>x: radial direction (outward from Earth)</li> <li>y: along-track direction (velocity direction)</li> <li>z: cross-track direction (normal to orbit plane)</li> </ul> <p>File: <code>examples/spacecraft/proxops_cw.py</code></p> <pre><code>import os\nimport sys\n\nimport numpy as np\n\n# Add grandparent directory to path to import examples.plotting\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\ngrandparent_dir = os.path.dirname(os.path.dirname(current_dir))\nsys.path.append(grandparent_dir)\n\nimport openscvx as ox\nfrom examples.plotting_viser import (\n    create_animated_plotting_server,\n    create_scp_animated_plotting_server,\n)\nfrom openscvx import Problem\nfrom openscvx.plotting import plot_scp_iterations\nfrom openscvx.plotting.viser import add_glideslope_cone\n\n# Problem parameters\nn_nodes = 5  # Number of discretization nodes\ntotal_time = 180.0  # Total maneuver time in seconds\n\n# Orbital parameters (ISS-like orbit at ~400 km altitude)\nmu = 3.986004418e14  # Earth gravitational parameter [m^3/s^2]\na = 6.778e6  # Semi-major axis [m] (Earth radius + 400 km)\nn = np.sqrt(mu / a**3)  # Mean motion [rad/s] (~0.00113 rad/s)\n\n# Define state components\n# Position in CW frame [x, y, z] in meters\nposition = ox.State(\"position\", shape=(3,))\nposition.max = np.array([100.0, 100.0, 100.0])\nposition.min = np.array([-100.0, -100.0, -100.0])\nposition.initial = np.array([0.0, -100.0, 0.0])  # Start 100m behind target (V-bar position)\nposition.final = np.array([0.0, 0.0, 0.0])  # Dock at origin\n\n# Velocity in CW frame [vx, vy, vz] in m/s\nvelocity = ox.State(\"velocity\", shape=(3,))\nv_max = 2.0  # Maximum relative velocity [m/s]\nvelocity.max = np.array([v_max, v_max, v_max])\nvelocity.min = np.array([-v_max, -v_max, -v_max])\nvelocity.initial = [0.0, 2.0, 0.0]\nvelocity.final = np.array([0.0, 0.0, 0.0])  # Zero relative velocity at docking\nvelocity.guess = np.zeros((n_nodes, 3))\n\n# Define control: acceleration from thrusters [ax, ay, az] in m/s^2\naccel = ox.Control(\"accel\", shape=(3,))\na_max = 0.1  # Maximum acceleration [m/s^2] (typical for reaction control thrusters)\naccel.max = np.array([a_max, a_max, a_max])\naccel.min = np.array([-a_max, -a_max, -a_max])\naccel.guess = np.zeros((n_nodes, 3))\n\n# Define list of all states and controls\nstates = [position, velocity]\ncontrols = [accel]\n\n# Generate constraints\nconstraints = []\n\n# Box constraints for states\nfor state in states:\n    constraints.extend(\n        [\n            ox.ctcs(state &lt;= state.max),\n            ox.ctcs(state.min &lt;= state),\n        ]\n    )\n\n# R-bar approach cone constraint (from below, -x direction)\n# Enforces sqrt(y^2 + z^2) &lt;= tan(theta) * (-x)\n# This requires the spacecraft to approach from negative x (below target)\n# and stay within a cone centered on the -x axis\ncone_half_angle = 20 * np.pi / 180  # 20 degree half-angle\nconstraints.append(\n    ox.ctcs(ox.linalg.Norm(position[1:]) &lt;= np.tan(cone_half_angle) * (-position[0])).over(\n        (n_nodes - 3, n_nodes - 1)\n    )\n)\n# Enforce entrance to the cone at safe distance\nconstraints.append((-position[0] &gt;= 20.0).at([n_nodes - 3]))\n\n# Clohessy-Wiltshire dynamics\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": ox.Concat(\n        3 * n**2 * position[0] + 2 * n * velocity[1] + accel[0],\n        -2 * n * velocity[0] + accel[1],\n        -(n**2) * position[2] + accel[2],\n    ),\n}\n\n# Time configuration (free final time to minimize fuel)\ntime = ox.Time(\n    initial=0.0,\n    final=(\"free\", total_time),\n    min=0.0,\n    max=total_time,\n)\n\n# Build the problem\nproblem = Problem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n_nodes,\n)\n\n# Solver settings (FOH is default, no need to set explicitly)\nproblem.settings.dis.dis_type = \"ZOH\"\nproblem.settings.scp.k_max = 100\nproblem.settings.scp.w_tr = 1e0\nproblem.settings.scp.w_tr_adapt = 1.2\nproblem.settings.scp.lam_cost = 1e-1\nproblem.settings.scp.lam_vc = 1e1\nproblem.settings.scp.lam_vb = 1e0\n\n# Plotting metadata\nplotting_dict = {\n    \"mean_motion\": n,\n}\n\nif __name__ == \"__main__\":\n    problem.initialize()\n    results = problem.solve()\n    results = problem.post_process()\n    results.update(plotting_dict)\n\n    # Plot results\n    plot_scp_iterations(results).show()\n\n    # Create animation\n    traj_server = create_animated_plotting_server(results, thrust_key=\"accel\", show_grid=False)\n\n    # Add R-bar approach cone (opens in -x direction)\n    add_glideslope_cone(\n        traj_server,\n        apex=(0, 0, 0),\n        height=20.0,  # Cone extends 100m in -x direction\n        glideslope_angle_deg=cone_half_angle * 180 / np.pi,\n        axis=(-1, 0, 0),  # R-bar: negative radial direction\n        color=(200, 80, 80),\n        opacity=0.5,\n    )\n\n    # Create SCP iteration visualization\n    scp_server = create_scp_animated_plotting_server(\n        results,\n        frame_duration_ms=200,\n        scene_scale=1.0,\n        show_grid=False,\n    )\n\n    # Add R-bar approach cone to SCP visualization\n    add_glideslope_cone(\n        scp_server,\n        apex=(0, 0, 0),\n        height=20.0,\n        glideslope_angle_deg=cone_half_angle * 180 / np.pi,\n        axis=(-1, 0, 0),\n        color=(200, 80, 80),\n        opacity=0.5,\n    )\n\n    scp_server.sleep_forever()\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>algorithms<ul> <li>autotuning</li> <li>base</li> <li>optimization_results</li> <li>penalized_trust_region</li> </ul> </li> <li>config</li> <li>discretization<ul> <li>discretization</li> </ul> </li> <li>expert<ul> <li>byof</li> <li>lowering</li> <li>validation</li> </ul> </li> <li>integrators<ul> <li>runge_kutta</li> </ul> </li> <li>lowered<ul> <li>cvxpy_constraints</li> <li>cvxpy_variables</li> <li>dynamics</li> <li>jax_constraints</li> <li>parameters</li> <li>problem</li> <li>unified</li> </ul> </li> <li>plotting<ul> <li>plotting</li> <li>scp_iteration</li> <li>viser<ul> <li>animated</li> <li>plotly_integration</li> <li>primitives</li> <li>scp</li> <li>server</li> </ul> </li> </ul> </li> <li>problem</li> <li>propagation<ul> <li>post_processing</li> <li>propagation</li> </ul> </li> <li>solvers<ul> <li>cvxpy</li> </ul> </li> <li>symbolic<ul> <li>augmentation</li> <li>builder</li> <li>constraint_set</li> <li>expr<ul> <li>arithmetic</li> <li>array</li> <li>constraint</li> <li>control</li> <li>expr</li> <li>lie<ul> <li>adjoint</li> <li>se3</li> <li>so3</li> </ul> </li> <li>linalg</li> <li>math</li> <li>spatial</li> <li>state</li> <li>stl</li> <li>variable</li> <li>vmap</li> </ul> </li> <li>hashing</li> <li>lower</li> <li>lowerers<ul> <li>cvxpy</li> <li>jax</li> </ul> </li> <li>preprocessing</li> <li>problem</li> <li>time</li> <li>unified</li> </ul> </li> <li>utils<ul> <li>cache</li> <li>caching</li> <li>printing</li> <li>profiling</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/config/","title":"config","text":""},{"location":"reference/config/#openscvx.config.ConvexSolverConfig","title":"<code>ConvexSolverConfig</code>  <code>dataclass</code>","text":"Source code in <code>openscvx/config.py</code> <pre><code>@dataclass\nclass ConvexSolverConfig:\n    def __init__(\n        self,\n        solver: str = \"QOCO\",\n        solver_args: Optional[dict] = None,\n        cvxpygen: bool = False,\n        cvxpygen_override: bool = False,\n    ):\n        \"\"\"\n        Configuration class for convex solver settings.\n\n        This class defines the parameters required for configuring a convex solver.\n\n        These are the arguments most commonly used day-to-day. Generally I have\n        found [QOCO](https://qoco-org.github.io/qoco/index.html) to be the most\n        performant of the CVXPY solvers for these types of problems (I do have a\n        bias as the author is from my group) and can handle up to SOCP's.\n        [CLARABEL](https://clarabel.org/stable/) is also a great option with\n        feasibility checking and can handle a few more problem types.\n        [CVXPYGen](https://github.com/cvxgrp/cvxpygen) is also great if your\n        problem isn't too large. I have found qocogen to be the most performant\n        of the CVXPYGen solvers.\n\n        Args:\n            solver (str): The name of the CVXPY solver to use. A list of options\n                can be found [here](https://www.cvxpy.org/tutorial/solvers/\n                index.html). Defaults to \"QOCO\".\n            solver_args (dict, optional): Ensure you are using the correct\n                arguments for your solver as they are not all common. Additional\n                arguments to configure the solver, such as tolerances. Defaults\n                to {\"abstol\": 1e-6, \"reltol\": 1e-9}.\n            cvxpygen (bool): Whether to enable CVXPY code generation for the\n                solver. Defaults to False.\n        \"\"\"\n        if solver_args is None:\n            solver_args = {\"abstol\": 1e-06, \"reltol\": 1e-09, \"enforce_dpp\": True}\n        self.solver = solver\n        self.solver_args = (\n            solver_args if solver_args is not None else {\"abstol\": 1e-6, \"reltol\": 1e-9}\n        )\n        self.cvxpygen = cvxpygen\n        self.cvxpygen_override = cvxpygen_override\n</code></pre>"},{"location":"reference/config/#openscvx.config.ConvexSolverConfig.__init__","title":"<code>__init__(solver: str = 'QOCO', solver_args: Optional[dict] = None, cvxpygen: bool = False, cvxpygen_override: bool = False)</code>","text":"<p>Configuration class for convex solver settings.</p> <p>This class defines the parameters required for configuring a convex solver.</p> <p>These are the arguments most commonly used day-to-day. Generally I have found QOCO to be the most performant of the CVXPY solvers for these types of problems (I do have a bias as the author is from my group) and can handle up to SOCP's. CLARABEL is also a great option with feasibility checking and can handle a few more problem types. CVXPYGen is also great if your problem isn't too large. I have found qocogen to be the most performant of the CVXPYGen solvers.</p> <p>Parameters:</p> Name Type Description Default <code>solver</code> <code>str</code> <p>The name of the CVXPY solver to use. A list of options can be found here. Defaults to \"QOCO\".</p> <code>'QOCO'</code> <code>solver_args</code> <code>dict</code> <p>Ensure you are using the correct arguments for your solver as they are not all common. Additional arguments to configure the solver, such as tolerances. Defaults to {\"abstol\": 1e-6, \"reltol\": 1e-9}.</p> <code>None</code> <code>cvxpygen</code> <code>bool</code> <p>Whether to enable CVXPY code generation for the solver. Defaults to False.</p> <code>False</code> Source code in <code>openscvx/config.py</code> <pre><code>def __init__(\n    self,\n    solver: str = \"QOCO\",\n    solver_args: Optional[dict] = None,\n    cvxpygen: bool = False,\n    cvxpygen_override: bool = False,\n):\n    \"\"\"\n    Configuration class for convex solver settings.\n\n    This class defines the parameters required for configuring a convex solver.\n\n    These are the arguments most commonly used day-to-day. Generally I have\n    found [QOCO](https://qoco-org.github.io/qoco/index.html) to be the most\n    performant of the CVXPY solvers for these types of problems (I do have a\n    bias as the author is from my group) and can handle up to SOCP's.\n    [CLARABEL](https://clarabel.org/stable/) is also a great option with\n    feasibility checking and can handle a few more problem types.\n    [CVXPYGen](https://github.com/cvxgrp/cvxpygen) is also great if your\n    problem isn't too large. I have found qocogen to be the most performant\n    of the CVXPYGen solvers.\n\n    Args:\n        solver (str): The name of the CVXPY solver to use. A list of options\n            can be found [here](https://www.cvxpy.org/tutorial/solvers/\n            index.html). Defaults to \"QOCO\".\n        solver_args (dict, optional): Ensure you are using the correct\n            arguments for your solver as they are not all common. Additional\n            arguments to configure the solver, such as tolerances. Defaults\n            to {\"abstol\": 1e-6, \"reltol\": 1e-9}.\n        cvxpygen (bool): Whether to enable CVXPY code generation for the\n            solver. Defaults to False.\n    \"\"\"\n    if solver_args is None:\n        solver_args = {\"abstol\": 1e-06, \"reltol\": 1e-09, \"enforce_dpp\": True}\n    self.solver = solver\n    self.solver_args = (\n        solver_args if solver_args is not None else {\"abstol\": 1e-6, \"reltol\": 1e-9}\n    )\n    self.cvxpygen = cvxpygen\n    self.cvxpygen_override = cvxpygen_override\n</code></pre>"},{"location":"reference/config/#openscvx.config.DevConfig","title":"<code>DevConfig</code>  <code>dataclass</code>","text":"Source code in <code>openscvx/config.py</code> <pre><code>@dataclass\nclass DevConfig:\n    def __init__(self, profiling: bool = False, debug: bool = False, printing: bool = True):\n        \"\"\"\n        Configuration class for development settings.\n\n        This class defines the parameters used for development and debugging\n        purposes.\n\n        Main arguments:\n        These are the arguments most commonly used day-to-day.\n\n        Args:\n            profiling (bool): Whether to enable profiling for performance\n                analysis. Defaults to False.\n            debug (bool): Disables all precompilation so you can place\n                breakpoints and inspect values. Defaults to False.\n            printing (bool): Whether to enable printing during development.\n                Defaults to True.\n        \"\"\"\n        self.profiling = profiling\n        self.debug = debug\n        self.printing = printing\n</code></pre>"},{"location":"reference/config/#openscvx.config.DevConfig.__init__","title":"<code>__init__(profiling: bool = False, debug: bool = False, printing: bool = True)</code>","text":"<p>Configuration class for development settings.</p> <p>This class defines the parameters used for development and debugging purposes.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>profiling</code> <code>bool</code> <p>Whether to enable profiling for performance analysis. Defaults to False.</p> <code>False</code> <code>debug</code> <code>bool</code> <p>Disables all precompilation so you can place breakpoints and inspect values. Defaults to False.</p> <code>False</code> <code>printing</code> <code>bool</code> <p>Whether to enable printing during development. Defaults to True.</p> <code>True</code> Source code in <code>openscvx/config.py</code> <pre><code>def __init__(self, profiling: bool = False, debug: bool = False, printing: bool = True):\n    \"\"\"\n    Configuration class for development settings.\n\n    This class defines the parameters used for development and debugging\n    purposes.\n\n    Main arguments:\n    These are the arguments most commonly used day-to-day.\n\n    Args:\n        profiling (bool): Whether to enable profiling for performance\n            analysis. Defaults to False.\n        debug (bool): Disables all precompilation so you can place\n            breakpoints and inspect values. Defaults to False.\n        printing (bool): Whether to enable printing during development.\n            Defaults to True.\n    \"\"\"\n    self.profiling = profiling\n    self.debug = debug\n    self.printing = printing\n</code></pre>"},{"location":"reference/config/#openscvx.config.DiscretizationConfig","title":"<code>DiscretizationConfig</code>  <code>dataclass</code>","text":"Source code in <code>openscvx/config.py</code> <pre><code>@dataclass\nclass DiscretizationConfig:\n    def __init__(\n        self,\n        dis_type: str = \"FOH\",\n        custom_integrator: bool = False,\n        solver: str = \"Tsit5\",\n        args: Optional[dict] = None,\n        atol: float = 1e-3,\n        rtol: float = 1e-6,\n    ):\n        \"\"\"\n        Configuration class for discretization settings.\n\n        This class defines the parameters required for discretizing system dynamics.\n\n        Main arguments:\n        These are the arguments most commonly used day-to-day.\n\n        Args:\n            dis_type (str): The type of discretization to use (e.g., \"FOH\" for\n                First-Order Hold). Defaults to \"FOH\".\n            custom_integrator (bool): This enables our custom fixed-step RK45\n                algorithm. This tends to be faster than Diffrax but unless you're\n                going for speed, it's recommended to stick with Diffrax for\n                robustness and other solver options. Defaults to False.\n            solver (str): Not used if custom_integrator is enabled. Any choice of\n                solver in Diffrax is valid, please refer here,\n                [How to Choose a Solver](https://docs.kidger.site/diffrax/usage/\n                how-to-choose-a-solver/). Defaults to \"Tsit5\".\n\n        Other arguments:\n        These arguments are less frequently used, and for most purposes you\n        shouldn't need to understand these.\n\n        Args:\n            args (Dict): Additional arguments to pass to the solver which can be\n                found [here](https://docs.kidger.site/diffrax/api/diffeqsolve/).\n                Defaults to an empty dictionary.\n            atol (float): Absolute tolerance for the solver. Defaults to 1e-3.\n            rtol (float): Relative tolerance for the solver. Defaults to 1e-6.\n        \"\"\"\n        self.dis_type = dis_type\n        self.custom_integrator = custom_integrator\n        self.solver = solver\n        self.args = args if args is not None else {}\n        self.atol = atol\n        self.rtol = rtol\n</code></pre>"},{"location":"reference/config/#openscvx.config.DiscretizationConfig.__init__","title":"<code>__init__(dis_type: str = 'FOH', custom_integrator: bool = False, solver: str = 'Tsit5', args: Optional[dict] = None, atol: float = 0.001, rtol: float = 1e-06)</code>","text":"<p>Configuration class for discretization settings.</p> <p>This class defines the parameters required for discretizing system dynamics.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>dis_type</code> <code>str</code> <p>The type of discretization to use (e.g., \"FOH\" for First-Order Hold). Defaults to \"FOH\".</p> <code>'FOH'</code> <code>custom_integrator</code> <code>bool</code> <p>This enables our custom fixed-step RK45 algorithm. This tends to be faster than Diffrax but unless you're going for speed, it's recommended to stick with Diffrax for robustness and other solver options. Defaults to False.</p> <code>False</code> <code>solver</code> <code>str</code> <p>Not used if custom_integrator is enabled. Any choice of solver in Diffrax is valid, please refer here, How to Choose a Solver. Defaults to \"Tsit5\".</p> <code>'Tsit5'</code> <p>Other arguments: These arguments are less frequently used, and for most purposes you shouldn't need to understand these.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Dict</code> <p>Additional arguments to pass to the solver which can be found here. Defaults to an empty dictionary.</p> <code>None</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for the solver. Defaults to 1e-3.</p> <code>0.001</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for the solver. Defaults to 1e-6.</p> <code>1e-06</code> Source code in <code>openscvx/config.py</code> <pre><code>def __init__(\n    self,\n    dis_type: str = \"FOH\",\n    custom_integrator: bool = False,\n    solver: str = \"Tsit5\",\n    args: Optional[dict] = None,\n    atol: float = 1e-3,\n    rtol: float = 1e-6,\n):\n    \"\"\"\n    Configuration class for discretization settings.\n\n    This class defines the parameters required for discretizing system dynamics.\n\n    Main arguments:\n    These are the arguments most commonly used day-to-day.\n\n    Args:\n        dis_type (str): The type of discretization to use (e.g., \"FOH\" for\n            First-Order Hold). Defaults to \"FOH\".\n        custom_integrator (bool): This enables our custom fixed-step RK45\n            algorithm. This tends to be faster than Diffrax but unless you're\n            going for speed, it's recommended to stick with Diffrax for\n            robustness and other solver options. Defaults to False.\n        solver (str): Not used if custom_integrator is enabled. Any choice of\n            solver in Diffrax is valid, please refer here,\n            [How to Choose a Solver](https://docs.kidger.site/diffrax/usage/\n            how-to-choose-a-solver/). Defaults to \"Tsit5\".\n\n    Other arguments:\n    These arguments are less frequently used, and for most purposes you\n    shouldn't need to understand these.\n\n    Args:\n        args (Dict): Additional arguments to pass to the solver which can be\n            found [here](https://docs.kidger.site/diffrax/api/diffeqsolve/).\n            Defaults to an empty dictionary.\n        atol (float): Absolute tolerance for the solver. Defaults to 1e-3.\n        rtol (float): Relative tolerance for the solver. Defaults to 1e-6.\n    \"\"\"\n    self.dis_type = dis_type\n    self.custom_integrator = custom_integrator\n    self.solver = solver\n    self.args = args if args is not None else {}\n    self.atol = atol\n    self.rtol = rtol\n</code></pre>"},{"location":"reference/config/#openscvx.config.PropagationConfig","title":"<code>PropagationConfig</code>  <code>dataclass</code>","text":"Source code in <code>openscvx/config.py</code> <pre><code>@dataclass\nclass PropagationConfig:\n    def __init__(\n        self,\n        inter_sample: int = 30,\n        dt: float = 0.01,\n        solver: str = \"Dopri8\",\n        max_tau_len: int = 1000,\n        args: Optional[dict] = None,\n        atol: float = 1e-3,\n        rtol: float = 1e-6,\n    ):\n        \"\"\"\n        Configuration class for propagation settings.\n\n        This class defines the parameters required for propagating the nonlinear\n        system dynamics using the optimal control sequence.\n\n        Main arguments:\n        These are the arguments most commonly used day-to-day.\n\n        Other arguments:\n        The solver should likely not be changed as it is a high accuracy 8th-order\n        Runge-Kutta method.\n\n        Args:\n            inter_sample (int): How dense the propagation within multishot\n                discretization should be. Defaults to 30.\n            dt (float): The time step for propagation. Defaults to 0.1.\n            solver (str): The numerical solver to use for propagation\n                (e.g., \"Dopri8\"). Defaults to \"Dopri8\".\n            max_tau_len (int): The maximum length of the time vector for\n                propagation. Defaults to 1000.\n            args (Dict, optional): Additional arguments to pass to the solver.\n                Defaults to an empty dictionary.\n            atol (float): Absolute tolerance for the solver. Defaults to 1e-3.\n            rtol (float): Relative tolerance for the solver. Defaults to 1e-6.\n        \"\"\"\n        self.inter_sample = inter_sample\n        self.dt = dt\n        self.solver = solver\n        self.max_tau_len = max_tau_len\n        self.args = args if args is not None else {}\n        self.atol = atol\n        self.rtol = rtol\n</code></pre>"},{"location":"reference/config/#openscvx.config.PropagationConfig.__init__","title":"<code>__init__(inter_sample: int = 30, dt: float = 0.01, solver: str = 'Dopri8', max_tau_len: int = 1000, args: Optional[dict] = None, atol: float = 0.001, rtol: float = 1e-06)</code>","text":"<p>Configuration class for propagation settings.</p> <p>This class defines the parameters required for propagating the nonlinear system dynamics using the optimal control sequence.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Other arguments: The solver should likely not be changed as it is a high accuracy 8th-order Runge-Kutta method.</p> <p>Parameters:</p> Name Type Description Default <code>inter_sample</code> <code>int</code> <p>How dense the propagation within multishot discretization should be. Defaults to 30.</p> <code>30</code> <code>dt</code> <code>float</code> <p>The time step for propagation. Defaults to 0.1.</p> <code>0.01</code> <code>solver</code> <code>str</code> <p>The numerical solver to use for propagation (e.g., \"Dopri8\"). Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>max_tau_len</code> <code>int</code> <p>The maximum length of the time vector for propagation. Defaults to 1000.</p> <code>1000</code> <code>args</code> <code>Dict</code> <p>Additional arguments to pass to the solver. Defaults to an empty dictionary.</p> <code>None</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for the solver. Defaults to 1e-3.</p> <code>0.001</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for the solver. Defaults to 1e-6.</p> <code>1e-06</code> Source code in <code>openscvx/config.py</code> <pre><code>def __init__(\n    self,\n    inter_sample: int = 30,\n    dt: float = 0.01,\n    solver: str = \"Dopri8\",\n    max_tau_len: int = 1000,\n    args: Optional[dict] = None,\n    atol: float = 1e-3,\n    rtol: float = 1e-6,\n):\n    \"\"\"\n    Configuration class for propagation settings.\n\n    This class defines the parameters required for propagating the nonlinear\n    system dynamics using the optimal control sequence.\n\n    Main arguments:\n    These are the arguments most commonly used day-to-day.\n\n    Other arguments:\n    The solver should likely not be changed as it is a high accuracy 8th-order\n    Runge-Kutta method.\n\n    Args:\n        inter_sample (int): How dense the propagation within multishot\n            discretization should be. Defaults to 30.\n        dt (float): The time step for propagation. Defaults to 0.1.\n        solver (str): The numerical solver to use for propagation\n            (e.g., \"Dopri8\"). Defaults to \"Dopri8\".\n        max_tau_len (int): The maximum length of the time vector for\n            propagation. Defaults to 1000.\n        args (Dict, optional): Additional arguments to pass to the solver.\n            Defaults to an empty dictionary.\n        atol (float): Absolute tolerance for the solver. Defaults to 1e-3.\n        rtol (float): Relative tolerance for the solver. Defaults to 1e-6.\n    \"\"\"\n    self.inter_sample = inter_sample\n    self.dt = dt\n    self.solver = solver\n    self.max_tau_len = max_tau_len\n    self.args = args if args is not None else {}\n    self.atol = atol\n    self.rtol = rtol\n</code></pre>"},{"location":"reference/config/#openscvx.config.ScpConfig","title":"<code>ScpConfig</code>  <code>dataclass</code>","text":"Source code in <code>openscvx/config.py</code> <pre><code>@dataclass\nclass ScpConfig:\n    def __init__(\n        self,\n        n: Optional[int] = None,\n        k_max: int = 200,\n        w_tr: float = 1.0,\n        lam_vc: float = 1.0,\n        ep_tr: float = 1e-4,\n        ep_vb: float = 1e-4,\n        ep_vc: float = 1e-8,\n        lam_cost: float = 0.0,\n        lam_vb: float = 0.0,\n        uniform_time_grid: bool = False,\n        cost_drop: int = -1,\n        cost_relax: float = 1.0,\n        w_tr_adapt: float = 1.0,\n        w_tr_max: Optional[float] = None,\n        w_tr_max_scaling_factor: Optional[float] = None,\n    ):\n        \"\"\"\n        Configuration class for Sequential Convex Programming (SCP).\n\n        This class defines the parameters used to configure the SCP solver. You\n        will very likely need to modify the weights for your problem. Please\n        refer to my guide [here](https://haynec.github.io/openscvx/\n        hyperparameter_tuning) for more information.\n\n        Attributes:\n            n (int): The number of discretization nodes. Defaults to `None`.\n            k_max (int): The maximum number of SCP iterations. Defaults to 200.\n            w_tr (float): The trust region weight. Defaults to 1.0.\n            lam_vc (float): The penalty weight for virtual control. Defaults to 1.0.\n            ep_tr (float): The trust region convergence tolerance. Defaults to 1e-4.\n            ep_vb (float): The boundary constraint convergence tolerance.\n                Defaults to 1e-4.\n            ep_vc (float): The virtual constraint convergence tolerance.\n                Defaults to 1e-8.\n            lam_cost (float): The weight for original cost. Defaults to 0.0.\n            lam_vb (float): The weight for virtual buffer. This is only used if\n                there are nonconvex nodal constraints present. Defaults to 0.0.\n            uniform_time_grid (bool): Whether to use a uniform time grid.\n                Defaults to `False`.\n            cost_drop (int): The number of iterations to allow for cost\n                stagnation before termination. Defaults to -1 (disabled).\n            cost_relax (float): The relaxation factor for cost reduction.\n                Defaults to 1.0.\n            w_tr_adapt (float): The adaptation factor for the trust region\n                weight. Defaults to 1.0.\n            w_tr_max (float): The maximum allowable trust region weight.\n                Defaults to `None`.\n            w_tr_max_scaling_factor (float): The scaling factor for the maximum\n                trust region weight. Defaults to `None`.\n        \"\"\"\n        self.n = n\n        self.k_max = k_max\n        self.w_tr = w_tr\n        self.lam_vc = lam_vc\n        self.ep_tr = ep_tr\n        self.ep_vb = ep_vb\n        self.ep_vc = ep_vc\n        self.lam_cost = lam_cost\n        self.lam_vb = lam_vb\n        self.uniform_time_grid = uniform_time_grid\n        self.cost_drop = cost_drop\n        self.cost_relax = cost_relax\n        self.w_tr_adapt = w_tr_adapt\n        self.w_tr_max = w_tr_max\n        self.w_tr_max_scaling_factor = w_tr_max_scaling_factor\n\n    def __post_init__(self):\n        keys_to_scale = [\"w_tr\", \"lam_vc\", \"lam_cost\", \"lam_vb\"]\n        # Handle lam_vc which might be scalar or array\n        scale_values = []\n        for key in keys_to_scale:\n            val = getattr(self, key)\n            if isinstance(val, np.ndarray):\n                scale_values.append(np.max(val))\n            else:\n                scale_values.append(val)\n        scale = max(scale_values)\n        for key in keys_to_scale:\n            val = getattr(self, key)\n            if isinstance(val, np.ndarray):\n                setattr(self, key, val / scale)\n            else:\n                setattr(self, key, val / scale)\n\n        if self.w_tr_max_scaling_factor is not None and self.w_tr_max is None:\n            self.w_tr_max = self.w_tr_max_scaling_factor * self.w_tr\n</code></pre>"},{"location":"reference/config/#openscvx.config.ScpConfig.__init__","title":"<code>__init__(n: Optional[int] = None, k_max: int = 200, w_tr: float = 1.0, lam_vc: float = 1.0, ep_tr: float = 0.0001, ep_vb: float = 0.0001, ep_vc: float = 1e-08, lam_cost: float = 0.0, lam_vb: float = 0.0, uniform_time_grid: bool = False, cost_drop: int = -1, cost_relax: float = 1.0, w_tr_adapt: float = 1.0, w_tr_max: Optional[float] = None, w_tr_max_scaling_factor: Optional[float] = None)</code>","text":"<p>Configuration class for Sequential Convex Programming (SCP).</p> <p>This class defines the parameters used to configure the SCP solver. You will very likely need to modify the weights for your problem. Please refer to my guide here for more information.</p> <p>Attributes:</p> Name Type Description <code>n</code> <code>int</code> <p>The number of discretization nodes. Defaults to <code>None</code>.</p> <code>k_max</code> <code>int</code> <p>The maximum number of SCP iterations. Defaults to 200.</p> <code>w_tr</code> <code>float</code> <p>The trust region weight. Defaults to 1.0.</p> <code>lam_vc</code> <code>float</code> <p>The penalty weight for virtual control. Defaults to 1.0.</p> <code>ep_tr</code> <code>float</code> <p>The trust region convergence tolerance. Defaults to 1e-4.</p> <code>ep_vb</code> <code>float</code> <p>The boundary constraint convergence tolerance. Defaults to 1e-4.</p> <code>ep_vc</code> <code>float</code> <p>The virtual constraint convergence tolerance. Defaults to 1e-8.</p> <code>lam_cost</code> <code>float</code> <p>The weight for original cost. Defaults to 0.0.</p> <code>lam_vb</code> <code>float</code> <p>The weight for virtual buffer. This is only used if there are nonconvex nodal constraints present. Defaults to 0.0.</p> <code>uniform_time_grid</code> <code>bool</code> <p>Whether to use a uniform time grid. Defaults to <code>False</code>.</p> <code>cost_drop</code> <code>int</code> <p>The number of iterations to allow for cost stagnation before termination. Defaults to -1 (disabled).</p> <code>cost_relax</code> <code>float</code> <p>The relaxation factor for cost reduction. Defaults to 1.0.</p> <code>w_tr_adapt</code> <code>float</code> <p>The adaptation factor for the trust region weight. Defaults to 1.0.</p> <code>w_tr_max</code> <code>float</code> <p>The maximum allowable trust region weight. Defaults to <code>None</code>.</p> <code>w_tr_max_scaling_factor</code> <code>float</code> <p>The scaling factor for the maximum trust region weight. Defaults to <code>None</code>.</p> Source code in <code>openscvx/config.py</code> <pre><code>def __init__(\n    self,\n    n: Optional[int] = None,\n    k_max: int = 200,\n    w_tr: float = 1.0,\n    lam_vc: float = 1.0,\n    ep_tr: float = 1e-4,\n    ep_vb: float = 1e-4,\n    ep_vc: float = 1e-8,\n    lam_cost: float = 0.0,\n    lam_vb: float = 0.0,\n    uniform_time_grid: bool = False,\n    cost_drop: int = -1,\n    cost_relax: float = 1.0,\n    w_tr_adapt: float = 1.0,\n    w_tr_max: Optional[float] = None,\n    w_tr_max_scaling_factor: Optional[float] = None,\n):\n    \"\"\"\n    Configuration class for Sequential Convex Programming (SCP).\n\n    This class defines the parameters used to configure the SCP solver. You\n    will very likely need to modify the weights for your problem. Please\n    refer to my guide [here](https://haynec.github.io/openscvx/\n    hyperparameter_tuning) for more information.\n\n    Attributes:\n        n (int): The number of discretization nodes. Defaults to `None`.\n        k_max (int): The maximum number of SCP iterations. Defaults to 200.\n        w_tr (float): The trust region weight. Defaults to 1.0.\n        lam_vc (float): The penalty weight for virtual control. Defaults to 1.0.\n        ep_tr (float): The trust region convergence tolerance. Defaults to 1e-4.\n        ep_vb (float): The boundary constraint convergence tolerance.\n            Defaults to 1e-4.\n        ep_vc (float): The virtual constraint convergence tolerance.\n            Defaults to 1e-8.\n        lam_cost (float): The weight for original cost. Defaults to 0.0.\n        lam_vb (float): The weight for virtual buffer. This is only used if\n            there are nonconvex nodal constraints present. Defaults to 0.0.\n        uniform_time_grid (bool): Whether to use a uniform time grid.\n            Defaults to `False`.\n        cost_drop (int): The number of iterations to allow for cost\n            stagnation before termination. Defaults to -1 (disabled).\n        cost_relax (float): The relaxation factor for cost reduction.\n            Defaults to 1.0.\n        w_tr_adapt (float): The adaptation factor for the trust region\n            weight. Defaults to 1.0.\n        w_tr_max (float): The maximum allowable trust region weight.\n            Defaults to `None`.\n        w_tr_max_scaling_factor (float): The scaling factor for the maximum\n            trust region weight. Defaults to `None`.\n    \"\"\"\n    self.n = n\n    self.k_max = k_max\n    self.w_tr = w_tr\n    self.lam_vc = lam_vc\n    self.ep_tr = ep_tr\n    self.ep_vb = ep_vb\n    self.ep_vc = ep_vc\n    self.lam_cost = lam_cost\n    self.lam_vb = lam_vb\n    self.uniform_time_grid = uniform_time_grid\n    self.cost_drop = cost_drop\n    self.cost_relax = cost_relax\n    self.w_tr_adapt = w_tr_adapt\n    self.w_tr_max = w_tr_max\n    self.w_tr_max_scaling_factor = w_tr_max_scaling_factor\n</code></pre>"},{"location":"reference/config/#openscvx.config.SimConfig","title":"<code>SimConfig</code>  <code>dataclass</code>","text":"Source code in <code>openscvx/config.py</code> <pre><code>@dataclass(init=False)\nclass SimConfig:\n    # No class-level field declarations\n\n    def __init__(\n        self,\n        x: UnifiedState,\n        x_prop: UnifiedState,\n        u: UnifiedControl,\n        total_time: float,\n        save_compiled: bool = False,\n        ctcs_node_intervals: Optional[list] = None,\n        n_states: Optional[int] = None,\n        n_states_prop: Optional[int] = None,\n        n_controls: Optional[int] = None,\n    ):\n        \"\"\"\n        Configuration class for simulation settings.\n\n        This class defines the parameters required for simulating a trajectory\n        optimization problem.\n\n        Main arguments:\n        These are the arguments most commonly used day-to-day.\n\n        Args:\n            x (State): State object, must have .min and .max attributes for bounds.\n            x_prop (State): Propagation state object, must have .min and .max\n                attributes for bounds.\n            u (Control): Control object, must have .min and .max attributes for\n                bounds.\n            total_time (float): The total simulation time.\n            idx_x_true (slice): Slice for true state indices.\n            idx_x_true_prop (slice): Slice for true propagation state indices.\n            idx_u_true (slice): Slice for true control indices.\n            idx_t (slice): Slice for time index.\n            idx_y (slice): Slice for constraint violation indices.\n            idx_y_prop (slice): Slice for propagation constraint violation\n                indices.\n            idx_s (slice): Slice for time dilation index.\n            save_compiled (bool): If True, save and reuse compiled solver\n                functions. Defaults to False.\n            ctcs_node_intervals (list, optional): Node intervals for CTCS\n                constraints.\n            n_states (int, optional): The number of state variables. Defaults to\n                `None` (inferred from x.max).\n            n_states_prop (int, optional): The number of propagation state\n                variables. Defaults to `None` (inferred from x_prop.max).\n            n_controls (int, optional): The number of control variables. Defaults\n                to `None` (inferred from u.max).\n\n        Note:\n            You can specify custom scaling for specific states/controls using\n            the `scaling_min` and `scaling_max` attributes on State, Control, and Time objects.\n            If not set, the default min/max bounds will be used for scaling.\n        \"\"\"\n        # Assign core arguments to self\n        self.x = x\n        self.x_prop = x_prop\n        self.u = u\n        self.total_time = total_time\n        self.save_compiled = save_compiled\n        self.ctcs_node_intervals = ctcs_node_intervals\n        self.n_states = n_states\n        self.n_states_prop = n_states_prop\n        self.n_controls = n_controls\n\n        # Call post init logic\n        self.__post_init__()\n\n    def __post_init__(self):\n        self.n_states = len(self.x.max)\n        self.n_controls = len(self.u.max)\n\n        # State scaling\n        # Use scaling_min/max if provided, otherwise use regular min/max\n        min_x = np.array(self.x.min, dtype=float)\n        max_x = np.array(self.x.max, dtype=float)\n\n        # UnifiedState now always provides full-size scaling arrays when any state has scaling\n        if self.x.scaling_min is not None:\n            lower_x = np.array(self.x.scaling_min, dtype=float)\n        else:\n            lower_x = min_x\n\n        if self.x.scaling_max is not None:\n            upper_x = np.array(self.x.scaling_max, dtype=float)\n        else:\n            upper_x = max_x\n\n        S_x, c_x = get_affine_scaling_matrices(self.n_states, lower_x, upper_x)\n        self.S_x = S_x\n        self.c_x = c_x\n        self.inv_S_x = np.diag(1 / np.diag(self.S_x))\n\n        # Control scaling\n        # Use scaling_min/max if provided, otherwise use regular min/max\n        min_u = np.array(self.u.min, dtype=float)\n        max_u = np.array(self.u.max, dtype=float)\n\n        # UnifiedControl now always provides full-size scaling arrays when any control has scaling\n        if self.u.scaling_min is not None:\n            lower_u = np.array(self.u.scaling_min, dtype=float)\n        else:\n            lower_u = min_u\n\n        if self.u.scaling_max is not None:\n            upper_u = np.array(self.u.scaling_max, dtype=float)\n        else:\n            upper_u = max_u\n\n        S_u, c_u = get_affine_scaling_matrices(self.n_controls, lower_u, upper_u)\n        self.S_u = S_u\n        self.c_u = c_u\n        self.inv_S_u = np.diag(1 / np.diag(self.S_u))\n\n    # Properties for accessing slices from unified objects\n    @property\n    def time_slice(self):\n        \"\"\"Slice for accessing time in the state vector.\"\"\"\n        return self.x.time_slice\n\n    @property\n    def ctcs_slice(self):\n        \"\"\"Slice for accessing CTCS augmented states.\"\"\"\n        return self.x.ctcs_slice\n\n    @property\n    def ctcs_slice_prop(self):\n        \"\"\"Slice for accessing CTCS augmented states in propagation.\"\"\"\n        return self.x_prop.ctcs_slice\n\n    @property\n    def time_dilation_slice(self):\n        \"\"\"Slice for accessing time dilation in the control vector.\"\"\"\n        return self.u.time_dilation_slice\n\n    @property\n    def true_state_slice(self):\n        \"\"\"Slice for accessing true (non-augmented) states.\"\"\"\n        return self.x._true_slice\n\n    @property\n    def true_state_slice_prop(self):\n        \"\"\"Slice for accessing true (non-augmented) propagation states.\"\"\"\n        return self.x_prop._true_slice\n\n    @property\n    def true_control_slice(self):\n        \"\"\"Slice for accessing true (non-augmented) controls.\"\"\"\n        return self.u._true_slice\n</code></pre>"},{"location":"reference/config/#openscvx.config.SimConfig.ctcs_slice","title":"<code>ctcs_slice</code>  <code>property</code>","text":"<p>Slice for accessing CTCS augmented states.</p>"},{"location":"reference/config/#openscvx.config.SimConfig.ctcs_slice_prop","title":"<code>ctcs_slice_prop</code>  <code>property</code>","text":"<p>Slice for accessing CTCS augmented states in propagation.</p>"},{"location":"reference/config/#openscvx.config.SimConfig.time_dilation_slice","title":"<code>time_dilation_slice</code>  <code>property</code>","text":"<p>Slice for accessing time dilation in the control vector.</p>"},{"location":"reference/config/#openscvx.config.SimConfig.time_slice","title":"<code>time_slice</code>  <code>property</code>","text":"<p>Slice for accessing time in the state vector.</p>"},{"location":"reference/config/#openscvx.config.SimConfig.true_control_slice","title":"<code>true_control_slice</code>  <code>property</code>","text":"<p>Slice for accessing true (non-augmented) controls.</p>"},{"location":"reference/config/#openscvx.config.SimConfig.true_state_slice","title":"<code>true_state_slice</code>  <code>property</code>","text":"<p>Slice for accessing true (non-augmented) states.</p>"},{"location":"reference/config/#openscvx.config.SimConfig.true_state_slice_prop","title":"<code>true_state_slice_prop</code>  <code>property</code>","text":"<p>Slice for accessing true (non-augmented) propagation states.</p>"},{"location":"reference/config/#openscvx.config.SimConfig.__init__","title":"<code>__init__(x: UnifiedState, x_prop: UnifiedState, u: UnifiedControl, total_time: float, save_compiled: bool = False, ctcs_node_intervals: Optional[list] = None, n_states: Optional[int] = None, n_states_prop: Optional[int] = None, n_controls: Optional[int] = None)</code>","text":"<p>Configuration class for simulation settings.</p> <p>This class defines the parameters required for simulating a trajectory optimization problem.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>State</code> <p>State object, must have .min and .max attributes for bounds.</p> required <code>x_prop</code> <code>State</code> <p>Propagation state object, must have .min and .max attributes for bounds.</p> required <code>u</code> <code>Control</code> <p>Control object, must have .min and .max attributes for bounds.</p> required <code>total_time</code> <code>float</code> <p>The total simulation time.</p> required <code>idx_x_true</code> <code>slice</code> <p>Slice for true state indices.</p> required <code>idx_x_true_prop</code> <code>slice</code> <p>Slice for true propagation state indices.</p> required <code>idx_u_true</code> <code>slice</code> <p>Slice for true control indices.</p> required <code>idx_t</code> <code>slice</code> <p>Slice for time index.</p> required <code>idx_y</code> <code>slice</code> <p>Slice for constraint violation indices.</p> required <code>idx_y_prop</code> <code>slice</code> <p>Slice for propagation constraint violation indices.</p> required <code>idx_s</code> <code>slice</code> <p>Slice for time dilation index.</p> required <code>save_compiled</code> <code>bool</code> <p>If True, save and reuse compiled solver functions. Defaults to False.</p> <code>False</code> <code>ctcs_node_intervals</code> <code>list</code> <p>Node intervals for CTCS constraints.</p> <code>None</code> <code>n_states</code> <code>int</code> <p>The number of state variables. Defaults to <code>None</code> (inferred from x.max).</p> <code>None</code> <code>n_states_prop</code> <code>int</code> <p>The number of propagation state variables. Defaults to <code>None</code> (inferred from x_prop.max).</p> <code>None</code> <code>n_controls</code> <code>int</code> <p>The number of control variables. Defaults to <code>None</code> (inferred from u.max).</p> <code>None</code> Note <p>You can specify custom scaling for specific states/controls using the <code>scaling_min</code> and <code>scaling_max</code> attributes on State, Control, and Time objects. If not set, the default min/max bounds will be used for scaling.</p> Source code in <code>openscvx/config.py</code> <pre><code>def __init__(\n    self,\n    x: UnifiedState,\n    x_prop: UnifiedState,\n    u: UnifiedControl,\n    total_time: float,\n    save_compiled: bool = False,\n    ctcs_node_intervals: Optional[list] = None,\n    n_states: Optional[int] = None,\n    n_states_prop: Optional[int] = None,\n    n_controls: Optional[int] = None,\n):\n    \"\"\"\n    Configuration class for simulation settings.\n\n    This class defines the parameters required for simulating a trajectory\n    optimization problem.\n\n    Main arguments:\n    These are the arguments most commonly used day-to-day.\n\n    Args:\n        x (State): State object, must have .min and .max attributes for bounds.\n        x_prop (State): Propagation state object, must have .min and .max\n            attributes for bounds.\n        u (Control): Control object, must have .min and .max attributes for\n            bounds.\n        total_time (float): The total simulation time.\n        idx_x_true (slice): Slice for true state indices.\n        idx_x_true_prop (slice): Slice for true propagation state indices.\n        idx_u_true (slice): Slice for true control indices.\n        idx_t (slice): Slice for time index.\n        idx_y (slice): Slice for constraint violation indices.\n        idx_y_prop (slice): Slice for propagation constraint violation\n            indices.\n        idx_s (slice): Slice for time dilation index.\n        save_compiled (bool): If True, save and reuse compiled solver\n            functions. Defaults to False.\n        ctcs_node_intervals (list, optional): Node intervals for CTCS\n            constraints.\n        n_states (int, optional): The number of state variables. Defaults to\n            `None` (inferred from x.max).\n        n_states_prop (int, optional): The number of propagation state\n            variables. Defaults to `None` (inferred from x_prop.max).\n        n_controls (int, optional): The number of control variables. Defaults\n            to `None` (inferred from u.max).\n\n    Note:\n        You can specify custom scaling for specific states/controls using\n        the `scaling_min` and `scaling_max` attributes on State, Control, and Time objects.\n        If not set, the default min/max bounds will be used for scaling.\n    \"\"\"\n    # Assign core arguments to self\n    self.x = x\n    self.x_prop = x_prop\n    self.u = u\n    self.total_time = total_time\n    self.save_compiled = save_compiled\n    self.ctcs_node_intervals = ctcs_node_intervals\n    self.n_states = n_states\n    self.n_states_prop = n_states_prop\n    self.n_controls = n_controls\n\n    # Call post init logic\n    self.__post_init__()\n</code></pre>"},{"location":"reference/problem/","title":"problem","text":"<p>Core optimization problem interface for trajectory optimization.</p> <p>This module provides the Problem class, the main entry point for defining and solving trajectory optimization problems using Sequential Convex Programming (SCP).</p> Example <p>The prototypical flow is to define a problem, then initialize, solve, and post-process the results</p> <pre><code>problem = Problem(dynamics, constraints, states, controls, N, time)\nproblem.initialize()\nresult = problem.solve()\nresult = problem.post_process()\n</code></pre>"},{"location":"reference/problem/#openscvx.problem.Problem","title":"<code>Problem</code>","text":"Source code in <code>openscvx/problem.py</code> <pre><code>class Problem:\n    def __init__(\n        self,\n        dynamics: dict,\n        constraints: List[Union[Constraint, CTCS]],\n        states: List[State],\n        controls: List[Control],\n        N: int,\n        time: Time,\n        *,\n        dynamics_prop: Optional[dict] = None,\n        states_prop: Optional[List[State]] = None,\n        algebraic_prop: Optional[dict] = None,\n        licq_min=0.0,\n        licq_max=1e-4,\n        time_dilation_factor_min=0.3,\n        time_dilation_factor_max=3.0,\n        byof: Optional[ByofSpec] = None,\n    ):\n        \"\"\"The primary class in charge of compiling and exporting the solvers.\n\n        Args:\n            dynamics (dict): Dictionary mapping state names to their dynamics expressions.\n                Each key should be a state name, and each value should be an Expr\n                representing the derivative of that state.\n            constraints (List[Union[CTCSConstraint, NodalConstraint]]):\n                List of constraints decorated with @ctcs or @nodal\n            states (List[State]): List of State objects representing the state variables.\n                May optionally include a State named \"time\" (see time parameter below).\n            controls (List[Control]): List of Control objects representing the control variables\n            N (int): Number of segments in the trajectory\n            time (Time): Time configuration object with initial, final, min, max.\n                Required. If including a \"time\" state in states, the Time object will be ignored\n                and time properties should be set on the time State object instead.\n            dynamics_prop (dict, optional): Dictionary mapping EXTRA state names to their\n                dynamics expressions for propagation. Only specify additional states beyond\n                optimization states (e.g., {\"distance\": speed}). Do NOT duplicate optimization\n                state dynamics here.\n            states_prop (List[State], optional): List of EXTRA State objects for propagation only.\n                Only specify additional states beyond optimization states. Used with dynamics_prop.\n            algebraic_prop (dict, optional): Dictionary mapping names to symbolic expressions\n                for outputs evaluated (not integrated) during propagation.\n            licq_min: Minimum LICQ constraint value\n            licq_max: Maximum LICQ constraint value\n            time_dilation_factor_min: Minimum time dilation factor\n            time_dilation_factor_max: Maximum time dilation factor\n            byof: Expert mode only. Raw JAX functions to bypass symbolic layer.\n                See :class:`openscvx.expert.ByofSpec` for detailed documentation.\n\n        Returns:\n            None\n\n        Note:\n            There are two approaches for handling time:\n            1. Auto-create (simple): Don't include \"time\" in states, provide Time object\n            2. User-provided (for time-dependent constraints): Include \"time\" State in states and\n               in dynamics dict, don't provide Time object\n        \"\"\"\n\n        # Symbolic Preprocessing &amp; Augmentation\n        self.symbolic: SymbolicProblem = preprocess_symbolic_problem(\n            dynamics=dynamics,\n            constraints=ConstraintSet(unsorted=list(constraints)),\n            states=states,\n            controls=controls,\n            N=N,\n            time=time,\n            licq_min=licq_min,\n            licq_max=licq_max,\n            time_dilation_factor_min=time_dilation_factor_min,\n            time_dilation_factor_max=time_dilation_factor_max,\n            dynamics_prop_extra=dynamics_prop,\n            states_prop_extra=states_prop,\n            algebraic_prop=algebraic_prop,\n            byof=byof,\n        )\n\n        # Validate byof early (after preprocessing, before lowering) to fail fast\n        if byof is not None:\n            from openscvx.expert.validation import validate_byof\n\n            # Calculate unified state and control dimensions from preprocessed states/controls\n            # These dimensions include symbolic augmentation (time, CTCS) but not byof CTCS\n            # augmentation, which is exactly what user byof functions will see\n            n_x = sum(\n                state.shape[0] if len(state.shape) &gt; 0 else 1 for state in self.symbolic.states\n            )\n            n_u = sum(\n                control.shape[0] if len(control.shape) &gt; 0 else 1\n                for control in self.symbolic.controls\n            )\n\n            validate_byof(byof, self.symbolic.states, n_x, n_u, N)\n\n        # Store byof for cache hashing\n        self._byof = byof\n\n        # Lower to JAX and CVXPy (byof handling happens inside lower_symbolic_problem)\n        self._lowered: LoweredProblem = lower_symbolic_problem(self.symbolic, byof=byof)\n\n        # Store parameters in two forms:\n        self._parameters = self.symbolic.parameters  # Plain dict for JAX functions\n        # Wrapper dict for user access that auto-syncs\n        self._parameter_wrapper = ParameterDict(self, self._parameters, self.symbolic.parameters)\n\n        # Setup SCP Configuration\n        self.settings = Config(\n            sim=SimConfig(\n                x=self._lowered.x_unified,\n                x_prop=self._lowered.x_prop_unified,\n                u=self._lowered.u_unified,\n                total_time=self._lowered.x_unified.initial[self._lowered.x_unified.time_slice][0],\n                n_states=self._lowered.x_unified.initial.shape[0],\n                n_states_prop=self._lowered.x_prop_unified.initial.shape[0],\n                ctcs_node_intervals=self.symbolic.node_intervals,\n            ),\n            scp=ScpConfig(\n                n=N,\n                w_tr_max_scaling_factor=1e2,  # Maximum Trust Region Weight\n            ),\n            dis=DiscretizationConfig(),\n            dev=DevConfig(),\n            cvx=ConvexSolverConfig(),\n            prp=PropagationConfig(),\n        )\n\n        # OCP construction happens in initialize() so users can modify\n        # settings (like uniform_time_grid) between __init__ and initialize()\n        self._optimal_control_problem: cp.Problem = None\n        self._discretization_solver: callable = None\n        self._solve_ocp: callable = None  # Solver callable (built during initialize)\n\n        # Set up emitter &amp; thread only if printing is enabled\n        if self.settings.dev.printing:\n            self.print_queue = queue.Queue()\n            self.emitter_function = lambda data: self.print_queue.put(data)\n            self.print_thread = threading.Thread(\n                target=printing.intermediate,\n                args=(self.print_queue, self.settings),\n                daemon=True,\n            )\n            self.print_thread.start()\n        else:\n            # no-op emitter; nothing ever gets queued or printed\n            self.emitter_function = lambda data: None\n\n        self.timing_init = None\n        self.timing_solve = None\n        self.timing_post = None\n\n        # Compiled dynamics (vmapped versions, set in initialize())\n        self._compiled_dynamics: Optional[Dynamics] = None\n        self._compiled_dynamics_prop: Optional[Dynamics] = None\n\n        # Compiled constraints (JIT-compiled versions, set in initialize())\n        self._compiled_constraints: Optional[LoweredJaxConstraints] = None\n\n        # Solver state (created fresh for each solve)\n        self._state: Optional[AlgorithmState] = None\n\n        # Final solution state (saved after successful solve)\n        self._solution: Optional[AlgorithmState] = None\n\n        # SCP algorithm (currently hardcoded to PTR)\n        self._algorithm = PenalizedTrustRegion()\n\n    @property\n    def parameters(self):\n        \"\"\"Get the parameters dictionary.\n\n        The returned dictionary automatically syncs to CVXPy when modified:\n            problem.parameters[\"obs_radius\"] = 2.0  # Auto-syncs to CVXPy\n            problem.parameters.update({\"gate_0_center\": center})  # Also syncs\n\n        Returns:\n            ParameterDict: Special dict that syncs to CVXPy on assignment\n        \"\"\"\n        return self._parameter_wrapper\n\n    @parameters.setter\n    def parameters(self, new_params: dict):\n        \"\"\"Replace the entire parameters dictionary and sync to CVXPy.\n\n        Args:\n            new_params: New parameters dictionary\n        \"\"\"\n        self._parameters = dict(new_params)  # Create new plain dict\n        self._parameter_wrapper = ParameterDict(self, self._parameters, new_params)\n        self._sync_parameters()\n\n    def _sync_parameters(self):\n        \"\"\"Sync all parameter values to CVXPy parameters.\"\"\"\n        if self._lowered.cvxpy_params is not None:\n            for name, value in self._parameter_wrapper.items():\n                if name in self._lowered.cvxpy_params:\n                    self._lowered.cvxpy_params[name].value = value\n\n    @property\n    def state(self) -&gt; Optional[AlgorithmState]:\n        \"\"\"Access the current solver state.\n\n        The solver state contains all mutable state from the SCP iterations,\n        including current guesses, costs, weights, and history.\n\n        Returns:\n            AlgorithmState if initialized, None otherwise\n\n        Example:\n            When using `Problem.step()` can use the state to check convergence _etc._\n\n                problem.initialize()\n                problem.step()\n                print(f\"Iteration {problem.state.k}, J_tr={problem.state.J_tr}\")\n        \"\"\"\n        return self._state\n\n    @property\n    def lowered(self) -&gt; LoweredProblem:\n        \"\"\"Access the lowered problem containing JAX/CVXPy objects.\n\n        Returns:\n            LoweredProblem with dynamics, constraints, unified interfaces, and CVXPy vars\n        \"\"\"\n        return self._lowered\n\n    @property\n    def x_unified(self):\n        \"\"\"Unified state interface (delegates to lowered.x_unified).\"\"\"\n        return self._lowered.x_unified\n\n    @property\n    def u_unified(self):\n        \"\"\"Unified control interface (delegates to lowered.u_unified).\"\"\"\n        return self._lowered.u_unified\n\n    @property\n    def slices(self) -&gt; dict[str, slice]:\n        \"\"\"Get mapping of state and control names to their slices in unified vectors.\n\n        This property returns a dictionary mapping each state and control variable name\n        to its slice in the respective unified vector. This is particularly useful for\n        expert users working with byof (bring-your-own functions) who need to manually\n        index into the unified x and u vectors.\n\n        Returns:\n            dict[str, slice]: Dictionary mapping variable names to slice objects.\n                State variables map to slices in the x vector.\n                Control variables map to slices in the u vector.\n\n        Example:\n                problem = ox.Problem(dynamics, states, controls, ...)\n                print(problem.slices)\n                # {'position': slice(0, 3), 'velocity': slice(3, 6), 'theta': slice(0, 1)}\n\n                # Use in byof functions\n                byof = {\n                    \"nodal_constraints\": [\n                        lambda x, u, node, params: x[problem.slices[\"velocity\"][0]] - 10.0,\n                        lambda x, u, node, params: u[problem.slices[\"theta\"][0]] - 1.57,\n                    ]\n                }\n        \"\"\"\n        slices = {}\n        slices.update({state.name: state.slice for state in self.symbolic.states})\n        slices.update({control.name: control.slice for control in self.symbolic.controls})\n        return slices\n\n    def _format_result(self, state: AlgorithmState, converged: bool) -&gt; OptimizationResults:\n        \"\"\"Format solver state as an OptimizationResults object.\n\n        Converts the internal solver state into a user-facing results object,\n        mapping state/control arrays to named fields based on symbolic metadata.\n\n        Args:\n            state: The AlgorithmState to extract results from.\n            converged: Whether the optimization converged.\n\n        Returns:\n            OptimizationResults containing the solution data.\n        \"\"\"\n        # Build nodes dictionary with all states and controls\n        nodes_dict = {}\n\n        # Add all states (user-defined and augmented)\n        for sym_state in self.symbolic.states:\n            nodes_dict[sym_state.name] = state.x[:, sym_state._slice]\n\n        # Add all controls (user-defined and augmented)\n        for control in self.symbolic.controls:\n            nodes_dict[control.name] = state.u[:, control._slice]\n\n        return OptimizationResults(\n            converged=converged,\n            t_final=state.x[:, self.settings.sim.time_slice][-1],\n            nodes=nodes_dict,\n            trajectory={},  # Populated by post_process\n            _states=self.symbolic.states_prop,  # Use propagation states for trajectory dict\n            _controls=self.symbolic.controls,\n            X=state.X,  # Single source of truth - x and u are properties\n            U=state.U,\n            discretization_history=state.V_history,\n            J_tr_history=state.J_tr,\n            J_vb_history=state.J_vb,\n            J_vc_history=state.J_vc,\n            TR_history=state.TR_history,\n            VC_history=state.VC_history,\n        )\n\n    def initialize(self):\n        \"\"\"Compile dynamics, constraints, and solvers; prepare for optimization.\n\n        This method vmaps dynamics, JIT-compiles constraints, builds the convex\n        subproblem, and initializes the solver state. Must be called before solve().\n\n        Example:\n            Prior to calling the `.solve()` method it is necessary to initialize the problem\n\n                problem = Problem(dynamics, constraints, states, controls, N, time)\n                problem.initialize()  # Compile and prepare\n                problem.solve()       # Run optimization\n        \"\"\"\n        printing.intro()\n\n        # Print problem summary\n        printing.print_problem_summary(self.settings, self._lowered)\n\n        # Enable the profiler\n        pr = profiling.profiling_start(self.settings.dev.profiling)\n\n        t_0_while = time.time()\n        # Ensure parameter sizes and normalization are correct\n        self.settings.scp.__post_init__()\n        self.settings.sim.__post_init__()\n\n        # Create compiled (vmapped) dynamics as new instances\n        # This preserves the original un-vmapped versions in _lowered\n        self._compiled_dynamics = Dynamics(\n            f=jax.vmap(self._lowered.dynamics.f, in_axes=(0, 0, 0, None)),\n            A=jax.vmap(self._lowered.dynamics.A, in_axes=(0, 0, 0, None)),\n            B=jax.vmap(self._lowered.dynamics.B, in_axes=(0, 0, 0, None)),\n        )\n\n        self._compiled_dynamics_prop = Dynamics(\n            f=jax.vmap(self._lowered.dynamics_prop.f, in_axes=(0, 0, 0, None)),\n        )\n\n        # Create compiled (JIT-compiled) constraints as new instances\n        # This preserves the original un-JIT'd versions in _lowered\n        # TODO: (haynec) switch to AOT instead of JIT\n        compiled_nodal = [\n            LoweredNodalConstraint(\n                func=jax.jit(c.func),\n                grad_g_x=jax.jit(c.grad_g_x),\n                grad_g_u=jax.jit(c.grad_g_u),\n                nodes=c.nodes,\n            )\n            for c in self._lowered.jax_constraints.nodal\n        ]\n\n        compiled_cross_node = [\n            LoweredCrossNodeConstraint(\n                func=jax.jit(c.func),\n                grad_g_X=jax.jit(c.grad_g_X),\n                grad_g_U=jax.jit(c.grad_g_U),\n            )\n            for c in self._lowered.jax_constraints.cross_node\n        ]\n\n        self._compiled_constraints = LoweredJaxConstraints(\n            nodal=compiled_nodal,\n            cross_node=compiled_cross_node,\n            ctcs=self._lowered.jax_constraints.ctcs,  # CTCS aren't JIT-compiled here\n        )\n\n        # Generate solvers using compiled (vmapped) dynamics\n        self._discretization_solver = get_discretization_solver(\n            self._compiled_dynamics, self.settings\n        )\n        self._propagation_solver = get_propagation_solver(\n            self._compiled_dynamics_prop.f, self.settings\n        )\n\n        # Build optimal control problem using LoweredProblem\n        self._optimal_control_problem = optimal_control_problem(self.settings, self._lowered)\n\n        # Get cache file paths using symbolic AST hashing\n        # This is more stable than hashing lowered JAX code\n        dis_solver_file, prop_solver_file = get_solver_cache_paths(\n            self.symbolic,\n            dt=self.settings.prp.dt,\n            total_time=self.settings.sim.total_time,\n            byof=self._byof,\n        )\n\n        # Compile the discretization solver\n        self._discretization_solver = load_or_compile_discretization_solver(\n            self._discretization_solver,\n            dis_solver_file,\n            self._parameters,  # Plain dict for JAX\n            self.settings.scp.n,\n            self.settings.sim.n_states,\n            self.settings.sim.n_controls,\n            save_compiled=self.settings.sim.save_compiled,\n            debug=self.settings.dev.debug,\n        )\n\n        # Setup propagation solver parameters\n        dtau = 1.0 / (self.settings.scp.n - 1)\n        dt_max = self.settings.sim.u.max[self.settings.sim.time_dilation_slice][0] * dtau\n        self.settings.prp.max_tau_len = int(dt_max / self.settings.prp.dt) + 2\n\n        # Compile the propagation solver\n        self._propagation_solver = load_or_compile_propagation_solver(\n            self._propagation_solver,\n            prop_solver_file,\n            self._parameters,  # Plain dict for JAX\n            self.settings.sim.n_states_prop,\n            self.settings.sim.n_controls,\n            self.settings.prp.max_tau_len,\n            save_compiled=self.settings.sim.save_compiled,\n        )\n\n        # Build solver callable (handle CVXPyGen if enabled)\n        if self.settings.cvx.cvxpygen:\n            try:\n                from solver.cpg_solver import cpg_solve\n\n                with open(\"solver/problem.pickle\", \"rb\") as f:\n                    pickle.load(f)\n                self._optimal_control_problem.register_solve(\"CPG\", cpg_solve)\n                solver_args = self.settings.cvx.solver_args\n                self._solve_ocp = lambda: self._optimal_control_problem.solve(\n                    method=\"CPG\", **solver_args\n                )\n            except ImportError:\n                raise ImportError(\n                    \"cvxpygen solver not found. Make sure cvxpygen is installed and code \"\n                    \"generation has been run. Install with: pip install openscvx[cvxpygen]\"\n                )\n        else:\n            solver = self.settings.cvx.solver\n            solver_args = self.settings.cvx.solver_args\n            self._solve_ocp = lambda: self._optimal_control_problem.solve(\n                solver=solver, **solver_args\n            )\n\n        # Initialize the SCP algorithm\n        print(\"Initializing the SCvx Subproblem Solver...\")\n        self._algorithm.initialize(\n            self._optimal_control_problem,\n            self._discretization_solver,\n            self._compiled_constraints,\n            self._solve_ocp,\n            self.emitter_function,\n            self._parameters,  # For warm-start only\n            self.settings,  # For warm-start only\n        )\n        print(\"\u2713 SCvx Subproblem Solver initialized\")\n\n        # Create fresh solver state\n        self._state = AlgorithmState.from_settings(self.settings)\n\n        t_f_while = time.time()\n        self.timing_init = t_f_while - t_0_while\n        print(\"Total Initialization Time: \", self.timing_init)\n\n        # Prime the propagation solver\n        prime_propagation_solver(self._propagation_solver, self._parameters, self.settings)\n\n        profiling.profiling_end(pr, \"initialize\")\n\n    def reset(self):\n        \"\"\"Reset solver state to re-run optimization from initial conditions.\n\n        Creates fresh AlgorithmState while preserving compiled dynamics and solvers.\n        Use this to run multiple optimizations without re-initializing.\n\n        Raises:\n            ValueError: If initialize() has not been called yet.\n\n        Example:\n            After calling `.step()` it may be necessary to reset the problem back to the initial\n            conditions\n\n                problem.initialize()\n                result1 = problem.step()\n                problem.reset()\n                result2 = problem.solve()  # Fresh run with same setup\n        \"\"\"\n        if self._compiled_dynamics is None:\n            raise ValueError(\"Problem has not been initialized. Call initialize() first\")\n\n        # Create fresh solver state from settings\n        self._state = AlgorithmState.from_settings(self.settings)\n\n        # Reset solution\n        self._solution = None\n\n        # Reset timing\n        self.timing_solve = None\n        self.timing_post = None\n\n    def step(self) -&gt; dict:\n        \"\"\"Perform a single SCP iteration.\n\n        Designed for real-time plotting and interactive optimization. Performs one\n        iteration including subproblem solve, state update, and progress emission.\n\n        Note:\n            This method is NOT idempotent - it mutates internal state and advances\n            the iteration counter. Use reset() to return to initial conditions.\n\n        Returns:\n            dict: Contains \"converged\" (bool) and current iteration state\n\n        Example:\n            Call `.step()` manually in a loop to control the algorithm directly\n\n                problem.initialize()\n                while not problem.step()[\"converged\"]:\n                    plot_trajectory(problem.state.trajs[-1])\n        \"\"\"\n        if self._state is None:\n            raise ValueError(\"Problem has not been initialized. Call initialize() first\")\n\n        converged = self._algorithm.step(\n            self._state,\n            self._parameters,  # May change between steps\n            self.settings,  # May change between steps\n        )\n\n        # Return dict matching original API\n        return {\n            \"converged\": converged,\n            \"scp_k\": self._state.k,\n            \"scp_J_tr\": self._state.J_tr,\n            \"scp_J_vb\": self._state.J_vb,\n            \"scp_J_vc\": self._state.J_vc,\n        }\n\n    def solve(\n        self, max_iters: Optional[int] = None, continuous: bool = False\n    ) -&gt; OptimizationResults:\n        \"\"\"Run the SCP algorithm until convergence or iteration limit.\n\n        Args:\n            max_iters: Maximum iterations (default: settings.scp.k_max)\n            continuous: If True, run all iterations regardless of convergence\n\n        Returns:\n            OptimizationResults with trajectory and convergence info\n                (call post_process() for full propagation)\n        \"\"\"\n        # Sync parameters before solving\n        self._sync_parameters()\n\n        required = [\n            self._compiled_dynamics,\n            self._compiled_constraints,\n            self._optimal_control_problem,\n            self._discretization_solver,\n            self._state,\n        ]\n        if any(r is None for r in required):\n            raise ValueError(\"Problem has not been initialized. Call initialize() before solve()\")\n\n        # Enable the profiler\n        pr = profiling.profiling_start(self.settings.dev.profiling)\n\n        t_0_while = time.time()\n        # Print top header for solver results\n        printing.header()\n\n        k_max = max_iters if max_iters is not None else self.settings.scp.k_max\n\n        while self._state.k &lt;= k_max:\n            result = self.step()\n            if result[\"converged\"] and not continuous:\n                break\n\n        t_f_while = time.time()\n        self.timing_solve = t_f_while - t_0_while\n\n        while self.print_queue.qsize() &gt; 0:\n            time.sleep(0.1)\n\n        # Print bottom footer for solver results as well as total computation time\n        printing.footer()\n\n        profiling.profiling_end(pr, \"solve\")\n\n        # Store solution state\n        self._solution = copy.deepcopy(self._state)\n\n        return self._format_result(self._state, self._state.k &lt;= k_max)\n\n    def post_process(self) -&gt; OptimizationResults:\n        \"\"\"Propagate solution through full nonlinear dynamics for high-fidelity trajectory.\n\n        Integrates the converged SCP solution through the nonlinear dynamics to\n        produce x_full, u_full, and t_full. Call after solve() for final results.\n\n        Returns:\n            OptimizationResults with propagated trajectory fields\n\n        Raises:\n            ValueError: If solve() has not been called yet.\n        \"\"\"\n        if self._solution is None:\n            raise ValueError(\"No solution available. Call solve() first.\")\n\n        # Enable the profiler\n        pr = profiling.profiling_start(self.settings.dev.profiling)\n\n        # Create result from stored solution state\n        result = self._format_result(self._solution, self._solution.k &lt;= self.settings.scp.k_max)\n\n        t_0_post = time.time()\n        result = propagate_trajectory_results(\n            self._parameters,\n            self.settings,\n            result,\n            self._propagation_solver,\n            algebraic_prop=self._lowered.algebraic_prop,\n        )\n        t_f_post = time.time()\n\n        self.timing_post = t_f_post - t_0_post\n\n        # Store the propagated result back into _solution for plotting\n        # Store as a cached attribute on the _solution object\n        self._solution._propagated_result = result\n\n        # Print results summary\n        printing.print_results_summary(\n            result, self.timing_post, self.timing_init, self.timing_solve\n        )\n\n        profiling.profiling_end(pr, \"postprocess\")\n        return result\n\n    def citation(self) -&gt; str:\n        \"\"\"Return BibTeX citations for all components used in this problem.\n\n        Aggregates citations from the algorithm and other components (discretization,\n        convex solver, etc.) Each section is prefixed with a comment indicating which component the\n        citation is for.\n\n        Returns:\n            Formatted string containing all BibTeX citations with comments.\n\n        Example:\n            Print all citations for a problem::\n\n                problem = Problem(dynamics, constraints, states, controls, N, time)\n                print(problem.citation())\n        \"\"\"\n        sections = []\n\n        sections.append(r\"% --- AUTO-GENERATED CITATIONS FOR OPENSCVX CONFIGURATION ---\")\n\n        # Algorithm citations\n        algo_citations = self._algorithm.citation()\n        if algo_citations:\n            algo_name = type(self._algorithm).__name__\n            header = f\"% Algorithm: {algo_name}\"\n            citations = \"\\n\".join(algo_citations)\n            sections.append(f\"{header}\\n\\n{citations}\")\n\n        # Future: add citations from discretization, constraint formulations, etc.\n\n        sections.append(r\"% --- END AUTO-GENERATED CITATIONS\")\n\n        return \"\\n\\n\".join(sections)\n</code></pre>"},{"location":"reference/problem/#openscvx.problem.Problem.lowered","title":"<code>lowered: LoweredProblem</code>  <code>property</code>","text":"<p>Access the lowered problem containing JAX/CVXPy objects.</p> <p>Returns:</p> Type Description <code>LoweredProblem</code> <p>LoweredProblem with dynamics, constraints, unified interfaces, and CVXPy vars</p>"},{"location":"reference/problem/#openscvx.problem.Problem.parameters","title":"<code>parameters</code>  <code>property</code> <code>writable</code>","text":"<p>Get the parameters dictionary.</p> The returned dictionary automatically syncs to CVXPy when modified <p>problem.parameters[\"obs_radius\"] = 2.0  # Auto-syncs to CVXPy problem.parameters.update({\"gate_0_center\": center})  # Also syncs</p> <p>Returns:</p> Name Type Description <code>ParameterDict</code> <p>Special dict that syncs to CVXPy on assignment</p>"},{"location":"reference/problem/#openscvx.problem.Problem.slices","title":"<code>slices: dict[str, slice]</code>  <code>property</code>","text":"<p>Get mapping of state and control names to their slices in unified vectors.</p> <p>This property returns a dictionary mapping each state and control variable name to its slice in the respective unified vector. This is particularly useful for expert users working with byof (bring-your-own functions) who need to manually index into the unified x and u vectors.</p> <p>Returns:</p> Type Description <code>dict[str, slice]</code> <p>dict[str, slice]: Dictionary mapping variable names to slice objects. State variables map to slices in the x vector. Control variables map to slices in the u vector.</p> Example <p>problem = ox.Problem(dynamics, states, controls, ...) print(problem.slices)</p>"},{"location":"reference/problem/#openscvx.problem.Problem.slices--position-slice0-3-velocity-slice3-6-theta-slice0-1","title":"{'position': slice(0, 3), 'velocity': slice(3, 6), 'theta': slice(0, 1)}","text":""},{"location":"reference/problem/#openscvx.problem.Problem.slices--use-in-byof-functions","title":"Use in byof functions","text":"<p>byof = {     \"nodal_constraints\": [         lambda x, u, node, params: x[problem.slices[\"velocity\"][0]] - 10.0,         lambda x, u, node, params: u[problem.slices[\"theta\"][0]] - 1.57,     ] }</p>"},{"location":"reference/problem/#openscvx.problem.Problem.state","title":"<code>state: Optional[AlgorithmState]</code>  <code>property</code>","text":"<p>Access the current solver state.</p> <p>The solver state contains all mutable state from the SCP iterations, including current guesses, costs, weights, and history.</p> <p>Returns:</p> Type Description <code>Optional[AlgorithmState]</code> <p>AlgorithmState if initialized, None otherwise</p> Example <p>When using <code>Problem.step()</code> can use the state to check convergence etc.</p> <pre><code>problem.initialize()\nproblem.step()\nprint(f\"Iteration {problem.state.k}, J_tr={problem.state.J_tr}\")\n</code></pre>"},{"location":"reference/problem/#openscvx.problem.Problem.u_unified","title":"<code>u_unified</code>  <code>property</code>","text":"<p>Unified control interface (delegates to lowered.u_unified).</p>"},{"location":"reference/problem/#openscvx.problem.Problem.x_unified","title":"<code>x_unified</code>  <code>property</code>","text":"<p>Unified state interface (delegates to lowered.x_unified).</p>"},{"location":"reference/problem/#openscvx.problem.Problem.__init__","title":"<code>__init__(dynamics: dict, constraints: List[Union[Constraint, CTCS]], states: List[State], controls: List[Control], N: int, time: Time, *, dynamics_prop: Optional[dict] = None, states_prop: Optional[List[State]] = None, algebraic_prop: Optional[dict] = None, licq_min=0.0, licq_max=0.0001, time_dilation_factor_min=0.3, time_dilation_factor_max=3.0, byof: Optional[ByofSpec] = None)</code>","text":"<p>The primary class in charge of compiling and exporting the solvers.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>dict</code> <p>Dictionary mapping state names to their dynamics expressions. Each key should be a state name, and each value should be an Expr representing the derivative of that state.</p> required <code>constraints</code> <code>List[Union[CTCSConstraint, NodalConstraint]]</code> <p>List of constraints decorated with @ctcs or @nodal</p> required <code>states</code> <code>List[State]</code> <p>List of State objects representing the state variables. May optionally include a State named \"time\" (see time parameter below).</p> required <code>controls</code> <code>List[Control]</code> <p>List of Control objects representing the control variables</p> required <code>N</code> <code>int</code> <p>Number of segments in the trajectory</p> required <code>time</code> <code>Time</code> <p>Time configuration object with initial, final, min, max. Required. If including a \"time\" state in states, the Time object will be ignored and time properties should be set on the time State object instead.</p> required <code>dynamics_prop</code> <code>dict</code> <p>Dictionary mapping EXTRA state names to their dynamics expressions for propagation. Only specify additional states beyond optimization states (e.g., {\"distance\": speed}). Do NOT duplicate optimization state dynamics here.</p> <code>None</code> <code>states_prop</code> <code>List[State]</code> <p>List of EXTRA State objects for propagation only. Only specify additional states beyond optimization states. Used with dynamics_prop.</p> <code>None</code> <code>algebraic_prop</code> <code>dict</code> <p>Dictionary mapping names to symbolic expressions for outputs evaluated (not integrated) during propagation.</p> <code>None</code> <code>licq_min</code> <p>Minimum LICQ constraint value</p> <code>0.0</code> <code>licq_max</code> <p>Maximum LICQ constraint value</p> <code>0.0001</code> <code>time_dilation_factor_min</code> <p>Minimum time dilation factor</p> <code>0.3</code> <code>time_dilation_factor_max</code> <p>Maximum time dilation factor</p> <code>3.0</code> <code>byof</code> <code>Optional[ByofSpec]</code> <p>Expert mode only. Raw JAX functions to bypass symbolic layer. See :class:<code>openscvx.expert.ByofSpec</code> for detailed documentation.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Note <p>There are two approaches for handling time: 1. Auto-create (simple): Don't include \"time\" in states, provide Time object 2. User-provided (for time-dependent constraints): Include \"time\" State in states and    in dynamics dict, don't provide Time object</p> Source code in <code>openscvx/problem.py</code> <pre><code>def __init__(\n    self,\n    dynamics: dict,\n    constraints: List[Union[Constraint, CTCS]],\n    states: List[State],\n    controls: List[Control],\n    N: int,\n    time: Time,\n    *,\n    dynamics_prop: Optional[dict] = None,\n    states_prop: Optional[List[State]] = None,\n    algebraic_prop: Optional[dict] = None,\n    licq_min=0.0,\n    licq_max=1e-4,\n    time_dilation_factor_min=0.3,\n    time_dilation_factor_max=3.0,\n    byof: Optional[ByofSpec] = None,\n):\n    \"\"\"The primary class in charge of compiling and exporting the solvers.\n\n    Args:\n        dynamics (dict): Dictionary mapping state names to their dynamics expressions.\n            Each key should be a state name, and each value should be an Expr\n            representing the derivative of that state.\n        constraints (List[Union[CTCSConstraint, NodalConstraint]]):\n            List of constraints decorated with @ctcs or @nodal\n        states (List[State]): List of State objects representing the state variables.\n            May optionally include a State named \"time\" (see time parameter below).\n        controls (List[Control]): List of Control objects representing the control variables\n        N (int): Number of segments in the trajectory\n        time (Time): Time configuration object with initial, final, min, max.\n            Required. If including a \"time\" state in states, the Time object will be ignored\n            and time properties should be set on the time State object instead.\n        dynamics_prop (dict, optional): Dictionary mapping EXTRA state names to their\n            dynamics expressions for propagation. Only specify additional states beyond\n            optimization states (e.g., {\"distance\": speed}). Do NOT duplicate optimization\n            state dynamics here.\n        states_prop (List[State], optional): List of EXTRA State objects for propagation only.\n            Only specify additional states beyond optimization states. Used with dynamics_prop.\n        algebraic_prop (dict, optional): Dictionary mapping names to symbolic expressions\n            for outputs evaluated (not integrated) during propagation.\n        licq_min: Minimum LICQ constraint value\n        licq_max: Maximum LICQ constraint value\n        time_dilation_factor_min: Minimum time dilation factor\n        time_dilation_factor_max: Maximum time dilation factor\n        byof: Expert mode only. Raw JAX functions to bypass symbolic layer.\n            See :class:`openscvx.expert.ByofSpec` for detailed documentation.\n\n    Returns:\n        None\n\n    Note:\n        There are two approaches for handling time:\n        1. Auto-create (simple): Don't include \"time\" in states, provide Time object\n        2. User-provided (for time-dependent constraints): Include \"time\" State in states and\n           in dynamics dict, don't provide Time object\n    \"\"\"\n\n    # Symbolic Preprocessing &amp; Augmentation\n    self.symbolic: SymbolicProblem = preprocess_symbolic_problem(\n        dynamics=dynamics,\n        constraints=ConstraintSet(unsorted=list(constraints)),\n        states=states,\n        controls=controls,\n        N=N,\n        time=time,\n        licq_min=licq_min,\n        licq_max=licq_max,\n        time_dilation_factor_min=time_dilation_factor_min,\n        time_dilation_factor_max=time_dilation_factor_max,\n        dynamics_prop_extra=dynamics_prop,\n        states_prop_extra=states_prop,\n        algebraic_prop=algebraic_prop,\n        byof=byof,\n    )\n\n    # Validate byof early (after preprocessing, before lowering) to fail fast\n    if byof is not None:\n        from openscvx.expert.validation import validate_byof\n\n        # Calculate unified state and control dimensions from preprocessed states/controls\n        # These dimensions include symbolic augmentation (time, CTCS) but not byof CTCS\n        # augmentation, which is exactly what user byof functions will see\n        n_x = sum(\n            state.shape[0] if len(state.shape) &gt; 0 else 1 for state in self.symbolic.states\n        )\n        n_u = sum(\n            control.shape[0] if len(control.shape) &gt; 0 else 1\n            for control in self.symbolic.controls\n        )\n\n        validate_byof(byof, self.symbolic.states, n_x, n_u, N)\n\n    # Store byof for cache hashing\n    self._byof = byof\n\n    # Lower to JAX and CVXPy (byof handling happens inside lower_symbolic_problem)\n    self._lowered: LoweredProblem = lower_symbolic_problem(self.symbolic, byof=byof)\n\n    # Store parameters in two forms:\n    self._parameters = self.symbolic.parameters  # Plain dict for JAX functions\n    # Wrapper dict for user access that auto-syncs\n    self._parameter_wrapper = ParameterDict(self, self._parameters, self.symbolic.parameters)\n\n    # Setup SCP Configuration\n    self.settings = Config(\n        sim=SimConfig(\n            x=self._lowered.x_unified,\n            x_prop=self._lowered.x_prop_unified,\n            u=self._lowered.u_unified,\n            total_time=self._lowered.x_unified.initial[self._lowered.x_unified.time_slice][0],\n            n_states=self._lowered.x_unified.initial.shape[0],\n            n_states_prop=self._lowered.x_prop_unified.initial.shape[0],\n            ctcs_node_intervals=self.symbolic.node_intervals,\n        ),\n        scp=ScpConfig(\n            n=N,\n            w_tr_max_scaling_factor=1e2,  # Maximum Trust Region Weight\n        ),\n        dis=DiscretizationConfig(),\n        dev=DevConfig(),\n        cvx=ConvexSolverConfig(),\n        prp=PropagationConfig(),\n    )\n\n    # OCP construction happens in initialize() so users can modify\n    # settings (like uniform_time_grid) between __init__ and initialize()\n    self._optimal_control_problem: cp.Problem = None\n    self._discretization_solver: callable = None\n    self._solve_ocp: callable = None  # Solver callable (built during initialize)\n\n    # Set up emitter &amp; thread only if printing is enabled\n    if self.settings.dev.printing:\n        self.print_queue = queue.Queue()\n        self.emitter_function = lambda data: self.print_queue.put(data)\n        self.print_thread = threading.Thread(\n            target=printing.intermediate,\n            args=(self.print_queue, self.settings),\n            daemon=True,\n        )\n        self.print_thread.start()\n    else:\n        # no-op emitter; nothing ever gets queued or printed\n        self.emitter_function = lambda data: None\n\n    self.timing_init = None\n    self.timing_solve = None\n    self.timing_post = None\n\n    # Compiled dynamics (vmapped versions, set in initialize())\n    self._compiled_dynamics: Optional[Dynamics] = None\n    self._compiled_dynamics_prop: Optional[Dynamics] = None\n\n    # Compiled constraints (JIT-compiled versions, set in initialize())\n    self._compiled_constraints: Optional[LoweredJaxConstraints] = None\n\n    # Solver state (created fresh for each solve)\n    self._state: Optional[AlgorithmState] = None\n\n    # Final solution state (saved after successful solve)\n    self._solution: Optional[AlgorithmState] = None\n\n    # SCP algorithm (currently hardcoded to PTR)\n    self._algorithm = PenalizedTrustRegion()\n</code></pre>"},{"location":"reference/problem/#openscvx.problem.Problem.citation","title":"<code>citation() -&gt; str</code>","text":"<p>Return BibTeX citations for all components used in this problem.</p> <p>Aggregates citations from the algorithm and other components (discretization, convex solver, etc.) Each section is prefixed with a comment indicating which component the citation is for.</p> <p>Returns:</p> Type Description <code>str</code> <p>Formatted string containing all BibTeX citations with comments.</p> Example <p>Print all citations for a problem::</p> <pre><code>problem = Problem(dynamics, constraints, states, controls, N, time)\nprint(problem.citation())\n</code></pre> Source code in <code>openscvx/problem.py</code> <pre><code>def citation(self) -&gt; str:\n    \"\"\"Return BibTeX citations for all components used in this problem.\n\n    Aggregates citations from the algorithm and other components (discretization,\n    convex solver, etc.) Each section is prefixed with a comment indicating which component the\n    citation is for.\n\n    Returns:\n        Formatted string containing all BibTeX citations with comments.\n\n    Example:\n        Print all citations for a problem::\n\n            problem = Problem(dynamics, constraints, states, controls, N, time)\n            print(problem.citation())\n    \"\"\"\n    sections = []\n\n    sections.append(r\"% --- AUTO-GENERATED CITATIONS FOR OPENSCVX CONFIGURATION ---\")\n\n    # Algorithm citations\n    algo_citations = self._algorithm.citation()\n    if algo_citations:\n        algo_name = type(self._algorithm).__name__\n        header = f\"% Algorithm: {algo_name}\"\n        citations = \"\\n\".join(algo_citations)\n        sections.append(f\"{header}\\n\\n{citations}\")\n\n    # Future: add citations from discretization, constraint formulations, etc.\n\n    sections.append(r\"% --- END AUTO-GENERATED CITATIONS\")\n\n    return \"\\n\\n\".join(sections)\n</code></pre>"},{"location":"reference/problem/#openscvx.problem.Problem.initialize","title":"<code>initialize()</code>","text":"<p>Compile dynamics, constraints, and solvers; prepare for optimization.</p> <p>This method vmaps dynamics, JIT-compiles constraints, builds the convex subproblem, and initializes the solver state. Must be called before solve().</p> Example <p>Prior to calling the <code>.solve()</code> method it is necessary to initialize the problem</p> <pre><code>problem = Problem(dynamics, constraints, states, controls, N, time)\nproblem.initialize()  # Compile and prepare\nproblem.solve()       # Run optimization\n</code></pre> Source code in <code>openscvx/problem.py</code> <pre><code>def initialize(self):\n    \"\"\"Compile dynamics, constraints, and solvers; prepare for optimization.\n\n    This method vmaps dynamics, JIT-compiles constraints, builds the convex\n    subproblem, and initializes the solver state. Must be called before solve().\n\n    Example:\n        Prior to calling the `.solve()` method it is necessary to initialize the problem\n\n            problem = Problem(dynamics, constraints, states, controls, N, time)\n            problem.initialize()  # Compile and prepare\n            problem.solve()       # Run optimization\n    \"\"\"\n    printing.intro()\n\n    # Print problem summary\n    printing.print_problem_summary(self.settings, self._lowered)\n\n    # Enable the profiler\n    pr = profiling.profiling_start(self.settings.dev.profiling)\n\n    t_0_while = time.time()\n    # Ensure parameter sizes and normalization are correct\n    self.settings.scp.__post_init__()\n    self.settings.sim.__post_init__()\n\n    # Create compiled (vmapped) dynamics as new instances\n    # This preserves the original un-vmapped versions in _lowered\n    self._compiled_dynamics = Dynamics(\n        f=jax.vmap(self._lowered.dynamics.f, in_axes=(0, 0, 0, None)),\n        A=jax.vmap(self._lowered.dynamics.A, in_axes=(0, 0, 0, None)),\n        B=jax.vmap(self._lowered.dynamics.B, in_axes=(0, 0, 0, None)),\n    )\n\n    self._compiled_dynamics_prop = Dynamics(\n        f=jax.vmap(self._lowered.dynamics_prop.f, in_axes=(0, 0, 0, None)),\n    )\n\n    # Create compiled (JIT-compiled) constraints as new instances\n    # This preserves the original un-JIT'd versions in _lowered\n    # TODO: (haynec) switch to AOT instead of JIT\n    compiled_nodal = [\n        LoweredNodalConstraint(\n            func=jax.jit(c.func),\n            grad_g_x=jax.jit(c.grad_g_x),\n            grad_g_u=jax.jit(c.grad_g_u),\n            nodes=c.nodes,\n        )\n        for c in self._lowered.jax_constraints.nodal\n    ]\n\n    compiled_cross_node = [\n        LoweredCrossNodeConstraint(\n            func=jax.jit(c.func),\n            grad_g_X=jax.jit(c.grad_g_X),\n            grad_g_U=jax.jit(c.grad_g_U),\n        )\n        for c in self._lowered.jax_constraints.cross_node\n    ]\n\n    self._compiled_constraints = LoweredJaxConstraints(\n        nodal=compiled_nodal,\n        cross_node=compiled_cross_node,\n        ctcs=self._lowered.jax_constraints.ctcs,  # CTCS aren't JIT-compiled here\n    )\n\n    # Generate solvers using compiled (vmapped) dynamics\n    self._discretization_solver = get_discretization_solver(\n        self._compiled_dynamics, self.settings\n    )\n    self._propagation_solver = get_propagation_solver(\n        self._compiled_dynamics_prop.f, self.settings\n    )\n\n    # Build optimal control problem using LoweredProblem\n    self._optimal_control_problem = optimal_control_problem(self.settings, self._lowered)\n\n    # Get cache file paths using symbolic AST hashing\n    # This is more stable than hashing lowered JAX code\n    dis_solver_file, prop_solver_file = get_solver_cache_paths(\n        self.symbolic,\n        dt=self.settings.prp.dt,\n        total_time=self.settings.sim.total_time,\n        byof=self._byof,\n    )\n\n    # Compile the discretization solver\n    self._discretization_solver = load_or_compile_discretization_solver(\n        self._discretization_solver,\n        dis_solver_file,\n        self._parameters,  # Plain dict for JAX\n        self.settings.scp.n,\n        self.settings.sim.n_states,\n        self.settings.sim.n_controls,\n        save_compiled=self.settings.sim.save_compiled,\n        debug=self.settings.dev.debug,\n    )\n\n    # Setup propagation solver parameters\n    dtau = 1.0 / (self.settings.scp.n - 1)\n    dt_max = self.settings.sim.u.max[self.settings.sim.time_dilation_slice][0] * dtau\n    self.settings.prp.max_tau_len = int(dt_max / self.settings.prp.dt) + 2\n\n    # Compile the propagation solver\n    self._propagation_solver = load_or_compile_propagation_solver(\n        self._propagation_solver,\n        prop_solver_file,\n        self._parameters,  # Plain dict for JAX\n        self.settings.sim.n_states_prop,\n        self.settings.sim.n_controls,\n        self.settings.prp.max_tau_len,\n        save_compiled=self.settings.sim.save_compiled,\n    )\n\n    # Build solver callable (handle CVXPyGen if enabled)\n    if self.settings.cvx.cvxpygen:\n        try:\n            from solver.cpg_solver import cpg_solve\n\n            with open(\"solver/problem.pickle\", \"rb\") as f:\n                pickle.load(f)\n            self._optimal_control_problem.register_solve(\"CPG\", cpg_solve)\n            solver_args = self.settings.cvx.solver_args\n            self._solve_ocp = lambda: self._optimal_control_problem.solve(\n                method=\"CPG\", **solver_args\n            )\n        except ImportError:\n            raise ImportError(\n                \"cvxpygen solver not found. Make sure cvxpygen is installed and code \"\n                \"generation has been run. Install with: pip install openscvx[cvxpygen]\"\n            )\n    else:\n        solver = self.settings.cvx.solver\n        solver_args = self.settings.cvx.solver_args\n        self._solve_ocp = lambda: self._optimal_control_problem.solve(\n            solver=solver, **solver_args\n        )\n\n    # Initialize the SCP algorithm\n    print(\"Initializing the SCvx Subproblem Solver...\")\n    self._algorithm.initialize(\n        self._optimal_control_problem,\n        self._discretization_solver,\n        self._compiled_constraints,\n        self._solve_ocp,\n        self.emitter_function,\n        self._parameters,  # For warm-start only\n        self.settings,  # For warm-start only\n    )\n    print(\"\u2713 SCvx Subproblem Solver initialized\")\n\n    # Create fresh solver state\n    self._state = AlgorithmState.from_settings(self.settings)\n\n    t_f_while = time.time()\n    self.timing_init = t_f_while - t_0_while\n    print(\"Total Initialization Time: \", self.timing_init)\n\n    # Prime the propagation solver\n    prime_propagation_solver(self._propagation_solver, self._parameters, self.settings)\n\n    profiling.profiling_end(pr, \"initialize\")\n</code></pre>"},{"location":"reference/problem/#openscvx.problem.Problem.post_process","title":"<code>post_process() -&gt; OptimizationResults</code>","text":"<p>Propagate solution through full nonlinear dynamics for high-fidelity trajectory.</p> <p>Integrates the converged SCP solution through the nonlinear dynamics to produce x_full, u_full, and t_full. Call after solve() for final results.</p> <p>Returns:</p> Type Description <code>OptimizationResults</code> <p>OptimizationResults with propagated trajectory fields</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If solve() has not been called yet.</p> Source code in <code>openscvx/problem.py</code> <pre><code>def post_process(self) -&gt; OptimizationResults:\n    \"\"\"Propagate solution through full nonlinear dynamics for high-fidelity trajectory.\n\n    Integrates the converged SCP solution through the nonlinear dynamics to\n    produce x_full, u_full, and t_full. Call after solve() for final results.\n\n    Returns:\n        OptimizationResults with propagated trajectory fields\n\n    Raises:\n        ValueError: If solve() has not been called yet.\n    \"\"\"\n    if self._solution is None:\n        raise ValueError(\"No solution available. Call solve() first.\")\n\n    # Enable the profiler\n    pr = profiling.profiling_start(self.settings.dev.profiling)\n\n    # Create result from stored solution state\n    result = self._format_result(self._solution, self._solution.k &lt;= self.settings.scp.k_max)\n\n    t_0_post = time.time()\n    result = propagate_trajectory_results(\n        self._parameters,\n        self.settings,\n        result,\n        self._propagation_solver,\n        algebraic_prop=self._lowered.algebraic_prop,\n    )\n    t_f_post = time.time()\n\n    self.timing_post = t_f_post - t_0_post\n\n    # Store the propagated result back into _solution for plotting\n    # Store as a cached attribute on the _solution object\n    self._solution._propagated_result = result\n\n    # Print results summary\n    printing.print_results_summary(\n        result, self.timing_post, self.timing_init, self.timing_solve\n    )\n\n    profiling.profiling_end(pr, \"postprocess\")\n    return result\n</code></pre>"},{"location":"reference/problem/#openscvx.problem.Problem.reset","title":"<code>reset()</code>","text":"<p>Reset solver state to re-run optimization from initial conditions.</p> <p>Creates fresh AlgorithmState while preserving compiled dynamics and solvers. Use this to run multiple optimizations without re-initializing.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If initialize() has not been called yet.</p> Example <p>After calling <code>.step()</code> it may be necessary to reset the problem back to the initial conditions</p> <pre><code>problem.initialize()\nresult1 = problem.step()\nproblem.reset()\nresult2 = problem.solve()  # Fresh run with same setup\n</code></pre> Source code in <code>openscvx/problem.py</code> <pre><code>def reset(self):\n    \"\"\"Reset solver state to re-run optimization from initial conditions.\n\n    Creates fresh AlgorithmState while preserving compiled dynamics and solvers.\n    Use this to run multiple optimizations without re-initializing.\n\n    Raises:\n        ValueError: If initialize() has not been called yet.\n\n    Example:\n        After calling `.step()` it may be necessary to reset the problem back to the initial\n        conditions\n\n            problem.initialize()\n            result1 = problem.step()\n            problem.reset()\n            result2 = problem.solve()  # Fresh run with same setup\n    \"\"\"\n    if self._compiled_dynamics is None:\n        raise ValueError(\"Problem has not been initialized. Call initialize() first\")\n\n    # Create fresh solver state from settings\n    self._state = AlgorithmState.from_settings(self.settings)\n\n    # Reset solution\n    self._solution = None\n\n    # Reset timing\n    self.timing_solve = None\n    self.timing_post = None\n</code></pre>"},{"location":"reference/problem/#openscvx.problem.Problem.solve","title":"<code>solve(max_iters: Optional[int] = None, continuous: bool = False) -&gt; OptimizationResults</code>","text":"<p>Run the SCP algorithm until convergence or iteration limit.</p> <p>Parameters:</p> Name Type Description Default <code>max_iters</code> <code>Optional[int]</code> <p>Maximum iterations (default: settings.scp.k_max)</p> <code>None</code> <code>continuous</code> <code>bool</code> <p>If True, run all iterations regardless of convergence</p> <code>False</code> <p>Returns:</p> Type Description <code>OptimizationResults</code> <p>OptimizationResults with trajectory and convergence info (call post_process() for full propagation)</p> Source code in <code>openscvx/problem.py</code> <pre><code>def solve(\n    self, max_iters: Optional[int] = None, continuous: bool = False\n) -&gt; OptimizationResults:\n    \"\"\"Run the SCP algorithm until convergence or iteration limit.\n\n    Args:\n        max_iters: Maximum iterations (default: settings.scp.k_max)\n        continuous: If True, run all iterations regardless of convergence\n\n    Returns:\n        OptimizationResults with trajectory and convergence info\n            (call post_process() for full propagation)\n    \"\"\"\n    # Sync parameters before solving\n    self._sync_parameters()\n\n    required = [\n        self._compiled_dynamics,\n        self._compiled_constraints,\n        self._optimal_control_problem,\n        self._discretization_solver,\n        self._state,\n    ]\n    if any(r is None for r in required):\n        raise ValueError(\"Problem has not been initialized. Call initialize() before solve()\")\n\n    # Enable the profiler\n    pr = profiling.profiling_start(self.settings.dev.profiling)\n\n    t_0_while = time.time()\n    # Print top header for solver results\n    printing.header()\n\n    k_max = max_iters if max_iters is not None else self.settings.scp.k_max\n\n    while self._state.k &lt;= k_max:\n        result = self.step()\n        if result[\"converged\"] and not continuous:\n            break\n\n    t_f_while = time.time()\n    self.timing_solve = t_f_while - t_0_while\n\n    while self.print_queue.qsize() &gt; 0:\n        time.sleep(0.1)\n\n    # Print bottom footer for solver results as well as total computation time\n    printing.footer()\n\n    profiling.profiling_end(pr, \"solve\")\n\n    # Store solution state\n    self._solution = copy.deepcopy(self._state)\n\n    return self._format_result(self._state, self._state.k &lt;= k_max)\n</code></pre>"},{"location":"reference/problem/#openscvx.problem.Problem.step","title":"<code>step() -&gt; dict</code>","text":"<p>Perform a single SCP iteration.</p> <p>Designed for real-time plotting and interactive optimization. Performs one iteration including subproblem solve, state update, and progress emission.</p> Note <p>This method is NOT idempotent - it mutates internal state and advances the iteration counter. Use reset() to return to initial conditions.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Contains \"converged\" (bool) and current iteration state</p> Example <p>Call <code>.step()</code> manually in a loop to control the algorithm directly</p> <pre><code>problem.initialize()\nwhile not problem.step()[\"converged\"]:\n    plot_trajectory(problem.state.trajs[-1])\n</code></pre> Source code in <code>openscvx/problem.py</code> <pre><code>def step(self) -&gt; dict:\n    \"\"\"Perform a single SCP iteration.\n\n    Designed for real-time plotting and interactive optimization. Performs one\n    iteration including subproblem solve, state update, and progress emission.\n\n    Note:\n        This method is NOT idempotent - it mutates internal state and advances\n        the iteration counter. Use reset() to return to initial conditions.\n\n    Returns:\n        dict: Contains \"converged\" (bool) and current iteration state\n\n    Example:\n        Call `.step()` manually in a loop to control the algorithm directly\n\n            problem.initialize()\n            while not problem.step()[\"converged\"]:\n                plot_trajectory(problem.state.trajs[-1])\n    \"\"\"\n    if self._state is None:\n        raise ValueError(\"Problem has not been initialized. Call initialize() first\")\n\n    converged = self._algorithm.step(\n        self._state,\n        self._parameters,  # May change between steps\n        self.settings,  # May change between steps\n    )\n\n    # Return dict matching original API\n    return {\n        \"converged\": converged,\n        \"scp_k\": self._state.k,\n        \"scp_J_tr\": self._state.J_tr,\n        \"scp_J_vb\": self._state.J_vb,\n        \"scp_J_vc\": self._state.J_vc,\n    }\n</code></pre>"},{"location":"reference/algorithms/","title":"algorithms","text":"<p>Successive convexification algorithms for trajectory optimization.</p> <p>This module provides implementations of SCvx (Successive Convexification) algorithms for solving non-convex trajectory optimization problems through iterative convex approximation.</p> <p>All algorithms inherit from :class:<code>Algorithm</code>, enabling pluggable algorithm implementations and custom SCvx variants:</p> <pre><code>class Algorithm(ABC):\n    @abstractmethod\n    def initialize(self, ocp, discretization_solver, jax_constraints,\n                   solve_ocp, emitter, params, settings) -&gt; None:\n        '''Store compiled infrastructure and warm-start solvers.'''\n        ...\n\n    @abstractmethod\n    def step(self, state, params, settings) -&gt; bool:\n        '''Execute one iteration using stored infrastructure.'''\n        ...\n</code></pre> <p>Immutable components (ocp, discretization_solver, jax_constraints, etc.) are stored during <code>initialize()</code>. Mutable configuration (params, settings) is passed per-step to support runtime parameter updates and tolerance tuning.</p> <p>:class:<code>AlgorithmState</code> holds mutable state during SCP iterations. Algorithms that require additional state can subclass it:</p> <pre><code>@dataclass\nclass MyAlgorithmState(AlgorithmState):\n    my_custom_field: float = 0.0\n</code></pre> Note <p><code>AlgorithmState</code> currently combines iteration metrics (costs, weights), trajectory history, and discretization data. A future refactor may separate these concerns into distinct classes for clearer data flow:</p> <pre><code>@dataclass\nclass AlgorithmState:\n    # Mutable iteration state\n    k: int\n    J_tr: float\n    J_vb: float\n    J_vc: float\n    w_tr: float\n    lam_cost: float\n    lam_vc: ...\n    lam_vb: float\n\n@dataclass\nclass TrajectoryHistory:\n    # Accumulated trajectory solutions\n    X: List[np.ndarray]\n    U: List[np.ndarray]\n\n    @property\n    def x(self): return self.X[-1]\n\n    @property\n    def u(self): return self.U[-1]\n\n@dataclass\nclass DebugHistory:\n    # Optional diagnostic data (discretization matrices, etc.)\n    V_history: List[np.ndarray]\n    VC_history: List[np.ndarray]\n    TR_history: List[np.ndarray]\n</code></pre> <p>Current Implementations:</p> <ul> <li>:class:<code>PenalizedTrustRegion</code>: Penalized Trust Region (PTR) algorithm</li> </ul>"},{"location":"reference/algorithms/#openscvx.algorithms.Algorithm","title":"<code>Algorithm</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for successive convexification algorithms.</p> <p>This class defines the interface for SCP algorithms used in trajectory optimization. Implementations should remain minimal and functional, delegating state management to the AlgorithmState dataclass.</p> <p>The two core methods mirror the SCP workflow:</p> <ul> <li>initialize: Store compiled infrastructure and warm-start solvers</li> <li>step: Execute one convex subproblem iteration</li> </ul> <p>Immutable components (ocp, discretization_solver, jax_constraints, etc.) are stored during initialize(). Mutable configuration (params, settings) is passed per-step to support runtime parameter updates and tolerance tuning.</p> <p>Statefullness</p> <p>Avoid storing mutable iteration state (costs, weights, trajectories) on <code>self</code>. All iteration state should live in :class:<code>AlgorithmState</code> or a subclass thereof, passed explicitly to <code>step()</code>. This keeps algorithm classes stateless w.r.t. iteration, making data flow explicit and staying close to functional programming principles where possible.</p> Example <p>Implementing a custom algorithm::</p> <pre><code>class MyAlgorithm(Algorithm):\n    def initialize(self, ocp, discretization_solver,\n                   jax_constraints, solve_ocp, emitter,\n                   params, settings):\n        # Store compiled infrastructure\n        self._ocp = ocp\n        self._discretization_solver = discretization_solver\n        self._jax_constraints = jax_constraints\n        self._solve_ocp = solve_ocp\n        self._emitter = emitter\n        # Warm-start with initial params/settings...\n\n    def step(self, state, params, settings):\n        # Run one iteration using self._* and per-step params/settings\n        return converged\n</code></pre> Source code in <code>openscvx/algorithms/base.py</code> <pre><code>class Algorithm(ABC):\n    \"\"\"Abstract base class for successive convexification algorithms.\n\n    This class defines the interface for SCP algorithms used in trajectory\n    optimization. Implementations should remain minimal and functional,\n    delegating state management to the AlgorithmState dataclass.\n\n    The two core methods mirror the SCP workflow:\n\n    - initialize: Store compiled infrastructure and warm-start solvers\n    - step: Execute one convex subproblem iteration\n\n    Immutable components (ocp, discretization_solver, jax_constraints, etc.) are\n    stored during initialize(). Mutable configuration (params, settings) is passed\n    per-step to support runtime parameter updates and tolerance tuning.\n\n    !!! tip \"Statefullness\"\n        Avoid storing mutable iteration state (costs, weights, trajectories) on\n        ``self``. All iteration state should live in :class:`AlgorithmState` or\n        a subclass thereof, passed explicitly to ``step()``. This keeps algorithm\n        classes stateless w.r.t. iteration, making data flow explicit and staying\n        close to functional programming principles where possible.\n\n    Example:\n        Implementing a custom algorithm::\n\n            class MyAlgorithm(Algorithm):\n                def initialize(self, ocp, discretization_solver,\n                               jax_constraints, solve_ocp, emitter,\n                               params, settings):\n                    # Store compiled infrastructure\n                    self._ocp = ocp\n                    self._discretization_solver = discretization_solver\n                    self._jax_constraints = jax_constraints\n                    self._solve_ocp = solve_ocp\n                    self._emitter = emitter\n                    # Warm-start with initial params/settings...\n\n                def step(self, state, params, settings):\n                    # Run one iteration using self._* and per-step params/settings\n                    return converged\n    \"\"\"\n\n    @abstractmethod\n    def initialize(\n        self,\n        ocp: \"cp.Problem\",\n        discretization_solver: callable,\n        jax_constraints: \"LoweredJaxConstraints\",\n        solve_ocp: callable,\n        emitter: callable,\n        params: dict,\n        settings: \"Config\",\n    ) -&gt; None:\n        \"\"\"Initialize the algorithm and store compiled infrastructure.\n\n        This method stores immutable components and performs any setup required\n        before the SCP loop begins (e.g., warm-starting solvers). The params and\n        settings are passed for warm-start but may change between steps.\n\n        Args:\n            ocp: The CVXPy optimal control problem\n            discretization_solver: Compiled discretization solver function\n            jax_constraints: JIT-compiled JAX constraint functions\n            solve_ocp: Callable that solves the OCP (captures solver config)\n            emitter: Callback for emitting iteration progress data\n            params: Problem parameters dictionary (for warm-start only)\n            settings: Configuration object (for warm-start only)\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def step(\n        self,\n        state: AlgorithmState,\n        params: dict,\n        settings: \"Config\",\n    ) -&gt; bool:\n        \"\"\"Execute one iteration of the SCP algorithm.\n\n        This method solves a single convex subproblem, updates the algorithm\n        state in place, and returns whether convergence criteria are met.\n\n        Uses stored infrastructure (ocp, discretization_solver, etc.) with\n        per-step params and settings to support runtime modifications.\n\n        Args:\n            state: Mutable algorithm state (modified in place)\n            params: Problem parameters dictionary (may change between steps)\n            settings: Configuration object (may change between steps)\n\n        Returns:\n            True if convergence criteria are satisfied, False otherwise.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def citation(self) -&gt; List[str]:\n        \"\"\"Return BibTeX citations for this algorithm.\n\n        Implementations should return a list of BibTeX entry strings for the\n        papers that should be cited when using this algorithm.\n\n        Returns:\n            List of BibTeX citation strings.\n\n        Example:\n            Getting citations for an algorithm::\n\n                algorithm = PenalizedTrustRegion()\n                for bibtex in algorithm.citation():\n                    print(bibtex)\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.Algorithm.citation","title":"<code>citation() -&gt; List[str]</code>  <code>abstractmethod</code>","text":"<p>Return BibTeX citations for this algorithm.</p> <p>Implementations should return a list of BibTeX entry strings for the papers that should be cited when using this algorithm.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of BibTeX citation strings.</p> Example <p>Getting citations for an algorithm::</p> <pre><code>algorithm = PenalizedTrustRegion()\nfor bibtex in algorithm.citation():\n    print(bibtex)\n</code></pre> Source code in <code>openscvx/algorithms/base.py</code> <pre><code>@abstractmethod\ndef citation(self) -&gt; List[str]:\n    \"\"\"Return BibTeX citations for this algorithm.\n\n    Implementations should return a list of BibTeX entry strings for the\n    papers that should be cited when using this algorithm.\n\n    Returns:\n        List of BibTeX citation strings.\n\n    Example:\n        Getting citations for an algorithm::\n\n            algorithm = PenalizedTrustRegion()\n            for bibtex in algorithm.citation():\n                print(bibtex)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.Algorithm.initialize","title":"<code>initialize(ocp: cp.Problem, discretization_solver: callable, jax_constraints: LoweredJaxConstraints, solve_ocp: callable, emitter: callable, params: dict, settings: Config) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Initialize the algorithm and store compiled infrastructure.</p> <p>This method stores immutable components and performs any setup required before the SCP loop begins (e.g., warm-starting solvers). The params and settings are passed for warm-start but may change between steps.</p> <p>Parameters:</p> Name Type Description Default <code>ocp</code> <code>Problem</code> <p>The CVXPy optimal control problem</p> required <code>discretization_solver</code> <code>callable</code> <p>Compiled discretization solver function</p> required <code>jax_constraints</code> <code>LoweredJaxConstraints</code> <p>JIT-compiled JAX constraint functions</p> required <code>solve_ocp</code> <code>callable</code> <p>Callable that solves the OCP (captures solver config)</p> required <code>emitter</code> <code>callable</code> <p>Callback for emitting iteration progress data</p> required <code>params</code> <code>dict</code> <p>Problem parameters dictionary (for warm-start only)</p> required <code>settings</code> <code>Config</code> <p>Configuration object (for warm-start only)</p> required Source code in <code>openscvx/algorithms/base.py</code> <pre><code>@abstractmethod\ndef initialize(\n    self,\n    ocp: \"cp.Problem\",\n    discretization_solver: callable,\n    jax_constraints: \"LoweredJaxConstraints\",\n    solve_ocp: callable,\n    emitter: callable,\n    params: dict,\n    settings: \"Config\",\n) -&gt; None:\n    \"\"\"Initialize the algorithm and store compiled infrastructure.\n\n    This method stores immutable components and performs any setup required\n    before the SCP loop begins (e.g., warm-starting solvers). The params and\n    settings are passed for warm-start but may change between steps.\n\n    Args:\n        ocp: The CVXPy optimal control problem\n        discretization_solver: Compiled discretization solver function\n        jax_constraints: JIT-compiled JAX constraint functions\n        solve_ocp: Callable that solves the OCP (captures solver config)\n        emitter: Callback for emitting iteration progress data\n        params: Problem parameters dictionary (for warm-start only)\n        settings: Configuration object (for warm-start only)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.Algorithm.step","title":"<code>step(state: AlgorithmState, params: dict, settings: Config) -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Execute one iteration of the SCP algorithm.</p> <p>This method solves a single convex subproblem, updates the algorithm state in place, and returns whether convergence criteria are met.</p> <p>Uses stored infrastructure (ocp, discretization_solver, etc.) with per-step params and settings to support runtime modifications.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>AlgorithmState</code> <p>Mutable algorithm state (modified in place)</p> required <code>params</code> <code>dict</code> <p>Problem parameters dictionary (may change between steps)</p> required <code>settings</code> <code>Config</code> <p>Configuration object (may change between steps)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if convergence criteria are satisfied, False otherwise.</p> Source code in <code>openscvx/algorithms/base.py</code> <pre><code>@abstractmethod\ndef step(\n    self,\n    state: AlgorithmState,\n    params: dict,\n    settings: \"Config\",\n) -&gt; bool:\n    \"\"\"Execute one iteration of the SCP algorithm.\n\n    This method solves a single convex subproblem, updates the algorithm\n    state in place, and returns whether convergence criteria are met.\n\n    Uses stored infrastructure (ocp, discretization_solver, etc.) with\n    per-step params and settings to support runtime modifications.\n\n    Args:\n        state: Mutable algorithm state (modified in place)\n        params: Problem parameters dictionary (may change between steps)\n        settings: Configuration object (may change between steps)\n\n    Returns:\n        True if convergence criteria are satisfied, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.AlgorithmState","title":"<code>AlgorithmState</code>  <code>dataclass</code>","text":"<p>Mutable state for SCP iterations.</p> <p>This dataclass holds all state that changes during the solve process. It stores only the evolving trajectory arrays, not the full State/Control objects which contain immutable configuration metadata.</p> <p>Trajectory arrays are stored in history lists, with the current guess accessed via properties that return the latest entry.</p> <p>A fresh instance is created for each solve, enabling easy reset functionality.</p> <p>Attributes:</p> Name Type Description <code>k</code> <code>int</code> <p>Current iteration number (starts at 1)</p> <code>J_tr</code> <code>float</code> <p>Current trust region cost</p> <code>J_vb</code> <code>float</code> <p>Current virtual buffer cost</p> <code>J_vc</code> <code>float</code> <p>Current virtual control cost</p> <code>w_tr</code> <code>float</code> <p>Current trust region weight (may adapt during solve)</p> <code>lam_cost</code> <code>float</code> <p>Current cost weight (may relax during solve)</p> <code>lam_vc</code> <code>Union[float, ndarray]</code> <p>Current virtual control penalty weight</p> <code>lam_vb</code> <code>float</code> <p>Current virtual buffer penalty weight</p> <code>n_x</code> <code>int</code> <p>Number of states (for unpacking V vectors)</p> <code>n_u</code> <code>int</code> <p>Number of controls (for unpacking V vectors)</p> <code>N</code> <code>int</code> <p>Number of trajectory nodes (for unpacking V vectors)</p> <code>X</code> <code>List[ndarray]</code> <p>List of state trajectory iterates</p> <code>U</code> <code>List[ndarray]</code> <p>List of control trajectory iterates</p> <code>V_history</code> <code>List[ndarray]</code> <p>List of discretization history</p> Source code in <code>openscvx/algorithms/base.py</code> <pre><code>@dataclass\nclass AlgorithmState:\n    \"\"\"Mutable state for SCP iterations.\n\n    This dataclass holds all state that changes during the solve process.\n    It stores only the evolving trajectory arrays, not the full State/Control\n    objects which contain immutable configuration metadata.\n\n    Trajectory arrays are stored in history lists, with the current guess\n    accessed via properties that return the latest entry.\n\n    A fresh instance is created for each solve, enabling easy reset functionality.\n\n    Attributes:\n        k: Current iteration number (starts at 1)\n        J_tr: Current trust region cost\n        J_vb: Current virtual buffer cost\n        J_vc: Current virtual control cost\n        w_tr: Current trust region weight (may adapt during solve)\n        lam_cost: Current cost weight (may relax during solve)\n        lam_vc: Current virtual control penalty weight\n        lam_vb: Current virtual buffer penalty weight\n        n_x: Number of states (for unpacking V vectors)\n        n_u: Number of controls (for unpacking V vectors)\n        N: Number of trajectory nodes (for unpacking V vectors)\n        X: List of state trajectory iterates\n        U: List of control trajectory iterates\n        V_history: List of discretization history\n    \"\"\"\n\n    k: int\n    J_tr: float\n    J_vb: float\n    J_vc: float\n    w_tr: float\n    lam_cost: float\n    lam_vc: Union[float, np.ndarray]\n    lam_vb: float\n    n_x: int\n    n_u: int\n    N: int\n    X: List[np.ndarray] = field(default_factory=list)\n    U: List[np.ndarray] = field(default_factory=list)\n    V_history: List[np.ndarray] = field(default_factory=list)\n    VC_history: List[np.ndarray] = field(default_factory=list)\n    TR_history: List[np.ndarray] = field(default_factory=list)\n\n    @property\n    def x(self) -&gt; np.ndarray:\n        \"\"\"Get current state trajectory array.\n\n        Returns:\n            Current state trajectory guess (latest entry in history), shape (N, n_states)\n        \"\"\"\n        return self.X[-1]\n\n    @property\n    def u(self) -&gt; np.ndarray:\n        \"\"\"Get current control trajectory array.\n\n        Returns:\n            Current control trajectory guess (latest entry in history), shape (N, n_controls)\n        \"\"\"\n        return self.U[-1]\n\n    @property\n    def x_prop(self) -&gt; np.ndarray:\n        \"\"\"Extract propagated state trajectory from latest V.\n\n        Returns:\n            Propagated state trajectory x_prop with shape (N-1, n_x), or None if no V_history\n\n        Example:\n            After running an iteration, access the propagated states::\n\n                problem.step()\n                x_prop = problem.state.x_prop  # Shape (N-1, n_x)\n        \"\"\"\n        if not self.V_history:\n            return None\n\n        # V_history contains Vmulti from discretization\n        # Shape: (flattened_size, n_timesteps) where flattened_size = (N-1) * i4\n        V = self.V_history[-1]\n\n        # Take final timestep and reshape to (N-1, i4)\n        i4 = self.n_x + self.n_x * self.n_x + 2 * self.n_x * self.n_u\n        V_final = V[:, -1].reshape(-1, i4)\n\n        # Extract propagated state (first n_x elements of each row)\n        return V_final[:, : self.n_x]\n\n    @property\n    def A_d(self) -&gt; np.ndarray:\n        \"\"\"Extract discretized state transition matrix from latest V.\n\n        Returns:\n            Discretized state Jacobian A_d with shape (N-1, n_x, n_x), or None if no V_history\n\n        Example:\n            After running an iteration, access linearization matrices::\n\n                problem.step()\n                A_d = problem.state.A_d  # Shape (N-1, n_x, n_x)\n        \"\"\"\n        if not self.V_history:\n            return None\n\n        # Extract indices for unpacking V vector\n        i1 = self.n_x\n        i2 = i1 + self.n_x * self.n_x\n\n        # V_history contains Vmulti from discretization\n        # Shape: (flattened_size, n_timesteps) where flattened_size = (N-1) * i4\n        V = self.V_history[-1]\n\n        # Take final timestep and reshape to (N-1, i4)\n        i4 = self.n_x + self.n_x * self.n_x + 2 * self.n_x * self.n_u\n        V_final = V[:, -1].reshape(-1, i4)\n\n        # Extract and reshape A_d matrix\n        return V_final[:, i1:i2].reshape(self.N - 1, self.n_x, self.n_x)\n\n    @property\n    def B_d(self) -&gt; np.ndarray:\n        \"\"\"Extract discretized control influence matrix (current node) from latest V.\n\n        Returns:\n            Discretized control Jacobian B_d with shape (N-1, n_x, n_u), or None if no V_history\n\n        Example:\n            After running an iteration, access linearization matrices::\n\n                problem.step()\n                B_d = problem.state.B_d  # Shape (N-1, n_x, n_u)\n        \"\"\"\n        if not self.V_history:\n            return None\n\n        # Extract indices for unpacking V vector\n        i1 = self.n_x\n        i2 = i1 + self.n_x * self.n_x\n        i3 = i2 + self.n_x * self.n_u\n\n        # V_history contains Vmulti from discretization\n        V = self.V_history[-1]\n\n        # Take final timestep and reshape to (N-1, i4)\n        i4 = self.n_x + self.n_x * self.n_x + 2 * self.n_x * self.n_u\n        V_final = V[:, -1].reshape(-1, i4)\n\n        # Extract and reshape B_d matrix\n        return V_final[:, i2:i3].reshape(self.N - 1, self.n_x, self.n_u)\n\n    @property\n    def C_d(self) -&gt; np.ndarray:\n        \"\"\"Extract discretized control influence matrix (next node) from latest V.\n\n        Returns:\n            Discretized control Jacobian C_d with shape (N-1, n_x, n_u), or None if no V_history\n\n        Example:\n            After running an iteration, access linearization matrices::\n\n                problem.step()\n                C_d = problem.state.C_d  # Shape (N-1, n_x, n_u)\n        \"\"\"\n        if not self.V_history:\n            return None\n\n        # Extract indices for unpacking V vector\n        i2 = self.n_x + self.n_x * self.n_x\n        i3 = i2 + self.n_x * self.n_u\n        i4 = i3 + self.n_x * self.n_u\n\n        # V_history contains Vmulti from discretization\n        V = self.V_history[-1]\n\n        # Take final timestep and reshape to (N-1, i4)\n        V_final = V[:, -1].reshape(-1, i4)\n\n        # Extract and reshape C_d matrix\n        return V_final[:, i3:i4].reshape(self.N - 1, self.n_x, self.n_u)\n\n    @classmethod\n    def from_settings(cls, settings: \"Config\") -&gt; \"AlgorithmState\":\n        \"\"\"Create initial algorithm state from configuration.\n\n        Copies only the trajectory arrays from settings, leaving all metadata\n        (bounds, boundary conditions, etc.) in the original settings object.\n\n        Args:\n            settings: Configuration object containing initial guesses and SCP parameters\n\n        Returns:\n            Fresh AlgorithmState initialized from settings with copied arrays\n        \"\"\"\n        return cls(\n            k=1,\n            J_tr=1e2,\n            J_vb=1e2,\n            J_vc=1e2,\n            w_tr=settings.scp.w_tr,\n            lam_cost=settings.scp.lam_cost,\n            lam_vc=settings.scp.lam_vc,\n            lam_vb=settings.scp.lam_vb,\n            n_x=settings.sim.n_states,\n            n_u=settings.sim.n_controls,\n            N=settings.scp.n,\n            X=[settings.sim.x.guess.copy()],\n            U=[settings.sim.u.guess.copy()],\n            V_history=[],\n            VC_history=[],\n            TR_history=[],\n        )\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.AlgorithmState.A_d","title":"<code>A_d: np.ndarray</code>  <code>property</code>","text":"<p>Extract discretized state transition matrix from latest V.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Discretized state Jacobian A_d with shape (N-1, n_x, n_x), or None if no V_history</p> Example <p>After running an iteration, access linearization matrices::</p> <pre><code>problem.step()\nA_d = problem.state.A_d  # Shape (N-1, n_x, n_x)\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.AlgorithmState.B_d","title":"<code>B_d: np.ndarray</code>  <code>property</code>","text":"<p>Extract discretized control influence matrix (current node) from latest V.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Discretized control Jacobian B_d with shape (N-1, n_x, n_u), or None if no V_history</p> Example <p>After running an iteration, access linearization matrices::</p> <pre><code>problem.step()\nB_d = problem.state.B_d  # Shape (N-1, n_x, n_u)\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.AlgorithmState.C_d","title":"<code>C_d: np.ndarray</code>  <code>property</code>","text":"<p>Extract discretized control influence matrix (next node) from latest V.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Discretized control Jacobian C_d with shape (N-1, n_x, n_u), or None if no V_history</p> Example <p>After running an iteration, access linearization matrices::</p> <pre><code>problem.step()\nC_d = problem.state.C_d  # Shape (N-1, n_x, n_u)\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.AlgorithmState.u","title":"<code>u: np.ndarray</code>  <code>property</code>","text":"<p>Get current control trajectory array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Current control trajectory guess (latest entry in history), shape (N, n_controls)</p>"},{"location":"reference/algorithms/#openscvx.algorithms.AlgorithmState.x","title":"<code>x: np.ndarray</code>  <code>property</code>","text":"<p>Get current state trajectory array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Current state trajectory guess (latest entry in history), shape (N, n_states)</p>"},{"location":"reference/algorithms/#openscvx.algorithms.AlgorithmState.x_prop","title":"<code>x_prop: np.ndarray</code>  <code>property</code>","text":"<p>Extract propagated state trajectory from latest V.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Propagated state trajectory x_prop with shape (N-1, n_x), or None if no V_history</p> Example <p>After running an iteration, access the propagated states::</p> <pre><code>problem.step()\nx_prop = problem.state.x_prop  # Shape (N-1, n_x)\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.AlgorithmState.from_settings","title":"<code>from_settings(settings: Config) -&gt; AlgorithmState</code>  <code>classmethod</code>","text":"<p>Create initial algorithm state from configuration.</p> <p>Copies only the trajectory arrays from settings, leaving all metadata (bounds, boundary conditions, etc.) in the original settings object.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Config</code> <p>Configuration object containing initial guesses and SCP parameters</p> required <p>Returns:</p> Type Description <code>AlgorithmState</code> <p>Fresh AlgorithmState initialized from settings with copied arrays</p> Source code in <code>openscvx/algorithms/base.py</code> <pre><code>@classmethod\ndef from_settings(cls, settings: \"Config\") -&gt; \"AlgorithmState\":\n    \"\"\"Create initial algorithm state from configuration.\n\n    Copies only the trajectory arrays from settings, leaving all metadata\n    (bounds, boundary conditions, etc.) in the original settings object.\n\n    Args:\n        settings: Configuration object containing initial guesses and SCP parameters\n\n    Returns:\n        Fresh AlgorithmState initialized from settings with copied arrays\n    \"\"\"\n    return cls(\n        k=1,\n        J_tr=1e2,\n        J_vb=1e2,\n        J_vc=1e2,\n        w_tr=settings.scp.w_tr,\n        lam_cost=settings.scp.lam_cost,\n        lam_vc=settings.scp.lam_vc,\n        lam_vb=settings.scp.lam_vb,\n        n_x=settings.sim.n_states,\n        n_u=settings.sim.n_controls,\n        N=settings.scp.n,\n        X=[settings.sim.x.guess.copy()],\n        U=[settings.sim.u.guess.copy()],\n        V_history=[],\n        VC_history=[],\n        TR_history=[],\n    )\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.OptimizationResults","title":"<code>OptimizationResults</code>  <code>dataclass</code>","text":"<p>Structured container for optimization results from the Successive Convexification (SCP) solver.</p> <p>This class provides a type-safe and organized way to store and access optimization results, replacing the previous dictionary-based approach. It includes core optimization data, iteration history for convergence analysis, post-processing results, and flexible storage for plotting and application-specific data.</p> <p>Attributes:</p> Name Type Description <code>converged</code> <code>bool</code> <p>Whether the optimization successfully converged</p> <code>t_final</code> <code>float</code> <p>Final time of the optimized trajectory</p> <code>x_guess</code> <code>ndarray</code> <p>Optimized state trajectory at discretization nodes, shape (N, n_states)</p> <code>u_guess</code> <code>ndarray</code> <p>Optimized control trajectory at discretization nodes, shape (N, n_controls)</p> <code>nodes</code> <code>dict[str, ndarray]</code> <p>Dictionary mapping state/control names to arrays at optimization nodes. Includes both user-defined and augmented variables.</p> <code>trajectory</code> <code>dict[str, ndarray]</code> <p>Dictionary mapping state/control names to arrays along the propagated trajectory. Added by post_process().</p> <code>x_history</code> <code>list[ndarray]</code> <p>State trajectories from each SCP iteration</p> <code>u_history</code> <code>list[ndarray]</code> <p>Control trajectories from each SCP iteration</p> <code>discretization_history</code> <code>list[ndarray]</code> <p>Time discretization from each iteration</p> <code>J_tr_history</code> <code>list[ndarray]</code> <p>Trust region cost history</p> <code>J_vb_history</code> <code>list[ndarray]</code> <p>Virtual buffer cost history</p> <code>J_vc_history</code> <code>list[ndarray]</code> <p>Virtual control cost history</p> <code>t_full</code> <code>Optional[ndarray]</code> <p>Full time grid for interpolated trajectory</p> <code>x_full</code> <code>Optional[ndarray]</code> <p>Interpolated state trajectory on full time grid</p> <code>u_full</code> <code>Optional[ndarray]</code> <p>Interpolated control trajectory on full time grid</p> <code>cost</code> <code>Optional[float]</code> <p>Total cost of the optimized trajectory</p> <code>ctcs_violation</code> <code>Optional[ndarray]</code> <p>Continuous-time constraint violations</p> <code>plotting_data</code> <code>dict[str, Any]</code> <p>Flexible storage for plotting and application data</p> Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>@dataclass\nclass OptimizationResults:\n    \"\"\"\n    Structured container for optimization results from the Successive Convexification (SCP) solver.\n\n    This class provides a type-safe and organized way to store and access optimization results,\n    replacing the previous dictionary-based approach. It includes core optimization data,\n    iteration history for convergence analysis, post-processing results, and flexible\n    storage for plotting and application-specific data.\n\n    Attributes:\n        converged (bool): Whether the optimization successfully converged\n        t_final (float): Final time of the optimized trajectory\n        x_guess (np.ndarray): Optimized state trajectory at discretization nodes,\n            shape (N, n_states)\n        u_guess (np.ndarray): Optimized control trajectory at discretization nodes,\n            shape (N, n_controls)\n\n        # Dictionary-based Access\n        nodes (dict[str, np.ndarray]): Dictionary mapping state/control names to arrays\n            at optimization nodes. Includes both user-defined and augmented variables.\n        trajectory (dict[str, np.ndarray]): Dictionary mapping state/control names to arrays\n            along the propagated trajectory. Added by post_process().\n\n        # SCP Iteration History (for convergence analysis)\n        x_history (list[np.ndarray]): State trajectories from each SCP iteration\n        u_history (list[np.ndarray]): Control trajectories from each SCP iteration\n        discretization_history (list[np.ndarray]): Time discretization from each iteration\n        J_tr_history (list[np.ndarray]): Trust region cost history\n        J_vb_history (list[np.ndarray]): Virtual buffer cost history\n        J_vc_history (list[np.ndarray]): Virtual control cost history\n\n        # Post-processing Results (added by propagate_trajectory_results)\n        t_full (Optional[np.ndarray]): Full time grid for interpolated trajectory\n        x_full (Optional[np.ndarray]): Interpolated state trajectory on full time grid\n        u_full (Optional[np.ndarray]): Interpolated control trajectory on full time grid\n        cost (Optional[float]): Total cost of the optimized trajectory\n        ctcs_violation (Optional[np.ndarray]): Continuous-time constraint violations\n\n        # User-defined Data\n        plotting_data (dict[str, Any]): Flexible storage for plotting and application data\n    \"\"\"\n\n    # Core optimization results\n    converged: bool\n    t_final: float\n\n    # Dictionary-based access to states and controls\n    nodes: dict[str, np.ndarray] = field(default_factory=dict)\n    trajectory: dict[str, np.ndarray] = field(default_factory=dict)\n\n    # Internal metadata for dictionary construction\n    _states: list = field(default_factory=list, repr=False)\n    _controls: list = field(default_factory=list, repr=False)\n\n    # History of SCP iterations (single source of truth)\n    X: list[np.ndarray] = field(default_factory=list)\n    U: list[np.ndarray] = field(default_factory=list)\n    discretization_history: list[np.ndarray] = field(default_factory=list)\n    J_tr_history: list[np.ndarray] = field(default_factory=list)\n    J_vb_history: list[np.ndarray] = field(default_factory=list)\n    J_vc_history: list[np.ndarray] = field(default_factory=list)\n    TR_history: list[np.ndarray] = field(default_factory=list)\n    VC_history: list[np.ndarray] = field(default_factory=list)\n\n    @property\n    def x(self) -&gt; np.ndarray:\n        \"\"\"Optimal state trajectory at discretization nodes.\n\n        Returns the final converged solution from the SCP iteration history.\n\n        Returns:\n            State trajectory array, shape (N, n_states)\n        \"\"\"\n        return self.X[-1]\n\n    @property\n    def u(self) -&gt; np.ndarray:\n        \"\"\"Optimal control trajectory at discretization nodes.\n\n        Returns the final converged solution from the SCP iteration history.\n\n        Returns:\n            Control trajectory array, shape (N, n_controls)\n        \"\"\"\n        return self.U[-1]\n\n    # Post-processing results (added by propagate_trajectory_results)\n    t_full: Optional[np.ndarray] = None\n    x_full: Optional[np.ndarray] = None\n    u_full: Optional[np.ndarray] = None\n    cost: Optional[float] = None\n    ctcs_violation: Optional[np.ndarray] = None\n\n    # Additional plotting/application data (added by user)\n    plotting_data: dict[str, Any] = field(default_factory=dict)\n\n    def __post_init__(self):\n        \"\"\"Initialize the results object.\"\"\"\n        pass\n\n    def update_plotting_data(self, **kwargs):\n        \"\"\"\n        Update the plotting data with additional information.\n\n        Args:\n            **kwargs: Key-value pairs to add to plotting_data\n        \"\"\"\n        self.plotting_data.update(kwargs)\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"\n        Get a value from the results, similar to dict.get().\n\n        Args:\n            key: The key to look up\n            default: Default value if key is not found\n\n        Returns:\n            The value associated with the key, or default if not found\n        \"\"\"\n        # Check if it's a direct attribute\n        if hasattr(self, key):\n            return getattr(self, key)\n\n        # Check if it's in plotting_data\n        if key in self.plotting_data:\n            return self.plotting_data[key]\n\n        return default\n\n    def __getitem__(self, key: str) -&gt; Any:\n        \"\"\"\n        Allow dictionary-style access to results.\n\n        Args:\n            key: The key to look up\n\n        Returns:\n            The value associated with the key\n\n        Raises:\n            KeyError: If key is not found\n        \"\"\"\n        # Check if it's a direct attribute\n        if hasattr(self, key):\n            return getattr(self, key)\n\n        # Check if it's in plotting_data\n        if key in self.plotting_data:\n            return self.plotting_data[key]\n\n        raise KeyError(f\"Key '{key}' not found in results\")\n\n    def __setitem__(self, key: str, value: Any):\n        \"\"\"\n        Allow dictionary-style assignment to results.\n\n        Args:\n            key: The key to set\n            value: The value to assign\n        \"\"\"\n        # Check if it's a direct attribute\n        if hasattr(self, key):\n            setattr(self, key, value)\n        else:\n            # Store in plotting_data\n            self.plotting_data[key] = value\n\n    def __contains__(self, key: str) -&gt; bool:\n        \"\"\"\n        Check if a key exists in the results.\n\n        Args:\n            key: The key to check\n\n        Returns:\n            True if key exists, False otherwise\n        \"\"\"\n        return hasattr(self, key) or key in self.plotting_data\n\n    def update(self, other: dict[str, Any]):\n        \"\"\"\n        Update the results with additional data from a dictionary.\n\n        Args:\n            other: Dictionary containing additional data\n        \"\"\"\n        for key, value in other.items():\n            self[key] = value\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Convert the results to a dictionary for backward compatibility.\n\n        Returns:\n            Dictionary representation of the results\n        \"\"\"\n        result_dict = {}\n\n        # Add all direct attributes\n        for attr_name in self.__dataclass_fields__:\n            if attr_name != \"plotting_data\":\n                result_dict[attr_name] = getattr(self, attr_name)\n\n        # Add plotting data\n        result_dict.update(self.plotting_data)\n\n        return result_dict\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.OptimizationResults.u","title":"<code>u: np.ndarray</code>  <code>property</code>","text":"<p>Optimal control trajectory at discretization nodes.</p> <p>Returns the final converged solution from the SCP iteration history.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Control trajectory array, shape (N, n_controls)</p>"},{"location":"reference/algorithms/#openscvx.algorithms.OptimizationResults.x","title":"<code>x: np.ndarray</code>  <code>property</code>","text":"<p>Optimal state trajectory at discretization nodes.</p> <p>Returns the final converged solution from the SCP iteration history.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>State trajectory array, shape (N, n_states)</p>"},{"location":"reference/algorithms/#openscvx.algorithms.OptimizationResults.get","title":"<code>get(key: str, default: Any = None) -&gt; Any</code>","text":"<p>Get a value from the results, similar to dict.get().</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to look up</p> required <code>default</code> <code>Any</code> <p>Default value if key is not found</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The value associated with the key, or default if not found</p> Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"\n    Get a value from the results, similar to dict.get().\n\n    Args:\n        key: The key to look up\n        default: Default value if key is not found\n\n    Returns:\n        The value associated with the key, or default if not found\n    \"\"\"\n    # Check if it's a direct attribute\n    if hasattr(self, key):\n        return getattr(self, key)\n\n    # Check if it's in plotting_data\n    if key in self.plotting_data:\n        return self.plotting_data[key]\n\n    return default\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.OptimizationResults.to_dict","title":"<code>to_dict() -&gt; dict[str, Any]</code>","text":"<p>Convert the results to a dictionary for backward compatibility.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary representation of the results</p> Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the results to a dictionary for backward compatibility.\n\n    Returns:\n        Dictionary representation of the results\n    \"\"\"\n    result_dict = {}\n\n    # Add all direct attributes\n    for attr_name in self.__dataclass_fields__:\n        if attr_name != \"plotting_data\":\n            result_dict[attr_name] = getattr(self, attr_name)\n\n    # Add plotting data\n    result_dict.update(self.plotting_data)\n\n    return result_dict\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.OptimizationResults.update","title":"<code>update(other: dict[str, Any])</code>","text":"<p>Update the results with additional data from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>dict[str, Any]</code> <p>Dictionary containing additional data</p> required Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>def update(self, other: dict[str, Any]):\n    \"\"\"\n    Update the results with additional data from a dictionary.\n\n    Args:\n        other: Dictionary containing additional data\n    \"\"\"\n    for key, value in other.items():\n        self[key] = value\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.OptimizationResults.update_plotting_data","title":"<code>update_plotting_data(**kwargs)</code>","text":"<p>Update the plotting data with additional information.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Key-value pairs to add to plotting_data</p> <code>{}</code> Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>def update_plotting_data(self, **kwargs):\n    \"\"\"\n    Update the plotting data with additional information.\n\n    Args:\n        **kwargs: Key-value pairs to add to plotting_data\n    \"\"\"\n    self.plotting_data.update(kwargs)\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.PenalizedTrustRegion","title":"<code>PenalizedTrustRegion</code>","text":"<p>               Bases: <code>Algorithm</code></p> <p>Penalized Trust Region (PTR) successive convexification algorithm.</p> <p>PTR solves non-convex trajectory optimization problems through iterative convex approximation. Each subproblem balances competing cost terms:</p> <ul> <li>Trust region penalty: Discourages large deviations from the previous   iterate, keeping the solution within the region where linearization is valid.</li> <li>Virtual control: Relaxes dynamics constraints, penalized to drive   defects toward zero as the algorithm converges.</li> <li>Virtual buffer: Relaxes non-convex constraints, similarly penalized   to enforce feasibility at convergence.</li> <li>Problem objective and other terms: The user-defined cost (e.g., minimum   fuel, minimum time) and any additional penalty terms.</li> </ul> <p>The interplay between these terms guides the optimization: the trust region anchors the solution near the linearization point while virtual terms allow temporary constraint violations that shrink over iterations.</p> Example <p>Using PTR with a Problem::</p> <pre><code>from openscvx.algorithms import PenalizedTrustRegion\n\nproblem = Problem(dynamics, constraints, states, controls, N, time)\nproblem.initialize()\nresult = problem.solve()\n</code></pre> Source code in <code>openscvx/algorithms/penalized_trust_region.py</code> <pre><code>class PenalizedTrustRegion(Algorithm):\n    \"\"\"Penalized Trust Region (PTR) successive convexification algorithm.\n\n    PTR solves non-convex trajectory optimization problems through iterative\n    convex approximation. Each subproblem balances competing cost terms:\n\n    - **Trust region penalty**: Discourages large deviations from the previous\n      iterate, keeping the solution within the region where linearization is valid.\n    - **Virtual control**: Relaxes dynamics constraints, penalized to drive\n      defects toward zero as the algorithm converges.\n    - **Virtual buffer**: Relaxes non-convex constraints, similarly penalized\n      to enforce feasibility at convergence.\n    - **Problem objective and other terms**: The user-defined cost (e.g., minimum\n      fuel, minimum time) and any additional penalty terms.\n\n    The interplay between these terms guides the optimization: the trust region\n    anchors the solution near the linearization point while virtual terms allow\n    temporary constraint violations that shrink over iterations.\n\n    Example:\n        Using PTR with a Problem::\n\n            from openscvx.algorithms import PenalizedTrustRegion\n\n            problem = Problem(dynamics, constraints, states, controls, N, time)\n            problem.initialize()\n            result = problem.solve()\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize PTR with unset infrastructure.\n\n        Call initialize() before step() to set up compiled components.\n        \"\"\"\n        self._ocp: cp.Problem = None\n        self._discretization_solver: callable = None\n        self._jax_constraints: \"LoweredJaxConstraints\" = None\n        self._solve_ocp: callable = None\n        self._emitter: callable = None\n\n    def initialize(\n        self,\n        ocp: cp.Problem,\n        discretization_solver: callable,\n        jax_constraints: \"LoweredJaxConstraints\",\n        solve_ocp: callable,\n        emitter: callable,\n        params: dict,\n        settings: Config,\n    ) -&gt; None:\n        \"\"\"Initialize PTR algorithm.\n\n        Stores compiled infrastructure and performs a warm-start solve to\n        initialize DPP and JAX jacobians.\n\n        Args:\n            ocp: CVXPy optimal control problem\n            discretization_solver: Compiled discretization solver\n            jax_constraints: JIT-compiled constraint functions\n            solve_ocp: Callable that solves the OCP\n            emitter: Callback for emitting iteration progress\n            params: Problem parameters dictionary (for warm-start)\n            settings: Configuration object (for warm-start)\n        \"\"\"\n        # Store immutable infrastructure\n        self._ocp = ocp\n        self._discretization_solver = discretization_solver\n        self._jax_constraints = jax_constraints\n        self._solve_ocp = solve_ocp\n        self._emitter = emitter\n\n        if \"x_init\" in ocp.param_dict:\n            _set_param(ocp, \"x_init\", settings.sim.x.initial)\n\n        if \"x_term\" in ocp.param_dict:\n            _set_param(ocp, \"x_term\", settings.sim.x.final)\n\n        # Create temporary state for initialization solve\n        init_state = AlgorithmState.from_settings(settings)\n\n        # Solve a dumb problem to initialize DPP and JAX jacobians\n        _ = self._subproblem(params, init_state, settings)\n\n    def step(\n        self,\n        state: AlgorithmState,\n        params: dict,\n        settings: Config,\n    ) -&gt; bool:\n        \"\"\"Execute one PTR iteration.\n\n        Solves the convex subproblem, updates state in place, and checks\n        convergence based on trust region, virtual buffer, and virtual\n        control costs.\n\n        Args:\n            state: Mutable solver state (modified in place)\n            params: Problem parameters dictionary (may change between steps)\n            settings: Configuration object (may change between steps)\n\n        Returns:\n            True if J_tr, J_vb, and J_vc are all below their thresholds.\n\n        Raises:\n            RuntimeError: If initialize() has not been called.\n        \"\"\"\n        if self._ocp is None:\n            raise RuntimeError(\n                \"PenalizedTrustRegion.step() called before initialize(). \"\n                \"Call initialize() first to set up compiled infrastructure.\"\n            )\n\n        # Run the subproblem\n        (\n            x_sol,\n            u_sol,\n            cost,\n            J_total,\n            J_vb_vec,\n            J_vc_vec,\n            J_tr_vec,\n            prob_stat,\n            V_multi_shoot,\n            subprop_time,\n            dis_time,\n            vc_mat,\n            tr_mat,\n        ) = self._subproblem(params, state, settings)\n\n        # Update state in place by appending to history\n        # The x_guess/u_guess properties will automatically return the latest entry\n        state.V_history.append(V_multi_shoot)\n        state.X.append(x_sol)\n        state.U.append(u_sol)\n        state.VC_history.append(vc_mat)\n        state.TR_history.append(tr_mat)\n\n        state.J_tr = np.sum(np.array(J_tr_vec))\n        state.J_vb = np.sum(np.array(J_vb_vec))\n        state.J_vc = np.sum(np.array(J_vc_vec))\n\n        # Update weights in state\n        update_scp_weights(state, settings, state.k)\n\n        # Emit data\n        self._emitter(\n            {\n                \"iter\": state.k,\n                \"dis_time\": dis_time * 1000.0,\n                \"subprop_time\": subprop_time * 1000.0,\n                \"J_total\": J_total,\n                \"J_tr\": state.J_tr,\n                \"J_vb\": state.J_vb,\n                \"J_vc\": state.J_vc,\n                \"cost\": cost[-1],\n                \"prob_stat\": prob_stat,\n            }\n        )\n\n        # Increment iteration counter\n        state.k += 1\n\n        # Return convergence status\n        return (\n            (state.J_tr &lt; settings.scp.ep_tr)\n            and (state.J_vb &lt; settings.scp.ep_vb)\n            and (state.J_vc &lt; settings.scp.ep_vc)\n        )\n\n    def _subproblem(\n        self,\n        params: dict,\n        state: AlgorithmState,\n        settings: Config,\n    ):\n        \"\"\"Solve a single convex subproblem.\n\n        Uses stored infrastructure (ocp, discretization_solver, jax_constraints)\n        with per-step params and settings.\n\n        Args:\n            params: Problem parameters dictionary\n            state: Current solver state\n            settings: Configuration object\n\n        Returns:\n            Tuple containing solution data, costs, and timing information.\n        \"\"\"\n        _set_param(self._ocp, \"x_bar\", state.x)\n        _set_param(self._ocp, \"u_bar\", state.u)\n\n        param_dict = params\n\n        t0 = time.time()\n        A_bar, B_bar, C_bar, x_prop, V_multi_shoot = self._discretization_solver.call(\n            state.x, state.u.astype(float), param_dict\n        )\n\n        _set_param(self._ocp, \"A_d\", A_bar.__array__())\n        _set_param(self._ocp, \"B_d\", B_bar.__array__())\n        _set_param(self._ocp, \"C_d\", C_bar.__array__())\n        _set_param(self._ocp, \"x_prop\", x_prop.__array__())\n        dis_time = time.time() - t0\n\n        # Update nodal constraint linearization parameters\n        # TODO: (norrisg) investigate why we are passing `0` for the node here\n        if self._jax_constraints.nodal:\n            for g_id, constraint in enumerate(self._jax_constraints.nodal):\n                _set_param(\n                    self._ocp,\n                    f\"g_{g_id}\",\n                    np.asarray(constraint.func(state.x, state.u, 0, param_dict)),\n                )\n                _set_param(\n                    self._ocp,\n                    f\"grad_g_x_{g_id}\",\n                    np.asarray(constraint.grad_g_x(state.x, state.u, 0, param_dict)),\n                )\n                _set_param(\n                    self._ocp,\n                    f\"grad_g_u_{g_id}\",\n                    np.asarray(constraint.grad_g_u(state.x, state.u, 0, param_dict)),\n                )\n\n        # Update cross-node constraint linearization parameters\n        if self._jax_constraints.cross_node:\n            for g_id, constraint in enumerate(self._jax_constraints.cross_node):\n                # Cross-node constraints take (X, U, params) not (x, u, node, params)\n                _set_param(\n                    self._ocp,\n                    f\"g_cross_{g_id}\",\n                    np.asarray(constraint.func(state.x, state.u, param_dict)),\n                )\n                _set_param(\n                    self._ocp,\n                    f\"grad_g_X_cross_{g_id}\",\n                    np.asarray(constraint.grad_g_X(state.x, state.u, param_dict)),\n                )\n                _set_param(\n                    self._ocp,\n                    f\"grad_g_U_cross_{g_id}\",\n                    np.asarray(constraint.grad_g_U(state.x, state.u, param_dict)),\n                )\n\n        # Convex constraints are already lowered and handled in the OCP, no action needed here\n\n        # Initialize lam_vc as matrix if it's still a scalar in state\n        if isinstance(state.lam_vc, (int, float)):\n            # Convert scalar to matrix: (N-1, n_states)\n            state.lam_vc = np.ones((settings.scp.n - 1, settings.sim.n_states)) * state.lam_vc\n\n        # Update CVXPy parameters from state\n        _set_param(self._ocp, \"w_tr\", state.w_tr)\n        _set_param(self._ocp, \"lam_cost\", state.lam_cost)\n        _set_param(self._ocp, \"lam_vc\", state.lam_vc)\n        _set_param(self._ocp, \"lam_vb\", state.lam_vb)\n\n        t0 = time.time()\n        self._solve_ocp()\n        subprop_time = time.time() - t0\n\n        x_new_guess = (\n            settings.sim.S_x @ self._ocp.var_dict[\"x\"].value.T\n            + np.expand_dims(settings.sim.c_x, axis=1)\n        ).T\n        u_new_guess = (\n            settings.sim.S_u @ self._ocp.var_dict[\"u\"].value.T\n            + np.expand_dims(settings.sim.c_u, axis=1)\n        ).T\n\n        # Calculate costs from boundary conditions using utility function\n        # Note: The original code only considered final_type, but the utility handles both\n        # Here we maintain backward compatibility by only using final_type\n        costs = [0]\n        for i, bc_type in enumerate(settings.sim.x.final_type):\n            if bc_type == \"Minimize\":\n                costs += x_new_guess[:, i]\n            elif bc_type == \"Maximize\":\n                costs -= x_new_guess[:, i]\n\n        # Create the block diagonal matrix using jax.numpy.block\n        inv_block_diag = np.block(\n            [\n                [\n                    settings.sim.inv_S_x,\n                    np.zeros((settings.sim.inv_S_x.shape[0], settings.sim.inv_S_u.shape[1])),\n                ],\n                [\n                    np.zeros((settings.sim.inv_S_u.shape[0], settings.sim.inv_S_x.shape[1])),\n                    settings.sim.inv_S_u,\n                ],\n            ]\n        )\n\n        # Calculate J_tr_vec using the JAX-compatible block diagonal matrix\n        tr_mat = inv_block_diag @ np.hstack((x_new_guess - state.x, u_new_guess - state.u)).T\n        J_tr_vec = la.norm(tr_mat, axis=0) ** 2\n        vc_mat = np.abs(self._ocp.var_dict[\"nu\"].value)\n        J_vc_vec = np.sum(vc_mat, axis=1)\n\n        id_ncvx = 0\n        J_vb_vec = 0\n        if self._jax_constraints.nodal:\n            for constraint in self._jax_constraints.nodal:\n                J_vb_vec += np.maximum(0, self._ocp.var_dict[\"nu_vb_\" + str(id_ncvx)].value)\n                id_ncvx += 1\n\n        # Add cross-node constraint violations\n        id_cross = 0\n        if self._jax_constraints.cross_node:\n            for constraint in self._jax_constraints.cross_node:\n                J_vb_vec += np.maximum(0, self._ocp.var_dict[\"nu_vb_cross_\" + str(id_cross)].value)\n                id_cross += 1\n\n        # Convex constraints are already handled in the OCP, no processing needed here\n        return (\n            x_new_guess,\n            u_new_guess,\n            costs,\n            self._ocp.value,\n            J_vb_vec,\n            J_vc_vec,\n            J_tr_vec,\n            self._ocp.status,\n            V_multi_shoot,\n            subprop_time,\n            dis_time,\n            vc_mat,\n            abs(tr_mat),\n        )\n\n    def citation(self) -&gt; List[str]:\n        \"\"\"Return BibTeX citations for the PTR algorithm.\n\n        Returns:\n            List containing the BibTeX entry for the PTR paper.\n        \"\"\"\n        return [\n            r\"\"\"@article{drusvyatskiy2018error,\n  title={Error bounds, quadratic growth, and linear convergence of proximal methods},\n  author={Drusvyatskiy, Dmitriy and Lewis, Adrian S},\n  journal={Mathematics of operations research},\n  volume={43},\n  number={3},\n  pages={919--948},\n  year={2018},\n  publisher={INFORMS}\n}\"\"\",\n            r\"\"\"@article{szmuk2020successive,\n  title={Successive convexification for real-time six-degree-of-freedom powered descent guidance\n    with state-triggered constraints},\n  author={Szmuk, Michael and Reynolds, Taylor P and A{\\c{c}}{\\i}kme{\\c{s}}e, Beh{\\c{c}}et},\n  journal={Journal of Guidance, Control, and Dynamics},\n  volume={43},\n  number={8},\n  pages={1399--1413},\n  year={2020},\n  publisher={American Institute of Aeronautics and Astronautics}\n}\"\"\",\n            r\"\"\"@article{reynolds2020dual,\n  title={Dual quaternion-based powered descent guidance with state-triggered constraints},\n  author={Reynolds, Taylor P and Szmuk, Michael and Malyuta, Danylo and Mesbahi, Mehran and\n    A{\\c{c}}{\\i}kme{\\c{s}}e, Beh{\\c{c}}et and Carson III, John M},\n  journal={Journal of Guidance, Control, and Dynamics},\n  volume={43},\n  number={9},\n  pages={1584--1599},\n  year={2020},\n  publisher={American Institute of Aeronautics and Astronautics}\n}\"\"\",\n        ]\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.PenalizedTrustRegion.__init__","title":"<code>__init__()</code>","text":"<p>Initialize PTR with unset infrastructure.</p> <p>Call initialize() before step() to set up compiled components.</p> Source code in <code>openscvx/algorithms/penalized_trust_region.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize PTR with unset infrastructure.\n\n    Call initialize() before step() to set up compiled components.\n    \"\"\"\n    self._ocp: cp.Problem = None\n    self._discretization_solver: callable = None\n    self._jax_constraints: \"LoweredJaxConstraints\" = None\n    self._solve_ocp: callable = None\n    self._emitter: callable = None\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.PenalizedTrustRegion.citation","title":"<code>citation() -&gt; List[str]</code>","text":"<p>Return BibTeX citations for the PTR algorithm.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List containing the BibTeX entry for the PTR paper.</p> Source code in <code>openscvx/algorithms/penalized_trust_region.py</code> <pre><code>    def citation(self) -&gt; List[str]:\n        \"\"\"Return BibTeX citations for the PTR algorithm.\n\n        Returns:\n            List containing the BibTeX entry for the PTR paper.\n        \"\"\"\n        return [\n            r\"\"\"@article{drusvyatskiy2018error,\n  title={Error bounds, quadratic growth, and linear convergence of proximal methods},\n  author={Drusvyatskiy, Dmitriy and Lewis, Adrian S},\n  journal={Mathematics of operations research},\n  volume={43},\n  number={3},\n  pages={919--948},\n  year={2018},\n  publisher={INFORMS}\n}\"\"\",\n            r\"\"\"@article{szmuk2020successive,\n  title={Successive convexification for real-time six-degree-of-freedom powered descent guidance\n    with state-triggered constraints},\n  author={Szmuk, Michael and Reynolds, Taylor P and A{\\c{c}}{\\i}kme{\\c{s}}e, Beh{\\c{c}}et},\n  journal={Journal of Guidance, Control, and Dynamics},\n  volume={43},\n  number={8},\n  pages={1399--1413},\n  year={2020},\n  publisher={American Institute of Aeronautics and Astronautics}\n}\"\"\",\n            r\"\"\"@article{reynolds2020dual,\n  title={Dual quaternion-based powered descent guidance with state-triggered constraints},\n  author={Reynolds, Taylor P and Szmuk, Michael and Malyuta, Danylo and Mesbahi, Mehran and\n    A{\\c{c}}{\\i}kme{\\c{s}}e, Beh{\\c{c}}et and Carson III, John M},\n  journal={Journal of Guidance, Control, and Dynamics},\n  volume={43},\n  number={9},\n  pages={1584--1599},\n  year={2020},\n  publisher={American Institute of Aeronautics and Astronautics}\n}\"\"\",\n        ]\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.PenalizedTrustRegion.initialize","title":"<code>initialize(ocp: cp.Problem, discretization_solver: callable, jax_constraints: LoweredJaxConstraints, solve_ocp: callable, emitter: callable, params: dict, settings: Config) -&gt; None</code>","text":"<p>Initialize PTR algorithm.</p> <p>Stores compiled infrastructure and performs a warm-start solve to initialize DPP and JAX jacobians.</p> <p>Parameters:</p> Name Type Description Default <code>ocp</code> <code>Problem</code> <p>CVXPy optimal control problem</p> required <code>discretization_solver</code> <code>callable</code> <p>Compiled discretization solver</p> required <code>jax_constraints</code> <code>LoweredJaxConstraints</code> <p>JIT-compiled constraint functions</p> required <code>solve_ocp</code> <code>callable</code> <p>Callable that solves the OCP</p> required <code>emitter</code> <code>callable</code> <p>Callback for emitting iteration progress</p> required <code>params</code> <code>dict</code> <p>Problem parameters dictionary (for warm-start)</p> required <code>settings</code> <code>Config</code> <p>Configuration object (for warm-start)</p> required Source code in <code>openscvx/algorithms/penalized_trust_region.py</code> <pre><code>def initialize(\n    self,\n    ocp: cp.Problem,\n    discretization_solver: callable,\n    jax_constraints: \"LoweredJaxConstraints\",\n    solve_ocp: callable,\n    emitter: callable,\n    params: dict,\n    settings: Config,\n) -&gt; None:\n    \"\"\"Initialize PTR algorithm.\n\n    Stores compiled infrastructure and performs a warm-start solve to\n    initialize DPP and JAX jacobians.\n\n    Args:\n        ocp: CVXPy optimal control problem\n        discretization_solver: Compiled discretization solver\n        jax_constraints: JIT-compiled constraint functions\n        solve_ocp: Callable that solves the OCP\n        emitter: Callback for emitting iteration progress\n        params: Problem parameters dictionary (for warm-start)\n        settings: Configuration object (for warm-start)\n    \"\"\"\n    # Store immutable infrastructure\n    self._ocp = ocp\n    self._discretization_solver = discretization_solver\n    self._jax_constraints = jax_constraints\n    self._solve_ocp = solve_ocp\n    self._emitter = emitter\n\n    if \"x_init\" in ocp.param_dict:\n        _set_param(ocp, \"x_init\", settings.sim.x.initial)\n\n    if \"x_term\" in ocp.param_dict:\n        _set_param(ocp, \"x_term\", settings.sim.x.final)\n\n    # Create temporary state for initialization solve\n    init_state = AlgorithmState.from_settings(settings)\n\n    # Solve a dumb problem to initialize DPP and JAX jacobians\n    _ = self._subproblem(params, init_state, settings)\n</code></pre>"},{"location":"reference/algorithms/#openscvx.algorithms.PenalizedTrustRegion.step","title":"<code>step(state: AlgorithmState, params: dict, settings: Config) -&gt; bool</code>","text":"<p>Execute one PTR iteration.</p> <p>Solves the convex subproblem, updates state in place, and checks convergence based on trust region, virtual buffer, and virtual control costs.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>AlgorithmState</code> <p>Mutable solver state (modified in place)</p> required <code>params</code> <code>dict</code> <p>Problem parameters dictionary (may change between steps)</p> required <code>settings</code> <code>Config</code> <p>Configuration object (may change between steps)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if J_tr, J_vb, and J_vc are all below their thresholds.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If initialize() has not been called.</p> Source code in <code>openscvx/algorithms/penalized_trust_region.py</code> <pre><code>def step(\n    self,\n    state: AlgorithmState,\n    params: dict,\n    settings: Config,\n) -&gt; bool:\n    \"\"\"Execute one PTR iteration.\n\n    Solves the convex subproblem, updates state in place, and checks\n    convergence based on trust region, virtual buffer, and virtual\n    control costs.\n\n    Args:\n        state: Mutable solver state (modified in place)\n        params: Problem parameters dictionary (may change between steps)\n        settings: Configuration object (may change between steps)\n\n    Returns:\n        True if J_tr, J_vb, and J_vc are all below their thresholds.\n\n    Raises:\n        RuntimeError: If initialize() has not been called.\n    \"\"\"\n    if self._ocp is None:\n        raise RuntimeError(\n            \"PenalizedTrustRegion.step() called before initialize(). \"\n            \"Call initialize() first to set up compiled infrastructure.\"\n        )\n\n    # Run the subproblem\n    (\n        x_sol,\n        u_sol,\n        cost,\n        J_total,\n        J_vb_vec,\n        J_vc_vec,\n        J_tr_vec,\n        prob_stat,\n        V_multi_shoot,\n        subprop_time,\n        dis_time,\n        vc_mat,\n        tr_mat,\n    ) = self._subproblem(params, state, settings)\n\n    # Update state in place by appending to history\n    # The x_guess/u_guess properties will automatically return the latest entry\n    state.V_history.append(V_multi_shoot)\n    state.X.append(x_sol)\n    state.U.append(u_sol)\n    state.VC_history.append(vc_mat)\n    state.TR_history.append(tr_mat)\n\n    state.J_tr = np.sum(np.array(J_tr_vec))\n    state.J_vb = np.sum(np.array(J_vb_vec))\n    state.J_vc = np.sum(np.array(J_vc_vec))\n\n    # Update weights in state\n    update_scp_weights(state, settings, state.k)\n\n    # Emit data\n    self._emitter(\n        {\n            \"iter\": state.k,\n            \"dis_time\": dis_time * 1000.0,\n            \"subprop_time\": subprop_time * 1000.0,\n            \"J_total\": J_total,\n            \"J_tr\": state.J_tr,\n            \"J_vb\": state.J_vb,\n            \"J_vc\": state.J_vc,\n            \"cost\": cost[-1],\n            \"prob_stat\": prob_stat,\n        }\n    )\n\n    # Increment iteration counter\n    state.k += 1\n\n    # Return convergence status\n    return (\n        (state.J_tr &lt; settings.scp.ep_tr)\n        and (state.J_vb &lt; settings.scp.ep_vb)\n        and (state.J_vc &lt; settings.scp.ep_vc)\n    )\n</code></pre>"},{"location":"reference/algorithms/autotuning/","title":"autotuning","text":"<p>Autotuning functions for SCP (Successive Convex Programming) parameters.</p>"},{"location":"reference/algorithms/autotuning/#openscvx.algorithms.autotuning.update_scp_weights","title":"<code>update_scp_weights(state: AlgorithmState, settings: Config, scp_k: int)</code>","text":"<p>Update SCP weights and cost parameters based on iteration number.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>AlgorithmState</code> <p>Solver state containing current weight values (mutated in place)</p> required <code>settings</code> <code>Config</code> <p>Configuration object containing adaptation parameters</p> required <code>scp_k</code> <code>int</code> <p>Current SCP iteration number</p> required Source code in <code>openscvx/algorithms/autotuning.py</code> <pre><code>def update_scp_weights(state: \"AlgorithmState\", settings: Config, scp_k: int):\n    \"\"\"Update SCP weights and cost parameters based on iteration number.\n\n    Args:\n        state: Solver state containing current weight values (mutated in place)\n        settings: Configuration object containing adaptation parameters\n        scp_k: Current SCP iteration number\n    \"\"\"\n    # Update trust region weight in state\n    state.w_tr = min(state.w_tr * settings.scp.w_tr_adapt, settings.scp.w_tr_max)\n\n    # Update cost relaxation parameter after cost_drop iterations\n    if scp_k &gt; settings.scp.cost_drop:\n        state.lam_cost = state.lam_cost * settings.scp.cost_relax\n</code></pre>"},{"location":"reference/algorithms/base/","title":"base","text":"<p>Base class for successive convexification algorithms.</p> <p>This module defines the abstract interface that all SCP algorithm implementations must follow, along with the AlgorithmState dataclass that holds mutable state during SCP iterations.</p>"},{"location":"reference/algorithms/base/#openscvx.algorithms.base.Algorithm","title":"<code>Algorithm</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for successive convexification algorithms.</p> <p>This class defines the interface for SCP algorithms used in trajectory optimization. Implementations should remain minimal and functional, delegating state management to the AlgorithmState dataclass.</p> <p>The two core methods mirror the SCP workflow:</p> <ul> <li>initialize: Store compiled infrastructure and warm-start solvers</li> <li>step: Execute one convex subproblem iteration</li> </ul> <p>Immutable components (ocp, discretization_solver, jax_constraints, etc.) are stored during initialize(). Mutable configuration (params, settings) is passed per-step to support runtime parameter updates and tolerance tuning.</p> <p>Statefullness</p> <p>Avoid storing mutable iteration state (costs, weights, trajectories) on <code>self</code>. All iteration state should live in :class:<code>AlgorithmState</code> or a subclass thereof, passed explicitly to <code>step()</code>. This keeps algorithm classes stateless w.r.t. iteration, making data flow explicit and staying close to functional programming principles where possible.</p> Example <p>Implementing a custom algorithm::</p> <pre><code>class MyAlgorithm(Algorithm):\n    def initialize(self, ocp, discretization_solver,\n                   jax_constraints, solve_ocp, emitter,\n                   params, settings):\n        # Store compiled infrastructure\n        self._ocp = ocp\n        self._discretization_solver = discretization_solver\n        self._jax_constraints = jax_constraints\n        self._solve_ocp = solve_ocp\n        self._emitter = emitter\n        # Warm-start with initial params/settings...\n\n    def step(self, state, params, settings):\n        # Run one iteration using self._* and per-step params/settings\n        return converged\n</code></pre> Source code in <code>openscvx/algorithms/base.py</code> <pre><code>class Algorithm(ABC):\n    \"\"\"Abstract base class for successive convexification algorithms.\n\n    This class defines the interface for SCP algorithms used in trajectory\n    optimization. Implementations should remain minimal and functional,\n    delegating state management to the AlgorithmState dataclass.\n\n    The two core methods mirror the SCP workflow:\n\n    - initialize: Store compiled infrastructure and warm-start solvers\n    - step: Execute one convex subproblem iteration\n\n    Immutable components (ocp, discretization_solver, jax_constraints, etc.) are\n    stored during initialize(). Mutable configuration (params, settings) is passed\n    per-step to support runtime parameter updates and tolerance tuning.\n\n    !!! tip \"Statefullness\"\n        Avoid storing mutable iteration state (costs, weights, trajectories) on\n        ``self``. All iteration state should live in :class:`AlgorithmState` or\n        a subclass thereof, passed explicitly to ``step()``. This keeps algorithm\n        classes stateless w.r.t. iteration, making data flow explicit and staying\n        close to functional programming principles where possible.\n\n    Example:\n        Implementing a custom algorithm::\n\n            class MyAlgorithm(Algorithm):\n                def initialize(self, ocp, discretization_solver,\n                               jax_constraints, solve_ocp, emitter,\n                               params, settings):\n                    # Store compiled infrastructure\n                    self._ocp = ocp\n                    self._discretization_solver = discretization_solver\n                    self._jax_constraints = jax_constraints\n                    self._solve_ocp = solve_ocp\n                    self._emitter = emitter\n                    # Warm-start with initial params/settings...\n\n                def step(self, state, params, settings):\n                    # Run one iteration using self._* and per-step params/settings\n                    return converged\n    \"\"\"\n\n    @abstractmethod\n    def initialize(\n        self,\n        ocp: \"cp.Problem\",\n        discretization_solver: callable,\n        jax_constraints: \"LoweredJaxConstraints\",\n        solve_ocp: callable,\n        emitter: callable,\n        params: dict,\n        settings: \"Config\",\n    ) -&gt; None:\n        \"\"\"Initialize the algorithm and store compiled infrastructure.\n\n        This method stores immutable components and performs any setup required\n        before the SCP loop begins (e.g., warm-starting solvers). The params and\n        settings are passed for warm-start but may change between steps.\n\n        Args:\n            ocp: The CVXPy optimal control problem\n            discretization_solver: Compiled discretization solver function\n            jax_constraints: JIT-compiled JAX constraint functions\n            solve_ocp: Callable that solves the OCP (captures solver config)\n            emitter: Callback for emitting iteration progress data\n            params: Problem parameters dictionary (for warm-start only)\n            settings: Configuration object (for warm-start only)\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def step(\n        self,\n        state: AlgorithmState,\n        params: dict,\n        settings: \"Config\",\n    ) -&gt; bool:\n        \"\"\"Execute one iteration of the SCP algorithm.\n\n        This method solves a single convex subproblem, updates the algorithm\n        state in place, and returns whether convergence criteria are met.\n\n        Uses stored infrastructure (ocp, discretization_solver, etc.) with\n        per-step params and settings to support runtime modifications.\n\n        Args:\n            state: Mutable algorithm state (modified in place)\n            params: Problem parameters dictionary (may change between steps)\n            settings: Configuration object (may change between steps)\n\n        Returns:\n            True if convergence criteria are satisfied, False otherwise.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def citation(self) -&gt; List[str]:\n        \"\"\"Return BibTeX citations for this algorithm.\n\n        Implementations should return a list of BibTeX entry strings for the\n        papers that should be cited when using this algorithm.\n\n        Returns:\n            List of BibTeX citation strings.\n\n        Example:\n            Getting citations for an algorithm::\n\n                algorithm = PenalizedTrustRegion()\n                for bibtex in algorithm.citation():\n                    print(bibtex)\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/algorithms/base/#openscvx.algorithms.base.Algorithm.citation","title":"<code>citation() -&gt; List[str]</code>  <code>abstractmethod</code>","text":"<p>Return BibTeX citations for this algorithm.</p> <p>Implementations should return a list of BibTeX entry strings for the papers that should be cited when using this algorithm.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of BibTeX citation strings.</p> Example <p>Getting citations for an algorithm::</p> <pre><code>algorithm = PenalizedTrustRegion()\nfor bibtex in algorithm.citation():\n    print(bibtex)\n</code></pre> Source code in <code>openscvx/algorithms/base.py</code> <pre><code>@abstractmethod\ndef citation(self) -&gt; List[str]:\n    \"\"\"Return BibTeX citations for this algorithm.\n\n    Implementations should return a list of BibTeX entry strings for the\n    papers that should be cited when using this algorithm.\n\n    Returns:\n        List of BibTeX citation strings.\n\n    Example:\n        Getting citations for an algorithm::\n\n            algorithm = PenalizedTrustRegion()\n            for bibtex in algorithm.citation():\n                print(bibtex)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/algorithms/base/#openscvx.algorithms.base.Algorithm.initialize","title":"<code>initialize(ocp: cp.Problem, discretization_solver: callable, jax_constraints: LoweredJaxConstraints, solve_ocp: callable, emitter: callable, params: dict, settings: Config) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Initialize the algorithm and store compiled infrastructure.</p> <p>This method stores immutable components and performs any setup required before the SCP loop begins (e.g., warm-starting solvers). The params and settings are passed for warm-start but may change between steps.</p> <p>Parameters:</p> Name Type Description Default <code>ocp</code> <code>Problem</code> <p>The CVXPy optimal control problem</p> required <code>discretization_solver</code> <code>callable</code> <p>Compiled discretization solver function</p> required <code>jax_constraints</code> <code>LoweredJaxConstraints</code> <p>JIT-compiled JAX constraint functions</p> required <code>solve_ocp</code> <code>callable</code> <p>Callable that solves the OCP (captures solver config)</p> required <code>emitter</code> <code>callable</code> <p>Callback for emitting iteration progress data</p> required <code>params</code> <code>dict</code> <p>Problem parameters dictionary (for warm-start only)</p> required <code>settings</code> <code>Config</code> <p>Configuration object (for warm-start only)</p> required Source code in <code>openscvx/algorithms/base.py</code> <pre><code>@abstractmethod\ndef initialize(\n    self,\n    ocp: \"cp.Problem\",\n    discretization_solver: callable,\n    jax_constraints: \"LoweredJaxConstraints\",\n    solve_ocp: callable,\n    emitter: callable,\n    params: dict,\n    settings: \"Config\",\n) -&gt; None:\n    \"\"\"Initialize the algorithm and store compiled infrastructure.\n\n    This method stores immutable components and performs any setup required\n    before the SCP loop begins (e.g., warm-starting solvers). The params and\n    settings are passed for warm-start but may change between steps.\n\n    Args:\n        ocp: The CVXPy optimal control problem\n        discretization_solver: Compiled discretization solver function\n        jax_constraints: JIT-compiled JAX constraint functions\n        solve_ocp: Callable that solves the OCP (captures solver config)\n        emitter: Callback for emitting iteration progress data\n        params: Problem parameters dictionary (for warm-start only)\n        settings: Configuration object (for warm-start only)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/algorithms/base/#openscvx.algorithms.base.Algorithm.step","title":"<code>step(state: AlgorithmState, params: dict, settings: Config) -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Execute one iteration of the SCP algorithm.</p> <p>This method solves a single convex subproblem, updates the algorithm state in place, and returns whether convergence criteria are met.</p> <p>Uses stored infrastructure (ocp, discretization_solver, etc.) with per-step params and settings to support runtime modifications.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>AlgorithmState</code> <p>Mutable algorithm state (modified in place)</p> required <code>params</code> <code>dict</code> <p>Problem parameters dictionary (may change between steps)</p> required <code>settings</code> <code>Config</code> <p>Configuration object (may change between steps)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if convergence criteria are satisfied, False otherwise.</p> Source code in <code>openscvx/algorithms/base.py</code> <pre><code>@abstractmethod\ndef step(\n    self,\n    state: AlgorithmState,\n    params: dict,\n    settings: \"Config\",\n) -&gt; bool:\n    \"\"\"Execute one iteration of the SCP algorithm.\n\n    This method solves a single convex subproblem, updates the algorithm\n    state in place, and returns whether convergence criteria are met.\n\n    Uses stored infrastructure (ocp, discretization_solver, etc.) with\n    per-step params and settings to support runtime modifications.\n\n    Args:\n        state: Mutable algorithm state (modified in place)\n        params: Problem parameters dictionary (may change between steps)\n        settings: Configuration object (may change between steps)\n\n    Returns:\n        True if convergence criteria are satisfied, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/algorithms/base/#openscvx.algorithms.base.AlgorithmState","title":"<code>AlgorithmState</code>  <code>dataclass</code>","text":"<p>Mutable state for SCP iterations.</p> <p>This dataclass holds all state that changes during the solve process. It stores only the evolving trajectory arrays, not the full State/Control objects which contain immutable configuration metadata.</p> <p>Trajectory arrays are stored in history lists, with the current guess accessed via properties that return the latest entry.</p> <p>A fresh instance is created for each solve, enabling easy reset functionality.</p> <p>Attributes:</p> Name Type Description <code>k</code> <code>int</code> <p>Current iteration number (starts at 1)</p> <code>J_tr</code> <code>float</code> <p>Current trust region cost</p> <code>J_vb</code> <code>float</code> <p>Current virtual buffer cost</p> <code>J_vc</code> <code>float</code> <p>Current virtual control cost</p> <code>w_tr</code> <code>float</code> <p>Current trust region weight (may adapt during solve)</p> <code>lam_cost</code> <code>float</code> <p>Current cost weight (may relax during solve)</p> <code>lam_vc</code> <code>Union[float, ndarray]</code> <p>Current virtual control penalty weight</p> <code>lam_vb</code> <code>float</code> <p>Current virtual buffer penalty weight</p> <code>n_x</code> <code>int</code> <p>Number of states (for unpacking V vectors)</p> <code>n_u</code> <code>int</code> <p>Number of controls (for unpacking V vectors)</p> <code>N</code> <code>int</code> <p>Number of trajectory nodes (for unpacking V vectors)</p> <code>X</code> <code>List[ndarray]</code> <p>List of state trajectory iterates</p> <code>U</code> <code>List[ndarray]</code> <p>List of control trajectory iterates</p> <code>V_history</code> <code>List[ndarray]</code> <p>List of discretization history</p> Source code in <code>openscvx/algorithms/base.py</code> <pre><code>@dataclass\nclass AlgorithmState:\n    \"\"\"Mutable state for SCP iterations.\n\n    This dataclass holds all state that changes during the solve process.\n    It stores only the evolving trajectory arrays, not the full State/Control\n    objects which contain immutable configuration metadata.\n\n    Trajectory arrays are stored in history lists, with the current guess\n    accessed via properties that return the latest entry.\n\n    A fresh instance is created for each solve, enabling easy reset functionality.\n\n    Attributes:\n        k: Current iteration number (starts at 1)\n        J_tr: Current trust region cost\n        J_vb: Current virtual buffer cost\n        J_vc: Current virtual control cost\n        w_tr: Current trust region weight (may adapt during solve)\n        lam_cost: Current cost weight (may relax during solve)\n        lam_vc: Current virtual control penalty weight\n        lam_vb: Current virtual buffer penalty weight\n        n_x: Number of states (for unpacking V vectors)\n        n_u: Number of controls (for unpacking V vectors)\n        N: Number of trajectory nodes (for unpacking V vectors)\n        X: List of state trajectory iterates\n        U: List of control trajectory iterates\n        V_history: List of discretization history\n    \"\"\"\n\n    k: int\n    J_tr: float\n    J_vb: float\n    J_vc: float\n    w_tr: float\n    lam_cost: float\n    lam_vc: Union[float, np.ndarray]\n    lam_vb: float\n    n_x: int\n    n_u: int\n    N: int\n    X: List[np.ndarray] = field(default_factory=list)\n    U: List[np.ndarray] = field(default_factory=list)\n    V_history: List[np.ndarray] = field(default_factory=list)\n    VC_history: List[np.ndarray] = field(default_factory=list)\n    TR_history: List[np.ndarray] = field(default_factory=list)\n\n    @property\n    def x(self) -&gt; np.ndarray:\n        \"\"\"Get current state trajectory array.\n\n        Returns:\n            Current state trajectory guess (latest entry in history), shape (N, n_states)\n        \"\"\"\n        return self.X[-1]\n\n    @property\n    def u(self) -&gt; np.ndarray:\n        \"\"\"Get current control trajectory array.\n\n        Returns:\n            Current control trajectory guess (latest entry in history), shape (N, n_controls)\n        \"\"\"\n        return self.U[-1]\n\n    @property\n    def x_prop(self) -&gt; np.ndarray:\n        \"\"\"Extract propagated state trajectory from latest V.\n\n        Returns:\n            Propagated state trajectory x_prop with shape (N-1, n_x), or None if no V_history\n\n        Example:\n            After running an iteration, access the propagated states::\n\n                problem.step()\n                x_prop = problem.state.x_prop  # Shape (N-1, n_x)\n        \"\"\"\n        if not self.V_history:\n            return None\n\n        # V_history contains Vmulti from discretization\n        # Shape: (flattened_size, n_timesteps) where flattened_size = (N-1) * i4\n        V = self.V_history[-1]\n\n        # Take final timestep and reshape to (N-1, i4)\n        i4 = self.n_x + self.n_x * self.n_x + 2 * self.n_x * self.n_u\n        V_final = V[:, -1].reshape(-1, i4)\n\n        # Extract propagated state (first n_x elements of each row)\n        return V_final[:, : self.n_x]\n\n    @property\n    def A_d(self) -&gt; np.ndarray:\n        \"\"\"Extract discretized state transition matrix from latest V.\n\n        Returns:\n            Discretized state Jacobian A_d with shape (N-1, n_x, n_x), or None if no V_history\n\n        Example:\n            After running an iteration, access linearization matrices::\n\n                problem.step()\n                A_d = problem.state.A_d  # Shape (N-1, n_x, n_x)\n        \"\"\"\n        if not self.V_history:\n            return None\n\n        # Extract indices for unpacking V vector\n        i1 = self.n_x\n        i2 = i1 + self.n_x * self.n_x\n\n        # V_history contains Vmulti from discretization\n        # Shape: (flattened_size, n_timesteps) where flattened_size = (N-1) * i4\n        V = self.V_history[-1]\n\n        # Take final timestep and reshape to (N-1, i4)\n        i4 = self.n_x + self.n_x * self.n_x + 2 * self.n_x * self.n_u\n        V_final = V[:, -1].reshape(-1, i4)\n\n        # Extract and reshape A_d matrix\n        return V_final[:, i1:i2].reshape(self.N - 1, self.n_x, self.n_x)\n\n    @property\n    def B_d(self) -&gt; np.ndarray:\n        \"\"\"Extract discretized control influence matrix (current node) from latest V.\n\n        Returns:\n            Discretized control Jacobian B_d with shape (N-1, n_x, n_u), or None if no V_history\n\n        Example:\n            After running an iteration, access linearization matrices::\n\n                problem.step()\n                B_d = problem.state.B_d  # Shape (N-1, n_x, n_u)\n        \"\"\"\n        if not self.V_history:\n            return None\n\n        # Extract indices for unpacking V vector\n        i1 = self.n_x\n        i2 = i1 + self.n_x * self.n_x\n        i3 = i2 + self.n_x * self.n_u\n\n        # V_history contains Vmulti from discretization\n        V = self.V_history[-1]\n\n        # Take final timestep and reshape to (N-1, i4)\n        i4 = self.n_x + self.n_x * self.n_x + 2 * self.n_x * self.n_u\n        V_final = V[:, -1].reshape(-1, i4)\n\n        # Extract and reshape B_d matrix\n        return V_final[:, i2:i3].reshape(self.N - 1, self.n_x, self.n_u)\n\n    @property\n    def C_d(self) -&gt; np.ndarray:\n        \"\"\"Extract discretized control influence matrix (next node) from latest V.\n\n        Returns:\n            Discretized control Jacobian C_d with shape (N-1, n_x, n_u), or None if no V_history\n\n        Example:\n            After running an iteration, access linearization matrices::\n\n                problem.step()\n                C_d = problem.state.C_d  # Shape (N-1, n_x, n_u)\n        \"\"\"\n        if not self.V_history:\n            return None\n\n        # Extract indices for unpacking V vector\n        i2 = self.n_x + self.n_x * self.n_x\n        i3 = i2 + self.n_x * self.n_u\n        i4 = i3 + self.n_x * self.n_u\n\n        # V_history contains Vmulti from discretization\n        V = self.V_history[-1]\n\n        # Take final timestep and reshape to (N-1, i4)\n        V_final = V[:, -1].reshape(-1, i4)\n\n        # Extract and reshape C_d matrix\n        return V_final[:, i3:i4].reshape(self.N - 1, self.n_x, self.n_u)\n\n    @classmethod\n    def from_settings(cls, settings: \"Config\") -&gt; \"AlgorithmState\":\n        \"\"\"Create initial algorithm state from configuration.\n\n        Copies only the trajectory arrays from settings, leaving all metadata\n        (bounds, boundary conditions, etc.) in the original settings object.\n\n        Args:\n            settings: Configuration object containing initial guesses and SCP parameters\n\n        Returns:\n            Fresh AlgorithmState initialized from settings with copied arrays\n        \"\"\"\n        return cls(\n            k=1,\n            J_tr=1e2,\n            J_vb=1e2,\n            J_vc=1e2,\n            w_tr=settings.scp.w_tr,\n            lam_cost=settings.scp.lam_cost,\n            lam_vc=settings.scp.lam_vc,\n            lam_vb=settings.scp.lam_vb,\n            n_x=settings.sim.n_states,\n            n_u=settings.sim.n_controls,\n            N=settings.scp.n,\n            X=[settings.sim.x.guess.copy()],\n            U=[settings.sim.u.guess.copy()],\n            V_history=[],\n            VC_history=[],\n            TR_history=[],\n        )\n</code></pre>"},{"location":"reference/algorithms/base/#openscvx.algorithms.base.AlgorithmState.A_d","title":"<code>A_d: np.ndarray</code>  <code>property</code>","text":"<p>Extract discretized state transition matrix from latest V.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Discretized state Jacobian A_d with shape (N-1, n_x, n_x), or None if no V_history</p> Example <p>After running an iteration, access linearization matrices::</p> <pre><code>problem.step()\nA_d = problem.state.A_d  # Shape (N-1, n_x, n_x)\n</code></pre>"},{"location":"reference/algorithms/base/#openscvx.algorithms.base.AlgorithmState.B_d","title":"<code>B_d: np.ndarray</code>  <code>property</code>","text":"<p>Extract discretized control influence matrix (current node) from latest V.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Discretized control Jacobian B_d with shape (N-1, n_x, n_u), or None if no V_history</p> Example <p>After running an iteration, access linearization matrices::</p> <pre><code>problem.step()\nB_d = problem.state.B_d  # Shape (N-1, n_x, n_u)\n</code></pre>"},{"location":"reference/algorithms/base/#openscvx.algorithms.base.AlgorithmState.C_d","title":"<code>C_d: np.ndarray</code>  <code>property</code>","text":"<p>Extract discretized control influence matrix (next node) from latest V.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Discretized control Jacobian C_d with shape (N-1, n_x, n_u), or None if no V_history</p> Example <p>After running an iteration, access linearization matrices::</p> <pre><code>problem.step()\nC_d = problem.state.C_d  # Shape (N-1, n_x, n_u)\n</code></pre>"},{"location":"reference/algorithms/base/#openscvx.algorithms.base.AlgorithmState.u","title":"<code>u: np.ndarray</code>  <code>property</code>","text":"<p>Get current control trajectory array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Current control trajectory guess (latest entry in history), shape (N, n_controls)</p>"},{"location":"reference/algorithms/base/#openscvx.algorithms.base.AlgorithmState.x","title":"<code>x: np.ndarray</code>  <code>property</code>","text":"<p>Get current state trajectory array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Current state trajectory guess (latest entry in history), shape (N, n_states)</p>"},{"location":"reference/algorithms/base/#openscvx.algorithms.base.AlgorithmState.x_prop","title":"<code>x_prop: np.ndarray</code>  <code>property</code>","text":"<p>Extract propagated state trajectory from latest V.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Propagated state trajectory x_prop with shape (N-1, n_x), or None if no V_history</p> Example <p>After running an iteration, access the propagated states::</p> <pre><code>problem.step()\nx_prop = problem.state.x_prop  # Shape (N-1, n_x)\n</code></pre>"},{"location":"reference/algorithms/base/#openscvx.algorithms.base.AlgorithmState.from_settings","title":"<code>from_settings(settings: Config) -&gt; AlgorithmState</code>  <code>classmethod</code>","text":"<p>Create initial algorithm state from configuration.</p> <p>Copies only the trajectory arrays from settings, leaving all metadata (bounds, boundary conditions, etc.) in the original settings object.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Config</code> <p>Configuration object containing initial guesses and SCP parameters</p> required <p>Returns:</p> Type Description <code>AlgorithmState</code> <p>Fresh AlgorithmState initialized from settings with copied arrays</p> Source code in <code>openscvx/algorithms/base.py</code> <pre><code>@classmethod\ndef from_settings(cls, settings: \"Config\") -&gt; \"AlgorithmState\":\n    \"\"\"Create initial algorithm state from configuration.\n\n    Copies only the trajectory arrays from settings, leaving all metadata\n    (bounds, boundary conditions, etc.) in the original settings object.\n\n    Args:\n        settings: Configuration object containing initial guesses and SCP parameters\n\n    Returns:\n        Fresh AlgorithmState initialized from settings with copied arrays\n    \"\"\"\n    return cls(\n        k=1,\n        J_tr=1e2,\n        J_vb=1e2,\n        J_vc=1e2,\n        w_tr=settings.scp.w_tr,\n        lam_cost=settings.scp.lam_cost,\n        lam_vc=settings.scp.lam_vc,\n        lam_vb=settings.scp.lam_vb,\n        n_x=settings.sim.n_states,\n        n_u=settings.sim.n_controls,\n        N=settings.scp.n,\n        X=[settings.sim.x.guess.copy()],\n        U=[settings.sim.u.guess.copy()],\n        V_history=[],\n        VC_history=[],\n        TR_history=[],\n    )\n</code></pre>"},{"location":"reference/algorithms/optimization_results/","title":"optimization_results","text":""},{"location":"reference/algorithms/optimization_results/#openscvx.algorithms.optimization_results.OptimizationResults","title":"<code>OptimizationResults</code>  <code>dataclass</code>","text":"<p>Structured container for optimization results from the Successive Convexification (SCP) solver.</p> <p>This class provides a type-safe and organized way to store and access optimization results, replacing the previous dictionary-based approach. It includes core optimization data, iteration history for convergence analysis, post-processing results, and flexible storage for plotting and application-specific data.</p> <p>Attributes:</p> Name Type Description <code>converged</code> <code>bool</code> <p>Whether the optimization successfully converged</p> <code>t_final</code> <code>float</code> <p>Final time of the optimized trajectory</p> <code>x_guess</code> <code>ndarray</code> <p>Optimized state trajectory at discretization nodes, shape (N, n_states)</p> <code>u_guess</code> <code>ndarray</code> <p>Optimized control trajectory at discretization nodes, shape (N, n_controls)</p> <code>nodes</code> <code>dict[str, ndarray]</code> <p>Dictionary mapping state/control names to arrays at optimization nodes. Includes both user-defined and augmented variables.</p> <code>trajectory</code> <code>dict[str, ndarray]</code> <p>Dictionary mapping state/control names to arrays along the propagated trajectory. Added by post_process().</p> <code>x_history</code> <code>list[ndarray]</code> <p>State trajectories from each SCP iteration</p> <code>u_history</code> <code>list[ndarray]</code> <p>Control trajectories from each SCP iteration</p> <code>discretization_history</code> <code>list[ndarray]</code> <p>Time discretization from each iteration</p> <code>J_tr_history</code> <code>list[ndarray]</code> <p>Trust region cost history</p> <code>J_vb_history</code> <code>list[ndarray]</code> <p>Virtual buffer cost history</p> <code>J_vc_history</code> <code>list[ndarray]</code> <p>Virtual control cost history</p> <code>t_full</code> <code>Optional[ndarray]</code> <p>Full time grid for interpolated trajectory</p> <code>x_full</code> <code>Optional[ndarray]</code> <p>Interpolated state trajectory on full time grid</p> <code>u_full</code> <code>Optional[ndarray]</code> <p>Interpolated control trajectory on full time grid</p> <code>cost</code> <code>Optional[float]</code> <p>Total cost of the optimized trajectory</p> <code>ctcs_violation</code> <code>Optional[ndarray]</code> <p>Continuous-time constraint violations</p> <code>plotting_data</code> <code>dict[str, Any]</code> <p>Flexible storage for plotting and application data</p> Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>@dataclass\nclass OptimizationResults:\n    \"\"\"\n    Structured container for optimization results from the Successive Convexification (SCP) solver.\n\n    This class provides a type-safe and organized way to store and access optimization results,\n    replacing the previous dictionary-based approach. It includes core optimization data,\n    iteration history for convergence analysis, post-processing results, and flexible\n    storage for plotting and application-specific data.\n\n    Attributes:\n        converged (bool): Whether the optimization successfully converged\n        t_final (float): Final time of the optimized trajectory\n        x_guess (np.ndarray): Optimized state trajectory at discretization nodes,\n            shape (N, n_states)\n        u_guess (np.ndarray): Optimized control trajectory at discretization nodes,\n            shape (N, n_controls)\n\n        # Dictionary-based Access\n        nodes (dict[str, np.ndarray]): Dictionary mapping state/control names to arrays\n            at optimization nodes. Includes both user-defined and augmented variables.\n        trajectory (dict[str, np.ndarray]): Dictionary mapping state/control names to arrays\n            along the propagated trajectory. Added by post_process().\n\n        # SCP Iteration History (for convergence analysis)\n        x_history (list[np.ndarray]): State trajectories from each SCP iteration\n        u_history (list[np.ndarray]): Control trajectories from each SCP iteration\n        discretization_history (list[np.ndarray]): Time discretization from each iteration\n        J_tr_history (list[np.ndarray]): Trust region cost history\n        J_vb_history (list[np.ndarray]): Virtual buffer cost history\n        J_vc_history (list[np.ndarray]): Virtual control cost history\n\n        # Post-processing Results (added by propagate_trajectory_results)\n        t_full (Optional[np.ndarray]): Full time grid for interpolated trajectory\n        x_full (Optional[np.ndarray]): Interpolated state trajectory on full time grid\n        u_full (Optional[np.ndarray]): Interpolated control trajectory on full time grid\n        cost (Optional[float]): Total cost of the optimized trajectory\n        ctcs_violation (Optional[np.ndarray]): Continuous-time constraint violations\n\n        # User-defined Data\n        plotting_data (dict[str, Any]): Flexible storage for plotting and application data\n    \"\"\"\n\n    # Core optimization results\n    converged: bool\n    t_final: float\n\n    # Dictionary-based access to states and controls\n    nodes: dict[str, np.ndarray] = field(default_factory=dict)\n    trajectory: dict[str, np.ndarray] = field(default_factory=dict)\n\n    # Internal metadata for dictionary construction\n    _states: list = field(default_factory=list, repr=False)\n    _controls: list = field(default_factory=list, repr=False)\n\n    # History of SCP iterations (single source of truth)\n    X: list[np.ndarray] = field(default_factory=list)\n    U: list[np.ndarray] = field(default_factory=list)\n    discretization_history: list[np.ndarray] = field(default_factory=list)\n    J_tr_history: list[np.ndarray] = field(default_factory=list)\n    J_vb_history: list[np.ndarray] = field(default_factory=list)\n    J_vc_history: list[np.ndarray] = field(default_factory=list)\n    TR_history: list[np.ndarray] = field(default_factory=list)\n    VC_history: list[np.ndarray] = field(default_factory=list)\n\n    @property\n    def x(self) -&gt; np.ndarray:\n        \"\"\"Optimal state trajectory at discretization nodes.\n\n        Returns the final converged solution from the SCP iteration history.\n\n        Returns:\n            State trajectory array, shape (N, n_states)\n        \"\"\"\n        return self.X[-1]\n\n    @property\n    def u(self) -&gt; np.ndarray:\n        \"\"\"Optimal control trajectory at discretization nodes.\n\n        Returns the final converged solution from the SCP iteration history.\n\n        Returns:\n            Control trajectory array, shape (N, n_controls)\n        \"\"\"\n        return self.U[-1]\n\n    # Post-processing results (added by propagate_trajectory_results)\n    t_full: Optional[np.ndarray] = None\n    x_full: Optional[np.ndarray] = None\n    u_full: Optional[np.ndarray] = None\n    cost: Optional[float] = None\n    ctcs_violation: Optional[np.ndarray] = None\n\n    # Additional plotting/application data (added by user)\n    plotting_data: dict[str, Any] = field(default_factory=dict)\n\n    def __post_init__(self):\n        \"\"\"Initialize the results object.\"\"\"\n        pass\n\n    def update_plotting_data(self, **kwargs):\n        \"\"\"\n        Update the plotting data with additional information.\n\n        Args:\n            **kwargs: Key-value pairs to add to plotting_data\n        \"\"\"\n        self.plotting_data.update(kwargs)\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"\n        Get a value from the results, similar to dict.get().\n\n        Args:\n            key: The key to look up\n            default: Default value if key is not found\n\n        Returns:\n            The value associated with the key, or default if not found\n        \"\"\"\n        # Check if it's a direct attribute\n        if hasattr(self, key):\n            return getattr(self, key)\n\n        # Check if it's in plotting_data\n        if key in self.plotting_data:\n            return self.plotting_data[key]\n\n        return default\n\n    def __getitem__(self, key: str) -&gt; Any:\n        \"\"\"\n        Allow dictionary-style access to results.\n\n        Args:\n            key: The key to look up\n\n        Returns:\n            The value associated with the key\n\n        Raises:\n            KeyError: If key is not found\n        \"\"\"\n        # Check if it's a direct attribute\n        if hasattr(self, key):\n            return getattr(self, key)\n\n        # Check if it's in plotting_data\n        if key in self.plotting_data:\n            return self.plotting_data[key]\n\n        raise KeyError(f\"Key '{key}' not found in results\")\n\n    def __setitem__(self, key: str, value: Any):\n        \"\"\"\n        Allow dictionary-style assignment to results.\n\n        Args:\n            key: The key to set\n            value: The value to assign\n        \"\"\"\n        # Check if it's a direct attribute\n        if hasattr(self, key):\n            setattr(self, key, value)\n        else:\n            # Store in plotting_data\n            self.plotting_data[key] = value\n\n    def __contains__(self, key: str) -&gt; bool:\n        \"\"\"\n        Check if a key exists in the results.\n\n        Args:\n            key: The key to check\n\n        Returns:\n            True if key exists, False otherwise\n        \"\"\"\n        return hasattr(self, key) or key in self.plotting_data\n\n    def update(self, other: dict[str, Any]):\n        \"\"\"\n        Update the results with additional data from a dictionary.\n\n        Args:\n            other: Dictionary containing additional data\n        \"\"\"\n        for key, value in other.items():\n            self[key] = value\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Convert the results to a dictionary for backward compatibility.\n\n        Returns:\n            Dictionary representation of the results\n        \"\"\"\n        result_dict = {}\n\n        # Add all direct attributes\n        for attr_name in self.__dataclass_fields__:\n            if attr_name != \"plotting_data\":\n                result_dict[attr_name] = getattr(self, attr_name)\n\n        # Add plotting data\n        result_dict.update(self.plotting_data)\n\n        return result_dict\n</code></pre>"},{"location":"reference/algorithms/optimization_results/#openscvx.algorithms.optimization_results.OptimizationResults.u","title":"<code>u: np.ndarray</code>  <code>property</code>","text":"<p>Optimal control trajectory at discretization nodes.</p> <p>Returns the final converged solution from the SCP iteration history.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Control trajectory array, shape (N, n_controls)</p>"},{"location":"reference/algorithms/optimization_results/#openscvx.algorithms.optimization_results.OptimizationResults.x","title":"<code>x: np.ndarray</code>  <code>property</code>","text":"<p>Optimal state trajectory at discretization nodes.</p> <p>Returns the final converged solution from the SCP iteration history.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>State trajectory array, shape (N, n_states)</p>"},{"location":"reference/algorithms/optimization_results/#openscvx.algorithms.optimization_results.OptimizationResults.get","title":"<code>get(key: str, default: Any = None) -&gt; Any</code>","text":"<p>Get a value from the results, similar to dict.get().</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to look up</p> required <code>default</code> <code>Any</code> <p>Default value if key is not found</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The value associated with the key, or default if not found</p> Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"\n    Get a value from the results, similar to dict.get().\n\n    Args:\n        key: The key to look up\n        default: Default value if key is not found\n\n    Returns:\n        The value associated with the key, or default if not found\n    \"\"\"\n    # Check if it's a direct attribute\n    if hasattr(self, key):\n        return getattr(self, key)\n\n    # Check if it's in plotting_data\n    if key in self.plotting_data:\n        return self.plotting_data[key]\n\n    return default\n</code></pre>"},{"location":"reference/algorithms/optimization_results/#openscvx.algorithms.optimization_results.OptimizationResults.to_dict","title":"<code>to_dict() -&gt; dict[str, Any]</code>","text":"<p>Convert the results to a dictionary for backward compatibility.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary representation of the results</p> Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the results to a dictionary for backward compatibility.\n\n    Returns:\n        Dictionary representation of the results\n    \"\"\"\n    result_dict = {}\n\n    # Add all direct attributes\n    for attr_name in self.__dataclass_fields__:\n        if attr_name != \"plotting_data\":\n            result_dict[attr_name] = getattr(self, attr_name)\n\n    # Add plotting data\n    result_dict.update(self.plotting_data)\n\n    return result_dict\n</code></pre>"},{"location":"reference/algorithms/optimization_results/#openscvx.algorithms.optimization_results.OptimizationResults.update","title":"<code>update(other: dict[str, Any])</code>","text":"<p>Update the results with additional data from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>dict[str, Any]</code> <p>Dictionary containing additional data</p> required Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>def update(self, other: dict[str, Any]):\n    \"\"\"\n    Update the results with additional data from a dictionary.\n\n    Args:\n        other: Dictionary containing additional data\n    \"\"\"\n    for key, value in other.items():\n        self[key] = value\n</code></pre>"},{"location":"reference/algorithms/optimization_results/#openscvx.algorithms.optimization_results.OptimizationResults.update_plotting_data","title":"<code>update_plotting_data(**kwargs)</code>","text":"<p>Update the plotting data with additional information.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Key-value pairs to add to plotting_data</p> <code>{}</code> Source code in <code>openscvx/algorithms/optimization_results.py</code> <pre><code>def update_plotting_data(self, **kwargs):\n    \"\"\"\n    Update the plotting data with additional information.\n\n    Args:\n        **kwargs: Key-value pairs to add to plotting_data\n    \"\"\"\n    self.plotting_data.update(kwargs)\n</code></pre>"},{"location":"reference/algorithms/penalized_trust_region/","title":"penalized_trust_region","text":"<p>Penalized Trust Region (PTR) successive convexification algorithm.</p> <p>This module implements the PTR algorithm for solving non-convex trajectory optimization problems through iterative convex approximation.</p>"},{"location":"reference/algorithms/penalized_trust_region/#openscvx.algorithms.penalized_trust_region.PenalizedTrustRegion","title":"<code>PenalizedTrustRegion</code>","text":"<p>               Bases: <code>Algorithm</code></p> <p>Penalized Trust Region (PTR) successive convexification algorithm.</p> <p>PTR solves non-convex trajectory optimization problems through iterative convex approximation. Each subproblem balances competing cost terms:</p> <ul> <li>Trust region penalty: Discourages large deviations from the previous   iterate, keeping the solution within the region where linearization is valid.</li> <li>Virtual control: Relaxes dynamics constraints, penalized to drive   defects toward zero as the algorithm converges.</li> <li>Virtual buffer: Relaxes non-convex constraints, similarly penalized   to enforce feasibility at convergence.</li> <li>Problem objective and other terms: The user-defined cost (e.g., minimum   fuel, minimum time) and any additional penalty terms.</li> </ul> <p>The interplay between these terms guides the optimization: the trust region anchors the solution near the linearization point while virtual terms allow temporary constraint violations that shrink over iterations.</p> Example <p>Using PTR with a Problem::</p> <pre><code>from openscvx.algorithms import PenalizedTrustRegion\n\nproblem = Problem(dynamics, constraints, states, controls, N, time)\nproblem.initialize()\nresult = problem.solve()\n</code></pre> Source code in <code>openscvx/algorithms/penalized_trust_region.py</code> <pre><code>class PenalizedTrustRegion(Algorithm):\n    \"\"\"Penalized Trust Region (PTR) successive convexification algorithm.\n\n    PTR solves non-convex trajectory optimization problems through iterative\n    convex approximation. Each subproblem balances competing cost terms:\n\n    - **Trust region penalty**: Discourages large deviations from the previous\n      iterate, keeping the solution within the region where linearization is valid.\n    - **Virtual control**: Relaxes dynamics constraints, penalized to drive\n      defects toward zero as the algorithm converges.\n    - **Virtual buffer**: Relaxes non-convex constraints, similarly penalized\n      to enforce feasibility at convergence.\n    - **Problem objective and other terms**: The user-defined cost (e.g., minimum\n      fuel, minimum time) and any additional penalty terms.\n\n    The interplay between these terms guides the optimization: the trust region\n    anchors the solution near the linearization point while virtual terms allow\n    temporary constraint violations that shrink over iterations.\n\n    Example:\n        Using PTR with a Problem::\n\n            from openscvx.algorithms import PenalizedTrustRegion\n\n            problem = Problem(dynamics, constraints, states, controls, N, time)\n            problem.initialize()\n            result = problem.solve()\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize PTR with unset infrastructure.\n\n        Call initialize() before step() to set up compiled components.\n        \"\"\"\n        self._ocp: cp.Problem = None\n        self._discretization_solver: callable = None\n        self._jax_constraints: \"LoweredJaxConstraints\" = None\n        self._solve_ocp: callable = None\n        self._emitter: callable = None\n\n    def initialize(\n        self,\n        ocp: cp.Problem,\n        discretization_solver: callable,\n        jax_constraints: \"LoweredJaxConstraints\",\n        solve_ocp: callable,\n        emitter: callable,\n        params: dict,\n        settings: Config,\n    ) -&gt; None:\n        \"\"\"Initialize PTR algorithm.\n\n        Stores compiled infrastructure and performs a warm-start solve to\n        initialize DPP and JAX jacobians.\n\n        Args:\n            ocp: CVXPy optimal control problem\n            discretization_solver: Compiled discretization solver\n            jax_constraints: JIT-compiled constraint functions\n            solve_ocp: Callable that solves the OCP\n            emitter: Callback for emitting iteration progress\n            params: Problem parameters dictionary (for warm-start)\n            settings: Configuration object (for warm-start)\n        \"\"\"\n        # Store immutable infrastructure\n        self._ocp = ocp\n        self._discretization_solver = discretization_solver\n        self._jax_constraints = jax_constraints\n        self._solve_ocp = solve_ocp\n        self._emitter = emitter\n\n        if \"x_init\" in ocp.param_dict:\n            _set_param(ocp, \"x_init\", settings.sim.x.initial)\n\n        if \"x_term\" in ocp.param_dict:\n            _set_param(ocp, \"x_term\", settings.sim.x.final)\n\n        # Create temporary state for initialization solve\n        init_state = AlgorithmState.from_settings(settings)\n\n        # Solve a dumb problem to initialize DPP and JAX jacobians\n        _ = self._subproblem(params, init_state, settings)\n\n    def step(\n        self,\n        state: AlgorithmState,\n        params: dict,\n        settings: Config,\n    ) -&gt; bool:\n        \"\"\"Execute one PTR iteration.\n\n        Solves the convex subproblem, updates state in place, and checks\n        convergence based on trust region, virtual buffer, and virtual\n        control costs.\n\n        Args:\n            state: Mutable solver state (modified in place)\n            params: Problem parameters dictionary (may change between steps)\n            settings: Configuration object (may change between steps)\n\n        Returns:\n            True if J_tr, J_vb, and J_vc are all below their thresholds.\n\n        Raises:\n            RuntimeError: If initialize() has not been called.\n        \"\"\"\n        if self._ocp is None:\n            raise RuntimeError(\n                \"PenalizedTrustRegion.step() called before initialize(). \"\n                \"Call initialize() first to set up compiled infrastructure.\"\n            )\n\n        # Run the subproblem\n        (\n            x_sol,\n            u_sol,\n            cost,\n            J_total,\n            J_vb_vec,\n            J_vc_vec,\n            J_tr_vec,\n            prob_stat,\n            V_multi_shoot,\n            subprop_time,\n            dis_time,\n            vc_mat,\n            tr_mat,\n        ) = self._subproblem(params, state, settings)\n\n        # Update state in place by appending to history\n        # The x_guess/u_guess properties will automatically return the latest entry\n        state.V_history.append(V_multi_shoot)\n        state.X.append(x_sol)\n        state.U.append(u_sol)\n        state.VC_history.append(vc_mat)\n        state.TR_history.append(tr_mat)\n\n        state.J_tr = np.sum(np.array(J_tr_vec))\n        state.J_vb = np.sum(np.array(J_vb_vec))\n        state.J_vc = np.sum(np.array(J_vc_vec))\n\n        # Update weights in state\n        update_scp_weights(state, settings, state.k)\n\n        # Emit data\n        self._emitter(\n            {\n                \"iter\": state.k,\n                \"dis_time\": dis_time * 1000.0,\n                \"subprop_time\": subprop_time * 1000.0,\n                \"J_total\": J_total,\n                \"J_tr\": state.J_tr,\n                \"J_vb\": state.J_vb,\n                \"J_vc\": state.J_vc,\n                \"cost\": cost[-1],\n                \"prob_stat\": prob_stat,\n            }\n        )\n\n        # Increment iteration counter\n        state.k += 1\n\n        # Return convergence status\n        return (\n            (state.J_tr &lt; settings.scp.ep_tr)\n            and (state.J_vb &lt; settings.scp.ep_vb)\n            and (state.J_vc &lt; settings.scp.ep_vc)\n        )\n\n    def _subproblem(\n        self,\n        params: dict,\n        state: AlgorithmState,\n        settings: Config,\n    ):\n        \"\"\"Solve a single convex subproblem.\n\n        Uses stored infrastructure (ocp, discretization_solver, jax_constraints)\n        with per-step params and settings.\n\n        Args:\n            params: Problem parameters dictionary\n            state: Current solver state\n            settings: Configuration object\n\n        Returns:\n            Tuple containing solution data, costs, and timing information.\n        \"\"\"\n        _set_param(self._ocp, \"x_bar\", state.x)\n        _set_param(self._ocp, \"u_bar\", state.u)\n\n        param_dict = params\n\n        t0 = time.time()\n        A_bar, B_bar, C_bar, x_prop, V_multi_shoot = self._discretization_solver.call(\n            state.x, state.u.astype(float), param_dict\n        )\n\n        _set_param(self._ocp, \"A_d\", A_bar.__array__())\n        _set_param(self._ocp, \"B_d\", B_bar.__array__())\n        _set_param(self._ocp, \"C_d\", C_bar.__array__())\n        _set_param(self._ocp, \"x_prop\", x_prop.__array__())\n        dis_time = time.time() - t0\n\n        # Update nodal constraint linearization parameters\n        # TODO: (norrisg) investigate why we are passing `0` for the node here\n        if self._jax_constraints.nodal:\n            for g_id, constraint in enumerate(self._jax_constraints.nodal):\n                _set_param(\n                    self._ocp,\n                    f\"g_{g_id}\",\n                    np.asarray(constraint.func(state.x, state.u, 0, param_dict)),\n                )\n                _set_param(\n                    self._ocp,\n                    f\"grad_g_x_{g_id}\",\n                    np.asarray(constraint.grad_g_x(state.x, state.u, 0, param_dict)),\n                )\n                _set_param(\n                    self._ocp,\n                    f\"grad_g_u_{g_id}\",\n                    np.asarray(constraint.grad_g_u(state.x, state.u, 0, param_dict)),\n                )\n\n        # Update cross-node constraint linearization parameters\n        if self._jax_constraints.cross_node:\n            for g_id, constraint in enumerate(self._jax_constraints.cross_node):\n                # Cross-node constraints take (X, U, params) not (x, u, node, params)\n                _set_param(\n                    self._ocp,\n                    f\"g_cross_{g_id}\",\n                    np.asarray(constraint.func(state.x, state.u, param_dict)),\n                )\n                _set_param(\n                    self._ocp,\n                    f\"grad_g_X_cross_{g_id}\",\n                    np.asarray(constraint.grad_g_X(state.x, state.u, param_dict)),\n                )\n                _set_param(\n                    self._ocp,\n                    f\"grad_g_U_cross_{g_id}\",\n                    np.asarray(constraint.grad_g_U(state.x, state.u, param_dict)),\n                )\n\n        # Convex constraints are already lowered and handled in the OCP, no action needed here\n\n        # Initialize lam_vc as matrix if it's still a scalar in state\n        if isinstance(state.lam_vc, (int, float)):\n            # Convert scalar to matrix: (N-1, n_states)\n            state.lam_vc = np.ones((settings.scp.n - 1, settings.sim.n_states)) * state.lam_vc\n\n        # Update CVXPy parameters from state\n        _set_param(self._ocp, \"w_tr\", state.w_tr)\n        _set_param(self._ocp, \"lam_cost\", state.lam_cost)\n        _set_param(self._ocp, \"lam_vc\", state.lam_vc)\n        _set_param(self._ocp, \"lam_vb\", state.lam_vb)\n\n        t0 = time.time()\n        self._solve_ocp()\n        subprop_time = time.time() - t0\n\n        x_new_guess = (\n            settings.sim.S_x @ self._ocp.var_dict[\"x\"].value.T\n            + np.expand_dims(settings.sim.c_x, axis=1)\n        ).T\n        u_new_guess = (\n            settings.sim.S_u @ self._ocp.var_dict[\"u\"].value.T\n            + np.expand_dims(settings.sim.c_u, axis=1)\n        ).T\n\n        # Calculate costs from boundary conditions using utility function\n        # Note: The original code only considered final_type, but the utility handles both\n        # Here we maintain backward compatibility by only using final_type\n        costs = [0]\n        for i, bc_type in enumerate(settings.sim.x.final_type):\n            if bc_type == \"Minimize\":\n                costs += x_new_guess[:, i]\n            elif bc_type == \"Maximize\":\n                costs -= x_new_guess[:, i]\n\n        # Create the block diagonal matrix using jax.numpy.block\n        inv_block_diag = np.block(\n            [\n                [\n                    settings.sim.inv_S_x,\n                    np.zeros((settings.sim.inv_S_x.shape[0], settings.sim.inv_S_u.shape[1])),\n                ],\n                [\n                    np.zeros((settings.sim.inv_S_u.shape[0], settings.sim.inv_S_x.shape[1])),\n                    settings.sim.inv_S_u,\n                ],\n            ]\n        )\n\n        # Calculate J_tr_vec using the JAX-compatible block diagonal matrix\n        tr_mat = inv_block_diag @ np.hstack((x_new_guess - state.x, u_new_guess - state.u)).T\n        J_tr_vec = la.norm(tr_mat, axis=0) ** 2\n        vc_mat = np.abs(self._ocp.var_dict[\"nu\"].value)\n        J_vc_vec = np.sum(vc_mat, axis=1)\n\n        id_ncvx = 0\n        J_vb_vec = 0\n        if self._jax_constraints.nodal:\n            for constraint in self._jax_constraints.nodal:\n                J_vb_vec += np.maximum(0, self._ocp.var_dict[\"nu_vb_\" + str(id_ncvx)].value)\n                id_ncvx += 1\n\n        # Add cross-node constraint violations\n        id_cross = 0\n        if self._jax_constraints.cross_node:\n            for constraint in self._jax_constraints.cross_node:\n                J_vb_vec += np.maximum(0, self._ocp.var_dict[\"nu_vb_cross_\" + str(id_cross)].value)\n                id_cross += 1\n\n        # Convex constraints are already handled in the OCP, no processing needed here\n        return (\n            x_new_guess,\n            u_new_guess,\n            costs,\n            self._ocp.value,\n            J_vb_vec,\n            J_vc_vec,\n            J_tr_vec,\n            self._ocp.status,\n            V_multi_shoot,\n            subprop_time,\n            dis_time,\n            vc_mat,\n            abs(tr_mat),\n        )\n\n    def citation(self) -&gt; List[str]:\n        \"\"\"Return BibTeX citations for the PTR algorithm.\n\n        Returns:\n            List containing the BibTeX entry for the PTR paper.\n        \"\"\"\n        return [\n            r\"\"\"@article{drusvyatskiy2018error,\n  title={Error bounds, quadratic growth, and linear convergence of proximal methods},\n  author={Drusvyatskiy, Dmitriy and Lewis, Adrian S},\n  journal={Mathematics of operations research},\n  volume={43},\n  number={3},\n  pages={919--948},\n  year={2018},\n  publisher={INFORMS}\n}\"\"\",\n            r\"\"\"@article{szmuk2020successive,\n  title={Successive convexification for real-time six-degree-of-freedom powered descent guidance\n    with state-triggered constraints},\n  author={Szmuk, Michael and Reynolds, Taylor P and A{\\c{c}}{\\i}kme{\\c{s}}e, Beh{\\c{c}}et},\n  journal={Journal of Guidance, Control, and Dynamics},\n  volume={43},\n  number={8},\n  pages={1399--1413},\n  year={2020},\n  publisher={American Institute of Aeronautics and Astronautics}\n}\"\"\",\n            r\"\"\"@article{reynolds2020dual,\n  title={Dual quaternion-based powered descent guidance with state-triggered constraints},\n  author={Reynolds, Taylor P and Szmuk, Michael and Malyuta, Danylo and Mesbahi, Mehran and\n    A{\\c{c}}{\\i}kme{\\c{s}}e, Beh{\\c{c}}et and Carson III, John M},\n  journal={Journal of Guidance, Control, and Dynamics},\n  volume={43},\n  number={9},\n  pages={1584--1599},\n  year={2020},\n  publisher={American Institute of Aeronautics and Astronautics}\n}\"\"\",\n        ]\n</code></pre>"},{"location":"reference/algorithms/penalized_trust_region/#openscvx.algorithms.penalized_trust_region.PenalizedTrustRegion.__init__","title":"<code>__init__()</code>","text":"<p>Initialize PTR with unset infrastructure.</p> <p>Call initialize() before step() to set up compiled components.</p> Source code in <code>openscvx/algorithms/penalized_trust_region.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize PTR with unset infrastructure.\n\n    Call initialize() before step() to set up compiled components.\n    \"\"\"\n    self._ocp: cp.Problem = None\n    self._discretization_solver: callable = None\n    self._jax_constraints: \"LoweredJaxConstraints\" = None\n    self._solve_ocp: callable = None\n    self._emitter: callable = None\n</code></pre>"},{"location":"reference/algorithms/penalized_trust_region/#openscvx.algorithms.penalized_trust_region.PenalizedTrustRegion.citation","title":"<code>citation() -&gt; List[str]</code>","text":"<p>Return BibTeX citations for the PTR algorithm.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List containing the BibTeX entry for the PTR paper.</p> Source code in <code>openscvx/algorithms/penalized_trust_region.py</code> <pre><code>    def citation(self) -&gt; List[str]:\n        \"\"\"Return BibTeX citations for the PTR algorithm.\n\n        Returns:\n            List containing the BibTeX entry for the PTR paper.\n        \"\"\"\n        return [\n            r\"\"\"@article{drusvyatskiy2018error,\n  title={Error bounds, quadratic growth, and linear convergence of proximal methods},\n  author={Drusvyatskiy, Dmitriy and Lewis, Adrian S},\n  journal={Mathematics of operations research},\n  volume={43},\n  number={3},\n  pages={919--948},\n  year={2018},\n  publisher={INFORMS}\n}\"\"\",\n            r\"\"\"@article{szmuk2020successive,\n  title={Successive convexification for real-time six-degree-of-freedom powered descent guidance\n    with state-triggered constraints},\n  author={Szmuk, Michael and Reynolds, Taylor P and A{\\c{c}}{\\i}kme{\\c{s}}e, Beh{\\c{c}}et},\n  journal={Journal of Guidance, Control, and Dynamics},\n  volume={43},\n  number={8},\n  pages={1399--1413},\n  year={2020},\n  publisher={American Institute of Aeronautics and Astronautics}\n}\"\"\",\n            r\"\"\"@article{reynolds2020dual,\n  title={Dual quaternion-based powered descent guidance with state-triggered constraints},\n  author={Reynolds, Taylor P and Szmuk, Michael and Malyuta, Danylo and Mesbahi, Mehran and\n    A{\\c{c}}{\\i}kme{\\c{s}}e, Beh{\\c{c}}et and Carson III, John M},\n  journal={Journal of Guidance, Control, and Dynamics},\n  volume={43},\n  number={9},\n  pages={1584--1599},\n  year={2020},\n  publisher={American Institute of Aeronautics and Astronautics}\n}\"\"\",\n        ]\n</code></pre>"},{"location":"reference/algorithms/penalized_trust_region/#openscvx.algorithms.penalized_trust_region.PenalizedTrustRegion.initialize","title":"<code>initialize(ocp: cp.Problem, discretization_solver: callable, jax_constraints: LoweredJaxConstraints, solve_ocp: callable, emitter: callable, params: dict, settings: Config) -&gt; None</code>","text":"<p>Initialize PTR algorithm.</p> <p>Stores compiled infrastructure and performs a warm-start solve to initialize DPP and JAX jacobians.</p> <p>Parameters:</p> Name Type Description Default <code>ocp</code> <code>Problem</code> <p>CVXPy optimal control problem</p> required <code>discretization_solver</code> <code>callable</code> <p>Compiled discretization solver</p> required <code>jax_constraints</code> <code>LoweredJaxConstraints</code> <p>JIT-compiled constraint functions</p> required <code>solve_ocp</code> <code>callable</code> <p>Callable that solves the OCP</p> required <code>emitter</code> <code>callable</code> <p>Callback for emitting iteration progress</p> required <code>params</code> <code>dict</code> <p>Problem parameters dictionary (for warm-start)</p> required <code>settings</code> <code>Config</code> <p>Configuration object (for warm-start)</p> required Source code in <code>openscvx/algorithms/penalized_trust_region.py</code> <pre><code>def initialize(\n    self,\n    ocp: cp.Problem,\n    discretization_solver: callable,\n    jax_constraints: \"LoweredJaxConstraints\",\n    solve_ocp: callable,\n    emitter: callable,\n    params: dict,\n    settings: Config,\n) -&gt; None:\n    \"\"\"Initialize PTR algorithm.\n\n    Stores compiled infrastructure and performs a warm-start solve to\n    initialize DPP and JAX jacobians.\n\n    Args:\n        ocp: CVXPy optimal control problem\n        discretization_solver: Compiled discretization solver\n        jax_constraints: JIT-compiled constraint functions\n        solve_ocp: Callable that solves the OCP\n        emitter: Callback for emitting iteration progress\n        params: Problem parameters dictionary (for warm-start)\n        settings: Configuration object (for warm-start)\n    \"\"\"\n    # Store immutable infrastructure\n    self._ocp = ocp\n    self._discretization_solver = discretization_solver\n    self._jax_constraints = jax_constraints\n    self._solve_ocp = solve_ocp\n    self._emitter = emitter\n\n    if \"x_init\" in ocp.param_dict:\n        _set_param(ocp, \"x_init\", settings.sim.x.initial)\n\n    if \"x_term\" in ocp.param_dict:\n        _set_param(ocp, \"x_term\", settings.sim.x.final)\n\n    # Create temporary state for initialization solve\n    init_state = AlgorithmState.from_settings(settings)\n\n    # Solve a dumb problem to initialize DPP and JAX jacobians\n    _ = self._subproblem(params, init_state, settings)\n</code></pre>"},{"location":"reference/algorithms/penalized_trust_region/#openscvx.algorithms.penalized_trust_region.PenalizedTrustRegion.step","title":"<code>step(state: AlgorithmState, params: dict, settings: Config) -&gt; bool</code>","text":"<p>Execute one PTR iteration.</p> <p>Solves the convex subproblem, updates state in place, and checks convergence based on trust region, virtual buffer, and virtual control costs.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>AlgorithmState</code> <p>Mutable solver state (modified in place)</p> required <code>params</code> <code>dict</code> <p>Problem parameters dictionary (may change between steps)</p> required <code>settings</code> <code>Config</code> <p>Configuration object (may change between steps)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if J_tr, J_vb, and J_vc are all below their thresholds.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If initialize() has not been called.</p> Source code in <code>openscvx/algorithms/penalized_trust_region.py</code> <pre><code>def step(\n    self,\n    state: AlgorithmState,\n    params: dict,\n    settings: Config,\n) -&gt; bool:\n    \"\"\"Execute one PTR iteration.\n\n    Solves the convex subproblem, updates state in place, and checks\n    convergence based on trust region, virtual buffer, and virtual\n    control costs.\n\n    Args:\n        state: Mutable solver state (modified in place)\n        params: Problem parameters dictionary (may change between steps)\n        settings: Configuration object (may change between steps)\n\n    Returns:\n        True if J_tr, J_vb, and J_vc are all below their thresholds.\n\n    Raises:\n        RuntimeError: If initialize() has not been called.\n    \"\"\"\n    if self._ocp is None:\n        raise RuntimeError(\n            \"PenalizedTrustRegion.step() called before initialize(). \"\n            \"Call initialize() first to set up compiled infrastructure.\"\n        )\n\n    # Run the subproblem\n    (\n        x_sol,\n        u_sol,\n        cost,\n        J_total,\n        J_vb_vec,\n        J_vc_vec,\n        J_tr_vec,\n        prob_stat,\n        V_multi_shoot,\n        subprop_time,\n        dis_time,\n        vc_mat,\n        tr_mat,\n    ) = self._subproblem(params, state, settings)\n\n    # Update state in place by appending to history\n    # The x_guess/u_guess properties will automatically return the latest entry\n    state.V_history.append(V_multi_shoot)\n    state.X.append(x_sol)\n    state.U.append(u_sol)\n    state.VC_history.append(vc_mat)\n    state.TR_history.append(tr_mat)\n\n    state.J_tr = np.sum(np.array(J_tr_vec))\n    state.J_vb = np.sum(np.array(J_vb_vec))\n    state.J_vc = np.sum(np.array(J_vc_vec))\n\n    # Update weights in state\n    update_scp_weights(state, settings, state.k)\n\n    # Emit data\n    self._emitter(\n        {\n            \"iter\": state.k,\n            \"dis_time\": dis_time * 1000.0,\n            \"subprop_time\": subprop_time * 1000.0,\n            \"J_total\": J_total,\n            \"J_tr\": state.J_tr,\n            \"J_vb\": state.J_vb,\n            \"J_vc\": state.J_vc,\n            \"cost\": cost[-1],\n            \"prob_stat\": prob_stat,\n        }\n    )\n\n    # Increment iteration counter\n    state.k += 1\n\n    # Return convergence status\n    return (\n        (state.J_tr &lt; settings.scp.ep_tr)\n        and (state.J_vb &lt; settings.scp.ep_vb)\n        and (state.J_vc &lt; settings.scp.ep_vc)\n    )\n</code></pre>"},{"location":"reference/discretization/","title":"discretization","text":"<p>Discretization methods for trajectory optimization.</p> <p>This module provides implementations of discretization schemes that convert continuous-time optimal control problems into discrete-time approximations suitable for numerical optimization. Discretization is a critical step in trajectory optimization that linearizes the nonlinear dynamics around a reference trajectory.</p> <p>Planned Architecture (ABC-based):</p> <p>A base class will be introduced to enable pluggable discretization methods. This will enable users to implement custom discretization methods. Future discretizers will implement the Discretizer interface:</p> <pre><code># discretization/base.py (planned):\nclass Discretizer(ABC):\n    def __init__(self, integrator: Integrator):\n        '''Initialize with a numerical integrator.'''\n        self.integrator = integrator\n\n    @abstractmethod\n    def discretize(self, dynamics, x, u, dt) -&gt; tuple[A_d, B_d, C_d]:\n        '''Discretize continuous dynamics around trajectory (x, u).\n\n        Args:\n            dynamics: Continuous-time dynamics object\n            x: State trajectory\n            u: Control trajectory\n            dt: Time step\n\n        Returns:\n            A_d: Discretized state transition matrix\n            B_d: Discretized control influence matrix (current node)\n            C_d: Discretized control influence matrix (next node)\n        '''\n        ...\n</code></pre>"},{"location":"reference/discretization/#openscvx.discretization.calculate_discretization","title":"<code>calculate_discretization(x, u, state_dot: callable, A: callable, B: callable, settings: Config, params: dict)</code>","text":"<p>Calculate the discretized system matrices.</p> <p>This function computes the discretized system matrices (A_bar, B_bar, C_bar) and defect vector (z_bar) using numerical integration.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>State trajectory.</p> required <code>u</code> <p>Control trajectory.</p> required <code>state_dot</code> <code>callable</code> <p>Function computing state derivatives.</p> required <code>A</code> <code>callable</code> <p>Function computing state Jacobian.</p> required <code>B</code> <code>callable</code> <p>Function computing control Jacobian.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings for OpenSCvx.</p> required <code>custom_integrator</code> <code>bool</code> <p>Whether to use custom RK45 integrator.</p> required <code>debug</code> <code>bool</code> <p>Whether to use debug mode.</p> required <code>solver</code> <code>str</code> <p>Name of the solver to use.</p> required <code>rtol</code> <code>float</code> <p>Relative tolerance for integration.</p> required <code>atol</code> <code>float</code> <p>Absolute tolerance for integration.</p> required <code>dis_type</code> <code>str</code> <p>Discretization type (\"ZOH\" or \"FOH\").</p> required <code>**kwargs</code> <p>Additional parameters passed to state_dot, A, and B.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(A_bar, B_bar, C_bar, z_bar, Vmulti) where: - A_bar: Discretized state transition matrix - B_bar: Discretized control influence matrix - C_bar: Discretized control influence matrix for next node - z_bar: Defect vector - Vmulti: Full augmented state trajectory</p> Source code in <code>openscvx/discretization/discretization.py</code> <pre><code>def calculate_discretization(\n    x,\n    u,\n    state_dot: callable,\n    A: callable,\n    B: callable,\n    settings: Config,\n    params: dict,\n):\n    \"\"\"Calculate the discretized system matrices.\n\n    This function computes the discretized system matrices (A_bar, B_bar, C_bar)\n    and defect vector (z_bar) using numerical integration.\n\n    Args:\n        x: State trajectory.\n        u: Control trajectory.\n        state_dot (callable): Function computing state derivatives.\n        A (callable): Function computing state Jacobian.\n        B (callable): Function computing control Jacobian.\n        settings: Configuration settings for OpenSCvx.\n        custom_integrator (bool): Whether to use custom RK45 integrator.\n        debug (bool): Whether to use debug mode.\n        solver (str): Name of the solver to use.\n        rtol (float): Relative tolerance for integration.\n        atol (float): Absolute tolerance for integration.\n        dis_type (str): Discretization type (\"ZOH\" or \"FOH\").\n        **kwargs: Additional parameters passed to state_dot, A, and B.\n\n    Returns:\n        tuple: (A_bar, B_bar, C_bar, z_bar, Vmulti) where:\n            - A_bar: Discretized state transition matrix\n            - B_bar: Discretized control influence matrix\n            - C_bar: Discretized control influence matrix for next node\n            - z_bar: Defect vector\n            - Vmulti: Full augmented state trajectory\n    \"\"\"\n    # Unpack settings\n    n_x = settings.sim.n_states\n    n_u = settings.sim.n_controls\n\n    N = settings.scp.n\n\n    # Define indices for slicing the augmented state vector\n    i0 = 0\n    i1 = n_x\n    i2 = i1 + n_x * n_x\n    i3 = i2 + n_x * n_u\n    i4 = i3 + n_x * n_u\n\n    # Initial augmented state\n    V0 = jnp.zeros((N - 1, i4))\n    V0 = V0.at[:, :n_x].set(x[:-1].astype(float))\n    V0 = V0.at[:, n_x : n_x + n_x * n_x].set(jnp.eye(n_x).reshape(1, -1).repeat(N - 1, axis=0))\n\n    # Choose integrator\n    integrator_args = dict(\n        u_cur=u[:-1].astype(float),\n        u_next=u[1:].astype(float),\n        state_dot=state_dot,\n        A=A,\n        B=B,\n        n_x=n_x,\n        n_u=n_u,\n        N=N,\n        dis_type=settings.dis.dis_type,\n        params=params,  # Pass params as single dict\n    )\n\n    # Define dVdt wrapper using named arguments\n    def dVdt_wrapped(t, y):\n        return dVdt(t, y, **integrator_args)\n\n    # Choose integrator\n    if settings.dis.custom_integrator:\n        sol = solve_ivp_rk45(\n            dVdt_wrapped,\n            1.0 / (N - 1),\n            V0.reshape(-1),\n            args=(),\n            is_not_compiled=settings.dev.debug,\n        )\n    else:\n        sol = solve_ivp_diffrax(\n            dVdt_wrapped,\n            1.0 / (N - 1),\n            V0.reshape(-1),\n            solver_name=settings.dis.solver,\n            rtol=settings.dis.rtol,\n            atol=settings.dis.atol,\n            args=(),\n            extra_kwargs=settings.dis.args,\n        )\n\n    Vend = sol[-1].T.reshape(-1, i4)\n    Vmulti = sol.T\n\n    x_prop = Vend[:, i0:i1]\n\n    # Return as 3D arrays: (N-1, n_x, n_x) for A_bar, (N-1, n_x, n_u) for B_bar/C_bar\n    A_bar = Vend[:, i1:i2].reshape(N - 1, n_x, n_x)\n    B_bar = Vend[:, i2:i3].reshape(N - 1, n_x, n_u)\n    C_bar = Vend[:, i3:i4].reshape(N - 1, n_x, n_u)\n\n    return A_bar, B_bar, C_bar, x_prop, Vmulti\n</code></pre>"},{"location":"reference/discretization/#openscvx.discretization.dVdt","title":"<code>dVdt(tau: float, V: jnp.ndarray, u_cur: np.ndarray, u_next: np.ndarray, state_dot: callable, A: callable, B: callable, n_x: int, n_u: int, N: int, dis_type: str, params: dict) -&gt; jnp.ndarray</code>","text":"<p>Compute the time derivative of the augmented state vector.</p> <p>This function computes the time derivative of the augmented state vector V, which includes the state, state transition matrix, and control influence matrix.</p> <p>Parameters:</p> Name Type Description Default <code>tau</code> <code>float</code> <p>Current normalized time in [0,1].</p> required <code>V</code> <code>ndarray</code> <p>Augmented state vector.</p> required <code>u_cur</code> <code>ndarray</code> <p>Control input at current node.</p> required <code>u_next</code> <code>ndarray</code> <p>Control input at next node.</p> required <code>state_dot</code> <code>callable</code> <p>Function computing state derivatives.</p> required <code>A</code> <code>callable</code> <p>Function computing state Jacobian.</p> required <code>B</code> <code>callable</code> <p>Function computing control Jacobian.</p> required <code>n_x</code> <code>int</code> <p>Number of states.</p> required <code>n_u</code> <code>int</code> <p>Number of controls.</p> required <code>N</code> <code>int</code> <p>Number of nodes in trajectory.</p> required <code>dis_type</code> <code>str</code> <p>Discretization type (\"ZOH\" or \"FOH\").</p> required <code>**params</code> <code>dict</code> <p>Additional parameters passed to state_dot, A, and B.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: Time derivative of augmented state vector.</p> Source code in <code>openscvx/discretization/discretization.py</code> <pre><code>def dVdt(\n    tau: float,\n    V: jnp.ndarray,\n    u_cur: np.ndarray,\n    u_next: np.ndarray,\n    state_dot: callable,\n    A: callable,\n    B: callable,\n    n_x: int,\n    n_u: int,\n    N: int,\n    dis_type: str,\n    params: dict,\n) -&gt; jnp.ndarray:\n    \"\"\"Compute the time derivative of the augmented state vector.\n\n    This function computes the time derivative of the augmented state vector V,\n    which includes the state, state transition matrix, and control influence matrix.\n\n    Args:\n        tau (float): Current normalized time in [0,1].\n        V (jnp.ndarray): Augmented state vector.\n        u_cur (np.ndarray): Control input at current node.\n        u_next (np.ndarray): Control input at next node.\n        state_dot (callable): Function computing state derivatives.\n        A (callable): Function computing state Jacobian.\n        B (callable): Function computing control Jacobian.\n        n_x (int): Number of states.\n        n_u (int): Number of controls.\n        N (int): Number of nodes in trajectory.\n        dis_type (str): Discretization type (\"ZOH\" or \"FOH\").\n        **params: Additional parameters passed to state_dot, A, and B.\n\n    Returns:\n        jnp.ndarray: Time derivative of augmented state vector.\n    \"\"\"\n    # Define the nodes\n    nodes = jnp.arange(0, N - 1)\n\n    # Define indices for slicing the augmented state vector\n    i0 = 0\n    i1 = n_x\n    i2 = i1 + n_x * n_x\n    i3 = i2 + n_x * n_u\n    i4 = i3 + n_x * n_u\n\n    # Unflatten V\n    V = V.reshape(-1, i4)\n\n    # Compute the interpolation factor based on the discretization type\n    if dis_type == \"ZOH\":\n        beta = 0.0\n    elif dis_type == \"FOH\":\n        beta = (tau) * N\n    alpha = 1 - beta\n\n    # Interpolate the control input\n    u = u_cur + beta * (u_next - u_cur)\n    s = u[:, -1]\n\n    # Initialize the augmented Jacobians\n    dfdx = jnp.zeros((V.shape[0], n_x, n_x))\n    dfdu = jnp.zeros((V.shape[0], n_x, n_u))\n\n    # Ensure x_seq and u have the same batch size\n    x = V[:, :n_x]\n    u = u[: x.shape[0]]\n\n    # Compute the nonlinear propagation term\n    f = state_dot(x, u[:, :-1], nodes, params)\n    F = s[:, None] * f\n\n    # Evaluate the State Jacobian\n    dfdx = A(x, u[:, :-1], nodes, params)\n    sdfdx = s[:, None, None] * dfdx\n\n    # Evaluate the Control Jacobian\n    dfdu_veh = B(x, u[:, :-1], nodes, params)\n    dfdu = dfdu.at[:, :, :-1].set(s[:, None, None] * dfdu_veh)\n    dfdu = dfdu.at[:, :, -1].set(f)\n\n    # Stack up the results into the augmented state vector\n    # fmt: off\n    dVdt = jnp.zeros_like(V)\n    dVdt = dVdt.at[:, i0:i1].set(F)\n    dVdt = dVdt.at[:, i1:i2].set(\n        jnp.matmul(sdfdx, V[:, i1:i2].reshape(-1, n_x, n_x)).reshape(-1, n_x * n_x)\n    )\n    dVdt = dVdt.at[:, i2:i3].set(\n        (jnp.matmul(sdfdx, V[:, i2:i3].reshape(-1, n_x, n_u)) + dfdu * alpha).reshape(-1, n_x * n_u)\n    )\n    dVdt = dVdt.at[:, i3:i4].set(\n        (jnp.matmul(sdfdx, V[:, i3:i4].reshape(-1, n_x, n_u)) + dfdu * beta).reshape(-1, n_x * n_u)\n    )\n    # fmt: on\n\n    return dVdt.reshape(-1)\n</code></pre>"},{"location":"reference/discretization/#openscvx.discretization.get_discretization_solver","title":"<code>get_discretization_solver(dyn: Dynamics, settings: Config)</code>","text":"<p>Create a discretization solver function.</p> <p>This function creates a solver that computes the discretized system matrices using the specified dynamics and settings.</p> <p>Parameters:</p> Name Type Description Default <code>dyn</code> <code>Dynamics</code> <p>System dynamics object.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings for discretization.</p> required <p>Returns:</p> Name Type Description <code>callable</code> <p>A function that computes the discretized system matrices.</p> Source code in <code>openscvx/discretization/discretization.py</code> <pre><code>def get_discretization_solver(dyn: Dynamics, settings: Config):\n    \"\"\"Create a discretization solver function.\n\n    This function creates a solver that computes the discretized system matrices\n    using the specified dynamics and settings.\n\n    Args:\n        dyn (Dynamics): System dynamics object.\n        settings: Configuration settings for discretization.\n\n    Returns:\n        callable: A function that computes the discretized system matrices.\n    \"\"\"\n    return lambda x, u, params: calculate_discretization(\n        x=x,\n        u=u,\n        state_dot=dyn.f,\n        A=dyn.A,\n        B=dyn.B,\n        settings=settings,\n        params=params,  # Pass as single dict\n    )\n</code></pre>"},{"location":"reference/discretization/discretization/","title":"discretization","text":""},{"location":"reference/discretization/discretization/#openscvx.discretization.discretization.calculate_discretization","title":"<code>calculate_discretization(x, u, state_dot: callable, A: callable, B: callable, settings: Config, params: dict)</code>","text":"<p>Calculate the discretized system matrices.</p> <p>This function computes the discretized system matrices (A_bar, B_bar, C_bar) and defect vector (z_bar) using numerical integration.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>State trajectory.</p> required <code>u</code> <p>Control trajectory.</p> required <code>state_dot</code> <code>callable</code> <p>Function computing state derivatives.</p> required <code>A</code> <code>callable</code> <p>Function computing state Jacobian.</p> required <code>B</code> <code>callable</code> <p>Function computing control Jacobian.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings for OpenSCvx.</p> required <code>custom_integrator</code> <code>bool</code> <p>Whether to use custom RK45 integrator.</p> required <code>debug</code> <code>bool</code> <p>Whether to use debug mode.</p> required <code>solver</code> <code>str</code> <p>Name of the solver to use.</p> required <code>rtol</code> <code>float</code> <p>Relative tolerance for integration.</p> required <code>atol</code> <code>float</code> <p>Absolute tolerance for integration.</p> required <code>dis_type</code> <code>str</code> <p>Discretization type (\"ZOH\" or \"FOH\").</p> required <code>**kwargs</code> <p>Additional parameters passed to state_dot, A, and B.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(A_bar, B_bar, C_bar, z_bar, Vmulti) where: - A_bar: Discretized state transition matrix - B_bar: Discretized control influence matrix - C_bar: Discretized control influence matrix for next node - z_bar: Defect vector - Vmulti: Full augmented state trajectory</p> Source code in <code>openscvx/discretization/discretization.py</code> <pre><code>def calculate_discretization(\n    x,\n    u,\n    state_dot: callable,\n    A: callable,\n    B: callable,\n    settings: Config,\n    params: dict,\n):\n    \"\"\"Calculate the discretized system matrices.\n\n    This function computes the discretized system matrices (A_bar, B_bar, C_bar)\n    and defect vector (z_bar) using numerical integration.\n\n    Args:\n        x: State trajectory.\n        u: Control trajectory.\n        state_dot (callable): Function computing state derivatives.\n        A (callable): Function computing state Jacobian.\n        B (callable): Function computing control Jacobian.\n        settings: Configuration settings for OpenSCvx.\n        custom_integrator (bool): Whether to use custom RK45 integrator.\n        debug (bool): Whether to use debug mode.\n        solver (str): Name of the solver to use.\n        rtol (float): Relative tolerance for integration.\n        atol (float): Absolute tolerance for integration.\n        dis_type (str): Discretization type (\"ZOH\" or \"FOH\").\n        **kwargs: Additional parameters passed to state_dot, A, and B.\n\n    Returns:\n        tuple: (A_bar, B_bar, C_bar, z_bar, Vmulti) where:\n            - A_bar: Discretized state transition matrix\n            - B_bar: Discretized control influence matrix\n            - C_bar: Discretized control influence matrix for next node\n            - z_bar: Defect vector\n            - Vmulti: Full augmented state trajectory\n    \"\"\"\n    # Unpack settings\n    n_x = settings.sim.n_states\n    n_u = settings.sim.n_controls\n\n    N = settings.scp.n\n\n    # Define indices for slicing the augmented state vector\n    i0 = 0\n    i1 = n_x\n    i2 = i1 + n_x * n_x\n    i3 = i2 + n_x * n_u\n    i4 = i3 + n_x * n_u\n\n    # Initial augmented state\n    V0 = jnp.zeros((N - 1, i4))\n    V0 = V0.at[:, :n_x].set(x[:-1].astype(float))\n    V0 = V0.at[:, n_x : n_x + n_x * n_x].set(jnp.eye(n_x).reshape(1, -1).repeat(N - 1, axis=0))\n\n    # Choose integrator\n    integrator_args = dict(\n        u_cur=u[:-1].astype(float),\n        u_next=u[1:].astype(float),\n        state_dot=state_dot,\n        A=A,\n        B=B,\n        n_x=n_x,\n        n_u=n_u,\n        N=N,\n        dis_type=settings.dis.dis_type,\n        params=params,  # Pass params as single dict\n    )\n\n    # Define dVdt wrapper using named arguments\n    def dVdt_wrapped(t, y):\n        return dVdt(t, y, **integrator_args)\n\n    # Choose integrator\n    if settings.dis.custom_integrator:\n        sol = solve_ivp_rk45(\n            dVdt_wrapped,\n            1.0 / (N - 1),\n            V0.reshape(-1),\n            args=(),\n            is_not_compiled=settings.dev.debug,\n        )\n    else:\n        sol = solve_ivp_diffrax(\n            dVdt_wrapped,\n            1.0 / (N - 1),\n            V0.reshape(-1),\n            solver_name=settings.dis.solver,\n            rtol=settings.dis.rtol,\n            atol=settings.dis.atol,\n            args=(),\n            extra_kwargs=settings.dis.args,\n        )\n\n    Vend = sol[-1].T.reshape(-1, i4)\n    Vmulti = sol.T\n\n    x_prop = Vend[:, i0:i1]\n\n    # Return as 3D arrays: (N-1, n_x, n_x) for A_bar, (N-1, n_x, n_u) for B_bar/C_bar\n    A_bar = Vend[:, i1:i2].reshape(N - 1, n_x, n_x)\n    B_bar = Vend[:, i2:i3].reshape(N - 1, n_x, n_u)\n    C_bar = Vend[:, i3:i4].reshape(N - 1, n_x, n_u)\n\n    return A_bar, B_bar, C_bar, x_prop, Vmulti\n</code></pre>"},{"location":"reference/discretization/discretization/#openscvx.discretization.discretization.dVdt","title":"<code>dVdt(tau: float, V: jnp.ndarray, u_cur: np.ndarray, u_next: np.ndarray, state_dot: callable, A: callable, B: callable, n_x: int, n_u: int, N: int, dis_type: str, params: dict) -&gt; jnp.ndarray</code>","text":"<p>Compute the time derivative of the augmented state vector.</p> <p>This function computes the time derivative of the augmented state vector V, which includes the state, state transition matrix, and control influence matrix.</p> <p>Parameters:</p> Name Type Description Default <code>tau</code> <code>float</code> <p>Current normalized time in [0,1].</p> required <code>V</code> <code>ndarray</code> <p>Augmented state vector.</p> required <code>u_cur</code> <code>ndarray</code> <p>Control input at current node.</p> required <code>u_next</code> <code>ndarray</code> <p>Control input at next node.</p> required <code>state_dot</code> <code>callable</code> <p>Function computing state derivatives.</p> required <code>A</code> <code>callable</code> <p>Function computing state Jacobian.</p> required <code>B</code> <code>callable</code> <p>Function computing control Jacobian.</p> required <code>n_x</code> <code>int</code> <p>Number of states.</p> required <code>n_u</code> <code>int</code> <p>Number of controls.</p> required <code>N</code> <code>int</code> <p>Number of nodes in trajectory.</p> required <code>dis_type</code> <code>str</code> <p>Discretization type (\"ZOH\" or \"FOH\").</p> required <code>**params</code> <code>dict</code> <p>Additional parameters passed to state_dot, A, and B.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: Time derivative of augmented state vector.</p> Source code in <code>openscvx/discretization/discretization.py</code> <pre><code>def dVdt(\n    tau: float,\n    V: jnp.ndarray,\n    u_cur: np.ndarray,\n    u_next: np.ndarray,\n    state_dot: callable,\n    A: callable,\n    B: callable,\n    n_x: int,\n    n_u: int,\n    N: int,\n    dis_type: str,\n    params: dict,\n) -&gt; jnp.ndarray:\n    \"\"\"Compute the time derivative of the augmented state vector.\n\n    This function computes the time derivative of the augmented state vector V,\n    which includes the state, state transition matrix, and control influence matrix.\n\n    Args:\n        tau (float): Current normalized time in [0,1].\n        V (jnp.ndarray): Augmented state vector.\n        u_cur (np.ndarray): Control input at current node.\n        u_next (np.ndarray): Control input at next node.\n        state_dot (callable): Function computing state derivatives.\n        A (callable): Function computing state Jacobian.\n        B (callable): Function computing control Jacobian.\n        n_x (int): Number of states.\n        n_u (int): Number of controls.\n        N (int): Number of nodes in trajectory.\n        dis_type (str): Discretization type (\"ZOH\" or \"FOH\").\n        **params: Additional parameters passed to state_dot, A, and B.\n\n    Returns:\n        jnp.ndarray: Time derivative of augmented state vector.\n    \"\"\"\n    # Define the nodes\n    nodes = jnp.arange(0, N - 1)\n\n    # Define indices for slicing the augmented state vector\n    i0 = 0\n    i1 = n_x\n    i2 = i1 + n_x * n_x\n    i3 = i2 + n_x * n_u\n    i4 = i3 + n_x * n_u\n\n    # Unflatten V\n    V = V.reshape(-1, i4)\n\n    # Compute the interpolation factor based on the discretization type\n    if dis_type == \"ZOH\":\n        beta = 0.0\n    elif dis_type == \"FOH\":\n        beta = (tau) * N\n    alpha = 1 - beta\n\n    # Interpolate the control input\n    u = u_cur + beta * (u_next - u_cur)\n    s = u[:, -1]\n\n    # Initialize the augmented Jacobians\n    dfdx = jnp.zeros((V.shape[0], n_x, n_x))\n    dfdu = jnp.zeros((V.shape[0], n_x, n_u))\n\n    # Ensure x_seq and u have the same batch size\n    x = V[:, :n_x]\n    u = u[: x.shape[0]]\n\n    # Compute the nonlinear propagation term\n    f = state_dot(x, u[:, :-1], nodes, params)\n    F = s[:, None] * f\n\n    # Evaluate the State Jacobian\n    dfdx = A(x, u[:, :-1], nodes, params)\n    sdfdx = s[:, None, None] * dfdx\n\n    # Evaluate the Control Jacobian\n    dfdu_veh = B(x, u[:, :-1], nodes, params)\n    dfdu = dfdu.at[:, :, :-1].set(s[:, None, None] * dfdu_veh)\n    dfdu = dfdu.at[:, :, -1].set(f)\n\n    # Stack up the results into the augmented state vector\n    # fmt: off\n    dVdt = jnp.zeros_like(V)\n    dVdt = dVdt.at[:, i0:i1].set(F)\n    dVdt = dVdt.at[:, i1:i2].set(\n        jnp.matmul(sdfdx, V[:, i1:i2].reshape(-1, n_x, n_x)).reshape(-1, n_x * n_x)\n    )\n    dVdt = dVdt.at[:, i2:i3].set(\n        (jnp.matmul(sdfdx, V[:, i2:i3].reshape(-1, n_x, n_u)) + dfdu * alpha).reshape(-1, n_x * n_u)\n    )\n    dVdt = dVdt.at[:, i3:i4].set(\n        (jnp.matmul(sdfdx, V[:, i3:i4].reshape(-1, n_x, n_u)) + dfdu * beta).reshape(-1, n_x * n_u)\n    )\n    # fmt: on\n\n    return dVdt.reshape(-1)\n</code></pre>"},{"location":"reference/discretization/discretization/#openscvx.discretization.discretization.get_discretization_solver","title":"<code>get_discretization_solver(dyn: Dynamics, settings: Config)</code>","text":"<p>Create a discretization solver function.</p> <p>This function creates a solver that computes the discretized system matrices using the specified dynamics and settings.</p> <p>Parameters:</p> Name Type Description Default <code>dyn</code> <code>Dynamics</code> <p>System dynamics object.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings for discretization.</p> required <p>Returns:</p> Name Type Description <code>callable</code> <p>A function that computes the discretized system matrices.</p> Source code in <code>openscvx/discretization/discretization.py</code> <pre><code>def get_discretization_solver(dyn: Dynamics, settings: Config):\n    \"\"\"Create a discretization solver function.\n\n    This function creates a solver that computes the discretized system matrices\n    using the specified dynamics and settings.\n\n    Args:\n        dyn (Dynamics): System dynamics object.\n        settings: Configuration settings for discretization.\n\n    Returns:\n        callable: A function that computes the discretized system matrices.\n    \"\"\"\n    return lambda x, u, params: calculate_discretization(\n        x=x,\n        u=u,\n        state_dot=dyn.f,\n        A=dyn.A,\n        B=dyn.B,\n        settings=settings,\n        params=params,  # Pass as single dict\n    )\n</code></pre>"},{"location":"reference/expert/","title":"expert","text":"<p>Expert-mode features for advanced users.</p> <p>This module contains features for expert users who need fine-grained control and are willing to bypass higher-level abstractions.</p>"},{"location":"reference/expert/#openscvx.expert.ByofSpec","title":"<code>ByofSpec</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Bring-Your-Own-Functions specification for expert users.</p> <p>Allows bypassing the symbolic layer and directly providing raw JAX functions. All fields are optional - you can mix symbolic and byof as needed.</p> Warning <p>You are responsible for:</p> <ul> <li>Correct indexing into unified state/control vectors</li> <li>Ensuring functions are JAX-compatible (use jax.numpy, no side effects)</li> <li>Ensuring functions are differentiable</li> <li>Following g(x,u) &lt;= 0 convention for constraints</li> </ul> Tip <p>Use the <code>.slice</code> property on State/Control objects for cleaner, more maintainable indexing instead of hardcoded indices. For example, use <code>x[velocity.slice]</code> instead of <code>x[2:3]</code>. The slice property is set after preprocessing and provides the correct indices into the unified state/control vectors.</p> <p>Attributes:</p> Name Type Description <code>dynamics</code> <code>dict[str, DynamicsFunction]</code> <p>Raw JAX functions for state derivatives. Maps state names to functions with signature <code>(x, u, node, params) -&gt; xdot_component</code>. States here should NOT appear in symbolic dynamics dict. You can mix: some states symbolic, some in byof.</p> <code>nodal_constraints</code> <code>List[NodalConstraintSpec]</code> <p>Point-wise constraints applied at specific nodes. Each item is a :class:<code>NodalConstraintSpec</code> dict with:</p> <ul> <li><code>func</code>: Constraint function <code>(x, u, node, params) -&gt; residual</code> (required)</li> <li><code>nodes</code>: List of node indices (optional, defaults to all nodes)</li> </ul> <p>Follows g(x,u) &lt;= 0 convention.</p> <code>cross_nodal_constraints</code> <code>List[CrossNodalConstraintFunction]</code> <p>Constraints coupling multiple nodes (smoothness, rate limits). Signature: <code>(X, U, params) -&gt; residual</code> where X is (N, n_x) and U is (N, n_u). N is the number of trajectory nodes, n_x is state dimension, n_u is control dimension. Follows g(X,U) &lt;= 0 convention.</p> <code>ctcs_constraints</code> <code>List[CtcsConstraintSpec]</code> <p>Continuous-time constraint satisfaction via dynamics augmentation. Each adds an augmented state accumulating violation penalties. See :class:<code>CtcsConstraintSpec</code> for details.</p> Example <p>Custom dynamics and constraints::</p> <pre><code>import jax.numpy as jnp\nimport openscvx as ox\nfrom openscvx import ByofSpec\n\n# Define states and controls\nposition = ox.State(\"position\", shape=(2,))\nvelocity = ox.State(\"velocity\", shape=(1,))\ntheta = ox.Control(\"theta\", shape=(1,))\n\n# Custom dynamics for one state using .slice property\ndef custom_velocity_dynamics(x, u, node, params):\n    # Use .slice property for clean indexing\n    return params[\"g\"] * jnp.cos(u[theta.slice][0])\n\nbyof: ByofSpec = {\n    \"dynamics\": {\n        \"velocity\": custom_velocity_dynamics,\n    },\n    \"nodal_constraints\": [\n        # Applied to all nodes (no \"nodes\" field)\n        {\n            \"constraint_fn\": lambda x, u, node, params: x[velocity.slice][0] - 10.0,\n        },\n        {\n            \"constraint_fn\": lambda x, u, node, params: -x[velocity.slice][0],\n        },\n        # Specify nodes for selective enforcement\n        {\n            \"constraint_fn\": lambda x, u, node, params: x[velocity.slice][0],\n            \"nodes\": [0],  # Velocity must be exactly 0 at start\n        },\n    ],\n    \"cross_nodal_constraints\": [\n        # Constrain total velocity across trajectory: sum(velocities) &gt;= 5\n        # X.shape = (N, n_x), extract velocity column using slice\n        lambda X, U, params: 5.0 - jnp.sum(X[:, velocity.slice]),\n    ],\n    \"ctcs_constraints\": [\n        {\n            \"constraint_fn\": lambda x, u, node, params: x[position.slice][0] - 5.0,\n            \"penalty\": \"square\",\n        }\n    ],\n}\n</code></pre> Source code in <code>openscvx/expert/byof.py</code> <pre><code>class ByofSpec(TypedDict, total=False):\n    \"\"\"Bring-Your-Own-Functions specification for expert users.\n\n    Allows bypassing the symbolic layer and directly providing raw JAX functions.\n    All fields are optional - you can mix symbolic and byof as needed.\n\n    Warning:\n        You are responsible for:\n\n        - Correct indexing into unified state/control vectors\n        - Ensuring functions are JAX-compatible (use jax.numpy, no side effects)\n        - Ensuring functions are differentiable\n        - Following g(x,u) &lt;= 0 convention for constraints\n\n    Tip:\n        Use the ``.slice`` property on State/Control objects for cleaner, more\n        maintainable indexing instead of hardcoded indices. For example, use\n        ``x[velocity.slice]`` instead of ``x[2:3]``. The slice property is set\n        after preprocessing and provides the correct indices into the unified\n        state/control vectors.\n\n    Attributes:\n        dynamics: Raw JAX functions for state derivatives. Maps state names to functions\n            with signature ``(x, u, node, params) -&gt; xdot_component``. States here should\n            NOT appear in symbolic dynamics dict. You can mix: some states symbolic,\n            some in byof.\n        nodal_constraints: Point-wise constraints applied at specific nodes.\n            Each item is a :class:`NodalConstraintSpec` dict with:\n\n            - ``func``: Constraint function ``(x, u, node, params) -&gt; residual`` (required)\n            - ``nodes``: List of node indices (optional, defaults to all nodes)\n\n            Follows g(x,u) &lt;= 0 convention.\n        cross_nodal_constraints: Constraints coupling multiple nodes (smoothness, rate limits).\n            Signature: ``(X, U, params) -&gt; residual`` where X is (N, n_x) and U is (N, n_u).\n            N is the number of trajectory nodes, n_x is state dimension, n_u is control dimension.\n            Follows g(X,U) &lt;= 0 convention.\n        ctcs_constraints: Continuous-time constraint satisfaction via dynamics augmentation.\n            Each adds an augmented state accumulating violation penalties.\n            See :class:`CtcsConstraintSpec` for details.\n\n    Example:\n        Custom dynamics and constraints::\n\n            import jax.numpy as jnp\n            import openscvx as ox\n            from openscvx import ByofSpec\n\n            # Define states and controls\n            position = ox.State(\"position\", shape=(2,))\n            velocity = ox.State(\"velocity\", shape=(1,))\n            theta = ox.Control(\"theta\", shape=(1,))\n\n            # Custom dynamics for one state using .slice property\n            def custom_velocity_dynamics(x, u, node, params):\n                # Use .slice property for clean indexing\n                return params[\"g\"] * jnp.cos(u[theta.slice][0])\n\n            byof: ByofSpec = {\n                \"dynamics\": {\n                    \"velocity\": custom_velocity_dynamics,\n                },\n                \"nodal_constraints\": [\n                    # Applied to all nodes (no \"nodes\" field)\n                    {\n                        \"constraint_fn\": lambda x, u, node, params: x[velocity.slice][0] - 10.0,\n                    },\n                    {\n                        \"constraint_fn\": lambda x, u, node, params: -x[velocity.slice][0],\n                    },\n                    # Specify nodes for selective enforcement\n                    {\n                        \"constraint_fn\": lambda x, u, node, params: x[velocity.slice][0],\n                        \"nodes\": [0],  # Velocity must be exactly 0 at start\n                    },\n                ],\n                \"cross_nodal_constraints\": [\n                    # Constrain total velocity across trajectory: sum(velocities) &gt;= 5\n                    # X.shape = (N, n_x), extract velocity column using slice\n                    lambda X, U, params: 5.0 - jnp.sum(X[:, velocity.slice]),\n                ],\n                \"ctcs_constraints\": [\n                    {\n                        \"constraint_fn\": lambda x, u, node, params: x[position.slice][0] - 5.0,\n                        \"penalty\": \"square\",\n                    }\n                ],\n            }\n    \"\"\"\n\n    dynamics: dict[str, DynamicsFunction]\n    nodal_constraints: List[NodalConstraintSpec]\n    cross_nodal_constraints: List[CrossNodalConstraintFunction]\n    ctcs_constraints: List[CtcsConstraintSpec]\n</code></pre>"},{"location":"reference/expert/#openscvx.expert.CtcsConstraintSpec","title":"<code>CtcsConstraintSpec</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Specification for CTCS (Continuous-Time Constraint Satisfaction) constraint.</p> <p>CTCS constraints are enforced by augmenting the dynamics with a penalty term that accumulates violations over time. Useful for path constraints that must be satisfied continuously, not just at discrete nodes.</p> <p>Attributes:</p> Name Type Description <code>constraint_fn</code> <code>CtcsConstraintFunction</code> <p>Function computing constraint residual with signature <code>(x, u, node, params) -&gt; scalar</code>. Must return scalar. Follows g(x,u) &lt;= 0 convention (negative = satisfied). Required field.</p> <code>penalty</code> <code>PenaltyFunction</code> <p>Penalty function for positive residuals (violations). Built-in options: \"square\" (max(r,0)^2, default), \"l1\" (max(r,0)), \"huber\" (Huber loss). Custom: Callable <code>(r) -&gt; penalty</code> (non-negative, differentiable).</p> <code>bounds</code> <code>Tuple[float, float]</code> <p>(min, max) bounds for augmented state accumulating penalties. Default: (0.0, 1e-4). Max acts as soft constraint on total violation.</p> <code>initial</code> <code>float</code> <p>Initial value for augmented state. Default: bounds[0] (usually 0.0).</p> <code>over</code> <code>Tuple[int, int]</code> <p>Node interval (start, end) where constraint is active. The constraint is enforced for nodes in [start, end). If omitted, constraint is active over all nodes. Matches symbolic <code>.over()</code> method behavior.</p> <code>idx</code> <code>int</code> <p>Constraint group index for sharing augmented states (default: 0). All CTCS constraints (symbolic and byof) with the same idx share a single augmented state. Their penalties are summed together. Use different idx values to track different types of violations separately.</p> Warning <p>If symbolic CTCS constraints exist with idx values [0, 1, 2], then byof idx must either:</p> <ul> <li>Match an existing idx (e.g., 0, 1, or 2) to add to that augmented state</li> <li>Be sequential after them (e.g., 3, 4, 5) to create new augmented states</li> </ul> <p>You cannot use idx values that create gaps (e.g., if symbolic has [0, 1], you cannot use byof idx=3 without also using idx=2).</p> Example <p>Enforce position[0] &lt;= 10.0 continuously::</p> <pre><code># Assuming position = ox.State(\"position\", shape=(2,))\nctcs_spec: CtcsConstraintSpec = {\n    \"constraint_fn\": lambda x, u, node, params: x[position.slice][0] - 10.0,\n    \"penalty\": \"square\",\n    \"bounds\": (0.0, 1e-4),\n    \"initial\": 0.0,\n    \"idx\": 0,  # Groups with other constraints having idx=0\n}\n</code></pre> <p>Enforce constraint only over specific node range::</p> <pre><code>ctcs_spec: CtcsConstraintSpec = {\n    \"constraint_fn\": lambda x, u, node, params: x[position.slice][0] - 10.0,\n    \"over\": (10, 50),  # Active only for nodes 10-49\n    \"penalty\": \"square\",\n}\n</code></pre> <p>Multiple constraints sharing an augmented state::</p> <pre><code># If symbolic CTCS already has idx=[0, 1], then:\n\nbyof = {\n    \"ctcs_constraints\": [\n        # Add to existing symbolic idx=0 augmented state\n        {\n            \"constraint_fn\": lambda x, u, node, params: x[pos.slice][0] - 10.0,\n            \"idx\": 0,  # Shares with symbolic idx=0\n        },\n        # Add to existing symbolic idx=1 augmented state\n        {\n            \"constraint_fn\": lambda x, u, node, params: x[vel.slice][0] - 5.0,\n            \"idx\": 1,  # Shares with symbolic idx=1\n        },\n        # Create NEW augmented state (sequential after symbolic)\n        {\n            \"constraint_fn\": lambda x, u, node, params: x[pos.slice][1] - 8.0,\n            \"idx\": 2,  # New state (symbolic has 0,1, so next is 2)\n        },\n    ]\n}\n</code></pre> Source code in <code>openscvx/expert/byof.py</code> <pre><code>class CtcsConstraintSpec(TypedDict, total=False):\n    \"\"\"Specification for CTCS (Continuous-Time Constraint Satisfaction) constraint.\n\n    CTCS constraints are enforced by augmenting the dynamics with a penalty term that\n    accumulates violations over time. Useful for path constraints that must be satisfied\n    continuously, not just at discrete nodes.\n\n    Attributes:\n        constraint_fn: Function computing constraint residual with signature\n            ``(x, u, node, params) -&gt; scalar``. Must return scalar.\n            Follows g(x,u) &lt;= 0 convention (negative = satisfied). Required field.\n        penalty: Penalty function for positive residuals (violations).\n            Built-in options: \"square\" (max(r,0)^2, default), \"l1\" (max(r,0)),\n            \"huber\" (Huber loss). Custom: Callable ``(r) -&gt; penalty`` (non-negative,\n            differentiable).\n        bounds: (min, max) bounds for augmented state accumulating penalties.\n            Default: (0.0, 1e-4). Max acts as soft constraint on total violation.\n        initial: Initial value for augmented state. Default: bounds[0] (usually 0.0).\n        over: Node interval (start, end) where constraint is active. The constraint\n            is enforced for nodes in [start, end). If omitted, constraint is active\n            over all nodes. Matches symbolic `.over()` method behavior.\n        idx: Constraint group index for sharing augmented states (default: 0).\n            All CTCS constraints (symbolic and byof) with the same idx share a single\n            augmented state. Their penalties are summed together. Use different idx values\n            to track different types of violations separately.\n\n    Warning:\n        If symbolic CTCS constraints exist with idx values [0, 1, 2], then byof idx **must** either:\n\n        - Match an existing idx (e.g., 0, 1, or 2) to add to that augmented state\n        - Be sequential after them (e.g., 3, 4, 5) to create new augmented states\n\n        You cannot use idx values that create gaps (e.g., if symbolic has [0, 1],\n        you cannot use byof idx=3 without also using idx=2).\n\n    Example:\n        Enforce position[0] &lt;= 10.0 continuously::\n\n            # Assuming position = ox.State(\"position\", shape=(2,))\n            ctcs_spec: CtcsConstraintSpec = {\n                \"constraint_fn\": lambda x, u, node, params: x[position.slice][0] - 10.0,\n                \"penalty\": \"square\",\n                \"bounds\": (0.0, 1e-4),\n                \"initial\": 0.0,\n                \"idx\": 0,  # Groups with other constraints having idx=0\n            }\n\n        Enforce constraint only over specific node range::\n\n            ctcs_spec: CtcsConstraintSpec = {\n                \"constraint_fn\": lambda x, u, node, params: x[position.slice][0] - 10.0,\n                \"over\": (10, 50),  # Active only for nodes 10-49\n                \"penalty\": \"square\",\n            }\n\n        Multiple constraints sharing an augmented state::\n\n            # If symbolic CTCS already has idx=[0, 1], then:\n\n            byof = {\n                \"ctcs_constraints\": [\n                    # Add to existing symbolic idx=0 augmented state\n                    {\n                        \"constraint_fn\": lambda x, u, node, params: x[pos.slice][0] - 10.0,\n                        \"idx\": 0,  # Shares with symbolic idx=0\n                    },\n                    # Add to existing symbolic idx=1 augmented state\n                    {\n                        \"constraint_fn\": lambda x, u, node, params: x[vel.slice][0] - 5.0,\n                        \"idx\": 1,  # Shares with symbolic idx=1\n                    },\n                    # Create NEW augmented state (sequential after symbolic)\n                    {\n                        \"constraint_fn\": lambda x, u, node, params: x[pos.slice][1] - 8.0,\n                        \"idx\": 2,  # New state (symbolic has 0,1, so next is 2)\n                    },\n                ]\n            }\n    \"\"\"\n\n    constraint_fn: CtcsConstraintFunction  # Required\n    penalty: PenaltyFunction\n    bounds: Tuple[float, float]\n    initial: float\n    over: Tuple[int, int]\n    idx: int\n</code></pre>"},{"location":"reference/expert/#openscvx.expert.NodalConstraintSpec","title":"<code>NodalConstraintSpec</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Specification for nodal constraint with optional node selection.</p> <p>Nodal constraints are point-wise constraints evaluated at specific trajectory nodes. By default, constraints apply to all nodes, but you can restrict enforcement to specific nodes for boundary conditions, waypoints, or computational efficiency.</p> <p>Attributes:</p> Name Type Description <code>constraint_fn</code> <code>NodalConstraintFunction</code> <p>Constraint function with signature <code>(x, u, node, params) -&gt; residual</code>. Follows g(x,u) &lt;= 0 convention (negative = satisfied). Required field.</p> <code>nodes</code> <code>List[int]</code> <p>List of integer node indices where constraint is enforced. If omitted, applies to all nodes. Negative indices supported (e.g., -1 for last). Optional field.</p> Example <p>Boundary constraint only at first and last nodes::</p> <pre><code>nodal_spec: NodalConstraintSpec = {\n    \"constraint_fn\": lambda x, u, node, params: x[velocity.slice][0],\n    \"nodes\": [0, -1],  # Only at start and end\n}\n</code></pre> <p>Waypoint constraint at middle of trajectory::</p> <pre><code>nodal_spec: NodalConstraintSpec = {\n    \"constraint_fn\": lambda x, u, node, params: jnp.linalg.norm(\n        x[position.slice] - jnp.array([5.0, 7.5])\n    ) - 0.1,\n    \"nodes\": [N // 2],\n}\n</code></pre> Source code in <code>openscvx/expert/byof.py</code> <pre><code>class NodalConstraintSpec(TypedDict, total=False):\n    \"\"\"Specification for nodal constraint with optional node selection.\n\n    Nodal constraints are point-wise constraints evaluated at specific trajectory nodes.\n    By default, constraints apply to all nodes, but you can restrict enforcement to\n    specific nodes for boundary conditions, waypoints, or computational efficiency.\n\n    Attributes:\n        constraint_fn: Constraint function with signature ``(x, u, node, params) -&gt; residual``.\n            Follows g(x,u) &lt;= 0 convention (negative = satisfied). Required field.\n        nodes: List of integer node indices where constraint is enforced.\n            If omitted, applies to all nodes. Negative indices supported (e.g., -1 for last).\n            Optional field.\n\n    Example:\n        Boundary constraint only at first and last nodes::\n\n            nodal_spec: NodalConstraintSpec = {\n                \"constraint_fn\": lambda x, u, node, params: x[velocity.slice][0],\n                \"nodes\": [0, -1],  # Only at start and end\n            }\n\n        Waypoint constraint at middle of trajectory::\n\n            nodal_spec: NodalConstraintSpec = {\n                \"constraint_fn\": lambda x, u, node, params: jnp.linalg.norm(\n                    x[position.slice] - jnp.array([5.0, 7.5])\n                ) - 0.1,\n                \"nodes\": [N // 2],\n            }\n    \"\"\"\n\n    constraint_fn: NodalConstraintFunction  # Required\n    nodes: List[int]\n</code></pre>"},{"location":"reference/expert/#openscvx.expert.apply_byof","title":"<code>apply_byof(byof: dict, dynamics: Dynamics, dynamics_prop: Dynamics, jax_constraints: LoweredJaxConstraints, x_unified: UnifiedState, x_prop_unified: UnifiedState, u_unified: UnifiedState, states: List[State], states_prop: List[State], N: int) -&gt; Tuple[Dynamics, Dynamics, LoweredJaxConstraints, UnifiedState, UnifiedState]</code>","text":"<p>Apply bring-your-own-functions (byof) to augment lowered problem.</p> <p>Handles raw JAX functions provided by expert users, including: - dynamics: Raw JAX functions for specific state derivatives - nodal_constraints: Point-wise constraints at each node - cross_nodal_constraints: Constraints coupling multiple nodes - ctcs_constraints: Continuous-time constraint satisfaction via dynamics augmentation</p> <p>Parameters:</p> Name Type Description Default <code>byof</code> <code>dict</code> <p>Dict with keys \"dynamics\", \"nodal_constraints\", \"cross_nodal_constraints\", \"ctcs_constraints\"</p> required <code>dynamics</code> <code>Dynamics</code> <p>Lowered optimization dynamics to potentially augment</p> required <code>dynamics_prop</code> <code>Dynamics</code> <p>Lowered propagation dynamics to potentially augment</p> required <code>jax_constraints</code> <code>LoweredJaxConstraints</code> <p>Lowered JAX constraints to append to</p> required <code>x_unified</code> <code>UnifiedState</code> <p>Unified optimization state interface to potentially augment</p> required <code>x_prop_unified</code> <code>UnifiedState</code> <p>Unified propagation state interface to potentially augment</p> required <code>u_unified</code> <code>UnifiedState</code> <p>Unified control interface for validation</p> required <code>states</code> <code>List[State]</code> <p>List of State objects for optimization (with _slice attributes)</p> required <code>states_prop</code> <code>List[State]</code> <p>List of State objects for propagation (with _slice attributes)</p> required <code>N</code> <code>int</code> <p>Number of nodes in the trajectory</p> required <p>Returns:</p> Type Description <code>Tuple[Dynamics, Dynamics, LoweredJaxConstraints, UnifiedState, UnifiedState]</code> <p>Tuple of (dynamics, dynamics_prop, jax_constraints, x_unified, x_prop_unified)</p> Example <p>dynamics, dynamics_prop, constraints, x_unified, x_prop_unified = apply_byof( ...     byof, dynamics, dynamics_prop, jax_constraints, ...     x_unified, x_prop_unified, u_unified, states, states_prop, N ... )</p> Source code in <code>openscvx/expert/lowering.py</code> <pre><code>def apply_byof(\n    byof: dict,\n    dynamics: Dynamics,\n    dynamics_prop: Dynamics,\n    jax_constraints: LoweredJaxConstraints,\n    x_unified: \"UnifiedState\",\n    x_prop_unified: \"UnifiedState\",\n    u_unified: \"UnifiedState\",\n    states: List[\"State\"],\n    states_prop: List[\"State\"],\n    N: int,\n) -&gt; Tuple[Dynamics, Dynamics, LoweredJaxConstraints, \"UnifiedState\", \"UnifiedState\"]:\n    \"\"\"Apply bring-your-own-functions (byof) to augment lowered problem.\n\n    Handles raw JAX functions provided by expert users, including:\n    - dynamics: Raw JAX functions for specific state derivatives\n    - nodal_constraints: Point-wise constraints at each node\n    - cross_nodal_constraints: Constraints coupling multiple nodes\n    - ctcs_constraints: Continuous-time constraint satisfaction via dynamics augmentation\n\n    Args:\n        byof: Dict with keys \"dynamics\", \"nodal_constraints\", \"cross_nodal_constraints\",\n            \"ctcs_constraints\"\n        dynamics: Lowered optimization dynamics to potentially augment\n        dynamics_prop: Lowered propagation dynamics to potentially augment\n        jax_constraints: Lowered JAX constraints to append to\n        x_unified: Unified optimization state interface to potentially augment\n        x_prop_unified: Unified propagation state interface to potentially augment\n        u_unified: Unified control interface for validation\n        states: List of State objects for optimization (with _slice attributes)\n        states_prop: List of State objects for propagation (with _slice attributes)\n        N: Number of nodes in the trajectory\n\n    Returns:\n        Tuple of (dynamics, dynamics_prop, jax_constraints, x_unified, x_prop_unified)\n\n    Example:\n        &gt;&gt;&gt; dynamics, dynamics_prop, constraints, x_unified, x_prop_unified = apply_byof(\n        ...     byof, dynamics, dynamics_prop, jax_constraints,\n        ...     x_unified, x_prop_unified, u_unified, states, states_prop, N\n        ... )\n    \"\"\"\n\n    # Note: byof validation happens earlier in Problem.__init__ to fail fast\n    # Handle byof dynamics by splicing in raw JAX functions at the correct slices\n    byof_dynamics = byof.get(\"dynamics\", {})\n    if byof_dynamics:\n        # Build mapping from state name to slice for optimization states\n        state_slices = {state.name: state._slice for state in states}\n        state_slices_prop = {state.name: state._slice for state in states_prop}\n\n        def _make_composite_dynamics(orig_f, byof_fns, slices_map):\n            \"\"\"Create composite dynamics combining symbolic and byof state derivatives.\n\n            This factory splices user-provided byof dynamics into the unified dynamics\n            function at the appropriate slice indices, replacing the symbolic dynamics\n            for specific states while preserving the rest.\n\n            Args:\n                orig_f: Original unified dynamics (x, u, node, params) -&gt; xdot\n                byof_fns: Dict mapping state names to byof dynamics functions\n                slices_map: Dict mapping state names to slice objects for indexing\n\n            Returns:\n                Composite dynamics function with byof derivatives spliced in\n            \"\"\"\n\n            def composite_f(x, u, node, params):\n                # Start with symbolic/default dynamics for all states\n                xdot = orig_f(x, u, node, params)\n\n                # Splice in byof dynamics for specific states\n                for state_name, byof_fn in byof_fns.items():\n                    sl = slices_map[state_name]\n                    # Replace the derivative for this state with the byof result\n                    xdot = xdot.at[sl].set(byof_fn(x, u, node, params))\n\n                return xdot\n\n            return composite_f\n\n        # Create composite optimization dynamics\n        composite_f = _make_composite_dynamics(dynamics.f, byof_dynamics, state_slices)\n        dynamics = Dynamics(\n            f=composite_f,\n            A=jacfwd(composite_f, argnums=0),\n            B=jacfwd(composite_f, argnums=1),\n        )\n\n        # Create composite propagation dynamics\n        composite_f_prop = _make_composite_dynamics(\n            dynamics_prop.f, byof_dynamics, state_slices_prop\n        )\n        dynamics_prop = Dynamics(\n            f=composite_f_prop,\n            A=jacfwd(composite_f_prop, argnums=0),\n            B=jacfwd(composite_f_prop, argnums=1),\n        )\n\n    # Handle nodal constraints\n    # Note: Validation happens earlier in Problem.__init__ via validate_byof\n    for constraint_spec in byof.get(\"nodal_constraints\", []):\n        fn = constraint_spec[\"constraint_fn\"]\n        nodes = constraint_spec.get(\"nodes\", list(range(N)))  # Default: all nodes\n\n        # Normalize negative node indices (validation already done in validate_byof)\n        normalized_nodes = [node if node &gt;= 0 else N + node for node in nodes]\n\n        constraint = LoweredNodalConstraint(\n            func=jax.vmap(fn, in_axes=(0, 0, None, None)),\n            grad_g_x=jax.vmap(jacfwd(fn, argnums=0), in_axes=(0, 0, None, None)),\n            grad_g_u=jax.vmap(jacfwd(fn, argnums=1), in_axes=(0, 0, None, None)),\n            nodes=normalized_nodes,\n        )\n        jax_constraints.nodal.append(constraint)\n\n    # Handle cross-nodal constraints\n    for fn in byof.get(\"cross_nodal_constraints\", []):\n        constraint = LoweredCrossNodeConstraint(\n            func=fn,\n            grad_g_X=jacfwd(fn, argnums=0),\n            grad_g_U=jacfwd(fn, argnums=1),\n        )\n        jax_constraints.cross_node.append(constraint)\n\n    # Handle CTCS constraints by augmenting dynamics\n    # Built-in penalty functions\n    def _penalty_square(r):\n        return jnp.maximum(r, 0.0) ** 2\n\n    def _penalty_l1(r):\n        return jnp.maximum(r, 0.0)\n\n    def _penalty_huber(r, delta=1.0):\n        abs_r = jnp.maximum(r, 0.0)\n        return jnp.where(abs_r &lt;= delta, 0.5 * abs_r**2, delta * (abs_r - 0.5 * delta))\n\n    _PENALTY_FUNCTIONS = {\n        \"square\": _penalty_square,\n        \"l1\": _penalty_l1,\n        \"huber\": _penalty_huber,\n    }\n\n    # Determine which symbolic CTCS idx values already exist\n    # Symbolic augmented states are named \"_ctcs_aug_{i}\" where i is sequential\n    # and corresponds to sorted symbolic idx values (0, 1, 2, ...)\n    symbolic_ctcs_idx = []\n    for state in states:\n        if state.name.startswith(\"_ctcs_aug_\"):\n            try:\n                aug_idx = int(state.name.split(\"_\")[-1])\n                symbolic_ctcs_idx.append(aug_idx)\n            except (ValueError, IndexError):\n                pass\n\n    # Symbolic CTCS creates augmented states with sequential idx: 0, 1, 2, ...\n    # so max_symbolic_idx = len(symbolic_ctcs_idx) - 1 (or -1 if none exist)\n    max_symbolic_idx = len(symbolic_ctcs_idx) - 1 if symbolic_ctcs_idx else -1\n\n    # Build idx -&gt; augmented_state_slice mapping for existing symbolic CTCS\n    # Augmented states appear after regular states in the unified vector\n    # We'll determine the slice by finding the state in the states list\n    idx_to_aug_slice = {}\n    for state in states:\n        if state.name.startswith(\"_ctcs_aug_\"):\n            try:\n                aug_idx = int(state.name.split(\"_\")[-1])\n                # The actual idx value IS the sequential index for symbolic CTCS\n                # (they're created with idx 0, 1, 2, ... in sorted order)\n                idx_to_aug_slice[aug_idx] = state._slice\n            except (ValueError, IndexError, AttributeError):\n                pass\n\n    # Group BYOF CTCS constraints by idx (default to 0)\n    byof_ctcs_groups = {}\n    for ctcs_spec in byof.get(\"ctcs_constraints\", []):\n        idx = ctcs_spec.get(\"idx\", 0)\n        if idx not in byof_ctcs_groups:\n            byof_ctcs_groups[idx] = []\n        byof_ctcs_groups[idx].append(ctcs_spec)\n\n    # Validate that byof idx values don't create gaps\n    # All idx must form contiguous sequence: [0, 1, 2, ..., max_idx]\n    if byof_ctcs_groups:\n        all_idx = sorted(set(range(max_symbolic_idx + 1)) | set(byof_ctcs_groups.keys()))\n        expected_idx = list(range(len(all_idx)))\n        if all_idx != expected_idx:\n            raise ValueError(\n                f\"BYOF CTCS idx values create non-contiguous sequence. \"\n                f\"Symbolic CTCS has idx=[{', '.join(map(str, range(max_symbolic_idx + 1)))}], \"\n                f\"combined with byof idx={sorted(byof_ctcs_groups.keys())} gives {all_idx}. \"\n                f\"Expected contiguous sequence {expected_idx}. \"\n                f\"Byof idx must either match existing symbolic idx or be sequential after them.\"\n            )\n\n    # Process each idx group\n    for idx in sorted(byof_ctcs_groups.keys()):\n        specs = byof_ctcs_groups[idx]\n\n        # Collect all penalty functions for this idx\n        penalty_fns = []\n        for spec in specs:\n            constraint_fn = spec[\"constraint_fn\"]\n            penalty_spec = spec.get(\"penalty\", \"square\")\n            over_interval = spec.get(\"over\", None)  # Node interval (start, end) or None\n\n            if callable(penalty_spec):\n                penalty_func = penalty_spec\n            else:\n                penalty_func = _PENALTY_FUNCTIONS[penalty_spec]\n\n            # Create a combined constraint+penalty function\n            def _make_penalty_fn(cons_fn, pen_func, over):\n                \"\"\"Factory to capture constraint, penalty functions, and node interval.\n\n                Args:\n                    cons_fn: Constraint function (x, u, node, params) -&gt; scalar residual\n                    pen_func: Penalty function (residual) -&gt; penalty value\n                    over: Optional (start, end) tuple for conditional activation\n\n                Returns:\n                    Penalty function that conditionally activates based on node interval\n                \"\"\"\n\n                def penalty_fn(x, u, node, params):\n                    # Compute penalty for the constraint violation\n                    residual = cons_fn(x, u, node, params)\n                    penalty_value = pen_func(residual)\n\n                    # Apply conditional logic if over interval is specified\n                    if over is not None:\n                        start_node, end_node = over\n                        # Extract scalar from node (which may be array or scalar)\n                        # Keep as JAX array for tracing compatibility\n                        node_scalar = jnp.atleast_1d(node)[0]\n                        is_active = (start_node &lt;= node_scalar) &amp; (node_scalar &lt; end_node)\n\n                        # Use jax.lax.cond for JAX-traceable conditional evaluation\n                        # Penalty is active only when node is in [start, end)\n                        return cond(\n                            is_active,\n                            lambda _: penalty_value,\n                            lambda _: 0.0,\n                            operand=None,\n                        )\n                    else:\n                        # Always active if no interval specified\n                        return penalty_value\n\n                return penalty_fn\n\n            penalty_fns.append(_make_penalty_fn(constraint_fn, penalty_func, over_interval))\n\n        if idx in idx_to_aug_slice:\n            # This idx already exists from symbolic CTCS - add penalties to existing state\n            aug_slice = idx_to_aug_slice[idx]\n\n            def _make_ctcs_addition(orig_f, pen_fns, aug_sl):\n                \"\"\"Create dynamics that adds penalties to existing augmented state.\n\n                Args:\n                    orig_f: Original dynamics function\n                    pen_fns: List of penalty functions to add\n                    aug_sl: Slice of the augmented state to modify\n\n                Returns:\n                    Modified dynamics function\n                \"\"\"\n\n                def modified_f(x, u, node, params):\n                    xdot = orig_f(x, u, node, params)\n\n                    # Sum all penalties for this idx\n                    total_penalty = sum(pen_fn(x, u, node, params) for pen_fn in pen_fns)\n\n                    # Add to existing augmented state derivative\n                    current_deriv = xdot[aug_sl]\n                    xdot = xdot.at[aug_sl].set(current_deriv + total_penalty)\n\n                    return xdot\n\n                return modified_f\n\n            # Modify both optimization and propagation dynamics\n            dynamics.f = _make_ctcs_addition(dynamics.f, penalty_fns, aug_slice)\n            dynamics.A = jacfwd(dynamics.f, argnums=0)\n            dynamics.B = jacfwd(dynamics.f, argnums=1)\n\n            dynamics_prop.f = _make_ctcs_addition(dynamics_prop.f, penalty_fns, aug_slice)\n            dynamics_prop.A = jacfwd(dynamics_prop.f, argnums=0)\n            dynamics_prop.B = jacfwd(dynamics_prop.f, argnums=1)\n\n        else:\n            # New idx - create new augmented state\n            # Use bounds/initial from first spec in this group\n            first_spec = specs[0]\n            bounds = first_spec.get(\"bounds\", (0.0, 1e-4))\n            initial = first_spec.get(\"initial\", bounds[0])\n\n            def _make_ctcs_new_state(orig_f, pen_fns):\n                \"\"\"Create dynamics augmented with new CTCS state.\n\n                Args:\n                    orig_f: Original dynamics function\n                    pen_fns: List of penalty functions to sum\n\n                Returns:\n                    Augmented dynamics function\n                \"\"\"\n\n                def augmented_f(x, u, node, params):\n                    xdot = orig_f(x, u, node, params)\n\n                    # Sum all penalties for this new idx\n                    total_penalty = sum(pen_fn(x, u, node, params) for pen_fn in pen_fns)\n\n                    # Append as new augmented state derivative\n                    return jnp.concatenate([xdot, jnp.atleast_1d(total_penalty)])\n\n                return augmented_f\n\n            # Augment optimization dynamics\n            aug_f = _make_ctcs_new_state(dynamics.f, penalty_fns)\n            dynamics = Dynamics(\n                f=aug_f,\n                A=jacfwd(aug_f, argnums=0),\n                B=jacfwd(aug_f, argnums=1),\n            )\n\n            # Augment propagation dynamics\n            aug_f_prop = _make_ctcs_new_state(dynamics_prop.f, penalty_fns)\n            dynamics_prop = Dynamics(\n                f=aug_f_prop,\n                A=jacfwd(aug_f_prop, argnums=0),\n                B=jacfwd(aug_f_prop, argnums=1),\n            )\n\n            # Create State objects for the new augmented states\n            # This is necessary for CVXPy variable creation and other bookkeeping\n            from openscvx.symbolic.expr.state import State\n\n            # Create augmented state for optimization\n            aug_state = State(f\"_ctcs_aug_{idx}\", shape=(1,))\n            aug_state.min = np.array([bounds[0]])\n            aug_state.max = np.array([bounds[1]])\n            aug_state.initial = np.array([initial])\n            aug_state.final = [(\"free\", 0.0)]\n            aug_state.guess = np.full((N, 1), initial)\n\n            # Set _slice attribute for the new state\n            current_dim = x_unified.shape[0]\n            aug_state._slice = slice(current_dim, current_dim + 1)\n\n            # Append to states list (in-place modification visible to caller)\n            states.append(aug_state)\n\n            # Create augmented state for propagation\n            aug_state_prop = State(f\"_ctcs_aug_{idx}\", shape=(1,))\n            aug_state_prop.min = np.array([bounds[0]])\n            aug_state_prop.max = np.array([bounds[1]])\n            aug_state_prop.initial = np.array([initial])\n            aug_state_prop.final = [(\"free\", 0.0)]\n            aug_state_prop.guess = np.full((N, 1), initial)\n\n            # Set _slice attribute for the propagation state\n            current_dim_prop = x_prop_unified.shape[0]\n            aug_state_prop._slice = slice(current_dim_prop, current_dim_prop + 1)\n\n            # Append to states_prop list\n            states_prop.append(aug_state_prop)\n\n            # Add new augmented states to both unified state interfaces\n            x_unified.append(\n                min=bounds[0],\n                max=bounds[1],\n                guess=initial,\n                initial=initial,\n                final=0.0,\n                augmented=True,\n            )\n            x_prop_unified.append(\n                min=bounds[0],\n                max=bounds[1],\n                guess=initial,\n                initial=initial,\n                final=0.0,\n                augmented=True,\n            )\n\n    return dynamics, dynamics_prop, jax_constraints, x_unified, x_prop_unified\n</code></pre>"},{"location":"reference/expert/#openscvx.expert.validate_byof","title":"<code>validate_byof(byof: dict, states: List[State], n_x: int, n_u: int, N: int = None) -&gt; None</code>","text":"<p>Validate byof function signatures and shapes.</p> <p>Checks that user-provided functions have the correct signatures and return appropriate shapes. Performs validation before functions are used to provide clear error messages.</p> <p>Parameters:</p> Name Type Description Default <code>byof</code> <code>dict</code> <p>Dictionary of user-provided functions to validate</p> required <code>states</code> <code>List[State]</code> <p>List of State objects for determining expected shapes</p> required <code>n_x</code> <code>int</code> <p>Total dimension of the unified state vector</p> required <code>n_u</code> <code>int</code> <p>Total dimension of the unified control vector</p> required <code>N</code> <code>int</code> <p>Number of nodes in the trajectory (optional). If provided, validates node indices in nodal constraints.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any function has invalid signature or returns wrong shape</p> <code>TypeError</code> <p>If functions are not callable</p> Example <p>validate_byof(byof, states, n_x=10, n_u=3, N=50)  # Raises if invalid</p> Source code in <code>openscvx/expert/validation.py</code> <pre><code>def validate_byof(\n    byof: dict,\n    states: List[\"State\"],\n    n_x: int,\n    n_u: int,\n    N: int = None,\n) -&gt; None:\n    \"\"\"Validate byof function signatures and shapes.\n\n    Checks that user-provided functions have the correct signatures and return\n    appropriate shapes. Performs validation before functions are used to provide\n    clear error messages.\n\n    Args:\n        byof: Dictionary of user-provided functions to validate\n        states: List of State objects for determining expected shapes\n        n_x: Total dimension of the unified state vector\n        n_u: Total dimension of the unified control vector\n        N: Number of nodes in the trajectory (optional). If provided, validates\n            node indices in nodal constraints.\n\n    Raises:\n        ValueError: If any function has invalid signature or returns wrong shape\n        TypeError: If functions are not callable\n\n    Example:\n        &gt;&gt;&gt; validate_byof(byof, states, n_x=10, n_u=3, N=50)  # Raises if invalid\n    \"\"\"\n    import jax\n    import jax.numpy as jnp\n\n    # Validate byof keys\n    valid_keys = {\"dynamics\", \"nodal_constraints\", \"cross_nodal_constraints\", \"ctcs_constraints\"}\n    invalid_keys = set(byof.keys()) - valid_keys\n    if invalid_keys:\n        raise ValueError(f\"Unknown byof keys: {invalid_keys}. Valid keys: {valid_keys}\")\n\n    # Create dummy inputs for testing\n    dummy_x = jnp.zeros(n_x)\n    dummy_u = jnp.zeros(n_u)\n    dummy_node = 0\n    dummy_params = {}\n\n    # Validate dynamics functions\n    byof_dynamics = byof.get(\"dynamics\", {})\n    if byof_dynamics:\n        # Build mapping from state name to expected shape\n        state_shapes = {state.name: state.shape for state in states}\n\n        for state_name, fn in byof_dynamics.items():\n            if state_name not in state_shapes:\n                raise ValueError(\n                    f\"byof dynamics '{state_name}' does not match any state name. \"\n                    f\"Available states: {list(state_shapes.keys())}\"\n                )\n\n            if not callable(fn):\n                raise TypeError(f\"byof dynamics '{state_name}' must be callable, got {type(fn)}\")\n\n            # Check signature\n            sig = inspect.signature(fn)\n            if len(sig.parameters) != 4:\n                raise ValueError(\n                    f\"byof dynamics '{state_name}' must have signature f(x, u, node, params), \"\n                    f\"got {len(sig.parameters)} parameters: {list(sig.parameters.keys())}\"\n                )\n\n            # Test call and check output shape\n            try:\n                result = fn(dummy_x, dummy_u, dummy_node, dummy_params)\n            except Exception as e:\n                raise ValueError(\n                    f\"byof dynamics '{state_name}' failed on test call with \"\n                    f\"x.shape={dummy_x.shape}, u.shape={dummy_u.shape}: {e}\"\n                ) from e\n\n            expected_shape = state_shapes[state_name]\n            result_shape = jnp.asarray(result).shape\n            if result_shape != expected_shape:\n                raise ValueError(\n                    f\"byof dynamics '{state_name}' returned shape {result_shape}, \"\n                    f\"expected {expected_shape} (state '{state_name}' shape)\"\n                )\n\n            # Test that gradient works (JAX compatibility check)\n            try:\n                jax.grad(lambda x: jnp.sum(fn(x, dummy_u, dummy_node, dummy_params)))(dummy_x)\n            except Exception as e:\n                raise ValueError(\n                    f\"byof dynamics '{state_name}' is not differentiable with JAX. \"\n                    f\"Ensure the function uses JAX operations (jax.numpy, not numpy): {e}\"\n                ) from e\n\n    # Validate nodal constraints\n    for i, constraint_spec in enumerate(byof.get(\"nodal_constraints\", [])):\n        if not isinstance(constraint_spec, dict):\n            raise TypeError(\n                f\"byof nodal_constraints[{i}] must be a dict (NodalConstraintSpec), \"\n                f\"got {type(constraint_spec)}\"\n            )\n\n        if \"constraint_fn\" not in constraint_spec:\n            raise ValueError(f\"byof nodal_constraints[{i}] missing required key 'constraint_fn'\")\n\n        fn = constraint_spec[\"constraint_fn\"]\n        if not callable(fn):\n            raise TypeError(\n                f\"byof nodal_constraints[{i}]['constraint_fn'] must be callable, got {type(fn)}\"\n            )\n\n        # Check signature\n        sig = inspect.signature(fn)\n        if len(sig.parameters) != 4:\n            raise ValueError(\n                f\"byof nodal_constraints[{i}]['constraint_fn'] must have signature \"\n                f\"f(x, u, node, params), \"\n                f\"got {len(sig.parameters)} parameters: {list(sig.parameters.keys())}\"\n            )\n\n        # Test call\n        try:\n            result = fn(dummy_x, dummy_u, dummy_node, dummy_params)\n        except Exception as e:\n            raise ValueError(\n                f\"byof nodal_constraints[{i}]['constraint_fn'] failed on test call with \"\n                f\"x.shape={dummy_x.shape}, u.shape={dummy_u.shape}: {e}\"\n            ) from e\n\n        # Check that result is array-like (can be scalar or vector)\n        try:\n            result_array = jnp.asarray(result)\n        except Exception as e:\n            raise ValueError(\n                f\"byof nodal_constraints[{i}]['constraint_fn'] must return array-like value, \"\n                f\"got {type(result)}: {e}\"\n            ) from e\n\n        # Test gradient\n        try:\n            jax.grad(lambda x: jnp.sum(fn(x, dummy_u, dummy_node, dummy_params)))(dummy_x)\n        except Exception as e:\n            raise ValueError(\n                f\"byof nodal_constraints[{i}]['constraint_fn'] is not differentiable with JAX: {e}\"\n            ) from e\n\n        # Validate nodes if provided\n        if \"nodes\" in constraint_spec:\n            nodes = constraint_spec[\"nodes\"]\n            if not isinstance(nodes, (list, tuple)):\n                raise TypeError(\n                    f\"byof nodal_constraints[{i}]['nodes'] must be a list or tuple, \"\n                    f\"got {type(nodes)}\"\n                )\n            if len(nodes) == 0:\n                raise ValueError(f\"byof nodal_constraints[{i}]['nodes'] cannot be empty\")\n\n            # Validate node indices if N is provided\n            if N is not None:\n                for node in nodes:\n                    # Handle negative indices (e.g., -1 for last node)\n                    normalized_node = node if node &gt;= 0 else N + node\n                    # Validate range\n                    if not (0 &lt;= normalized_node &lt; N):\n                        raise ValueError(\n                            f\"byof nodal_constraints[{i}]['nodes'] contains invalid index {node} \"\n                            f\"(normalized: {normalized_node}). Valid range is [0, {N}) or \"\n                            f\"negative indices [-{N}, -1].\"\n                        )\n\n    # Validate cross-nodal constraints\n    dummy_X = jnp.zeros((10, n_x))  # Dummy trajectory with 10 nodes\n    dummy_U = jnp.zeros((10, n_u))\n\n    for i, fn in enumerate(byof.get(\"cross_nodal_constraints\", [])):\n        if not callable(fn):\n            raise TypeError(f\"byof cross_nodal_constraints[{i}] must be callable, got {type(fn)}\")\n\n        # Check signature\n        sig = inspect.signature(fn)\n        if len(sig.parameters) != 3:\n            raise ValueError(\n                f\"byof cross_nodal_constraints[{i}] must have signature f(X, U, params), \"\n                f\"got {len(sig.parameters)} parameters: {list(sig.parameters.keys())}\"\n            )\n\n        # Test call\n        try:\n            result = fn(dummy_X, dummy_U, dummy_params)\n        except Exception as e:\n            raise ValueError(\n                f\"byof cross_nodal_constraints[{i}] failed on test call with \"\n                f\"X.shape={dummy_X.shape}, U.shape={dummy_U.shape}: {e}\"\n            ) from e\n\n        # Check that result is array-like\n        try:\n            result_array = jnp.asarray(result)\n        except Exception as e:\n            raise ValueError(\n                f\"byof cross_nodal_constraints[{i}] must return array-like value, \"\n                f\"got {type(result)}: {e}\"\n            ) from e\n\n        # Test gradient\n        try:\n            jax.grad(lambda X: jnp.sum(fn(X, dummy_U, dummy_params)))(dummy_X)\n        except Exception as e:\n            raise ValueError(\n                f\"byof cross_nodal_constraints[{i}] is not differentiable with JAX: {e}\"\n            ) from e\n\n    # Validate CTCS constraints\n    for i, ctcs_spec in enumerate(byof.get(\"ctcs_constraints\", [])):\n        if not isinstance(ctcs_spec, dict):\n            raise TypeError(f\"byof ctcs_constraints[{i}] must be a dict, got {type(ctcs_spec)}\")\n\n        if \"constraint_fn\" not in ctcs_spec:\n            raise ValueError(f\"byof ctcs_constraints[{i}] missing required key 'constraint_fn'\")\n\n        fn = ctcs_spec[\"constraint_fn\"]\n        if not callable(fn):\n            raise TypeError(\n                f\"byof ctcs_constraints[{i}]['constraint_fn'] must be callable, got {type(fn)}\"\n            )\n\n        # Check signature\n        sig = inspect.signature(fn)\n        if len(sig.parameters) != 4:\n            raise ValueError(\n                f\"byof ctcs_constraints[{i}]['constraint_fn'] must have signature \"\n                f\"f(x, u, node, params), got {len(sig.parameters)} parameters: \"\n                f\"{list(sig.parameters.keys())}\"\n            )\n\n        # Test call\n        try:\n            result = fn(dummy_x, dummy_u, dummy_node, dummy_params)\n        except Exception as e:\n            raise ValueError(\n                f\"byof ctcs_constraints[{i}]['constraint_fn'] failed on test call: {e}\"\n            ) from e\n\n        # Check that result is scalar\n        result_array = jnp.asarray(result)\n        if result_array.shape != ():\n            raise ValueError(\n                f\"byof ctcs_constraints[{i}]['constraint_fn'] must return a scalar, \"\n                f\"got shape {result_array.shape}\"\n            )\n\n        # Test gradient\n        try:\n            jax.grad(lambda x: fn(x, dummy_u, dummy_node, dummy_params))(dummy_x)\n        except Exception as e:\n            raise ValueError(\n                f\"byof ctcs_constraints[{i}]['constraint_fn'] is not differentiable with JAX: {e}\"\n            ) from e\n\n        # Validate penalty function if provided\n        if \"penalty\" in ctcs_spec:\n            penalty_spec = ctcs_spec[\"penalty\"]\n            if callable(penalty_spec):\n                # Test custom penalty function\n                try:\n                    test_residual = jnp.array(0.5)\n                    penalty_result = penalty_spec(test_residual)\n                    jnp.asarray(penalty_result)\n                except Exception as e:\n                    raise ValueError(\n                        f\"byof ctcs_constraints[{i}]['penalty'] custom function failed: {e}\"\n                    ) from e\n            elif penalty_spec not in [\"square\", \"l1\", \"huber\"]:\n                raise ValueError(\n                    f\"byof ctcs_constraints[{i}]['penalty'] must be 'square', 'l1', 'huber', \"\n                    f\"or a callable, got {penalty_spec!r}\"\n                )\n\n        # Validate idx if provided\n        if \"idx\" in ctcs_spec:\n            idx = ctcs_spec[\"idx\"]\n            if not isinstance(idx, int):\n                raise TypeError(\n                    f\"byof ctcs_constraints[{i}]['idx'] must be an integer, got {type(idx)}\"\n                )\n            if idx &lt; 0:\n                raise ValueError(\n                    f\"byof ctcs_constraints[{i}]['idx'] must be non-negative, got {idx}\"\n                )\n\n        # Validate bounds if provided\n        if \"bounds\" in ctcs_spec:\n            bounds = ctcs_spec[\"bounds\"]\n            if not isinstance(bounds, (tuple, list)) or len(bounds) != 2:\n                raise ValueError(\n                    f\"byof ctcs_constraints[{i}]['bounds'] must be a (min, max) tuple, got {bounds}\"\n                )\n            if bounds[0] &gt; bounds[1]:\n                raise ValueError(\n                    f\"byof ctcs_constraints[{i}]['bounds'] min ({bounds[0]}) must be &lt;= \"\n                    f\"max ({bounds[1]})\"\n                )\n        else:\n            # Use default bounds for initial value validation\n            bounds = (0.0, 1e-4)\n\n        # Validate initial value is within bounds\n        if \"initial\" in ctcs_spec:\n            initial = ctcs_spec[\"initial\"]\n            if not (bounds[0] &lt;= initial &lt;= bounds[1]):\n                raise ValueError(\n                    f\"byof ctcs_constraints[{i}]['initial'] ({initial}) must be within \"\n                    f\"bounds [{bounds[0]}, {bounds[1]}]\"\n                )\n\n        # Validate over (node interval) if provided\n        if \"over\" in ctcs_spec:\n            over = ctcs_spec[\"over\"]\n            if not isinstance(over, (tuple, list)) or len(over) != 2:\n                raise ValueError(\n                    f\"byof ctcs_constraints[{i}]['over'] must be a (start, end) tuple, got {over}\"\n                )\n            start, end = over\n            if not isinstance(start, int) or not isinstance(end, int):\n                raise TypeError(\n                    f\"byof ctcs_constraints[{i}]['over'] indices must be integers, \"\n                    f\"got start={type(start)}, end={type(end)}\"\n                )\n            if start &gt;= end:\n                raise ValueError(\n                    f\"byof ctcs_constraints[{i}]['over'] start ({start}) must be &lt; end ({end})\"\n                )\n            if start &lt; 0:\n                raise ValueError(\n                    f\"byof ctcs_constraints[{i}]['over'] start ({start}) must be non-negative\"\n                )\n            # Validate against trajectory length if N is provided\n            if N is not None:\n                if end &gt; N:\n                    raise ValueError(\n                        f\"byof ctcs_constraints[{i}]['over'] end ({end}) exceeds \"\n                        f\"trajectory length ({N})\"\n                    )\n</code></pre>"},{"location":"reference/expert/byof/","title":"byof","text":"<p>Bring-Your-Own-Functions (BYOF) - Expert User Mode.</p> <p>This module provides type definitions and documentation for expert users who want to bypass the symbolic layer and directly provide raw JAX functions.</p> Important <p>The unified state/control vectors include ALL states/controls in the order they were provided, plus any augmented states from CTCS constraints. You are responsible for correct indexing. Consider inspecting the symbolic problem to understand the layout.</p> Warning <p>Constraint Sign Convention: All constraints follow g(x,u) &lt;= 0 convention. Return negative when satisfied, positive when violated. Example: for x &lt;= 10 return <code>x - 10</code>, for x &gt;= 5 return <code>5 - x</code>.</p> Function Signatures <p>All byof functions must be JAX-compatible (use jax.numpy, avoid side effects).</p> <ul> <li> <p>dynamics: <code>(x, u, node, params) -&gt; xdot_component</code></p> <ul> <li>x: Full unified state vector (1D array)</li> <li>u: Full unified control vector (1D array)</li> <li>node: Integer node index</li> <li>params: Dict of parameters</li> <li>Returns: State derivative component (array matching state shape)</li> </ul> </li> <li> <p>nodal_constraints: <code>(x, u, node, params) -&gt; residual</code></p> <ul> <li>Same arguments as dynamics</li> <li>Returns: Constraint residual (g &lt;= 0: negative=satisfied, positive=violated)</li> </ul> </li> <li> <p>cross_nodal_constraints: <code>(X, U, params) -&gt; residual</code></p> <ul> <li>X: State trajectory (N, n_x) where N is number of trajectory nodes,     n_x is unified state dimension</li> <li>U: Control trajectory (N, n_u) where N is number of trajectory nodes,     n_u is unified control dimension</li> <li>params: Dict of parameters</li> <li>Returns: Constraint residual (g &lt;= 0: negative=satisfied, positive=violated)</li> </ul> </li> <li> <p>ctcs constraint_fn: <code>(x, u, node, params) -&gt; scalar</code></p> <ul> <li>Same as nodal_constraints but MUST return scalar</li> <li>Returns: Constraint residual (g &lt;= 0: negative=satisfied, positive=violated)</li> </ul> </li> <li> <p>ctcs penalty: <code>(residual) -&gt; penalty_value</code></p> <ul> <li>residual: Scalar constraint residual</li> <li>Returns: Non-negative penalty value</li> </ul> </li> </ul> Example <p>Basic usage mixing symbolic and byof::</p> <pre><code>import jax.numpy as jnp\nimport openscvx as ox\nfrom openscvx import ByofSpec\n\n# Define states\nposition = ox.State(\"position\", shape=(2,))\nvelocity = ox.State(\"velocity\", shape=(1,))\ntheta = ox.Control(\"theta\", shape=(1,))\n\n# Unified state: [position[0], position[1], velocity[0], time, augmented...]\n# Unified control: [theta[0], time_dilation]\n\n# Tip: Use the .slice property on State/Control objects for cleaner,\n# more maintainable indexing instead of hardcoded indices.\nbyof: ByofSpec = {\n    \"nodal_constraints\": [\n        # Velocity bounds (applied to all nodes)\n        {\n            \"constraint_fn\": lambda x, u, node, params: x[velocity.slice][0] - 10.0,\n        },\n        {\n            \"constraint_fn\": lambda x, u, node, params: -x[velocity.slice][0],\n        },\n        # Velocity must be exactly 0 at start (selective enforcement)\n        {\n            \"constraint_fn\": lambda x, u, node, params: x[velocity.slice][0],\n            \"nodes\": [0],  # Only at first node\n        },\n    ],\n    \"ctcs_constraints\": [\n        {\n            \"constraint_fn\": lambda x, u, node, params: x[position.slice][0] - 10.0,\n            \"penalty\": \"square\",\n            \"bounds\": (0.0, 1e-4),\n        }\n    ],\n}\n\nproblem = ox.Problem(..., byof=byof)\n</code></pre>"},{"location":"reference/expert/byof/#openscvx.expert.byof.ByofSpec","title":"<code>ByofSpec</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Bring-Your-Own-Functions specification for expert users.</p> <p>Allows bypassing the symbolic layer and directly providing raw JAX functions. All fields are optional - you can mix symbolic and byof as needed.</p> Warning <p>You are responsible for:</p> <ul> <li>Correct indexing into unified state/control vectors</li> <li>Ensuring functions are JAX-compatible (use jax.numpy, no side effects)</li> <li>Ensuring functions are differentiable</li> <li>Following g(x,u) &lt;= 0 convention for constraints</li> </ul> Tip <p>Use the <code>.slice</code> property on State/Control objects for cleaner, more maintainable indexing instead of hardcoded indices. For example, use <code>x[velocity.slice]</code> instead of <code>x[2:3]</code>. The slice property is set after preprocessing and provides the correct indices into the unified state/control vectors.</p> <p>Attributes:</p> Name Type Description <code>dynamics</code> <code>dict[str, DynamicsFunction]</code> <p>Raw JAX functions for state derivatives. Maps state names to functions with signature <code>(x, u, node, params) -&gt; xdot_component</code>. States here should NOT appear in symbolic dynamics dict. You can mix: some states symbolic, some in byof.</p> <code>nodal_constraints</code> <code>List[NodalConstraintSpec]</code> <p>Point-wise constraints applied at specific nodes. Each item is a :class:<code>NodalConstraintSpec</code> dict with:</p> <ul> <li><code>func</code>: Constraint function <code>(x, u, node, params) -&gt; residual</code> (required)</li> <li><code>nodes</code>: List of node indices (optional, defaults to all nodes)</li> </ul> <p>Follows g(x,u) &lt;= 0 convention.</p> <code>cross_nodal_constraints</code> <code>List[CrossNodalConstraintFunction]</code> <p>Constraints coupling multiple nodes (smoothness, rate limits). Signature: <code>(X, U, params) -&gt; residual</code> where X is (N, n_x) and U is (N, n_u). N is the number of trajectory nodes, n_x is state dimension, n_u is control dimension. Follows g(X,U) &lt;= 0 convention.</p> <code>ctcs_constraints</code> <code>List[CtcsConstraintSpec]</code> <p>Continuous-time constraint satisfaction via dynamics augmentation. Each adds an augmented state accumulating violation penalties. See :class:<code>CtcsConstraintSpec</code> for details.</p> Example <p>Custom dynamics and constraints::</p> <pre><code>import jax.numpy as jnp\nimport openscvx as ox\nfrom openscvx import ByofSpec\n\n# Define states and controls\nposition = ox.State(\"position\", shape=(2,))\nvelocity = ox.State(\"velocity\", shape=(1,))\ntheta = ox.Control(\"theta\", shape=(1,))\n\n# Custom dynamics for one state using .slice property\ndef custom_velocity_dynamics(x, u, node, params):\n    # Use .slice property for clean indexing\n    return params[\"g\"] * jnp.cos(u[theta.slice][0])\n\nbyof: ByofSpec = {\n    \"dynamics\": {\n        \"velocity\": custom_velocity_dynamics,\n    },\n    \"nodal_constraints\": [\n        # Applied to all nodes (no \"nodes\" field)\n        {\n            \"constraint_fn\": lambda x, u, node, params: x[velocity.slice][0] - 10.0,\n        },\n        {\n            \"constraint_fn\": lambda x, u, node, params: -x[velocity.slice][0],\n        },\n        # Specify nodes for selective enforcement\n        {\n            \"constraint_fn\": lambda x, u, node, params: x[velocity.slice][0],\n            \"nodes\": [0],  # Velocity must be exactly 0 at start\n        },\n    ],\n    \"cross_nodal_constraints\": [\n        # Constrain total velocity across trajectory: sum(velocities) &gt;= 5\n        # X.shape = (N, n_x), extract velocity column using slice\n        lambda X, U, params: 5.0 - jnp.sum(X[:, velocity.slice]),\n    ],\n    \"ctcs_constraints\": [\n        {\n            \"constraint_fn\": lambda x, u, node, params: x[position.slice][0] - 5.0,\n            \"penalty\": \"square\",\n        }\n    ],\n}\n</code></pre> Source code in <code>openscvx/expert/byof.py</code> <pre><code>class ByofSpec(TypedDict, total=False):\n    \"\"\"Bring-Your-Own-Functions specification for expert users.\n\n    Allows bypassing the symbolic layer and directly providing raw JAX functions.\n    All fields are optional - you can mix symbolic and byof as needed.\n\n    Warning:\n        You are responsible for:\n\n        - Correct indexing into unified state/control vectors\n        - Ensuring functions are JAX-compatible (use jax.numpy, no side effects)\n        - Ensuring functions are differentiable\n        - Following g(x,u) &lt;= 0 convention for constraints\n\n    Tip:\n        Use the ``.slice`` property on State/Control objects for cleaner, more\n        maintainable indexing instead of hardcoded indices. For example, use\n        ``x[velocity.slice]`` instead of ``x[2:3]``. The slice property is set\n        after preprocessing and provides the correct indices into the unified\n        state/control vectors.\n\n    Attributes:\n        dynamics: Raw JAX functions for state derivatives. Maps state names to functions\n            with signature ``(x, u, node, params) -&gt; xdot_component``. States here should\n            NOT appear in symbolic dynamics dict. You can mix: some states symbolic,\n            some in byof.\n        nodal_constraints: Point-wise constraints applied at specific nodes.\n            Each item is a :class:`NodalConstraintSpec` dict with:\n\n            - ``func``: Constraint function ``(x, u, node, params) -&gt; residual`` (required)\n            - ``nodes``: List of node indices (optional, defaults to all nodes)\n\n            Follows g(x,u) &lt;= 0 convention.\n        cross_nodal_constraints: Constraints coupling multiple nodes (smoothness, rate limits).\n            Signature: ``(X, U, params) -&gt; residual`` where X is (N, n_x) and U is (N, n_u).\n            N is the number of trajectory nodes, n_x is state dimension, n_u is control dimension.\n            Follows g(X,U) &lt;= 0 convention.\n        ctcs_constraints: Continuous-time constraint satisfaction via dynamics augmentation.\n            Each adds an augmented state accumulating violation penalties.\n            See :class:`CtcsConstraintSpec` for details.\n\n    Example:\n        Custom dynamics and constraints::\n\n            import jax.numpy as jnp\n            import openscvx as ox\n            from openscvx import ByofSpec\n\n            # Define states and controls\n            position = ox.State(\"position\", shape=(2,))\n            velocity = ox.State(\"velocity\", shape=(1,))\n            theta = ox.Control(\"theta\", shape=(1,))\n\n            # Custom dynamics for one state using .slice property\n            def custom_velocity_dynamics(x, u, node, params):\n                # Use .slice property for clean indexing\n                return params[\"g\"] * jnp.cos(u[theta.slice][0])\n\n            byof: ByofSpec = {\n                \"dynamics\": {\n                    \"velocity\": custom_velocity_dynamics,\n                },\n                \"nodal_constraints\": [\n                    # Applied to all nodes (no \"nodes\" field)\n                    {\n                        \"constraint_fn\": lambda x, u, node, params: x[velocity.slice][0] - 10.0,\n                    },\n                    {\n                        \"constraint_fn\": lambda x, u, node, params: -x[velocity.slice][0],\n                    },\n                    # Specify nodes for selective enforcement\n                    {\n                        \"constraint_fn\": lambda x, u, node, params: x[velocity.slice][0],\n                        \"nodes\": [0],  # Velocity must be exactly 0 at start\n                    },\n                ],\n                \"cross_nodal_constraints\": [\n                    # Constrain total velocity across trajectory: sum(velocities) &gt;= 5\n                    # X.shape = (N, n_x), extract velocity column using slice\n                    lambda X, U, params: 5.0 - jnp.sum(X[:, velocity.slice]),\n                ],\n                \"ctcs_constraints\": [\n                    {\n                        \"constraint_fn\": lambda x, u, node, params: x[position.slice][0] - 5.0,\n                        \"penalty\": \"square\",\n                    }\n                ],\n            }\n    \"\"\"\n\n    dynamics: dict[str, DynamicsFunction]\n    nodal_constraints: List[NodalConstraintSpec]\n    cross_nodal_constraints: List[CrossNodalConstraintFunction]\n    ctcs_constraints: List[CtcsConstraintSpec]\n</code></pre>"},{"location":"reference/expert/byof/#openscvx.expert.byof.CtcsConstraintSpec","title":"<code>CtcsConstraintSpec</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Specification for CTCS (Continuous-Time Constraint Satisfaction) constraint.</p> <p>CTCS constraints are enforced by augmenting the dynamics with a penalty term that accumulates violations over time. Useful for path constraints that must be satisfied continuously, not just at discrete nodes.</p> <p>Attributes:</p> Name Type Description <code>constraint_fn</code> <code>CtcsConstraintFunction</code> <p>Function computing constraint residual with signature <code>(x, u, node, params) -&gt; scalar</code>. Must return scalar. Follows g(x,u) &lt;= 0 convention (negative = satisfied). Required field.</p> <code>penalty</code> <code>PenaltyFunction</code> <p>Penalty function for positive residuals (violations). Built-in options: \"square\" (max(r,0)^2, default), \"l1\" (max(r,0)), \"huber\" (Huber loss). Custom: Callable <code>(r) -&gt; penalty</code> (non-negative, differentiable).</p> <code>bounds</code> <code>Tuple[float, float]</code> <p>(min, max) bounds for augmented state accumulating penalties. Default: (0.0, 1e-4). Max acts as soft constraint on total violation.</p> <code>initial</code> <code>float</code> <p>Initial value for augmented state. Default: bounds[0] (usually 0.0).</p> <code>over</code> <code>Tuple[int, int]</code> <p>Node interval (start, end) where constraint is active. The constraint is enforced for nodes in [start, end). If omitted, constraint is active over all nodes. Matches symbolic <code>.over()</code> method behavior.</p> <code>idx</code> <code>int</code> <p>Constraint group index for sharing augmented states (default: 0). All CTCS constraints (symbolic and byof) with the same idx share a single augmented state. Their penalties are summed together. Use different idx values to track different types of violations separately.</p> Warning <p>If symbolic CTCS constraints exist with idx values [0, 1, 2], then byof idx must either:</p> <ul> <li>Match an existing idx (e.g., 0, 1, or 2) to add to that augmented state</li> <li>Be sequential after them (e.g., 3, 4, 5) to create new augmented states</li> </ul> <p>You cannot use idx values that create gaps (e.g., if symbolic has [0, 1], you cannot use byof idx=3 without also using idx=2).</p> Example <p>Enforce position[0] &lt;= 10.0 continuously::</p> <pre><code># Assuming position = ox.State(\"position\", shape=(2,))\nctcs_spec: CtcsConstraintSpec = {\n    \"constraint_fn\": lambda x, u, node, params: x[position.slice][0] - 10.0,\n    \"penalty\": \"square\",\n    \"bounds\": (0.0, 1e-4),\n    \"initial\": 0.0,\n    \"idx\": 0,  # Groups with other constraints having idx=0\n}\n</code></pre> <p>Enforce constraint only over specific node range::</p> <pre><code>ctcs_spec: CtcsConstraintSpec = {\n    \"constraint_fn\": lambda x, u, node, params: x[position.slice][0] - 10.0,\n    \"over\": (10, 50),  # Active only for nodes 10-49\n    \"penalty\": \"square\",\n}\n</code></pre> <p>Multiple constraints sharing an augmented state::</p> <pre><code># If symbolic CTCS already has idx=[0, 1], then:\n\nbyof = {\n    \"ctcs_constraints\": [\n        # Add to existing symbolic idx=0 augmented state\n        {\n            \"constraint_fn\": lambda x, u, node, params: x[pos.slice][0] - 10.0,\n            \"idx\": 0,  # Shares with symbolic idx=0\n        },\n        # Add to existing symbolic idx=1 augmented state\n        {\n            \"constraint_fn\": lambda x, u, node, params: x[vel.slice][0] - 5.0,\n            \"idx\": 1,  # Shares with symbolic idx=1\n        },\n        # Create NEW augmented state (sequential after symbolic)\n        {\n            \"constraint_fn\": lambda x, u, node, params: x[pos.slice][1] - 8.0,\n            \"idx\": 2,  # New state (symbolic has 0,1, so next is 2)\n        },\n    ]\n}\n</code></pre> Source code in <code>openscvx/expert/byof.py</code> <pre><code>class CtcsConstraintSpec(TypedDict, total=False):\n    \"\"\"Specification for CTCS (Continuous-Time Constraint Satisfaction) constraint.\n\n    CTCS constraints are enforced by augmenting the dynamics with a penalty term that\n    accumulates violations over time. Useful for path constraints that must be satisfied\n    continuously, not just at discrete nodes.\n\n    Attributes:\n        constraint_fn: Function computing constraint residual with signature\n            ``(x, u, node, params) -&gt; scalar``. Must return scalar.\n            Follows g(x,u) &lt;= 0 convention (negative = satisfied). Required field.\n        penalty: Penalty function for positive residuals (violations).\n            Built-in options: \"square\" (max(r,0)^2, default), \"l1\" (max(r,0)),\n            \"huber\" (Huber loss). Custom: Callable ``(r) -&gt; penalty`` (non-negative,\n            differentiable).\n        bounds: (min, max) bounds for augmented state accumulating penalties.\n            Default: (0.0, 1e-4). Max acts as soft constraint on total violation.\n        initial: Initial value for augmented state. Default: bounds[0] (usually 0.0).\n        over: Node interval (start, end) where constraint is active. The constraint\n            is enforced for nodes in [start, end). If omitted, constraint is active\n            over all nodes. Matches symbolic `.over()` method behavior.\n        idx: Constraint group index for sharing augmented states (default: 0).\n            All CTCS constraints (symbolic and byof) with the same idx share a single\n            augmented state. Their penalties are summed together. Use different idx values\n            to track different types of violations separately.\n\n    Warning:\n        If symbolic CTCS constraints exist with idx values [0, 1, 2], then byof idx **must** either:\n\n        - Match an existing idx (e.g., 0, 1, or 2) to add to that augmented state\n        - Be sequential after them (e.g., 3, 4, 5) to create new augmented states\n\n        You cannot use idx values that create gaps (e.g., if symbolic has [0, 1],\n        you cannot use byof idx=3 without also using idx=2).\n\n    Example:\n        Enforce position[0] &lt;= 10.0 continuously::\n\n            # Assuming position = ox.State(\"position\", shape=(2,))\n            ctcs_spec: CtcsConstraintSpec = {\n                \"constraint_fn\": lambda x, u, node, params: x[position.slice][0] - 10.0,\n                \"penalty\": \"square\",\n                \"bounds\": (0.0, 1e-4),\n                \"initial\": 0.0,\n                \"idx\": 0,  # Groups with other constraints having idx=0\n            }\n\n        Enforce constraint only over specific node range::\n\n            ctcs_spec: CtcsConstraintSpec = {\n                \"constraint_fn\": lambda x, u, node, params: x[position.slice][0] - 10.0,\n                \"over\": (10, 50),  # Active only for nodes 10-49\n                \"penalty\": \"square\",\n            }\n\n        Multiple constraints sharing an augmented state::\n\n            # If symbolic CTCS already has idx=[0, 1], then:\n\n            byof = {\n                \"ctcs_constraints\": [\n                    # Add to existing symbolic idx=0 augmented state\n                    {\n                        \"constraint_fn\": lambda x, u, node, params: x[pos.slice][0] - 10.0,\n                        \"idx\": 0,  # Shares with symbolic idx=0\n                    },\n                    # Add to existing symbolic idx=1 augmented state\n                    {\n                        \"constraint_fn\": lambda x, u, node, params: x[vel.slice][0] - 5.0,\n                        \"idx\": 1,  # Shares with symbolic idx=1\n                    },\n                    # Create NEW augmented state (sequential after symbolic)\n                    {\n                        \"constraint_fn\": lambda x, u, node, params: x[pos.slice][1] - 8.0,\n                        \"idx\": 2,  # New state (symbolic has 0,1, so next is 2)\n                    },\n                ]\n            }\n    \"\"\"\n\n    constraint_fn: CtcsConstraintFunction  # Required\n    penalty: PenaltyFunction\n    bounds: Tuple[float, float]\n    initial: float\n    over: Tuple[int, int]\n    idx: int\n</code></pre>"},{"location":"reference/expert/byof/#openscvx.expert.byof.NodalConstraintSpec","title":"<code>NodalConstraintSpec</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Specification for nodal constraint with optional node selection.</p> <p>Nodal constraints are point-wise constraints evaluated at specific trajectory nodes. By default, constraints apply to all nodes, but you can restrict enforcement to specific nodes for boundary conditions, waypoints, or computational efficiency.</p> <p>Attributes:</p> Name Type Description <code>constraint_fn</code> <code>NodalConstraintFunction</code> <p>Constraint function with signature <code>(x, u, node, params) -&gt; residual</code>. Follows g(x,u) &lt;= 0 convention (negative = satisfied). Required field.</p> <code>nodes</code> <code>List[int]</code> <p>List of integer node indices where constraint is enforced. If omitted, applies to all nodes. Negative indices supported (e.g., -1 for last). Optional field.</p> Example <p>Boundary constraint only at first and last nodes::</p> <pre><code>nodal_spec: NodalConstraintSpec = {\n    \"constraint_fn\": lambda x, u, node, params: x[velocity.slice][0],\n    \"nodes\": [0, -1],  # Only at start and end\n}\n</code></pre> <p>Waypoint constraint at middle of trajectory::</p> <pre><code>nodal_spec: NodalConstraintSpec = {\n    \"constraint_fn\": lambda x, u, node, params: jnp.linalg.norm(\n        x[position.slice] - jnp.array([5.0, 7.5])\n    ) - 0.1,\n    \"nodes\": [N // 2],\n}\n</code></pre> Source code in <code>openscvx/expert/byof.py</code> <pre><code>class NodalConstraintSpec(TypedDict, total=False):\n    \"\"\"Specification for nodal constraint with optional node selection.\n\n    Nodal constraints are point-wise constraints evaluated at specific trajectory nodes.\n    By default, constraints apply to all nodes, but you can restrict enforcement to\n    specific nodes for boundary conditions, waypoints, or computational efficiency.\n\n    Attributes:\n        constraint_fn: Constraint function with signature ``(x, u, node, params) -&gt; residual``.\n            Follows g(x,u) &lt;= 0 convention (negative = satisfied). Required field.\n        nodes: List of integer node indices where constraint is enforced.\n            If omitted, applies to all nodes. Negative indices supported (e.g., -1 for last).\n            Optional field.\n\n    Example:\n        Boundary constraint only at first and last nodes::\n\n            nodal_spec: NodalConstraintSpec = {\n                \"constraint_fn\": lambda x, u, node, params: x[velocity.slice][0],\n                \"nodes\": [0, -1],  # Only at start and end\n            }\n\n        Waypoint constraint at middle of trajectory::\n\n            nodal_spec: NodalConstraintSpec = {\n                \"constraint_fn\": lambda x, u, node, params: jnp.linalg.norm(\n                    x[position.slice] - jnp.array([5.0, 7.5])\n                ) - 0.1,\n                \"nodes\": [N // 2],\n            }\n    \"\"\"\n\n    constraint_fn: NodalConstraintFunction  # Required\n    nodes: List[int]\n</code></pre>"},{"location":"reference/expert/lowering/","title":"lowering","text":"<p>Lowering logic for bring-your-own-functions (byof).</p> <p>This module handles integration of user-provided JAX functions into the lowered problem representation, including dynamics splicing and constraint addition.</p>"},{"location":"reference/expert/lowering/#openscvx.expert.lowering.apply_byof","title":"<code>apply_byof(byof: dict, dynamics: Dynamics, dynamics_prop: Dynamics, jax_constraints: LoweredJaxConstraints, x_unified: UnifiedState, x_prop_unified: UnifiedState, u_unified: UnifiedState, states: List[State], states_prop: List[State], N: int) -&gt; Tuple[Dynamics, Dynamics, LoweredJaxConstraints, UnifiedState, UnifiedState]</code>","text":"<p>Apply bring-your-own-functions (byof) to augment lowered problem.</p> <p>Handles raw JAX functions provided by expert users, including: - dynamics: Raw JAX functions for specific state derivatives - nodal_constraints: Point-wise constraints at each node - cross_nodal_constraints: Constraints coupling multiple nodes - ctcs_constraints: Continuous-time constraint satisfaction via dynamics augmentation</p> <p>Parameters:</p> Name Type Description Default <code>byof</code> <code>dict</code> <p>Dict with keys \"dynamics\", \"nodal_constraints\", \"cross_nodal_constraints\", \"ctcs_constraints\"</p> required <code>dynamics</code> <code>Dynamics</code> <p>Lowered optimization dynamics to potentially augment</p> required <code>dynamics_prop</code> <code>Dynamics</code> <p>Lowered propagation dynamics to potentially augment</p> required <code>jax_constraints</code> <code>LoweredJaxConstraints</code> <p>Lowered JAX constraints to append to</p> required <code>x_unified</code> <code>UnifiedState</code> <p>Unified optimization state interface to potentially augment</p> required <code>x_prop_unified</code> <code>UnifiedState</code> <p>Unified propagation state interface to potentially augment</p> required <code>u_unified</code> <code>UnifiedState</code> <p>Unified control interface for validation</p> required <code>states</code> <code>List[State]</code> <p>List of State objects for optimization (with _slice attributes)</p> required <code>states_prop</code> <code>List[State]</code> <p>List of State objects for propagation (with _slice attributes)</p> required <code>N</code> <code>int</code> <p>Number of nodes in the trajectory</p> required <p>Returns:</p> Type Description <code>Tuple[Dynamics, Dynamics, LoweredJaxConstraints, UnifiedState, UnifiedState]</code> <p>Tuple of (dynamics, dynamics_prop, jax_constraints, x_unified, x_prop_unified)</p> Example <p>dynamics, dynamics_prop, constraints, x_unified, x_prop_unified = apply_byof( ...     byof, dynamics, dynamics_prop, jax_constraints, ...     x_unified, x_prop_unified, u_unified, states, states_prop, N ... )</p> Source code in <code>openscvx/expert/lowering.py</code> <pre><code>def apply_byof(\n    byof: dict,\n    dynamics: Dynamics,\n    dynamics_prop: Dynamics,\n    jax_constraints: LoweredJaxConstraints,\n    x_unified: \"UnifiedState\",\n    x_prop_unified: \"UnifiedState\",\n    u_unified: \"UnifiedState\",\n    states: List[\"State\"],\n    states_prop: List[\"State\"],\n    N: int,\n) -&gt; Tuple[Dynamics, Dynamics, LoweredJaxConstraints, \"UnifiedState\", \"UnifiedState\"]:\n    \"\"\"Apply bring-your-own-functions (byof) to augment lowered problem.\n\n    Handles raw JAX functions provided by expert users, including:\n    - dynamics: Raw JAX functions for specific state derivatives\n    - nodal_constraints: Point-wise constraints at each node\n    - cross_nodal_constraints: Constraints coupling multiple nodes\n    - ctcs_constraints: Continuous-time constraint satisfaction via dynamics augmentation\n\n    Args:\n        byof: Dict with keys \"dynamics\", \"nodal_constraints\", \"cross_nodal_constraints\",\n            \"ctcs_constraints\"\n        dynamics: Lowered optimization dynamics to potentially augment\n        dynamics_prop: Lowered propagation dynamics to potentially augment\n        jax_constraints: Lowered JAX constraints to append to\n        x_unified: Unified optimization state interface to potentially augment\n        x_prop_unified: Unified propagation state interface to potentially augment\n        u_unified: Unified control interface for validation\n        states: List of State objects for optimization (with _slice attributes)\n        states_prop: List of State objects for propagation (with _slice attributes)\n        N: Number of nodes in the trajectory\n\n    Returns:\n        Tuple of (dynamics, dynamics_prop, jax_constraints, x_unified, x_prop_unified)\n\n    Example:\n        &gt;&gt;&gt; dynamics, dynamics_prop, constraints, x_unified, x_prop_unified = apply_byof(\n        ...     byof, dynamics, dynamics_prop, jax_constraints,\n        ...     x_unified, x_prop_unified, u_unified, states, states_prop, N\n        ... )\n    \"\"\"\n\n    # Note: byof validation happens earlier in Problem.__init__ to fail fast\n    # Handle byof dynamics by splicing in raw JAX functions at the correct slices\n    byof_dynamics = byof.get(\"dynamics\", {})\n    if byof_dynamics:\n        # Build mapping from state name to slice for optimization states\n        state_slices = {state.name: state._slice for state in states}\n        state_slices_prop = {state.name: state._slice for state in states_prop}\n\n        def _make_composite_dynamics(orig_f, byof_fns, slices_map):\n            \"\"\"Create composite dynamics combining symbolic and byof state derivatives.\n\n            This factory splices user-provided byof dynamics into the unified dynamics\n            function at the appropriate slice indices, replacing the symbolic dynamics\n            for specific states while preserving the rest.\n\n            Args:\n                orig_f: Original unified dynamics (x, u, node, params) -&gt; xdot\n                byof_fns: Dict mapping state names to byof dynamics functions\n                slices_map: Dict mapping state names to slice objects for indexing\n\n            Returns:\n                Composite dynamics function with byof derivatives spliced in\n            \"\"\"\n\n            def composite_f(x, u, node, params):\n                # Start with symbolic/default dynamics for all states\n                xdot = orig_f(x, u, node, params)\n\n                # Splice in byof dynamics for specific states\n                for state_name, byof_fn in byof_fns.items():\n                    sl = slices_map[state_name]\n                    # Replace the derivative for this state with the byof result\n                    xdot = xdot.at[sl].set(byof_fn(x, u, node, params))\n\n                return xdot\n\n            return composite_f\n\n        # Create composite optimization dynamics\n        composite_f = _make_composite_dynamics(dynamics.f, byof_dynamics, state_slices)\n        dynamics = Dynamics(\n            f=composite_f,\n            A=jacfwd(composite_f, argnums=0),\n            B=jacfwd(composite_f, argnums=1),\n        )\n\n        # Create composite propagation dynamics\n        composite_f_prop = _make_composite_dynamics(\n            dynamics_prop.f, byof_dynamics, state_slices_prop\n        )\n        dynamics_prop = Dynamics(\n            f=composite_f_prop,\n            A=jacfwd(composite_f_prop, argnums=0),\n            B=jacfwd(composite_f_prop, argnums=1),\n        )\n\n    # Handle nodal constraints\n    # Note: Validation happens earlier in Problem.__init__ via validate_byof\n    for constraint_spec in byof.get(\"nodal_constraints\", []):\n        fn = constraint_spec[\"constraint_fn\"]\n        nodes = constraint_spec.get(\"nodes\", list(range(N)))  # Default: all nodes\n\n        # Normalize negative node indices (validation already done in validate_byof)\n        normalized_nodes = [node if node &gt;= 0 else N + node for node in nodes]\n\n        constraint = LoweredNodalConstraint(\n            func=jax.vmap(fn, in_axes=(0, 0, None, None)),\n            grad_g_x=jax.vmap(jacfwd(fn, argnums=0), in_axes=(0, 0, None, None)),\n            grad_g_u=jax.vmap(jacfwd(fn, argnums=1), in_axes=(0, 0, None, None)),\n            nodes=normalized_nodes,\n        )\n        jax_constraints.nodal.append(constraint)\n\n    # Handle cross-nodal constraints\n    for fn in byof.get(\"cross_nodal_constraints\", []):\n        constraint = LoweredCrossNodeConstraint(\n            func=fn,\n            grad_g_X=jacfwd(fn, argnums=0),\n            grad_g_U=jacfwd(fn, argnums=1),\n        )\n        jax_constraints.cross_node.append(constraint)\n\n    # Handle CTCS constraints by augmenting dynamics\n    # Built-in penalty functions\n    def _penalty_square(r):\n        return jnp.maximum(r, 0.0) ** 2\n\n    def _penalty_l1(r):\n        return jnp.maximum(r, 0.0)\n\n    def _penalty_huber(r, delta=1.0):\n        abs_r = jnp.maximum(r, 0.0)\n        return jnp.where(abs_r &lt;= delta, 0.5 * abs_r**2, delta * (abs_r - 0.5 * delta))\n\n    _PENALTY_FUNCTIONS = {\n        \"square\": _penalty_square,\n        \"l1\": _penalty_l1,\n        \"huber\": _penalty_huber,\n    }\n\n    # Determine which symbolic CTCS idx values already exist\n    # Symbolic augmented states are named \"_ctcs_aug_{i}\" where i is sequential\n    # and corresponds to sorted symbolic idx values (0, 1, 2, ...)\n    symbolic_ctcs_idx = []\n    for state in states:\n        if state.name.startswith(\"_ctcs_aug_\"):\n            try:\n                aug_idx = int(state.name.split(\"_\")[-1])\n                symbolic_ctcs_idx.append(aug_idx)\n            except (ValueError, IndexError):\n                pass\n\n    # Symbolic CTCS creates augmented states with sequential idx: 0, 1, 2, ...\n    # so max_symbolic_idx = len(symbolic_ctcs_idx) - 1 (or -1 if none exist)\n    max_symbolic_idx = len(symbolic_ctcs_idx) - 1 if symbolic_ctcs_idx else -1\n\n    # Build idx -&gt; augmented_state_slice mapping for existing symbolic CTCS\n    # Augmented states appear after regular states in the unified vector\n    # We'll determine the slice by finding the state in the states list\n    idx_to_aug_slice = {}\n    for state in states:\n        if state.name.startswith(\"_ctcs_aug_\"):\n            try:\n                aug_idx = int(state.name.split(\"_\")[-1])\n                # The actual idx value IS the sequential index for symbolic CTCS\n                # (they're created with idx 0, 1, 2, ... in sorted order)\n                idx_to_aug_slice[aug_idx] = state._slice\n            except (ValueError, IndexError, AttributeError):\n                pass\n\n    # Group BYOF CTCS constraints by idx (default to 0)\n    byof_ctcs_groups = {}\n    for ctcs_spec in byof.get(\"ctcs_constraints\", []):\n        idx = ctcs_spec.get(\"idx\", 0)\n        if idx not in byof_ctcs_groups:\n            byof_ctcs_groups[idx] = []\n        byof_ctcs_groups[idx].append(ctcs_spec)\n\n    # Validate that byof idx values don't create gaps\n    # All idx must form contiguous sequence: [0, 1, 2, ..., max_idx]\n    if byof_ctcs_groups:\n        all_idx = sorted(set(range(max_symbolic_idx + 1)) | set(byof_ctcs_groups.keys()))\n        expected_idx = list(range(len(all_idx)))\n        if all_idx != expected_idx:\n            raise ValueError(\n                f\"BYOF CTCS idx values create non-contiguous sequence. \"\n                f\"Symbolic CTCS has idx=[{', '.join(map(str, range(max_symbolic_idx + 1)))}], \"\n                f\"combined with byof idx={sorted(byof_ctcs_groups.keys())} gives {all_idx}. \"\n                f\"Expected contiguous sequence {expected_idx}. \"\n                f\"Byof idx must either match existing symbolic idx or be sequential after them.\"\n            )\n\n    # Process each idx group\n    for idx in sorted(byof_ctcs_groups.keys()):\n        specs = byof_ctcs_groups[idx]\n\n        # Collect all penalty functions for this idx\n        penalty_fns = []\n        for spec in specs:\n            constraint_fn = spec[\"constraint_fn\"]\n            penalty_spec = spec.get(\"penalty\", \"square\")\n            over_interval = spec.get(\"over\", None)  # Node interval (start, end) or None\n\n            if callable(penalty_spec):\n                penalty_func = penalty_spec\n            else:\n                penalty_func = _PENALTY_FUNCTIONS[penalty_spec]\n\n            # Create a combined constraint+penalty function\n            def _make_penalty_fn(cons_fn, pen_func, over):\n                \"\"\"Factory to capture constraint, penalty functions, and node interval.\n\n                Args:\n                    cons_fn: Constraint function (x, u, node, params) -&gt; scalar residual\n                    pen_func: Penalty function (residual) -&gt; penalty value\n                    over: Optional (start, end) tuple for conditional activation\n\n                Returns:\n                    Penalty function that conditionally activates based on node interval\n                \"\"\"\n\n                def penalty_fn(x, u, node, params):\n                    # Compute penalty for the constraint violation\n                    residual = cons_fn(x, u, node, params)\n                    penalty_value = pen_func(residual)\n\n                    # Apply conditional logic if over interval is specified\n                    if over is not None:\n                        start_node, end_node = over\n                        # Extract scalar from node (which may be array or scalar)\n                        # Keep as JAX array for tracing compatibility\n                        node_scalar = jnp.atleast_1d(node)[0]\n                        is_active = (start_node &lt;= node_scalar) &amp; (node_scalar &lt; end_node)\n\n                        # Use jax.lax.cond for JAX-traceable conditional evaluation\n                        # Penalty is active only when node is in [start, end)\n                        return cond(\n                            is_active,\n                            lambda _: penalty_value,\n                            lambda _: 0.0,\n                            operand=None,\n                        )\n                    else:\n                        # Always active if no interval specified\n                        return penalty_value\n\n                return penalty_fn\n\n            penalty_fns.append(_make_penalty_fn(constraint_fn, penalty_func, over_interval))\n\n        if idx in idx_to_aug_slice:\n            # This idx already exists from symbolic CTCS - add penalties to existing state\n            aug_slice = idx_to_aug_slice[idx]\n\n            def _make_ctcs_addition(orig_f, pen_fns, aug_sl):\n                \"\"\"Create dynamics that adds penalties to existing augmented state.\n\n                Args:\n                    orig_f: Original dynamics function\n                    pen_fns: List of penalty functions to add\n                    aug_sl: Slice of the augmented state to modify\n\n                Returns:\n                    Modified dynamics function\n                \"\"\"\n\n                def modified_f(x, u, node, params):\n                    xdot = orig_f(x, u, node, params)\n\n                    # Sum all penalties for this idx\n                    total_penalty = sum(pen_fn(x, u, node, params) for pen_fn in pen_fns)\n\n                    # Add to existing augmented state derivative\n                    current_deriv = xdot[aug_sl]\n                    xdot = xdot.at[aug_sl].set(current_deriv + total_penalty)\n\n                    return xdot\n\n                return modified_f\n\n            # Modify both optimization and propagation dynamics\n            dynamics.f = _make_ctcs_addition(dynamics.f, penalty_fns, aug_slice)\n            dynamics.A = jacfwd(dynamics.f, argnums=0)\n            dynamics.B = jacfwd(dynamics.f, argnums=1)\n\n            dynamics_prop.f = _make_ctcs_addition(dynamics_prop.f, penalty_fns, aug_slice)\n            dynamics_prop.A = jacfwd(dynamics_prop.f, argnums=0)\n            dynamics_prop.B = jacfwd(dynamics_prop.f, argnums=1)\n\n        else:\n            # New idx - create new augmented state\n            # Use bounds/initial from first spec in this group\n            first_spec = specs[0]\n            bounds = first_spec.get(\"bounds\", (0.0, 1e-4))\n            initial = first_spec.get(\"initial\", bounds[0])\n\n            def _make_ctcs_new_state(orig_f, pen_fns):\n                \"\"\"Create dynamics augmented with new CTCS state.\n\n                Args:\n                    orig_f: Original dynamics function\n                    pen_fns: List of penalty functions to sum\n\n                Returns:\n                    Augmented dynamics function\n                \"\"\"\n\n                def augmented_f(x, u, node, params):\n                    xdot = orig_f(x, u, node, params)\n\n                    # Sum all penalties for this new idx\n                    total_penalty = sum(pen_fn(x, u, node, params) for pen_fn in pen_fns)\n\n                    # Append as new augmented state derivative\n                    return jnp.concatenate([xdot, jnp.atleast_1d(total_penalty)])\n\n                return augmented_f\n\n            # Augment optimization dynamics\n            aug_f = _make_ctcs_new_state(dynamics.f, penalty_fns)\n            dynamics = Dynamics(\n                f=aug_f,\n                A=jacfwd(aug_f, argnums=0),\n                B=jacfwd(aug_f, argnums=1),\n            )\n\n            # Augment propagation dynamics\n            aug_f_prop = _make_ctcs_new_state(dynamics_prop.f, penalty_fns)\n            dynamics_prop = Dynamics(\n                f=aug_f_prop,\n                A=jacfwd(aug_f_prop, argnums=0),\n                B=jacfwd(aug_f_prop, argnums=1),\n            )\n\n            # Create State objects for the new augmented states\n            # This is necessary for CVXPy variable creation and other bookkeeping\n            from openscvx.symbolic.expr.state import State\n\n            # Create augmented state for optimization\n            aug_state = State(f\"_ctcs_aug_{idx}\", shape=(1,))\n            aug_state.min = np.array([bounds[0]])\n            aug_state.max = np.array([bounds[1]])\n            aug_state.initial = np.array([initial])\n            aug_state.final = [(\"free\", 0.0)]\n            aug_state.guess = np.full((N, 1), initial)\n\n            # Set _slice attribute for the new state\n            current_dim = x_unified.shape[0]\n            aug_state._slice = slice(current_dim, current_dim + 1)\n\n            # Append to states list (in-place modification visible to caller)\n            states.append(aug_state)\n\n            # Create augmented state for propagation\n            aug_state_prop = State(f\"_ctcs_aug_{idx}\", shape=(1,))\n            aug_state_prop.min = np.array([bounds[0]])\n            aug_state_prop.max = np.array([bounds[1]])\n            aug_state_prop.initial = np.array([initial])\n            aug_state_prop.final = [(\"free\", 0.0)]\n            aug_state_prop.guess = np.full((N, 1), initial)\n\n            # Set _slice attribute for the propagation state\n            current_dim_prop = x_prop_unified.shape[0]\n            aug_state_prop._slice = slice(current_dim_prop, current_dim_prop + 1)\n\n            # Append to states_prop list\n            states_prop.append(aug_state_prop)\n\n            # Add new augmented states to both unified state interfaces\n            x_unified.append(\n                min=bounds[0],\n                max=bounds[1],\n                guess=initial,\n                initial=initial,\n                final=0.0,\n                augmented=True,\n            )\n            x_prop_unified.append(\n                min=bounds[0],\n                max=bounds[1],\n                guess=initial,\n                initial=initial,\n                final=0.0,\n                augmented=True,\n            )\n\n    return dynamics, dynamics_prop, jax_constraints, x_unified, x_prop_unified\n</code></pre>"},{"location":"reference/expert/validation/","title":"validation","text":"<p>Validation for bring-your-own-functions (byof).</p> <p>This module provides validation for user-provided JAX functions in expert mode, checking signatures, shapes, and differentiability before use.</p>"},{"location":"reference/expert/validation/#openscvx.expert.validation.validate_byof","title":"<code>validate_byof(byof: dict, states: List[State], n_x: int, n_u: int, N: int = None) -&gt; None</code>","text":"<p>Validate byof function signatures and shapes.</p> <p>Checks that user-provided functions have the correct signatures and return appropriate shapes. Performs validation before functions are used to provide clear error messages.</p> <p>Parameters:</p> Name Type Description Default <code>byof</code> <code>dict</code> <p>Dictionary of user-provided functions to validate</p> required <code>states</code> <code>List[State]</code> <p>List of State objects for determining expected shapes</p> required <code>n_x</code> <code>int</code> <p>Total dimension of the unified state vector</p> required <code>n_u</code> <code>int</code> <p>Total dimension of the unified control vector</p> required <code>N</code> <code>int</code> <p>Number of nodes in the trajectory (optional). If provided, validates node indices in nodal constraints.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any function has invalid signature or returns wrong shape</p> <code>TypeError</code> <p>If functions are not callable</p> Example <p>validate_byof(byof, states, n_x=10, n_u=3, N=50)  # Raises if invalid</p> Source code in <code>openscvx/expert/validation.py</code> <pre><code>def validate_byof(\n    byof: dict,\n    states: List[\"State\"],\n    n_x: int,\n    n_u: int,\n    N: int = None,\n) -&gt; None:\n    \"\"\"Validate byof function signatures and shapes.\n\n    Checks that user-provided functions have the correct signatures and return\n    appropriate shapes. Performs validation before functions are used to provide\n    clear error messages.\n\n    Args:\n        byof: Dictionary of user-provided functions to validate\n        states: List of State objects for determining expected shapes\n        n_x: Total dimension of the unified state vector\n        n_u: Total dimension of the unified control vector\n        N: Number of nodes in the trajectory (optional). If provided, validates\n            node indices in nodal constraints.\n\n    Raises:\n        ValueError: If any function has invalid signature or returns wrong shape\n        TypeError: If functions are not callable\n\n    Example:\n        &gt;&gt;&gt; validate_byof(byof, states, n_x=10, n_u=3, N=50)  # Raises if invalid\n    \"\"\"\n    import jax\n    import jax.numpy as jnp\n\n    # Validate byof keys\n    valid_keys = {\"dynamics\", \"nodal_constraints\", \"cross_nodal_constraints\", \"ctcs_constraints\"}\n    invalid_keys = set(byof.keys()) - valid_keys\n    if invalid_keys:\n        raise ValueError(f\"Unknown byof keys: {invalid_keys}. Valid keys: {valid_keys}\")\n\n    # Create dummy inputs for testing\n    dummy_x = jnp.zeros(n_x)\n    dummy_u = jnp.zeros(n_u)\n    dummy_node = 0\n    dummy_params = {}\n\n    # Validate dynamics functions\n    byof_dynamics = byof.get(\"dynamics\", {})\n    if byof_dynamics:\n        # Build mapping from state name to expected shape\n        state_shapes = {state.name: state.shape for state in states}\n\n        for state_name, fn in byof_dynamics.items():\n            if state_name not in state_shapes:\n                raise ValueError(\n                    f\"byof dynamics '{state_name}' does not match any state name. \"\n                    f\"Available states: {list(state_shapes.keys())}\"\n                )\n\n            if not callable(fn):\n                raise TypeError(f\"byof dynamics '{state_name}' must be callable, got {type(fn)}\")\n\n            # Check signature\n            sig = inspect.signature(fn)\n            if len(sig.parameters) != 4:\n                raise ValueError(\n                    f\"byof dynamics '{state_name}' must have signature f(x, u, node, params), \"\n                    f\"got {len(sig.parameters)} parameters: {list(sig.parameters.keys())}\"\n                )\n\n            # Test call and check output shape\n            try:\n                result = fn(dummy_x, dummy_u, dummy_node, dummy_params)\n            except Exception as e:\n                raise ValueError(\n                    f\"byof dynamics '{state_name}' failed on test call with \"\n                    f\"x.shape={dummy_x.shape}, u.shape={dummy_u.shape}: {e}\"\n                ) from e\n\n            expected_shape = state_shapes[state_name]\n            result_shape = jnp.asarray(result).shape\n            if result_shape != expected_shape:\n                raise ValueError(\n                    f\"byof dynamics '{state_name}' returned shape {result_shape}, \"\n                    f\"expected {expected_shape} (state '{state_name}' shape)\"\n                )\n\n            # Test that gradient works (JAX compatibility check)\n            try:\n                jax.grad(lambda x: jnp.sum(fn(x, dummy_u, dummy_node, dummy_params)))(dummy_x)\n            except Exception as e:\n                raise ValueError(\n                    f\"byof dynamics '{state_name}' is not differentiable with JAX. \"\n                    f\"Ensure the function uses JAX operations (jax.numpy, not numpy): {e}\"\n                ) from e\n\n    # Validate nodal constraints\n    for i, constraint_spec in enumerate(byof.get(\"nodal_constraints\", [])):\n        if not isinstance(constraint_spec, dict):\n            raise TypeError(\n                f\"byof nodal_constraints[{i}] must be a dict (NodalConstraintSpec), \"\n                f\"got {type(constraint_spec)}\"\n            )\n\n        if \"constraint_fn\" not in constraint_spec:\n            raise ValueError(f\"byof nodal_constraints[{i}] missing required key 'constraint_fn'\")\n\n        fn = constraint_spec[\"constraint_fn\"]\n        if not callable(fn):\n            raise TypeError(\n                f\"byof nodal_constraints[{i}]['constraint_fn'] must be callable, got {type(fn)}\"\n            )\n\n        # Check signature\n        sig = inspect.signature(fn)\n        if len(sig.parameters) != 4:\n            raise ValueError(\n                f\"byof nodal_constraints[{i}]['constraint_fn'] must have signature \"\n                f\"f(x, u, node, params), \"\n                f\"got {len(sig.parameters)} parameters: {list(sig.parameters.keys())}\"\n            )\n\n        # Test call\n        try:\n            result = fn(dummy_x, dummy_u, dummy_node, dummy_params)\n        except Exception as e:\n            raise ValueError(\n                f\"byof nodal_constraints[{i}]['constraint_fn'] failed on test call with \"\n                f\"x.shape={dummy_x.shape}, u.shape={dummy_u.shape}: {e}\"\n            ) from e\n\n        # Check that result is array-like (can be scalar or vector)\n        try:\n            result_array = jnp.asarray(result)\n        except Exception as e:\n            raise ValueError(\n                f\"byof nodal_constraints[{i}]['constraint_fn'] must return array-like value, \"\n                f\"got {type(result)}: {e}\"\n            ) from e\n\n        # Test gradient\n        try:\n            jax.grad(lambda x: jnp.sum(fn(x, dummy_u, dummy_node, dummy_params)))(dummy_x)\n        except Exception as e:\n            raise ValueError(\n                f\"byof nodal_constraints[{i}]['constraint_fn'] is not differentiable with JAX: {e}\"\n            ) from e\n\n        # Validate nodes if provided\n        if \"nodes\" in constraint_spec:\n            nodes = constraint_spec[\"nodes\"]\n            if not isinstance(nodes, (list, tuple)):\n                raise TypeError(\n                    f\"byof nodal_constraints[{i}]['nodes'] must be a list or tuple, \"\n                    f\"got {type(nodes)}\"\n                )\n            if len(nodes) == 0:\n                raise ValueError(f\"byof nodal_constraints[{i}]['nodes'] cannot be empty\")\n\n            # Validate node indices if N is provided\n            if N is not None:\n                for node in nodes:\n                    # Handle negative indices (e.g., -1 for last node)\n                    normalized_node = node if node &gt;= 0 else N + node\n                    # Validate range\n                    if not (0 &lt;= normalized_node &lt; N):\n                        raise ValueError(\n                            f\"byof nodal_constraints[{i}]['nodes'] contains invalid index {node} \"\n                            f\"(normalized: {normalized_node}). Valid range is [0, {N}) or \"\n                            f\"negative indices [-{N}, -1].\"\n                        )\n\n    # Validate cross-nodal constraints\n    dummy_X = jnp.zeros((10, n_x))  # Dummy trajectory with 10 nodes\n    dummy_U = jnp.zeros((10, n_u))\n\n    for i, fn in enumerate(byof.get(\"cross_nodal_constraints\", [])):\n        if not callable(fn):\n            raise TypeError(f\"byof cross_nodal_constraints[{i}] must be callable, got {type(fn)}\")\n\n        # Check signature\n        sig = inspect.signature(fn)\n        if len(sig.parameters) != 3:\n            raise ValueError(\n                f\"byof cross_nodal_constraints[{i}] must have signature f(X, U, params), \"\n                f\"got {len(sig.parameters)} parameters: {list(sig.parameters.keys())}\"\n            )\n\n        # Test call\n        try:\n            result = fn(dummy_X, dummy_U, dummy_params)\n        except Exception as e:\n            raise ValueError(\n                f\"byof cross_nodal_constraints[{i}] failed on test call with \"\n                f\"X.shape={dummy_X.shape}, U.shape={dummy_U.shape}: {e}\"\n            ) from e\n\n        # Check that result is array-like\n        try:\n            result_array = jnp.asarray(result)\n        except Exception as e:\n            raise ValueError(\n                f\"byof cross_nodal_constraints[{i}] must return array-like value, \"\n                f\"got {type(result)}: {e}\"\n            ) from e\n\n        # Test gradient\n        try:\n            jax.grad(lambda X: jnp.sum(fn(X, dummy_U, dummy_params)))(dummy_X)\n        except Exception as e:\n            raise ValueError(\n                f\"byof cross_nodal_constraints[{i}] is not differentiable with JAX: {e}\"\n            ) from e\n\n    # Validate CTCS constraints\n    for i, ctcs_spec in enumerate(byof.get(\"ctcs_constraints\", [])):\n        if not isinstance(ctcs_spec, dict):\n            raise TypeError(f\"byof ctcs_constraints[{i}] must be a dict, got {type(ctcs_spec)}\")\n\n        if \"constraint_fn\" not in ctcs_spec:\n            raise ValueError(f\"byof ctcs_constraints[{i}] missing required key 'constraint_fn'\")\n\n        fn = ctcs_spec[\"constraint_fn\"]\n        if not callable(fn):\n            raise TypeError(\n                f\"byof ctcs_constraints[{i}]['constraint_fn'] must be callable, got {type(fn)}\"\n            )\n\n        # Check signature\n        sig = inspect.signature(fn)\n        if len(sig.parameters) != 4:\n            raise ValueError(\n                f\"byof ctcs_constraints[{i}]['constraint_fn'] must have signature \"\n                f\"f(x, u, node, params), got {len(sig.parameters)} parameters: \"\n                f\"{list(sig.parameters.keys())}\"\n            )\n\n        # Test call\n        try:\n            result = fn(dummy_x, dummy_u, dummy_node, dummy_params)\n        except Exception as e:\n            raise ValueError(\n                f\"byof ctcs_constraints[{i}]['constraint_fn'] failed on test call: {e}\"\n            ) from e\n\n        # Check that result is scalar\n        result_array = jnp.asarray(result)\n        if result_array.shape != ():\n            raise ValueError(\n                f\"byof ctcs_constraints[{i}]['constraint_fn'] must return a scalar, \"\n                f\"got shape {result_array.shape}\"\n            )\n\n        # Test gradient\n        try:\n            jax.grad(lambda x: fn(x, dummy_u, dummy_node, dummy_params))(dummy_x)\n        except Exception as e:\n            raise ValueError(\n                f\"byof ctcs_constraints[{i}]['constraint_fn'] is not differentiable with JAX: {e}\"\n            ) from e\n\n        # Validate penalty function if provided\n        if \"penalty\" in ctcs_spec:\n            penalty_spec = ctcs_spec[\"penalty\"]\n            if callable(penalty_spec):\n                # Test custom penalty function\n                try:\n                    test_residual = jnp.array(0.5)\n                    penalty_result = penalty_spec(test_residual)\n                    jnp.asarray(penalty_result)\n                except Exception as e:\n                    raise ValueError(\n                        f\"byof ctcs_constraints[{i}]['penalty'] custom function failed: {e}\"\n                    ) from e\n            elif penalty_spec not in [\"square\", \"l1\", \"huber\"]:\n                raise ValueError(\n                    f\"byof ctcs_constraints[{i}]['penalty'] must be 'square', 'l1', 'huber', \"\n                    f\"or a callable, got {penalty_spec!r}\"\n                )\n\n        # Validate idx if provided\n        if \"idx\" in ctcs_spec:\n            idx = ctcs_spec[\"idx\"]\n            if not isinstance(idx, int):\n                raise TypeError(\n                    f\"byof ctcs_constraints[{i}]['idx'] must be an integer, got {type(idx)}\"\n                )\n            if idx &lt; 0:\n                raise ValueError(\n                    f\"byof ctcs_constraints[{i}]['idx'] must be non-negative, got {idx}\"\n                )\n\n        # Validate bounds if provided\n        if \"bounds\" in ctcs_spec:\n            bounds = ctcs_spec[\"bounds\"]\n            if not isinstance(bounds, (tuple, list)) or len(bounds) != 2:\n                raise ValueError(\n                    f\"byof ctcs_constraints[{i}]['bounds'] must be a (min, max) tuple, got {bounds}\"\n                )\n            if bounds[0] &gt; bounds[1]:\n                raise ValueError(\n                    f\"byof ctcs_constraints[{i}]['bounds'] min ({bounds[0]}) must be &lt;= \"\n                    f\"max ({bounds[1]})\"\n                )\n        else:\n            # Use default bounds for initial value validation\n            bounds = (0.0, 1e-4)\n\n        # Validate initial value is within bounds\n        if \"initial\" in ctcs_spec:\n            initial = ctcs_spec[\"initial\"]\n            if not (bounds[0] &lt;= initial &lt;= bounds[1]):\n                raise ValueError(\n                    f\"byof ctcs_constraints[{i}]['initial'] ({initial}) must be within \"\n                    f\"bounds [{bounds[0]}, {bounds[1]}]\"\n                )\n\n        # Validate over (node interval) if provided\n        if \"over\" in ctcs_spec:\n            over = ctcs_spec[\"over\"]\n            if not isinstance(over, (tuple, list)) or len(over) != 2:\n                raise ValueError(\n                    f\"byof ctcs_constraints[{i}]['over'] must be a (start, end) tuple, got {over}\"\n                )\n            start, end = over\n            if not isinstance(start, int) or not isinstance(end, int):\n                raise TypeError(\n                    f\"byof ctcs_constraints[{i}]['over'] indices must be integers, \"\n                    f\"got start={type(start)}, end={type(end)}\"\n                )\n            if start &gt;= end:\n                raise ValueError(\n                    f\"byof ctcs_constraints[{i}]['over'] start ({start}) must be &lt; end ({end})\"\n                )\n            if start &lt; 0:\n                raise ValueError(\n                    f\"byof ctcs_constraints[{i}]['over'] start ({start}) must be non-negative\"\n                )\n            # Validate against trajectory length if N is provided\n            if N is not None:\n                if end &gt; N:\n                    raise ValueError(\n                        f\"byof ctcs_constraints[{i}]['over'] end ({end}) exceeds \"\n                        f\"trajectory length ({N})\"\n                    )\n</code></pre>"},{"location":"reference/integrators/","title":"integrators","text":"<p>Numerical integration schemes for trajectory optimization.</p> <p>This module provides implementations of numerical integrators used for simulating continuous-time dynamics.</p> Current Implementations <p>RK45 Integration: Explicit Runge-Kutta-Fehlberg method (4th/5th order)     with both fixed-step and adaptive implementations via Diffrax.     Supports a variety of explicit and implicit ODE solvers through the     Diffrax backend (Dopri5/8, Tsit5, KenCarp3/4/5, etc.).</p> <p>Planned Architecture (ABC-based):</p> <p>A base class will be introduced to enable pluggable integrator implementations. This will enable users to implement custom integrators. Future integrators will implement the Integrator interface:</p> <pre><code># integrators/base.py (planned):\nclass Integrator(ABC):\n    @abstractmethod\n    def step(self, f: Callable, x: Array, u: Array, t: float, dt: float) -&gt; Array:\n        '''Take one integration step from state x at time t with step dt.'''\n        ...\n\n    @abstractmethod\n    def integrate(self, f: Callable, x0: Array, u_traj: Array,\n                    t_span: tuple[float, float], num_steps: int) -&gt; Array:\n        '''Integrate over a time span with given control trajectory.'''\n        ...\n</code></pre>"},{"location":"reference/integrators/#openscvx.integrators.rk45_step","title":"<code>rk45_step(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], t: jnp.ndarray, y: jnp.ndarray, h: float, *args) -&gt; jnp.ndarray</code>","text":"<p>Perform a single RK45 (Runge-Kutta-Fehlberg) integration step.</p> <p>This implements the classic Dorman-Prince coefficients for an explicit 4(5) method, returning the fourth-order estimate.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>t</code> <code>ndarray</code> <p>Current time.</p> required <code>y</code> <code>ndarray</code> <p>Current state vector.</p> required <code>h</code> <code>float</code> <p>Step size.</p> required <code>*args</code> <p>Additional arguments passed to <code>f</code>.</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: Next state estimate at t + h.</p> Source code in <code>openscvx/integrators/runge_kutta.py</code> <pre><code>def rk45_step(\n    f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray],\n    t: jnp.ndarray,\n    y: jnp.ndarray,\n    h: float,\n    *args\n) -&gt; jnp.ndarray:\n    \"\"\"\n    Perform a single RK45 (Runge-Kutta-Fehlberg) integration step.\n\n    This implements the classic Dorman-Prince coefficients for an\n    explicit 4(5) method, returning the fourth-order estimate.\n\n    Args:\n        f (Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray]):\n            ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.\n        t (jnp.ndarray): Current time.\n        y (jnp.ndarray): Current state vector.\n        h (float): Step size.\n        *args: Additional arguments passed to `f`.\n\n    Returns:\n        jnp.ndarray: Next state estimate at t + h.\n    \"\"\"\n    k1 = f(t, y, *args)\n    k2 = f(t + h/4, y + h*k1/4, *args)\n    k3 = f(t + 3*h/8, y + 3*h*k1/32 + 9*h*k2/32, *args)\n    k4 = f(t + 12*h/13, y + 1932*h*k1/2197 - 7200*h*k2/2197 + 7296*h*k3/2197, *args)\n    k5 = f(t + h, y + 439*h*k1/216 - 8*h*k2 + 3680*h*k3/513 - 845*h*k4/4104, *args)\n    y_next = y + h * (25*k1/216 + 1408*k3/2565 + 2197*k4/4104 - k5/5)\n    return y_next\n</code></pre>"},{"location":"reference/integrators/#openscvx.integrators.solve_ivp_diffrax","title":"<code>solve_ivp_diffrax(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; f(t, y, *args).</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>solver_name</code> is not in SOLVER_MAP.</p> Source code in <code>openscvx/integrators/runge_kutta.py</code> <pre><code>def solve_ivp_diffrax(\n    f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray],\n    tau_final: float,\n    y_0: jnp.ndarray,\n    args,\n    tau_0: float = 0.0,\n    num_substeps: int = 50,\n    solver_name: str = \"Dopri8\",\n    rtol: float = 1e-3,\n    atol: float = 1e-6,\n    extra_kwargs=None,\n):\n    \"\"\"\n    Solve an initial-value ODE problem using a Diffrax adaptive solver.\n\n    Args:\n        f (Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray]):\n            ODE right-hand side; f(t, y, *args).\n        tau_final (float): Final integration time.\n        y_0 (jnp.ndarray): Initial state at tau_0.\n        args (tuple): Extra arguments to pass to `f` in the solver term.\n        tau_0 (float, optional): Initial time. Defaults to 0.0.\n        num_substeps (int, optional): Number of save points between tau_0 and tau_final.\n            Defaults to 50.\n        solver_name (str, optional): Key into SOLVER_MAP for the Diffrax solver class.\n            Defaults to \"Dopri8\".\n        rtol (float, optional): Relative tolerance for adaptive stepping. Defaults to 1e-3.\n        atol (float, optional): Absolute tolerance for adaptive stepping. Defaults to 1e-6.\n        extra_kwargs (dict, optional): Additional keyword arguments forwarded to `diffeqsolve`.\n\n    Returns:\n        jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).\n\n    Raises:\n        ValueError: If `solver_name` is not in SOLVER_MAP.\n    \"\"\"\n    substeps = jnp.linspace(tau_0, tau_final, num_substeps)\n\n    solver_class = SOLVER_MAP.get(solver_name)\n    if solver_class is None:\n        raise ValueError(f\"Unknown solver: {solver_name}\")\n    solver = solver_class()\n\n    term = dfx.ODETerm(lambda t, y, args: f(t, y, *args))\n    stepsize_controller = dfx.PIDController(rtol=rtol, atol=atol)\n    solution = dfx.diffeqsolve(\n        term,\n        solver=solver,\n        t0=tau_0,\n        t1=tau_final,\n        dt0=(tau_final - tau_0) / (len(substeps) - 1),\n        y0=y_0,\n        args=args,\n        stepsize_controller=stepsize_controller,\n        saveat=dfx.SaveAt(ts=substeps),\n        progress_meter=dfx.NoProgressMeter(),\n        **(extra_kwargs or {}),\n    )\n\n    return solution.ys\n</code></pre>"},{"location":"reference/integrators/#openscvx.integrators.solve_ivp_diffrax_prop","title":"<code>solve_ivp_diffrax_prop(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None, save_time: jnp.ndarray = None, mask: jnp.ndarray = None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver. This function is specifically designed for use in the context of trajectory optimization and handles the nonlinear single-shot propagation of state variables in undilated time.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <code>save_time</code> <code>ndarray</code> <p>Time points at which to evaluate the solution. Must be provided for export compatibility.</p> <code>None</code> <code>mask</code> <code>ndarray</code> <p>Boolean mask for the save_time points.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:     ValueError: If <code>solver_name</code> is not in SOLVER_MAP or if save_time is not provided.</p> Source code in <code>openscvx/integrators/runge_kutta.py</code> <pre><code>def solve_ivp_diffrax_prop(\n    f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray],\n    tau_final: float,\n    y_0: jnp.ndarray,\n    args,\n    tau_0: float = 0.0,\n    num_substeps: int = 50,\n    solver_name: str = \"Dopri8\",\n    rtol: float = 1e-3,\n    atol: float = 1e-6,\n    extra_kwargs=None,\n    save_time: jnp.ndarray = None,\n    mask: jnp.ndarray = None,\n):\n    \"\"\"\n    Solve an initial-value ODE problem using a Diffrax adaptive solver.\n    This function is specifically designed for use in the context of\n    trajectory optimization and handles the nonlinear single-shot propagation\n    of state variables in undilated time.\n\n    Args:\n        f (Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray]): ODE right-hand side;\n            signature f(t, y, *args) -&gt; dy/dt.\n        tau_final (float): Final integration time.\n        y_0 (jnp.ndarray): Initial state at tau_0.\n        args (tuple): Extra arguments to pass to `f` in the solver term.\n        tau_0 (float, optional): Initial time. Defaults to 0.0.\n        num_substeps (int, optional): Number of save points between tau_0 and tau_final.\n            Defaults to 50.\n        solver_name (str, optional): Key into SOLVER_MAP for the Diffrax solver class.\n            Defaults to \"Dopri8\".\n        rtol (float, optional): Relative tolerance for adaptive stepping. Defaults to 1e-3.\n        atol (float, optional): Absolute tolerance for adaptive stepping. Defaults to 1e-6.\n        extra_kwargs (dict, optional): Additional keyword arguments forwarded to `diffeqsolve`.\n        save_time (jnp.ndarray, optional): Time points at which to evaluate the solution.\n            Must be provided for export compatibility.\n        mask (jnp.ndarray, optional): Boolean mask for the save_time points.\n\n    Returns:\n        jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).\n    Raises:\n        ValueError: If `solver_name` is not in SOLVER_MAP or if save_time is not provided.\n    \"\"\"\n\n    if save_time is None:\n        raise ValueError(\"save_time must be provided for export compatibility.\")\n    if mask is None:\n        mask = jnp.ones_like(save_time, dtype=bool)\n\n    solver_class = SOLVER_MAP.get(solver_name)\n    if solver_class is None:\n        raise ValueError(f\"Unknown solver: {solver_name}\")\n    solver = solver_class()\n\n    term = dfx.ODETerm(lambda t, y, args: f(t, y, *args))\n    stepsize_controller = dfx.PIDController(rtol=rtol, atol=atol)\n\n    solution = dfx.diffeqsolve(\n        term,\n        solver=solver,\n        t0=tau_0,\n        t1=tau_final,\n        dt0=(tau_final - tau_0) / 1,\n        y0=y_0,\n        args=args,\n        stepsize_controller=stepsize_controller,\n        saveat=dfx.SaveAt(dense=True),\n        **(extra_kwargs or {}),\n    )\n\n    # Evaluate all save_time points (static size), then mask them\n    all_evals = jax.vmap(solution.evaluate)(save_time)  # shape: (MAX_TAU_LEN, n_states)\n    masked_array = jnp.where(mask[:, None], all_evals, jnp.zeros_like(all_evals))\n    # shape: (variable_len, n_states)\n\n    return masked_array\n</code></pre>"},{"location":"reference/integrators/#openscvx.integrators.solve_ivp_rk45","title":"<code>solve_ivp_rk45(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, is_not_compiled: bool = False)</code>","text":"<p>Solve an initial-value ODE problem using fixed-step RK45 integration.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code>.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of output time points. Defaults to 50.</p> <code>50</code> <code>is_not_compiled</code> <code>bool</code> <p>If True, use Python loop instead of JAX <code>lax.fori_loop</code>. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Array of shape (num_substeps, state_dim) with solution at each time.</p> Source code in <code>openscvx/integrators/runge_kutta.py</code> <pre><code>def solve_ivp_rk45(\n    f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray],\n    tau_final: float,\n    y_0: jnp.ndarray,\n    args,\n    tau_0: float = 0.0,\n    num_substeps: int = 50,\n    is_not_compiled: bool = False,\n):\n    \"\"\"\n    Solve an initial-value ODE problem using fixed-step RK45 integration.\n\n    Args:\n        f (Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray]):\n            ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.\n        tau_final (float): Final integration time.\n        y_0 (jnp.ndarray): Initial state at tau_0.\n        args (tuple): Extra arguments to pass to `f`.\n        tau_0 (float, optional): Initial time. Defaults to 0.0.\n        num_substeps (int, optional): Number of output time points. Defaults to 50.\n        is_not_compiled (bool, optional): If True, use Python loop instead of\n            JAX `lax.fori_loop`. Defaults to False.\n\n    Returns:\n        jnp.ndarray: Array of shape (num_substeps, state_dim) with solution at each time.\n    \"\"\"\n    substeps = jnp.linspace(tau_0, tau_final, num_substeps)\n\n    h = (tau_final - tau_0) / (len(substeps) - 1)\n    solution = jnp.zeros((len(substeps), len(y_0)))\n    solution = solution.at[0].set(y_0)\n\n    if is_not_compiled:\n        for i in range(1, len(substeps)):\n            t = tau_0 + i * h\n            solution = solution.at[i].set(rk45_step(f, t, solution[i - 1], h, *args))\n    else:\n\n        def body_fun(i, val):\n            t, y, V_result = val\n            y_next = rk45_step(f, t, y, h, *args)\n            V_result = V_result.at[i].set(y_next)\n            return (t + h, y_next, V_result)\n\n        _, _, solution = jax.lax.fori_loop(1, len(substeps), body_fun, (tau_0, y_0, solution))\n\n    return solution\n</code></pre>"},{"location":"reference/integrators/runge_kutta/","title":"runge_kutta","text":""},{"location":"reference/integrators/runge_kutta/#openscvx.integrators.runge_kutta.rk45_step","title":"<code>rk45_step(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], t: jnp.ndarray, y: jnp.ndarray, h: float, *args) -&gt; jnp.ndarray</code>","text":"<p>Perform a single RK45 (Runge-Kutta-Fehlberg) integration step.</p> <p>This implements the classic Dorman-Prince coefficients for an explicit 4(5) method, returning the fourth-order estimate.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>t</code> <code>ndarray</code> <p>Current time.</p> required <code>y</code> <code>ndarray</code> <p>Current state vector.</p> required <code>h</code> <code>float</code> <p>Step size.</p> required <code>*args</code> <p>Additional arguments passed to <code>f</code>.</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: Next state estimate at t + h.</p> Source code in <code>openscvx/integrators/runge_kutta.py</code> <pre><code>def rk45_step(\n    f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray],\n    t: jnp.ndarray,\n    y: jnp.ndarray,\n    h: float,\n    *args\n) -&gt; jnp.ndarray:\n    \"\"\"\n    Perform a single RK45 (Runge-Kutta-Fehlberg) integration step.\n\n    This implements the classic Dorman-Prince coefficients for an\n    explicit 4(5) method, returning the fourth-order estimate.\n\n    Args:\n        f (Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray]):\n            ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.\n        t (jnp.ndarray): Current time.\n        y (jnp.ndarray): Current state vector.\n        h (float): Step size.\n        *args: Additional arguments passed to `f`.\n\n    Returns:\n        jnp.ndarray: Next state estimate at t + h.\n    \"\"\"\n    k1 = f(t, y, *args)\n    k2 = f(t + h/4, y + h*k1/4, *args)\n    k3 = f(t + 3*h/8, y + 3*h*k1/32 + 9*h*k2/32, *args)\n    k4 = f(t + 12*h/13, y + 1932*h*k1/2197 - 7200*h*k2/2197 + 7296*h*k3/2197, *args)\n    k5 = f(t + h, y + 439*h*k1/216 - 8*h*k2 + 3680*h*k3/513 - 845*h*k4/4104, *args)\n    y_next = y + h * (25*k1/216 + 1408*k3/2565 + 2197*k4/4104 - k5/5)\n    return y_next\n</code></pre>"},{"location":"reference/integrators/runge_kutta/#openscvx.integrators.runge_kutta.solve_ivp_diffrax","title":"<code>solve_ivp_diffrax(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; f(t, y, *args).</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>solver_name</code> is not in SOLVER_MAP.</p> Source code in <code>openscvx/integrators/runge_kutta.py</code> <pre><code>def solve_ivp_diffrax(\n    f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray],\n    tau_final: float,\n    y_0: jnp.ndarray,\n    args,\n    tau_0: float = 0.0,\n    num_substeps: int = 50,\n    solver_name: str = \"Dopri8\",\n    rtol: float = 1e-3,\n    atol: float = 1e-6,\n    extra_kwargs=None,\n):\n    \"\"\"\n    Solve an initial-value ODE problem using a Diffrax adaptive solver.\n\n    Args:\n        f (Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray]):\n            ODE right-hand side; f(t, y, *args).\n        tau_final (float): Final integration time.\n        y_0 (jnp.ndarray): Initial state at tau_0.\n        args (tuple): Extra arguments to pass to `f` in the solver term.\n        tau_0 (float, optional): Initial time. Defaults to 0.0.\n        num_substeps (int, optional): Number of save points between tau_0 and tau_final.\n            Defaults to 50.\n        solver_name (str, optional): Key into SOLVER_MAP for the Diffrax solver class.\n            Defaults to \"Dopri8\".\n        rtol (float, optional): Relative tolerance for adaptive stepping. Defaults to 1e-3.\n        atol (float, optional): Absolute tolerance for adaptive stepping. Defaults to 1e-6.\n        extra_kwargs (dict, optional): Additional keyword arguments forwarded to `diffeqsolve`.\n\n    Returns:\n        jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).\n\n    Raises:\n        ValueError: If `solver_name` is not in SOLVER_MAP.\n    \"\"\"\n    substeps = jnp.linspace(tau_0, tau_final, num_substeps)\n\n    solver_class = SOLVER_MAP.get(solver_name)\n    if solver_class is None:\n        raise ValueError(f\"Unknown solver: {solver_name}\")\n    solver = solver_class()\n\n    term = dfx.ODETerm(lambda t, y, args: f(t, y, *args))\n    stepsize_controller = dfx.PIDController(rtol=rtol, atol=atol)\n    solution = dfx.diffeqsolve(\n        term,\n        solver=solver,\n        t0=tau_0,\n        t1=tau_final,\n        dt0=(tau_final - tau_0) / (len(substeps) - 1),\n        y0=y_0,\n        args=args,\n        stepsize_controller=stepsize_controller,\n        saveat=dfx.SaveAt(ts=substeps),\n        progress_meter=dfx.NoProgressMeter(),\n        **(extra_kwargs or {}),\n    )\n\n    return solution.ys\n</code></pre>"},{"location":"reference/integrators/runge_kutta/#openscvx.integrators.runge_kutta.solve_ivp_diffrax_prop","title":"<code>solve_ivp_diffrax_prop(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None, save_time: jnp.ndarray = None, mask: jnp.ndarray = None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver. This function is specifically designed for use in the context of trajectory optimization and handles the nonlinear single-shot propagation of state variables in undilated time.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <code>save_time</code> <code>ndarray</code> <p>Time points at which to evaluate the solution. Must be provided for export compatibility.</p> <code>None</code> <code>mask</code> <code>ndarray</code> <p>Boolean mask for the save_time points.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:     ValueError: If <code>solver_name</code> is not in SOLVER_MAP or if save_time is not provided.</p> Source code in <code>openscvx/integrators/runge_kutta.py</code> <pre><code>def solve_ivp_diffrax_prop(\n    f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray],\n    tau_final: float,\n    y_0: jnp.ndarray,\n    args,\n    tau_0: float = 0.0,\n    num_substeps: int = 50,\n    solver_name: str = \"Dopri8\",\n    rtol: float = 1e-3,\n    atol: float = 1e-6,\n    extra_kwargs=None,\n    save_time: jnp.ndarray = None,\n    mask: jnp.ndarray = None,\n):\n    \"\"\"\n    Solve an initial-value ODE problem using a Diffrax adaptive solver.\n    This function is specifically designed for use in the context of\n    trajectory optimization and handles the nonlinear single-shot propagation\n    of state variables in undilated time.\n\n    Args:\n        f (Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray]): ODE right-hand side;\n            signature f(t, y, *args) -&gt; dy/dt.\n        tau_final (float): Final integration time.\n        y_0 (jnp.ndarray): Initial state at tau_0.\n        args (tuple): Extra arguments to pass to `f` in the solver term.\n        tau_0 (float, optional): Initial time. Defaults to 0.0.\n        num_substeps (int, optional): Number of save points between tau_0 and tau_final.\n            Defaults to 50.\n        solver_name (str, optional): Key into SOLVER_MAP for the Diffrax solver class.\n            Defaults to \"Dopri8\".\n        rtol (float, optional): Relative tolerance for adaptive stepping. Defaults to 1e-3.\n        atol (float, optional): Absolute tolerance for adaptive stepping. Defaults to 1e-6.\n        extra_kwargs (dict, optional): Additional keyword arguments forwarded to `diffeqsolve`.\n        save_time (jnp.ndarray, optional): Time points at which to evaluate the solution.\n            Must be provided for export compatibility.\n        mask (jnp.ndarray, optional): Boolean mask for the save_time points.\n\n    Returns:\n        jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).\n    Raises:\n        ValueError: If `solver_name` is not in SOLVER_MAP or if save_time is not provided.\n    \"\"\"\n\n    if save_time is None:\n        raise ValueError(\"save_time must be provided for export compatibility.\")\n    if mask is None:\n        mask = jnp.ones_like(save_time, dtype=bool)\n\n    solver_class = SOLVER_MAP.get(solver_name)\n    if solver_class is None:\n        raise ValueError(f\"Unknown solver: {solver_name}\")\n    solver = solver_class()\n\n    term = dfx.ODETerm(lambda t, y, args: f(t, y, *args))\n    stepsize_controller = dfx.PIDController(rtol=rtol, atol=atol)\n\n    solution = dfx.diffeqsolve(\n        term,\n        solver=solver,\n        t0=tau_0,\n        t1=tau_final,\n        dt0=(tau_final - tau_0) / 1,\n        y0=y_0,\n        args=args,\n        stepsize_controller=stepsize_controller,\n        saveat=dfx.SaveAt(dense=True),\n        **(extra_kwargs or {}),\n    )\n\n    # Evaluate all save_time points (static size), then mask them\n    all_evals = jax.vmap(solution.evaluate)(save_time)  # shape: (MAX_TAU_LEN, n_states)\n    masked_array = jnp.where(mask[:, None], all_evals, jnp.zeros_like(all_evals))\n    # shape: (variable_len, n_states)\n\n    return masked_array\n</code></pre>"},{"location":"reference/integrators/runge_kutta/#openscvx.integrators.runge_kutta.solve_ivp_rk45","title":"<code>solve_ivp_rk45(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, is_not_compiled: bool = False)</code>","text":"<p>Solve an initial-value ODE problem using fixed-step RK45 integration.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code>.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of output time points. Defaults to 50.</p> <code>50</code> <code>is_not_compiled</code> <code>bool</code> <p>If True, use Python loop instead of JAX <code>lax.fori_loop</code>. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Array of shape (num_substeps, state_dim) with solution at each time.</p> Source code in <code>openscvx/integrators/runge_kutta.py</code> <pre><code>def solve_ivp_rk45(\n    f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray],\n    tau_final: float,\n    y_0: jnp.ndarray,\n    args,\n    tau_0: float = 0.0,\n    num_substeps: int = 50,\n    is_not_compiled: bool = False,\n):\n    \"\"\"\n    Solve an initial-value ODE problem using fixed-step RK45 integration.\n\n    Args:\n        f (Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray]):\n            ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.\n        tau_final (float): Final integration time.\n        y_0 (jnp.ndarray): Initial state at tau_0.\n        args (tuple): Extra arguments to pass to `f`.\n        tau_0 (float, optional): Initial time. Defaults to 0.0.\n        num_substeps (int, optional): Number of output time points. Defaults to 50.\n        is_not_compiled (bool, optional): If True, use Python loop instead of\n            JAX `lax.fori_loop`. Defaults to False.\n\n    Returns:\n        jnp.ndarray: Array of shape (num_substeps, state_dim) with solution at each time.\n    \"\"\"\n    substeps = jnp.linspace(tau_0, tau_final, num_substeps)\n\n    h = (tau_final - tau_0) / (len(substeps) - 1)\n    solution = jnp.zeros((len(substeps), len(y_0)))\n    solution = solution.at[0].set(y_0)\n\n    if is_not_compiled:\n        for i in range(1, len(substeps)):\n            t = tau_0 + i * h\n            solution = solution.at[i].set(rk45_step(f, t, solution[i - 1], h, *args))\n    else:\n\n        def body_fun(i, val):\n            t, y, V_result = val\n            y_next = rk45_step(f, t, y, h, *args)\n            V_result = V_result.at[i].set(y_next)\n            return (t + h, y_next, V_result)\n\n        _, _, solution = jax.lax.fori_loop(1, len(substeps), body_fun, (tau_0, y_0, solution))\n\n    return solution\n</code></pre>"},{"location":"reference/lowered/","title":"lowered","text":"<p>Lowered problem dataclasses.</p> <p>This module contains dataclasses representing the outputs of the lowering phase, where symbolic expressions are converted to executable JAX and CVXPy code.</p>"},{"location":"reference/lowered/#openscvx.lowered.CVXPyVariables","title":"<code>CVXPyVariables</code>  <code>dataclass</code>","text":"<p>CVXPy variables and parameters for the optimal control problem.</p> <p>This dataclass holds all CVXPy Variable and Parameter objects needed to construct and solve the optimal control problem. It replaces the previous untyped dictionary approach with a typed, self-documenting structure.</p> The variables are organized into logical groups <ul> <li>SCP weights: Parameters controlling trust region and penalty weights</li> <li>State: Variables and parameters for the state trajectory</li> <li>Control: Variables and parameters for the control trajectory</li> <li>Dynamics: Parameters for the discretized dynamics constraints</li> <li>Nodal constraints: Parameters for linearized non-convex nodal constraints</li> <li>Cross-node constraints: Parameters for linearized cross-node constraints</li> <li>Scaling: Affine scaling matrices and offset vectors</li> <li>Scaled expressions: CVXPy expressions for scaled state/control at each node</li> </ul> <p>Attributes:</p> Name Type Description <code>w_tr</code> <code>Parameter</code> <p>Trust region weight parameter (scalar, nonneg)</p> <code>lam_cost</code> <code>Parameter</code> <p>Cost function weight parameter (scalar, nonneg)</p> <code>lam_vc</code> <code>Parameter</code> <p>Virtual control penalty weights (N-1 x n_states, nonneg)</p> <code>lam_vb</code> <code>Parameter</code> <p>Virtual buffer penalty weight (scalar, nonneg)</p> <code>x</code> <code>Variable</code> <p>State variable (N x n_states)</p> <code>dx</code> <code>Variable</code> <p>State error variable (N x n_states)</p> <code>x_bar</code> <code>Parameter</code> <p>Previous SCP state parameter (N x n_states)</p> <code>x_init</code> <code>Parameter</code> <p>Initial state parameter (n_states,)</p> <code>x_term</code> <code>Parameter</code> <p>Terminal state parameter (n_states,)</p> <code>u</code> <code>Variable</code> <p>Control variable (N x n_controls)</p> <code>du</code> <code>Variable</code> <p>Control error variable (N x n_controls)</p> <code>u_bar</code> <code>Parameter</code> <p>Previous SCP control parameter (N x n_controls)</p> <code>A_d</code> <code>Parameter</code> <p>Discretized state Jacobian parameter (N-1 x n_states*n_states)</p> <code>B_d</code> <code>Parameter</code> <p>Discretized control Jacobian parameter (N-1 x n_states*n_controls)</p> <code>C_d</code> <code>Parameter</code> <p>Discretized control Jacobian (next node) parameter</p> <code>x_prop</code> <code>Parameter</code> <p>Propagated state parameter (N-1 x n_states)</p> <code>nu</code> <code>Variable</code> <p>Virtual control variable (N-1 x n_states)</p> <code>g</code> <code>List[Parameter]</code> <p>List of constraint value parameters (one per nodal constraint)</p> <code>grad_g_x</code> <code>List[Parameter]</code> <p>List of state gradient parameters (one per nodal constraint)</p> <code>grad_g_u</code> <code>List[Parameter]</code> <p>List of control gradient parameters (one per nodal constraint)</p> <code>nu_vb</code> <code>List[Variable]</code> <p>List of virtual buffer variables (one per nodal constraint)</p> <code>g_cross</code> <code>List[Parameter]</code> <p>List of cross-node constraint value parameters</p> <code>grad_g_X_cross</code> <code>List[Parameter]</code> <p>List of trajectory state gradient parameters</p> <code>grad_g_U_cross</code> <code>List[Parameter]</code> <p>List of trajectory control gradient parameters</p> <code>nu_vb_cross</code> <code>List[Variable]</code> <p>List of cross-node virtual buffer variables</p> <code>S_x</code> <code>ndarray</code> <p>State scaling matrix (n_states x n_states)</p> <code>inv_S_x</code> <code>ndarray</code> <p>Inverse state scaling matrix</p> <code>c_x</code> <code>ndarray</code> <p>State offset vector (n_states,)</p> <code>S_u</code> <code>ndarray</code> <p>Control scaling matrix (n_controls x n_controls)</p> <code>inv_S_u</code> <code>ndarray</code> <p>Inverse control scaling matrix</p> <code>c_u</code> <code>ndarray</code> <p>Control offset vector (n_controls,)</p> <code>x_nonscaled</code> <code>List</code> <p>List of scaled state expressions at each node</p> <code>u_nonscaled</code> <code>List</code> <p>List of scaled control expressions at each node</p> <code>dx_nonscaled</code> <code>List</code> <p>List of scaled state error expressions at each node</p> <code>du_nonscaled</code> <code>List</code> <p>List of scaled control error expressions at each node</p> Source code in <code>openscvx/lowered/cvxpy_variables.py</code> <pre><code>@dataclass\nclass CVXPyVariables:\n    \"\"\"CVXPy variables and parameters for the optimal control problem.\n\n    This dataclass holds all CVXPy Variable and Parameter objects needed to\n    construct and solve the optimal control problem. It replaces the previous\n    untyped dictionary approach with a typed, self-documenting structure.\n\n    The variables are organized into logical groups:\n        - SCP weights: Parameters controlling trust region and penalty weights\n        - State: Variables and parameters for the state trajectory\n        - Control: Variables and parameters for the control trajectory\n        - Dynamics: Parameters for the discretized dynamics constraints\n        - Nodal constraints: Parameters for linearized non-convex nodal constraints\n        - Cross-node constraints: Parameters for linearized cross-node constraints\n        - Scaling: Affine scaling matrices and offset vectors\n        - Scaled expressions: CVXPy expressions for scaled state/control at each node\n\n    Attributes:\n        w_tr: Trust region weight parameter (scalar, nonneg)\n        lam_cost: Cost function weight parameter (scalar, nonneg)\n        lam_vc: Virtual control penalty weights (N-1 x n_states, nonneg)\n        lam_vb: Virtual buffer penalty weight (scalar, nonneg)\n\n        x: State variable (N x n_states)\n        dx: State error variable (N x n_states)\n        x_bar: Previous SCP state parameter (N x n_states)\n        x_init: Initial state parameter (n_states,)\n        x_term: Terminal state parameter (n_states,)\n\n        u: Control variable (N x n_controls)\n        du: Control error variable (N x n_controls)\n        u_bar: Previous SCP control parameter (N x n_controls)\n\n        A_d: Discretized state Jacobian parameter (N-1 x n_states*n_states)\n        B_d: Discretized control Jacobian parameter (N-1 x n_states*n_controls)\n        C_d: Discretized control Jacobian (next node) parameter\n        x_prop: Propagated state parameter (N-1 x n_states)\n        nu: Virtual control variable (N-1 x n_states)\n\n        g: List of constraint value parameters (one per nodal constraint)\n        grad_g_x: List of state gradient parameters (one per nodal constraint)\n        grad_g_u: List of control gradient parameters (one per nodal constraint)\n        nu_vb: List of virtual buffer variables (one per nodal constraint)\n\n        g_cross: List of cross-node constraint value parameters\n        grad_g_X_cross: List of trajectory state gradient parameters\n        grad_g_U_cross: List of trajectory control gradient parameters\n        nu_vb_cross: List of cross-node virtual buffer variables\n\n        S_x: State scaling matrix (n_states x n_states)\n        inv_S_x: Inverse state scaling matrix\n        c_x: State offset vector (n_states,)\n        S_u: Control scaling matrix (n_controls x n_controls)\n        inv_S_u: Inverse control scaling matrix\n        c_u: Control offset vector (n_controls,)\n\n        x_nonscaled: List of scaled state expressions at each node\n        u_nonscaled: List of scaled control expressions at each node\n        dx_nonscaled: List of scaled state error expressions at each node\n        du_nonscaled: List of scaled control error expressions at each node\n    \"\"\"\n\n    # SCP weight parameters\n    w_tr: \"cp.Parameter\"\n    lam_cost: \"cp.Parameter\"\n    lam_vc: \"cp.Parameter\"\n    lam_vb: \"cp.Parameter\"\n\n    # State variables and parameters\n    x: \"cp.Variable\"\n    dx: \"cp.Variable\"\n    x_bar: \"cp.Parameter\"\n    x_init: \"cp.Parameter\"\n    x_term: \"cp.Parameter\"\n\n    # Control variables and parameters\n    u: \"cp.Variable\"\n    du: \"cp.Variable\"\n    u_bar: \"cp.Parameter\"\n\n    # Dynamics discretization parameters\n    A_d: \"cp.Parameter\"\n    B_d: \"cp.Parameter\"\n    C_d: \"cp.Parameter\"\n    x_prop: \"cp.Parameter\"\n    nu: \"cp.Variable\"\n\n    # Nodal constraint linearization (lists, one per constraint)\n    g: List[\"cp.Parameter\"] = field(default_factory=list)\n    grad_g_x: List[\"cp.Parameter\"] = field(default_factory=list)\n    grad_g_u: List[\"cp.Parameter\"] = field(default_factory=list)\n    nu_vb: List[\"cp.Variable\"] = field(default_factory=list)\n\n    # Cross-node constraint linearization (lists, one per constraint)\n    g_cross: List[\"cp.Parameter\"] = field(default_factory=list)\n    grad_g_X_cross: List[\"cp.Parameter\"] = field(default_factory=list)\n    grad_g_U_cross: List[\"cp.Parameter\"] = field(default_factory=list)\n    nu_vb_cross: List[\"cp.Variable\"] = field(default_factory=list)\n\n    # Scaling matrices and offsets (numpy arrays)\n    S_x: np.ndarray = field(default_factory=lambda: np.array([]))\n    inv_S_x: np.ndarray = field(default_factory=lambda: np.array([]))\n    c_x: np.ndarray = field(default_factory=lambda: np.array([]))\n    S_u: np.ndarray = field(default_factory=lambda: np.array([]))\n    inv_S_u: np.ndarray = field(default_factory=lambda: np.array([]))\n    c_u: np.ndarray = field(default_factory=lambda: np.array([]))\n\n    # Scaled CVXPy expressions at each node (lists of length N)\n    x_nonscaled: List = field(default_factory=list)\n    u_nonscaled: List = field(default_factory=list)\n    dx_nonscaled: List = field(default_factory=list)\n    du_nonscaled: List = field(default_factory=list)\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.Dynamics","title":"<code>Dynamics</code>  <code>dataclass</code>","text":"<p>Dataclass to hold a system dynamics function and its Jacobians.</p> <p>This dataclass is used internally by openscvx to store the compiled dynamics function and its gradients after symbolic expressions are lowered to JAX. Users typically don't instantiate this class directly.</p> <p>Attributes:</p> Name Type Description <code>f</code> <code>Callable[[ndarray, ndarray], ndarray]</code> <p>Function defining the continuous time nonlinear system dynamics as x_dot = f(x, u, ...params). - x: 1D array (state at a single node), shape (n_x,) - u: 1D array (control at a single node), shape (n_u,) - Additional parameters: passed as keyword arguments with names   matching the parameter name plus an underscore (e.g., g_ for   Parameter('g')). If you use vectorized integration or batch evaluation, x and u may be 2D arrays (N, n_x) and (N, n_u).</p> <code>A</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of <code>f</code> w.r.t. <code>x</code>.</p> <code>B</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of <code>f</code> w.r.t. <code>u</code>.</p> Source code in <code>openscvx/lowered/dynamics.py</code> <pre><code>@dataclass\nclass Dynamics:\n    \"\"\"Dataclass to hold a system dynamics function and its Jacobians.\n\n    This dataclass is used internally by openscvx to store the compiled dynamics\n    function and its gradients after symbolic expressions are lowered to JAX.\n    Users typically don't instantiate this class directly.\n\n    Attributes:\n        f (Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]):\n            Function defining the continuous time nonlinear system dynamics\n            as x_dot = f(x, u, ...params).\n            - x: 1D array (state at a single node), shape (n_x,)\n            - u: 1D array (control at a single node), shape (n_u,)\n            - Additional parameters: passed as keyword arguments with names\n              matching the parameter name plus an underscore (e.g., g_ for\n              Parameter('g')).\n            If you use vectorized integration or batch evaluation, x and u\n            may be 2D arrays (N, n_x) and (N, n_u).\n        A (Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]]):\n            Jacobian of ``f`` w.r.t. ``x``.\n        B (Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]]):\n            Jacobian of ``f`` w.r.t. ``u``.\n    \"\"\"\n\n    f: Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]\n    A: Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]] = None\n    B: Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]] = None\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.LoweredCrossNodeConstraint","title":"<code>LoweredCrossNodeConstraint</code>  <code>dataclass</code>","text":"<p>Lowered cross-node constraint with trajectory-level evaluation.</p> <p>Unlike regular LoweredNodalConstraint which operates on single-node vectors and is vmapped across the trajectory, LoweredCrossNodeConstraint operates on full trajectory arrays to relate multiple nodes simultaneously.</p> <p>This is necessary for constraints like: - Rate limits: x[k] - x[k-1] &lt;= max_rate - Multi-step dependencies: x[k] = 2*x[k-1] - x[k-2] - Periodic boundaries: x[0] = x[N-1]</p> <p>The function signatures differ from LoweredNodalConstraint: - Regular: f(x, u, node, params) -&gt; scalar (vmapped to handle (N, n_x)) - Cross-node: f(X, U, params) -&gt; scalar (single constraint with fixed node indices)</p> <p>Attributes:</p> Name Type Description <code>func</code> <code>Callable[[ndarray, ndarray, dict], ndarray]</code> <p>Function (X, U, params) -&gt; scalar residual where X: (N, n_x), U: (N, n_u) Returns constraint residual following g(X, U) &lt;= 0 convention The constraint references fixed trajectory nodes (e.g., X[5] - X[4])</p> <code>grad_g_X</code> <code>Callable[[ndarray, ndarray, dict], ndarray]</code> <p>Function (X, U, params) -&gt; (N, n_x) Jacobian wrt full state trajectory This is typically sparse - most constraints only couple nearby nodes</p> <code>grad_g_U</code> <code>Callable[[ndarray, ndarray, dict], ndarray]</code> <p>Function (X, U, params) -&gt; (N, n_u) Jacobian wrt full control trajectory Often zero or very sparse for cross-node state constraints</p> Example <p>For rate constraint x[5] - x[4] &lt;= r:</p> <pre><code>func(X, U, params) -&gt; scalar residual\ngrad_g_X(X, U, params) -&gt; (N, n_x) sparse Jacobian\n    where grad_g_X[5, :] = \u2202g/\u2202x[5] (derivative wrt node 5)\n    and grad_g_X[4, :] = \u2202g/\u2202x[4] (derivative wrt node 4)\n    all other entries are zero\n</code></pre> Performance Note - Dense Jacobian Storage <p>The Jacobian matrices grad_g_X and grad_g_U are stored as DENSE arrays with shape (N, n_x) and (N, n_u), but most cross-node constraints only couple a small number of nearby nodes, making these matrices extremely sparse.</p> <p>For example, a rate limit constraint x[k] - x[k-1] &lt;= r only has non-zero Jacobian entries at positions [k, :] and [k-1, :]. All other N-2 rows are zero but still stored in memory.</p> <p>Memory impact for large problems: - A single constraint with N=100 nodes, n_x=10 states requires ~8KB for   grad_g_X (compared to ~160 bytes if sparse with 2 non-zero rows) - Multiple cross-node constraints multiply this overhead - May cause issues for N &gt; 1000 with many constraints</p> <p>Performance impact: - Slower autodiff (computes many zero gradients) - Inefficient constraint linearization in the SCP solver - Potential GPU memory limitations for very large problems</p> <p>The current implementation prioritizes simplicity and compatibility with JAX's autodiff over memory efficiency. Future versions may support sparse Jacobian formats (COO, CSR, or custom sparse representations) if this becomes a bottleneck in practice.</p> Source code in <code>openscvx/lowered/jax_constraints.py</code> <pre><code>@dataclass\nclass LoweredCrossNodeConstraint:\n    \"\"\"Lowered cross-node constraint with trajectory-level evaluation.\n\n    Unlike regular LoweredNodalConstraint which operates on single-node vectors\n    and is vmapped across the trajectory, LoweredCrossNodeConstraint operates\n    on full trajectory arrays to relate multiple nodes simultaneously.\n\n    This is necessary for constraints like:\n    - Rate limits: x[k] - x[k-1] &lt;= max_rate\n    - Multi-step dependencies: x[k] = 2*x[k-1] - x[k-2]\n    - Periodic boundaries: x[0] = x[N-1]\n\n    The function signatures differ from LoweredNodalConstraint:\n    - Regular: f(x, u, node, params) -&gt; scalar (vmapped to handle (N, n_x))\n    - Cross-node: f(X, U, params) -&gt; scalar (single constraint with fixed node indices)\n\n    Attributes:\n        func: Function (X, U, params) -&gt; scalar residual\n            where X: (N, n_x), U: (N, n_u)\n            Returns constraint residual following g(X, U) &lt;= 0 convention\n            The constraint references fixed trajectory nodes (e.g., X[5] - X[4])\n        grad_g_X: Function (X, U, params) -&gt; (N, n_x) Jacobian wrt full state trajectory\n            This is typically sparse - most constraints only couple nearby nodes\n        grad_g_U: Function (X, U, params) -&gt; (N, n_u) Jacobian wrt full control trajectory\n            Often zero or very sparse for cross-node state constraints\n\n    Example:\n        For rate constraint x[5] - x[4] &lt;= r:\n\n            func(X, U, params) -&gt; scalar residual\n            grad_g_X(X, U, params) -&gt; (N, n_x) sparse Jacobian\n                where grad_g_X[5, :] = \u2202g/\u2202x[5] (derivative wrt node 5)\n                and grad_g_X[4, :] = \u2202g/\u2202x[4] (derivative wrt node 4)\n                all other entries are zero\n\n    Performance Note - Dense Jacobian Storage:\n        The Jacobian matrices grad_g_X and grad_g_U are stored as DENSE arrays with\n        shape (N, n_x) and (N, n_u), but most cross-node constraints only couple a\n        small number of nearby nodes, making these matrices extremely sparse.\n\n        For example, a rate limit constraint x[k] - x[k-1] &lt;= r only has non-zero\n        Jacobian entries at positions [k, :] and [k-1, :]. All other N-2 rows are\n        zero but still stored in memory.\n\n        Memory impact for large problems:\n        - A single constraint with N=100 nodes, n_x=10 states requires ~8KB for\n          grad_g_X (compared to ~160 bytes if sparse with 2 non-zero rows)\n        - Multiple cross-node constraints multiply this overhead\n        - May cause issues for N &gt; 1000 with many constraints\n\n        Performance impact:\n        - Slower autodiff (computes many zero gradients)\n        - Inefficient constraint linearization in the SCP solver\n        - Potential GPU memory limitations for very large problems\n\n        The current implementation prioritizes simplicity and compatibility with\n        JAX's autodiff over memory efficiency. Future versions may support sparse\n        Jacobian formats (COO, CSR, or custom sparse representations) if this\n        becomes a bottleneck in practice.\n    \"\"\"\n\n    func: Callable[[jnp.ndarray, jnp.ndarray, dict], jnp.ndarray]\n    grad_g_X: Callable[[jnp.ndarray, jnp.ndarray, dict], jnp.ndarray]\n    grad_g_U: Callable[[jnp.ndarray, jnp.ndarray, dict], jnp.ndarray]\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.LoweredCvxpyConstraints","title":"<code>LoweredCvxpyConstraints</code>  <code>dataclass</code>","text":"<p>CVXPy-lowered convex constraints.</p> <p>Contains constraints that have been lowered to CVXPy constraint objects. These are added directly to the optimal control problem without linearization.</p> <p>Attributes:</p> Name Type Description <code>constraints</code> <code>list[Constraint]</code> <p>List of CVXPy constraint objects (cp.Constraint). Includes both nodal and cross-node convex constraints.</p> Source code in <code>openscvx/lowered/cvxpy_constraints.py</code> <pre><code>@dataclass\nclass LoweredCvxpyConstraints:\n    \"\"\"CVXPy-lowered convex constraints.\n\n    Contains constraints that have been lowered to CVXPy constraint objects.\n    These are added directly to the optimal control problem without\n    linearization.\n\n    Attributes:\n        constraints: List of CVXPy constraint objects (cp.Constraint).\n            Includes both nodal and cross-node convex constraints.\n    \"\"\"\n\n    constraints: list[\"cp.Constraint\"] = field(default_factory=list)\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.LoweredJaxConstraints","title":"<code>LoweredJaxConstraints</code>  <code>dataclass</code>","text":"<p>JAX-lowered non-convex constraints with gradient functions.</p> <p>Contains constraints that have been lowered to JAX callable functions with automatically computed gradients. These are used for linearization in the SCP (Sequential Convex Programming) loop.</p> <p>Attributes:</p> Name Type Description <code>nodal</code> <code>list[LoweredNodalConstraint]</code> <p>List of LoweredNodalConstraint objects. Each has <code>func</code>, <code>grad_g_x</code>, <code>grad_g_u</code> callables and <code>nodes</code> list.</p> <code>cross_node</code> <code>list[LoweredCrossNodeConstraint]</code> <p>List of LoweredCrossNodeConstraint objects. Each has <code>func</code>, <code>grad_g_X</code>, <code>grad_g_U</code> for trajectory-level constraints.</p> <code>ctcs</code> <code>list[CTCS]</code> <p>CTCS constraints (unchanged from input, not lowered here).</p> Source code in <code>openscvx/lowered/jax_constraints.py</code> <pre><code>@dataclass\nclass LoweredJaxConstraints:\n    \"\"\"JAX-lowered non-convex constraints with gradient functions.\n\n    Contains constraints that have been lowered to JAX callable functions\n    with automatically computed gradients. These are used for linearization\n    in the SCP (Sequential Convex Programming) loop.\n\n    Attributes:\n        nodal: List of LoweredNodalConstraint objects. Each has `func`,\n            `grad_g_x`, `grad_g_u` callables and `nodes` list.\n        cross_node: List of LoweredCrossNodeConstraint objects. Each has\n            `func`, `grad_g_X`, `grad_g_U` for trajectory-level constraints.\n        ctcs: CTCS constraints (unchanged from input, not lowered here).\n    \"\"\"\n\n    nodal: list[LoweredNodalConstraint] = field(default_factory=list)\n    cross_node: list[LoweredCrossNodeConstraint] = field(default_factory=list)\n    ctcs: list[\"CTCS\"] = field(default_factory=list)\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.LoweredNodalConstraint","title":"<code>LoweredNodalConstraint</code>  <code>dataclass</code>","text":"<p>Dataclass to hold a lowered symbolic constraint function and its jacobians.</p> <p>This is a simplified drop-in replacement for NodalConstraint that holds only the essential lowered JAX functions and their jacobians, without the complexity of convex/vectorized flags or post-initialization logic.</p> <p>Designed for use with symbolic expressions that have been lowered to JAX and will be linearized for sequential convex programming.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[ndarray, ndarray], ndarray]</code> <p>The lowered constraint function g(x, u, ...params) that returns constraint residuals. Should follow g(x, u) &lt;= 0 convention. - x: 1D array (state at a single node), shape (n_x,) - u: 1D array (control at a single node), shape (n_u,) - Additional parameters: passed as keyword arguments</p> required <code>grad_g_x</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of g w.r.t. x. If None, should be computed using jax.jacfwd.</p> <code>None</code> <code>grad_g_u</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of g w.r.t. u. If None, should be computed using jax.jacfwd.</p> <code>None</code> <code>nodes</code> <code>Optional[List[int]]</code> <p>List of node indices where this constraint applies. Set after lowering from NodalConstraint.</p> <code>None</code> Source code in <code>openscvx/lowered/jax_constraints.py</code> <pre><code>@dataclass\nclass LoweredNodalConstraint:\n    \"\"\"\n    Dataclass to hold a lowered symbolic constraint function and its jacobians.\n\n    This is a simplified drop-in replacement for NodalConstraint that holds\n    only the essential lowered JAX functions and their jacobians, without\n    the complexity of convex/vectorized flags or post-initialization logic.\n\n    Designed for use with symbolic expressions that have been lowered to JAX\n    and will be linearized for sequential convex programming.\n\n    Args:\n        func (Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]):\n            The lowered constraint function g(x, u, ...params) that returns\n            constraint residuals. Should follow g(x, u) &lt;= 0 convention.\n            - x: 1D array (state at a single node), shape (n_x,)\n            - u: 1D array (control at a single node), shape (n_u,)\n            - Additional parameters: passed as keyword arguments\n\n        grad_g_x (Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]]):\n            Jacobian of g w.r.t. x. If None, should be computed using jax.jacfwd.\n\n        grad_g_u (Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]]):\n            Jacobian of g w.r.t. u. If None, should be computed using jax.jacfwd.\n\n        nodes (Optional[List[int]]): List of node indices where this constraint applies.\n            Set after lowering from NodalConstraint.\n    \"\"\"\n\n    func: Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]\n    grad_g_x: Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]] = None\n    grad_g_u: Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]] = None\n    nodes: Optional[List[int]] = None\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.LoweredProblem","title":"<code>LoweredProblem</code>  <code>dataclass</code>","text":"<p>Container for all outputs from symbolic problem lowering.</p> <p>This dataclass holds all the results of lowering symbolic expressions to executable JAX and CVXPy code. It provides a clean, typed interface for accessing the various components needed for optimization.</p> <p>Attributes:</p> Name Type Description <code>dynamics</code> <code>Dynamics</code> <p>Optimization dynamics with fields f, A, B (JAX functions)</p> <code>dynamics_prop</code> <code>Dynamics</code> <p>Propagation dynamics with fields f, A, B</p> <code>jax_constraints</code> <code>LoweredJaxConstraints</code> <p>Non-convex constraints lowered to JAX with gradients</p> <code>cvxpy_constraints</code> <code>LoweredCvxpyConstraints</code> <p>Convex constraints lowered to CVXPy</p> <code>x_unified</code> <code>UnifiedState</code> <p>Aggregated optimization state interface</p> <code>u_unified</code> <code>UnifiedControl</code> <p>Aggregated optimization control interface</p> <code>x_prop_unified</code> <code>UnifiedState</code> <p>Aggregated propagation state interface</p> <code>ocp_vars</code> <code>CVXPyVariables</code> <p>Typed CVXPy variables and parameters for OCP construction</p> <code>cvxpy_params</code> <code>Dict[str, Parameter]</code> <p>Dict mapping user parameter names to CVXPy Parameter objects</p> <code>algebraic_prop</code> <code>Optional[Dict[str, Callable]]</code> <p>Dict mapping output names to vmapped JAX functions (evaluated, not integrated)</p> Example <p>After lowering a symbolic problem::</p> <pre><code>lowered = lower_symbolic_problem(\n    dynamics_aug=dynamics,\n    states_aug=states,\n    controls_aug=controls,\n    constraints=constraint_set,\n    parameters=params,\n    N=50,\n)\n\n# Access components\ndx_dt = lowered.dynamics.f(x, u, node, params)\njacobian_A = lowered.dynamics.A(x, u, node, params)\n\n# Use CVXPy objects\nocp = OptimalControlProblem(settings, lowered)\n</code></pre> Source code in <code>openscvx/lowered/problem.py</code> <pre><code>@dataclass\nclass LoweredProblem:\n    \"\"\"Container for all outputs from symbolic problem lowering.\n\n    This dataclass holds all the results of lowering symbolic expressions\n    to executable JAX and CVXPy code. It provides a clean, typed interface\n    for accessing the various components needed for optimization.\n\n    Attributes:\n        dynamics: Optimization dynamics with fields f, A, B (JAX functions)\n        dynamics_prop: Propagation dynamics with fields f, A, B\n        jax_constraints: Non-convex constraints lowered to JAX with gradients\n        cvxpy_constraints: Convex constraints lowered to CVXPy\n        x_unified: Aggregated optimization state interface\n        u_unified: Aggregated optimization control interface\n        x_prop_unified: Aggregated propagation state interface\n        ocp_vars: Typed CVXPy variables and parameters for OCP construction\n        cvxpy_params: Dict mapping user parameter names to CVXPy Parameter objects\n        algebraic_prop: Dict mapping output names to vmapped JAX functions\n            (evaluated, not integrated)\n\n    Example:\n        After lowering a symbolic problem::\n\n            lowered = lower_symbolic_problem(\n                dynamics_aug=dynamics,\n                states_aug=states,\n                controls_aug=controls,\n                constraints=constraint_set,\n                parameters=params,\n                N=50,\n            )\n\n            # Access components\n            dx_dt = lowered.dynamics.f(x, u, node, params)\n            jacobian_A = lowered.dynamics.A(x, u, node, params)\n\n            # Use CVXPy objects\n            ocp = OptimalControlProblem(settings, lowered)\n    \"\"\"\n\n    # JAX dynamics\n    dynamics: Dynamics\n    dynamics_prop: Dynamics\n\n    # Lowered constraints (separate types for JAX vs CVXPy)\n    jax_constraints: LoweredJaxConstraints\n    cvxpy_constraints: LoweredCvxpyConstraints\n\n    # Unified interfaces\n    x_unified: UnifiedState\n    u_unified: UnifiedControl\n    x_prop_unified: UnifiedState\n\n    # CVXPy objects\n    ocp_vars: CVXPyVariables\n    cvxpy_params: Dict[str, \"cp.Parameter\"]\n\n    # Algebraic outputs (vmapped JAX functions for propagation)\n    algebraic_prop: Optional[Dict[str, Callable]] = field(default_factory=dict)\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.ParameterDict","title":"<code>ParameterDict</code>","text":"<p>               Bases: <code>dict</code></p> <p>Dictionary that syncs to both internal _parameters dict and CVXPy parameters.</p> This allows users to naturally update parameters like <p>problem.parameters[\"obs_radius\"] = 2.0</p> <p>Changes automatically propagate to: 1. Internal _parameters dict (plain dict for JAX) 2. CVXPy parameters (for optimization)</p> Source code in <code>openscvx/lowered/parameters.py</code> <pre><code>class ParameterDict(dict):\n    \"\"\"Dictionary that syncs to both internal _parameters dict and CVXPy parameters.\n\n    This allows users to naturally update parameters like:\n        problem.parameters[\"obs_radius\"] = 2.0\n\n    Changes automatically propagate to:\n    1. Internal _parameters dict (plain dict for JAX)\n    2. CVXPy parameters (for optimization)\n    \"\"\"\n\n    def __init__(self, problem, internal_dict, *args, **kwargs):\n        self._problem = problem\n        self._internal_dict = internal_dict  # Reference to plain dict for JAX\n        super().__init__()\n        # Initialize with float enforcement by using __setitem__\n        if args:\n            other = args[0]\n            if hasattr(other, \"items\"):\n                for key, value in other.items():\n                    self[key] = value\n            else:\n                for key, value in other:\n                    self[key] = value\n        for key, value in kwargs.items():\n            self[key] = value\n\n    def __setitem__(self, key, value):\n        # Enforce float dtype to prevent int/float mismatch bugs\n        value = np.asarray(value, dtype=float)\n        super().__setitem__(key, value)\n        # Sync to internal dict for JAX\n        self._internal_dict[key] = value\n        # Sync to CVXPy if it exists\n        lowered = getattr(self._problem, \"_lowered\", None)\n        if lowered is not None and key in lowered.cvxpy_params:\n            lowered.cvxpy_params[key].value = value\n\n    def update(self, other=None, **kwargs):\n        \"\"\"Update multiple parameters and sync to internal dict and CVXPy.\"\"\"\n        if other is not None:\n            if hasattr(other, \"items\"):\n                for key, value in other.items():\n                    self[key] = value\n            else:\n                for key, value in other:\n                    self[key] = value\n        for key, value in kwargs.items():\n            self[key] = value\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.ParameterDict.update","title":"<code>update(other=None, **kwargs)</code>","text":"<p>Update multiple parameters and sync to internal dict and CVXPy.</p> Source code in <code>openscvx/lowered/parameters.py</code> <pre><code>def update(self, other=None, **kwargs):\n    \"\"\"Update multiple parameters and sync to internal dict and CVXPy.\"\"\"\n    if other is not None:\n        if hasattr(other, \"items\"):\n            for key, value in other.items():\n                self[key] = value\n        else:\n            for key, value in other:\n                self[key] = value\n    for key, value in kwargs.items():\n        self[key] = value\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.UnifiedControl","title":"<code>UnifiedControl</code>  <code>dataclass</code>","text":"<p>Unified control vector aggregating multiple Control objects.</p> <p>UnifiedControl is a drop-in replacement for individual Control objects that holds aggregated data from multiple Control instances. It maintains compatibility with optimization infrastructure while providing access to individual control components through slicing.</p> <p>The unified control separates user-defined \"true\" controls from augmented controls added internally (e.g., for time dilation). This separation allows clean access to physical control inputs while supporting advanced features.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the unified control vector</p> <code>shape</code> <code>tuple</code> <p>Combined shape (total_dim,) of all aggregated controls</p> <code>min</code> <code>ndarray</code> <p>Lower bounds for all control variables, shape (total_dim,)</p> <code>max</code> <code>ndarray</code> <p>Upper bounds for all control variables, shape (total_dim,)</p> <code>guess</code> <code>ndarray</code> <p>Initial guess trajectory, shape (num_nodes, total_dim)</p> <code>_true_dim</code> <code>int</code> <p>Number of user-defined control dimensions (excludes augmented)</p> <code>_true_slice</code> <code>slice</code> <p>Slice for extracting true controls from unified vector</p> <code>_augmented_slice</code> <code>slice</code> <p>Slice for extracting augmented controls</p> <code>time_dilation_slice</code> <code>Optional[slice]</code> <p>Slice for time dilation control, if present</p> Properties <p>true: Returns UnifiedControl view containing only true (user-defined) controls augmented: Returns UnifiedControl view containing only augmented controls</p> Example <p>Creating a unified control from multiple Control objects::</p> <pre><code>from openscvx.symbolic.unified import unify_controls\n\nthrust = ox.Control(\"thrust\", shape=(3,), min=0, max=10)\ntorque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n\nunified = unify_controls([thrust, torque], name=\"u\")\nprint(unified.shape)        # (6,)\nprint(unified.min)          # [0, 0, 0, -1, -1, -1]\nprint(unified.true.shape)   # (6,) - all are true controls\nprint(unified.augmented.shape)  # (0,) - no augmented controls\n</code></pre> <p>Appending controls dynamically::</p> <pre><code>unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.0)  # Add scalar control\nprint(unified.shape)  # (1,)\n</code></pre> See Also <ul> <li>unify_controls(): Factory function for creating UnifiedControl from Control list</li> <li>Control: Individual symbolic control variable</li> <li>UnifiedState: Analogous unified state vector</li> </ul> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>@dataclass\nclass UnifiedControl:\n    \"\"\"Unified control vector aggregating multiple Control objects.\n\n    UnifiedControl is a drop-in replacement for individual Control objects that holds\n    aggregated data from multiple Control instances. It maintains compatibility with\n    optimization infrastructure while providing access to individual control components\n    through slicing.\n\n    The unified control separates user-defined \"true\" controls from augmented controls\n    added internally (e.g., for time dilation). This separation allows clean access to\n    physical control inputs while supporting advanced features.\n\n    Attributes:\n        name (str): Name identifier for the unified control vector\n        shape (tuple): Combined shape (total_dim,) of all aggregated controls\n        min (np.ndarray): Lower bounds for all control variables, shape (total_dim,)\n        max (np.ndarray): Upper bounds for all control variables, shape (total_dim,)\n        guess (np.ndarray): Initial guess trajectory, shape (num_nodes, total_dim)\n        _true_dim (int): Number of user-defined control dimensions (excludes augmented)\n        _true_slice (slice): Slice for extracting true controls from unified vector\n        _augmented_slice (slice): Slice for extracting augmented controls\n        time_dilation_slice (Optional[slice]): Slice for time dilation control, if present\n\n    Properties:\n        true: Returns UnifiedControl view containing only true (user-defined) controls\n        augmented: Returns UnifiedControl view containing only augmented controls\n\n    Example:\n        Creating a unified control from multiple Control objects::\n\n            from openscvx.symbolic.unified import unify_controls\n\n            thrust = ox.Control(\"thrust\", shape=(3,), min=0, max=10)\n            torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n\n            unified = unify_controls([thrust, torque], name=\"u\")\n            print(unified.shape)        # (6,)\n            print(unified.min)          # [0, 0, 0, -1, -1, -1]\n            print(unified.true.shape)   # (6,) - all are true controls\n            print(unified.augmented.shape)  # (0,) - no augmented controls\n\n        Appending controls dynamically::\n\n            unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.0)  # Add scalar control\n            print(unified.shape)  # (1,)\n\n    See Also:\n        - unify_controls(): Factory function for creating UnifiedControl from Control list\n        - Control: Individual symbolic control variable\n        - UnifiedState: Analogous unified state vector\n    \"\"\"\n\n    name: str\n    shape: tuple\n    min: Optional[np.ndarray] = None\n    max: Optional[np.ndarray] = None\n    guess: Optional[np.ndarray] = None\n    _true_dim: int = 0\n    _true_slice: Optional[slice] = None\n    _augmented_slice: Optional[slice] = None\n    time_dilation_slice: Optional[slice] = None  # Slice for time dilation control\n    scaling_min: Optional[np.ndarray] = None  # Scaling minimum bounds for unified control\n    scaling_max: Optional[np.ndarray] = None  # Scaling maximum bounds for unified control\n\n    def __post_init__(self):\n        \"\"\"Initialize slices after dataclass creation.\"\"\"\n        if self._true_slice is None:\n            self._true_slice = slice(0, self._true_dim)\n        if self._augmented_slice is None:\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    @property\n    def true(self) -&gt; \"UnifiedControl\":\n        \"\"\"Get the true (user-defined) control variables.\n\n        Returns a view of the unified control containing only user-defined controls,\n        excluding internal augmented controls added for time dilation, etc.\n\n        Returns:\n            UnifiedControl: Sliced view containing only true control variables\n\n        Example:\n            Get true user defined controls::\n\n                unified = unify_controls([thrust, torque, time_dilation], name=\"u\")\n                true_controls = unified.true  # Only thrust and torque\n        \"\"\"\n        return self[self._true_slice]\n\n    @property\n    def augmented(self) -&gt; \"UnifiedControl\":\n        \"\"\"Get the augmented (internal) control variables.\n\n        Returns a view of the unified control containing only augmented controls\n        added internally by the optimization framework (e.g., time dilation control).\n\n        Returns:\n            UnifiedControl: Sliced view containing only augmented control variables\n\n        Example:\n            Get augmented controls::\n\n                unified = unify_controls([thrust, time_dilation], name=\"u\")\n                aug_controls = unified.augmented  # Only time dilation\n        \"\"\"\n        return self[self._augmented_slice]\n\n    def append(\n        self,\n        other: \"Optional[Control | UnifiedControl]\" = None,\n        *,\n        min=-np.inf,\n        max=np.inf,\n        guess=0.0,\n        augmented=False,\n    ):\n        \"\"\"Append another control or create a new control variable.\n\n        This method allows dynamic extension of the unified control, either by appending\n        another Control/UnifiedControl object or by creating a new scalar control variable\n        with specified properties. Modifies the unified control in-place.\n\n        Args:\n            other (Optional[Control | UnifiedControl]): Control object to append. If None,\n                creates a new scalar control variable with properties from keyword args.\n            min (float): Lower bound for new scalar control (default: -inf)\n            max (float): Upper bound for new scalar control (default: inf)\n            guess (float): Initial guess value for new scalar control (default: 0.0)\n            augmented (bool): Whether the appended control is augmented (internal) rather\n                than true (user-defined). Affects _true_dim tracking. Default: False\n\n        Returns:\n            None: Modifies the unified control in-place\n\n        Example:\n            Appending a Control object::\n\n                unified = unify_controls([thrust], name=\"u\")\n                torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n                unified.append(torque)\n                print(unified.shape)  # (6,) - thrust (3) + torque (3)\n\n            Creating new scalar control variables::\n\n                unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\n                unified.append(min=-1, max=1, guess=0.0)  # Add scalar control\n                print(unified.shape)  # (1,)\n        \"\"\"\n        # Import here to avoid circular imports at module level\n        from openscvx.symbolic.expr.control import Control\n\n        if isinstance(other, (Control, UnifiedControl)):\n            # Append another control object\n            new_shape = (self.shape[0] + other.shape[0],)\n\n            # Update bounds\n            if self.min is not None and other.min is not None:\n                new_min = np.concatenate([self.min, other.min])\n            else:\n                new_min = self.min\n\n            if self.max is not None and other.max is not None:\n                new_max = np.concatenate([self.max, other.max])\n            else:\n                new_max = self.max\n\n            # Update guess\n            if self.guess is not None and other.guess is not None:\n                new_guess = np.concatenate([self.guess, other.guess], axis=1)\n            else:\n                new_guess = self.guess\n\n            # Update scaling bounds (if present)\n            if (\n                self.scaling_min is not None\n                and hasattr(other, \"scaling_min\")\n                and other.scaling_min is not None\n            ):\n                new_scaling_min = np.concatenate([self.scaling_min, other.scaling_min])\n            else:\n                new_scaling_min = self.scaling_min\n\n            if (\n                self.scaling_max is not None\n                and hasattr(other, \"scaling_max\")\n                and other.scaling_max is not None\n            ):\n                new_scaling_max = np.concatenate([self.scaling_max, other.scaling_max])\n            else:\n                new_scaling_max = self.scaling_max\n\n            # Update true dimension\n            if not augmented:\n                new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n            else:\n                new_true_dim = self._true_dim\n\n            # Update all attributes in place\n            self.shape = new_shape\n            self.min = new_min\n            self.max = new_max\n            self.guess = new_guess\n            self.scaling_min = new_scaling_min\n            self.scaling_max = new_scaling_max\n            self._true_dim = new_true_dim\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n        else:\n            # Create a single new variable\n            new_shape = (self.shape[0] + 1,)\n\n            # Extend arrays\n            if self.min is not None:\n                self.min = np.concatenate([self.min, np.array([min])])\n            if self.max is not None:\n                self.max = np.concatenate([self.max, np.array([max])])\n            if self.guess is not None:\n                guess_arr = np.full((self.guess.shape[0], 1), guess)\n                self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n            if self.scaling_min is not None:\n                self.scaling_min = np.concatenate([self.scaling_min, np.array([min])])\n            if self.scaling_max is not None:\n                self.scaling_max = np.concatenate([self.scaling_max, np.array([max])])\n\n            # Update dimensions\n            self.shape = new_shape\n            if not augmented:\n                self._true_dim += 1\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    def __getitem__(self, idx):\n        \"\"\"Get a subset of the unified control variables.\n\n        Enables slicing of the unified control to extract subsets of control variables.\n        Returns a new UnifiedControl containing only the sliced dimensions.\n\n        Args:\n            idx (slice): Slice object specifying which control dimensions to extract.\n                Only simple slices with step=1 are supported.\n\n        Returns:\n            UnifiedControl: New unified control containing only the sliced dimensions\n\n        Raises:\n            NotImplementedError: If idx is not a slice, or if step != 1\n\n        Example:\n            Generate unified control object::\n\n                unified = unify_controls([thrust, torque], name=\"u\")\n\n            thrust has shape (3,), torque has shape (3,)::\n\n                first_three = unified[0:3]  # Extract thrust only\n                print(first_three.shape)  # (3,)\n\n        Note:\n            The sliced control maintains all properties (bounds, guesses, etc.) for\n            the selected dimensions. The _true_dim is recalculated based on which\n            dimensions fall within the original true control range.\n        \"\"\"\n        if isinstance(idx, slice):\n            start, stop, step = idx.indices(self.shape[0])\n            if step != 1:\n                raise NotImplementedError(\"Step slicing not supported\")\n\n            new_shape = (stop - start,)\n            new_name = f\"{self.name}[{start}:{stop}]\"\n\n            # Slice all arrays\n            new_min = self.min[idx] if self.min is not None else None\n            new_max = self.max[idx] if self.max is not None else None\n            new_guess = self.guess[:, idx] if self.guess is not None else None\n\n            # Calculate new true dimension\n            new_true_dim = max(0, min(stop, self._true_dim) - max(start, 0))\n\n            return UnifiedControl(\n                name=new_name,\n                shape=new_shape,\n                min=new_min,\n                max=new_max,\n                guess=new_guess,\n                _true_dim=new_true_dim,\n                _true_slice=slice(0, new_true_dim),\n                _augmented_slice=slice(new_true_dim, new_shape[0]),\n            )\n        else:\n            raise NotImplementedError(\"Only slice indexing is supported\")\n\n    def __repr__(self):\n        \"\"\"String representation of the UnifiedControl object.\"\"\"\n        return f\"UnifiedControl('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.UnifiedControl.augmented","title":"<code>augmented: UnifiedControl</code>  <code>property</code>","text":"<p>Get the augmented (internal) control variables.</p> <p>Returns a view of the unified control containing only augmented controls added internally by the optimization framework (e.g., time dilation control).</p> <p>Returns:</p> Name Type Description <code>UnifiedControl</code> <code>UnifiedControl</code> <p>Sliced view containing only augmented control variables</p> Example <p>Get augmented controls::</p> <pre><code>unified = unify_controls([thrust, time_dilation], name=\"u\")\naug_controls = unified.augmented  # Only time dilation\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.UnifiedControl.true","title":"<code>true: UnifiedControl</code>  <code>property</code>","text":"<p>Get the true (user-defined) control variables.</p> <p>Returns a view of the unified control containing only user-defined controls, excluding internal augmented controls added for time dilation, etc.</p> <p>Returns:</p> Name Type Description <code>UnifiedControl</code> <code>UnifiedControl</code> <p>Sliced view containing only true control variables</p> Example <p>Get true user defined controls::</p> <pre><code>unified = unify_controls([thrust, torque, time_dilation], name=\"u\")\ntrue_controls = unified.true  # Only thrust and torque\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.UnifiedControl.append","title":"<code>append(other: Optional[Control | UnifiedControl] = None, *, min=-np.inf, max=np.inf, guess=0.0, augmented=False)</code>","text":"<p>Append another control or create a new control variable.</p> <p>This method allows dynamic extension of the unified control, either by appending another Control/UnifiedControl object or by creating a new scalar control variable with specified properties. Modifies the unified control in-place.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Optional[Control | UnifiedControl]</code> <p>Control object to append. If None, creates a new scalar control variable with properties from keyword args.</p> <code>None</code> <code>min</code> <code>float</code> <p>Lower bound for new scalar control (default: -inf)</p> <code>-inf</code> <code>max</code> <code>float</code> <p>Upper bound for new scalar control (default: inf)</p> <code>inf</code> <code>guess</code> <code>float</code> <p>Initial guess value for new scalar control (default: 0.0)</p> <code>0.0</code> <code>augmented</code> <code>bool</code> <p>Whether the appended control is augmented (internal) rather than true (user-defined). Affects _true_dim tracking. Default: False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <p>Modifies the unified control in-place</p> Example <p>Appending a Control object::</p> <pre><code>unified = unify_controls([thrust], name=\"u\")\ntorque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\nunified.append(torque)\nprint(unified.shape)  # (6,) - thrust (3) + torque (3)\n</code></pre> <p>Creating new scalar control variables::</p> <pre><code>unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.0)  # Add scalar control\nprint(unified.shape)  # (1,)\n</code></pre> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>def append(\n    self,\n    other: \"Optional[Control | UnifiedControl]\" = None,\n    *,\n    min=-np.inf,\n    max=np.inf,\n    guess=0.0,\n    augmented=False,\n):\n    \"\"\"Append another control or create a new control variable.\n\n    This method allows dynamic extension of the unified control, either by appending\n    another Control/UnifiedControl object or by creating a new scalar control variable\n    with specified properties. Modifies the unified control in-place.\n\n    Args:\n        other (Optional[Control | UnifiedControl]): Control object to append. If None,\n            creates a new scalar control variable with properties from keyword args.\n        min (float): Lower bound for new scalar control (default: -inf)\n        max (float): Upper bound for new scalar control (default: inf)\n        guess (float): Initial guess value for new scalar control (default: 0.0)\n        augmented (bool): Whether the appended control is augmented (internal) rather\n            than true (user-defined). Affects _true_dim tracking. Default: False\n\n    Returns:\n        None: Modifies the unified control in-place\n\n    Example:\n        Appending a Control object::\n\n            unified = unify_controls([thrust], name=\"u\")\n            torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n            unified.append(torque)\n            print(unified.shape)  # (6,) - thrust (3) + torque (3)\n\n        Creating new scalar control variables::\n\n            unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.0)  # Add scalar control\n            print(unified.shape)  # (1,)\n    \"\"\"\n    # Import here to avoid circular imports at module level\n    from openscvx.symbolic.expr.control import Control\n\n    if isinstance(other, (Control, UnifiedControl)):\n        # Append another control object\n        new_shape = (self.shape[0] + other.shape[0],)\n\n        # Update bounds\n        if self.min is not None and other.min is not None:\n            new_min = np.concatenate([self.min, other.min])\n        else:\n            new_min = self.min\n\n        if self.max is not None and other.max is not None:\n            new_max = np.concatenate([self.max, other.max])\n        else:\n            new_max = self.max\n\n        # Update guess\n        if self.guess is not None and other.guess is not None:\n            new_guess = np.concatenate([self.guess, other.guess], axis=1)\n        else:\n            new_guess = self.guess\n\n        # Update scaling bounds (if present)\n        if (\n            self.scaling_min is not None\n            and hasattr(other, \"scaling_min\")\n            and other.scaling_min is not None\n        ):\n            new_scaling_min = np.concatenate([self.scaling_min, other.scaling_min])\n        else:\n            new_scaling_min = self.scaling_min\n\n        if (\n            self.scaling_max is not None\n            and hasattr(other, \"scaling_max\")\n            and other.scaling_max is not None\n        ):\n            new_scaling_max = np.concatenate([self.scaling_max, other.scaling_max])\n        else:\n            new_scaling_max = self.scaling_max\n\n        # Update true dimension\n        if not augmented:\n            new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n        else:\n            new_true_dim = self._true_dim\n\n        # Update all attributes in place\n        self.shape = new_shape\n        self.min = new_min\n        self.max = new_max\n        self.guess = new_guess\n        self.scaling_min = new_scaling_min\n        self.scaling_max = new_scaling_max\n        self._true_dim = new_true_dim\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    else:\n        # Create a single new variable\n        new_shape = (self.shape[0] + 1,)\n\n        # Extend arrays\n        if self.min is not None:\n            self.min = np.concatenate([self.min, np.array([min])])\n        if self.max is not None:\n            self.max = np.concatenate([self.max, np.array([max])])\n        if self.guess is not None:\n            guess_arr = np.full((self.guess.shape[0], 1), guess)\n            self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n        if self.scaling_min is not None:\n            self.scaling_min = np.concatenate([self.scaling_min, np.array([min])])\n        if self.scaling_max is not None:\n            self.scaling_max = np.concatenate([self.scaling_max, np.array([max])])\n\n        # Update dimensions\n        self.shape = new_shape\n        if not augmented:\n            self._true_dim += 1\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.UnifiedState","title":"<code>UnifiedState</code>  <code>dataclass</code>","text":"<p>Unified state vector aggregating multiple State objects.</p> <p>UnifiedState is a drop-in replacement for individual State objects that holds aggregated data from multiple State instances. It maintains compatibility with optimization infrastructure while providing access to individual state components through slicing.</p> <p>The unified state separates user-defined \"true\" states from augmented states added internally (e.g., for CTCS constraints or time variables). This separation allows clean access to physical states while supporting advanced features.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the unified state vector</p> <code>shape</code> <code>tuple</code> <p>Combined shape (total_dim,) of all aggregated states</p> <code>min</code> <code>ndarray</code> <p>Lower bounds for all state variables, shape (total_dim,)</p> <code>max</code> <code>ndarray</code> <p>Upper bounds for all state variables, shape (total_dim,)</p> <code>guess</code> <code>ndarray</code> <p>Initial guess trajectory, shape (num_nodes, total_dim)</p> <code>initial</code> <code>ndarray</code> <p>Initial boundary conditions, shape (total_dim,)</p> <code>final</code> <code>ndarray</code> <p>Final boundary conditions, shape (total_dim,)</p> <code>_initial</code> <code>ndarray</code> <p>Internal initial values, shape (total_dim,)</p> <code>_final</code> <code>ndarray</code> <p>Internal final values, shape (total_dim,)</p> <code>initial_type</code> <code>ndarray</code> <p>Boundary condition types at t0 (\"Fix\" or \"Free\"), shape (total_dim,), dtype=object</p> <code>final_type</code> <code>ndarray</code> <p>Boundary condition types at tf (\"Fix\" or \"Free\"), shape (total_dim,), dtype=object</p> <code>_true_dim</code> <code>int</code> <p>Number of user-defined state dimensions (excludes augmented)</p> <code>_true_slice</code> <code>slice</code> <p>Slice for extracting true states from unified vector</p> <code>_augmented_slice</code> <code>slice</code> <p>Slice for extracting augmented states</p> <code>time_slice</code> <code>Optional[slice]</code> <p>Slice for time state variable, if present</p> <code>ctcs_slice</code> <code>Optional[slice]</code> <p>Slice for CTCS augmented states, if present</p> Properties <p>true: Returns UnifiedState view containing only true (user-defined) states augmented: Returns UnifiedState view containing only augmented states</p> Example <p>Creating a unified state from multiple State objects::</p> <pre><code>from openscvx.symbolic.unified import unify_states\n\nposition = ox.State(\"pos\", shape=(3,), min=-10, max=10)\nvelocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n\nunified = unify_states([position, velocity], name=\"x\")\nprint(unified.shape)        # (6,)\nprint(unified.min)          # [-10, -10, -10, -5, -5, -5]\nprint(unified.true.shape)   # (6,) - all are true states\nprint(unified.augmented.shape)  # (0,) - no augmented states\n</code></pre> <p>Appending states dynamically::</p> <pre><code>unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.5)  # Add scalar state\nprint(unified.shape)  # (1,)\n</code></pre> See Also <ul> <li>unify_states(): Factory function for creating UnifiedState from State list</li> <li>State: Individual symbolic state variable</li> <li>UnifiedControl: Analogous unified control vector</li> </ul> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>@dataclass\nclass UnifiedState:\n    \"\"\"Unified state vector aggregating multiple State objects.\n\n    UnifiedState is a drop-in replacement for individual State objects that holds\n    aggregated data from multiple State instances. It maintains compatibility with\n    optimization infrastructure while providing access to individual state components\n    through slicing.\n\n    The unified state separates user-defined \"true\" states from augmented states\n    added internally (e.g., for CTCS constraints or time variables). This separation\n    allows clean access to physical states while supporting advanced features.\n\n    Attributes:\n        name (str): Name identifier for the unified state vector\n        shape (tuple): Combined shape (total_dim,) of all aggregated states\n        min (np.ndarray): Lower bounds for all state variables, shape (total_dim,)\n        max (np.ndarray): Upper bounds for all state variables, shape (total_dim,)\n        guess (np.ndarray): Initial guess trajectory, shape (num_nodes, total_dim)\n        initial (np.ndarray): Initial boundary conditions, shape (total_dim,)\n        final (np.ndarray): Final boundary conditions, shape (total_dim,)\n        _initial (np.ndarray): Internal initial values, shape (total_dim,)\n        _final (np.ndarray): Internal final values, shape (total_dim,)\n        initial_type (np.ndarray): Boundary condition types at t0 (\"Fix\" or \"Free\"),\n            shape (total_dim,), dtype=object\n        final_type (np.ndarray): Boundary condition types at tf (\"Fix\" or \"Free\"),\n            shape (total_dim,), dtype=object\n        _true_dim (int): Number of user-defined state dimensions (excludes augmented)\n        _true_slice (slice): Slice for extracting true states from unified vector\n        _augmented_slice (slice): Slice for extracting augmented states\n        time_slice (Optional[slice]): Slice for time state variable, if present\n        ctcs_slice (Optional[slice]): Slice for CTCS augmented states, if present\n\n    Properties:\n        true: Returns UnifiedState view containing only true (user-defined) states\n        augmented: Returns UnifiedState view containing only augmented states\n\n    Example:\n        Creating a unified state from multiple State objects::\n\n            from openscvx.symbolic.unified import unify_states\n\n            position = ox.State(\"pos\", shape=(3,), min=-10, max=10)\n            velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n\n            unified = unify_states([position, velocity], name=\"x\")\n            print(unified.shape)        # (6,)\n            print(unified.min)          # [-10, -10, -10, -5, -5, -5]\n            print(unified.true.shape)   # (6,) - all are true states\n            print(unified.augmented.shape)  # (0,) - no augmented states\n\n        Appending states dynamically::\n\n            unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.5)  # Add scalar state\n            print(unified.shape)  # (1,)\n\n    See Also:\n        - unify_states(): Factory function for creating UnifiedState from State list\n        - State: Individual symbolic state variable\n        - UnifiedControl: Analogous unified control vector\n    \"\"\"\n\n    name: str\n    shape: tuple\n    min: Optional[np.ndarray] = None\n    max: Optional[np.ndarray] = None\n    guess: Optional[np.ndarray] = None\n    initial: Optional[np.ndarray] = None\n    final: Optional[np.ndarray] = None\n    _initial: Optional[np.ndarray] = None\n    _final: Optional[np.ndarray] = None\n    initial_type: Optional[np.ndarray] = None\n    final_type: Optional[np.ndarray] = None\n    _true_dim: int = 0\n    _true_slice: Optional[slice] = None\n    _augmented_slice: Optional[slice] = None\n    time_slice: Optional[slice] = None  # Slice for time state\n    ctcs_slice: Optional[slice] = None  # Slice for CTCS augmented states\n    scaling_min: Optional[np.ndarray] = None  # Scaling minimum bounds for unified state\n    scaling_max: Optional[np.ndarray] = None  # Scaling maximum bounds for unified state\n\n    def __post_init__(self):\n        \"\"\"Initialize slices after dataclass creation.\"\"\"\n        if self._true_slice is None:\n            self._true_slice = slice(0, self._true_dim)\n        if self._augmented_slice is None:\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    @property\n    def true(self) -&gt; \"UnifiedState\":\n        \"\"\"Get the true (user-defined) state variables.\n\n        Returns a view of the unified state containing only user-defined states,\n        excluding internal augmented states added for CTCS, time, etc.\n\n        Returns:\n            UnifiedState: Sliced view containing only true state variables\n\n        Example:\n            Get true user-defined state::\n\n                unified = unify_states([position, velocity, ctcs_aug], name=\"x\")\n                true_states = unified.true  # Only position and velocity\n                true_states.shape  # (6,) if position and velocity are 3D each\n        \"\"\"\n        return self[self._true_slice]\n\n    @property\n    def augmented(self) -&gt; \"UnifiedState\":\n        \"\"\"Get the augmented (internal) state variables.\n\n        Returns a view of the unified state containing only augmented states\n        added internally by the optimization framework (e.g., CTCS penalty states,\n        time variables).\n\n        Returns:\n            UnifiedState: Sliced view containing only augmented state variables\n\n        Example:\n            Get augmented state::\n\n                unified = unify_states([position, ctcs_aug], name=\"x\")\n                aug_states = unified.augmented  # Only CTCS states\n        \"\"\"\n        return self[self._augmented_slice]\n\n    def append(\n        self,\n        other: \"Optional[State | UnifiedState]\" = None,\n        *,\n        min=-np.inf,\n        max=np.inf,\n        guess=0.0,\n        initial=0.0,\n        final=0.0,\n        augmented=False,\n    ):\n        \"\"\"Append another state or create a new state variable.\n\n        This method allows dynamic extension of the unified state, either by appending\n        another State/UnifiedState object or by creating a new scalar state variable\n        with specified properties. Modifies the unified state in-place.\n\n        Args:\n            other (Optional[State | UnifiedState]): State object to append. If None,\n                creates a new scalar state variable with properties from keyword args.\n            min (float): Lower bound for new scalar state (default: -inf)\n            max (float): Upper bound for new scalar state (default: inf)\n            guess (float): Initial guess value for new scalar state (default: 0.0)\n            initial (float): Initial boundary condition for new scalar state (default: 0.0)\n            final (float): Final boundary condition for new scalar state (default: 0.0)\n            augmented (bool): Whether the appended state is augmented (internal) rather\n                than true (user-defined). Affects _true_dim tracking. Default: False\n\n        Returns:\n            None: Modifies the unified state in-place\n\n        Example:\n            Appending a State object::\n\n                unified = unify_states([position], name=\"x\")\n                velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n                unified.append(velocity)\n                print(unified.shape)  # (6,) - position (3) + velocity (3)\n\n            Creating new scalar state variables::\n\n                unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\n                unified.append(min=-1, max=1, guess=0.5)  # Add scalar state\n                unified.append(min=-2, max=2, augmented=True)  # Add augmented state\n                print(unified.shape)  # (2,)\n                print(unified._true_dim)  # 1 (only first is true)\n\n        Note:\n            Maintains the invariant that true states appear before augmented states\n            in the unified vector. When appending augmented states, they are added\n            to the end but don't increment _true_dim.\n        \"\"\"\n        # Import here to avoid circular imports at module level\n        from openscvx.symbolic.expr.state import State\n\n        if isinstance(other, (State, UnifiedState)):\n            # Append another state object\n            new_shape = (self.shape[0] + other.shape[0],)\n\n            # Update bounds\n            if self.min is not None and other.min is not None:\n                new_min = np.concatenate([self.min, other.min])\n            else:\n                new_min = self.min\n\n            if self.max is not None and other.max is not None:\n                new_max = np.concatenate([self.max, other.max])\n            else:\n                new_max = self.max\n\n            # Update guess\n            if self.guess is not None and other.guess is not None:\n                new_guess = np.concatenate([self.guess, other.guess], axis=1)\n            else:\n                new_guess = self.guess\n\n            # Update initial/final conditions\n            if self.initial is not None and other.initial is not None:\n                new_initial = np.concatenate([self.initial, other.initial])\n            else:\n                new_initial = self.initial\n\n            if self.final is not None and other.final is not None:\n                new_final = np.concatenate([self.final, other.final])\n            else:\n                new_final = self.final\n\n            # Update internal arrays\n            if self._initial is not None and other._initial is not None:\n                new__initial = np.concatenate([self._initial, other._initial])\n            else:\n                new__initial = self._initial\n\n            if self._final is not None and other._final is not None:\n                new__final = np.concatenate([self._final, other._final])\n            else:\n                new__final = self._final\n\n            # Update types\n            if self.initial_type is not None and other.initial_type is not None:\n                new_initial_type = np.concatenate([self.initial_type, other.initial_type])\n            else:\n                new_initial_type = self.initial_type\n\n            if self.final_type is not None and other.final_type is not None:\n                new_final_type = np.concatenate([self.final_type, other.final_type])\n            else:\n                new_final_type = self.final_type\n\n            # Update scaling bounds (if present)\n            if (\n                self.scaling_min is not None\n                and hasattr(other, \"scaling_min\")\n                and other.scaling_min is not None\n            ):\n                new_scaling_min = np.concatenate([self.scaling_min, other.scaling_min])\n            else:\n                new_scaling_min = self.scaling_min\n\n            if (\n                self.scaling_max is not None\n                and hasattr(other, \"scaling_max\")\n                and other.scaling_max is not None\n            ):\n                new_scaling_max = np.concatenate([self.scaling_max, other.scaling_max])\n            else:\n                new_scaling_max = self.scaling_max\n\n            # Update true dimension\n            if not augmented:\n                new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n            else:\n                new_true_dim = self._true_dim\n\n            # Update all attributes in place\n            self.shape = new_shape\n            self.min = new_min\n            self.max = new_max\n            self.guess = new_guess\n            self.initial = new_initial\n            self.final = new_final\n            self._initial = new__initial\n            self._final = new__final\n            self.initial_type = new_initial_type\n            self.final_type = new_final_type\n            self.scaling_min = new_scaling_min\n            self.scaling_max = new_scaling_max\n            self._true_dim = new_true_dim\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n        else:\n            # Create a single new variable\n            new_shape = (self.shape[0] + 1,)\n\n            # Extend arrays\n            if self.min is not None:\n                self.min = np.concatenate([self.min, np.array([min])])\n            if self.max is not None:\n                self.max = np.concatenate([self.max, np.array([max])])\n            if self.guess is not None:\n                guess_arr = np.full((self.guess.shape[0], 1), guess)\n                self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n            if self.initial is not None:\n                self.initial = np.concatenate([self.initial, np.array([initial])])\n            if self.final is not None:\n                self.final = np.concatenate([self.final, np.array([final])])\n            if self._initial is not None:\n                self._initial = np.concatenate([self._initial, np.array([initial])])\n            if self._final is not None:\n                self._final = np.concatenate([self._final, np.array([final])])\n            if self.initial_type is not None:\n                self.initial_type = np.concatenate(\n                    [self.initial_type, np.array([\"Fix\"], dtype=object)]\n                )\n            if self.final_type is not None:\n                self.final_type = np.concatenate([self.final_type, np.array([\"Fix\"], dtype=object)])\n            if self.scaling_min is not None:\n                self.scaling_min = np.concatenate([self.scaling_min, np.array([min])])\n            if self.scaling_max is not None:\n                self.scaling_max = np.concatenate([self.scaling_max, np.array([max])])\n\n            # Update dimensions\n            self.shape = new_shape\n            if not augmented:\n                self._true_dim += 1\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    def __getitem__(self, idx):\n        \"\"\"Get a subset of the unified state variables.\n\n        Enables slicing of the unified state to extract subsets of state variables.\n        Returns a new UnifiedState containing only the sliced dimensions.\n\n        Args:\n            idx (slice): Slice object specifying which state dimensions to extract.\n                Only simple slices with step=1 are supported.\n\n        Returns:\n            UnifiedState: New unified state containing only the sliced dimensions\n\n        Raises:\n            NotImplementedError: If idx is not a slice, or if step != 1\n\n        Example:\n            Generate unified state object::\n\n                unified = unify_states([position, velocity], name=\"x\")\n\n            position has shape (3,), velocity has shape (3,)::\n\n                first_three = unified[0:3]  # Extract position only\n                print(first_three.shape)  # (3,)\n                last_three = unified[3:6]  # Extract velocity only\n                print(last_three.shape)  # (3,)\n\n        Note:\n            The sliced state maintains all properties (bounds, guesses, etc.) for\n            the selected dimensions. The _true_dim is recalculated based on which\n            dimensions fall within the original true state range.\n        \"\"\"\n        if isinstance(idx, slice):\n            start, stop, step = idx.indices(self.shape[0])\n            if step != 1:\n                raise NotImplementedError(\"Step slicing not supported\")\n\n            new_shape = (stop - start,)\n            new_name = f\"{self.name}[{start}:{stop}]\"\n\n            # Slice all arrays\n            new_min = self.min[idx] if self.min is not None else None\n            new_max = self.max[idx] if self.max is not None else None\n            new_guess = self.guess[:, idx] if self.guess is not None else None\n            new_initial = self.initial[idx] if self.initial is not None else None\n            new_final = self.final[idx] if self.final is not None else None\n            new__initial = self._initial[idx] if self._initial is not None else None\n            new__final = self._final[idx] if self._final is not None else None\n            new_initial_type = self.initial_type[idx] if self.initial_type is not None else None\n            new_final_type = self.final_type[idx] if self.final_type is not None else None\n\n            # Calculate new true dimension\n            new_true_dim = max(0, min(stop, self._true_dim) - max(start, 0))\n\n            return UnifiedState(\n                name=new_name,\n                shape=new_shape,\n                min=new_min,\n                max=new_max,\n                guess=new_guess,\n                initial=new_initial,\n                final=new_final,\n                _initial=new__initial,\n                _final=new__final,\n                initial_type=new_initial_type,\n                final_type=new_final_type,\n                _true_dim=new_true_dim,\n                _true_slice=slice(0, new_true_dim),\n                _augmented_slice=slice(new_true_dim, new_shape[0]),\n            )\n        else:\n            raise NotImplementedError(\"Only slice indexing is supported\")\n\n    def __repr__(self):\n        \"\"\"String representation of the UnifiedState object.\"\"\"\n        return f\"UnifiedState('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.UnifiedState.augmented","title":"<code>augmented: UnifiedState</code>  <code>property</code>","text":"<p>Get the augmented (internal) state variables.</p> <p>Returns a view of the unified state containing only augmented states added internally by the optimization framework (e.g., CTCS penalty states, time variables).</p> <p>Returns:</p> Name Type Description <code>UnifiedState</code> <code>UnifiedState</code> <p>Sliced view containing only augmented state variables</p> Example <p>Get augmented state::</p> <pre><code>unified = unify_states([position, ctcs_aug], name=\"x\")\naug_states = unified.augmented  # Only CTCS states\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.UnifiedState.true","title":"<code>true: UnifiedState</code>  <code>property</code>","text":"<p>Get the true (user-defined) state variables.</p> <p>Returns a view of the unified state containing only user-defined states, excluding internal augmented states added for CTCS, time, etc.</p> <p>Returns:</p> Name Type Description <code>UnifiedState</code> <code>UnifiedState</code> <p>Sliced view containing only true state variables</p> Example <p>Get true user-defined state::</p> <pre><code>unified = unify_states([position, velocity, ctcs_aug], name=\"x\")\ntrue_states = unified.true  # Only position and velocity\ntrue_states.shape  # (6,) if position and velocity are 3D each\n</code></pre>"},{"location":"reference/lowered/#openscvx.lowered.UnifiedState.append","title":"<code>append(other: Optional[State | UnifiedState] = None, *, min=-np.inf, max=np.inf, guess=0.0, initial=0.0, final=0.0, augmented=False)</code>","text":"<p>Append another state or create a new state variable.</p> <p>This method allows dynamic extension of the unified state, either by appending another State/UnifiedState object or by creating a new scalar state variable with specified properties. Modifies the unified state in-place.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Optional[State | UnifiedState]</code> <p>State object to append. If None, creates a new scalar state variable with properties from keyword args.</p> <code>None</code> <code>min</code> <code>float</code> <p>Lower bound for new scalar state (default: -inf)</p> <code>-inf</code> <code>max</code> <code>float</code> <p>Upper bound for new scalar state (default: inf)</p> <code>inf</code> <code>guess</code> <code>float</code> <p>Initial guess value for new scalar state (default: 0.0)</p> <code>0.0</code> <code>initial</code> <code>float</code> <p>Initial boundary condition for new scalar state (default: 0.0)</p> <code>0.0</code> <code>final</code> <code>float</code> <p>Final boundary condition for new scalar state (default: 0.0)</p> <code>0.0</code> <code>augmented</code> <code>bool</code> <p>Whether the appended state is augmented (internal) rather than true (user-defined). Affects _true_dim tracking. Default: False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <p>Modifies the unified state in-place</p> Example <p>Appending a State object::</p> <pre><code>unified = unify_states([position], name=\"x\")\nvelocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\nunified.append(velocity)\nprint(unified.shape)  # (6,) - position (3) + velocity (3)\n</code></pre> <p>Creating new scalar state variables::</p> <pre><code>unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.5)  # Add scalar state\nunified.append(min=-2, max=2, augmented=True)  # Add augmented state\nprint(unified.shape)  # (2,)\nprint(unified._true_dim)  # 1 (only first is true)\n</code></pre> Note <p>Maintains the invariant that true states appear before augmented states in the unified vector. When appending augmented states, they are added to the end but don't increment _true_dim.</p> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>def append(\n    self,\n    other: \"Optional[State | UnifiedState]\" = None,\n    *,\n    min=-np.inf,\n    max=np.inf,\n    guess=0.0,\n    initial=0.0,\n    final=0.0,\n    augmented=False,\n):\n    \"\"\"Append another state or create a new state variable.\n\n    This method allows dynamic extension of the unified state, either by appending\n    another State/UnifiedState object or by creating a new scalar state variable\n    with specified properties. Modifies the unified state in-place.\n\n    Args:\n        other (Optional[State | UnifiedState]): State object to append. If None,\n            creates a new scalar state variable with properties from keyword args.\n        min (float): Lower bound for new scalar state (default: -inf)\n        max (float): Upper bound for new scalar state (default: inf)\n        guess (float): Initial guess value for new scalar state (default: 0.0)\n        initial (float): Initial boundary condition for new scalar state (default: 0.0)\n        final (float): Final boundary condition for new scalar state (default: 0.0)\n        augmented (bool): Whether the appended state is augmented (internal) rather\n            than true (user-defined). Affects _true_dim tracking. Default: False\n\n    Returns:\n        None: Modifies the unified state in-place\n\n    Example:\n        Appending a State object::\n\n            unified = unify_states([position], name=\"x\")\n            velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n            unified.append(velocity)\n            print(unified.shape)  # (6,) - position (3) + velocity (3)\n\n        Creating new scalar state variables::\n\n            unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.5)  # Add scalar state\n            unified.append(min=-2, max=2, augmented=True)  # Add augmented state\n            print(unified.shape)  # (2,)\n            print(unified._true_dim)  # 1 (only first is true)\n\n    Note:\n        Maintains the invariant that true states appear before augmented states\n        in the unified vector. When appending augmented states, they are added\n        to the end but don't increment _true_dim.\n    \"\"\"\n    # Import here to avoid circular imports at module level\n    from openscvx.symbolic.expr.state import State\n\n    if isinstance(other, (State, UnifiedState)):\n        # Append another state object\n        new_shape = (self.shape[0] + other.shape[0],)\n\n        # Update bounds\n        if self.min is not None and other.min is not None:\n            new_min = np.concatenate([self.min, other.min])\n        else:\n            new_min = self.min\n\n        if self.max is not None and other.max is not None:\n            new_max = np.concatenate([self.max, other.max])\n        else:\n            new_max = self.max\n\n        # Update guess\n        if self.guess is not None and other.guess is not None:\n            new_guess = np.concatenate([self.guess, other.guess], axis=1)\n        else:\n            new_guess = self.guess\n\n        # Update initial/final conditions\n        if self.initial is not None and other.initial is not None:\n            new_initial = np.concatenate([self.initial, other.initial])\n        else:\n            new_initial = self.initial\n\n        if self.final is not None and other.final is not None:\n            new_final = np.concatenate([self.final, other.final])\n        else:\n            new_final = self.final\n\n        # Update internal arrays\n        if self._initial is not None and other._initial is not None:\n            new__initial = np.concatenate([self._initial, other._initial])\n        else:\n            new__initial = self._initial\n\n        if self._final is not None and other._final is not None:\n            new__final = np.concatenate([self._final, other._final])\n        else:\n            new__final = self._final\n\n        # Update types\n        if self.initial_type is not None and other.initial_type is not None:\n            new_initial_type = np.concatenate([self.initial_type, other.initial_type])\n        else:\n            new_initial_type = self.initial_type\n\n        if self.final_type is not None and other.final_type is not None:\n            new_final_type = np.concatenate([self.final_type, other.final_type])\n        else:\n            new_final_type = self.final_type\n\n        # Update scaling bounds (if present)\n        if (\n            self.scaling_min is not None\n            and hasattr(other, \"scaling_min\")\n            and other.scaling_min is not None\n        ):\n            new_scaling_min = np.concatenate([self.scaling_min, other.scaling_min])\n        else:\n            new_scaling_min = self.scaling_min\n\n        if (\n            self.scaling_max is not None\n            and hasattr(other, \"scaling_max\")\n            and other.scaling_max is not None\n        ):\n            new_scaling_max = np.concatenate([self.scaling_max, other.scaling_max])\n        else:\n            new_scaling_max = self.scaling_max\n\n        # Update true dimension\n        if not augmented:\n            new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n        else:\n            new_true_dim = self._true_dim\n\n        # Update all attributes in place\n        self.shape = new_shape\n        self.min = new_min\n        self.max = new_max\n        self.guess = new_guess\n        self.initial = new_initial\n        self.final = new_final\n        self._initial = new__initial\n        self._final = new__final\n        self.initial_type = new_initial_type\n        self.final_type = new_final_type\n        self.scaling_min = new_scaling_min\n        self.scaling_max = new_scaling_max\n        self._true_dim = new_true_dim\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    else:\n        # Create a single new variable\n        new_shape = (self.shape[0] + 1,)\n\n        # Extend arrays\n        if self.min is not None:\n            self.min = np.concatenate([self.min, np.array([min])])\n        if self.max is not None:\n            self.max = np.concatenate([self.max, np.array([max])])\n        if self.guess is not None:\n            guess_arr = np.full((self.guess.shape[0], 1), guess)\n            self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n        if self.initial is not None:\n            self.initial = np.concatenate([self.initial, np.array([initial])])\n        if self.final is not None:\n            self.final = np.concatenate([self.final, np.array([final])])\n        if self._initial is not None:\n            self._initial = np.concatenate([self._initial, np.array([initial])])\n        if self._final is not None:\n            self._final = np.concatenate([self._final, np.array([final])])\n        if self.initial_type is not None:\n            self.initial_type = np.concatenate(\n                [self.initial_type, np.array([\"Fix\"], dtype=object)]\n            )\n        if self.final_type is not None:\n            self.final_type = np.concatenate([self.final_type, np.array([\"Fix\"], dtype=object)])\n        if self.scaling_min is not None:\n            self.scaling_min = np.concatenate([self.scaling_min, np.array([min])])\n        if self.scaling_max is not None:\n            self.scaling_max = np.concatenate([self.scaling_max, np.array([max])])\n\n        # Update dimensions\n        self.shape = new_shape\n        if not augmented:\n            self._true_dim += 1\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n</code></pre>"},{"location":"reference/lowered/cvxpy_constraints/","title":"cvxpy_constraints","text":"<p>CVXPy-lowered constraint dataclass.</p>"},{"location":"reference/lowered/cvxpy_constraints/#openscvx.lowered.cvxpy_constraints.LoweredCvxpyConstraints","title":"<code>LoweredCvxpyConstraints</code>  <code>dataclass</code>","text":"<p>CVXPy-lowered convex constraints.</p> <p>Contains constraints that have been lowered to CVXPy constraint objects. These are added directly to the optimal control problem without linearization.</p> <p>Attributes:</p> Name Type Description <code>constraints</code> <code>list[Constraint]</code> <p>List of CVXPy constraint objects (cp.Constraint). Includes both nodal and cross-node convex constraints.</p> Source code in <code>openscvx/lowered/cvxpy_constraints.py</code> <pre><code>@dataclass\nclass LoweredCvxpyConstraints:\n    \"\"\"CVXPy-lowered convex constraints.\n\n    Contains constraints that have been lowered to CVXPy constraint objects.\n    These are added directly to the optimal control problem without\n    linearization.\n\n    Attributes:\n        constraints: List of CVXPy constraint objects (cp.Constraint).\n            Includes both nodal and cross-node convex constraints.\n    \"\"\"\n\n    constraints: list[\"cp.Constraint\"] = field(default_factory=list)\n</code></pre>"},{"location":"reference/lowered/cvxpy_variables/","title":"cvxpy_variables","text":"<p>CVXPy variables and parameters dataclass for the optimal control problem.</p>"},{"location":"reference/lowered/cvxpy_variables/#openscvx.lowered.cvxpy_variables.CVXPyVariables","title":"<code>CVXPyVariables</code>  <code>dataclass</code>","text":"<p>CVXPy variables and parameters for the optimal control problem.</p> <p>This dataclass holds all CVXPy Variable and Parameter objects needed to construct and solve the optimal control problem. It replaces the previous untyped dictionary approach with a typed, self-documenting structure.</p> The variables are organized into logical groups <ul> <li>SCP weights: Parameters controlling trust region and penalty weights</li> <li>State: Variables and parameters for the state trajectory</li> <li>Control: Variables and parameters for the control trajectory</li> <li>Dynamics: Parameters for the discretized dynamics constraints</li> <li>Nodal constraints: Parameters for linearized non-convex nodal constraints</li> <li>Cross-node constraints: Parameters for linearized cross-node constraints</li> <li>Scaling: Affine scaling matrices and offset vectors</li> <li>Scaled expressions: CVXPy expressions for scaled state/control at each node</li> </ul> <p>Attributes:</p> Name Type Description <code>w_tr</code> <code>Parameter</code> <p>Trust region weight parameter (scalar, nonneg)</p> <code>lam_cost</code> <code>Parameter</code> <p>Cost function weight parameter (scalar, nonneg)</p> <code>lam_vc</code> <code>Parameter</code> <p>Virtual control penalty weights (N-1 x n_states, nonneg)</p> <code>lam_vb</code> <code>Parameter</code> <p>Virtual buffer penalty weight (scalar, nonneg)</p> <code>x</code> <code>Variable</code> <p>State variable (N x n_states)</p> <code>dx</code> <code>Variable</code> <p>State error variable (N x n_states)</p> <code>x_bar</code> <code>Parameter</code> <p>Previous SCP state parameter (N x n_states)</p> <code>x_init</code> <code>Parameter</code> <p>Initial state parameter (n_states,)</p> <code>x_term</code> <code>Parameter</code> <p>Terminal state parameter (n_states,)</p> <code>u</code> <code>Variable</code> <p>Control variable (N x n_controls)</p> <code>du</code> <code>Variable</code> <p>Control error variable (N x n_controls)</p> <code>u_bar</code> <code>Parameter</code> <p>Previous SCP control parameter (N x n_controls)</p> <code>A_d</code> <code>Parameter</code> <p>Discretized state Jacobian parameter (N-1 x n_states*n_states)</p> <code>B_d</code> <code>Parameter</code> <p>Discretized control Jacobian parameter (N-1 x n_states*n_controls)</p> <code>C_d</code> <code>Parameter</code> <p>Discretized control Jacobian (next node) parameter</p> <code>x_prop</code> <code>Parameter</code> <p>Propagated state parameter (N-1 x n_states)</p> <code>nu</code> <code>Variable</code> <p>Virtual control variable (N-1 x n_states)</p> <code>g</code> <code>List[Parameter]</code> <p>List of constraint value parameters (one per nodal constraint)</p> <code>grad_g_x</code> <code>List[Parameter]</code> <p>List of state gradient parameters (one per nodal constraint)</p> <code>grad_g_u</code> <code>List[Parameter]</code> <p>List of control gradient parameters (one per nodal constraint)</p> <code>nu_vb</code> <code>List[Variable]</code> <p>List of virtual buffer variables (one per nodal constraint)</p> <code>g_cross</code> <code>List[Parameter]</code> <p>List of cross-node constraint value parameters</p> <code>grad_g_X_cross</code> <code>List[Parameter]</code> <p>List of trajectory state gradient parameters</p> <code>grad_g_U_cross</code> <code>List[Parameter]</code> <p>List of trajectory control gradient parameters</p> <code>nu_vb_cross</code> <code>List[Variable]</code> <p>List of cross-node virtual buffer variables</p> <code>S_x</code> <code>ndarray</code> <p>State scaling matrix (n_states x n_states)</p> <code>inv_S_x</code> <code>ndarray</code> <p>Inverse state scaling matrix</p> <code>c_x</code> <code>ndarray</code> <p>State offset vector (n_states,)</p> <code>S_u</code> <code>ndarray</code> <p>Control scaling matrix (n_controls x n_controls)</p> <code>inv_S_u</code> <code>ndarray</code> <p>Inverse control scaling matrix</p> <code>c_u</code> <code>ndarray</code> <p>Control offset vector (n_controls,)</p> <code>x_nonscaled</code> <code>List</code> <p>List of scaled state expressions at each node</p> <code>u_nonscaled</code> <code>List</code> <p>List of scaled control expressions at each node</p> <code>dx_nonscaled</code> <code>List</code> <p>List of scaled state error expressions at each node</p> <code>du_nonscaled</code> <code>List</code> <p>List of scaled control error expressions at each node</p> Source code in <code>openscvx/lowered/cvxpy_variables.py</code> <pre><code>@dataclass\nclass CVXPyVariables:\n    \"\"\"CVXPy variables and parameters for the optimal control problem.\n\n    This dataclass holds all CVXPy Variable and Parameter objects needed to\n    construct and solve the optimal control problem. It replaces the previous\n    untyped dictionary approach with a typed, self-documenting structure.\n\n    The variables are organized into logical groups:\n        - SCP weights: Parameters controlling trust region and penalty weights\n        - State: Variables and parameters for the state trajectory\n        - Control: Variables and parameters for the control trajectory\n        - Dynamics: Parameters for the discretized dynamics constraints\n        - Nodal constraints: Parameters for linearized non-convex nodal constraints\n        - Cross-node constraints: Parameters for linearized cross-node constraints\n        - Scaling: Affine scaling matrices and offset vectors\n        - Scaled expressions: CVXPy expressions for scaled state/control at each node\n\n    Attributes:\n        w_tr: Trust region weight parameter (scalar, nonneg)\n        lam_cost: Cost function weight parameter (scalar, nonneg)\n        lam_vc: Virtual control penalty weights (N-1 x n_states, nonneg)\n        lam_vb: Virtual buffer penalty weight (scalar, nonneg)\n\n        x: State variable (N x n_states)\n        dx: State error variable (N x n_states)\n        x_bar: Previous SCP state parameter (N x n_states)\n        x_init: Initial state parameter (n_states,)\n        x_term: Terminal state parameter (n_states,)\n\n        u: Control variable (N x n_controls)\n        du: Control error variable (N x n_controls)\n        u_bar: Previous SCP control parameter (N x n_controls)\n\n        A_d: Discretized state Jacobian parameter (N-1 x n_states*n_states)\n        B_d: Discretized control Jacobian parameter (N-1 x n_states*n_controls)\n        C_d: Discretized control Jacobian (next node) parameter\n        x_prop: Propagated state parameter (N-1 x n_states)\n        nu: Virtual control variable (N-1 x n_states)\n\n        g: List of constraint value parameters (one per nodal constraint)\n        grad_g_x: List of state gradient parameters (one per nodal constraint)\n        grad_g_u: List of control gradient parameters (one per nodal constraint)\n        nu_vb: List of virtual buffer variables (one per nodal constraint)\n\n        g_cross: List of cross-node constraint value parameters\n        grad_g_X_cross: List of trajectory state gradient parameters\n        grad_g_U_cross: List of trajectory control gradient parameters\n        nu_vb_cross: List of cross-node virtual buffer variables\n\n        S_x: State scaling matrix (n_states x n_states)\n        inv_S_x: Inverse state scaling matrix\n        c_x: State offset vector (n_states,)\n        S_u: Control scaling matrix (n_controls x n_controls)\n        inv_S_u: Inverse control scaling matrix\n        c_u: Control offset vector (n_controls,)\n\n        x_nonscaled: List of scaled state expressions at each node\n        u_nonscaled: List of scaled control expressions at each node\n        dx_nonscaled: List of scaled state error expressions at each node\n        du_nonscaled: List of scaled control error expressions at each node\n    \"\"\"\n\n    # SCP weight parameters\n    w_tr: \"cp.Parameter\"\n    lam_cost: \"cp.Parameter\"\n    lam_vc: \"cp.Parameter\"\n    lam_vb: \"cp.Parameter\"\n\n    # State variables and parameters\n    x: \"cp.Variable\"\n    dx: \"cp.Variable\"\n    x_bar: \"cp.Parameter\"\n    x_init: \"cp.Parameter\"\n    x_term: \"cp.Parameter\"\n\n    # Control variables and parameters\n    u: \"cp.Variable\"\n    du: \"cp.Variable\"\n    u_bar: \"cp.Parameter\"\n\n    # Dynamics discretization parameters\n    A_d: \"cp.Parameter\"\n    B_d: \"cp.Parameter\"\n    C_d: \"cp.Parameter\"\n    x_prop: \"cp.Parameter\"\n    nu: \"cp.Variable\"\n\n    # Nodal constraint linearization (lists, one per constraint)\n    g: List[\"cp.Parameter\"] = field(default_factory=list)\n    grad_g_x: List[\"cp.Parameter\"] = field(default_factory=list)\n    grad_g_u: List[\"cp.Parameter\"] = field(default_factory=list)\n    nu_vb: List[\"cp.Variable\"] = field(default_factory=list)\n\n    # Cross-node constraint linearization (lists, one per constraint)\n    g_cross: List[\"cp.Parameter\"] = field(default_factory=list)\n    grad_g_X_cross: List[\"cp.Parameter\"] = field(default_factory=list)\n    grad_g_U_cross: List[\"cp.Parameter\"] = field(default_factory=list)\n    nu_vb_cross: List[\"cp.Variable\"] = field(default_factory=list)\n\n    # Scaling matrices and offsets (numpy arrays)\n    S_x: np.ndarray = field(default_factory=lambda: np.array([]))\n    inv_S_x: np.ndarray = field(default_factory=lambda: np.array([]))\n    c_x: np.ndarray = field(default_factory=lambda: np.array([]))\n    S_u: np.ndarray = field(default_factory=lambda: np.array([]))\n    inv_S_u: np.ndarray = field(default_factory=lambda: np.array([]))\n    c_u: np.ndarray = field(default_factory=lambda: np.array([]))\n\n    # Scaled CVXPy expressions at each node (lists of length N)\n    x_nonscaled: List = field(default_factory=list)\n    u_nonscaled: List = field(default_factory=list)\n    dx_nonscaled: List = field(default_factory=list)\n    du_nonscaled: List = field(default_factory=list)\n</code></pre>"},{"location":"reference/lowered/dynamics/","title":"dynamics","text":""},{"location":"reference/lowered/dynamics/#openscvx.lowered.dynamics.Dynamics","title":"<code>Dynamics</code>  <code>dataclass</code>","text":"<p>Dataclass to hold a system dynamics function and its Jacobians.</p> <p>This dataclass is used internally by openscvx to store the compiled dynamics function and its gradients after symbolic expressions are lowered to JAX. Users typically don't instantiate this class directly.</p> <p>Attributes:</p> Name Type Description <code>f</code> <code>Callable[[ndarray, ndarray], ndarray]</code> <p>Function defining the continuous time nonlinear system dynamics as x_dot = f(x, u, ...params). - x: 1D array (state at a single node), shape (n_x,) - u: 1D array (control at a single node), shape (n_u,) - Additional parameters: passed as keyword arguments with names   matching the parameter name plus an underscore (e.g., g_ for   Parameter('g')). If you use vectorized integration or batch evaluation, x and u may be 2D arrays (N, n_x) and (N, n_u).</p> <code>A</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of <code>f</code> w.r.t. <code>x</code>.</p> <code>B</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of <code>f</code> w.r.t. <code>u</code>.</p> Source code in <code>openscvx/lowered/dynamics.py</code> <pre><code>@dataclass\nclass Dynamics:\n    \"\"\"Dataclass to hold a system dynamics function and its Jacobians.\n\n    This dataclass is used internally by openscvx to store the compiled dynamics\n    function and its gradients after symbolic expressions are lowered to JAX.\n    Users typically don't instantiate this class directly.\n\n    Attributes:\n        f (Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]):\n            Function defining the continuous time nonlinear system dynamics\n            as x_dot = f(x, u, ...params).\n            - x: 1D array (state at a single node), shape (n_x,)\n            - u: 1D array (control at a single node), shape (n_u,)\n            - Additional parameters: passed as keyword arguments with names\n              matching the parameter name plus an underscore (e.g., g_ for\n              Parameter('g')).\n            If you use vectorized integration or batch evaluation, x and u\n            may be 2D arrays (N, n_x) and (N, n_u).\n        A (Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]]):\n            Jacobian of ``f`` w.r.t. ``x``.\n        B (Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]]):\n            Jacobian of ``f`` w.r.t. ``u``.\n    \"\"\"\n\n    f: Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]\n    A: Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]] = None\n    B: Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]] = None\n</code></pre>"},{"location":"reference/lowered/jax_constraints/","title":"jax_constraints","text":"<p>JAX-lowered constraint dataclass.</p>"},{"location":"reference/lowered/jax_constraints/#openscvx.lowered.jax_constraints.LoweredCrossNodeConstraint","title":"<code>LoweredCrossNodeConstraint</code>  <code>dataclass</code>","text":"<p>Lowered cross-node constraint with trajectory-level evaluation.</p> <p>Unlike regular LoweredNodalConstraint which operates on single-node vectors and is vmapped across the trajectory, LoweredCrossNodeConstraint operates on full trajectory arrays to relate multiple nodes simultaneously.</p> <p>This is necessary for constraints like: - Rate limits: x[k] - x[k-1] &lt;= max_rate - Multi-step dependencies: x[k] = 2*x[k-1] - x[k-2] - Periodic boundaries: x[0] = x[N-1]</p> <p>The function signatures differ from LoweredNodalConstraint: - Regular: f(x, u, node, params) -&gt; scalar (vmapped to handle (N, n_x)) - Cross-node: f(X, U, params) -&gt; scalar (single constraint with fixed node indices)</p> <p>Attributes:</p> Name Type Description <code>func</code> <code>Callable[[ndarray, ndarray, dict], ndarray]</code> <p>Function (X, U, params) -&gt; scalar residual where X: (N, n_x), U: (N, n_u) Returns constraint residual following g(X, U) &lt;= 0 convention The constraint references fixed trajectory nodes (e.g., X[5] - X[4])</p> <code>grad_g_X</code> <code>Callable[[ndarray, ndarray, dict], ndarray]</code> <p>Function (X, U, params) -&gt; (N, n_x) Jacobian wrt full state trajectory This is typically sparse - most constraints only couple nearby nodes</p> <code>grad_g_U</code> <code>Callable[[ndarray, ndarray, dict], ndarray]</code> <p>Function (X, U, params) -&gt; (N, n_u) Jacobian wrt full control trajectory Often zero or very sparse for cross-node state constraints</p> Example <p>For rate constraint x[5] - x[4] &lt;= r:</p> <pre><code>func(X, U, params) -&gt; scalar residual\ngrad_g_X(X, U, params) -&gt; (N, n_x) sparse Jacobian\n    where grad_g_X[5, :] = \u2202g/\u2202x[5] (derivative wrt node 5)\n    and grad_g_X[4, :] = \u2202g/\u2202x[4] (derivative wrt node 4)\n    all other entries are zero\n</code></pre> Performance Note - Dense Jacobian Storage <p>The Jacobian matrices grad_g_X and grad_g_U are stored as DENSE arrays with shape (N, n_x) and (N, n_u), but most cross-node constraints only couple a small number of nearby nodes, making these matrices extremely sparse.</p> <p>For example, a rate limit constraint x[k] - x[k-1] &lt;= r only has non-zero Jacobian entries at positions [k, :] and [k-1, :]. All other N-2 rows are zero but still stored in memory.</p> <p>Memory impact for large problems: - A single constraint with N=100 nodes, n_x=10 states requires ~8KB for   grad_g_X (compared to ~160 bytes if sparse with 2 non-zero rows) - Multiple cross-node constraints multiply this overhead - May cause issues for N &gt; 1000 with many constraints</p> <p>Performance impact: - Slower autodiff (computes many zero gradients) - Inefficient constraint linearization in the SCP solver - Potential GPU memory limitations for very large problems</p> <p>The current implementation prioritizes simplicity and compatibility with JAX's autodiff over memory efficiency. Future versions may support sparse Jacobian formats (COO, CSR, or custom sparse representations) if this becomes a bottleneck in practice.</p> Source code in <code>openscvx/lowered/jax_constraints.py</code> <pre><code>@dataclass\nclass LoweredCrossNodeConstraint:\n    \"\"\"Lowered cross-node constraint with trajectory-level evaluation.\n\n    Unlike regular LoweredNodalConstraint which operates on single-node vectors\n    and is vmapped across the trajectory, LoweredCrossNodeConstraint operates\n    on full trajectory arrays to relate multiple nodes simultaneously.\n\n    This is necessary for constraints like:\n    - Rate limits: x[k] - x[k-1] &lt;= max_rate\n    - Multi-step dependencies: x[k] = 2*x[k-1] - x[k-2]\n    - Periodic boundaries: x[0] = x[N-1]\n\n    The function signatures differ from LoweredNodalConstraint:\n    - Regular: f(x, u, node, params) -&gt; scalar (vmapped to handle (N, n_x))\n    - Cross-node: f(X, U, params) -&gt; scalar (single constraint with fixed node indices)\n\n    Attributes:\n        func: Function (X, U, params) -&gt; scalar residual\n            where X: (N, n_x), U: (N, n_u)\n            Returns constraint residual following g(X, U) &lt;= 0 convention\n            The constraint references fixed trajectory nodes (e.g., X[5] - X[4])\n        grad_g_X: Function (X, U, params) -&gt; (N, n_x) Jacobian wrt full state trajectory\n            This is typically sparse - most constraints only couple nearby nodes\n        grad_g_U: Function (X, U, params) -&gt; (N, n_u) Jacobian wrt full control trajectory\n            Often zero or very sparse for cross-node state constraints\n\n    Example:\n        For rate constraint x[5] - x[4] &lt;= r:\n\n            func(X, U, params) -&gt; scalar residual\n            grad_g_X(X, U, params) -&gt; (N, n_x) sparse Jacobian\n                where grad_g_X[5, :] = \u2202g/\u2202x[5] (derivative wrt node 5)\n                and grad_g_X[4, :] = \u2202g/\u2202x[4] (derivative wrt node 4)\n                all other entries are zero\n\n    Performance Note - Dense Jacobian Storage:\n        The Jacobian matrices grad_g_X and grad_g_U are stored as DENSE arrays with\n        shape (N, n_x) and (N, n_u), but most cross-node constraints only couple a\n        small number of nearby nodes, making these matrices extremely sparse.\n\n        For example, a rate limit constraint x[k] - x[k-1] &lt;= r only has non-zero\n        Jacobian entries at positions [k, :] and [k-1, :]. All other N-2 rows are\n        zero but still stored in memory.\n\n        Memory impact for large problems:\n        - A single constraint with N=100 nodes, n_x=10 states requires ~8KB for\n          grad_g_X (compared to ~160 bytes if sparse with 2 non-zero rows)\n        - Multiple cross-node constraints multiply this overhead\n        - May cause issues for N &gt; 1000 with many constraints\n\n        Performance impact:\n        - Slower autodiff (computes many zero gradients)\n        - Inefficient constraint linearization in the SCP solver\n        - Potential GPU memory limitations for very large problems\n\n        The current implementation prioritizes simplicity and compatibility with\n        JAX's autodiff over memory efficiency. Future versions may support sparse\n        Jacobian formats (COO, CSR, or custom sparse representations) if this\n        becomes a bottleneck in practice.\n    \"\"\"\n\n    func: Callable[[jnp.ndarray, jnp.ndarray, dict], jnp.ndarray]\n    grad_g_X: Callable[[jnp.ndarray, jnp.ndarray, dict], jnp.ndarray]\n    grad_g_U: Callable[[jnp.ndarray, jnp.ndarray, dict], jnp.ndarray]\n</code></pre>"},{"location":"reference/lowered/jax_constraints/#openscvx.lowered.jax_constraints.LoweredJaxConstraints","title":"<code>LoweredJaxConstraints</code>  <code>dataclass</code>","text":"<p>JAX-lowered non-convex constraints with gradient functions.</p> <p>Contains constraints that have been lowered to JAX callable functions with automatically computed gradients. These are used for linearization in the SCP (Sequential Convex Programming) loop.</p> <p>Attributes:</p> Name Type Description <code>nodal</code> <code>list[LoweredNodalConstraint]</code> <p>List of LoweredNodalConstraint objects. Each has <code>func</code>, <code>grad_g_x</code>, <code>grad_g_u</code> callables and <code>nodes</code> list.</p> <code>cross_node</code> <code>list[LoweredCrossNodeConstraint]</code> <p>List of LoweredCrossNodeConstraint objects. Each has <code>func</code>, <code>grad_g_X</code>, <code>grad_g_U</code> for trajectory-level constraints.</p> <code>ctcs</code> <code>list[CTCS]</code> <p>CTCS constraints (unchanged from input, not lowered here).</p> Source code in <code>openscvx/lowered/jax_constraints.py</code> <pre><code>@dataclass\nclass LoweredJaxConstraints:\n    \"\"\"JAX-lowered non-convex constraints with gradient functions.\n\n    Contains constraints that have been lowered to JAX callable functions\n    with automatically computed gradients. These are used for linearization\n    in the SCP (Sequential Convex Programming) loop.\n\n    Attributes:\n        nodal: List of LoweredNodalConstraint objects. Each has `func`,\n            `grad_g_x`, `grad_g_u` callables and `nodes` list.\n        cross_node: List of LoweredCrossNodeConstraint objects. Each has\n            `func`, `grad_g_X`, `grad_g_U` for trajectory-level constraints.\n        ctcs: CTCS constraints (unchanged from input, not lowered here).\n    \"\"\"\n\n    nodal: list[LoweredNodalConstraint] = field(default_factory=list)\n    cross_node: list[LoweredCrossNodeConstraint] = field(default_factory=list)\n    ctcs: list[\"CTCS\"] = field(default_factory=list)\n</code></pre>"},{"location":"reference/lowered/jax_constraints/#openscvx.lowered.jax_constraints.LoweredNodalConstraint","title":"<code>LoweredNodalConstraint</code>  <code>dataclass</code>","text":"<p>Dataclass to hold a lowered symbolic constraint function and its jacobians.</p> <p>This is a simplified drop-in replacement for NodalConstraint that holds only the essential lowered JAX functions and their jacobians, without the complexity of convex/vectorized flags or post-initialization logic.</p> <p>Designed for use with symbolic expressions that have been lowered to JAX and will be linearized for sequential convex programming.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[ndarray, ndarray], ndarray]</code> <p>The lowered constraint function g(x, u, ...params) that returns constraint residuals. Should follow g(x, u) &lt;= 0 convention. - x: 1D array (state at a single node), shape (n_x,) - u: 1D array (control at a single node), shape (n_u,) - Additional parameters: passed as keyword arguments</p> required <code>grad_g_x</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of g w.r.t. x. If None, should be computed using jax.jacfwd.</p> <code>None</code> <code>grad_g_u</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of g w.r.t. u. If None, should be computed using jax.jacfwd.</p> <code>None</code> <code>nodes</code> <code>Optional[List[int]]</code> <p>List of node indices where this constraint applies. Set after lowering from NodalConstraint.</p> <code>None</code> Source code in <code>openscvx/lowered/jax_constraints.py</code> <pre><code>@dataclass\nclass LoweredNodalConstraint:\n    \"\"\"\n    Dataclass to hold a lowered symbolic constraint function and its jacobians.\n\n    This is a simplified drop-in replacement for NodalConstraint that holds\n    only the essential lowered JAX functions and their jacobians, without\n    the complexity of convex/vectorized flags or post-initialization logic.\n\n    Designed for use with symbolic expressions that have been lowered to JAX\n    and will be linearized for sequential convex programming.\n\n    Args:\n        func (Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]):\n            The lowered constraint function g(x, u, ...params) that returns\n            constraint residuals. Should follow g(x, u) &lt;= 0 convention.\n            - x: 1D array (state at a single node), shape (n_x,)\n            - u: 1D array (control at a single node), shape (n_u,)\n            - Additional parameters: passed as keyword arguments\n\n        grad_g_x (Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]]):\n            Jacobian of g w.r.t. x. If None, should be computed using jax.jacfwd.\n\n        grad_g_u (Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]]):\n            Jacobian of g w.r.t. u. If None, should be computed using jax.jacfwd.\n\n        nodes (Optional[List[int]]): List of node indices where this constraint applies.\n            Set after lowering from NodalConstraint.\n    \"\"\"\n\n    func: Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]\n    grad_g_x: Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]] = None\n    grad_g_u: Optional[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]] = None\n    nodes: Optional[List[int]] = None\n</code></pre>"},{"location":"reference/lowered/parameters/","title":"parameters","text":"<p>Parameter dictionary that syncs between JAX and CVXPy.</p>"},{"location":"reference/lowered/parameters/#openscvx.lowered.parameters.ParameterDict","title":"<code>ParameterDict</code>","text":"<p>               Bases: <code>dict</code></p> <p>Dictionary that syncs to both internal _parameters dict and CVXPy parameters.</p> This allows users to naturally update parameters like <p>problem.parameters[\"obs_radius\"] = 2.0</p> <p>Changes automatically propagate to: 1. Internal _parameters dict (plain dict for JAX) 2. CVXPy parameters (for optimization)</p> Source code in <code>openscvx/lowered/parameters.py</code> <pre><code>class ParameterDict(dict):\n    \"\"\"Dictionary that syncs to both internal _parameters dict and CVXPy parameters.\n\n    This allows users to naturally update parameters like:\n        problem.parameters[\"obs_radius\"] = 2.0\n\n    Changes automatically propagate to:\n    1. Internal _parameters dict (plain dict for JAX)\n    2. CVXPy parameters (for optimization)\n    \"\"\"\n\n    def __init__(self, problem, internal_dict, *args, **kwargs):\n        self._problem = problem\n        self._internal_dict = internal_dict  # Reference to plain dict for JAX\n        super().__init__()\n        # Initialize with float enforcement by using __setitem__\n        if args:\n            other = args[0]\n            if hasattr(other, \"items\"):\n                for key, value in other.items():\n                    self[key] = value\n            else:\n                for key, value in other:\n                    self[key] = value\n        for key, value in kwargs.items():\n            self[key] = value\n\n    def __setitem__(self, key, value):\n        # Enforce float dtype to prevent int/float mismatch bugs\n        value = np.asarray(value, dtype=float)\n        super().__setitem__(key, value)\n        # Sync to internal dict for JAX\n        self._internal_dict[key] = value\n        # Sync to CVXPy if it exists\n        lowered = getattr(self._problem, \"_lowered\", None)\n        if lowered is not None and key in lowered.cvxpy_params:\n            lowered.cvxpy_params[key].value = value\n\n    def update(self, other=None, **kwargs):\n        \"\"\"Update multiple parameters and sync to internal dict and CVXPy.\"\"\"\n        if other is not None:\n            if hasattr(other, \"items\"):\n                for key, value in other.items():\n                    self[key] = value\n            else:\n                for key, value in other:\n                    self[key] = value\n        for key, value in kwargs.items():\n            self[key] = value\n</code></pre>"},{"location":"reference/lowered/parameters/#openscvx.lowered.parameters.ParameterDict.update","title":"<code>update(other=None, **kwargs)</code>","text":"<p>Update multiple parameters and sync to internal dict and CVXPy.</p> Source code in <code>openscvx/lowered/parameters.py</code> <pre><code>def update(self, other=None, **kwargs):\n    \"\"\"Update multiple parameters and sync to internal dict and CVXPy.\"\"\"\n    if other is not None:\n        if hasattr(other, \"items\"):\n            for key, value in other.items():\n                self[key] = value\n        else:\n            for key, value in other:\n                self[key] = value\n    for key, value in kwargs.items():\n        self[key] = value\n</code></pre>"},{"location":"reference/lowered/problem/","title":"problem","text":"<p>LoweredProblem dataclass - container for all lowering outputs.</p>"},{"location":"reference/lowered/problem/#openscvx.lowered.problem.LoweredProblem","title":"<code>LoweredProblem</code>  <code>dataclass</code>","text":"<p>Container for all outputs from symbolic problem lowering.</p> <p>This dataclass holds all the results of lowering symbolic expressions to executable JAX and CVXPy code. It provides a clean, typed interface for accessing the various components needed for optimization.</p> <p>Attributes:</p> Name Type Description <code>dynamics</code> <code>Dynamics</code> <p>Optimization dynamics with fields f, A, B (JAX functions)</p> <code>dynamics_prop</code> <code>Dynamics</code> <p>Propagation dynamics with fields f, A, B</p> <code>jax_constraints</code> <code>LoweredJaxConstraints</code> <p>Non-convex constraints lowered to JAX with gradients</p> <code>cvxpy_constraints</code> <code>LoweredCvxpyConstraints</code> <p>Convex constraints lowered to CVXPy</p> <code>x_unified</code> <code>UnifiedState</code> <p>Aggregated optimization state interface</p> <code>u_unified</code> <code>UnifiedControl</code> <p>Aggregated optimization control interface</p> <code>x_prop_unified</code> <code>UnifiedState</code> <p>Aggregated propagation state interface</p> <code>ocp_vars</code> <code>CVXPyVariables</code> <p>Typed CVXPy variables and parameters for OCP construction</p> <code>cvxpy_params</code> <code>Dict[str, Parameter]</code> <p>Dict mapping user parameter names to CVXPy Parameter objects</p> <code>algebraic_prop</code> <code>Optional[Dict[str, Callable]]</code> <p>Dict mapping output names to vmapped JAX functions (evaluated, not integrated)</p> Example <p>After lowering a symbolic problem::</p> <pre><code>lowered = lower_symbolic_problem(\n    dynamics_aug=dynamics,\n    states_aug=states,\n    controls_aug=controls,\n    constraints=constraint_set,\n    parameters=params,\n    N=50,\n)\n\n# Access components\ndx_dt = lowered.dynamics.f(x, u, node, params)\njacobian_A = lowered.dynamics.A(x, u, node, params)\n\n# Use CVXPy objects\nocp = OptimalControlProblem(settings, lowered)\n</code></pre> Source code in <code>openscvx/lowered/problem.py</code> <pre><code>@dataclass\nclass LoweredProblem:\n    \"\"\"Container for all outputs from symbolic problem lowering.\n\n    This dataclass holds all the results of lowering symbolic expressions\n    to executable JAX and CVXPy code. It provides a clean, typed interface\n    for accessing the various components needed for optimization.\n\n    Attributes:\n        dynamics: Optimization dynamics with fields f, A, B (JAX functions)\n        dynamics_prop: Propagation dynamics with fields f, A, B\n        jax_constraints: Non-convex constraints lowered to JAX with gradients\n        cvxpy_constraints: Convex constraints lowered to CVXPy\n        x_unified: Aggregated optimization state interface\n        u_unified: Aggregated optimization control interface\n        x_prop_unified: Aggregated propagation state interface\n        ocp_vars: Typed CVXPy variables and parameters for OCP construction\n        cvxpy_params: Dict mapping user parameter names to CVXPy Parameter objects\n        algebraic_prop: Dict mapping output names to vmapped JAX functions\n            (evaluated, not integrated)\n\n    Example:\n        After lowering a symbolic problem::\n\n            lowered = lower_symbolic_problem(\n                dynamics_aug=dynamics,\n                states_aug=states,\n                controls_aug=controls,\n                constraints=constraint_set,\n                parameters=params,\n                N=50,\n            )\n\n            # Access components\n            dx_dt = lowered.dynamics.f(x, u, node, params)\n            jacobian_A = lowered.dynamics.A(x, u, node, params)\n\n            # Use CVXPy objects\n            ocp = OptimalControlProblem(settings, lowered)\n    \"\"\"\n\n    # JAX dynamics\n    dynamics: Dynamics\n    dynamics_prop: Dynamics\n\n    # Lowered constraints (separate types for JAX vs CVXPy)\n    jax_constraints: LoweredJaxConstraints\n    cvxpy_constraints: LoweredCvxpyConstraints\n\n    # Unified interfaces\n    x_unified: UnifiedState\n    u_unified: UnifiedControl\n    x_prop_unified: UnifiedState\n\n    # CVXPy objects\n    ocp_vars: CVXPyVariables\n    cvxpy_params: Dict[str, \"cp.Parameter\"]\n\n    # Algebraic outputs (vmapped JAX functions for propagation)\n    algebraic_prop: Optional[Dict[str, Callable]] = field(default_factory=dict)\n</code></pre>"},{"location":"reference/lowered/unified/","title":"unified","text":"<p>Unified state and control dataclasses for the lowered representation.</p> <p>This module contains the UnifiedState and UnifiedControl dataclasses that describe the structure of the monolithic state and control vectors used in numerical optimization.</p> <p>In the symbolic world, users define many named State and Control objects (position, velocity, thrust, etc.). In the lowered world, these are aggregated into single monolithic x and u vectors. UnifiedState and UnifiedControl hold the metadata describing this aggregation: bounds, guesses, boundary conditions, and slices for extracting individual components.</p> See Also <ul> <li>openscvx.symbolic.unified: Contains unify_states() and unify_controls()   functions that create these dataclasses from symbolic State/Control objects.</li> </ul>"},{"location":"reference/lowered/unified/#openscvx.lowered.unified.UnifiedControl","title":"<code>UnifiedControl</code>  <code>dataclass</code>","text":"<p>Unified control vector aggregating multiple Control objects.</p> <p>UnifiedControl is a drop-in replacement for individual Control objects that holds aggregated data from multiple Control instances. It maintains compatibility with optimization infrastructure while providing access to individual control components through slicing.</p> <p>The unified control separates user-defined \"true\" controls from augmented controls added internally (e.g., for time dilation). This separation allows clean access to physical control inputs while supporting advanced features.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the unified control vector</p> <code>shape</code> <code>tuple</code> <p>Combined shape (total_dim,) of all aggregated controls</p> <code>min</code> <code>ndarray</code> <p>Lower bounds for all control variables, shape (total_dim,)</p> <code>max</code> <code>ndarray</code> <p>Upper bounds for all control variables, shape (total_dim,)</p> <code>guess</code> <code>ndarray</code> <p>Initial guess trajectory, shape (num_nodes, total_dim)</p> <code>_true_dim</code> <code>int</code> <p>Number of user-defined control dimensions (excludes augmented)</p> <code>_true_slice</code> <code>slice</code> <p>Slice for extracting true controls from unified vector</p> <code>_augmented_slice</code> <code>slice</code> <p>Slice for extracting augmented controls</p> <code>time_dilation_slice</code> <code>Optional[slice]</code> <p>Slice for time dilation control, if present</p> Properties <p>true: Returns UnifiedControl view containing only true (user-defined) controls augmented: Returns UnifiedControl view containing only augmented controls</p> Example <p>Creating a unified control from multiple Control objects::</p> <pre><code>from openscvx.symbolic.unified import unify_controls\n\nthrust = ox.Control(\"thrust\", shape=(3,), min=0, max=10)\ntorque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n\nunified = unify_controls([thrust, torque], name=\"u\")\nprint(unified.shape)        # (6,)\nprint(unified.min)          # [0, 0, 0, -1, -1, -1]\nprint(unified.true.shape)   # (6,) - all are true controls\nprint(unified.augmented.shape)  # (0,) - no augmented controls\n</code></pre> <p>Appending controls dynamically::</p> <pre><code>unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.0)  # Add scalar control\nprint(unified.shape)  # (1,)\n</code></pre> See Also <ul> <li>unify_controls(): Factory function for creating UnifiedControl from Control list</li> <li>Control: Individual symbolic control variable</li> <li>UnifiedState: Analogous unified state vector</li> </ul> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>@dataclass\nclass UnifiedControl:\n    \"\"\"Unified control vector aggregating multiple Control objects.\n\n    UnifiedControl is a drop-in replacement for individual Control objects that holds\n    aggregated data from multiple Control instances. It maintains compatibility with\n    optimization infrastructure while providing access to individual control components\n    through slicing.\n\n    The unified control separates user-defined \"true\" controls from augmented controls\n    added internally (e.g., for time dilation). This separation allows clean access to\n    physical control inputs while supporting advanced features.\n\n    Attributes:\n        name (str): Name identifier for the unified control vector\n        shape (tuple): Combined shape (total_dim,) of all aggregated controls\n        min (np.ndarray): Lower bounds for all control variables, shape (total_dim,)\n        max (np.ndarray): Upper bounds for all control variables, shape (total_dim,)\n        guess (np.ndarray): Initial guess trajectory, shape (num_nodes, total_dim)\n        _true_dim (int): Number of user-defined control dimensions (excludes augmented)\n        _true_slice (slice): Slice for extracting true controls from unified vector\n        _augmented_slice (slice): Slice for extracting augmented controls\n        time_dilation_slice (Optional[slice]): Slice for time dilation control, if present\n\n    Properties:\n        true: Returns UnifiedControl view containing only true (user-defined) controls\n        augmented: Returns UnifiedControl view containing only augmented controls\n\n    Example:\n        Creating a unified control from multiple Control objects::\n\n            from openscvx.symbolic.unified import unify_controls\n\n            thrust = ox.Control(\"thrust\", shape=(3,), min=0, max=10)\n            torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n\n            unified = unify_controls([thrust, torque], name=\"u\")\n            print(unified.shape)        # (6,)\n            print(unified.min)          # [0, 0, 0, -1, -1, -1]\n            print(unified.true.shape)   # (6,) - all are true controls\n            print(unified.augmented.shape)  # (0,) - no augmented controls\n\n        Appending controls dynamically::\n\n            unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.0)  # Add scalar control\n            print(unified.shape)  # (1,)\n\n    See Also:\n        - unify_controls(): Factory function for creating UnifiedControl from Control list\n        - Control: Individual symbolic control variable\n        - UnifiedState: Analogous unified state vector\n    \"\"\"\n\n    name: str\n    shape: tuple\n    min: Optional[np.ndarray] = None\n    max: Optional[np.ndarray] = None\n    guess: Optional[np.ndarray] = None\n    _true_dim: int = 0\n    _true_slice: Optional[slice] = None\n    _augmented_slice: Optional[slice] = None\n    time_dilation_slice: Optional[slice] = None  # Slice for time dilation control\n    scaling_min: Optional[np.ndarray] = None  # Scaling minimum bounds for unified control\n    scaling_max: Optional[np.ndarray] = None  # Scaling maximum bounds for unified control\n\n    def __post_init__(self):\n        \"\"\"Initialize slices after dataclass creation.\"\"\"\n        if self._true_slice is None:\n            self._true_slice = slice(0, self._true_dim)\n        if self._augmented_slice is None:\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    @property\n    def true(self) -&gt; \"UnifiedControl\":\n        \"\"\"Get the true (user-defined) control variables.\n\n        Returns a view of the unified control containing only user-defined controls,\n        excluding internal augmented controls added for time dilation, etc.\n\n        Returns:\n            UnifiedControl: Sliced view containing only true control variables\n\n        Example:\n            Get true user defined controls::\n\n                unified = unify_controls([thrust, torque, time_dilation], name=\"u\")\n                true_controls = unified.true  # Only thrust and torque\n        \"\"\"\n        return self[self._true_slice]\n\n    @property\n    def augmented(self) -&gt; \"UnifiedControl\":\n        \"\"\"Get the augmented (internal) control variables.\n\n        Returns a view of the unified control containing only augmented controls\n        added internally by the optimization framework (e.g., time dilation control).\n\n        Returns:\n            UnifiedControl: Sliced view containing only augmented control variables\n\n        Example:\n            Get augmented controls::\n\n                unified = unify_controls([thrust, time_dilation], name=\"u\")\n                aug_controls = unified.augmented  # Only time dilation\n        \"\"\"\n        return self[self._augmented_slice]\n\n    def append(\n        self,\n        other: \"Optional[Control | UnifiedControl]\" = None,\n        *,\n        min=-np.inf,\n        max=np.inf,\n        guess=0.0,\n        augmented=False,\n    ):\n        \"\"\"Append another control or create a new control variable.\n\n        This method allows dynamic extension of the unified control, either by appending\n        another Control/UnifiedControl object or by creating a new scalar control variable\n        with specified properties. Modifies the unified control in-place.\n\n        Args:\n            other (Optional[Control | UnifiedControl]): Control object to append. If None,\n                creates a new scalar control variable with properties from keyword args.\n            min (float): Lower bound for new scalar control (default: -inf)\n            max (float): Upper bound for new scalar control (default: inf)\n            guess (float): Initial guess value for new scalar control (default: 0.0)\n            augmented (bool): Whether the appended control is augmented (internal) rather\n                than true (user-defined). Affects _true_dim tracking. Default: False\n\n        Returns:\n            None: Modifies the unified control in-place\n\n        Example:\n            Appending a Control object::\n\n                unified = unify_controls([thrust], name=\"u\")\n                torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n                unified.append(torque)\n                print(unified.shape)  # (6,) - thrust (3) + torque (3)\n\n            Creating new scalar control variables::\n\n                unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\n                unified.append(min=-1, max=1, guess=0.0)  # Add scalar control\n                print(unified.shape)  # (1,)\n        \"\"\"\n        # Import here to avoid circular imports at module level\n        from openscvx.symbolic.expr.control import Control\n\n        if isinstance(other, (Control, UnifiedControl)):\n            # Append another control object\n            new_shape = (self.shape[0] + other.shape[0],)\n\n            # Update bounds\n            if self.min is not None and other.min is not None:\n                new_min = np.concatenate([self.min, other.min])\n            else:\n                new_min = self.min\n\n            if self.max is not None and other.max is not None:\n                new_max = np.concatenate([self.max, other.max])\n            else:\n                new_max = self.max\n\n            # Update guess\n            if self.guess is not None and other.guess is not None:\n                new_guess = np.concatenate([self.guess, other.guess], axis=1)\n            else:\n                new_guess = self.guess\n\n            # Update scaling bounds (if present)\n            if (\n                self.scaling_min is not None\n                and hasattr(other, \"scaling_min\")\n                and other.scaling_min is not None\n            ):\n                new_scaling_min = np.concatenate([self.scaling_min, other.scaling_min])\n            else:\n                new_scaling_min = self.scaling_min\n\n            if (\n                self.scaling_max is not None\n                and hasattr(other, \"scaling_max\")\n                and other.scaling_max is not None\n            ):\n                new_scaling_max = np.concatenate([self.scaling_max, other.scaling_max])\n            else:\n                new_scaling_max = self.scaling_max\n\n            # Update true dimension\n            if not augmented:\n                new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n            else:\n                new_true_dim = self._true_dim\n\n            # Update all attributes in place\n            self.shape = new_shape\n            self.min = new_min\n            self.max = new_max\n            self.guess = new_guess\n            self.scaling_min = new_scaling_min\n            self.scaling_max = new_scaling_max\n            self._true_dim = new_true_dim\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n        else:\n            # Create a single new variable\n            new_shape = (self.shape[0] + 1,)\n\n            # Extend arrays\n            if self.min is not None:\n                self.min = np.concatenate([self.min, np.array([min])])\n            if self.max is not None:\n                self.max = np.concatenate([self.max, np.array([max])])\n            if self.guess is not None:\n                guess_arr = np.full((self.guess.shape[0], 1), guess)\n                self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n            if self.scaling_min is not None:\n                self.scaling_min = np.concatenate([self.scaling_min, np.array([min])])\n            if self.scaling_max is not None:\n                self.scaling_max = np.concatenate([self.scaling_max, np.array([max])])\n\n            # Update dimensions\n            self.shape = new_shape\n            if not augmented:\n                self._true_dim += 1\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    def __getitem__(self, idx):\n        \"\"\"Get a subset of the unified control variables.\n\n        Enables slicing of the unified control to extract subsets of control variables.\n        Returns a new UnifiedControl containing only the sliced dimensions.\n\n        Args:\n            idx (slice): Slice object specifying which control dimensions to extract.\n                Only simple slices with step=1 are supported.\n\n        Returns:\n            UnifiedControl: New unified control containing only the sliced dimensions\n\n        Raises:\n            NotImplementedError: If idx is not a slice, or if step != 1\n\n        Example:\n            Generate unified control object::\n\n                unified = unify_controls([thrust, torque], name=\"u\")\n\n            thrust has shape (3,), torque has shape (3,)::\n\n                first_three = unified[0:3]  # Extract thrust only\n                print(first_three.shape)  # (3,)\n\n        Note:\n            The sliced control maintains all properties (bounds, guesses, etc.) for\n            the selected dimensions. The _true_dim is recalculated based on which\n            dimensions fall within the original true control range.\n        \"\"\"\n        if isinstance(idx, slice):\n            start, stop, step = idx.indices(self.shape[0])\n            if step != 1:\n                raise NotImplementedError(\"Step slicing not supported\")\n\n            new_shape = (stop - start,)\n            new_name = f\"{self.name}[{start}:{stop}]\"\n\n            # Slice all arrays\n            new_min = self.min[idx] if self.min is not None else None\n            new_max = self.max[idx] if self.max is not None else None\n            new_guess = self.guess[:, idx] if self.guess is not None else None\n\n            # Calculate new true dimension\n            new_true_dim = max(0, min(stop, self._true_dim) - max(start, 0))\n\n            return UnifiedControl(\n                name=new_name,\n                shape=new_shape,\n                min=new_min,\n                max=new_max,\n                guess=new_guess,\n                _true_dim=new_true_dim,\n                _true_slice=slice(0, new_true_dim),\n                _augmented_slice=slice(new_true_dim, new_shape[0]),\n            )\n        else:\n            raise NotImplementedError(\"Only slice indexing is supported\")\n\n    def __repr__(self):\n        \"\"\"String representation of the UnifiedControl object.\"\"\"\n        return f\"UnifiedControl('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/lowered/unified/#openscvx.lowered.unified.UnifiedControl.augmented","title":"<code>augmented: UnifiedControl</code>  <code>property</code>","text":"<p>Get the augmented (internal) control variables.</p> <p>Returns a view of the unified control containing only augmented controls added internally by the optimization framework (e.g., time dilation control).</p> <p>Returns:</p> Name Type Description <code>UnifiedControl</code> <code>UnifiedControl</code> <p>Sliced view containing only augmented control variables</p> Example <p>Get augmented controls::</p> <pre><code>unified = unify_controls([thrust, time_dilation], name=\"u\")\naug_controls = unified.augmented  # Only time dilation\n</code></pre>"},{"location":"reference/lowered/unified/#openscvx.lowered.unified.UnifiedControl.true","title":"<code>true: UnifiedControl</code>  <code>property</code>","text":"<p>Get the true (user-defined) control variables.</p> <p>Returns a view of the unified control containing only user-defined controls, excluding internal augmented controls added for time dilation, etc.</p> <p>Returns:</p> Name Type Description <code>UnifiedControl</code> <code>UnifiedControl</code> <p>Sliced view containing only true control variables</p> Example <p>Get true user defined controls::</p> <pre><code>unified = unify_controls([thrust, torque, time_dilation], name=\"u\")\ntrue_controls = unified.true  # Only thrust and torque\n</code></pre>"},{"location":"reference/lowered/unified/#openscvx.lowered.unified.UnifiedControl.append","title":"<code>append(other: Optional[Control | UnifiedControl] = None, *, min=-np.inf, max=np.inf, guess=0.0, augmented=False)</code>","text":"<p>Append another control or create a new control variable.</p> <p>This method allows dynamic extension of the unified control, either by appending another Control/UnifiedControl object or by creating a new scalar control variable with specified properties. Modifies the unified control in-place.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Optional[Control | UnifiedControl]</code> <p>Control object to append. If None, creates a new scalar control variable with properties from keyword args.</p> <code>None</code> <code>min</code> <code>float</code> <p>Lower bound for new scalar control (default: -inf)</p> <code>-inf</code> <code>max</code> <code>float</code> <p>Upper bound for new scalar control (default: inf)</p> <code>inf</code> <code>guess</code> <code>float</code> <p>Initial guess value for new scalar control (default: 0.0)</p> <code>0.0</code> <code>augmented</code> <code>bool</code> <p>Whether the appended control is augmented (internal) rather than true (user-defined). Affects _true_dim tracking. Default: False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <p>Modifies the unified control in-place</p> Example <p>Appending a Control object::</p> <pre><code>unified = unify_controls([thrust], name=\"u\")\ntorque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\nunified.append(torque)\nprint(unified.shape)  # (6,) - thrust (3) + torque (3)\n</code></pre> <p>Creating new scalar control variables::</p> <pre><code>unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.0)  # Add scalar control\nprint(unified.shape)  # (1,)\n</code></pre> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>def append(\n    self,\n    other: \"Optional[Control | UnifiedControl]\" = None,\n    *,\n    min=-np.inf,\n    max=np.inf,\n    guess=0.0,\n    augmented=False,\n):\n    \"\"\"Append another control or create a new control variable.\n\n    This method allows dynamic extension of the unified control, either by appending\n    another Control/UnifiedControl object or by creating a new scalar control variable\n    with specified properties. Modifies the unified control in-place.\n\n    Args:\n        other (Optional[Control | UnifiedControl]): Control object to append. If None,\n            creates a new scalar control variable with properties from keyword args.\n        min (float): Lower bound for new scalar control (default: -inf)\n        max (float): Upper bound for new scalar control (default: inf)\n        guess (float): Initial guess value for new scalar control (default: 0.0)\n        augmented (bool): Whether the appended control is augmented (internal) rather\n            than true (user-defined). Affects _true_dim tracking. Default: False\n\n    Returns:\n        None: Modifies the unified control in-place\n\n    Example:\n        Appending a Control object::\n\n            unified = unify_controls([thrust], name=\"u\")\n            torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n            unified.append(torque)\n            print(unified.shape)  # (6,) - thrust (3) + torque (3)\n\n        Creating new scalar control variables::\n\n            unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.0)  # Add scalar control\n            print(unified.shape)  # (1,)\n    \"\"\"\n    # Import here to avoid circular imports at module level\n    from openscvx.symbolic.expr.control import Control\n\n    if isinstance(other, (Control, UnifiedControl)):\n        # Append another control object\n        new_shape = (self.shape[0] + other.shape[0],)\n\n        # Update bounds\n        if self.min is not None and other.min is not None:\n            new_min = np.concatenate([self.min, other.min])\n        else:\n            new_min = self.min\n\n        if self.max is not None and other.max is not None:\n            new_max = np.concatenate([self.max, other.max])\n        else:\n            new_max = self.max\n\n        # Update guess\n        if self.guess is not None and other.guess is not None:\n            new_guess = np.concatenate([self.guess, other.guess], axis=1)\n        else:\n            new_guess = self.guess\n\n        # Update scaling bounds (if present)\n        if (\n            self.scaling_min is not None\n            and hasattr(other, \"scaling_min\")\n            and other.scaling_min is not None\n        ):\n            new_scaling_min = np.concatenate([self.scaling_min, other.scaling_min])\n        else:\n            new_scaling_min = self.scaling_min\n\n        if (\n            self.scaling_max is not None\n            and hasattr(other, \"scaling_max\")\n            and other.scaling_max is not None\n        ):\n            new_scaling_max = np.concatenate([self.scaling_max, other.scaling_max])\n        else:\n            new_scaling_max = self.scaling_max\n\n        # Update true dimension\n        if not augmented:\n            new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n        else:\n            new_true_dim = self._true_dim\n\n        # Update all attributes in place\n        self.shape = new_shape\n        self.min = new_min\n        self.max = new_max\n        self.guess = new_guess\n        self.scaling_min = new_scaling_min\n        self.scaling_max = new_scaling_max\n        self._true_dim = new_true_dim\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    else:\n        # Create a single new variable\n        new_shape = (self.shape[0] + 1,)\n\n        # Extend arrays\n        if self.min is not None:\n            self.min = np.concatenate([self.min, np.array([min])])\n        if self.max is not None:\n            self.max = np.concatenate([self.max, np.array([max])])\n        if self.guess is not None:\n            guess_arr = np.full((self.guess.shape[0], 1), guess)\n            self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n        if self.scaling_min is not None:\n            self.scaling_min = np.concatenate([self.scaling_min, np.array([min])])\n        if self.scaling_max is not None:\n            self.scaling_max = np.concatenate([self.scaling_max, np.array([max])])\n\n        # Update dimensions\n        self.shape = new_shape\n        if not augmented:\n            self._true_dim += 1\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n</code></pre>"},{"location":"reference/lowered/unified/#openscvx.lowered.unified.UnifiedState","title":"<code>UnifiedState</code>  <code>dataclass</code>","text":"<p>Unified state vector aggregating multiple State objects.</p> <p>UnifiedState is a drop-in replacement for individual State objects that holds aggregated data from multiple State instances. It maintains compatibility with optimization infrastructure while providing access to individual state components through slicing.</p> <p>The unified state separates user-defined \"true\" states from augmented states added internally (e.g., for CTCS constraints or time variables). This separation allows clean access to physical states while supporting advanced features.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the unified state vector</p> <code>shape</code> <code>tuple</code> <p>Combined shape (total_dim,) of all aggregated states</p> <code>min</code> <code>ndarray</code> <p>Lower bounds for all state variables, shape (total_dim,)</p> <code>max</code> <code>ndarray</code> <p>Upper bounds for all state variables, shape (total_dim,)</p> <code>guess</code> <code>ndarray</code> <p>Initial guess trajectory, shape (num_nodes, total_dim)</p> <code>initial</code> <code>ndarray</code> <p>Initial boundary conditions, shape (total_dim,)</p> <code>final</code> <code>ndarray</code> <p>Final boundary conditions, shape (total_dim,)</p> <code>_initial</code> <code>ndarray</code> <p>Internal initial values, shape (total_dim,)</p> <code>_final</code> <code>ndarray</code> <p>Internal final values, shape (total_dim,)</p> <code>initial_type</code> <code>ndarray</code> <p>Boundary condition types at t0 (\"Fix\" or \"Free\"), shape (total_dim,), dtype=object</p> <code>final_type</code> <code>ndarray</code> <p>Boundary condition types at tf (\"Fix\" or \"Free\"), shape (total_dim,), dtype=object</p> <code>_true_dim</code> <code>int</code> <p>Number of user-defined state dimensions (excludes augmented)</p> <code>_true_slice</code> <code>slice</code> <p>Slice for extracting true states from unified vector</p> <code>_augmented_slice</code> <code>slice</code> <p>Slice for extracting augmented states</p> <code>time_slice</code> <code>Optional[slice]</code> <p>Slice for time state variable, if present</p> <code>ctcs_slice</code> <code>Optional[slice]</code> <p>Slice for CTCS augmented states, if present</p> Properties <p>true: Returns UnifiedState view containing only true (user-defined) states augmented: Returns UnifiedState view containing only augmented states</p> Example <p>Creating a unified state from multiple State objects::</p> <pre><code>from openscvx.symbolic.unified import unify_states\n\nposition = ox.State(\"pos\", shape=(3,), min=-10, max=10)\nvelocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n\nunified = unify_states([position, velocity], name=\"x\")\nprint(unified.shape)        # (6,)\nprint(unified.min)          # [-10, -10, -10, -5, -5, -5]\nprint(unified.true.shape)   # (6,) - all are true states\nprint(unified.augmented.shape)  # (0,) - no augmented states\n</code></pre> <p>Appending states dynamically::</p> <pre><code>unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.5)  # Add scalar state\nprint(unified.shape)  # (1,)\n</code></pre> See Also <ul> <li>unify_states(): Factory function for creating UnifiedState from State list</li> <li>State: Individual symbolic state variable</li> <li>UnifiedControl: Analogous unified control vector</li> </ul> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>@dataclass\nclass UnifiedState:\n    \"\"\"Unified state vector aggregating multiple State objects.\n\n    UnifiedState is a drop-in replacement for individual State objects that holds\n    aggregated data from multiple State instances. It maintains compatibility with\n    optimization infrastructure while providing access to individual state components\n    through slicing.\n\n    The unified state separates user-defined \"true\" states from augmented states\n    added internally (e.g., for CTCS constraints or time variables). This separation\n    allows clean access to physical states while supporting advanced features.\n\n    Attributes:\n        name (str): Name identifier for the unified state vector\n        shape (tuple): Combined shape (total_dim,) of all aggregated states\n        min (np.ndarray): Lower bounds for all state variables, shape (total_dim,)\n        max (np.ndarray): Upper bounds for all state variables, shape (total_dim,)\n        guess (np.ndarray): Initial guess trajectory, shape (num_nodes, total_dim)\n        initial (np.ndarray): Initial boundary conditions, shape (total_dim,)\n        final (np.ndarray): Final boundary conditions, shape (total_dim,)\n        _initial (np.ndarray): Internal initial values, shape (total_dim,)\n        _final (np.ndarray): Internal final values, shape (total_dim,)\n        initial_type (np.ndarray): Boundary condition types at t0 (\"Fix\" or \"Free\"),\n            shape (total_dim,), dtype=object\n        final_type (np.ndarray): Boundary condition types at tf (\"Fix\" or \"Free\"),\n            shape (total_dim,), dtype=object\n        _true_dim (int): Number of user-defined state dimensions (excludes augmented)\n        _true_slice (slice): Slice for extracting true states from unified vector\n        _augmented_slice (slice): Slice for extracting augmented states\n        time_slice (Optional[slice]): Slice for time state variable, if present\n        ctcs_slice (Optional[slice]): Slice for CTCS augmented states, if present\n\n    Properties:\n        true: Returns UnifiedState view containing only true (user-defined) states\n        augmented: Returns UnifiedState view containing only augmented states\n\n    Example:\n        Creating a unified state from multiple State objects::\n\n            from openscvx.symbolic.unified import unify_states\n\n            position = ox.State(\"pos\", shape=(3,), min=-10, max=10)\n            velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n\n            unified = unify_states([position, velocity], name=\"x\")\n            print(unified.shape)        # (6,)\n            print(unified.min)          # [-10, -10, -10, -5, -5, -5]\n            print(unified.true.shape)   # (6,) - all are true states\n            print(unified.augmented.shape)  # (0,) - no augmented states\n\n        Appending states dynamically::\n\n            unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.5)  # Add scalar state\n            print(unified.shape)  # (1,)\n\n    See Also:\n        - unify_states(): Factory function for creating UnifiedState from State list\n        - State: Individual symbolic state variable\n        - UnifiedControl: Analogous unified control vector\n    \"\"\"\n\n    name: str\n    shape: tuple\n    min: Optional[np.ndarray] = None\n    max: Optional[np.ndarray] = None\n    guess: Optional[np.ndarray] = None\n    initial: Optional[np.ndarray] = None\n    final: Optional[np.ndarray] = None\n    _initial: Optional[np.ndarray] = None\n    _final: Optional[np.ndarray] = None\n    initial_type: Optional[np.ndarray] = None\n    final_type: Optional[np.ndarray] = None\n    _true_dim: int = 0\n    _true_slice: Optional[slice] = None\n    _augmented_slice: Optional[slice] = None\n    time_slice: Optional[slice] = None  # Slice for time state\n    ctcs_slice: Optional[slice] = None  # Slice for CTCS augmented states\n    scaling_min: Optional[np.ndarray] = None  # Scaling minimum bounds for unified state\n    scaling_max: Optional[np.ndarray] = None  # Scaling maximum bounds for unified state\n\n    def __post_init__(self):\n        \"\"\"Initialize slices after dataclass creation.\"\"\"\n        if self._true_slice is None:\n            self._true_slice = slice(0, self._true_dim)\n        if self._augmented_slice is None:\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    @property\n    def true(self) -&gt; \"UnifiedState\":\n        \"\"\"Get the true (user-defined) state variables.\n\n        Returns a view of the unified state containing only user-defined states,\n        excluding internal augmented states added for CTCS, time, etc.\n\n        Returns:\n            UnifiedState: Sliced view containing only true state variables\n\n        Example:\n            Get true user-defined state::\n\n                unified = unify_states([position, velocity, ctcs_aug], name=\"x\")\n                true_states = unified.true  # Only position and velocity\n                true_states.shape  # (6,) if position and velocity are 3D each\n        \"\"\"\n        return self[self._true_slice]\n\n    @property\n    def augmented(self) -&gt; \"UnifiedState\":\n        \"\"\"Get the augmented (internal) state variables.\n\n        Returns a view of the unified state containing only augmented states\n        added internally by the optimization framework (e.g., CTCS penalty states,\n        time variables).\n\n        Returns:\n            UnifiedState: Sliced view containing only augmented state variables\n\n        Example:\n            Get augmented state::\n\n                unified = unify_states([position, ctcs_aug], name=\"x\")\n                aug_states = unified.augmented  # Only CTCS states\n        \"\"\"\n        return self[self._augmented_slice]\n\n    def append(\n        self,\n        other: \"Optional[State | UnifiedState]\" = None,\n        *,\n        min=-np.inf,\n        max=np.inf,\n        guess=0.0,\n        initial=0.0,\n        final=0.0,\n        augmented=False,\n    ):\n        \"\"\"Append another state or create a new state variable.\n\n        This method allows dynamic extension of the unified state, either by appending\n        another State/UnifiedState object or by creating a new scalar state variable\n        with specified properties. Modifies the unified state in-place.\n\n        Args:\n            other (Optional[State | UnifiedState]): State object to append. If None,\n                creates a new scalar state variable with properties from keyword args.\n            min (float): Lower bound for new scalar state (default: -inf)\n            max (float): Upper bound for new scalar state (default: inf)\n            guess (float): Initial guess value for new scalar state (default: 0.0)\n            initial (float): Initial boundary condition for new scalar state (default: 0.0)\n            final (float): Final boundary condition for new scalar state (default: 0.0)\n            augmented (bool): Whether the appended state is augmented (internal) rather\n                than true (user-defined). Affects _true_dim tracking. Default: False\n\n        Returns:\n            None: Modifies the unified state in-place\n\n        Example:\n            Appending a State object::\n\n                unified = unify_states([position], name=\"x\")\n                velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n                unified.append(velocity)\n                print(unified.shape)  # (6,) - position (3) + velocity (3)\n\n            Creating new scalar state variables::\n\n                unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\n                unified.append(min=-1, max=1, guess=0.5)  # Add scalar state\n                unified.append(min=-2, max=2, augmented=True)  # Add augmented state\n                print(unified.shape)  # (2,)\n                print(unified._true_dim)  # 1 (only first is true)\n\n        Note:\n            Maintains the invariant that true states appear before augmented states\n            in the unified vector. When appending augmented states, they are added\n            to the end but don't increment _true_dim.\n        \"\"\"\n        # Import here to avoid circular imports at module level\n        from openscvx.symbolic.expr.state import State\n\n        if isinstance(other, (State, UnifiedState)):\n            # Append another state object\n            new_shape = (self.shape[0] + other.shape[0],)\n\n            # Update bounds\n            if self.min is not None and other.min is not None:\n                new_min = np.concatenate([self.min, other.min])\n            else:\n                new_min = self.min\n\n            if self.max is not None and other.max is not None:\n                new_max = np.concatenate([self.max, other.max])\n            else:\n                new_max = self.max\n\n            # Update guess\n            if self.guess is not None and other.guess is not None:\n                new_guess = np.concatenate([self.guess, other.guess], axis=1)\n            else:\n                new_guess = self.guess\n\n            # Update initial/final conditions\n            if self.initial is not None and other.initial is not None:\n                new_initial = np.concatenate([self.initial, other.initial])\n            else:\n                new_initial = self.initial\n\n            if self.final is not None and other.final is not None:\n                new_final = np.concatenate([self.final, other.final])\n            else:\n                new_final = self.final\n\n            # Update internal arrays\n            if self._initial is not None and other._initial is not None:\n                new__initial = np.concatenate([self._initial, other._initial])\n            else:\n                new__initial = self._initial\n\n            if self._final is not None and other._final is not None:\n                new__final = np.concatenate([self._final, other._final])\n            else:\n                new__final = self._final\n\n            # Update types\n            if self.initial_type is not None and other.initial_type is not None:\n                new_initial_type = np.concatenate([self.initial_type, other.initial_type])\n            else:\n                new_initial_type = self.initial_type\n\n            if self.final_type is not None and other.final_type is not None:\n                new_final_type = np.concatenate([self.final_type, other.final_type])\n            else:\n                new_final_type = self.final_type\n\n            # Update scaling bounds (if present)\n            if (\n                self.scaling_min is not None\n                and hasattr(other, \"scaling_min\")\n                and other.scaling_min is not None\n            ):\n                new_scaling_min = np.concatenate([self.scaling_min, other.scaling_min])\n            else:\n                new_scaling_min = self.scaling_min\n\n            if (\n                self.scaling_max is not None\n                and hasattr(other, \"scaling_max\")\n                and other.scaling_max is not None\n            ):\n                new_scaling_max = np.concatenate([self.scaling_max, other.scaling_max])\n            else:\n                new_scaling_max = self.scaling_max\n\n            # Update true dimension\n            if not augmented:\n                new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n            else:\n                new_true_dim = self._true_dim\n\n            # Update all attributes in place\n            self.shape = new_shape\n            self.min = new_min\n            self.max = new_max\n            self.guess = new_guess\n            self.initial = new_initial\n            self.final = new_final\n            self._initial = new__initial\n            self._final = new__final\n            self.initial_type = new_initial_type\n            self.final_type = new_final_type\n            self.scaling_min = new_scaling_min\n            self.scaling_max = new_scaling_max\n            self._true_dim = new_true_dim\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n        else:\n            # Create a single new variable\n            new_shape = (self.shape[0] + 1,)\n\n            # Extend arrays\n            if self.min is not None:\n                self.min = np.concatenate([self.min, np.array([min])])\n            if self.max is not None:\n                self.max = np.concatenate([self.max, np.array([max])])\n            if self.guess is not None:\n                guess_arr = np.full((self.guess.shape[0], 1), guess)\n                self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n            if self.initial is not None:\n                self.initial = np.concatenate([self.initial, np.array([initial])])\n            if self.final is not None:\n                self.final = np.concatenate([self.final, np.array([final])])\n            if self._initial is not None:\n                self._initial = np.concatenate([self._initial, np.array([initial])])\n            if self._final is not None:\n                self._final = np.concatenate([self._final, np.array([final])])\n            if self.initial_type is not None:\n                self.initial_type = np.concatenate(\n                    [self.initial_type, np.array([\"Fix\"], dtype=object)]\n                )\n            if self.final_type is not None:\n                self.final_type = np.concatenate([self.final_type, np.array([\"Fix\"], dtype=object)])\n            if self.scaling_min is not None:\n                self.scaling_min = np.concatenate([self.scaling_min, np.array([min])])\n            if self.scaling_max is not None:\n                self.scaling_max = np.concatenate([self.scaling_max, np.array([max])])\n\n            # Update dimensions\n            self.shape = new_shape\n            if not augmented:\n                self._true_dim += 1\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    def __getitem__(self, idx):\n        \"\"\"Get a subset of the unified state variables.\n\n        Enables slicing of the unified state to extract subsets of state variables.\n        Returns a new UnifiedState containing only the sliced dimensions.\n\n        Args:\n            idx (slice): Slice object specifying which state dimensions to extract.\n                Only simple slices with step=1 are supported.\n\n        Returns:\n            UnifiedState: New unified state containing only the sliced dimensions\n\n        Raises:\n            NotImplementedError: If idx is not a slice, or if step != 1\n\n        Example:\n            Generate unified state object::\n\n                unified = unify_states([position, velocity], name=\"x\")\n\n            position has shape (3,), velocity has shape (3,)::\n\n                first_three = unified[0:3]  # Extract position only\n                print(first_three.shape)  # (3,)\n                last_three = unified[3:6]  # Extract velocity only\n                print(last_three.shape)  # (3,)\n\n        Note:\n            The sliced state maintains all properties (bounds, guesses, etc.) for\n            the selected dimensions. The _true_dim is recalculated based on which\n            dimensions fall within the original true state range.\n        \"\"\"\n        if isinstance(idx, slice):\n            start, stop, step = idx.indices(self.shape[0])\n            if step != 1:\n                raise NotImplementedError(\"Step slicing not supported\")\n\n            new_shape = (stop - start,)\n            new_name = f\"{self.name}[{start}:{stop}]\"\n\n            # Slice all arrays\n            new_min = self.min[idx] if self.min is not None else None\n            new_max = self.max[idx] if self.max is not None else None\n            new_guess = self.guess[:, idx] if self.guess is not None else None\n            new_initial = self.initial[idx] if self.initial is not None else None\n            new_final = self.final[idx] if self.final is not None else None\n            new__initial = self._initial[idx] if self._initial is not None else None\n            new__final = self._final[idx] if self._final is not None else None\n            new_initial_type = self.initial_type[idx] if self.initial_type is not None else None\n            new_final_type = self.final_type[idx] if self.final_type is not None else None\n\n            # Calculate new true dimension\n            new_true_dim = max(0, min(stop, self._true_dim) - max(start, 0))\n\n            return UnifiedState(\n                name=new_name,\n                shape=new_shape,\n                min=new_min,\n                max=new_max,\n                guess=new_guess,\n                initial=new_initial,\n                final=new_final,\n                _initial=new__initial,\n                _final=new__final,\n                initial_type=new_initial_type,\n                final_type=new_final_type,\n                _true_dim=new_true_dim,\n                _true_slice=slice(0, new_true_dim),\n                _augmented_slice=slice(new_true_dim, new_shape[0]),\n            )\n        else:\n            raise NotImplementedError(\"Only slice indexing is supported\")\n\n    def __repr__(self):\n        \"\"\"String representation of the UnifiedState object.\"\"\"\n        return f\"UnifiedState('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/lowered/unified/#openscvx.lowered.unified.UnifiedState.augmented","title":"<code>augmented: UnifiedState</code>  <code>property</code>","text":"<p>Get the augmented (internal) state variables.</p> <p>Returns a view of the unified state containing only augmented states added internally by the optimization framework (e.g., CTCS penalty states, time variables).</p> <p>Returns:</p> Name Type Description <code>UnifiedState</code> <code>UnifiedState</code> <p>Sliced view containing only augmented state variables</p> Example <p>Get augmented state::</p> <pre><code>unified = unify_states([position, ctcs_aug], name=\"x\")\naug_states = unified.augmented  # Only CTCS states\n</code></pre>"},{"location":"reference/lowered/unified/#openscvx.lowered.unified.UnifiedState.true","title":"<code>true: UnifiedState</code>  <code>property</code>","text":"<p>Get the true (user-defined) state variables.</p> <p>Returns a view of the unified state containing only user-defined states, excluding internal augmented states added for CTCS, time, etc.</p> <p>Returns:</p> Name Type Description <code>UnifiedState</code> <code>UnifiedState</code> <p>Sliced view containing only true state variables</p> Example <p>Get true user-defined state::</p> <pre><code>unified = unify_states([position, velocity, ctcs_aug], name=\"x\")\ntrue_states = unified.true  # Only position and velocity\ntrue_states.shape  # (6,) if position and velocity are 3D each\n</code></pre>"},{"location":"reference/lowered/unified/#openscvx.lowered.unified.UnifiedState.append","title":"<code>append(other: Optional[State | UnifiedState] = None, *, min=-np.inf, max=np.inf, guess=0.0, initial=0.0, final=0.0, augmented=False)</code>","text":"<p>Append another state or create a new state variable.</p> <p>This method allows dynamic extension of the unified state, either by appending another State/UnifiedState object or by creating a new scalar state variable with specified properties. Modifies the unified state in-place.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Optional[State | UnifiedState]</code> <p>State object to append. If None, creates a new scalar state variable with properties from keyword args.</p> <code>None</code> <code>min</code> <code>float</code> <p>Lower bound for new scalar state (default: -inf)</p> <code>-inf</code> <code>max</code> <code>float</code> <p>Upper bound for new scalar state (default: inf)</p> <code>inf</code> <code>guess</code> <code>float</code> <p>Initial guess value for new scalar state (default: 0.0)</p> <code>0.0</code> <code>initial</code> <code>float</code> <p>Initial boundary condition for new scalar state (default: 0.0)</p> <code>0.0</code> <code>final</code> <code>float</code> <p>Final boundary condition for new scalar state (default: 0.0)</p> <code>0.0</code> <code>augmented</code> <code>bool</code> <p>Whether the appended state is augmented (internal) rather than true (user-defined). Affects _true_dim tracking. Default: False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <p>Modifies the unified state in-place</p> Example <p>Appending a State object::</p> <pre><code>unified = unify_states([position], name=\"x\")\nvelocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\nunified.append(velocity)\nprint(unified.shape)  # (6,) - position (3) + velocity (3)\n</code></pre> <p>Creating new scalar state variables::</p> <pre><code>unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.5)  # Add scalar state\nunified.append(min=-2, max=2, augmented=True)  # Add augmented state\nprint(unified.shape)  # (2,)\nprint(unified._true_dim)  # 1 (only first is true)\n</code></pre> Note <p>Maintains the invariant that true states appear before augmented states in the unified vector. When appending augmented states, they are added to the end but don't increment _true_dim.</p> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>def append(\n    self,\n    other: \"Optional[State | UnifiedState]\" = None,\n    *,\n    min=-np.inf,\n    max=np.inf,\n    guess=0.0,\n    initial=0.0,\n    final=0.0,\n    augmented=False,\n):\n    \"\"\"Append another state or create a new state variable.\n\n    This method allows dynamic extension of the unified state, either by appending\n    another State/UnifiedState object or by creating a new scalar state variable\n    with specified properties. Modifies the unified state in-place.\n\n    Args:\n        other (Optional[State | UnifiedState]): State object to append. If None,\n            creates a new scalar state variable with properties from keyword args.\n        min (float): Lower bound for new scalar state (default: -inf)\n        max (float): Upper bound for new scalar state (default: inf)\n        guess (float): Initial guess value for new scalar state (default: 0.0)\n        initial (float): Initial boundary condition for new scalar state (default: 0.0)\n        final (float): Final boundary condition for new scalar state (default: 0.0)\n        augmented (bool): Whether the appended state is augmented (internal) rather\n            than true (user-defined). Affects _true_dim tracking. Default: False\n\n    Returns:\n        None: Modifies the unified state in-place\n\n    Example:\n        Appending a State object::\n\n            unified = unify_states([position], name=\"x\")\n            velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n            unified.append(velocity)\n            print(unified.shape)  # (6,) - position (3) + velocity (3)\n\n        Creating new scalar state variables::\n\n            unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.5)  # Add scalar state\n            unified.append(min=-2, max=2, augmented=True)  # Add augmented state\n            print(unified.shape)  # (2,)\n            print(unified._true_dim)  # 1 (only first is true)\n\n    Note:\n        Maintains the invariant that true states appear before augmented states\n        in the unified vector. When appending augmented states, they are added\n        to the end but don't increment _true_dim.\n    \"\"\"\n    # Import here to avoid circular imports at module level\n    from openscvx.symbolic.expr.state import State\n\n    if isinstance(other, (State, UnifiedState)):\n        # Append another state object\n        new_shape = (self.shape[0] + other.shape[0],)\n\n        # Update bounds\n        if self.min is not None and other.min is not None:\n            new_min = np.concatenate([self.min, other.min])\n        else:\n            new_min = self.min\n\n        if self.max is not None and other.max is not None:\n            new_max = np.concatenate([self.max, other.max])\n        else:\n            new_max = self.max\n\n        # Update guess\n        if self.guess is not None and other.guess is not None:\n            new_guess = np.concatenate([self.guess, other.guess], axis=1)\n        else:\n            new_guess = self.guess\n\n        # Update initial/final conditions\n        if self.initial is not None and other.initial is not None:\n            new_initial = np.concatenate([self.initial, other.initial])\n        else:\n            new_initial = self.initial\n\n        if self.final is not None and other.final is not None:\n            new_final = np.concatenate([self.final, other.final])\n        else:\n            new_final = self.final\n\n        # Update internal arrays\n        if self._initial is not None and other._initial is not None:\n            new__initial = np.concatenate([self._initial, other._initial])\n        else:\n            new__initial = self._initial\n\n        if self._final is not None and other._final is not None:\n            new__final = np.concatenate([self._final, other._final])\n        else:\n            new__final = self._final\n\n        # Update types\n        if self.initial_type is not None and other.initial_type is not None:\n            new_initial_type = np.concatenate([self.initial_type, other.initial_type])\n        else:\n            new_initial_type = self.initial_type\n\n        if self.final_type is not None and other.final_type is not None:\n            new_final_type = np.concatenate([self.final_type, other.final_type])\n        else:\n            new_final_type = self.final_type\n\n        # Update scaling bounds (if present)\n        if (\n            self.scaling_min is not None\n            and hasattr(other, \"scaling_min\")\n            and other.scaling_min is not None\n        ):\n            new_scaling_min = np.concatenate([self.scaling_min, other.scaling_min])\n        else:\n            new_scaling_min = self.scaling_min\n\n        if (\n            self.scaling_max is not None\n            and hasattr(other, \"scaling_max\")\n            and other.scaling_max is not None\n        ):\n            new_scaling_max = np.concatenate([self.scaling_max, other.scaling_max])\n        else:\n            new_scaling_max = self.scaling_max\n\n        # Update true dimension\n        if not augmented:\n            new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n        else:\n            new_true_dim = self._true_dim\n\n        # Update all attributes in place\n        self.shape = new_shape\n        self.min = new_min\n        self.max = new_max\n        self.guess = new_guess\n        self.initial = new_initial\n        self.final = new_final\n        self._initial = new__initial\n        self._final = new__final\n        self.initial_type = new_initial_type\n        self.final_type = new_final_type\n        self.scaling_min = new_scaling_min\n        self.scaling_max = new_scaling_max\n        self._true_dim = new_true_dim\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    else:\n        # Create a single new variable\n        new_shape = (self.shape[0] + 1,)\n\n        # Extend arrays\n        if self.min is not None:\n            self.min = np.concatenate([self.min, np.array([min])])\n        if self.max is not None:\n            self.max = np.concatenate([self.max, np.array([max])])\n        if self.guess is not None:\n            guess_arr = np.full((self.guess.shape[0], 1), guess)\n            self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n        if self.initial is not None:\n            self.initial = np.concatenate([self.initial, np.array([initial])])\n        if self.final is not None:\n            self.final = np.concatenate([self.final, np.array([final])])\n        if self._initial is not None:\n            self._initial = np.concatenate([self._initial, np.array([initial])])\n        if self._final is not None:\n            self._final = np.concatenate([self._final, np.array([final])])\n        if self.initial_type is not None:\n            self.initial_type = np.concatenate(\n                [self.initial_type, np.array([\"Fix\"], dtype=object)]\n            )\n        if self.final_type is not None:\n            self.final_type = np.concatenate([self.final_type, np.array([\"Fix\"], dtype=object)])\n        if self.scaling_min is not None:\n            self.scaling_min = np.concatenate([self.scaling_min, np.array([min])])\n        if self.scaling_max is not None:\n            self.scaling_max = np.concatenate([self.scaling_max, np.array([max])])\n\n        # Update dimensions\n        self.shape = new_shape\n        if not augmented:\n            self._true_dim += 1\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n</code></pre>"},{"location":"reference/plotting/","title":"plotting","text":"<p>Trajectory visualization and plotting utilities.</p> <p>This module provides reusable building blocks for visualizing trajectory optimization results. It is intentionally minimal - we provide common utilities that can be composed together, not a complete solution that tries to do everything for you.</p> <p>2D Plots (plotly-based):     Two-layer API for time series visualization::</p> <pre><code>    from openscvx.plotting import plot_states, plot_controls, plot_vector_norm\n\n    # High-level: subplot grid with individual scaling per component\n    plot_states(results, [\"position\", \"velocity\"]).show()\n    plot_controls(results, [\"thrust\"]).show()\n\n    # Low-level: single component\n    plot_state_component(results, \"position\", component=2).show()  # z only\n\n    # Specialized plots\n    plot_vector_norm(results, \"thrust\", bounds=(rho_min, rho_max)).show()\n    plot_projections_2d(results, velocity_var_name=\"velocity\").show()\n</code></pre> <p>3D Visualization (viser-based):     The <code>viser</code> submodule provides composable primitives for building     interactive 3D visualizations. See <code>openscvx.plotting.viser</code> for details::</p> <pre><code>    from openscvx.plotting import viser\n    server = viser.create_server(positions)\n    viser.add_gates(server, gate_vertices)\n    server.sleep_forever()\n</code></pre> <p>For problem-specific visualization examples (drones, rockets, etc.), see <code>examples/plotting_viser.py</code>.</p>"},{"location":"reference/plotting/#openscvx.plotting.plot_control_component","title":"<code>plot_control_component(result: OptimizationResults, control_name: str, component: int = 0) -&gt; go.Figure</code>","text":"<p>Plot a single component of a control variable vs time.</p> <p>This is the low-level function for plotting one scalar control over time. For plotting all components of a control, use plot_controls().</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>OptimizationResults</code> <p>Optimization results containing control trajectories</p> required <code>control_name</code> <code>str</code> <p>Name of the control variable</p> required <code>component</code> <code>int</code> <p>Component index (0-indexed). For scalar controls, use 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly figure with single plot</p> Example <p>plot_control_component(result, \"thrust\", 0)  # Plot thrust_x</p> Source code in <code>openscvx/plotting/plotting.py</code> <pre><code>def plot_control_component(\n    result: OptimizationResults,\n    control_name: str,\n    component: int = 0,\n) -&gt; go.Figure:\n    \"\"\"Plot a single component of a control variable vs time.\n\n    This is the low-level function for plotting one scalar control over time.\n    For plotting all components of a control, use plot_controls().\n\n    Args:\n        result: Optimization results containing control trajectories\n        control_name: Name of the control variable\n        component: Component index (0-indexed). For scalar controls, use 0.\n\n    Returns:\n        Plotly figure with single plot\n\n    Example:\n        &gt;&gt;&gt; plot_control_component(result, \"thrust\", 0)  # Plot thrust_x\n    \"\"\"\n    available = {c.name for c in result._controls}\n    if control_name not in available:\n        raise ValueError(f\"Control '{control_name}' not found. Available: {sorted(available)}\")\n\n    dim = _get_var_dim(result, control_name, result._controls)\n    if component &lt; 0 or component &gt;= dim:\n        raise ValueError(f\"Component {component} out of range for '{control_name}' (dim={dim})\")\n\n    t_nodes = result.nodes[\"time\"].flatten()\n    has_trajectory = bool(result.trajectory) and control_name in result.trajectory\n    t_full = result.trajectory[\"time\"].flatten() if has_trajectory else None\n\n    label = f\"{control_name}_{component}\" if dim &gt; 1 else control_name\n\n    fig = go.Figure()\n    fig.update_layout(title_text=label, template=\"plotly_dark\")\n\n    if has_trajectory:\n        data = result.trajectory[control_name]\n        y = data if data.ndim == 1 else data[:, component]\n        fig.add_trace(\n            go.Scatter(\n                x=t_full,\n                y=y,\n                mode=\"lines\",\n                name=\"Trajectory\",\n                line={\"color\": \"green\", \"width\": 2},\n            )\n        )\n\n    if control_name in result.nodes:\n        data = result.nodes[control_name]\n        y = data if data.ndim == 1 else data[:, component]\n        fig.add_trace(\n            go.Scatter(\n                x=t_nodes,\n                y=y,\n                mode=\"markers\",\n                name=\"Nodes\",\n                marker={\"color\": \"cyan\", \"size\": 6},\n            )\n        )\n\n    fig.update_xaxes(title_text=\"Time (s)\")\n    fig.update_yaxes(title_text=label)\n    return fig\n</code></pre>"},{"location":"reference/plotting/#openscvx.plotting.plot_controls","title":"<code>plot_controls(result: OptimizationResults, control_names: list[str] | None = None, include_private: bool = False, cols: int = 3) -&gt; go.Figure</code>","text":"<p>Plot control variables in a subplot grid.</p> <p>Each component of each control gets its own subplot with individual y-axis scaling. This is the primary function for visualizing control trajectories.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>OptimizationResults</code> <p>Optimization results containing control trajectories</p> required <code>control_names</code> <code>list[str] | None</code> <p>List of control names to plot. If None, plots all controls.</p> <code>None</code> <code>include_private</code> <code>bool</code> <p>Whether to include private controls (names starting with '_')</p> <code>False</code> <code>cols</code> <code>int</code> <p>Maximum number of columns in subplot grid</p> <code>3</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly figure with subplot grid</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; plot_controls(result, [\"thrust\"])  # 3 subplots for x, y, z\n&gt;&gt;&gt; plot_controls(result)  # All controls\n</code></pre> Source code in <code>openscvx/plotting/plotting.py</code> <pre><code>def plot_controls(\n    result: OptimizationResults,\n    control_names: list[str] | None = None,\n    include_private: bool = False,\n    cols: int = 3,\n) -&gt; go.Figure:\n    \"\"\"Plot control variables in a subplot grid.\n\n    Each component of each control gets its own subplot with individual y-axis\n    scaling. This is the primary function for visualizing control trajectories.\n\n    Args:\n        result: Optimization results containing control trajectories\n        control_names: List of control names to plot. If None, plots all controls.\n        include_private: Whether to include private controls (names starting with '_')\n        cols: Maximum number of columns in subplot grid\n\n    Returns:\n        Plotly figure with subplot grid\n\n    Examples:\n        &gt;&gt;&gt; plot_controls(result, [\"thrust\"])  # 3 subplots for x, y, z\n        &gt;&gt;&gt; plot_controls(result)  # All controls\n    \"\"\"\n\n    controls = result._controls\n    if not include_private:\n        controls = [c for c in controls if not c.name.startswith(\"_\")]\n\n    if control_names is not None:\n        available = {c.name for c in controls}\n        missing = set(control_names) - available\n        if missing:\n            raise ValueError(f\"Controls not found in result: {missing}\")\n        # Preserve order from control_names\n        control_order = {name: i for i, name in enumerate(control_names)}\n        controls = sorted(\n            [c for c in controls if c.name in control_names],\n            key=lambda c: control_order[c.name],\n        )\n\n    # Build list of (display_name, var_name, component_idx)\n    components = []\n    for c in controls:\n        dim = _get_var_dim(result, c.name, result._controls)\n        if dim == 1:\n            components.append((c.name, c.name, 0))\n        else:\n            for i in range(dim):\n                components.append((f\"{c.name}_{i}\", c.name, i))\n\n    if not components:\n        raise ValueError(\"No control components to plot\")\n\n    n_cols = min(cols, len(components))\n    n_rows = (len(components) + n_cols - 1) // n_cols\n\n    fig = make_subplots(rows=n_rows, cols=n_cols, subplot_titles=[c[0] for c in components])\n    fig.update_layout(title_text=\"Control Trajectories\", template=\"plotly_dark\")\n\n    for idx, (_, var_name, comp_idx) in enumerate(components):\n        row = (idx // n_cols) + 1\n        col = (idx % n_cols) + 1\n\n        # Get bounds for this component\n        var = _get_var(result, var_name, result._controls)\n        min_val = var.min[comp_idx] if var.min is not None else None\n        max_val = var.max[comp_idx] if var.max is not None else None\n\n        _add_component_traces(\n            fig,\n            result,\n            var_name,\n            comp_idx,\n            row,\n            col,\n            show_legend=(idx == 0),\n            min_val=min_val,\n            max_val=max_val,\n        )\n\n    # Add x-axis labels to bottom row\n    for col_idx in range(1, n_cols + 1):\n        fig.update_xaxes(title_text=\"Time (s)\", row=n_rows, col=col_idx)\n\n    return fig\n</code></pre>"},{"location":"reference/plotting/#openscvx.plotting.plot_projections_2d","title":"<code>plot_projections_2d(result: OptimizationResults, var_name: str = 'position', velocity_var_name: str | None = None, cmap: str = 'viridis')</code>","text":"<p>Plot XY, XZ, YZ projections of a 3D variable.</p> <p>Useful for visualizing 3D trajectories in 2D plane views.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>OptimizationResults</code> <p>Optimization results containing trajectories</p> required <code>var_name</code> <code>str</code> <p>Name of the 3D variable to plot (default: \"position\")</p> <code>'position'</code> <code>velocity_var_name</code> <code>str | None</code> <p>Optional name of velocity variable for coloring by speed. If provided, trajectory points are colored by velocity magnitude.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap name for velocity coloring (default: \"viridis\")</p> <code>'viridis'</code> <p>Returns:</p> Type Description <p>Plotly figure with three subplots (XY, XZ, YZ planes)</p> Source code in <code>openscvx/plotting/plotting.py</code> <pre><code>def plot_projections_2d(\n    result: OptimizationResults,\n    var_name: str = \"position\",\n    velocity_var_name: str | None = None,\n    cmap: str = \"viridis\",\n):\n    \"\"\"Plot XY, XZ, YZ projections of a 3D variable.\n\n    Useful for visualizing 3D trajectories in 2D plane views.\n\n    Args:\n        result: Optimization results containing trajectories\n        var_name: Name of the 3D variable to plot (default: \"position\")\n        velocity_var_name: Optional name of velocity variable for coloring by speed.\n            If provided, trajectory points are colored by velocity magnitude.\n        cmap: Matplotlib colormap name for velocity coloring (default: \"viridis\")\n\n    Returns:\n        Plotly figure with three subplots (XY, XZ, YZ planes)\n    \"\"\"\n    import numpy as np\n\n    has_trajectory = bool(result.trajectory) and var_name in result.trajectory\n    has_nodes = var_name in result.nodes\n\n    if not has_trajectory and not has_nodes:\n        available_traj = set(result.trajectory.keys()) if result.trajectory else set()\n        available_nodes = set(result.nodes.keys())\n        raise ValueError(\n            f\"Variable '{var_name}' not found. \"\n            f\"Available in trajectory: {sorted(available_traj)}, nodes: {sorted(available_nodes)}\"\n        )\n\n    fig = make_subplots(\n        rows=2,\n        cols=2,\n        subplot_titles=(\"XY Plane\", \"XZ Plane\", \"YZ Plane\"),\n        specs=[[{}, {}], [{}, None]],\n    )\n\n    # Subplot positions: (x_idx, y_idx, row, col)\n    subplots = [(0, 1, 1, 1), (0, 2, 1, 2), (1, 2, 2, 1)]\n\n    # Compute velocity norms if velocity variable is provided\n    traj_vel_norm = None\n    node_vel_norm = None\n    if velocity_var_name is not None:\n        if has_trajectory and velocity_var_name in result.trajectory:\n            traj_vel_norm = np.linalg.norm(result.trajectory[velocity_var_name], axis=1)\n        if has_nodes and velocity_var_name in result.nodes:\n            node_vel_norm = np.linalg.norm(result.nodes[velocity_var_name], axis=1)\n\n    # Colorbar config (only shown once)\n    colorbar_cfg = {\"title\": \"\u2016velocity\u2016\", \"x\": 1.02, \"y\": 0.5, \"len\": 0.9}\n\n    # Plot trajectory if available\n    if has_trajectory:\n        data = result.trajectory[var_name]\n        for i, (xi, yi, row, col) in enumerate(subplots):\n            if traj_vel_norm is not None:\n                marker = {\n                    \"size\": 4,\n                    \"color\": traj_vel_norm,\n                    \"colorscale\": cmap,\n                    \"showscale\": (i == 0),\n                    \"colorbar\": colorbar_cfg if i == 0 else None,\n                }\n                fig.add_trace(\n                    go.Scatter(\n                        x=data[:, xi],\n                        y=data[:, yi],\n                        mode=\"markers\",\n                        marker=marker,\n                        name=\"Trajectory\",\n                        legendgroup=\"trajectory\",\n                        showlegend=(i == 0),\n                    ),\n                    row=row,\n                    col=col,\n                )\n            else:\n                fig.add_trace(\n                    go.Scatter(\n                        x=data[:, xi],\n                        y=data[:, yi],\n                        mode=\"lines\",\n                        line={\"color\": \"green\", \"width\": 2},\n                        name=\"Trajectory\",\n                        legendgroup=\"trajectory\",\n                        showlegend=(i == 0),\n                    ),\n                    row=row,\n                    col=col,\n                )\n\n    # Plot nodes if available\n    if has_nodes:\n        data = result.nodes[var_name]\n        # Only show colorbar on nodes if trajectory doesn't have one\n        show_node_colorbar = (traj_vel_norm is None) and (node_vel_norm is not None)\n        for i, (xi, yi, row, col) in enumerate(subplots):\n            if node_vel_norm is not None:\n                marker = {\n                    \"size\": 8,\n                    \"color\": node_vel_norm,\n                    \"colorscale\": cmap,\n                    \"showscale\": show_node_colorbar and (i == 0),\n                    \"colorbar\": colorbar_cfg if (show_node_colorbar and i == 0) else None,\n                    \"line\": {\"color\": \"white\", \"width\": 1},\n                }\n            else:\n                marker = {\"color\": \"cyan\", \"size\": 6}\n            fig.add_trace(\n                go.Scatter(\n                    x=data[:, xi],\n                    y=data[:, yi],\n                    mode=\"markers\",\n                    marker=marker,\n                    name=\"Nodes\",\n                    legendgroup=\"nodes\",\n                    showlegend=(i == 0),\n                ),\n                row=row,\n                col=col,\n            )\n\n    # Set axis titles\n    fig.update_xaxes(title_text=\"X\", row=1, col=1)\n    fig.update_yaxes(title_text=\"Y\", row=1, col=1)\n    fig.update_xaxes(title_text=\"X\", row=1, col=2)\n    fig.update_yaxes(title_text=\"Z\", row=1, col=2)\n    fig.update_xaxes(title_text=\"Y\", row=2, col=1)\n    fig.update_yaxes(title_text=\"Z\", row=2, col=1)\n\n    # Set equal aspect ratio for each subplot\n    layout_opts = {\n        \"title\": f\"{var_name} - XY, XZ, YZ Projections\",\n        \"template\": \"plotly_dark\",\n        \"xaxis\": {\"scaleanchor\": \"y\"},\n        \"xaxis2\": {\"scaleanchor\": \"y2\"},\n        \"xaxis3\": {\"scaleanchor\": \"y3\"},\n    }\n    # Move legend to bottom-right when using colorbar to avoid overlap\n    if velocity_var_name is not None:\n        layout_opts[\"legend\"] = {\n            \"orientation\": \"h\",\n            \"yanchor\": \"bottom\",\n            \"y\": -0.15,\n            \"xanchor\": \"center\",\n            \"x\": 0.5,\n        }\n    fig.update_layout(**layout_opts)\n\n    return fig\n</code></pre>"},{"location":"reference/plotting/#openscvx.plotting.plot_scp_iterations","title":"<code>plot_scp_iterations(result: OptimizationResults, state_names: list[str] | None = None, control_names: list[str] | None = None, cmap_name: str = 'viridis', show_propagation: bool = True)</code>","text":"<p>Plot all SCP iterations overlaid with colormap-based coloring.</p> <p>Shows the evolution of states and controls across SCP iterations. Early iterations are dark, later iterations are bright (following the colormap). This makes convergence visible at a glance.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>OptimizationResults</code> <p>Optimization results containing iteration history</p> required <code>state_names</code> <code>list[str] | None</code> <p>Optional list of state names to include. If None, plots all states.</p> <code>None</code> <code>control_names</code> <code>list[str] | None</code> <p>Optional list of control names to include. If None, plots all controls.</p> <code>None</code> <code>cmap_name</code> <code>str</code> <p>Matplotlib colormap name (default: \"viridis\")</p> <code>'viridis'</code> <code>show_propagation</code> <code>bool</code> <p>If True, show multi-shot propagation lines (default: True)</p> <code>True</code> <p>Returns:</p> Type Description <p>Plotly figure with all iterations overlaid</p> Example <p>results = problem.solve() plot_scp_iterations(results, [\"position\", \"velocity\"]).show()</p> Source code in <code>openscvx/plotting/scp_iteration.py</code> <pre><code>def plot_scp_iterations(\n    result: OptimizationResults,\n    state_names: list[str] | None = None,\n    control_names: list[str] | None = None,\n    cmap_name: str = \"viridis\",\n    show_propagation: bool = True,\n):\n    \"\"\"Plot all SCP iterations overlaid with colormap-based coloring.\n\n    Shows the evolution of states and controls across SCP iterations. Early\n    iterations are dark, later iterations are bright (following the colormap).\n    This makes convergence visible at a glance.\n\n    Args:\n        result: Optimization results containing iteration history\n        state_names: Optional list of state names to include. If None, plots all states.\n        control_names: Optional list of control names to include. If None, plots all controls.\n        cmap_name: Matplotlib colormap name (default: \"viridis\")\n        show_propagation: If True, show multi-shot propagation lines (default: True)\n\n    Returns:\n        Plotly figure with all iterations overlaid\n\n    Example:\n        &gt;&gt;&gt; results = problem.solve()\n        &gt;&gt;&gt; plot_scp_iterations(results, [\"position\", \"velocity\"]).show()\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    if not result.X:\n        raise ValueError(\"No iteration history available in result.X\")\n\n    # Derive dimensions from result data\n    n_x = result.X[0].shape[1]\n    n_u = result.U[0].shape[1]\n\n    # Find time slice by looking for \"time\" state\n    time_slice = None\n    for state in result._states:\n        if state.name.lower() == \"time\":\n            time_slice = state._slice\n            break\n\n    # Extract multi-shot propagation trajectories\n    V_history = result.discretization_history if result.discretization_history else []\n    X_prop_history = []\n    if V_history and show_propagation:\n        i4 = n_x + n_x * n_x + 2 * n_x * n_u\n        for V in V_history:\n            pos_traj = []\n            for i_multi in range(V.shape[1]):\n                pos_traj.append(V[:, i_multi].reshape(-1, i4)[:, :n_x])\n            X_prop_history.append(np.array(pos_traj))\n\n    n_iterations = len(result.X)\n    if X_prop_history:\n        n_iterations = min(n_iterations, len(X_prop_history))\n\n    # Filter states and controls (exclude ctcs_aug and time)\n    states = [\n        s for s in result._states if \"ctcs_aug\" not in s.name.lower() and s.name.lower() != \"time\"\n    ]\n    controls = list(result._controls) if result._controls else []\n\n    state_filter = set(state_names) if state_names else None\n    control_filter = set(control_names) if control_names else None\n\n    if state_filter and control_filter is None:\n        controls = []\n    if control_filter and state_filter is None:\n        states = []\n    if state_filter:\n        states = [s for s in states if s.name in state_filter]\n        if not states:\n            available = {s.name for s in result._states if \"ctcs_aug\" not in s.name.lower()}\n            raise ValueError(\n                f\"No states matched filter {state_names}. Available: {sorted(available)}\"\n            )\n    if control_filter:\n        controls = [c for c in controls if c.name in control_filter]\n        if not controls:\n            available = {c.name for c in result._controls}\n            raise ValueError(\n                f\"No controls matched filter {control_names}. Available: {sorted(available)}\"\n            )\n\n    if not states and not controls:\n        raise ValueError(\"No states or controls to plot\")\n\n    # Expand multi-dimensional variables to individual components\n    def expand_variables(variables):\n        expanded = []\n        for var in variables:\n            s = var._slice\n            start = s.start if isinstance(s, slice) else s\n            stop = s.stop if isinstance(s, slice) else start + 1\n            n_comp = (stop or start + 1) - (start or 0)\n\n            for i in range(n_comp):\n                expanded.append(\n                    {\n                        \"name\": f\"{var.name}_{i}\" if n_comp &gt; 1 else var.name,\n                        \"idx\": start + i,\n                        \"parent\": var.name,\n                        \"comp\": i,\n                    }\n                )\n        return expanded\n\n    expanded_states = expand_variables(states)\n    expanded_controls = expand_variables(controls)\n\n    # Grid layout\n    n_states = len(expanded_states)\n    n_controls = len(expanded_controls)\n    n_state_cols = min(7, n_states) if n_states &gt; 0 else 1\n    n_control_cols = min(3, n_controls) if n_controls &gt; 0 else 1\n    n_state_rows = (n_states + n_state_cols - 1) // n_state_cols if n_states &gt; 0 else 0\n    n_control_rows = (n_controls + n_control_cols - 1) // n_control_cols if n_controls &gt; 0 else 0\n    total_rows = n_state_rows + n_control_rows\n    max_cols = max(n_state_cols, n_control_cols)\n\n    subplot_titles = [s[\"name\"] for s in expanded_states] + [c[\"name\"] for c in expanded_controls]\n    fig = make_subplots(\n        rows=total_rows,\n        cols=max_cols,\n        subplot_titles=subplot_titles,\n        vertical_spacing=0.08,\n        horizontal_spacing=0.05,\n    )\n\n    # Get colormap\n    cmap = plt.get_cmap(cmap_name)\n\n    def iter_color(iter_idx):\n        rgba = cmap(iter_idx / max(n_iterations - 1, 1))\n        return f\"rgb({int(rgba[0] * 255)},{int(rgba[1] * 255)},{int(rgba[2] * 255)})\"\n\n    # Plot all iterations\n    for iter_idx in range(n_iterations):\n        X_nodes = result.X[iter_idx]\n        U_iter = result.U[iter_idx]\n        color = iter_color(iter_idx)\n        legend_group = f\"iter_{iter_idx}\"\n        show_legend_for_iter = True  # Show legend for first trace of this iteration\n\n        t_nodes = (\n            X_nodes[:, time_slice].flatten()\n            if time_slice is not None\n            else np.linspace(0, result.t_final, X_nodes.shape[0])\n        )\n\n        # States\n        for state_idx, state in enumerate(expanded_states):\n            row = (state_idx // n_state_cols) + 1\n            col = (state_idx % n_state_cols) + 1\n            idx = state[\"idx\"]\n\n            # Multi-shot propagation lines\n            if X_prop_history and iter_idx &lt; len(X_prop_history):\n                pos_traj = X_prop_history[iter_idx]\n                for j in range(pos_traj.shape[1]):\n                    segment_times = pos_traj[:, j, time_slice].flatten()\n                    segment_states = pos_traj[:, j, idx]\n                    fig.add_trace(\n                        go.Scatter(\n                            x=segment_times,\n                            y=segment_states,\n                            mode=\"lines\",\n                            line={\"color\": color, \"width\": 1.5},\n                            legendgroup=legend_group,\n                            showlegend=show_legend_for_iter,\n                            name=f\"Iter {iter_idx}\" if show_legend_for_iter else None,\n                            hoverinfo=\"skip\",\n                        ),\n                        row=row,\n                        col=col,\n                    )\n                    show_legend_for_iter = False\n\n            # Nodes\n            fig.add_trace(\n                go.Scatter(\n                    x=t_nodes,\n                    y=X_nodes[:, idx],\n                    mode=\"markers\",\n                    marker={\"color\": color, \"size\": 5},\n                    legendgroup=legend_group,\n                    showlegend=show_legend_for_iter,\n                    name=f\"Iter {iter_idx}\" if show_legend_for_iter else None,\n                    hovertemplate=f\"iter {iter_idx}&lt;br&gt;t=%{{x:.2f}}&lt;br&gt;y=%{{y:.3g}}&lt;extra&gt;&lt;/extra&gt;\",\n                ),\n                row=row,\n                col=col,\n            )\n            show_legend_for_iter = False\n\n        # Controls\n        for control_idx, control in enumerate(expanded_controls):\n            row = n_state_rows + (control_idx // n_control_cols) + 1\n            col = (control_idx % n_control_cols) + 1\n            idx = control[\"idx\"]\n\n            fig.add_trace(\n                go.Scatter(\n                    x=t_nodes,\n                    y=U_iter[:, idx],\n                    mode=\"markers\",\n                    marker={\"color\": color, \"size\": 5},\n                    legendgroup=legend_group,\n                    showlegend=show_legend_for_iter,\n                    name=f\"Iter {iter_idx}\" if show_legend_for_iter else None,\n                    hovertemplate=f\"iter {iter_idx}&lt;br&gt;t=%{{x:.2f}}&lt;br&gt;y=%{{y:.3g}}&lt;extra&gt;&lt;/extra&gt;\",\n                ),\n                row=row,\n                col=col,\n            )\n            show_legend_for_iter = False\n\n    # Add bounds (once, using final iteration's time range)\n    t_nodes_final = (\n        result.X[-1][:, time_slice].flatten()\n        if time_slice is not None\n        else np.linspace(0, result.t_final, result.X[-1].shape[0])\n    )\n    t_min, t_max = t_nodes_final.min(), t_nodes_final.max()\n\n    for state_idx, state in enumerate(expanded_states):\n        row = (state_idx // n_state_cols) + 1\n        col = (state_idx % n_state_cols) + 1\n        parent = _get_var(result, state[\"parent\"], result._states)\n        comp_idx = state[\"comp\"]\n\n        for bound_val, bound_attr in [(parent.min, \"min\"), (parent.max, \"max\")]:\n            if bound_val is not None and np.isfinite(bound_val[comp_idx]):\n                fig.add_trace(\n                    go.Scatter(\n                        x=[t_min, t_max],\n                        y=[bound_val[comp_idx], bound_val[comp_idx]],\n                        mode=\"lines\",\n                        line={\"color\": \"red\", \"width\": 1.5, \"dash\": \"dot\"},\n                        showlegend=False,\n                        hoverinfo=\"skip\",\n                    ),\n                    row=row,\n                    col=col,\n                )\n\n    for control_idx, control in enumerate(expanded_controls):\n        row = n_state_rows + (control_idx // n_control_cols) + 1\n        col = (control_idx % n_control_cols) + 1\n        parent = _get_var(result, control[\"parent\"], result._controls)\n        comp_idx = control[\"comp\"]\n\n        for bound_val in [parent.min, parent.max]:\n            if bound_val is not None and np.isfinite(bound_val[comp_idx]):\n                fig.add_trace(\n                    go.Scatter(\n                        x=[t_min, t_max],\n                        y=[bound_val[comp_idx], bound_val[comp_idx]],\n                        mode=\"lines\",\n                        line={\"color\": \"red\", \"width\": 1.5, \"dash\": \"dot\"},\n                        showlegend=False,\n                        hoverinfo=\"skip\",\n                    ),\n                    row=row,\n                    col=col,\n                )\n\n    # Layout\n    fig.update_layout(\n        title_text=\"SCP Iterations\",\n        template=\"plotly_dark\",\n        showlegend=True,\n        legend={\n            \"title\": \"Iterations\",\n            \"yanchor\": \"top\",\n            \"y\": 0.99,\n            \"xanchor\": \"left\",\n            \"x\": 1.02,\n            \"bgcolor\": \"rgba(0, 0, 0, 0.5)\",\n            \"itemclick\": \"toggle\",\n            \"itemdoubleclick\": \"toggleothers\",\n        },\n    )\n\n    for col_idx in range(1, max_cols + 1):\n        fig.update_xaxes(title_text=\"Time (s)\", row=total_rows, col=col_idx)\n\n    return fig\n</code></pre>"},{"location":"reference/plotting/#openscvx.plotting.plot_state_component","title":"<code>plot_state_component(result: OptimizationResults, state_name: str, component: int = 0) -&gt; go.Figure</code>","text":"<p>Plot a single component of a state variable vs time.</p> <p>This is the low-level function for plotting one scalar value over time. For plotting all components of a state, use plot_states().</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>OptimizationResults</code> <p>Optimization results containing state trajectories</p> required <code>state_name</code> <code>str</code> <p>Name of the state variable</p> required <code>component</code> <code>int</code> <p>Component index (0-indexed). For scalar states, use 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly figure with single plot</p> Example <p>plot_state_component(result, \"position\", 2)  # Plot z-component</p> Source code in <code>openscvx/plotting/plotting.py</code> <pre><code>def plot_state_component(\n    result: OptimizationResults,\n    state_name: str,\n    component: int = 0,\n) -&gt; go.Figure:\n    \"\"\"Plot a single component of a state variable vs time.\n\n    This is the low-level function for plotting one scalar value over time.\n    For plotting all components of a state, use plot_states().\n\n    Args:\n        result: Optimization results containing state trajectories\n        state_name: Name of the state variable\n        component: Component index (0-indexed). For scalar states, use 0.\n\n    Returns:\n        Plotly figure with single plot\n\n    Example:\n        &gt;&gt;&gt; plot_state_component(result, \"position\", 2)  # Plot z-component\n    \"\"\"\n    available = {s.name for s in result._states}\n    if state_name not in available:\n        raise ValueError(f\"State '{state_name}' not found. Available: {sorted(available)}\")\n\n    dim = _get_var_dim(result, state_name, result._states)\n    if component &lt; 0 or component &gt;= dim:\n        raise ValueError(f\"Component {component} out of range for '{state_name}' (dim={dim})\")\n\n    t_nodes = result.nodes[\"time\"].flatten()\n    has_trajectory = bool(result.trajectory) and state_name in result.trajectory\n    t_full = result.trajectory[\"time\"].flatten() if has_trajectory else None\n\n    label = f\"{state_name}_{component}\" if dim &gt; 1 else state_name\n\n    fig = go.Figure()\n    fig.update_layout(title_text=label, template=\"plotly_dark\")\n\n    if has_trajectory:\n        data = result.trajectory[state_name]\n        y = data if data.ndim == 1 else data[:, component]\n        fig.add_trace(\n            go.Scatter(\n                x=t_full,\n                y=y,\n                mode=\"lines\",\n                name=\"Trajectory\",\n                line={\"color\": \"green\", \"width\": 2},\n            )\n        )\n\n    if state_name in result.nodes:\n        data = result.nodes[state_name]\n        y = data if data.ndim == 1 else data[:, component]\n        fig.add_trace(\n            go.Scatter(\n                x=t_nodes,\n                y=y,\n                mode=\"markers\",\n                name=\"Nodes\",\n                marker={\"color\": \"cyan\", \"size\": 6},\n            )\n        )\n\n    fig.update_xaxes(title_text=\"Time (s)\")\n    fig.update_yaxes(title_text=label)\n    return fig\n</code></pre>"},{"location":"reference/plotting/#openscvx.plotting.plot_states","title":"<code>plot_states(result: OptimizationResults, state_names: list[str] | None = None, include_private: bool = False, cols: int = 4) -&gt; go.Figure</code>","text":"<p>Plot state variables in a subplot grid.</p> <p>Each component of each state gets its own subplot with individual y-axis scaling. This is the primary function for visualizing state trajectories.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>OptimizationResults</code> <p>Optimization results containing state trajectories</p> required <code>state_names</code> <code>list[str] | None</code> <p>List of state names to plot. If None, plots all states.</p> <code>None</code> <code>include_private</code> <code>bool</code> <p>Whether to include private states (names starting with '_')</p> <code>False</code> <code>cols</code> <code>int</code> <p>Maximum number of columns in subplot grid</p> <code>4</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly figure with subplot grid</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; plot_states(result, [\"position\"])  # 3 subplots for x, y, z\n&gt;&gt;&gt; plot_states(result, [\"position\", \"velocity\"])  # 6 subplots\n&gt;&gt;&gt; plot_states(result)  # All states\n</code></pre> Source code in <code>openscvx/plotting/plotting.py</code> <pre><code>def plot_states(\n    result: OptimizationResults,\n    state_names: list[str] | None = None,\n    include_private: bool = False,\n    cols: int = 4,\n) -&gt; go.Figure:\n    \"\"\"Plot state variables in a subplot grid.\n\n    Each component of each state gets its own subplot with individual y-axis\n    scaling. This is the primary function for visualizing state trajectories.\n\n    Args:\n        result: Optimization results containing state trajectories\n        state_names: List of state names to plot. If None, plots all states.\n        include_private: Whether to include private states (names starting with '_')\n        cols: Maximum number of columns in subplot grid\n\n    Returns:\n        Plotly figure with subplot grid\n\n    Examples:\n        &gt;&gt;&gt; plot_states(result, [\"position\"])  # 3 subplots for x, y, z\n        &gt;&gt;&gt; plot_states(result, [\"position\", \"velocity\"])  # 6 subplots\n        &gt;&gt;&gt; plot_states(result)  # All states\n    \"\"\"\n\n    states = result._states\n    if not include_private:\n        states = [s for s in states if not s.name.startswith(\"_\")]\n\n    if state_names is not None:\n        available = {s.name for s in states}\n        missing = set(state_names) - available\n        if missing:\n            raise ValueError(f\"States not found in result: {missing}\")\n        # Preserve order from state_names\n        state_order = {name: i for i, name in enumerate(state_names)}\n        states = sorted(\n            [s for s in states if s.name in state_names],\n            key=lambda s: state_order[s.name],\n        )\n\n    # Build list of (display_name, var_name, component_idx)\n    components = []\n    for s in states:\n        dim = _get_var_dim(result, s.name, result._states)\n        if dim == 1:\n            components.append((s.name, s.name, 0))\n        else:\n            for i in range(dim):\n                components.append((f\"{s.name}_{i}\", s.name, i))\n\n    if not components:\n        raise ValueError(\"No state components to plot\")\n\n    n_cols = min(cols, len(components))\n    n_rows = (len(components) + n_cols - 1) // n_cols\n\n    fig = make_subplots(rows=n_rows, cols=n_cols, subplot_titles=[c[0] for c in components])\n    fig.update_layout(title_text=\"State Trajectories\", template=\"plotly_dark\")\n\n    for idx, (_, var_name, comp_idx) in enumerate(components):\n        row = (idx // n_cols) + 1\n        col = (idx % n_cols) + 1\n\n        # Get bounds for this component\n        var = _get_var(result, var_name, result._states)\n        min_val = var.min[comp_idx] if var.min is not None else None\n        max_val = var.max[comp_idx] if var.max is not None else None\n\n        _add_component_traces(\n            fig,\n            result,\n            var_name,\n            comp_idx,\n            row,\n            col,\n            show_legend=(idx == 0),\n            min_val=min_val,\n            max_val=max_val,\n        )\n\n    # Add x-axis labels to bottom row\n    for col_idx in range(1, n_cols + 1):\n        fig.update_xaxes(title_text=\"Time (s)\", row=n_rows, col=col_idx)\n\n    return fig\n</code></pre>"},{"location":"reference/plotting/#openscvx.plotting.plot_trust_region_heatmap","title":"<code>plot_trust_region_heatmap(result: OptimizationResults)</code>","text":"<p>Plot heatmap of the final trust-region deltas (TR_history[-1]).</p> Source code in <code>openscvx/plotting/plotting.py</code> <pre><code>def plot_trust_region_heatmap(result: OptimizationResults):\n    \"\"\"Plot heatmap of the final trust-region deltas (TR_history[-1]).\"\"\"\n    if not result.TR_history:\n        raise ValueError(\"Result has no TR_history to plot\")\n\n    tr_mat = result.TR_history[-1]\n\n    # Build variable names list\n    var_names = []\n    for var_list in [result._states, result._controls]:\n        for var in var_list:\n            dim = _get_var_dim(result, var.name, var_list)\n            if dim == 1:\n                var_names.append(var.name)\n            else:\n                var_names.extend(f\"{var.name}_{i}\" for i in range(dim))\n\n    # TR matrix is (n_states+n_controls, n_nodes): rows = variables, cols = nodes\n    if tr_mat.shape[0] == len(var_names):\n        z = tr_mat\n    elif tr_mat.shape[1] == len(var_names):\n        z = tr_mat.T\n    else:\n        raise ValueError(\"TR matrix dimensions do not align with state/control components\")\n\n    x_len = z.shape[1]\n    t_nodes = result.nodes[\"time\"].flatten()\n    x_labels = t_nodes if len(t_nodes) == x_len else list(range(x_len))\n\n    fig = go.Figure(data=go.Heatmap(z=z, x=x_labels, y=var_names, colorscale=\"Viridis\"))\n    fig.update_layout(\n        title=\"Trust Region Delta Magnitudes (last iteration)\", template=\"plotly_dark\"\n    )\n    fig.update_xaxes(title_text=\"Node / Time\", side=\"bottom\")\n    fig.update_yaxes(title_text=\"State / Control component\", side=\"left\")\n    return fig\n</code></pre>"},{"location":"reference/plotting/#openscvx.plotting.plot_vector_norm","title":"<code>plot_vector_norm(result: OptimizationResults, var_name: str, bounds: tuple[float, float] | None = None)</code>","text":"<p>Plot the 2-norm of a vector variable over time.</p> <p>Useful for visualizing thrust magnitude, velocity magnitude, etc.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>OptimizationResults</code> <p>Optimization results containing trajectories</p> required <code>var_name</code> <code>str</code> <p>Name of the vector variable (state or control)</p> required <code>bounds</code> <code>tuple[float, float] | None</code> <p>Optional (min, max) bounds to show as horizontal dashed lines</p> <code>None</code> <p>Returns:</p> Type Description <p>Plotly figure</p> Source code in <code>openscvx/plotting/plotting.py</code> <pre><code>def plot_vector_norm(\n    result: OptimizationResults,\n    var_name: str,\n    bounds: tuple[float, float] | None = None,\n):\n    \"\"\"Plot the 2-norm of a vector variable over time.\n\n    Useful for visualizing thrust magnitude, velocity magnitude, etc.\n\n    Args:\n        result: Optimization results containing trajectories\n        var_name: Name of the vector variable (state or control)\n        bounds: Optional (min, max) bounds to show as horizontal dashed lines\n\n    Returns:\n        Plotly figure\n    \"\"\"\n    import numpy as np\n\n    has_trajectory = bool(result.trajectory) and var_name in result.trajectory\n    has_nodes = var_name in result.nodes\n\n    if not has_trajectory and not has_nodes:\n        available_traj = set(result.trajectory.keys()) if result.trajectory else set()\n        available_nodes = set(result.nodes.keys())\n        raise ValueError(\n            f\"Variable '{var_name}' not found. \"\n            f\"Available in trajectory: {sorted(available_traj)}, nodes: {sorted(available_nodes)}\"\n        )\n\n    fig = go.Figure()\n\n    # Plot trajectory norm if available\n    if has_trajectory:\n        t_full = result.trajectory[\"time\"].flatten()\n        data = result.trajectory[var_name]\n        norm = np.linalg.norm(data, axis=1)\n        fig.add_trace(\n            go.Scatter(\n                x=t_full,\n                y=norm,\n                mode=\"lines\",\n                line={\"color\": \"green\", \"width\": 2},\n                name=\"Trajectory\",\n                legendgroup=\"trajectory\",\n            )\n        )\n\n    # Plot node norms if available\n    if has_nodes:\n        t_nodes = result.nodes[\"time\"].flatten()\n        data = result.nodes[var_name]\n        norm = np.linalg.norm(data, axis=1)\n        fig.add_trace(\n            go.Scatter(\n                x=t_nodes,\n                y=norm,\n                mode=\"markers\",\n                marker={\"color\": \"cyan\", \"size\": 6},\n                name=\"Nodes\",\n                legendgroup=\"nodes\",\n            )\n        )\n\n    # Add bounds if provided\n    if bounds is not None:\n        min_bound, max_bound = bounds\n        fig.add_hline(\n            y=min_bound,\n            line={\"color\": \"red\", \"width\": 2, \"dash\": \"dash\"},\n            annotation_text=\"Min\",\n            annotation_position=\"right\",\n        )\n        fig.add_hline(\n            y=max_bound,\n            line={\"color\": \"red\", \"width\": 2, \"dash\": \"dash\"},\n            annotation_text=\"Max\",\n            annotation_position=\"right\",\n        )\n\n    fig.update_layout(\n        title=f\"\u2016{var_name}\u2016\u2082\",\n        xaxis_title=\"Time (s)\",\n        yaxis_title=\"Norm\",\n        template=\"plotly_dark\",\n    )\n\n    return fig\n</code></pre>"},{"location":"reference/plotting/#openscvx.plotting.plot_virtual_control_heatmap","title":"<code>plot_virtual_control_heatmap(result: OptimizationResults)</code>","text":"<p>Plot heatmap of the final virtual control magnitudes (VC_history[-1]).</p> Source code in <code>openscvx/plotting/plotting.py</code> <pre><code>def plot_virtual_control_heatmap(result: OptimizationResults):\n    \"\"\"Plot heatmap of the final virtual control magnitudes (VC_history[-1]).\"\"\"\n    if not result.VC_history:\n        raise ValueError(\"Result has no VC_history to plot\")\n\n    vc_mat = result.VC_history[-1]\n\n    # Build state names list\n    state_names = []\n    for var in result._states:\n        dim = _get_var_dim(result, var.name, result._states)\n        if dim == 1:\n            state_names.append(var.name)\n        else:\n            state_names.extend(f\"{var.name}_{i}\" for i in range(dim))\n\n    # Align so rows = states, cols = nodes\n    if vc_mat.shape[1] == len(state_names):\n        z = vc_mat.T\n    elif vc_mat.shape[0] == len(state_names):\n        z = vc_mat\n    else:\n        raise ValueError(\"VC matrix shape does not align with state components\")\n\n    x_len = z.shape[1]\n    t_nodes = result.nodes[\"time\"].flatten()\n\n    # Virtual control uses N-1 intervals\n    if len(t_nodes) == x_len + 1:\n        x_labels = t_nodes[:-1]\n    elif len(t_nodes) == x_len:\n        x_labels = t_nodes\n    else:\n        x_labels = list(range(x_len))\n\n    fig = go.Figure(data=go.Heatmap(z=z, x=x_labels, y=state_names, colorscale=\"Magma\"))\n    fig.update_layout(title=\"Virtual Control Magnitudes (last iteration)\", template=\"plotly_dark\")\n    fig.update_xaxes(title_text=\"Node Interval (N-1)\")\n    fig.update_yaxes(title_text=\"State component\")\n    return fig\n</code></pre>"},{"location":"reference/plotting/plotting/","title":"plotting","text":""},{"location":"reference/plotting/plotting/#openscvx.plotting.plotting.plot_control_component","title":"<code>plot_control_component(result: OptimizationResults, control_name: str, component: int = 0) -&gt; go.Figure</code>","text":"<p>Plot a single component of a control variable vs time.</p> <p>This is the low-level function for plotting one scalar control over time. For plotting all components of a control, use plot_controls().</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>OptimizationResults</code> <p>Optimization results containing control trajectories</p> required <code>control_name</code> <code>str</code> <p>Name of the control variable</p> required <code>component</code> <code>int</code> <p>Component index (0-indexed). For scalar controls, use 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly figure with single plot</p> Example <p>plot_control_component(result, \"thrust\", 0)  # Plot thrust_x</p> Source code in <code>openscvx/plotting/plotting.py</code> <pre><code>def plot_control_component(\n    result: OptimizationResults,\n    control_name: str,\n    component: int = 0,\n) -&gt; go.Figure:\n    \"\"\"Plot a single component of a control variable vs time.\n\n    This is the low-level function for plotting one scalar control over time.\n    For plotting all components of a control, use plot_controls().\n\n    Args:\n        result: Optimization results containing control trajectories\n        control_name: Name of the control variable\n        component: Component index (0-indexed). For scalar controls, use 0.\n\n    Returns:\n        Plotly figure with single plot\n\n    Example:\n        &gt;&gt;&gt; plot_control_component(result, \"thrust\", 0)  # Plot thrust_x\n    \"\"\"\n    available = {c.name for c in result._controls}\n    if control_name not in available:\n        raise ValueError(f\"Control '{control_name}' not found. Available: {sorted(available)}\")\n\n    dim = _get_var_dim(result, control_name, result._controls)\n    if component &lt; 0 or component &gt;= dim:\n        raise ValueError(f\"Component {component} out of range for '{control_name}' (dim={dim})\")\n\n    t_nodes = result.nodes[\"time\"].flatten()\n    has_trajectory = bool(result.trajectory) and control_name in result.trajectory\n    t_full = result.trajectory[\"time\"].flatten() if has_trajectory else None\n\n    label = f\"{control_name}_{component}\" if dim &gt; 1 else control_name\n\n    fig = go.Figure()\n    fig.update_layout(title_text=label, template=\"plotly_dark\")\n\n    if has_trajectory:\n        data = result.trajectory[control_name]\n        y = data if data.ndim == 1 else data[:, component]\n        fig.add_trace(\n            go.Scatter(\n                x=t_full,\n                y=y,\n                mode=\"lines\",\n                name=\"Trajectory\",\n                line={\"color\": \"green\", \"width\": 2},\n            )\n        )\n\n    if control_name in result.nodes:\n        data = result.nodes[control_name]\n        y = data if data.ndim == 1 else data[:, component]\n        fig.add_trace(\n            go.Scatter(\n                x=t_nodes,\n                y=y,\n                mode=\"markers\",\n                name=\"Nodes\",\n                marker={\"color\": \"cyan\", \"size\": 6},\n            )\n        )\n\n    fig.update_xaxes(title_text=\"Time (s)\")\n    fig.update_yaxes(title_text=label)\n    return fig\n</code></pre>"},{"location":"reference/plotting/plotting/#openscvx.plotting.plotting.plot_controls","title":"<code>plot_controls(result: OptimizationResults, control_names: list[str] | None = None, include_private: bool = False, cols: int = 3) -&gt; go.Figure</code>","text":"<p>Plot control variables in a subplot grid.</p> <p>Each component of each control gets its own subplot with individual y-axis scaling. This is the primary function for visualizing control trajectories.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>OptimizationResults</code> <p>Optimization results containing control trajectories</p> required <code>control_names</code> <code>list[str] | None</code> <p>List of control names to plot. If None, plots all controls.</p> <code>None</code> <code>include_private</code> <code>bool</code> <p>Whether to include private controls (names starting with '_')</p> <code>False</code> <code>cols</code> <code>int</code> <p>Maximum number of columns in subplot grid</p> <code>3</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly figure with subplot grid</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; plot_controls(result, [\"thrust\"])  # 3 subplots for x, y, z\n&gt;&gt;&gt; plot_controls(result)  # All controls\n</code></pre> Source code in <code>openscvx/plotting/plotting.py</code> <pre><code>def plot_controls(\n    result: OptimizationResults,\n    control_names: list[str] | None = None,\n    include_private: bool = False,\n    cols: int = 3,\n) -&gt; go.Figure:\n    \"\"\"Plot control variables in a subplot grid.\n\n    Each component of each control gets its own subplot with individual y-axis\n    scaling. This is the primary function for visualizing control trajectories.\n\n    Args:\n        result: Optimization results containing control trajectories\n        control_names: List of control names to plot. If None, plots all controls.\n        include_private: Whether to include private controls (names starting with '_')\n        cols: Maximum number of columns in subplot grid\n\n    Returns:\n        Plotly figure with subplot grid\n\n    Examples:\n        &gt;&gt;&gt; plot_controls(result, [\"thrust\"])  # 3 subplots for x, y, z\n        &gt;&gt;&gt; plot_controls(result)  # All controls\n    \"\"\"\n\n    controls = result._controls\n    if not include_private:\n        controls = [c for c in controls if not c.name.startswith(\"_\")]\n\n    if control_names is not None:\n        available = {c.name for c in controls}\n        missing = set(control_names) - available\n        if missing:\n            raise ValueError(f\"Controls not found in result: {missing}\")\n        # Preserve order from control_names\n        control_order = {name: i for i, name in enumerate(control_names)}\n        controls = sorted(\n            [c for c in controls if c.name in control_names],\n            key=lambda c: control_order[c.name],\n        )\n\n    # Build list of (display_name, var_name, component_idx)\n    components = []\n    for c in controls:\n        dim = _get_var_dim(result, c.name, result._controls)\n        if dim == 1:\n            components.append((c.name, c.name, 0))\n        else:\n            for i in range(dim):\n                components.append((f\"{c.name}_{i}\", c.name, i))\n\n    if not components:\n        raise ValueError(\"No control components to plot\")\n\n    n_cols = min(cols, len(components))\n    n_rows = (len(components) + n_cols - 1) // n_cols\n\n    fig = make_subplots(rows=n_rows, cols=n_cols, subplot_titles=[c[0] for c in components])\n    fig.update_layout(title_text=\"Control Trajectories\", template=\"plotly_dark\")\n\n    for idx, (_, var_name, comp_idx) in enumerate(components):\n        row = (idx // n_cols) + 1\n        col = (idx % n_cols) + 1\n\n        # Get bounds for this component\n        var = _get_var(result, var_name, result._controls)\n        min_val = var.min[comp_idx] if var.min is not None else None\n        max_val = var.max[comp_idx] if var.max is not None else None\n\n        _add_component_traces(\n            fig,\n            result,\n            var_name,\n            comp_idx,\n            row,\n            col,\n            show_legend=(idx == 0),\n            min_val=min_val,\n            max_val=max_val,\n        )\n\n    # Add x-axis labels to bottom row\n    for col_idx in range(1, n_cols + 1):\n        fig.update_xaxes(title_text=\"Time (s)\", row=n_rows, col=col_idx)\n\n    return fig\n</code></pre>"},{"location":"reference/plotting/plotting/#openscvx.plotting.plotting.plot_projections_2d","title":"<code>plot_projections_2d(result: OptimizationResults, var_name: str = 'position', velocity_var_name: str | None = None, cmap: str = 'viridis')</code>","text":"<p>Plot XY, XZ, YZ projections of a 3D variable.</p> <p>Useful for visualizing 3D trajectories in 2D plane views.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>OptimizationResults</code> <p>Optimization results containing trajectories</p> required <code>var_name</code> <code>str</code> <p>Name of the 3D variable to plot (default: \"position\")</p> <code>'position'</code> <code>velocity_var_name</code> <code>str | None</code> <p>Optional name of velocity variable for coloring by speed. If provided, trajectory points are colored by velocity magnitude.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap name for velocity coloring (default: \"viridis\")</p> <code>'viridis'</code> <p>Returns:</p> Type Description <p>Plotly figure with three subplots (XY, XZ, YZ planes)</p> Source code in <code>openscvx/plotting/plotting.py</code> <pre><code>def plot_projections_2d(\n    result: OptimizationResults,\n    var_name: str = \"position\",\n    velocity_var_name: str | None = None,\n    cmap: str = \"viridis\",\n):\n    \"\"\"Plot XY, XZ, YZ projections of a 3D variable.\n\n    Useful for visualizing 3D trajectories in 2D plane views.\n\n    Args:\n        result: Optimization results containing trajectories\n        var_name: Name of the 3D variable to plot (default: \"position\")\n        velocity_var_name: Optional name of velocity variable for coloring by speed.\n            If provided, trajectory points are colored by velocity magnitude.\n        cmap: Matplotlib colormap name for velocity coloring (default: \"viridis\")\n\n    Returns:\n        Plotly figure with three subplots (XY, XZ, YZ planes)\n    \"\"\"\n    import numpy as np\n\n    has_trajectory = bool(result.trajectory) and var_name in result.trajectory\n    has_nodes = var_name in result.nodes\n\n    if not has_trajectory and not has_nodes:\n        available_traj = set(result.trajectory.keys()) if result.trajectory else set()\n        available_nodes = set(result.nodes.keys())\n        raise ValueError(\n            f\"Variable '{var_name}' not found. \"\n            f\"Available in trajectory: {sorted(available_traj)}, nodes: {sorted(available_nodes)}\"\n        )\n\n    fig = make_subplots(\n        rows=2,\n        cols=2,\n        subplot_titles=(\"XY Plane\", \"XZ Plane\", \"YZ Plane\"),\n        specs=[[{}, {}], [{}, None]],\n    )\n\n    # Subplot positions: (x_idx, y_idx, row, col)\n    subplots = [(0, 1, 1, 1), (0, 2, 1, 2), (1, 2, 2, 1)]\n\n    # Compute velocity norms if velocity variable is provided\n    traj_vel_norm = None\n    node_vel_norm = None\n    if velocity_var_name is not None:\n        if has_trajectory and velocity_var_name in result.trajectory:\n            traj_vel_norm = np.linalg.norm(result.trajectory[velocity_var_name], axis=1)\n        if has_nodes and velocity_var_name in result.nodes:\n            node_vel_norm = np.linalg.norm(result.nodes[velocity_var_name], axis=1)\n\n    # Colorbar config (only shown once)\n    colorbar_cfg = {\"title\": \"\u2016velocity\u2016\", \"x\": 1.02, \"y\": 0.5, \"len\": 0.9}\n\n    # Plot trajectory if available\n    if has_trajectory:\n        data = result.trajectory[var_name]\n        for i, (xi, yi, row, col) in enumerate(subplots):\n            if traj_vel_norm is not None:\n                marker = {\n                    \"size\": 4,\n                    \"color\": traj_vel_norm,\n                    \"colorscale\": cmap,\n                    \"showscale\": (i == 0),\n                    \"colorbar\": colorbar_cfg if i == 0 else None,\n                }\n                fig.add_trace(\n                    go.Scatter(\n                        x=data[:, xi],\n                        y=data[:, yi],\n                        mode=\"markers\",\n                        marker=marker,\n                        name=\"Trajectory\",\n                        legendgroup=\"trajectory\",\n                        showlegend=(i == 0),\n                    ),\n                    row=row,\n                    col=col,\n                )\n            else:\n                fig.add_trace(\n                    go.Scatter(\n                        x=data[:, xi],\n                        y=data[:, yi],\n                        mode=\"lines\",\n                        line={\"color\": \"green\", \"width\": 2},\n                        name=\"Trajectory\",\n                        legendgroup=\"trajectory\",\n                        showlegend=(i == 0),\n                    ),\n                    row=row,\n                    col=col,\n                )\n\n    # Plot nodes if available\n    if has_nodes:\n        data = result.nodes[var_name]\n        # Only show colorbar on nodes if trajectory doesn't have one\n        show_node_colorbar = (traj_vel_norm is None) and (node_vel_norm is not None)\n        for i, (xi, yi, row, col) in enumerate(subplots):\n            if node_vel_norm is not None:\n                marker = {\n                    \"size\": 8,\n                    \"color\": node_vel_norm,\n                    \"colorscale\": cmap,\n                    \"showscale\": show_node_colorbar and (i == 0),\n                    \"colorbar\": colorbar_cfg if (show_node_colorbar and i == 0) else None,\n                    \"line\": {\"color\": \"white\", \"width\": 1},\n                }\n            else:\n                marker = {\"color\": \"cyan\", \"size\": 6}\n            fig.add_trace(\n                go.Scatter(\n                    x=data[:, xi],\n                    y=data[:, yi],\n                    mode=\"markers\",\n                    marker=marker,\n                    name=\"Nodes\",\n                    legendgroup=\"nodes\",\n                    showlegend=(i == 0),\n                ),\n                row=row,\n                col=col,\n            )\n\n    # Set axis titles\n    fig.update_xaxes(title_text=\"X\", row=1, col=1)\n    fig.update_yaxes(title_text=\"Y\", row=1, col=1)\n    fig.update_xaxes(title_text=\"X\", row=1, col=2)\n    fig.update_yaxes(title_text=\"Z\", row=1, col=2)\n    fig.update_xaxes(title_text=\"Y\", row=2, col=1)\n    fig.update_yaxes(title_text=\"Z\", row=2, col=1)\n\n    # Set equal aspect ratio for each subplot\n    layout_opts = {\n        \"title\": f\"{var_name} - XY, XZ, YZ Projections\",\n        \"template\": \"plotly_dark\",\n        \"xaxis\": {\"scaleanchor\": \"y\"},\n        \"xaxis2\": {\"scaleanchor\": \"y2\"},\n        \"xaxis3\": {\"scaleanchor\": \"y3\"},\n    }\n    # Move legend to bottom-right when using colorbar to avoid overlap\n    if velocity_var_name is not None:\n        layout_opts[\"legend\"] = {\n            \"orientation\": \"h\",\n            \"yanchor\": \"bottom\",\n            \"y\": -0.15,\n            \"xanchor\": \"center\",\n            \"x\": 0.5,\n        }\n    fig.update_layout(**layout_opts)\n\n    return fig\n</code></pre>"},{"location":"reference/plotting/plotting/#openscvx.plotting.plotting.plot_state_component","title":"<code>plot_state_component(result: OptimizationResults, state_name: str, component: int = 0) -&gt; go.Figure</code>","text":"<p>Plot a single component of a state variable vs time.</p> <p>This is the low-level function for plotting one scalar value over time. For plotting all components of a state, use plot_states().</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>OptimizationResults</code> <p>Optimization results containing state trajectories</p> required <code>state_name</code> <code>str</code> <p>Name of the state variable</p> required <code>component</code> <code>int</code> <p>Component index (0-indexed). For scalar states, use 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly figure with single plot</p> Example <p>plot_state_component(result, \"position\", 2)  # Plot z-component</p> Source code in <code>openscvx/plotting/plotting.py</code> <pre><code>def plot_state_component(\n    result: OptimizationResults,\n    state_name: str,\n    component: int = 0,\n) -&gt; go.Figure:\n    \"\"\"Plot a single component of a state variable vs time.\n\n    This is the low-level function for plotting one scalar value over time.\n    For plotting all components of a state, use plot_states().\n\n    Args:\n        result: Optimization results containing state trajectories\n        state_name: Name of the state variable\n        component: Component index (0-indexed). For scalar states, use 0.\n\n    Returns:\n        Plotly figure with single plot\n\n    Example:\n        &gt;&gt;&gt; plot_state_component(result, \"position\", 2)  # Plot z-component\n    \"\"\"\n    available = {s.name for s in result._states}\n    if state_name not in available:\n        raise ValueError(f\"State '{state_name}' not found. Available: {sorted(available)}\")\n\n    dim = _get_var_dim(result, state_name, result._states)\n    if component &lt; 0 or component &gt;= dim:\n        raise ValueError(f\"Component {component} out of range for '{state_name}' (dim={dim})\")\n\n    t_nodes = result.nodes[\"time\"].flatten()\n    has_trajectory = bool(result.trajectory) and state_name in result.trajectory\n    t_full = result.trajectory[\"time\"].flatten() if has_trajectory else None\n\n    label = f\"{state_name}_{component}\" if dim &gt; 1 else state_name\n\n    fig = go.Figure()\n    fig.update_layout(title_text=label, template=\"plotly_dark\")\n\n    if has_trajectory:\n        data = result.trajectory[state_name]\n        y = data if data.ndim == 1 else data[:, component]\n        fig.add_trace(\n            go.Scatter(\n                x=t_full,\n                y=y,\n                mode=\"lines\",\n                name=\"Trajectory\",\n                line={\"color\": \"green\", \"width\": 2},\n            )\n        )\n\n    if state_name in result.nodes:\n        data = result.nodes[state_name]\n        y = data if data.ndim == 1 else data[:, component]\n        fig.add_trace(\n            go.Scatter(\n                x=t_nodes,\n                y=y,\n                mode=\"markers\",\n                name=\"Nodes\",\n                marker={\"color\": \"cyan\", \"size\": 6},\n            )\n        )\n\n    fig.update_xaxes(title_text=\"Time (s)\")\n    fig.update_yaxes(title_text=label)\n    return fig\n</code></pre>"},{"location":"reference/plotting/plotting/#openscvx.plotting.plotting.plot_states","title":"<code>plot_states(result: OptimizationResults, state_names: list[str] | None = None, include_private: bool = False, cols: int = 4) -&gt; go.Figure</code>","text":"<p>Plot state variables in a subplot grid.</p> <p>Each component of each state gets its own subplot with individual y-axis scaling. This is the primary function for visualizing state trajectories.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>OptimizationResults</code> <p>Optimization results containing state trajectories</p> required <code>state_names</code> <code>list[str] | None</code> <p>List of state names to plot. If None, plots all states.</p> <code>None</code> <code>include_private</code> <code>bool</code> <p>Whether to include private states (names starting with '_')</p> <code>False</code> <code>cols</code> <code>int</code> <p>Maximum number of columns in subplot grid</p> <code>4</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly figure with subplot grid</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; plot_states(result, [\"position\"])  # 3 subplots for x, y, z\n&gt;&gt;&gt; plot_states(result, [\"position\", \"velocity\"])  # 6 subplots\n&gt;&gt;&gt; plot_states(result)  # All states\n</code></pre> Source code in <code>openscvx/plotting/plotting.py</code> <pre><code>def plot_states(\n    result: OptimizationResults,\n    state_names: list[str] | None = None,\n    include_private: bool = False,\n    cols: int = 4,\n) -&gt; go.Figure:\n    \"\"\"Plot state variables in a subplot grid.\n\n    Each component of each state gets its own subplot with individual y-axis\n    scaling. This is the primary function for visualizing state trajectories.\n\n    Args:\n        result: Optimization results containing state trajectories\n        state_names: List of state names to plot. If None, plots all states.\n        include_private: Whether to include private states (names starting with '_')\n        cols: Maximum number of columns in subplot grid\n\n    Returns:\n        Plotly figure with subplot grid\n\n    Examples:\n        &gt;&gt;&gt; plot_states(result, [\"position\"])  # 3 subplots for x, y, z\n        &gt;&gt;&gt; plot_states(result, [\"position\", \"velocity\"])  # 6 subplots\n        &gt;&gt;&gt; plot_states(result)  # All states\n    \"\"\"\n\n    states = result._states\n    if not include_private:\n        states = [s for s in states if not s.name.startswith(\"_\")]\n\n    if state_names is not None:\n        available = {s.name for s in states}\n        missing = set(state_names) - available\n        if missing:\n            raise ValueError(f\"States not found in result: {missing}\")\n        # Preserve order from state_names\n        state_order = {name: i for i, name in enumerate(state_names)}\n        states = sorted(\n            [s for s in states if s.name in state_names],\n            key=lambda s: state_order[s.name],\n        )\n\n    # Build list of (display_name, var_name, component_idx)\n    components = []\n    for s in states:\n        dim = _get_var_dim(result, s.name, result._states)\n        if dim == 1:\n            components.append((s.name, s.name, 0))\n        else:\n            for i in range(dim):\n                components.append((f\"{s.name}_{i}\", s.name, i))\n\n    if not components:\n        raise ValueError(\"No state components to plot\")\n\n    n_cols = min(cols, len(components))\n    n_rows = (len(components) + n_cols - 1) // n_cols\n\n    fig = make_subplots(rows=n_rows, cols=n_cols, subplot_titles=[c[0] for c in components])\n    fig.update_layout(title_text=\"State Trajectories\", template=\"plotly_dark\")\n\n    for idx, (_, var_name, comp_idx) in enumerate(components):\n        row = (idx // n_cols) + 1\n        col = (idx % n_cols) + 1\n\n        # Get bounds for this component\n        var = _get_var(result, var_name, result._states)\n        min_val = var.min[comp_idx] if var.min is not None else None\n        max_val = var.max[comp_idx] if var.max is not None else None\n\n        _add_component_traces(\n            fig,\n            result,\n            var_name,\n            comp_idx,\n            row,\n            col,\n            show_legend=(idx == 0),\n            min_val=min_val,\n            max_val=max_val,\n        )\n\n    # Add x-axis labels to bottom row\n    for col_idx in range(1, n_cols + 1):\n        fig.update_xaxes(title_text=\"Time (s)\", row=n_rows, col=col_idx)\n\n    return fig\n</code></pre>"},{"location":"reference/plotting/plotting/#openscvx.plotting.plotting.plot_trust_region_heatmap","title":"<code>plot_trust_region_heatmap(result: OptimizationResults)</code>","text":"<p>Plot heatmap of the final trust-region deltas (TR_history[-1]).</p> Source code in <code>openscvx/plotting/plotting.py</code> <pre><code>def plot_trust_region_heatmap(result: OptimizationResults):\n    \"\"\"Plot heatmap of the final trust-region deltas (TR_history[-1]).\"\"\"\n    if not result.TR_history:\n        raise ValueError(\"Result has no TR_history to plot\")\n\n    tr_mat = result.TR_history[-1]\n\n    # Build variable names list\n    var_names = []\n    for var_list in [result._states, result._controls]:\n        for var in var_list:\n            dim = _get_var_dim(result, var.name, var_list)\n            if dim == 1:\n                var_names.append(var.name)\n            else:\n                var_names.extend(f\"{var.name}_{i}\" for i in range(dim))\n\n    # TR matrix is (n_states+n_controls, n_nodes): rows = variables, cols = nodes\n    if tr_mat.shape[0] == len(var_names):\n        z = tr_mat\n    elif tr_mat.shape[1] == len(var_names):\n        z = tr_mat.T\n    else:\n        raise ValueError(\"TR matrix dimensions do not align with state/control components\")\n\n    x_len = z.shape[1]\n    t_nodes = result.nodes[\"time\"].flatten()\n    x_labels = t_nodes if len(t_nodes) == x_len else list(range(x_len))\n\n    fig = go.Figure(data=go.Heatmap(z=z, x=x_labels, y=var_names, colorscale=\"Viridis\"))\n    fig.update_layout(\n        title=\"Trust Region Delta Magnitudes (last iteration)\", template=\"plotly_dark\"\n    )\n    fig.update_xaxes(title_text=\"Node / Time\", side=\"bottom\")\n    fig.update_yaxes(title_text=\"State / Control component\", side=\"left\")\n    return fig\n</code></pre>"},{"location":"reference/plotting/plotting/#openscvx.plotting.plotting.plot_vector_norm","title":"<code>plot_vector_norm(result: OptimizationResults, var_name: str, bounds: tuple[float, float] | None = None)</code>","text":"<p>Plot the 2-norm of a vector variable over time.</p> <p>Useful for visualizing thrust magnitude, velocity magnitude, etc.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>OptimizationResults</code> <p>Optimization results containing trajectories</p> required <code>var_name</code> <code>str</code> <p>Name of the vector variable (state or control)</p> required <code>bounds</code> <code>tuple[float, float] | None</code> <p>Optional (min, max) bounds to show as horizontal dashed lines</p> <code>None</code> <p>Returns:</p> Type Description <p>Plotly figure</p> Source code in <code>openscvx/plotting/plotting.py</code> <pre><code>def plot_vector_norm(\n    result: OptimizationResults,\n    var_name: str,\n    bounds: tuple[float, float] | None = None,\n):\n    \"\"\"Plot the 2-norm of a vector variable over time.\n\n    Useful for visualizing thrust magnitude, velocity magnitude, etc.\n\n    Args:\n        result: Optimization results containing trajectories\n        var_name: Name of the vector variable (state or control)\n        bounds: Optional (min, max) bounds to show as horizontal dashed lines\n\n    Returns:\n        Plotly figure\n    \"\"\"\n    import numpy as np\n\n    has_trajectory = bool(result.trajectory) and var_name in result.trajectory\n    has_nodes = var_name in result.nodes\n\n    if not has_trajectory and not has_nodes:\n        available_traj = set(result.trajectory.keys()) if result.trajectory else set()\n        available_nodes = set(result.nodes.keys())\n        raise ValueError(\n            f\"Variable '{var_name}' not found. \"\n            f\"Available in trajectory: {sorted(available_traj)}, nodes: {sorted(available_nodes)}\"\n        )\n\n    fig = go.Figure()\n\n    # Plot trajectory norm if available\n    if has_trajectory:\n        t_full = result.trajectory[\"time\"].flatten()\n        data = result.trajectory[var_name]\n        norm = np.linalg.norm(data, axis=1)\n        fig.add_trace(\n            go.Scatter(\n                x=t_full,\n                y=norm,\n                mode=\"lines\",\n                line={\"color\": \"green\", \"width\": 2},\n                name=\"Trajectory\",\n                legendgroup=\"trajectory\",\n            )\n        )\n\n    # Plot node norms if available\n    if has_nodes:\n        t_nodes = result.nodes[\"time\"].flatten()\n        data = result.nodes[var_name]\n        norm = np.linalg.norm(data, axis=1)\n        fig.add_trace(\n            go.Scatter(\n                x=t_nodes,\n                y=norm,\n                mode=\"markers\",\n                marker={\"color\": \"cyan\", \"size\": 6},\n                name=\"Nodes\",\n                legendgroup=\"nodes\",\n            )\n        )\n\n    # Add bounds if provided\n    if bounds is not None:\n        min_bound, max_bound = bounds\n        fig.add_hline(\n            y=min_bound,\n            line={\"color\": \"red\", \"width\": 2, \"dash\": \"dash\"},\n            annotation_text=\"Min\",\n            annotation_position=\"right\",\n        )\n        fig.add_hline(\n            y=max_bound,\n            line={\"color\": \"red\", \"width\": 2, \"dash\": \"dash\"},\n            annotation_text=\"Max\",\n            annotation_position=\"right\",\n        )\n\n    fig.update_layout(\n        title=f\"\u2016{var_name}\u2016\u2082\",\n        xaxis_title=\"Time (s)\",\n        yaxis_title=\"Norm\",\n        template=\"plotly_dark\",\n    )\n\n    return fig\n</code></pre>"},{"location":"reference/plotting/plotting/#openscvx.plotting.plotting.plot_virtual_control_heatmap","title":"<code>plot_virtual_control_heatmap(result: OptimizationResults)</code>","text":"<p>Plot heatmap of the final virtual control magnitudes (VC_history[-1]).</p> Source code in <code>openscvx/plotting/plotting.py</code> <pre><code>def plot_virtual_control_heatmap(result: OptimizationResults):\n    \"\"\"Plot heatmap of the final virtual control magnitudes (VC_history[-1]).\"\"\"\n    if not result.VC_history:\n        raise ValueError(\"Result has no VC_history to plot\")\n\n    vc_mat = result.VC_history[-1]\n\n    # Build state names list\n    state_names = []\n    for var in result._states:\n        dim = _get_var_dim(result, var.name, result._states)\n        if dim == 1:\n            state_names.append(var.name)\n        else:\n            state_names.extend(f\"{var.name}_{i}\" for i in range(dim))\n\n    # Align so rows = states, cols = nodes\n    if vc_mat.shape[1] == len(state_names):\n        z = vc_mat.T\n    elif vc_mat.shape[0] == len(state_names):\n        z = vc_mat\n    else:\n        raise ValueError(\"VC matrix shape does not align with state components\")\n\n    x_len = z.shape[1]\n    t_nodes = result.nodes[\"time\"].flatten()\n\n    # Virtual control uses N-1 intervals\n    if len(t_nodes) == x_len + 1:\n        x_labels = t_nodes[:-1]\n    elif len(t_nodes) == x_len:\n        x_labels = t_nodes\n    else:\n        x_labels = list(range(x_len))\n\n    fig = go.Figure(data=go.Heatmap(z=z, x=x_labels, y=state_names, colorscale=\"Magma\"))\n    fig.update_layout(title=\"Virtual Control Magnitudes (last iteration)\", template=\"plotly_dark\")\n    fig.update_xaxes(title_text=\"Node Interval (N-1)\")\n    fig.update_yaxes(title_text=\"State component\")\n    return fig\n</code></pre>"},{"location":"reference/plotting/scp_iteration/","title":"scp_iteration","text":""},{"location":"reference/plotting/scp_iteration/#openscvx.plotting.scp_iteration.plot_scp_iterations","title":"<code>plot_scp_iterations(result: OptimizationResults, state_names: list[str] | None = None, control_names: list[str] | None = None, cmap_name: str = 'viridis', show_propagation: bool = True)</code>","text":"<p>Plot all SCP iterations overlaid with colormap-based coloring.</p> <p>Shows the evolution of states and controls across SCP iterations. Early iterations are dark, later iterations are bright (following the colormap). This makes convergence visible at a glance.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>OptimizationResults</code> <p>Optimization results containing iteration history</p> required <code>state_names</code> <code>list[str] | None</code> <p>Optional list of state names to include. If None, plots all states.</p> <code>None</code> <code>control_names</code> <code>list[str] | None</code> <p>Optional list of control names to include. If None, plots all controls.</p> <code>None</code> <code>cmap_name</code> <code>str</code> <p>Matplotlib colormap name (default: \"viridis\")</p> <code>'viridis'</code> <code>show_propagation</code> <code>bool</code> <p>If True, show multi-shot propagation lines (default: True)</p> <code>True</code> <p>Returns:</p> Type Description <p>Plotly figure with all iterations overlaid</p> Example <p>results = problem.solve() plot_scp_iterations(results, [\"position\", \"velocity\"]).show()</p> Source code in <code>openscvx/plotting/scp_iteration.py</code> <pre><code>def plot_scp_iterations(\n    result: OptimizationResults,\n    state_names: list[str] | None = None,\n    control_names: list[str] | None = None,\n    cmap_name: str = \"viridis\",\n    show_propagation: bool = True,\n):\n    \"\"\"Plot all SCP iterations overlaid with colormap-based coloring.\n\n    Shows the evolution of states and controls across SCP iterations. Early\n    iterations are dark, later iterations are bright (following the colormap).\n    This makes convergence visible at a glance.\n\n    Args:\n        result: Optimization results containing iteration history\n        state_names: Optional list of state names to include. If None, plots all states.\n        control_names: Optional list of control names to include. If None, plots all controls.\n        cmap_name: Matplotlib colormap name (default: \"viridis\")\n        show_propagation: If True, show multi-shot propagation lines (default: True)\n\n    Returns:\n        Plotly figure with all iterations overlaid\n\n    Example:\n        &gt;&gt;&gt; results = problem.solve()\n        &gt;&gt;&gt; plot_scp_iterations(results, [\"position\", \"velocity\"]).show()\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    if not result.X:\n        raise ValueError(\"No iteration history available in result.X\")\n\n    # Derive dimensions from result data\n    n_x = result.X[0].shape[1]\n    n_u = result.U[0].shape[1]\n\n    # Find time slice by looking for \"time\" state\n    time_slice = None\n    for state in result._states:\n        if state.name.lower() == \"time\":\n            time_slice = state._slice\n            break\n\n    # Extract multi-shot propagation trajectories\n    V_history = result.discretization_history if result.discretization_history else []\n    X_prop_history = []\n    if V_history and show_propagation:\n        i4 = n_x + n_x * n_x + 2 * n_x * n_u\n        for V in V_history:\n            pos_traj = []\n            for i_multi in range(V.shape[1]):\n                pos_traj.append(V[:, i_multi].reshape(-1, i4)[:, :n_x])\n            X_prop_history.append(np.array(pos_traj))\n\n    n_iterations = len(result.X)\n    if X_prop_history:\n        n_iterations = min(n_iterations, len(X_prop_history))\n\n    # Filter states and controls (exclude ctcs_aug and time)\n    states = [\n        s for s in result._states if \"ctcs_aug\" not in s.name.lower() and s.name.lower() != \"time\"\n    ]\n    controls = list(result._controls) if result._controls else []\n\n    state_filter = set(state_names) if state_names else None\n    control_filter = set(control_names) if control_names else None\n\n    if state_filter and control_filter is None:\n        controls = []\n    if control_filter and state_filter is None:\n        states = []\n    if state_filter:\n        states = [s for s in states if s.name in state_filter]\n        if not states:\n            available = {s.name for s in result._states if \"ctcs_aug\" not in s.name.lower()}\n            raise ValueError(\n                f\"No states matched filter {state_names}. Available: {sorted(available)}\"\n            )\n    if control_filter:\n        controls = [c for c in controls if c.name in control_filter]\n        if not controls:\n            available = {c.name for c in result._controls}\n            raise ValueError(\n                f\"No controls matched filter {control_names}. Available: {sorted(available)}\"\n            )\n\n    if not states and not controls:\n        raise ValueError(\"No states or controls to plot\")\n\n    # Expand multi-dimensional variables to individual components\n    def expand_variables(variables):\n        expanded = []\n        for var in variables:\n            s = var._slice\n            start = s.start if isinstance(s, slice) else s\n            stop = s.stop if isinstance(s, slice) else start + 1\n            n_comp = (stop or start + 1) - (start or 0)\n\n            for i in range(n_comp):\n                expanded.append(\n                    {\n                        \"name\": f\"{var.name}_{i}\" if n_comp &gt; 1 else var.name,\n                        \"idx\": start + i,\n                        \"parent\": var.name,\n                        \"comp\": i,\n                    }\n                )\n        return expanded\n\n    expanded_states = expand_variables(states)\n    expanded_controls = expand_variables(controls)\n\n    # Grid layout\n    n_states = len(expanded_states)\n    n_controls = len(expanded_controls)\n    n_state_cols = min(7, n_states) if n_states &gt; 0 else 1\n    n_control_cols = min(3, n_controls) if n_controls &gt; 0 else 1\n    n_state_rows = (n_states + n_state_cols - 1) // n_state_cols if n_states &gt; 0 else 0\n    n_control_rows = (n_controls + n_control_cols - 1) // n_control_cols if n_controls &gt; 0 else 0\n    total_rows = n_state_rows + n_control_rows\n    max_cols = max(n_state_cols, n_control_cols)\n\n    subplot_titles = [s[\"name\"] for s in expanded_states] + [c[\"name\"] for c in expanded_controls]\n    fig = make_subplots(\n        rows=total_rows,\n        cols=max_cols,\n        subplot_titles=subplot_titles,\n        vertical_spacing=0.08,\n        horizontal_spacing=0.05,\n    )\n\n    # Get colormap\n    cmap = plt.get_cmap(cmap_name)\n\n    def iter_color(iter_idx):\n        rgba = cmap(iter_idx / max(n_iterations - 1, 1))\n        return f\"rgb({int(rgba[0] * 255)},{int(rgba[1] * 255)},{int(rgba[2] * 255)})\"\n\n    # Plot all iterations\n    for iter_idx in range(n_iterations):\n        X_nodes = result.X[iter_idx]\n        U_iter = result.U[iter_idx]\n        color = iter_color(iter_idx)\n        legend_group = f\"iter_{iter_idx}\"\n        show_legend_for_iter = True  # Show legend for first trace of this iteration\n\n        t_nodes = (\n            X_nodes[:, time_slice].flatten()\n            if time_slice is not None\n            else np.linspace(0, result.t_final, X_nodes.shape[0])\n        )\n\n        # States\n        for state_idx, state in enumerate(expanded_states):\n            row = (state_idx // n_state_cols) + 1\n            col = (state_idx % n_state_cols) + 1\n            idx = state[\"idx\"]\n\n            # Multi-shot propagation lines\n            if X_prop_history and iter_idx &lt; len(X_prop_history):\n                pos_traj = X_prop_history[iter_idx]\n                for j in range(pos_traj.shape[1]):\n                    segment_times = pos_traj[:, j, time_slice].flatten()\n                    segment_states = pos_traj[:, j, idx]\n                    fig.add_trace(\n                        go.Scatter(\n                            x=segment_times,\n                            y=segment_states,\n                            mode=\"lines\",\n                            line={\"color\": color, \"width\": 1.5},\n                            legendgroup=legend_group,\n                            showlegend=show_legend_for_iter,\n                            name=f\"Iter {iter_idx}\" if show_legend_for_iter else None,\n                            hoverinfo=\"skip\",\n                        ),\n                        row=row,\n                        col=col,\n                    )\n                    show_legend_for_iter = False\n\n            # Nodes\n            fig.add_trace(\n                go.Scatter(\n                    x=t_nodes,\n                    y=X_nodes[:, idx],\n                    mode=\"markers\",\n                    marker={\"color\": color, \"size\": 5},\n                    legendgroup=legend_group,\n                    showlegend=show_legend_for_iter,\n                    name=f\"Iter {iter_idx}\" if show_legend_for_iter else None,\n                    hovertemplate=f\"iter {iter_idx}&lt;br&gt;t=%{{x:.2f}}&lt;br&gt;y=%{{y:.3g}}&lt;extra&gt;&lt;/extra&gt;\",\n                ),\n                row=row,\n                col=col,\n            )\n            show_legend_for_iter = False\n\n        # Controls\n        for control_idx, control in enumerate(expanded_controls):\n            row = n_state_rows + (control_idx // n_control_cols) + 1\n            col = (control_idx % n_control_cols) + 1\n            idx = control[\"idx\"]\n\n            fig.add_trace(\n                go.Scatter(\n                    x=t_nodes,\n                    y=U_iter[:, idx],\n                    mode=\"markers\",\n                    marker={\"color\": color, \"size\": 5},\n                    legendgroup=legend_group,\n                    showlegend=show_legend_for_iter,\n                    name=f\"Iter {iter_idx}\" if show_legend_for_iter else None,\n                    hovertemplate=f\"iter {iter_idx}&lt;br&gt;t=%{{x:.2f}}&lt;br&gt;y=%{{y:.3g}}&lt;extra&gt;&lt;/extra&gt;\",\n                ),\n                row=row,\n                col=col,\n            )\n            show_legend_for_iter = False\n\n    # Add bounds (once, using final iteration's time range)\n    t_nodes_final = (\n        result.X[-1][:, time_slice].flatten()\n        if time_slice is not None\n        else np.linspace(0, result.t_final, result.X[-1].shape[0])\n    )\n    t_min, t_max = t_nodes_final.min(), t_nodes_final.max()\n\n    for state_idx, state in enumerate(expanded_states):\n        row = (state_idx // n_state_cols) + 1\n        col = (state_idx % n_state_cols) + 1\n        parent = _get_var(result, state[\"parent\"], result._states)\n        comp_idx = state[\"comp\"]\n\n        for bound_val, bound_attr in [(parent.min, \"min\"), (parent.max, \"max\")]:\n            if bound_val is not None and np.isfinite(bound_val[comp_idx]):\n                fig.add_trace(\n                    go.Scatter(\n                        x=[t_min, t_max],\n                        y=[bound_val[comp_idx], bound_val[comp_idx]],\n                        mode=\"lines\",\n                        line={\"color\": \"red\", \"width\": 1.5, \"dash\": \"dot\"},\n                        showlegend=False,\n                        hoverinfo=\"skip\",\n                    ),\n                    row=row,\n                    col=col,\n                )\n\n    for control_idx, control in enumerate(expanded_controls):\n        row = n_state_rows + (control_idx // n_control_cols) + 1\n        col = (control_idx % n_control_cols) + 1\n        parent = _get_var(result, control[\"parent\"], result._controls)\n        comp_idx = control[\"comp\"]\n\n        for bound_val in [parent.min, parent.max]:\n            if bound_val is not None and np.isfinite(bound_val[comp_idx]):\n                fig.add_trace(\n                    go.Scatter(\n                        x=[t_min, t_max],\n                        y=[bound_val[comp_idx], bound_val[comp_idx]],\n                        mode=\"lines\",\n                        line={\"color\": \"red\", \"width\": 1.5, \"dash\": \"dot\"},\n                        showlegend=False,\n                        hoverinfo=\"skip\",\n                    ),\n                    row=row,\n                    col=col,\n                )\n\n    # Layout\n    fig.update_layout(\n        title_text=\"SCP Iterations\",\n        template=\"plotly_dark\",\n        showlegend=True,\n        legend={\n            \"title\": \"Iterations\",\n            \"yanchor\": \"top\",\n            \"y\": 0.99,\n            \"xanchor\": \"left\",\n            \"x\": 1.02,\n            \"bgcolor\": \"rgba(0, 0, 0, 0.5)\",\n            \"itemclick\": \"toggle\",\n            \"itemdoubleclick\": \"toggleothers\",\n        },\n    )\n\n    for col_idx in range(1, max_cols + 1):\n        fig.update_xaxes(title_text=\"Time (s)\", row=total_rows, col=col_idx)\n\n    return fig\n</code></pre>"},{"location":"reference/plotting/viser/","title":"viser","text":"<p>Composable 3D visualization primitives using viser.</p> <p>This module provides building blocks for creating interactive 3D trajectory visualizations. The design philosophy is to give you useful primitives that you can mix and match - not a monolithic plotting function that tries to handle every case.</p> <p>Basic Pattern:     1. Create a <code>viser.ViserServer</code> (use our helper, or make your own!)     2. Add static scene elements (obstacles, gates, ground planes, etc.)     3. Add animated elements - each returns <code>(handle, update_callback)</code>     4. Wire up animation controls with your list of update callbacks     5. Call <code>server.sleep_forever()</code> to keep the visualization running</p> <p>Example - Building Your Own Visualization::</p> <pre><code>from openscvx.plotting import viser\n\n# Step 1: Create server (or just use viser.ViserServer() directly!)\nserver = viser.create_server(positions)\n\n# Step 2: Add static elements\nviser.add_gates(server, gate_vertices)\nviser.add_ellipsoid_obstacles(server, centers, radii)\nviser.add_ghost_trajectory(server, positions, colors)\n\n# Step 3: Add animated elements (collect the update callbacks)\n_, update_trail = viser.add_animated_trail(server, positions, colors)\n_, update_marker = viser.add_position_marker(server, positions)\n_, update_thrust = viser.add_thrust_vector(server, positions, thrust)\n\n# Step 4: Wire up animation controls\nviser.add_animation_controls(\n    server, time_array,\n    [update_trail, update_marker, update_thrust]\n)\n\n# Step 5: Keep server running\nserver.sleep_forever()\n</code></pre> <p>Available Primitives:     - Server: <code>create_server</code>, <code>compute_velocity_colors</code>, <code>compute_grid_size</code>     - Static: <code>add_gates</code>, <code>add_ellipsoid_obstacles</code>, <code>add_glideslope_cone</code>,       <code>add_ghost_trajectory</code>     - Animated: <code>add_animated_trail</code>, <code>add_position_marker</code>, <code>add_thrust_vector</code>,       <code>add_attitude_frame</code>, <code>add_viewcone</code>, <code>add_target_marker(s)</code>     - Plotly: <code>add_animated_plotly_marker</code>, <code>add_animated_vector_norm_plot</code>     - SCP iteration: <code>add_scp_animation_controls</code>, <code>add_scp_iteration_nodes</code>, etc.</p> <p>For problem-specific examples (drones with viewcones, rockets with glideslope constraints, etc.), see <code>examples/plotting_viser.py</code>.</p>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_animated_plotly_marker","title":"<code>add_animated_plotly_marker(server: viser.ViserServer, fig: go.Figure, time_array: np.ndarray, marker_x_data: np.ndarray, marker_y_data: np.ndarray, use_trajectory_indexing: bool = True, marker_name: str = 'Current', marker_color: str = 'red', marker_size: int = 12, folder_name: str | None = None, aspect: float = 1.5) -&gt; tuple</code>","text":"<p>Add a plotly figure to viser GUI with an animated time marker.</p> <p>This function takes any plotly figure and adds an animated marker that synchronizes with viser's 3D animation timeline. The marker shows the current position on the plot as the animation plays.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>fig</code> <code>Figure</code> <p>Plotly figure to display</p> required <code>time_array</code> <code>ndarray</code> <p>Time values corresponding to animation frames (N,). This should match the time array passed to add_animation_controls().</p> required <code>marker_x_data</code> <code>ndarray</code> <p>X-axis values for marker position (N,)</p> required <code>marker_y_data</code> <code>ndarray</code> <p>Y-axis values for marker position (N,)</p> required <code>use_trajectory_indexing</code> <code>bool</code> <p>If True, frame_idx maps directly to data indices. If False, searches for nearest time value (use for node-only data).</p> <code>True</code> <code>marker_name</code> <code>str</code> <p>Legend name for the marker trace</p> <code>'Current'</code> <code>marker_color</code> <code>str</code> <p>Color of the animated marker</p> <code>'red'</code> <code>marker_size</code> <code>int</code> <p>Size of the animated marker in points</p> <code>12</code> <code>folder_name</code> <code>str | None</code> <p>Optional GUI folder name to organize plots</p> <code>None</code> <code>aspect</code> <code>float</code> <p>Aspect ratio for plot display (width/height)</p> <code>1.5</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (plot_handle, update_callback)</p> <p>Example::</p> <pre><code>from openscvx.plotting import plot_vector_norm, viser\n\n# Create any plotly figure\nfig = plot_vector_norm(results, \"thrust\")\nthrust_norms = np.linalg.norm(results.trajectory[\"thrust\"], axis=1)\n\n# Add to viser with animated marker\n_, update_plot = viser.add_animated_plotly_marker(\n    server, fig,\n    time_array=results.trajectory[\"time\"].flatten(),\n    marker_x_data=results.trajectory[\"time\"].flatten(),\n    marker_y_data=thrust_norms,\n)\n\n# Add to animation callbacks\nupdate_callbacks.append(update_plot)\n</code></pre> Source code in <code>openscvx/plotting/viser/plotly_integration.py</code> <pre><code>def add_animated_plotly_marker(\n    server: viser.ViserServer,\n    fig: go.Figure,\n    time_array: np.ndarray,\n    marker_x_data: np.ndarray,\n    marker_y_data: np.ndarray,\n    use_trajectory_indexing: bool = True,\n    marker_name: str = \"Current\",\n    marker_color: str = \"red\",\n    marker_size: int = 12,\n    folder_name: str | None = None,\n    aspect: float = 1.5,\n) -&gt; tuple:\n    \"\"\"Add a plotly figure to viser GUI with an animated time marker.\n\n    This function takes any plotly figure and adds an animated marker that\n    synchronizes with viser's 3D animation timeline. The marker shows the\n    current position on the plot as the animation plays.\n\n    Args:\n        server: ViserServer instance\n        fig: Plotly figure to display\n        time_array: Time values corresponding to animation frames (N,).\n            This should match the time array passed to add_animation_controls().\n        marker_x_data: X-axis values for marker position (N,)\n        marker_y_data: Y-axis values for marker position (N,)\n        use_trajectory_indexing: If True, frame_idx maps directly to data indices.\n            If False, searches for nearest time value (use for node-only data).\n        marker_name: Legend name for the marker trace\n        marker_color: Color of the animated marker\n        marker_size: Size of the animated marker in points\n        folder_name: Optional GUI folder name to organize plots\n        aspect: Aspect ratio for plot display (width/height)\n\n    Returns:\n        Tuple of (plot_handle, update_callback)\n\n    Example::\n\n        from openscvx.plotting import plot_vector_norm, viser\n\n        # Create any plotly figure\n        fig = plot_vector_norm(results, \"thrust\")\n        thrust_norms = np.linalg.norm(results.trajectory[\"thrust\"], axis=1)\n\n        # Add to viser with animated marker\n        _, update_plot = viser.add_animated_plotly_marker(\n            server, fig,\n            time_array=results.trajectory[\"time\"].flatten(),\n            marker_x_data=results.trajectory[\"time\"].flatten(),\n            marker_y_data=thrust_norms,\n        )\n\n        # Add to animation callbacks\n        update_callbacks.append(update_plot)\n    \"\"\"\n    # Add marker trace to figure\n    marker_trace = go.Scatter(\n        x=[marker_x_data[0]],\n        y=[marker_y_data[0]],\n        mode=\"markers\",\n        marker={\"color\": marker_color, \"size\": marker_size, \"symbol\": \"circle\"},\n        name=marker_name,\n    )\n    fig.add_trace(marker_trace)\n    marker_trace_idx = len(fig.data) - 1\n\n    # Add to viser GUI\n    if folder_name:\n        with server.gui.add_folder(folder_name):\n            plot_handle = server.gui.add_plotly(figure=fig, aspect=aspect)\n    else:\n        plot_handle = server.gui.add_plotly(figure=fig, aspect=aspect)\n\n    # Create update callback\n    def update(frame_idx: int) -&gt; None:\n        \"\"\"Update marker position based on current frame.\"\"\"\n        if use_trajectory_indexing:\n            # Direct indexing: frame_idx corresponds to data index\n            idx = min(frame_idx, len(marker_y_data) - 1)\n        else:\n            # Search for nearest time (for node-only data)\n            current_time = time_array[frame_idx]\n            idx = min(np.searchsorted(marker_x_data, current_time), len(marker_y_data) - 1)\n\n        # Update marker position\n        fig.data[marker_trace_idx].x = [marker_x_data[idx]]\n        fig.data[marker_trace_idx].y = [marker_y_data[idx]]\n\n        # Trigger viser update\n        plot_handle.figure = fig\n\n    return plot_handle, update\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_animated_plotly_vline","title":"<code>add_animated_plotly_vline(server: viser.ViserServer, fig: go.Figure, time_array: np.ndarray, use_trajectory_indexing: bool = True, line_color: str = 'red', line_width: int = 2, line_dash: str = 'dash', annotation_text: str = 'Current', annotation_position: str = 'top', folder_name: str | None = None, aspect: float = 1.5) -&gt; tuple</code>","text":"<p>Add a plotly figure to viser GUI with an animated vertical line.</p> <p>This function takes any plotly figure and adds an animated vertical line that synchronizes with viser's 3D animation timeline. The line shows the current time position as the animation plays.</p> <p>This is more generic than add_animated_plotly_marker() as it works for any number of traces without needing to specify y-data for each.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>fig</code> <code>Figure</code> <p>Plotly figure to display</p> required <code>time_array</code> <code>ndarray</code> <p>Time values corresponding to animation frames (N,). This should match the time array passed to add_animation_controls().</p> required <code>use_trajectory_indexing</code> <code>bool</code> <p>If True, frame_idx maps directly to time indices. If False, searches for nearest time value (use for node-only data).</p> <code>True</code> <code>line_color</code> <code>str</code> <p>Color of the vertical line</p> <code>'red'</code> <code>line_width</code> <code>int</code> <p>Width of the vertical line in pixels</p> <code>2</code> <code>line_dash</code> <code>str</code> <p>Dash style - \"solid\", \"dash\", \"dot\", \"dashdot\"</p> <code>'dash'</code> <code>annotation_text</code> <code>str</code> <p>Text to show on the line</p> <code>'Current'</code> <code>annotation_position</code> <code>str</code> <p>Position of annotation - \"top\", \"bottom\", \"top left\", etc.</p> <code>'top'</code> <code>folder_name</code> <code>str | None</code> <p>Optional GUI folder name to organize plots</p> <code>None</code> <code>aspect</code> <code>float</code> <p>Aspect ratio for plot display (width/height)</p> <code>1.5</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (plot_handle, update_callback)</p> <p>Example::</p> <pre><code>from openscvx.plotting import plot_control, viser\n\n# Create any plotly figure\nfig = plot_control(results, \"thrust_force\")\n\n# Add to viser with animated vertical line\n_, update_plot = viser.add_animated_plotly_vline(\n    server, fig,\n    time_array=results.trajectory[\"time\"].flatten(),\n)\n\n# Add to animation callbacks\nupdate_callbacks.append(update_plot)\n</code></pre> Source code in <code>openscvx/plotting/viser/plotly_integration.py</code> <pre><code>def add_animated_plotly_vline(\n    server: viser.ViserServer,\n    fig: go.Figure,\n    time_array: np.ndarray,\n    use_trajectory_indexing: bool = True,\n    line_color: str = \"red\",\n    line_width: int = 2,\n    line_dash: str = \"dash\",\n    annotation_text: str = \"Current\",\n    annotation_position: str = \"top\",\n    folder_name: str | None = None,\n    aspect: float = 1.5,\n) -&gt; tuple:\n    \"\"\"Add a plotly figure to viser GUI with an animated vertical line.\n\n    This function takes any plotly figure and adds an animated vertical line that\n    synchronizes with viser's 3D animation timeline. The line shows the current\n    time position as the animation plays.\n\n    This is more generic than add_animated_plotly_marker() as it works for any\n    number of traces without needing to specify y-data for each.\n\n    Args:\n        server: ViserServer instance\n        fig: Plotly figure to display\n        time_array: Time values corresponding to animation frames (N,).\n            This should match the time array passed to add_animation_controls().\n        use_trajectory_indexing: If True, frame_idx maps directly to time indices.\n            If False, searches for nearest time value (use for node-only data).\n        line_color: Color of the vertical line\n        line_width: Width of the vertical line in pixels\n        line_dash: Dash style - \"solid\", \"dash\", \"dot\", \"dashdot\"\n        annotation_text: Text to show on the line\n        annotation_position: Position of annotation - \"top\", \"bottom\", \"top left\", etc.\n        folder_name: Optional GUI folder name to organize plots\n        aspect: Aspect ratio for plot display (width/height)\n\n    Returns:\n        Tuple of (plot_handle, update_callback)\n\n    Example::\n\n        from openscvx.plotting import plot_control, viser\n\n        # Create any plotly figure\n        fig = plot_control(results, \"thrust_force\")\n\n        # Add to viser with animated vertical line\n        _, update_plot = viser.add_animated_plotly_vline(\n            server, fig,\n            time_array=results.trajectory[\"time\"].flatten(),\n        )\n\n        # Add to animation callbacks\n        update_callbacks.append(update_plot)\n    \"\"\"\n    # Detect number of subplots in the figure\n    # Count unique xaxis/yaxis references in the layout\n    n_subplots = 1\n    if hasattr(fig, \"_grid_ref\") and fig._grid_ref is not None:\n        # Figure created with make_subplots - use grid dimensions\n        n_rows = len(fig._grid_ref)\n        n_cols = len(fig._grid_ref[0]) if n_rows &gt; 0 else 1\n        n_subplots = n_rows * n_cols\n\n    # Track which shapes are our vlines (before adding new ones)\n    n_existing_shapes = len(fig.layout.shapes) if fig.layout.shapes else 0\n\n    # Add vertical line to each subplot\n    if n_subplots == 1:\n        # Single plot - add one vline\n        fig.add_vline(\n            x=time_array[0],\n            line_dash=line_dash,\n            line_color=line_color,\n            line_width=line_width,\n            annotation_text=annotation_text,\n            annotation_position=annotation_position,\n        )\n    else:\n        # Multiple subplots - add vline to each\n        # Determine grid layout\n        n_rows = len(fig._grid_ref)\n        n_cols = len(fig._grid_ref[0]) if n_rows &gt; 0 else 1\n\n        for row_idx in range(n_rows):\n            for col_idx in range(n_cols):\n                # Add vline to this subplot\n                # Only add annotation to first subplot to avoid clutter\n                show_annotation = row_idx == 0 and col_idx == 0\n                fig.add_vline(\n                    x=time_array[0],\n                    line_dash=line_dash,\n                    line_color=line_color,\n                    line_width=line_width,\n                    annotation_text=annotation_text if show_annotation else None,\n                    annotation_position=annotation_position if show_annotation else None,\n                    row=row_idx + 1,\n                    col=col_idx + 1,\n                )\n\n    # Track indices of shapes we added\n    n_new_shapes = len(fig.layout.shapes) - n_existing_shapes\n    vline_shape_indices = list(range(n_existing_shapes, n_existing_shapes + n_new_shapes))\n\n    # Add to viser GUI\n    if folder_name:\n        with server.gui.add_folder(folder_name):\n            plot_handle = server.gui.add_plotly(figure=fig, aspect=aspect)\n    else:\n        plot_handle = server.gui.add_plotly(figure=fig, aspect=aspect)\n\n    # Create update callback\n    def update(frame_idx: int) -&gt; None:\n        \"\"\"Update vertical line position based on current frame.\"\"\"\n        if use_trajectory_indexing:\n            # Direct indexing: frame_idx corresponds to time index\n            idx = min(frame_idx, len(time_array) - 1)\n        else:\n            # Search for nearest time (for node-only data)\n            current_time = time_array[frame_idx]\n            idx = min(frame_idx, len(time_array) - 1)\n\n        # Update all vertical line positions\n        current_time = time_array[idx]\n        for shape_idx in vline_shape_indices:\n            fig.layout.shapes[shape_idx].x0 = current_time\n            fig.layout.shapes[shape_idx].x1 = current_time\n\n        # Trigger viser update\n        plot_handle.figure = fig\n\n    return plot_handle, update\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_animated_trail","title":"<code>add_animated_trail(server: viser.ViserServer, pos: np.ndarray, colors: np.ndarray, point_size: float = 0.15) -&gt; tuple[viser.PointCloudHandle, UpdateCallback]</code>","text":"<p>Add an animated trail that grows with the animation.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>pos</code> <code>ndarray</code> <p>Position array of shape (N, 3)</p> required <code>colors</code> <code>ndarray</code> <p>RGB color array of shape (N, 3)</p> required <code>point_size</code> <code>float</code> <p>Size of trail points</p> <code>0.15</code> <p>Returns:</p> Type Description <code>tuple[PointCloudHandle, UpdateCallback]</code> <p>Tuple of (handle, update_callback)</p> Source code in <code>openscvx/plotting/viser/animated.py</code> <pre><code>def add_animated_trail(\n    server: viser.ViserServer,\n    pos: np.ndarray,\n    colors: np.ndarray,\n    point_size: float = 0.15,\n) -&gt; tuple[viser.PointCloudHandle, UpdateCallback]:\n    \"\"\"Add an animated trail that grows with the animation.\n\n    Args:\n        server: ViserServer instance\n        pos: Position array of shape (N, 3)\n        colors: RGB color array of shape (N, 3)\n        point_size: Size of trail points\n\n    Returns:\n        Tuple of (handle, update_callback)\n    \"\"\"\n    handle = server.scene.add_point_cloud(\n        \"/trail\",\n        points=pos[:1],\n        colors=colors[:1],\n        point_size=point_size,\n    )\n\n    def update(frame_idx: int) -&gt; None:\n        idx = frame_idx + 1  # Include current frame\n        handle.points = pos[:idx]\n        handle.colors = colors[:idx]\n\n    return handle, update\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_animated_vector_norm_plot","title":"<code>add_animated_vector_norm_plot(server: viser.ViserServer, results: OptimizationResults, var_name: str, bounds: tuple[float, float] | None = None, title: str | None = None, folder_name: str | None = None, aspect: float = 1.5, marker_color: str = 'red', marker_size: int = 12) -&gt; tuple</code>","text":"<p>Add animated norm plot for a state or control variable.</p> <p>Convenience wrapper around add_animated_plotly_marker() that uses the existing plot_vector_norm() function to create the base plot.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>results</code> <code>OptimizationResults</code> <p>Optimization results containing variable data</p> required <code>var_name</code> <code>str</code> <p>Name of the state or control variable to plot</p> required <code>bounds</code> <code>tuple[float, float] | None</code> <p>Optional (min, max) bounds to display on plot</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Optional custom title for the plot (defaults to \"\u2016{var_name}\u2016\u2082\")</p> <code>None</code> <code>folder_name</code> <code>str | None</code> <p>Optional GUI folder name to organize plots</p> <code>None</code> <code>aspect</code> <code>float</code> <p>Aspect ratio for plot display (width/height)</p> <code>1.5</code> <code>marker_color</code> <code>str</code> <p>Color of the animated marker</p> <code>'red'</code> <code>marker_size</code> <code>int</code> <p>Size of the animated marker in points</p> <code>12</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (plot_handle, update_callback), or (None, None) if variable not found</p> <p>Example::</p> <pre><code>from openscvx.plotting import viser\n\n# Add animated thrust norm plot\n_, update_thrust = viser.add_animated_vector_norm_plot(\n    server, results, \"thrust\",\n    title=\"Thrust Magnitude\",\n    bounds=(0.0, max_thrust),\n    folder_name=\"Control Plots\"\n)\nif update_thrust is not None:\n    update_callbacks.append(update_thrust)\n</code></pre> Source code in <code>openscvx/plotting/viser/plotly_integration.py</code> <pre><code>def add_animated_vector_norm_plot(\n    server: viser.ViserServer,\n    results: OptimizationResults,\n    var_name: str,\n    bounds: tuple[float, float] | None = None,\n    title: str | None = None,\n    folder_name: str | None = None,\n    aspect: float = 1.5,\n    marker_color: str = \"red\",\n    marker_size: int = 12,\n) -&gt; tuple:\n    \"\"\"Add animated norm plot for a state or control variable.\n\n    Convenience wrapper around add_animated_plotly_marker() that uses\n    the existing plot_vector_norm() function to create the base plot.\n\n    Args:\n        server: ViserServer instance\n        results: Optimization results containing variable data\n        var_name: Name of the state or control variable to plot\n        bounds: Optional (min, max) bounds to display on plot\n        title: Optional custom title for the plot (defaults to \"\u2016{var_name}\u2016\u2082\")\n        folder_name: Optional GUI folder name to organize plots\n        aspect: Aspect ratio for plot display (width/height)\n        marker_color: Color of the animated marker\n        marker_size: Size of the animated marker in points\n\n    Returns:\n        Tuple of (plot_handle, update_callback), or (None, None) if variable not found\n\n    Example::\n\n        from openscvx.plotting import viser\n\n        # Add animated thrust norm plot\n        _, update_thrust = viser.add_animated_vector_norm_plot(\n            server, results, \"thrust\",\n            title=\"Thrust Magnitude\",\n            bounds=(0.0, max_thrust),\n            folder_name=\"Control Plots\"\n        )\n        if update_thrust is not None:\n            update_callbacks.append(update_thrust)\n    \"\"\"\n    from openscvx.plotting import plot_vector_norm\n\n    # Check if variable exists in results\n    has_in_trajectory = bool(results.trajectory) and var_name in results.trajectory\n    has_in_nodes = var_name in results.nodes\n\n    if not (has_in_trajectory or has_in_nodes):\n        import warnings\n\n        warnings.warn(f\"Variable '{var_name}' not found in results, skipping plot\")\n        return None, None\n\n    # Create figure using existing plotting function\n    fig = plot_vector_norm(results, var_name, bounds=bounds)\n\n    # Update title if custom title provided\n    if title is not None:\n        fig.update_layout(title_text=title)\n\n    # Determine data source and compute norms\n    if has_in_trajectory:\n        time_data = results.trajectory[\"time\"].flatten()\n        var_data = results.trajectory[var_name]\n        use_trajectory_indexing = True\n    else:\n        time_data = results.nodes[\"time\"].flatten()\n        var_data = results.nodes[var_name]\n        use_trajectory_indexing = False\n\n    # Compute norms\n    norm_data = np.linalg.norm(var_data, axis=1) if var_data.ndim &gt; 1 else np.abs(var_data)\n\n    # Add animated marker\n    return add_animated_plotly_marker(\n        server,\n        fig,\n        time_array=time_data,\n        marker_x_data=time_data,\n        marker_y_data=norm_data,\n        use_trajectory_indexing=use_trajectory_indexing,\n        marker_name=\"Current\",\n        marker_color=marker_color,\n        marker_size=marker_size,\n        folder_name=folder_name,\n        aspect=aspect,\n    )\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_animation_controls","title":"<code>add_animation_controls(server: viser.ViserServer, traj_time: np.ndarray, update_callbacks: list[UpdateCallback], loop: bool = True, folder_name: str = 'Animation') -&gt; None</code>","text":"<p>Add animation GUI controls and start the animation loop.</p> <p>Creates play/pause button, reset button, time slider, speed slider, and loop checkbox. Runs animation in a background daemon thread.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>traj_time</code> <code>ndarray</code> <p>Time array of shape (N,) with timestamps for each frame</p> required <code>update_callbacks</code> <code>list[UpdateCallback]</code> <p>List of update functions to call each frame</p> required <code>loop</code> <code>bool</code> <p>Whether to loop animation by default</p> <code>True</code> <code>folder_name</code> <code>str</code> <p>Name for the GUI folder</p> <code>'Animation'</code> Source code in <code>openscvx/plotting/viser/animated.py</code> <pre><code>def add_animation_controls(\n    server: viser.ViserServer,\n    traj_time: np.ndarray,\n    update_callbacks: list[UpdateCallback],\n    loop: bool = True,\n    folder_name: str = \"Animation\",\n) -&gt; None:\n    \"\"\"Add animation GUI controls and start the animation loop.\n\n    Creates play/pause button, reset button, time slider, speed slider, and loop checkbox.\n    Runs animation in a background daemon thread.\n\n    Args:\n        server: ViserServer instance\n        traj_time: Time array of shape (N,) with timestamps for each frame\n        update_callbacks: List of update functions to call each frame\n        loop: Whether to loop animation by default\n        folder_name: Name for the GUI folder\n    \"\"\"\n    traj_time = traj_time.flatten()\n    n_frames = len(traj_time)\n    t_start, t_end = float(traj_time[0]), float(traj_time[-1])\n    duration = t_end - t_start\n\n    # Filter out None callbacks\n    callbacks = [cb for cb in update_callbacks if cb is not None]\n\n    def time_to_frame(t: float) -&gt; int:\n        \"\"\"Convert simulation time to frame index.\"\"\"\n        return int(np.clip(np.searchsorted(traj_time, t, side=\"right\") - 1, 0, n_frames - 1))\n\n    def update_all(sim_t: float) -&gt; None:\n        \"\"\"Update all visualization components.\"\"\"\n        idx = time_to_frame(sim_t)\n        for callback in callbacks:\n            callback(idx)\n\n    # --- GUI Controls ---\n    with server.gui.add_folder(folder_name):\n        play_button = server.gui.add_button(\"Play\")\n        reset_button = server.gui.add_button(\"Reset\")\n        time_slider = server.gui.add_slider(\n            \"Time (s)\",\n            min=t_start,\n            max=t_end,\n            step=duration / 100,\n            initial_value=t_start,\n        )\n        speed_slider = server.gui.add_slider(\n            \"Speed\",\n            min=0.1,\n            max=5.0,\n            step=0.1,\n            initial_value=1.0,\n        )\n        loop_checkbox = server.gui.add_checkbox(\"Loop\", initial_value=loop)\n\n    # Animation state\n    state = {\"playing\": False, \"sim_time\": t_start}\n\n    @play_button.on_click\n    def _(_) -&gt; None:\n        state[\"playing\"] = not state[\"playing\"]\n        play_button.name = \"Pause\" if state[\"playing\"] else \"Play\"\n\n    @reset_button.on_click\n    def _(_) -&gt; None:\n        state[\"sim_time\"] = t_start\n        time_slider.value = t_start\n        update_all(t_start)\n\n    @time_slider.on_update\n    def _(_) -&gt; None:\n        if not state[\"playing\"]:\n            state[\"sim_time\"] = float(time_slider.value)\n            update_all(state[\"sim_time\"])\n\n    def animation_loop() -&gt; None:\n        \"\"\"Background thread for realtime animation playback.\"\"\"\n        last_time = time.time()\n        while True:\n            time.sleep(0.016)  # ~60 fps\n            current_time = time.time()\n            dt = current_time - last_time\n            last_time = current_time\n\n            if state[\"playing\"]:\n                # Advance simulation time (speed=1.0 is realtime)\n                state[\"sim_time\"] += dt * speed_slider.value\n\n                if state[\"sim_time\"] &gt;= t_end:\n                    if loop_checkbox.value:\n                        state[\"sim_time\"] = t_start\n                    else:\n                        state[\"sim_time\"] = t_end\n                        state[\"playing\"] = False\n                        play_button.name = \"Play\"\n\n                time_slider.value = state[\"sim_time\"]\n                update_all(state[\"sim_time\"])\n\n    # Start animation thread\n    thread = threading.Thread(target=animation_loop, daemon=True)\n    thread.start()\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_attitude_frame","title":"<code>add_attitude_frame(server: viser.ViserServer, pos: np.ndarray, attitude: np.ndarray | None, axes_length: float = 2.0, axes_radius: float = 0.05) -&gt; tuple[viser.FrameHandle | None, UpdateCallback | None]</code>","text":"<p>Add an animated body coordinate frame showing attitude.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>pos</code> <code>ndarray</code> <p>Position array of shape (N, 3)</p> required <code>attitude</code> <code>ndarray | None</code> <p>Quaternion array of shape (N, 4) in [w, x, y, z] format, or None to skip</p> required <code>axes_length</code> <code>float</code> <p>Length of the coordinate axes</p> <code>2.0</code> <code>axes_radius</code> <code>float</code> <p>Radius of the axes cylinders</p> <code>0.05</code> <p>Returns:</p> Type Description <code>tuple[FrameHandle | None, UpdateCallback | None]</code> <p>Tuple of (handle, update_callback), or (None, None) if attitude is None</p> Source code in <code>openscvx/plotting/viser/animated.py</code> <pre><code>def add_attitude_frame(\n    server: viser.ViserServer,\n    pos: np.ndarray,\n    attitude: np.ndarray | None,\n    axes_length: float = 2.0,\n    axes_radius: float = 0.05,\n) -&gt; tuple[viser.FrameHandle | None, UpdateCallback | None]:\n    \"\"\"Add an animated body coordinate frame showing attitude.\n\n    Args:\n        server: ViserServer instance\n        pos: Position array of shape (N, 3)\n        attitude: Quaternion array of shape (N, 4) in [w, x, y, z] format, or None to skip\n        axes_length: Length of the coordinate axes\n        axes_radius: Radius of the axes cylinders\n\n    Returns:\n        Tuple of (handle, update_callback), or (None, None) if attitude is None\n    \"\"\"\n    if attitude is None:\n        return None, None\n\n    # Viser uses wxyz quaternion format\n    handle = server.scene.add_frame(\n        \"/body_frame\",\n        wxyz=attitude[0],\n        position=pos[0],\n        axes_length=axes_length,\n        axes_radius=axes_radius,\n    )\n\n    def update(frame_idx: int) -&gt; None:\n        handle.wxyz = attitude[frame_idx]\n        handle.position = pos[frame_idx]\n\n    return handle, update\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_ellipsoid_obstacles","title":"<code>add_ellipsoid_obstacles(server: viser.ViserServer, centers: list[np.ndarray], radii: list[np.ndarray], axes: list[np.ndarray] | None = None, color: tuple[int, int, int] = (255, 100, 100), opacity: float = 0.6, wireframe: bool = False, subdivisions: int = 2) -&gt; list</code>","text":"<p>Add ellipsoidal obstacles to the scene.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>centers</code> <code>list[ndarray]</code> <p>List of center positions, each shape (3,)</p> required <code>radii</code> <code>list[ndarray]</code> <p>List of radii along principal axes, each shape (3,)</p> required <code>axes</code> <code>list[ndarray] | None</code> <p>List of rotation matrices (3, 3) defining principal axes. If None, ellipsoids are axis-aligned.</p> <code>None</code> <code>color</code> <code>tuple[int, int, int]</code> <p>RGB color tuple</p> <code>(255, 100, 100)</code> <code>opacity</code> <code>float</code> <p>Opacity (0-1), only used when wireframe=False</p> <code>0.6</code> <code>wireframe</code> <code>bool</code> <p>If True, render as wireframe instead of solid</p> <code>False</code> <code>subdivisions</code> <code>int</code> <p>Icosphere subdivisions (higher = smoother, 2 is usually good)</p> <code>2</code> <p>Returns:</p> Type Description <code>list</code> <p>List of mesh handles</p> Source code in <code>openscvx/plotting/viser/primitives.py</code> <pre><code>def add_ellipsoid_obstacles(\n    server: viser.ViserServer,\n    centers: list[np.ndarray],\n    radii: list[np.ndarray],\n    axes: list[np.ndarray] | None = None,\n    color: tuple[int, int, int] = (255, 100, 100),\n    opacity: float = 0.6,\n    wireframe: bool = False,\n    subdivisions: int = 2,\n) -&gt; list:\n    \"\"\"Add ellipsoidal obstacles to the scene.\n\n    Args:\n        server: ViserServer instance\n        centers: List of center positions, each shape (3,)\n        radii: List of radii along principal axes, each shape (3,)\n        axes: List of rotation matrices (3, 3) defining principal axes.\n            If None, ellipsoids are axis-aligned.\n        color: RGB color tuple\n        opacity: Opacity (0-1), only used when wireframe=False\n        wireframe: If True, render as wireframe instead of solid\n        subdivisions: Icosphere subdivisions (higher = smoother, 2 is usually good)\n\n    Returns:\n        List of mesh handles\n    \"\"\"\n    handles = []\n\n    if axes is None:\n        axes = [None] * len(centers)\n\n    for i, (center, rad, ax) in enumerate(zip(centers, radii, axes)):\n        # Convert JAX arrays to numpy if needed\n        center = np.asarray(center, dtype=np.float64)\n        rad = np.asarray(rad, dtype=np.float64)\n        if ax is not None:\n            ax = np.asarray(ax, dtype=np.float64)\n\n        vertices, faces = _generate_ellipsoid_mesh(center, rad, ax, subdivisions)\n\n        handle = server.scene.add_mesh_simple(\n            f\"/obstacles/ellipsoid_{i}\",\n            vertices=vertices,\n            faces=faces,\n            color=color,\n            wireframe=wireframe,\n            opacity=opacity if not wireframe else 1.0,\n        )\n        handles.append(handle)\n\n    return handles\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_gates","title":"<code>add_gates(server: viser.ViserServer, vertices: list, color: tuple[int, int, int] = (255, 165, 0), line_width: float = 3.0) -&gt; None</code>","text":"<p>Add gate/obstacle wireframes to the scene.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>vertices</code> <code>list</code> <p>List of vertex arrays (4 vertices for planar gate, 8 for box)</p> required <code>color</code> <code>tuple[int, int, int]</code> <p>RGB color tuple</p> <code>(255, 165, 0)</code> <code>line_width</code> <code>float</code> <p>Line width for wireframe</p> <code>3.0</code> Source code in <code>openscvx/plotting/viser/primitives.py</code> <pre><code>def add_gates(\n    server: viser.ViserServer,\n    vertices: list,\n    color: tuple[int, int, int] = (255, 165, 0),\n    line_width: float = 3.0,\n) -&gt; None:\n    \"\"\"Add gate/obstacle wireframes to the scene.\n\n    Args:\n        server: ViserServer instance\n        vertices: List of vertex arrays (4 vertices for planar gate, 8 for box)\n        color: RGB color tuple\n        line_width: Line width for wireframe\n    \"\"\"\n    for i, verts in enumerate(vertices):\n        verts = np.array(verts)\n        n_verts = len(verts)\n\n        if n_verts == 4:\n            # Planar gate: 4 vertices forming a closed loop\n            edges = [[0, 1], [1, 2], [2, 3], [3, 0]]\n        elif n_verts == 8:\n            # 3D box: 8 vertices\n            edges = [\n                [0, 1],\n                [1, 2],\n                [2, 3],\n                [3, 0],  # front face\n                [4, 5],\n                [5, 6],\n                [6, 7],\n                [7, 4],  # back face\n                [0, 4],\n                [1, 5],\n                [2, 6],\n                [3, 7],  # connecting edges\n            ]\n        else:\n            # Unknown format, skip\n            continue\n\n        # Shape (N, 2, 3) for N line segments\n        points = np.array([[verts[e[0]], verts[e[1]]] for e in edges])\n        server.scene.add_line_segments(\n            f\"/gates/gate_{i}\",\n            points=points,\n            colors=color,\n            line_width=line_width,\n        )\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_ghost_trajectory","title":"<code>add_ghost_trajectory(server: viser.ViserServer, pos: np.ndarray, colors: np.ndarray, opacity: float = 0.3, point_size: float = 0.05) -&gt; None</code>","text":"<p>Add a faint ghost trajectory showing the full path.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>pos</code> <code>ndarray</code> <p>Position array of shape (N, 3)</p> required <code>colors</code> <code>ndarray</code> <p>RGB color array of shape (N, 3)</p> required <code>opacity</code> <code>float</code> <p>Opacity factor (0-1) applied to colors</p> <code>0.3</code> <code>point_size</code> <code>float</code> <p>Size of trajectory points</p> <code>0.05</code> Source code in <code>openscvx/plotting/viser/primitives.py</code> <pre><code>def add_ghost_trajectory(\n    server: viser.ViserServer,\n    pos: np.ndarray,\n    colors: np.ndarray,\n    opacity: float = 0.3,\n    point_size: float = 0.05,\n) -&gt; None:\n    \"\"\"Add a faint ghost trajectory showing the full path.\n\n    Args:\n        server: ViserServer instance\n        pos: Position array of shape (N, 3)\n        colors: RGB color array of shape (N, 3)\n        opacity: Opacity factor (0-1) applied to colors\n        point_size: Size of trajectory points\n    \"\"\"\n    ghost_colors = (colors * opacity).astype(np.uint8)\n    server.scene.add_point_cloud(\n        \"/ghost_traj\",\n        points=pos,\n        colors=ghost_colors,\n        point_size=point_size,\n    )\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_glideslope_cone","title":"<code>add_glideslope_cone(server: viser.ViserServer, apex: np.ndarray | tuple = (0.0, 0.0, 0.0), height: float = 2000.0, glideslope_angle_deg: float = 86.0, axis: np.ndarray | tuple = (0.0, 0.0, 1.0), color: tuple[int, int, int] = (100, 200, 100), opacity: float = 0.2, wireframe: bool = False, n_segments: int = 32) -&gt; viser.MeshHandle</code>","text":"<p>Add a glideslope/approach constraint cone to the scene.</p> The glideslope constraint typically has the form <p>||position_perp|| &lt;= tan(angle) * position_along_axis</p> <p>This creates a cone with apex at the target, opening along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>apex</code> <code>ndarray | tuple</code> <p>Apex position (docking/landing site), default is origin</p> <code>(0.0, 0.0, 0.0)</code> <code>height</code> <code>float</code> <p>Height of the cone visualization</p> <code>2000.0</code> <code>glideslope_angle_deg</code> <code>float</code> <p>Glideslope angle in degrees (measured from axis). For constraint ||r_perp|| &lt;= tan(theta) * r_axis, pass theta here. Common values: 86 deg (very wide), 70 deg (moderate), 45 deg (steep)</p> <code>86.0</code> <code>axis</code> <code>ndarray | tuple</code> <p>Unit vector direction the cone opens toward. Default (0,0,1) for +Z. Use (-1,0,0) for R-bar approach (from below in radial direction).</p> <code>(0.0, 0.0, 1.0)</code> <code>color</code> <code>tuple[int, int, int]</code> <p>RGB color tuple</p> <code>(100, 200, 100)</code> <code>opacity</code> <code>float</code> <p>Opacity (0-1)</p> <code>0.2</code> <code>wireframe</code> <code>bool</code> <p>If True, render as wireframe</p> <code>False</code> <code>n_segments</code> <code>int</code> <p>Number of segments for cone smoothness</p> <code>32</code> <p>Returns:</p> Type Description <code>MeshHandle</code> <p>Mesh handle for the cone</p> Source code in <code>openscvx/plotting/viser/primitives.py</code> <pre><code>def add_glideslope_cone(\n    server: viser.ViserServer,\n    apex: np.ndarray | tuple = (0.0, 0.0, 0.0),\n    height: float = 2000.0,\n    glideslope_angle_deg: float = 86.0,\n    axis: np.ndarray | tuple = (0.0, 0.0, 1.0),\n    color: tuple[int, int, int] = (100, 200, 100),\n    opacity: float = 0.2,\n    wireframe: bool = False,\n    n_segments: int = 32,\n) -&gt; viser.MeshHandle:\n    \"\"\"Add a glideslope/approach constraint cone to the scene.\n\n    The glideslope constraint typically has the form:\n        ||position_perp|| &lt;= tan(angle) * position_along_axis\n\n    This creates a cone with apex at the target, opening along the specified axis.\n\n    Args:\n        server: ViserServer instance\n        apex: Apex position (docking/landing site), default is origin\n        height: Height of the cone visualization\n        glideslope_angle_deg: Glideslope angle in degrees (measured from axis).\n            For constraint ||r_perp|| &lt;= tan(theta) * r_axis, pass theta here.\n            Common values: 86 deg (very wide), 70 deg (moderate), 45 deg (steep)\n        axis: Unit vector direction the cone opens toward. Default (0,0,1) for +Z.\n            Use (-1,0,0) for R-bar approach (from below in radial direction).\n        color: RGB color tuple\n        opacity: Opacity (0-1)\n        wireframe: If True, render as wireframe\n        n_segments: Number of segments for cone smoothness\n\n    Returns:\n        Mesh handle for the cone\n    \"\"\"\n    apex = np.asarray(apex, dtype=np.float32)\n\n    vertices, faces = _generate_cone_mesh(apex, height, glideslope_angle_deg, n_segments, axis=axis)\n\n    handle = server.scene.add_mesh_simple(\n        \"/constraints/glideslope_cone\",\n        vertices=vertices,\n        faces=faces,\n        color=color,\n        wireframe=wireframe,\n        opacity=opacity if not wireframe else 1.0,\n    )\n\n    return handle\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_position_marker","title":"<code>add_position_marker(server: viser.ViserServer, pos: np.ndarray, radius: float = 0.5, color: tuple[int, int, int] = (100, 200, 255)) -&gt; tuple[viser.IcosphereHandle, UpdateCallback]</code>","text":"<p>Add an animated position marker (sphere at current position).</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>pos</code> <code>ndarray</code> <p>Position array of shape (N, 3)</p> required <code>radius</code> <code>float</code> <p>Marker radius</p> <code>0.5</code> <code>color</code> <code>tuple[int, int, int]</code> <p>RGB color tuple</p> <code>(100, 200, 255)</code> <p>Returns:</p> Type Description <code>tuple[IcosphereHandle, UpdateCallback]</code> <p>Tuple of (handle, update_callback)</p> Source code in <code>openscvx/plotting/viser/animated.py</code> <pre><code>def add_position_marker(\n    server: viser.ViserServer,\n    pos: np.ndarray,\n    radius: float = 0.5,\n    color: tuple[int, int, int] = (100, 200, 255),\n) -&gt; tuple[viser.IcosphereHandle, UpdateCallback]:\n    \"\"\"Add an animated position marker (sphere at current position).\n\n    Args:\n        server: ViserServer instance\n        pos: Position array of shape (N, 3)\n        radius: Marker radius\n        color: RGB color tuple\n\n    Returns:\n        Tuple of (handle, update_callback)\n    \"\"\"\n    handle = server.scene.add_icosphere(\n        \"/current_pos\",\n        radius=radius,\n        color=color,\n        position=pos[0],\n    )\n\n    def update(frame_idx: int) -&gt; None:\n        handle.position = pos[frame_idx]\n\n    return handle, update\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_scp_animation_controls","title":"<code>add_scp_animation_controls(server: viser.ViserServer, n_iterations: int, update_callbacks: list[UpdateCallback], autoplay: bool = False, frame_duration_ms: int = 500, folder_name: str = 'SCP Animation') -&gt; None</code>","text":"<p>Add GUI controls for stepping through SCP iterations.</p> <p>Creates play/pause button, step buttons, iteration slider, and speed control.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>n_iterations</code> <code>int</code> <p>Total number of SCP iterations</p> required <code>update_callbacks</code> <code>list[UpdateCallback]</code> <p>List of update functions to call each iteration</p> required <code>autoplay</code> <code>bool</code> <p>Whether to start playing automatically</p> <code>False</code> <code>frame_duration_ms</code> <code>int</code> <p>Default milliseconds per iteration frame</p> <code>500</code> <code>folder_name</code> <code>str</code> <p>Name for the GUI folder</p> <code>'SCP Animation'</code> Source code in <code>openscvx/plotting/viser/scp.py</code> <pre><code>def add_scp_animation_controls(\n    server: viser.ViserServer,\n    n_iterations: int,\n    update_callbacks: list[UpdateCallback],\n    autoplay: bool = False,\n    frame_duration_ms: int = 500,\n    folder_name: str = \"SCP Animation\",\n) -&gt; None:\n    \"\"\"Add GUI controls for stepping through SCP iterations.\n\n    Creates play/pause button, step buttons, iteration slider, and speed control.\n\n    Args:\n        server: ViserServer instance\n        n_iterations: Total number of SCP iterations\n        update_callbacks: List of update functions to call each iteration\n        autoplay: Whether to start playing automatically\n        frame_duration_ms: Default milliseconds per iteration frame\n        folder_name: Name for the GUI folder\n    \"\"\"\n    # Filter out None callbacks\n    callbacks = [cb for cb in update_callbacks if cb is not None]\n\n    def update_all(iter_idx: int) -&gt; None:\n        \"\"\"Update all visualization components.\"\"\"\n        for callback in callbacks:\n            callback(iter_idx)\n\n    # --- GUI Controls ---\n    with server.gui.add_folder(folder_name):\n        play_button = server.gui.add_button(\"Play\")\n        with server.gui.add_folder(\"Step Controls\", expand_by_default=False):\n            prev_button = server.gui.add_button(\"&lt; Previous\")\n            next_button = server.gui.add_button(\"Next &gt;\")\n        iter_slider = server.gui.add_slider(\n            \"Iteration\",\n            min=0,\n            max=n_iterations - 1,\n            step=1,\n            initial_value=0,\n        )\n        speed_slider = server.gui.add_slider(\n            \"Speed (ms/iter)\",\n            min=50,\n            max=2000,\n            step=50,\n            initial_value=frame_duration_ms,\n        )\n        loop_checkbox = server.gui.add_checkbox(\"Loop\", initial_value=True)\n\n    # Animation state\n    state = {\"playing\": autoplay, \"iteration\": 0, \"needs_update\": True}\n\n    @play_button.on_click\n    def _(_) -&gt; None:\n        state[\"playing\"] = not state[\"playing\"]\n        state[\"needs_update\"] = True  # Trigger immediate update on play\n        play_button.name = \"Pause\" if state[\"playing\"] else \"Play\"\n\n    @prev_button.on_click\n    def _(_) -&gt; None:\n        if state[\"iteration\"] &gt; 0:\n            state[\"iteration\"] -= 1\n            iter_slider.value = state[\"iteration\"]\n            update_all(state[\"iteration\"])\n\n    @next_button.on_click\n    def _(_) -&gt; None:\n        if state[\"iteration\"] &lt; n_iterations - 1:\n            state[\"iteration\"] += 1\n            iter_slider.value = state[\"iteration\"]\n            update_all(state[\"iteration\"])\n\n    @iter_slider.on_update\n    def _(_) -&gt; None:\n        if not state[\"playing\"]:\n            state[\"iteration\"] = int(iter_slider.value)\n            update_all(state[\"iteration\"])\n\n    def animation_loop() -&gt; None:\n        \"\"\"Background thread for SCP iteration playback.\"\"\"\n        last_update = time.time()\n        while True:\n            time.sleep(0.016)  # ~60 fps check rate\n\n            # Handle immediate update requests (e.g., on play button click)\n            if state[\"needs_update\"]:\n                state[\"needs_update\"] = False\n                last_update = time.time()\n                update_all(state[\"iteration\"])\n                continue\n\n            if state[\"playing\"]:\n                current_time = time.time()\n                elapsed_ms = (current_time - last_update) * 1000\n\n                if elapsed_ms &gt;= speed_slider.value:\n                    last_update = current_time\n                    state[\"iteration\"] += 1\n\n                    if state[\"iteration\"] &gt;= n_iterations:\n                        if loop_checkbox.value:\n                            state[\"iteration\"] = 0\n                        else:\n                            state[\"iteration\"] = n_iterations - 1\n                            state[\"playing\"] = False\n                            play_button.name = \"Play\"\n\n                    iter_slider.value = state[\"iteration\"]\n                    update_all(state[\"iteration\"])\n\n    # Start animation thread\n    thread = threading.Thread(target=animation_loop, daemon=True)\n    thread.start()\n\n    # Initial update to ensure first frame is fully rendered\n    update_all(0)\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_scp_ghost_iterations","title":"<code>add_scp_ghost_iterations(server: viser.ViserServer, positions: list[np.ndarray], point_size: float = 0.15, cmap_name: str = 'viridis') -&gt; tuple[list[viser.PointCloudHandle], UpdateCallback]</code>","text":"<p>Add ghost trails showing all previous SCP iterations.</p> <p>Pre-buffers point clouds for all iterations and toggles visibility for performance. Shows all previous iterations with viridis coloring to visualize convergence.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>positions</code> <code>list[ndarray]</code> <p>List of position arrays per iteration, each shape (N, 3)</p> required <code>point_size</code> <code>float</code> <p>Size of ghost points</p> <code>0.15</code> <code>cmap_name</code> <code>str</code> <p>Matplotlib colormap name for ghost colors</p> <code>'viridis'</code> <p>Returns:</p> Type Description <code>tuple[list[PointCloudHandle], UpdateCallback]</code> <p>Tuple of (list of handles, update_callback)</p> Source code in <code>openscvx/plotting/viser/scp.py</code> <pre><code>def add_scp_ghost_iterations(\n    server: viser.ViserServer,\n    positions: list[np.ndarray],\n    point_size: float = 0.15,\n    cmap_name: str = \"viridis\",\n) -&gt; tuple[list[viser.PointCloudHandle], UpdateCallback]:\n    \"\"\"Add ghost trails showing all previous SCP iterations.\n\n    Pre-buffers point clouds for all iterations and toggles visibility for performance.\n    Shows all previous iterations with viridis coloring to visualize convergence.\n\n    Args:\n        server: ViserServer instance\n        positions: List of position arrays per iteration, each shape (N, 3)\n        point_size: Size of ghost points\n        cmap_name: Matplotlib colormap name for ghost colors\n\n    Returns:\n        Tuple of (list of handles, update_callback)\n    \"\"\"\n    n_iterations = len(positions)\n    cmap = plt.get_cmap(cmap_name)\n\n    # Pre-create point clouds for all iterations with their colors\n    # (all initially hidden, shown progressively as ghosts)\n    handles = []\n    for i in range(n_iterations):\n        t = i / max(n_iterations - 1, 1)\n        rgb = cmap(t)[:3]\n        color = np.array([int(c * 255) for c in rgb], dtype=np.uint8)\n        pos = np.asarray(positions[i], dtype=np.float32)\n\n        handle = server.scene.add_point_cloud(\n            f\"/scp/ghosts/iter_{i}\",\n            points=pos,\n            colors=color,\n            point_size=point_size,\n            visible=False,  # All start hidden\n        )\n        handles.append(handle)\n\n    # Track which iterations are currently visible as ghosts\n    state = {\"visible_up_to\": -1}\n\n    def update(iter_idx: int) -&gt; None:\n        idx = min(iter_idx, n_iterations - 1)\n        # Ghosts are iterations 0 through idx-1 (everything before current)\n        new_visible_up_to = idx - 1\n\n        if new_visible_up_to != state[\"visible_up_to\"]:\n            # Show/hide only the iterations that changed\n            if new_visible_up_to &gt; state[\"visible_up_to\"]:\n                # Show newly visible ghosts\n                for i in range(state[\"visible_up_to\"] + 1, new_visible_up_to + 1):\n                    handles[i].visible = True\n            else:\n                # Hide ghosts that should no longer be visible\n                for i in range(new_visible_up_to + 1, state[\"visible_up_to\"] + 1):\n                    handles[i].visible = False\n            state[\"visible_up_to\"] = new_visible_up_to\n\n    return handles, update\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_scp_iteration_attitudes","title":"<code>add_scp_iteration_attitudes(server: viser.ViserServer, positions: list[np.ndarray], attitudes: list[np.ndarray] | None, axes_length: float = 1.5, axes_radius: float = 0.03, stride: int = 1) -&gt; tuple[list[viser.FrameHandle], UpdateCallback | None]</code>","text":"<p>Add animated attitude frames at each node that update per SCP iteration.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>positions</code> <code>list[ndarray]</code> <p>List of position arrays per iteration, each shape (N, 3)</p> required <code>attitudes</code> <code>list[ndarray] | None</code> <p>List of quaternion arrays per iteration, each shape (N, 4) in wxyz format. If None, returns empty list and None callback.</p> required <code>axes_length</code> <code>float</code> <p>Length of coordinate frame axes</p> <code>1.5</code> <code>axes_radius</code> <code>float</code> <p>Radius of axes cylinders</p> <code>0.03</code> <code>stride</code> <code>int</code> <p>Show attitude frame every <code>stride</code> nodes (1 = all nodes)</p> <code>1</code> <p>Returns:</p> Type Description <code>tuple[list[FrameHandle], UpdateCallback | None]</code> <p>Tuple of (list of frame handles, update_callback)</p> Source code in <code>openscvx/plotting/viser/scp.py</code> <pre><code>def add_scp_iteration_attitudes(\n    server: viser.ViserServer,\n    positions: list[np.ndarray],\n    attitudes: list[np.ndarray] | None,\n    axes_length: float = 1.5,\n    axes_radius: float = 0.03,\n    stride: int = 1,\n) -&gt; tuple[list[viser.FrameHandle], UpdateCallback | None]:\n    \"\"\"Add animated attitude frames at each node that update per SCP iteration.\n\n    Args:\n        server: ViserServer instance\n        positions: List of position arrays per iteration, each shape (N, 3)\n        attitudes: List of quaternion arrays per iteration, each shape (N, 4) in wxyz format.\n            If None, returns empty list and None callback.\n        axes_length: Length of coordinate frame axes\n        axes_radius: Radius of axes cylinders\n        stride: Show attitude frame every `stride` nodes (1 = all nodes)\n\n    Returns:\n        Tuple of (list of frame handles, update_callback)\n    \"\"\"\n    if attitudes is None:\n        return [], None\n\n    n_iterations = len(positions)\n    n_nodes = len(positions[0])\n\n    # Create frame handles for nodes at stride intervals\n    node_indices = list(range(0, n_nodes, stride))\n    handles = []\n\n    for i, node_idx in enumerate(node_indices):\n        handle = server.scene.add_frame(\n            f\"/scp/attitudes/frame_{i}\",\n            wxyz=attitudes[0][node_idx],\n            position=positions[0][node_idx],\n            axes_length=axes_length,\n            axes_radius=axes_radius,\n        )\n        handles.append(handle)\n\n    def update(iter_idx: int) -&gt; None:\n        idx = min(iter_idx, n_iterations - 1)\n        pos = positions[idx]\n        att = attitudes[idx]\n\n        for i, node_idx in enumerate(node_indices):\n            # Handle case where number of nodes changes between iterations\n            if node_idx &lt; len(pos) and node_idx &lt; len(att):\n                handles[i].position = pos[node_idx]\n                handles[i].wxyz = att[node_idx]\n\n    return handles, update\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_scp_iteration_nodes","title":"<code>add_scp_iteration_nodes(server: viser.ViserServer, positions: list[np.ndarray], colors: list[tuple[int, int, int]] | None = None, point_size: float = 0.3, cmap_name: str = 'viridis') -&gt; tuple[list[viser.PointCloudHandle], UpdateCallback]</code>","text":"<p>Add animated optimization nodes that update per SCP iteration.</p> <p>Pre-buffers point clouds for all iterations and toggles visibility for performance. This avoids transmitting point data on every frame update.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>positions</code> <code>list[ndarray]</code> <p>List of position arrays per iteration, each shape (N, 3)</p> required <code>colors</code> <code>list[tuple[int, int, int]] | None</code> <p>Optional list of RGB colors per iteration. If None, uses viridis colormap.</p> <code>None</code> <code>point_size</code> <code>float</code> <p>Size of node markers</p> <code>0.3</code> <code>cmap_name</code> <code>str</code> <p>Matplotlib colormap name (default: \"viridis\")</p> <code>'viridis'</code> <p>Returns:</p> Type Description <code>tuple[list[PointCloudHandle], UpdateCallback]</code> <p>Tuple of (list of point_handles, update_callback)</p> Source code in <code>openscvx/plotting/viser/scp.py</code> <pre><code>def add_scp_iteration_nodes(\n    server: viser.ViserServer,\n    positions: list[np.ndarray],\n    colors: list[tuple[int, int, int]] | None = None,\n    point_size: float = 0.3,\n    cmap_name: str = \"viridis\",\n) -&gt; tuple[list[viser.PointCloudHandle], UpdateCallback]:\n    \"\"\"Add animated optimization nodes that update per SCP iteration.\n\n    Pre-buffers point clouds for all iterations and toggles visibility for performance.\n    This avoids transmitting point data on every frame update.\n\n    Args:\n        server: ViserServer instance\n        positions: List of position arrays per iteration, each shape (N, 3)\n        colors: Optional list of RGB colors per iteration. If None, uses viridis colormap.\n        point_size: Size of node markers\n        cmap_name: Matplotlib colormap name (default: \"viridis\")\n\n    Returns:\n        Tuple of (list of point_handles, update_callback)\n    \"\"\"\n    n_iterations = len(positions)\n\n    # Default: use viridis colormap\n    if colors is None:\n        cmap = plt.get_cmap(cmap_name)\n        colors = []\n        for i in range(n_iterations):\n            t = i / max(n_iterations - 1, 1)\n            rgb = cmap(t)[:3]\n            colors.append(tuple(int(c * 255) for c in rgb))\n\n    # Convert colors to numpy arrays for viser compatibility\n    colors_np = [np.array([c[0], c[1], c[2]], dtype=np.uint8) for c in colors]\n\n    # Pre-create point clouds for all iterations (only first visible initially)\n    handles = []\n    for i in range(n_iterations):\n        pos = np.asarray(positions[i], dtype=np.float32)\n        handle = server.scene.add_point_cloud(\n            f\"/scp/nodes/iter_{i}\",\n            points=pos,\n            colors=colors_np[i],\n            point_size=point_size,\n            visible=(i == 0),\n        )\n        handles.append(handle)\n\n    # Track current visible iteration to minimize visibility toggles\n    state = {\"current_idx\": 0}\n\n    def update(iter_idx: int) -&gt; None:\n        idx = min(iter_idx, n_iterations - 1)\n        if idx != state[\"current_idx\"]:\n            handles[state[\"current_idx\"]].visible = False\n            handles[idx].visible = True\n            state[\"current_idx\"] = idx\n\n    return handles, update\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_scp_propagation_lines","title":"<code>add_scp_propagation_lines(server: viser.ViserServer, propagations: list[list[np.ndarray]], line_width: float = 2.0, cmap_name: str = 'viridis') -&gt; tuple[list, UpdateCallback]</code>","text":"<p>Add animated nonlinear propagation lines that update per SCP iteration.</p> <p>Shows the actual integrated trajectory between optimization nodes, revealing defects (gaps) in early iterations that close as SCP converges. All iterations up to the current one are shown with viridis coloring, similar to ghost iterations for nodes.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>propagations</code> <code>list[list[ndarray]]</code> <p>List of propagation trajectories per iteration from extract_propagation_positions(). Each iteration contains a list of (n_substeps, 3) position arrays, one per segment.</p> required <code>line_width</code> <code>float</code> <p>Width of propagation lines</p> <code>2.0</code> <code>cmap_name</code> <code>str</code> <p>Matplotlib colormap name (default: \"viridis\")</p> <code>'viridis'</code> <p>Returns:</p> Type Description <code>tuple[list, UpdateCallback]</code> <p>Tuple of (list of line handles, update_callback)</p> Source code in <code>openscvx/plotting/viser/scp.py</code> <pre><code>def add_scp_propagation_lines(\n    server: viser.ViserServer,\n    propagations: list[list[np.ndarray]],\n    line_width: float = 2.0,\n    cmap_name: str = \"viridis\",\n) -&gt; tuple[list, UpdateCallback]:\n    \"\"\"Add animated nonlinear propagation lines that update per SCP iteration.\n\n    Shows the actual integrated trajectory between optimization nodes,\n    revealing defects (gaps) in early iterations that close as SCP converges.\n    All iterations up to the current one are shown with viridis coloring,\n    similar to ghost iterations for nodes.\n\n    Args:\n        server: ViserServer instance\n        propagations: List of propagation trajectories per iteration from\n            extract_propagation_positions(). Each iteration contains a list\n            of (n_substeps, 3) position arrays, one per segment.\n        line_width: Width of propagation lines\n        cmap_name: Matplotlib colormap name (default: \"viridis\")\n\n    Returns:\n        Tuple of (list of line handles, update_callback)\n    \"\"\"\n    if not propagations:\n        return [], lambda _: None\n\n    n_iterations = len(propagations)\n    n_segments = len(propagations[0])\n    cmap = plt.get_cmap(cmap_name)\n\n    # Pre-compute colors for each iteration\n    iteration_colors = []\n    for i in range(n_iterations):\n        t = i / max(n_iterations - 1, 1)\n        rgb = cmap(t)[:3]\n        iteration_colors.append(np.array([int(c * 255) for c in rgb], dtype=np.uint8))\n\n    # Create line handles for each (iteration, segment) pair\n    # Structure: handles[iter_idx][seg_idx]\n    all_handles = []\n\n    for iter_idx in range(n_iterations):\n        iter_handles = []\n        color = iteration_colors[iter_idx]\n\n        for seg_idx in range(n_segments):\n            seg_pos = propagations[iter_idx][seg_idx]  # Shape (n_substeps, 3)\n\n            if len(seg_pos) &lt; 2:\n                iter_handles.append(None)\n                continue\n\n            # Create line segments connecting consecutive substeps\n            segments = np.array(\n                [[seg_pos[i], seg_pos[i + 1]] for i in range(len(seg_pos) - 1)],\n                dtype=np.float32,\n            )\n\n            handle = server.scene.add_line_segments(\n                f\"/scp/propagation/iter_{iter_idx}/segment_{seg_idx}\",\n                points=segments,\n                colors=color,\n                line_width=line_width,\n                visible=(iter_idx == 0),  # Only first iteration visible initially\n            )\n            iter_handles.append(handle)\n\n        all_handles.append(iter_handles)\n\n    def update(iter_idx: int) -&gt; None:\n        idx = min(iter_idx, n_iterations - 1)\n\n        # Show all iterations up to and including current, hide the rest\n        for i in range(n_iterations):\n            should_show = i &lt;= idx\n            for handle in all_handles[i]:\n                if handle is not None:\n                    handle.visible = should_show\n\n    return all_handles, update\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_target_marker","title":"<code>add_target_marker(server: viser.ViserServer, target_pos: np.ndarray, name: str = 'target', radius: float = 0.8, color: tuple[int, int, int] = (255, 50, 50), show_trail: bool = True, trail_color: tuple[int, int, int] | None = None) -&gt; tuple[viser.IcosphereHandle, UpdateCallback | None]</code>","text":"<p>Add a viewplanning target marker (static or moving).</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>target_pos</code> <code>ndarray</code> <p>Target position - either shape (3,) for static or (N, 3) for moving</p> required <code>name</code> <code>str</code> <p>Unique name for this target (used in scene path)</p> <code>'target'</code> <code>radius</code> <code>float</code> <p>Marker radius</p> <code>0.8</code> <code>color</code> <code>tuple[int, int, int]</code> <p>RGB color tuple for marker</p> <code>(255, 50, 50)</code> <code>show_trail</code> <code>bool</code> <p>If True and target is moving, show trajectory trail</p> <code>True</code> <code>trail_color</code> <code>tuple[int, int, int] | None</code> <p>RGB color for trail (defaults to dimmed marker color)</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[IcosphereHandle, UpdateCallback | None]</code> <p>Tuple of (handle, update_callback). update_callback is None for static targets.</p> Source code in <code>openscvx/plotting/viser/animated.py</code> <pre><code>def add_target_marker(\n    server: viser.ViserServer,\n    target_pos: np.ndarray,\n    name: str = \"target\",\n    radius: float = 0.8,\n    color: tuple[int, int, int] = (255, 50, 50),\n    show_trail: bool = True,\n    trail_color: tuple[int, int, int] | None = None,\n) -&gt; tuple[viser.IcosphereHandle, UpdateCallback | None]:\n    \"\"\"Add a viewplanning target marker (static or moving).\n\n    Args:\n        server: ViserServer instance\n        target_pos: Target position - either shape (3,) for static or (N, 3) for moving\n        name: Unique name for this target (used in scene path)\n        radius: Marker radius\n        color: RGB color tuple for marker\n        show_trail: If True and target is moving, show trajectory trail\n        trail_color: RGB color for trail (defaults to dimmed marker color)\n\n    Returns:\n        Tuple of (handle, update_callback). update_callback is None for static targets.\n    \"\"\"\n    target_pos = np.asarray(target_pos)\n\n    # Check if static (single position) or moving (trajectory)\n    is_moving = target_pos.ndim == 2 and target_pos.shape[0] &gt; 1\n\n    initial_pos = target_pos[0] if is_moving else target_pos\n\n    # Add marker\n    handle = server.scene.add_icosphere(\n        f\"/targets/{name}/marker\",\n        radius=radius,\n        color=color,\n        position=initial_pos,\n    )\n\n    # For moving targets, optionally show trail\n    if is_moving and show_trail:\n        if trail_color is None:\n            trail_color = tuple(int(c * 0.5) for c in color)\n        server.scene.add_point_cloud(\n            f\"/targets/{name}/trail\",\n            points=target_pos,\n            colors=trail_color,\n            point_size=0.1,\n        )\n\n    if not is_moving:\n        # Static target - no update needed\n        return handle, None\n\n    def update(frame_idx: int) -&gt; None:\n        # Clamp to valid range for target trajectory\n        idx = min(frame_idx, len(target_pos) - 1)\n        handle.position = target_pos[idx]\n\n    return handle, update\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_target_markers","title":"<code>add_target_markers(server: viser.ViserServer, target_positions: list[np.ndarray], colors: list[tuple[int, int, int]] | None = None, radius: float = 0.8, show_trails: bool = True) -&gt; list[tuple[viser.IcosphereHandle, UpdateCallback | None]]</code>","text":"<p>Add multiple viewplanning target markers.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>target_positions</code> <code>list[ndarray]</code> <p>List of target positions, each either (3,) or (N, 3)</p> required <code>colors</code> <code>list[tuple[int, int, int]] | None</code> <p>List of RGB colors, one per target. Defaults to distinct colors.</p> <code>None</code> <code>radius</code> <code>float</code> <p>Marker radius</p> <code>0.8</code> <code>show_trails</code> <code>bool</code> <p>If True, show trails for moving targets</p> <code>True</code> <p>Returns:</p> Type Description <code>list[tuple[IcosphereHandle, UpdateCallback | None]]</code> <p>List of (handle, update_callback) tuples</p> Source code in <code>openscvx/plotting/viser/animated.py</code> <pre><code>def add_target_markers(\n    server: viser.ViserServer,\n    target_positions: list[np.ndarray],\n    colors: list[tuple[int, int, int]] | None = None,\n    radius: float = 0.8,\n    show_trails: bool = True,\n) -&gt; list[tuple[viser.IcosphereHandle, UpdateCallback | None]]:\n    \"\"\"Add multiple viewplanning target markers.\n\n    Args:\n        server: ViserServer instance\n        target_positions: List of target positions, each either (3,) or (N, 3)\n        colors: List of RGB colors, one per target. Defaults to distinct colors.\n        radius: Marker radius\n        show_trails: If True, show trails for moving targets\n\n    Returns:\n        List of (handle, update_callback) tuples\n    \"\"\"\n    # Default colors if not provided\n    if colors is None:\n        default_colors = [\n            (255, 50, 50),  # Red\n            (50, 255, 50),  # Green\n            (50, 50, 255),  # Blue\n            (255, 255, 50),  # Yellow\n            (255, 50, 255),  # Magenta\n            (50, 255, 255),  # Cyan\n        ]\n        colors = [default_colors[i % len(default_colors)] for i in range(len(target_positions))]\n\n    results = []\n    for i, (pos, color) in enumerate(zip(target_positions, colors)):\n        handle, update = add_target_marker(\n            server,\n            pos,\n            name=f\"target_{i}\",\n            radius=radius,\n            color=color,\n            show_trail=show_trails,\n        )\n        results.append((handle, update))\n\n    return results\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_thrust_vector","title":"<code>add_thrust_vector(server: viser.ViserServer, pos: np.ndarray, thrust: np.ndarray | None, attitude: np.ndarray | None = None, scale: float = 0.3, color: tuple[int, int, int] = (255, 100, 100), line_width: float = 4.0) -&gt; tuple[viser.LineSegmentsHandle | None, UpdateCallback | None]</code>","text":"<p>Add an animated thrust/force vector visualization.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>pos</code> <code>ndarray</code> <p>Position array of shape (N, 3)</p> required <code>thrust</code> <code>ndarray | None</code> <p>Thrust/force array of shape (N, 3), or None to skip</p> required <code>attitude</code> <code>ndarray | None</code> <p>Quaternion array of shape (N, 4) in [w, x, y, z] format. If provided, thrust is assumed to be in body frame and will be rotated to world frame using the attitude.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Scale factor for thrust vector length</p> <code>0.3</code> <code>color</code> <code>tuple[int, int, int]</code> <p>RGB color tuple</p> <code>(255, 100, 100)</code> <code>line_width</code> <code>float</code> <p>Line width</p> <code>4.0</code> <p>Returns:</p> Type Description <code>tuple[LineSegmentsHandle | None, UpdateCallback | None]</code> <p>Tuple of (handle, update_callback), or (None, None) if thrust is None</p> Source code in <code>openscvx/plotting/viser/animated.py</code> <pre><code>def add_thrust_vector(\n    server: viser.ViserServer,\n    pos: np.ndarray,\n    thrust: np.ndarray | None,\n    attitude: np.ndarray | None = None,\n    scale: float = 0.3,\n    color: tuple[int, int, int] = (255, 100, 100),\n    line_width: float = 4.0,\n) -&gt; tuple[viser.LineSegmentsHandle | None, UpdateCallback | None]:\n    \"\"\"Add an animated thrust/force vector visualization.\n\n    Args:\n        server: ViserServer instance\n        pos: Position array of shape (N, 3)\n        thrust: Thrust/force array of shape (N, 3), or None to skip\n        attitude: Quaternion array of shape (N, 4) in [w, x, y, z] format.\n            If provided, thrust is assumed to be in body frame and will be\n            rotated to world frame using the attitude.\n        scale: Scale factor for thrust vector length\n        color: RGB color tuple\n        line_width: Line width\n\n    Returns:\n        Tuple of (handle, update_callback), or (None, None) if thrust is None\n    \"\"\"\n    if thrust is None:\n        return None, None\n\n    def get_thrust_world(frame_idx: int) -&gt; np.ndarray:\n        \"\"\"Get thrust vector in world frame.\"\"\"\n        thrust_body = thrust[frame_idx]\n        if attitude is not None:\n            return _rotate_vector_by_quaternion(thrust_body, attitude[frame_idx])\n        return thrust_body\n\n    thrust_world = get_thrust_world(0)\n    thrust_end = pos[0] + thrust_world * scale\n    handle = server.scene.add_line_segments(\n        \"/thrust_vector\",\n        points=np.array([[pos[0], thrust_end]]),  # Shape (1, 2, 3)\n        colors=color,\n        line_width=line_width,\n    )\n\n    def update(frame_idx: int) -&gt; None:\n        thrust_world = get_thrust_world(frame_idx)\n        thrust_end = pos[frame_idx] + thrust_world * scale\n        handle.points = np.array([[pos[frame_idx], thrust_end]])\n\n    return handle, update\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.add_viewcone","title":"<code>add_viewcone(server: viser.ViserServer, pos: np.ndarray, attitude: np.ndarray | None, half_angle_x: float, half_angle_y: float | None = None, scale: float = 10.0, norm_type: float | str = 2, R_sb: np.ndarray | None = None, color: tuple[int, int, int] = (35, 138, 141), opacity: float = 0.4, wireframe: bool = False, n_segments: int = 32) -&gt; tuple[viser.MeshHandle | None, UpdateCallback | None]</code>","text":"<p>Add an animated viewcone mesh that matches p-norm constraints.</p> <p>The sensor is assumed to look along +Z in its own frame (boresight = [0,0,1]). The viewcone represents the constraint ||[x,y]||_p &lt;= tan(alpha) * z.</p> Cross-section shapes by norm <ul> <li>p=1: diamond</li> <li>p=2: circle/ellipse</li> <li>p&gt;2: rounded square (superellipse)</li> <li>p=inf: square/rectangle</li> </ul> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>pos</code> <code>ndarray</code> <p>Position array of shape (N, 3)</p> required <code>attitude</code> <code>ndarray | None</code> <p>Quaternion array of shape (N, 4) in [w, x, y, z] format, or None to skip</p> required <code>half_angle_x</code> <code>float</code> <p>Half-angle of the cone in x direction (radians). For symmetric cones, this is pi/alpha_x where alpha_x is the constraint parameter.</p> required <code>half_angle_y</code> <code>float | None</code> <p>Half-angle in y direction (radians). If None, uses half_angle_x. For asymmetric constraints, this is pi/alpha_y.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Depth/length of the cone visualization</p> <code>10.0</code> <code>norm_type</code> <code>float | str</code> <p>p-norm value (1, 2, 3, ..., or \"inf\" for infinity norm)</p> <code>2</code> <code>R_sb</code> <code>ndarray | None</code> <p>Body-to-sensor rotation matrix (3x3). If None, sensor is aligned with body z-axis.</p> <code>None</code> <code>color</code> <code>tuple[int, int, int]</code> <p>RGB color tuple</p> <code>(35, 138, 141)</code> <code>opacity</code> <code>float</code> <p>Mesh opacity (0-1), ignored if wireframe=True</p> <code>0.4</code> <code>wireframe</code> <code>bool</code> <p>If True, render as wireframe instead of solid</p> <code>False</code> <code>n_segments</code> <code>int</code> <p>Number of segments for cone smoothness</p> <code>32</code> <p>Returns:</p> Type Description <code>tuple[MeshHandle | None, UpdateCallback | None]</code> <p>Tuple of (handle, update_callback), or (None, None) if attitude is None</p> Source code in <code>openscvx/plotting/viser/animated.py</code> <pre><code>def add_viewcone(\n    server: viser.ViserServer,\n    pos: np.ndarray,\n    attitude: np.ndarray | None,\n    half_angle_x: float,\n    half_angle_y: float | None = None,\n    scale: float = 10.0,\n    norm_type: float | str = 2,\n    R_sb: np.ndarray | None = None,\n    color: tuple[int, int, int] = (35, 138, 141),  # Viridis at t~0.33 (teal)\n    opacity: float = 0.4,\n    wireframe: bool = False,\n    n_segments: int = 32,\n) -&gt; tuple[viser.MeshHandle | None, UpdateCallback | None]:\n    \"\"\"Add an animated viewcone mesh that matches p-norm constraints.\n\n    The sensor is assumed to look along +Z in its own frame (boresight = [0,0,1]).\n    The viewcone represents the constraint ||[x,y]||_p &lt;= tan(alpha) * z.\n\n    Cross-section shapes by norm:\n        - p=1: diamond\n        - p=2: circle/ellipse\n        - p&gt;2: rounded square (superellipse)\n        - p=inf: square/rectangle\n\n    Args:\n        server: ViserServer instance\n        pos: Position array of shape (N, 3)\n        attitude: Quaternion array of shape (N, 4) in [w, x, y, z] format, or None to skip\n        half_angle_x: Half-angle of the cone in x direction (radians).\n            For symmetric cones, this is pi/alpha_x where alpha_x is the constraint parameter.\n        half_angle_y: Half-angle in y direction (radians). If None, uses half_angle_x.\n            For asymmetric constraints, this is pi/alpha_y.\n        scale: Depth/length of the cone visualization\n        norm_type: p-norm value (1, 2, 3, ..., or \"inf\" for infinity norm)\n        R_sb: Body-to-sensor rotation matrix (3x3). If None, sensor is aligned with body z-axis.\n        color: RGB color tuple\n        opacity: Mesh opacity (0-1), ignored if wireframe=True\n        wireframe: If True, render as wireframe instead of solid\n        n_segments: Number of segments for cone smoothness\n\n    Returns:\n        Tuple of (handle, update_callback), or (None, None) if attitude is None\n    \"\"\"\n    if attitude is None:\n        return None, None\n\n    # Convert inputs to numpy arrays (handles JAX arrays)\n    pos = np.asarray(pos, dtype=np.float64)\n    attitude = np.asarray(attitude, dtype=np.float64)\n    if R_sb is not None:\n        R_sb = np.asarray(R_sb, dtype=np.float64)\n\n    # Generate base geometry in sensor frame\n    base_vertices = _generate_viewcone_vertices(\n        half_angle_x, half_angle_y, scale, norm_type, n_segments\n    )\n    n_base_verts = len(base_vertices) - 1  # Exclude apex\n    faces = _generate_viewcone_faces(n_base_verts)\n\n    # Sensor-to-body rotation (transpose of body-to-sensor)\n    R_sensor_to_body = R_sb.T if R_sb is not None else np.eye(3)\n\n    def transform_vertices(frame_idx: int) -&gt; np.ndarray:\n        \"\"\"Transform cone vertices from sensor frame to world frame.\"\"\"\n        # Get body-to-world rotation from attitude quaternion\n        q_body = attitude[frame_idx]\n        R_body_to_world = _quaternion_to_rotation_matrix(q_body)\n\n        # Full transform: sensor -&gt; body -&gt; world\n        R_sensor_to_world = R_body_to_world @ R_sensor_to_body\n\n        # Transform vertices and translate to position\n        world_vertices = (R_sensor_to_world @ base_vertices.T).T + pos[frame_idx]\n        return world_vertices.astype(np.float32)\n\n    # Create initial mesh\n    initial_vertices = transform_vertices(0)\n    handle = server.scene.add_mesh_simple(\n        \"/viewcone_mesh\",\n        vertices=initial_vertices,\n        faces=faces,\n        color=color,\n        wireframe=wireframe,\n        opacity=opacity if not wireframe else 1.0,\n    )\n\n    def update(frame_idx: int) -&gt; None:\n        handle.vertices = transform_vertices(frame_idx)\n\n    return handle, update\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.compute_grid_size","title":"<code>compute_grid_size(pos: np.ndarray, padding: float = 1.2) -&gt; float</code>","text":"<p>Compute grid size based on trajectory extent.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>ndarray</code> <p>Position array of shape (N, 3)</p> required <code>padding</code> <code>float</code> <p>Padding factor (1.2 = 20% padding)</p> <code>1.2</code> <p>Returns:</p> Type Description <code>float</code> <p>Grid size (width and height)</p> Source code in <code>openscvx/plotting/viser/server.py</code> <pre><code>def compute_grid_size(pos: np.ndarray, padding: float = 1.2) -&gt; float:\n    \"\"\"Compute grid size based on trajectory extent.\n\n    Args:\n        pos: Position array of shape (N, 3)\n        padding: Padding factor (1.2 = 20% padding)\n\n    Returns:\n        Grid size (width and height)\n    \"\"\"\n    max_x = np.abs(pos[:, 0]).max()\n    max_y = np.abs(pos[:, 1]).max()\n    return max(max_x, max_y) * 2 * padding\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.compute_velocity_colors","title":"<code>compute_velocity_colors(vel: np.ndarray, cmap_name: str = 'viridis') -&gt; np.ndarray</code>","text":"<p>Compute RGB colors based on velocity magnitude.</p> <p>Parameters:</p> Name Type Description Default <code>vel</code> <code>ndarray</code> <p>Velocity array of shape (N, 3)</p> required <code>cmap_name</code> <code>str</code> <p>Matplotlib colormap name</p> <code>'viridis'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of RGB colors with shape (N, 3), values in [0, 255]</p> Source code in <code>openscvx/plotting/viser/server.py</code> <pre><code>def compute_velocity_colors(vel: np.ndarray, cmap_name: str = \"viridis\") -&gt; np.ndarray:\n    \"\"\"Compute RGB colors based on velocity magnitude.\n\n    Args:\n        vel: Velocity array of shape (N, 3)\n        cmap_name: Matplotlib colormap name\n\n    Returns:\n        Array of RGB colors with shape (N, 3), values in [0, 255]\n    \"\"\"\n    vel_norms = np.linalg.norm(vel, axis=1)\n    vel_range = vel_norms.max() - vel_norms.min()\n    if vel_range &lt; 1e-8:\n        vel_normalized = np.zeros_like(vel_norms)\n    else:\n        vel_normalized = (vel_norms - vel_norms.min()) / vel_range\n\n    cmap = plt.get_cmap(cmap_name)\n    colors = np.array([[int(c * 255) for c in cmap(v)[:3]] for v in vel_normalized])\n    return colors\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.create_server","title":"<code>create_server(pos: np.ndarray, dark_mode: bool = True, show_grid: bool = True) -&gt; viser.ViserServer</code>","text":"<p>Create a viser server with basic scene setup.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>ndarray</code> <p>Position array for computing grid size</p> required <code>dark_mode</code> <code>bool</code> <p>Whether to use dark theme</p> <code>True</code> <code>show_grid</code> <code>bool</code> <p>Whether to show the grid (default True)</p> <code>True</code> <p>Returns:</p> Type Description <code>ViserServer</code> <p>ViserServer instance with grid and origin frame</p> Source code in <code>openscvx/plotting/viser/server.py</code> <pre><code>def create_server(\n    pos: np.ndarray,\n    dark_mode: bool = True,\n    show_grid: bool = True,\n) -&gt; viser.ViserServer:\n    \"\"\"Create a viser server with basic scene setup.\n\n    Args:\n        pos: Position array for computing grid size\n        dark_mode: Whether to use dark theme\n        show_grid: Whether to show the grid (default True)\n\n    Returns:\n        ViserServer instance with grid and origin frame\n    \"\"\"\n    server = viser.ViserServer()\n\n    # Configure theme with OpenSCvx branding\n    # TitlebarButton and TitlebarConfig are TypedDict classes (create as plain dicts)\n    buttons = (\n        TitlebarButton(\n            text=\"Getting Started\",\n            icon=\"Description\",\n            href=\"https://haynec.github.io/OpenSCvx/latest/getting-started/\",\n        ),\n        TitlebarButton(\n            text=\"Docs\",\n            icon=\"Description\",\n            href=\"https://haynec.github.io/OpenSCvx/\",\n        ),\n        TitlebarButton(\n            text=\"GitHub\",\n            icon=\"GitHub\",\n            href=\"https://github.com/haynec/OpenSCvx\",\n        ),\n    )\n\n    # Add OpenSCvx logo to titlebar (loaded from GitHub)\n    logo_url = (\n        \"https://raw.githubusercontent.com/haynec/OpenSCvx/main/figures/openscvx_logo_square.png\"\n    )\n    image = TitlebarImage(\n        image_url_light=logo_url,\n        image_url_dark=logo_url,  # Use same logo for both themes\n        image_alt=\"OpenSCvx\",\n        href=\"https://github.com/haynec/OpenSCvx\",\n    )\n\n    titlebar_config = TitlebarConfig(buttons=buttons, image=image)\n\n    server.gui.configure_theme(\n        titlebar_content=titlebar_config,\n        dark_mode=dark_mode,\n    )\n\n    if show_grid:\n        grid_size = compute_grid_size(pos)\n        server.scene.add_grid(\n            \"/grid\",\n            width=grid_size,\n            height=grid_size,\n            position=np.array([0.0, 0.0, 0.0]),\n        )\n    server.scene.add_frame(\n        \"/origin\",\n        wxyz=(1.0, 0.0, 0.0, 0.0),\n        position=(0.0, 0.0, 0.0),\n    )\n\n    return server\n</code></pre>"},{"location":"reference/plotting/viser/#openscvx.plotting.viser.extract_propagation_positions","title":"<code>extract_propagation_positions(discretization_history: list[np.ndarray], n_x: int, n_u: int, position_slice: slice, scene_scale: float = 1.0) -&gt; list[list[np.ndarray]]</code>","text":"<p>Extract 3D position trajectories from discretization history.</p> <p>The discretization history contains the multi-shot integration results. Each V matrix has shape (flattened_size, n_timesteps) where: - flattened_size = (N-1) * i4 - i4 = n_x + n_x*n_x + 2*n_x*n_u (state + STM + control influence matrices) - n_timesteps = number of integration substeps</p> <p>Parameters:</p> Name Type Description Default <code>discretization_history</code> <code>list[ndarray]</code> <p>List of V matrices from each SCP iteration</p> required <code>n_x</code> <code>int</code> <p>Number of states</p> required <code>n_u</code> <code>int</code> <p>Number of controls</p> required <code>position_slice</code> <code>slice</code> <p>Slice for extracting position from state vector</p> required <code>scene_scale</code> <code>float</code> <p>Divide positions by this factor for visualization</p> <code>1.0</code> <p>Returns:</p> Type Description <code>list[list[ndarray]]</code> <p>List of propagation trajectories per iteration.</p> <code>list[list[ndarray]]</code> <p>Each iteration contains a list of (n_substeps, 3) arrays, one per segment.</p> Source code in <code>openscvx/plotting/viser/scp.py</code> <pre><code>def extract_propagation_positions(\n    discretization_history: list[np.ndarray],\n    n_x: int,\n    n_u: int,\n    position_slice: slice,\n    scene_scale: float = 1.0,\n) -&gt; list[list[np.ndarray]]:\n    \"\"\"Extract 3D position trajectories from discretization history.\n\n    The discretization history contains the multi-shot integration results.\n    Each V matrix has shape (flattened_size, n_timesteps) where:\n    - flattened_size = (N-1) * i4\n    - i4 = n_x + n_x*n_x + 2*n_x*n_u (state + STM + control influence matrices)\n    - n_timesteps = number of integration substeps\n\n    Args:\n        discretization_history: List of V matrices from each SCP iteration\n        n_x: Number of states\n        n_u: Number of controls\n        position_slice: Slice for extracting position from state vector\n        scene_scale: Divide positions by this factor for visualization\n\n    Returns:\n        List of propagation trajectories per iteration.\n        Each iteration contains a list of (n_substeps, 3) arrays, one per segment.\n    \"\"\"\n    if not discretization_history:\n        return []\n\n    i4 = n_x + n_x * n_x + 2 * n_x * n_u\n    propagations = []\n\n    for V in discretization_history:\n        # V shape: (flattened_size, n_timesteps)\n        n_timesteps = V.shape[1]\n        n_segments = V.shape[0] // i4  # N-1 segments\n\n        iteration_segments = []\n        for seg_idx in range(n_segments):\n            # Extract this segment's data across all timesteps\n            seg_start = seg_idx * i4\n            seg_end = seg_start + i4\n\n            # For each timestep, extract the position from the state\n            segment_positions = []\n            for t_idx in range(n_timesteps):\n                # Get full state at this segment and timestep\n                state = V[seg_start:seg_end, t_idx][:n_x]\n                # Extract position components\n                pos = state[position_slice] / scene_scale\n                segment_positions.append(pos)\n\n            iteration_segments.append(np.array(segment_positions, dtype=np.float32))\n\n        propagations.append(iteration_segments)\n\n    return propagations\n</code></pre>"},{"location":"reference/plotting/viser/animated/","title":"animated","text":"<p>Animated scene elements for viser visualization.</p> <p>Each function in this module adds an animated element to a viser scene and returns a tuple of <code>(handle, update_callback)</code>. The update callback has signature <code>update_callback(frame_idx: int) -&gt; None</code> and updates the visual to reflect the state at that frame index.</p> <p>Collect these callbacks and pass them to <code>add_animation_controls()</code> to wire up playback with GUI controls (play/pause, scrubber, speed, etc.).</p> <p>Example::</p> <pre><code>_, update_trail = add_animated_trail(server, positions, colors)\n_, update_marker = add_position_marker(server, positions)\n_, update_thrust = add_thrust_vector(server, positions, thrust, attitude)\n\nadd_animation_controls(server, time_array, [update_trail, update_marker, update_thrust])\n</code></pre>"},{"location":"reference/plotting/viser/animated/#openscvx.plotting.viser.animated.add_animated_trail","title":"<code>add_animated_trail(server: viser.ViserServer, pos: np.ndarray, colors: np.ndarray, point_size: float = 0.15) -&gt; tuple[viser.PointCloudHandle, UpdateCallback]</code>","text":"<p>Add an animated trail that grows with the animation.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>pos</code> <code>ndarray</code> <p>Position array of shape (N, 3)</p> required <code>colors</code> <code>ndarray</code> <p>RGB color array of shape (N, 3)</p> required <code>point_size</code> <code>float</code> <p>Size of trail points</p> <code>0.15</code> <p>Returns:</p> Type Description <code>tuple[PointCloudHandle, UpdateCallback]</code> <p>Tuple of (handle, update_callback)</p> Source code in <code>openscvx/plotting/viser/animated.py</code> <pre><code>def add_animated_trail(\n    server: viser.ViserServer,\n    pos: np.ndarray,\n    colors: np.ndarray,\n    point_size: float = 0.15,\n) -&gt; tuple[viser.PointCloudHandle, UpdateCallback]:\n    \"\"\"Add an animated trail that grows with the animation.\n\n    Args:\n        server: ViserServer instance\n        pos: Position array of shape (N, 3)\n        colors: RGB color array of shape (N, 3)\n        point_size: Size of trail points\n\n    Returns:\n        Tuple of (handle, update_callback)\n    \"\"\"\n    handle = server.scene.add_point_cloud(\n        \"/trail\",\n        points=pos[:1],\n        colors=colors[:1],\n        point_size=point_size,\n    )\n\n    def update(frame_idx: int) -&gt; None:\n        idx = frame_idx + 1  # Include current frame\n        handle.points = pos[:idx]\n        handle.colors = colors[:idx]\n\n    return handle, update\n</code></pre>"},{"location":"reference/plotting/viser/animated/#openscvx.plotting.viser.animated.add_animation_controls","title":"<code>add_animation_controls(server: viser.ViserServer, traj_time: np.ndarray, update_callbacks: list[UpdateCallback], loop: bool = True, folder_name: str = 'Animation') -&gt; None</code>","text":"<p>Add animation GUI controls and start the animation loop.</p> <p>Creates play/pause button, reset button, time slider, speed slider, and loop checkbox. Runs animation in a background daemon thread.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>traj_time</code> <code>ndarray</code> <p>Time array of shape (N,) with timestamps for each frame</p> required <code>update_callbacks</code> <code>list[UpdateCallback]</code> <p>List of update functions to call each frame</p> required <code>loop</code> <code>bool</code> <p>Whether to loop animation by default</p> <code>True</code> <code>folder_name</code> <code>str</code> <p>Name for the GUI folder</p> <code>'Animation'</code> Source code in <code>openscvx/plotting/viser/animated.py</code> <pre><code>def add_animation_controls(\n    server: viser.ViserServer,\n    traj_time: np.ndarray,\n    update_callbacks: list[UpdateCallback],\n    loop: bool = True,\n    folder_name: str = \"Animation\",\n) -&gt; None:\n    \"\"\"Add animation GUI controls and start the animation loop.\n\n    Creates play/pause button, reset button, time slider, speed slider, and loop checkbox.\n    Runs animation in a background daemon thread.\n\n    Args:\n        server: ViserServer instance\n        traj_time: Time array of shape (N,) with timestamps for each frame\n        update_callbacks: List of update functions to call each frame\n        loop: Whether to loop animation by default\n        folder_name: Name for the GUI folder\n    \"\"\"\n    traj_time = traj_time.flatten()\n    n_frames = len(traj_time)\n    t_start, t_end = float(traj_time[0]), float(traj_time[-1])\n    duration = t_end - t_start\n\n    # Filter out None callbacks\n    callbacks = [cb for cb in update_callbacks if cb is not None]\n\n    def time_to_frame(t: float) -&gt; int:\n        \"\"\"Convert simulation time to frame index.\"\"\"\n        return int(np.clip(np.searchsorted(traj_time, t, side=\"right\") - 1, 0, n_frames - 1))\n\n    def update_all(sim_t: float) -&gt; None:\n        \"\"\"Update all visualization components.\"\"\"\n        idx = time_to_frame(sim_t)\n        for callback in callbacks:\n            callback(idx)\n\n    # --- GUI Controls ---\n    with server.gui.add_folder(folder_name):\n        play_button = server.gui.add_button(\"Play\")\n        reset_button = server.gui.add_button(\"Reset\")\n        time_slider = server.gui.add_slider(\n            \"Time (s)\",\n            min=t_start,\n            max=t_end,\n            step=duration / 100,\n            initial_value=t_start,\n        )\n        speed_slider = server.gui.add_slider(\n            \"Speed\",\n            min=0.1,\n            max=5.0,\n            step=0.1,\n            initial_value=1.0,\n        )\n        loop_checkbox = server.gui.add_checkbox(\"Loop\", initial_value=loop)\n\n    # Animation state\n    state = {\"playing\": False, \"sim_time\": t_start}\n\n    @play_button.on_click\n    def _(_) -&gt; None:\n        state[\"playing\"] = not state[\"playing\"]\n        play_button.name = \"Pause\" if state[\"playing\"] else \"Play\"\n\n    @reset_button.on_click\n    def _(_) -&gt; None:\n        state[\"sim_time\"] = t_start\n        time_slider.value = t_start\n        update_all(t_start)\n\n    @time_slider.on_update\n    def _(_) -&gt; None:\n        if not state[\"playing\"]:\n            state[\"sim_time\"] = float(time_slider.value)\n            update_all(state[\"sim_time\"])\n\n    def animation_loop() -&gt; None:\n        \"\"\"Background thread for realtime animation playback.\"\"\"\n        last_time = time.time()\n        while True:\n            time.sleep(0.016)  # ~60 fps\n            current_time = time.time()\n            dt = current_time - last_time\n            last_time = current_time\n\n            if state[\"playing\"]:\n                # Advance simulation time (speed=1.0 is realtime)\n                state[\"sim_time\"] += dt * speed_slider.value\n\n                if state[\"sim_time\"] &gt;= t_end:\n                    if loop_checkbox.value:\n                        state[\"sim_time\"] = t_start\n                    else:\n                        state[\"sim_time\"] = t_end\n                        state[\"playing\"] = False\n                        play_button.name = \"Play\"\n\n                time_slider.value = state[\"sim_time\"]\n                update_all(state[\"sim_time\"])\n\n    # Start animation thread\n    thread = threading.Thread(target=animation_loop, daemon=True)\n    thread.start()\n</code></pre>"},{"location":"reference/plotting/viser/animated/#openscvx.plotting.viser.animated.add_attitude_frame","title":"<code>add_attitude_frame(server: viser.ViserServer, pos: np.ndarray, attitude: np.ndarray | None, axes_length: float = 2.0, axes_radius: float = 0.05) -&gt; tuple[viser.FrameHandle | None, UpdateCallback | None]</code>","text":"<p>Add an animated body coordinate frame showing attitude.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>pos</code> <code>ndarray</code> <p>Position array of shape (N, 3)</p> required <code>attitude</code> <code>ndarray | None</code> <p>Quaternion array of shape (N, 4) in [w, x, y, z] format, or None to skip</p> required <code>axes_length</code> <code>float</code> <p>Length of the coordinate axes</p> <code>2.0</code> <code>axes_radius</code> <code>float</code> <p>Radius of the axes cylinders</p> <code>0.05</code> <p>Returns:</p> Type Description <code>tuple[FrameHandle | None, UpdateCallback | None]</code> <p>Tuple of (handle, update_callback), or (None, None) if attitude is None</p> Source code in <code>openscvx/plotting/viser/animated.py</code> <pre><code>def add_attitude_frame(\n    server: viser.ViserServer,\n    pos: np.ndarray,\n    attitude: np.ndarray | None,\n    axes_length: float = 2.0,\n    axes_radius: float = 0.05,\n) -&gt; tuple[viser.FrameHandle | None, UpdateCallback | None]:\n    \"\"\"Add an animated body coordinate frame showing attitude.\n\n    Args:\n        server: ViserServer instance\n        pos: Position array of shape (N, 3)\n        attitude: Quaternion array of shape (N, 4) in [w, x, y, z] format, or None to skip\n        axes_length: Length of the coordinate axes\n        axes_radius: Radius of the axes cylinders\n\n    Returns:\n        Tuple of (handle, update_callback), or (None, None) if attitude is None\n    \"\"\"\n    if attitude is None:\n        return None, None\n\n    # Viser uses wxyz quaternion format\n    handle = server.scene.add_frame(\n        \"/body_frame\",\n        wxyz=attitude[0],\n        position=pos[0],\n        axes_length=axes_length,\n        axes_radius=axes_radius,\n    )\n\n    def update(frame_idx: int) -&gt; None:\n        handle.wxyz = attitude[frame_idx]\n        handle.position = pos[frame_idx]\n\n    return handle, update\n</code></pre>"},{"location":"reference/plotting/viser/animated/#openscvx.plotting.viser.animated.add_position_marker","title":"<code>add_position_marker(server: viser.ViserServer, pos: np.ndarray, radius: float = 0.5, color: tuple[int, int, int] = (100, 200, 255)) -&gt; tuple[viser.IcosphereHandle, UpdateCallback]</code>","text":"<p>Add an animated position marker (sphere at current position).</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>pos</code> <code>ndarray</code> <p>Position array of shape (N, 3)</p> required <code>radius</code> <code>float</code> <p>Marker radius</p> <code>0.5</code> <code>color</code> <code>tuple[int, int, int]</code> <p>RGB color tuple</p> <code>(100, 200, 255)</code> <p>Returns:</p> Type Description <code>tuple[IcosphereHandle, UpdateCallback]</code> <p>Tuple of (handle, update_callback)</p> Source code in <code>openscvx/plotting/viser/animated.py</code> <pre><code>def add_position_marker(\n    server: viser.ViserServer,\n    pos: np.ndarray,\n    radius: float = 0.5,\n    color: tuple[int, int, int] = (100, 200, 255),\n) -&gt; tuple[viser.IcosphereHandle, UpdateCallback]:\n    \"\"\"Add an animated position marker (sphere at current position).\n\n    Args:\n        server: ViserServer instance\n        pos: Position array of shape (N, 3)\n        radius: Marker radius\n        color: RGB color tuple\n\n    Returns:\n        Tuple of (handle, update_callback)\n    \"\"\"\n    handle = server.scene.add_icosphere(\n        \"/current_pos\",\n        radius=radius,\n        color=color,\n        position=pos[0],\n    )\n\n    def update(frame_idx: int) -&gt; None:\n        handle.position = pos[frame_idx]\n\n    return handle, update\n</code></pre>"},{"location":"reference/plotting/viser/animated/#openscvx.plotting.viser.animated.add_target_marker","title":"<code>add_target_marker(server: viser.ViserServer, target_pos: np.ndarray, name: str = 'target', radius: float = 0.8, color: tuple[int, int, int] = (255, 50, 50), show_trail: bool = True, trail_color: tuple[int, int, int] | None = None) -&gt; tuple[viser.IcosphereHandle, UpdateCallback | None]</code>","text":"<p>Add a viewplanning target marker (static or moving).</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>target_pos</code> <code>ndarray</code> <p>Target position - either shape (3,) for static or (N, 3) for moving</p> required <code>name</code> <code>str</code> <p>Unique name for this target (used in scene path)</p> <code>'target'</code> <code>radius</code> <code>float</code> <p>Marker radius</p> <code>0.8</code> <code>color</code> <code>tuple[int, int, int]</code> <p>RGB color tuple for marker</p> <code>(255, 50, 50)</code> <code>show_trail</code> <code>bool</code> <p>If True and target is moving, show trajectory trail</p> <code>True</code> <code>trail_color</code> <code>tuple[int, int, int] | None</code> <p>RGB color for trail (defaults to dimmed marker color)</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[IcosphereHandle, UpdateCallback | None]</code> <p>Tuple of (handle, update_callback). update_callback is None for static targets.</p> Source code in <code>openscvx/plotting/viser/animated.py</code> <pre><code>def add_target_marker(\n    server: viser.ViserServer,\n    target_pos: np.ndarray,\n    name: str = \"target\",\n    radius: float = 0.8,\n    color: tuple[int, int, int] = (255, 50, 50),\n    show_trail: bool = True,\n    trail_color: tuple[int, int, int] | None = None,\n) -&gt; tuple[viser.IcosphereHandle, UpdateCallback | None]:\n    \"\"\"Add a viewplanning target marker (static or moving).\n\n    Args:\n        server: ViserServer instance\n        target_pos: Target position - either shape (3,) for static or (N, 3) for moving\n        name: Unique name for this target (used in scene path)\n        radius: Marker radius\n        color: RGB color tuple for marker\n        show_trail: If True and target is moving, show trajectory trail\n        trail_color: RGB color for trail (defaults to dimmed marker color)\n\n    Returns:\n        Tuple of (handle, update_callback). update_callback is None for static targets.\n    \"\"\"\n    target_pos = np.asarray(target_pos)\n\n    # Check if static (single position) or moving (trajectory)\n    is_moving = target_pos.ndim == 2 and target_pos.shape[0] &gt; 1\n\n    initial_pos = target_pos[0] if is_moving else target_pos\n\n    # Add marker\n    handle = server.scene.add_icosphere(\n        f\"/targets/{name}/marker\",\n        radius=radius,\n        color=color,\n        position=initial_pos,\n    )\n\n    # For moving targets, optionally show trail\n    if is_moving and show_trail:\n        if trail_color is None:\n            trail_color = tuple(int(c * 0.5) for c in color)\n        server.scene.add_point_cloud(\n            f\"/targets/{name}/trail\",\n            points=target_pos,\n            colors=trail_color,\n            point_size=0.1,\n        )\n\n    if not is_moving:\n        # Static target - no update needed\n        return handle, None\n\n    def update(frame_idx: int) -&gt; None:\n        # Clamp to valid range for target trajectory\n        idx = min(frame_idx, len(target_pos) - 1)\n        handle.position = target_pos[idx]\n\n    return handle, update\n</code></pre>"},{"location":"reference/plotting/viser/animated/#openscvx.plotting.viser.animated.add_target_markers","title":"<code>add_target_markers(server: viser.ViserServer, target_positions: list[np.ndarray], colors: list[tuple[int, int, int]] | None = None, radius: float = 0.8, show_trails: bool = True) -&gt; list[tuple[viser.IcosphereHandle, UpdateCallback | None]]</code>","text":"<p>Add multiple viewplanning target markers.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>target_positions</code> <code>list[ndarray]</code> <p>List of target positions, each either (3,) or (N, 3)</p> required <code>colors</code> <code>list[tuple[int, int, int]] | None</code> <p>List of RGB colors, one per target. Defaults to distinct colors.</p> <code>None</code> <code>radius</code> <code>float</code> <p>Marker radius</p> <code>0.8</code> <code>show_trails</code> <code>bool</code> <p>If True, show trails for moving targets</p> <code>True</code> <p>Returns:</p> Type Description <code>list[tuple[IcosphereHandle, UpdateCallback | None]]</code> <p>List of (handle, update_callback) tuples</p> Source code in <code>openscvx/plotting/viser/animated.py</code> <pre><code>def add_target_markers(\n    server: viser.ViserServer,\n    target_positions: list[np.ndarray],\n    colors: list[tuple[int, int, int]] | None = None,\n    radius: float = 0.8,\n    show_trails: bool = True,\n) -&gt; list[tuple[viser.IcosphereHandle, UpdateCallback | None]]:\n    \"\"\"Add multiple viewplanning target markers.\n\n    Args:\n        server: ViserServer instance\n        target_positions: List of target positions, each either (3,) or (N, 3)\n        colors: List of RGB colors, one per target. Defaults to distinct colors.\n        radius: Marker radius\n        show_trails: If True, show trails for moving targets\n\n    Returns:\n        List of (handle, update_callback) tuples\n    \"\"\"\n    # Default colors if not provided\n    if colors is None:\n        default_colors = [\n            (255, 50, 50),  # Red\n            (50, 255, 50),  # Green\n            (50, 50, 255),  # Blue\n            (255, 255, 50),  # Yellow\n            (255, 50, 255),  # Magenta\n            (50, 255, 255),  # Cyan\n        ]\n        colors = [default_colors[i % len(default_colors)] for i in range(len(target_positions))]\n\n    results = []\n    for i, (pos, color) in enumerate(zip(target_positions, colors)):\n        handle, update = add_target_marker(\n            server,\n            pos,\n            name=f\"target_{i}\",\n            radius=radius,\n            color=color,\n            show_trail=show_trails,\n        )\n        results.append((handle, update))\n\n    return results\n</code></pre>"},{"location":"reference/plotting/viser/animated/#openscvx.plotting.viser.animated.add_thrust_vector","title":"<code>add_thrust_vector(server: viser.ViserServer, pos: np.ndarray, thrust: np.ndarray | None, attitude: np.ndarray | None = None, scale: float = 0.3, color: tuple[int, int, int] = (255, 100, 100), line_width: float = 4.0) -&gt; tuple[viser.LineSegmentsHandle | None, UpdateCallback | None]</code>","text":"<p>Add an animated thrust/force vector visualization.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>pos</code> <code>ndarray</code> <p>Position array of shape (N, 3)</p> required <code>thrust</code> <code>ndarray | None</code> <p>Thrust/force array of shape (N, 3), or None to skip</p> required <code>attitude</code> <code>ndarray | None</code> <p>Quaternion array of shape (N, 4) in [w, x, y, z] format. If provided, thrust is assumed to be in body frame and will be rotated to world frame using the attitude.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Scale factor for thrust vector length</p> <code>0.3</code> <code>color</code> <code>tuple[int, int, int]</code> <p>RGB color tuple</p> <code>(255, 100, 100)</code> <code>line_width</code> <code>float</code> <p>Line width</p> <code>4.0</code> <p>Returns:</p> Type Description <code>tuple[LineSegmentsHandle | None, UpdateCallback | None]</code> <p>Tuple of (handle, update_callback), or (None, None) if thrust is None</p> Source code in <code>openscvx/plotting/viser/animated.py</code> <pre><code>def add_thrust_vector(\n    server: viser.ViserServer,\n    pos: np.ndarray,\n    thrust: np.ndarray | None,\n    attitude: np.ndarray | None = None,\n    scale: float = 0.3,\n    color: tuple[int, int, int] = (255, 100, 100),\n    line_width: float = 4.0,\n) -&gt; tuple[viser.LineSegmentsHandle | None, UpdateCallback | None]:\n    \"\"\"Add an animated thrust/force vector visualization.\n\n    Args:\n        server: ViserServer instance\n        pos: Position array of shape (N, 3)\n        thrust: Thrust/force array of shape (N, 3), or None to skip\n        attitude: Quaternion array of shape (N, 4) in [w, x, y, z] format.\n            If provided, thrust is assumed to be in body frame and will be\n            rotated to world frame using the attitude.\n        scale: Scale factor for thrust vector length\n        color: RGB color tuple\n        line_width: Line width\n\n    Returns:\n        Tuple of (handle, update_callback), or (None, None) if thrust is None\n    \"\"\"\n    if thrust is None:\n        return None, None\n\n    def get_thrust_world(frame_idx: int) -&gt; np.ndarray:\n        \"\"\"Get thrust vector in world frame.\"\"\"\n        thrust_body = thrust[frame_idx]\n        if attitude is not None:\n            return _rotate_vector_by_quaternion(thrust_body, attitude[frame_idx])\n        return thrust_body\n\n    thrust_world = get_thrust_world(0)\n    thrust_end = pos[0] + thrust_world * scale\n    handle = server.scene.add_line_segments(\n        \"/thrust_vector\",\n        points=np.array([[pos[0], thrust_end]]),  # Shape (1, 2, 3)\n        colors=color,\n        line_width=line_width,\n    )\n\n    def update(frame_idx: int) -&gt; None:\n        thrust_world = get_thrust_world(frame_idx)\n        thrust_end = pos[frame_idx] + thrust_world * scale\n        handle.points = np.array([[pos[frame_idx], thrust_end]])\n\n    return handle, update\n</code></pre>"},{"location":"reference/plotting/viser/animated/#openscvx.plotting.viser.animated.add_viewcone","title":"<code>add_viewcone(server: viser.ViserServer, pos: np.ndarray, attitude: np.ndarray | None, half_angle_x: float, half_angle_y: float | None = None, scale: float = 10.0, norm_type: float | str = 2, R_sb: np.ndarray | None = None, color: tuple[int, int, int] = (35, 138, 141), opacity: float = 0.4, wireframe: bool = False, n_segments: int = 32) -&gt; tuple[viser.MeshHandle | None, UpdateCallback | None]</code>","text":"<p>Add an animated viewcone mesh that matches p-norm constraints.</p> <p>The sensor is assumed to look along +Z in its own frame (boresight = [0,0,1]). The viewcone represents the constraint ||[x,y]||_p &lt;= tan(alpha) * z.</p> Cross-section shapes by norm <ul> <li>p=1: diamond</li> <li>p=2: circle/ellipse</li> <li>p&gt;2: rounded square (superellipse)</li> <li>p=inf: square/rectangle</li> </ul> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>pos</code> <code>ndarray</code> <p>Position array of shape (N, 3)</p> required <code>attitude</code> <code>ndarray | None</code> <p>Quaternion array of shape (N, 4) in [w, x, y, z] format, or None to skip</p> required <code>half_angle_x</code> <code>float</code> <p>Half-angle of the cone in x direction (radians). For symmetric cones, this is pi/alpha_x where alpha_x is the constraint parameter.</p> required <code>half_angle_y</code> <code>float | None</code> <p>Half-angle in y direction (radians). If None, uses half_angle_x. For asymmetric constraints, this is pi/alpha_y.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Depth/length of the cone visualization</p> <code>10.0</code> <code>norm_type</code> <code>float | str</code> <p>p-norm value (1, 2, 3, ..., or \"inf\" for infinity norm)</p> <code>2</code> <code>R_sb</code> <code>ndarray | None</code> <p>Body-to-sensor rotation matrix (3x3). If None, sensor is aligned with body z-axis.</p> <code>None</code> <code>color</code> <code>tuple[int, int, int]</code> <p>RGB color tuple</p> <code>(35, 138, 141)</code> <code>opacity</code> <code>float</code> <p>Mesh opacity (0-1), ignored if wireframe=True</p> <code>0.4</code> <code>wireframe</code> <code>bool</code> <p>If True, render as wireframe instead of solid</p> <code>False</code> <code>n_segments</code> <code>int</code> <p>Number of segments for cone smoothness</p> <code>32</code> <p>Returns:</p> Type Description <code>tuple[MeshHandle | None, UpdateCallback | None]</code> <p>Tuple of (handle, update_callback), or (None, None) if attitude is None</p> Source code in <code>openscvx/plotting/viser/animated.py</code> <pre><code>def add_viewcone(\n    server: viser.ViserServer,\n    pos: np.ndarray,\n    attitude: np.ndarray | None,\n    half_angle_x: float,\n    half_angle_y: float | None = None,\n    scale: float = 10.0,\n    norm_type: float | str = 2,\n    R_sb: np.ndarray | None = None,\n    color: tuple[int, int, int] = (35, 138, 141),  # Viridis at t~0.33 (teal)\n    opacity: float = 0.4,\n    wireframe: bool = False,\n    n_segments: int = 32,\n) -&gt; tuple[viser.MeshHandle | None, UpdateCallback | None]:\n    \"\"\"Add an animated viewcone mesh that matches p-norm constraints.\n\n    The sensor is assumed to look along +Z in its own frame (boresight = [0,0,1]).\n    The viewcone represents the constraint ||[x,y]||_p &lt;= tan(alpha) * z.\n\n    Cross-section shapes by norm:\n        - p=1: diamond\n        - p=2: circle/ellipse\n        - p&gt;2: rounded square (superellipse)\n        - p=inf: square/rectangle\n\n    Args:\n        server: ViserServer instance\n        pos: Position array of shape (N, 3)\n        attitude: Quaternion array of shape (N, 4) in [w, x, y, z] format, or None to skip\n        half_angle_x: Half-angle of the cone in x direction (radians).\n            For symmetric cones, this is pi/alpha_x where alpha_x is the constraint parameter.\n        half_angle_y: Half-angle in y direction (radians). If None, uses half_angle_x.\n            For asymmetric constraints, this is pi/alpha_y.\n        scale: Depth/length of the cone visualization\n        norm_type: p-norm value (1, 2, 3, ..., or \"inf\" for infinity norm)\n        R_sb: Body-to-sensor rotation matrix (3x3). If None, sensor is aligned with body z-axis.\n        color: RGB color tuple\n        opacity: Mesh opacity (0-1), ignored if wireframe=True\n        wireframe: If True, render as wireframe instead of solid\n        n_segments: Number of segments for cone smoothness\n\n    Returns:\n        Tuple of (handle, update_callback), or (None, None) if attitude is None\n    \"\"\"\n    if attitude is None:\n        return None, None\n\n    # Convert inputs to numpy arrays (handles JAX arrays)\n    pos = np.asarray(pos, dtype=np.float64)\n    attitude = np.asarray(attitude, dtype=np.float64)\n    if R_sb is not None:\n        R_sb = np.asarray(R_sb, dtype=np.float64)\n\n    # Generate base geometry in sensor frame\n    base_vertices = _generate_viewcone_vertices(\n        half_angle_x, half_angle_y, scale, norm_type, n_segments\n    )\n    n_base_verts = len(base_vertices) - 1  # Exclude apex\n    faces = _generate_viewcone_faces(n_base_verts)\n\n    # Sensor-to-body rotation (transpose of body-to-sensor)\n    R_sensor_to_body = R_sb.T if R_sb is not None else np.eye(3)\n\n    def transform_vertices(frame_idx: int) -&gt; np.ndarray:\n        \"\"\"Transform cone vertices from sensor frame to world frame.\"\"\"\n        # Get body-to-world rotation from attitude quaternion\n        q_body = attitude[frame_idx]\n        R_body_to_world = _quaternion_to_rotation_matrix(q_body)\n\n        # Full transform: sensor -&gt; body -&gt; world\n        R_sensor_to_world = R_body_to_world @ R_sensor_to_body\n\n        # Transform vertices and translate to position\n        world_vertices = (R_sensor_to_world @ base_vertices.T).T + pos[frame_idx]\n        return world_vertices.astype(np.float32)\n\n    # Create initial mesh\n    initial_vertices = transform_vertices(0)\n    handle = server.scene.add_mesh_simple(\n        \"/viewcone_mesh\",\n        vertices=initial_vertices,\n        faces=faces,\n        color=color,\n        wireframe=wireframe,\n        opacity=opacity if not wireframe else 1.0,\n    )\n\n    def update(frame_idx: int) -&gt; None:\n        handle.vertices = transform_vertices(frame_idx)\n\n    return handle, update\n</code></pre>"},{"location":"reference/plotting/viser/plotly_integration/","title":"plotly_integration","text":"<p>Plotly integration for viser - animated 2D plots synchronized with 3D visualization.</p> <p>This module provides utilities for embedding plotly figures in viser's GUI with animated markers that synchronize with the 3D animation timeline.</p>"},{"location":"reference/plotting/viser/plotly_integration/#openscvx.plotting.viser.plotly_integration.add_animated_plotly_marker","title":"<code>add_animated_plotly_marker(server: viser.ViserServer, fig: go.Figure, time_array: np.ndarray, marker_x_data: np.ndarray, marker_y_data: np.ndarray, use_trajectory_indexing: bool = True, marker_name: str = 'Current', marker_color: str = 'red', marker_size: int = 12, folder_name: str | None = None, aspect: float = 1.5) -&gt; tuple</code>","text":"<p>Add a plotly figure to viser GUI with an animated time marker.</p> <p>This function takes any plotly figure and adds an animated marker that synchronizes with viser's 3D animation timeline. The marker shows the current position on the plot as the animation plays.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>fig</code> <code>Figure</code> <p>Plotly figure to display</p> required <code>time_array</code> <code>ndarray</code> <p>Time values corresponding to animation frames (N,). This should match the time array passed to add_animation_controls().</p> required <code>marker_x_data</code> <code>ndarray</code> <p>X-axis values for marker position (N,)</p> required <code>marker_y_data</code> <code>ndarray</code> <p>Y-axis values for marker position (N,)</p> required <code>use_trajectory_indexing</code> <code>bool</code> <p>If True, frame_idx maps directly to data indices. If False, searches for nearest time value (use for node-only data).</p> <code>True</code> <code>marker_name</code> <code>str</code> <p>Legend name for the marker trace</p> <code>'Current'</code> <code>marker_color</code> <code>str</code> <p>Color of the animated marker</p> <code>'red'</code> <code>marker_size</code> <code>int</code> <p>Size of the animated marker in points</p> <code>12</code> <code>folder_name</code> <code>str | None</code> <p>Optional GUI folder name to organize plots</p> <code>None</code> <code>aspect</code> <code>float</code> <p>Aspect ratio for plot display (width/height)</p> <code>1.5</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (plot_handle, update_callback)</p> <p>Example::</p> <pre><code>from openscvx.plotting import plot_vector_norm, viser\n\n# Create any plotly figure\nfig = plot_vector_norm(results, \"thrust\")\nthrust_norms = np.linalg.norm(results.trajectory[\"thrust\"], axis=1)\n\n# Add to viser with animated marker\n_, update_plot = viser.add_animated_plotly_marker(\n    server, fig,\n    time_array=results.trajectory[\"time\"].flatten(),\n    marker_x_data=results.trajectory[\"time\"].flatten(),\n    marker_y_data=thrust_norms,\n)\n\n# Add to animation callbacks\nupdate_callbacks.append(update_plot)\n</code></pre> Source code in <code>openscvx/plotting/viser/plotly_integration.py</code> <pre><code>def add_animated_plotly_marker(\n    server: viser.ViserServer,\n    fig: go.Figure,\n    time_array: np.ndarray,\n    marker_x_data: np.ndarray,\n    marker_y_data: np.ndarray,\n    use_trajectory_indexing: bool = True,\n    marker_name: str = \"Current\",\n    marker_color: str = \"red\",\n    marker_size: int = 12,\n    folder_name: str | None = None,\n    aspect: float = 1.5,\n) -&gt; tuple:\n    \"\"\"Add a plotly figure to viser GUI with an animated time marker.\n\n    This function takes any plotly figure and adds an animated marker that\n    synchronizes with viser's 3D animation timeline. The marker shows the\n    current position on the plot as the animation plays.\n\n    Args:\n        server: ViserServer instance\n        fig: Plotly figure to display\n        time_array: Time values corresponding to animation frames (N,).\n            This should match the time array passed to add_animation_controls().\n        marker_x_data: X-axis values for marker position (N,)\n        marker_y_data: Y-axis values for marker position (N,)\n        use_trajectory_indexing: If True, frame_idx maps directly to data indices.\n            If False, searches for nearest time value (use for node-only data).\n        marker_name: Legend name for the marker trace\n        marker_color: Color of the animated marker\n        marker_size: Size of the animated marker in points\n        folder_name: Optional GUI folder name to organize plots\n        aspect: Aspect ratio for plot display (width/height)\n\n    Returns:\n        Tuple of (plot_handle, update_callback)\n\n    Example::\n\n        from openscvx.plotting import plot_vector_norm, viser\n\n        # Create any plotly figure\n        fig = plot_vector_norm(results, \"thrust\")\n        thrust_norms = np.linalg.norm(results.trajectory[\"thrust\"], axis=1)\n\n        # Add to viser with animated marker\n        _, update_plot = viser.add_animated_plotly_marker(\n            server, fig,\n            time_array=results.trajectory[\"time\"].flatten(),\n            marker_x_data=results.trajectory[\"time\"].flatten(),\n            marker_y_data=thrust_norms,\n        )\n\n        # Add to animation callbacks\n        update_callbacks.append(update_plot)\n    \"\"\"\n    # Add marker trace to figure\n    marker_trace = go.Scatter(\n        x=[marker_x_data[0]],\n        y=[marker_y_data[0]],\n        mode=\"markers\",\n        marker={\"color\": marker_color, \"size\": marker_size, \"symbol\": \"circle\"},\n        name=marker_name,\n    )\n    fig.add_trace(marker_trace)\n    marker_trace_idx = len(fig.data) - 1\n\n    # Add to viser GUI\n    if folder_name:\n        with server.gui.add_folder(folder_name):\n            plot_handle = server.gui.add_plotly(figure=fig, aspect=aspect)\n    else:\n        plot_handle = server.gui.add_plotly(figure=fig, aspect=aspect)\n\n    # Create update callback\n    def update(frame_idx: int) -&gt; None:\n        \"\"\"Update marker position based on current frame.\"\"\"\n        if use_trajectory_indexing:\n            # Direct indexing: frame_idx corresponds to data index\n            idx = min(frame_idx, len(marker_y_data) - 1)\n        else:\n            # Search for nearest time (for node-only data)\n            current_time = time_array[frame_idx]\n            idx = min(np.searchsorted(marker_x_data, current_time), len(marker_y_data) - 1)\n\n        # Update marker position\n        fig.data[marker_trace_idx].x = [marker_x_data[idx]]\n        fig.data[marker_trace_idx].y = [marker_y_data[idx]]\n\n        # Trigger viser update\n        plot_handle.figure = fig\n\n    return plot_handle, update\n</code></pre>"},{"location":"reference/plotting/viser/plotly_integration/#openscvx.plotting.viser.plotly_integration.add_animated_plotly_vline","title":"<code>add_animated_plotly_vline(server: viser.ViserServer, fig: go.Figure, time_array: np.ndarray, use_trajectory_indexing: bool = True, line_color: str = 'red', line_width: int = 2, line_dash: str = 'dash', annotation_text: str = 'Current', annotation_position: str = 'top', folder_name: str | None = None, aspect: float = 1.5) -&gt; tuple</code>","text":"<p>Add a plotly figure to viser GUI with an animated vertical line.</p> <p>This function takes any plotly figure and adds an animated vertical line that synchronizes with viser's 3D animation timeline. The line shows the current time position as the animation plays.</p> <p>This is more generic than add_animated_plotly_marker() as it works for any number of traces without needing to specify y-data for each.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>fig</code> <code>Figure</code> <p>Plotly figure to display</p> required <code>time_array</code> <code>ndarray</code> <p>Time values corresponding to animation frames (N,). This should match the time array passed to add_animation_controls().</p> required <code>use_trajectory_indexing</code> <code>bool</code> <p>If True, frame_idx maps directly to time indices. If False, searches for nearest time value (use for node-only data).</p> <code>True</code> <code>line_color</code> <code>str</code> <p>Color of the vertical line</p> <code>'red'</code> <code>line_width</code> <code>int</code> <p>Width of the vertical line in pixels</p> <code>2</code> <code>line_dash</code> <code>str</code> <p>Dash style - \"solid\", \"dash\", \"dot\", \"dashdot\"</p> <code>'dash'</code> <code>annotation_text</code> <code>str</code> <p>Text to show on the line</p> <code>'Current'</code> <code>annotation_position</code> <code>str</code> <p>Position of annotation - \"top\", \"bottom\", \"top left\", etc.</p> <code>'top'</code> <code>folder_name</code> <code>str | None</code> <p>Optional GUI folder name to organize plots</p> <code>None</code> <code>aspect</code> <code>float</code> <p>Aspect ratio for plot display (width/height)</p> <code>1.5</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (plot_handle, update_callback)</p> <p>Example::</p> <pre><code>from openscvx.plotting import plot_control, viser\n\n# Create any plotly figure\nfig = plot_control(results, \"thrust_force\")\n\n# Add to viser with animated vertical line\n_, update_plot = viser.add_animated_plotly_vline(\n    server, fig,\n    time_array=results.trajectory[\"time\"].flatten(),\n)\n\n# Add to animation callbacks\nupdate_callbacks.append(update_plot)\n</code></pre> Source code in <code>openscvx/plotting/viser/plotly_integration.py</code> <pre><code>def add_animated_plotly_vline(\n    server: viser.ViserServer,\n    fig: go.Figure,\n    time_array: np.ndarray,\n    use_trajectory_indexing: bool = True,\n    line_color: str = \"red\",\n    line_width: int = 2,\n    line_dash: str = \"dash\",\n    annotation_text: str = \"Current\",\n    annotation_position: str = \"top\",\n    folder_name: str | None = None,\n    aspect: float = 1.5,\n) -&gt; tuple:\n    \"\"\"Add a plotly figure to viser GUI with an animated vertical line.\n\n    This function takes any plotly figure and adds an animated vertical line that\n    synchronizes with viser's 3D animation timeline. The line shows the current\n    time position as the animation plays.\n\n    This is more generic than add_animated_plotly_marker() as it works for any\n    number of traces without needing to specify y-data for each.\n\n    Args:\n        server: ViserServer instance\n        fig: Plotly figure to display\n        time_array: Time values corresponding to animation frames (N,).\n            This should match the time array passed to add_animation_controls().\n        use_trajectory_indexing: If True, frame_idx maps directly to time indices.\n            If False, searches for nearest time value (use for node-only data).\n        line_color: Color of the vertical line\n        line_width: Width of the vertical line in pixels\n        line_dash: Dash style - \"solid\", \"dash\", \"dot\", \"dashdot\"\n        annotation_text: Text to show on the line\n        annotation_position: Position of annotation - \"top\", \"bottom\", \"top left\", etc.\n        folder_name: Optional GUI folder name to organize plots\n        aspect: Aspect ratio for plot display (width/height)\n\n    Returns:\n        Tuple of (plot_handle, update_callback)\n\n    Example::\n\n        from openscvx.plotting import plot_control, viser\n\n        # Create any plotly figure\n        fig = plot_control(results, \"thrust_force\")\n\n        # Add to viser with animated vertical line\n        _, update_plot = viser.add_animated_plotly_vline(\n            server, fig,\n            time_array=results.trajectory[\"time\"].flatten(),\n        )\n\n        # Add to animation callbacks\n        update_callbacks.append(update_plot)\n    \"\"\"\n    # Detect number of subplots in the figure\n    # Count unique xaxis/yaxis references in the layout\n    n_subplots = 1\n    if hasattr(fig, \"_grid_ref\") and fig._grid_ref is not None:\n        # Figure created with make_subplots - use grid dimensions\n        n_rows = len(fig._grid_ref)\n        n_cols = len(fig._grid_ref[0]) if n_rows &gt; 0 else 1\n        n_subplots = n_rows * n_cols\n\n    # Track which shapes are our vlines (before adding new ones)\n    n_existing_shapes = len(fig.layout.shapes) if fig.layout.shapes else 0\n\n    # Add vertical line to each subplot\n    if n_subplots == 1:\n        # Single plot - add one vline\n        fig.add_vline(\n            x=time_array[0],\n            line_dash=line_dash,\n            line_color=line_color,\n            line_width=line_width,\n            annotation_text=annotation_text,\n            annotation_position=annotation_position,\n        )\n    else:\n        # Multiple subplots - add vline to each\n        # Determine grid layout\n        n_rows = len(fig._grid_ref)\n        n_cols = len(fig._grid_ref[0]) if n_rows &gt; 0 else 1\n\n        for row_idx in range(n_rows):\n            for col_idx in range(n_cols):\n                # Add vline to this subplot\n                # Only add annotation to first subplot to avoid clutter\n                show_annotation = row_idx == 0 and col_idx == 0\n                fig.add_vline(\n                    x=time_array[0],\n                    line_dash=line_dash,\n                    line_color=line_color,\n                    line_width=line_width,\n                    annotation_text=annotation_text if show_annotation else None,\n                    annotation_position=annotation_position if show_annotation else None,\n                    row=row_idx + 1,\n                    col=col_idx + 1,\n                )\n\n    # Track indices of shapes we added\n    n_new_shapes = len(fig.layout.shapes) - n_existing_shapes\n    vline_shape_indices = list(range(n_existing_shapes, n_existing_shapes + n_new_shapes))\n\n    # Add to viser GUI\n    if folder_name:\n        with server.gui.add_folder(folder_name):\n            plot_handle = server.gui.add_plotly(figure=fig, aspect=aspect)\n    else:\n        plot_handle = server.gui.add_plotly(figure=fig, aspect=aspect)\n\n    # Create update callback\n    def update(frame_idx: int) -&gt; None:\n        \"\"\"Update vertical line position based on current frame.\"\"\"\n        if use_trajectory_indexing:\n            # Direct indexing: frame_idx corresponds to time index\n            idx = min(frame_idx, len(time_array) - 1)\n        else:\n            # Search for nearest time (for node-only data)\n            current_time = time_array[frame_idx]\n            idx = min(frame_idx, len(time_array) - 1)\n\n        # Update all vertical line positions\n        current_time = time_array[idx]\n        for shape_idx in vline_shape_indices:\n            fig.layout.shapes[shape_idx].x0 = current_time\n            fig.layout.shapes[shape_idx].x1 = current_time\n\n        # Trigger viser update\n        plot_handle.figure = fig\n\n    return plot_handle, update\n</code></pre>"},{"location":"reference/plotting/viser/plotly_integration/#openscvx.plotting.viser.plotly_integration.add_animated_vector_norm_plot","title":"<code>add_animated_vector_norm_plot(server: viser.ViserServer, results: OptimizationResults, var_name: str, bounds: tuple[float, float] | None = None, title: str | None = None, folder_name: str | None = None, aspect: float = 1.5, marker_color: str = 'red', marker_size: int = 12) -&gt; tuple</code>","text":"<p>Add animated norm plot for a state or control variable.</p> <p>Convenience wrapper around add_animated_plotly_marker() that uses the existing plot_vector_norm() function to create the base plot.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>results</code> <code>OptimizationResults</code> <p>Optimization results containing variable data</p> required <code>var_name</code> <code>str</code> <p>Name of the state or control variable to plot</p> required <code>bounds</code> <code>tuple[float, float] | None</code> <p>Optional (min, max) bounds to display on plot</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Optional custom title for the plot (defaults to \"\u2016{var_name}\u2016\u2082\")</p> <code>None</code> <code>folder_name</code> <code>str | None</code> <p>Optional GUI folder name to organize plots</p> <code>None</code> <code>aspect</code> <code>float</code> <p>Aspect ratio for plot display (width/height)</p> <code>1.5</code> <code>marker_color</code> <code>str</code> <p>Color of the animated marker</p> <code>'red'</code> <code>marker_size</code> <code>int</code> <p>Size of the animated marker in points</p> <code>12</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (plot_handle, update_callback), or (None, None) if variable not found</p> <p>Example::</p> <pre><code>from openscvx.plotting import viser\n\n# Add animated thrust norm plot\n_, update_thrust = viser.add_animated_vector_norm_plot(\n    server, results, \"thrust\",\n    title=\"Thrust Magnitude\",\n    bounds=(0.0, max_thrust),\n    folder_name=\"Control Plots\"\n)\nif update_thrust is not None:\n    update_callbacks.append(update_thrust)\n</code></pre> Source code in <code>openscvx/plotting/viser/plotly_integration.py</code> <pre><code>def add_animated_vector_norm_plot(\n    server: viser.ViserServer,\n    results: OptimizationResults,\n    var_name: str,\n    bounds: tuple[float, float] | None = None,\n    title: str | None = None,\n    folder_name: str | None = None,\n    aspect: float = 1.5,\n    marker_color: str = \"red\",\n    marker_size: int = 12,\n) -&gt; tuple:\n    \"\"\"Add animated norm plot for a state or control variable.\n\n    Convenience wrapper around add_animated_plotly_marker() that uses\n    the existing plot_vector_norm() function to create the base plot.\n\n    Args:\n        server: ViserServer instance\n        results: Optimization results containing variable data\n        var_name: Name of the state or control variable to plot\n        bounds: Optional (min, max) bounds to display on plot\n        title: Optional custom title for the plot (defaults to \"\u2016{var_name}\u2016\u2082\")\n        folder_name: Optional GUI folder name to organize plots\n        aspect: Aspect ratio for plot display (width/height)\n        marker_color: Color of the animated marker\n        marker_size: Size of the animated marker in points\n\n    Returns:\n        Tuple of (plot_handle, update_callback), or (None, None) if variable not found\n\n    Example::\n\n        from openscvx.plotting import viser\n\n        # Add animated thrust norm plot\n        _, update_thrust = viser.add_animated_vector_norm_plot(\n            server, results, \"thrust\",\n            title=\"Thrust Magnitude\",\n            bounds=(0.0, max_thrust),\n            folder_name=\"Control Plots\"\n        )\n        if update_thrust is not None:\n            update_callbacks.append(update_thrust)\n    \"\"\"\n    from openscvx.plotting import plot_vector_norm\n\n    # Check if variable exists in results\n    has_in_trajectory = bool(results.trajectory) and var_name in results.trajectory\n    has_in_nodes = var_name in results.nodes\n\n    if not (has_in_trajectory or has_in_nodes):\n        import warnings\n\n        warnings.warn(f\"Variable '{var_name}' not found in results, skipping plot\")\n        return None, None\n\n    # Create figure using existing plotting function\n    fig = plot_vector_norm(results, var_name, bounds=bounds)\n\n    # Update title if custom title provided\n    if title is not None:\n        fig.update_layout(title_text=title)\n\n    # Determine data source and compute norms\n    if has_in_trajectory:\n        time_data = results.trajectory[\"time\"].flatten()\n        var_data = results.trajectory[var_name]\n        use_trajectory_indexing = True\n    else:\n        time_data = results.nodes[\"time\"].flatten()\n        var_data = results.nodes[var_name]\n        use_trajectory_indexing = False\n\n    # Compute norms\n    norm_data = np.linalg.norm(var_data, axis=1) if var_data.ndim &gt; 1 else np.abs(var_data)\n\n    # Add animated marker\n    return add_animated_plotly_marker(\n        server,\n        fig,\n        time_array=time_data,\n        marker_x_data=time_data,\n        marker_y_data=norm_data,\n        use_trajectory_indexing=use_trajectory_indexing,\n        marker_name=\"Current\",\n        marker_color=marker_color,\n        marker_size=marker_size,\n        folder_name=folder_name,\n        aspect=aspect,\n    )\n</code></pre>"},{"location":"reference/plotting/viser/primitives/","title":"primitives","text":"<p>Static scene primitives for viser visualization.</p> <p>Functions for adding non-animated elements: obstacles, gates, constraint cones, ghost trajectories, etc. Called once during scene setup.</p>"},{"location":"reference/plotting/viser/primitives/#openscvx.plotting.viser.primitives.add_ellipsoid_obstacles","title":"<code>add_ellipsoid_obstacles(server: viser.ViserServer, centers: list[np.ndarray], radii: list[np.ndarray], axes: list[np.ndarray] | None = None, color: tuple[int, int, int] = (255, 100, 100), opacity: float = 0.6, wireframe: bool = False, subdivisions: int = 2) -&gt; list</code>","text":"<p>Add ellipsoidal obstacles to the scene.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>centers</code> <code>list[ndarray]</code> <p>List of center positions, each shape (3,)</p> required <code>radii</code> <code>list[ndarray]</code> <p>List of radii along principal axes, each shape (3,)</p> required <code>axes</code> <code>list[ndarray] | None</code> <p>List of rotation matrices (3, 3) defining principal axes. If None, ellipsoids are axis-aligned.</p> <code>None</code> <code>color</code> <code>tuple[int, int, int]</code> <p>RGB color tuple</p> <code>(255, 100, 100)</code> <code>opacity</code> <code>float</code> <p>Opacity (0-1), only used when wireframe=False</p> <code>0.6</code> <code>wireframe</code> <code>bool</code> <p>If True, render as wireframe instead of solid</p> <code>False</code> <code>subdivisions</code> <code>int</code> <p>Icosphere subdivisions (higher = smoother, 2 is usually good)</p> <code>2</code> <p>Returns:</p> Type Description <code>list</code> <p>List of mesh handles</p> Source code in <code>openscvx/plotting/viser/primitives.py</code> <pre><code>def add_ellipsoid_obstacles(\n    server: viser.ViserServer,\n    centers: list[np.ndarray],\n    radii: list[np.ndarray],\n    axes: list[np.ndarray] | None = None,\n    color: tuple[int, int, int] = (255, 100, 100),\n    opacity: float = 0.6,\n    wireframe: bool = False,\n    subdivisions: int = 2,\n) -&gt; list:\n    \"\"\"Add ellipsoidal obstacles to the scene.\n\n    Args:\n        server: ViserServer instance\n        centers: List of center positions, each shape (3,)\n        radii: List of radii along principal axes, each shape (3,)\n        axes: List of rotation matrices (3, 3) defining principal axes.\n            If None, ellipsoids are axis-aligned.\n        color: RGB color tuple\n        opacity: Opacity (0-1), only used when wireframe=False\n        wireframe: If True, render as wireframe instead of solid\n        subdivisions: Icosphere subdivisions (higher = smoother, 2 is usually good)\n\n    Returns:\n        List of mesh handles\n    \"\"\"\n    handles = []\n\n    if axes is None:\n        axes = [None] * len(centers)\n\n    for i, (center, rad, ax) in enumerate(zip(centers, radii, axes)):\n        # Convert JAX arrays to numpy if needed\n        center = np.asarray(center, dtype=np.float64)\n        rad = np.asarray(rad, dtype=np.float64)\n        if ax is not None:\n            ax = np.asarray(ax, dtype=np.float64)\n\n        vertices, faces = _generate_ellipsoid_mesh(center, rad, ax, subdivisions)\n\n        handle = server.scene.add_mesh_simple(\n            f\"/obstacles/ellipsoid_{i}\",\n            vertices=vertices,\n            faces=faces,\n            color=color,\n            wireframe=wireframe,\n            opacity=opacity if not wireframe else 1.0,\n        )\n        handles.append(handle)\n\n    return handles\n</code></pre>"},{"location":"reference/plotting/viser/primitives/#openscvx.plotting.viser.primitives.add_gates","title":"<code>add_gates(server: viser.ViserServer, vertices: list, color: tuple[int, int, int] = (255, 165, 0), line_width: float = 3.0) -&gt; None</code>","text":"<p>Add gate/obstacle wireframes to the scene.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>vertices</code> <code>list</code> <p>List of vertex arrays (4 vertices for planar gate, 8 for box)</p> required <code>color</code> <code>tuple[int, int, int]</code> <p>RGB color tuple</p> <code>(255, 165, 0)</code> <code>line_width</code> <code>float</code> <p>Line width for wireframe</p> <code>3.0</code> Source code in <code>openscvx/plotting/viser/primitives.py</code> <pre><code>def add_gates(\n    server: viser.ViserServer,\n    vertices: list,\n    color: tuple[int, int, int] = (255, 165, 0),\n    line_width: float = 3.0,\n) -&gt; None:\n    \"\"\"Add gate/obstacle wireframes to the scene.\n\n    Args:\n        server: ViserServer instance\n        vertices: List of vertex arrays (4 vertices for planar gate, 8 for box)\n        color: RGB color tuple\n        line_width: Line width for wireframe\n    \"\"\"\n    for i, verts in enumerate(vertices):\n        verts = np.array(verts)\n        n_verts = len(verts)\n\n        if n_verts == 4:\n            # Planar gate: 4 vertices forming a closed loop\n            edges = [[0, 1], [1, 2], [2, 3], [3, 0]]\n        elif n_verts == 8:\n            # 3D box: 8 vertices\n            edges = [\n                [0, 1],\n                [1, 2],\n                [2, 3],\n                [3, 0],  # front face\n                [4, 5],\n                [5, 6],\n                [6, 7],\n                [7, 4],  # back face\n                [0, 4],\n                [1, 5],\n                [2, 6],\n                [3, 7],  # connecting edges\n            ]\n        else:\n            # Unknown format, skip\n            continue\n\n        # Shape (N, 2, 3) for N line segments\n        points = np.array([[verts[e[0]], verts[e[1]]] for e in edges])\n        server.scene.add_line_segments(\n            f\"/gates/gate_{i}\",\n            points=points,\n            colors=color,\n            line_width=line_width,\n        )\n</code></pre>"},{"location":"reference/plotting/viser/primitives/#openscvx.plotting.viser.primitives.add_ghost_trajectory","title":"<code>add_ghost_trajectory(server: viser.ViserServer, pos: np.ndarray, colors: np.ndarray, opacity: float = 0.3, point_size: float = 0.05) -&gt; None</code>","text":"<p>Add a faint ghost trajectory showing the full path.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>pos</code> <code>ndarray</code> <p>Position array of shape (N, 3)</p> required <code>colors</code> <code>ndarray</code> <p>RGB color array of shape (N, 3)</p> required <code>opacity</code> <code>float</code> <p>Opacity factor (0-1) applied to colors</p> <code>0.3</code> <code>point_size</code> <code>float</code> <p>Size of trajectory points</p> <code>0.05</code> Source code in <code>openscvx/plotting/viser/primitives.py</code> <pre><code>def add_ghost_trajectory(\n    server: viser.ViserServer,\n    pos: np.ndarray,\n    colors: np.ndarray,\n    opacity: float = 0.3,\n    point_size: float = 0.05,\n) -&gt; None:\n    \"\"\"Add a faint ghost trajectory showing the full path.\n\n    Args:\n        server: ViserServer instance\n        pos: Position array of shape (N, 3)\n        colors: RGB color array of shape (N, 3)\n        opacity: Opacity factor (0-1) applied to colors\n        point_size: Size of trajectory points\n    \"\"\"\n    ghost_colors = (colors * opacity).astype(np.uint8)\n    server.scene.add_point_cloud(\n        \"/ghost_traj\",\n        points=pos,\n        colors=ghost_colors,\n        point_size=point_size,\n    )\n</code></pre>"},{"location":"reference/plotting/viser/primitives/#openscvx.plotting.viser.primitives.add_glideslope_cone","title":"<code>add_glideslope_cone(server: viser.ViserServer, apex: np.ndarray | tuple = (0.0, 0.0, 0.0), height: float = 2000.0, glideslope_angle_deg: float = 86.0, axis: np.ndarray | tuple = (0.0, 0.0, 1.0), color: tuple[int, int, int] = (100, 200, 100), opacity: float = 0.2, wireframe: bool = False, n_segments: int = 32) -&gt; viser.MeshHandle</code>","text":"<p>Add a glideslope/approach constraint cone to the scene.</p> The glideslope constraint typically has the form <p>||position_perp|| &lt;= tan(angle) * position_along_axis</p> <p>This creates a cone with apex at the target, opening along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>apex</code> <code>ndarray | tuple</code> <p>Apex position (docking/landing site), default is origin</p> <code>(0.0, 0.0, 0.0)</code> <code>height</code> <code>float</code> <p>Height of the cone visualization</p> <code>2000.0</code> <code>glideslope_angle_deg</code> <code>float</code> <p>Glideslope angle in degrees (measured from axis). For constraint ||r_perp|| &lt;= tan(theta) * r_axis, pass theta here. Common values: 86 deg (very wide), 70 deg (moderate), 45 deg (steep)</p> <code>86.0</code> <code>axis</code> <code>ndarray | tuple</code> <p>Unit vector direction the cone opens toward. Default (0,0,1) for +Z. Use (-1,0,0) for R-bar approach (from below in radial direction).</p> <code>(0.0, 0.0, 1.0)</code> <code>color</code> <code>tuple[int, int, int]</code> <p>RGB color tuple</p> <code>(100, 200, 100)</code> <code>opacity</code> <code>float</code> <p>Opacity (0-1)</p> <code>0.2</code> <code>wireframe</code> <code>bool</code> <p>If True, render as wireframe</p> <code>False</code> <code>n_segments</code> <code>int</code> <p>Number of segments for cone smoothness</p> <code>32</code> <p>Returns:</p> Type Description <code>MeshHandle</code> <p>Mesh handle for the cone</p> Source code in <code>openscvx/plotting/viser/primitives.py</code> <pre><code>def add_glideslope_cone(\n    server: viser.ViserServer,\n    apex: np.ndarray | tuple = (0.0, 0.0, 0.0),\n    height: float = 2000.0,\n    glideslope_angle_deg: float = 86.0,\n    axis: np.ndarray | tuple = (0.0, 0.0, 1.0),\n    color: tuple[int, int, int] = (100, 200, 100),\n    opacity: float = 0.2,\n    wireframe: bool = False,\n    n_segments: int = 32,\n) -&gt; viser.MeshHandle:\n    \"\"\"Add a glideslope/approach constraint cone to the scene.\n\n    The glideslope constraint typically has the form:\n        ||position_perp|| &lt;= tan(angle) * position_along_axis\n\n    This creates a cone with apex at the target, opening along the specified axis.\n\n    Args:\n        server: ViserServer instance\n        apex: Apex position (docking/landing site), default is origin\n        height: Height of the cone visualization\n        glideslope_angle_deg: Glideslope angle in degrees (measured from axis).\n            For constraint ||r_perp|| &lt;= tan(theta) * r_axis, pass theta here.\n            Common values: 86 deg (very wide), 70 deg (moderate), 45 deg (steep)\n        axis: Unit vector direction the cone opens toward. Default (0,0,1) for +Z.\n            Use (-1,0,0) for R-bar approach (from below in radial direction).\n        color: RGB color tuple\n        opacity: Opacity (0-1)\n        wireframe: If True, render as wireframe\n        n_segments: Number of segments for cone smoothness\n\n    Returns:\n        Mesh handle for the cone\n    \"\"\"\n    apex = np.asarray(apex, dtype=np.float32)\n\n    vertices, faces = _generate_cone_mesh(apex, height, glideslope_angle_deg, n_segments, axis=axis)\n\n    handle = server.scene.add_mesh_simple(\n        \"/constraints/glideslope_cone\",\n        vertices=vertices,\n        faces=faces,\n        color=color,\n        wireframe=wireframe,\n        opacity=opacity if not wireframe else 1.0,\n    )\n\n    return handle\n</code></pre>"},{"location":"reference/plotting/viser/scp/","title":"scp","text":"<p>SCP iteration visualization components for viser.</p> <p>This module contains functions for visualizing the successive convex programming (SCP) optimization process, showing how the solution evolves across iterations.</p>"},{"location":"reference/plotting/viser/scp/#openscvx.plotting.viser.scp.add_scp_animation_controls","title":"<code>add_scp_animation_controls(server: viser.ViserServer, n_iterations: int, update_callbacks: list[UpdateCallback], autoplay: bool = False, frame_duration_ms: int = 500, folder_name: str = 'SCP Animation') -&gt; None</code>","text":"<p>Add GUI controls for stepping through SCP iterations.</p> <p>Creates play/pause button, step buttons, iteration slider, and speed control.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>n_iterations</code> <code>int</code> <p>Total number of SCP iterations</p> required <code>update_callbacks</code> <code>list[UpdateCallback]</code> <p>List of update functions to call each iteration</p> required <code>autoplay</code> <code>bool</code> <p>Whether to start playing automatically</p> <code>False</code> <code>frame_duration_ms</code> <code>int</code> <p>Default milliseconds per iteration frame</p> <code>500</code> <code>folder_name</code> <code>str</code> <p>Name for the GUI folder</p> <code>'SCP Animation'</code> Source code in <code>openscvx/plotting/viser/scp.py</code> <pre><code>def add_scp_animation_controls(\n    server: viser.ViserServer,\n    n_iterations: int,\n    update_callbacks: list[UpdateCallback],\n    autoplay: bool = False,\n    frame_duration_ms: int = 500,\n    folder_name: str = \"SCP Animation\",\n) -&gt; None:\n    \"\"\"Add GUI controls for stepping through SCP iterations.\n\n    Creates play/pause button, step buttons, iteration slider, and speed control.\n\n    Args:\n        server: ViserServer instance\n        n_iterations: Total number of SCP iterations\n        update_callbacks: List of update functions to call each iteration\n        autoplay: Whether to start playing automatically\n        frame_duration_ms: Default milliseconds per iteration frame\n        folder_name: Name for the GUI folder\n    \"\"\"\n    # Filter out None callbacks\n    callbacks = [cb for cb in update_callbacks if cb is not None]\n\n    def update_all(iter_idx: int) -&gt; None:\n        \"\"\"Update all visualization components.\"\"\"\n        for callback in callbacks:\n            callback(iter_idx)\n\n    # --- GUI Controls ---\n    with server.gui.add_folder(folder_name):\n        play_button = server.gui.add_button(\"Play\")\n        with server.gui.add_folder(\"Step Controls\", expand_by_default=False):\n            prev_button = server.gui.add_button(\"&lt; Previous\")\n            next_button = server.gui.add_button(\"Next &gt;\")\n        iter_slider = server.gui.add_slider(\n            \"Iteration\",\n            min=0,\n            max=n_iterations - 1,\n            step=1,\n            initial_value=0,\n        )\n        speed_slider = server.gui.add_slider(\n            \"Speed (ms/iter)\",\n            min=50,\n            max=2000,\n            step=50,\n            initial_value=frame_duration_ms,\n        )\n        loop_checkbox = server.gui.add_checkbox(\"Loop\", initial_value=True)\n\n    # Animation state\n    state = {\"playing\": autoplay, \"iteration\": 0, \"needs_update\": True}\n\n    @play_button.on_click\n    def _(_) -&gt; None:\n        state[\"playing\"] = not state[\"playing\"]\n        state[\"needs_update\"] = True  # Trigger immediate update on play\n        play_button.name = \"Pause\" if state[\"playing\"] else \"Play\"\n\n    @prev_button.on_click\n    def _(_) -&gt; None:\n        if state[\"iteration\"] &gt; 0:\n            state[\"iteration\"] -= 1\n            iter_slider.value = state[\"iteration\"]\n            update_all(state[\"iteration\"])\n\n    @next_button.on_click\n    def _(_) -&gt; None:\n        if state[\"iteration\"] &lt; n_iterations - 1:\n            state[\"iteration\"] += 1\n            iter_slider.value = state[\"iteration\"]\n            update_all(state[\"iteration\"])\n\n    @iter_slider.on_update\n    def _(_) -&gt; None:\n        if not state[\"playing\"]:\n            state[\"iteration\"] = int(iter_slider.value)\n            update_all(state[\"iteration\"])\n\n    def animation_loop() -&gt; None:\n        \"\"\"Background thread for SCP iteration playback.\"\"\"\n        last_update = time.time()\n        while True:\n            time.sleep(0.016)  # ~60 fps check rate\n\n            # Handle immediate update requests (e.g., on play button click)\n            if state[\"needs_update\"]:\n                state[\"needs_update\"] = False\n                last_update = time.time()\n                update_all(state[\"iteration\"])\n                continue\n\n            if state[\"playing\"]:\n                current_time = time.time()\n                elapsed_ms = (current_time - last_update) * 1000\n\n                if elapsed_ms &gt;= speed_slider.value:\n                    last_update = current_time\n                    state[\"iteration\"] += 1\n\n                    if state[\"iteration\"] &gt;= n_iterations:\n                        if loop_checkbox.value:\n                            state[\"iteration\"] = 0\n                        else:\n                            state[\"iteration\"] = n_iterations - 1\n                            state[\"playing\"] = False\n                            play_button.name = \"Play\"\n\n                    iter_slider.value = state[\"iteration\"]\n                    update_all(state[\"iteration\"])\n\n    # Start animation thread\n    thread = threading.Thread(target=animation_loop, daemon=True)\n    thread.start()\n\n    # Initial update to ensure first frame is fully rendered\n    update_all(0)\n</code></pre>"},{"location":"reference/plotting/viser/scp/#openscvx.plotting.viser.scp.add_scp_ghost_iterations","title":"<code>add_scp_ghost_iterations(server: viser.ViserServer, positions: list[np.ndarray], point_size: float = 0.15, cmap_name: str = 'viridis') -&gt; tuple[list[viser.PointCloudHandle], UpdateCallback]</code>","text":"<p>Add ghost trails showing all previous SCP iterations.</p> <p>Pre-buffers point clouds for all iterations and toggles visibility for performance. Shows all previous iterations with viridis coloring to visualize convergence.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>positions</code> <code>list[ndarray]</code> <p>List of position arrays per iteration, each shape (N, 3)</p> required <code>point_size</code> <code>float</code> <p>Size of ghost points</p> <code>0.15</code> <code>cmap_name</code> <code>str</code> <p>Matplotlib colormap name for ghost colors</p> <code>'viridis'</code> <p>Returns:</p> Type Description <code>tuple[list[PointCloudHandle], UpdateCallback]</code> <p>Tuple of (list of handles, update_callback)</p> Source code in <code>openscvx/plotting/viser/scp.py</code> <pre><code>def add_scp_ghost_iterations(\n    server: viser.ViserServer,\n    positions: list[np.ndarray],\n    point_size: float = 0.15,\n    cmap_name: str = \"viridis\",\n) -&gt; tuple[list[viser.PointCloudHandle], UpdateCallback]:\n    \"\"\"Add ghost trails showing all previous SCP iterations.\n\n    Pre-buffers point clouds for all iterations and toggles visibility for performance.\n    Shows all previous iterations with viridis coloring to visualize convergence.\n\n    Args:\n        server: ViserServer instance\n        positions: List of position arrays per iteration, each shape (N, 3)\n        point_size: Size of ghost points\n        cmap_name: Matplotlib colormap name for ghost colors\n\n    Returns:\n        Tuple of (list of handles, update_callback)\n    \"\"\"\n    n_iterations = len(positions)\n    cmap = plt.get_cmap(cmap_name)\n\n    # Pre-create point clouds for all iterations with their colors\n    # (all initially hidden, shown progressively as ghosts)\n    handles = []\n    for i in range(n_iterations):\n        t = i / max(n_iterations - 1, 1)\n        rgb = cmap(t)[:3]\n        color = np.array([int(c * 255) for c in rgb], dtype=np.uint8)\n        pos = np.asarray(positions[i], dtype=np.float32)\n\n        handle = server.scene.add_point_cloud(\n            f\"/scp/ghosts/iter_{i}\",\n            points=pos,\n            colors=color,\n            point_size=point_size,\n            visible=False,  # All start hidden\n        )\n        handles.append(handle)\n\n    # Track which iterations are currently visible as ghosts\n    state = {\"visible_up_to\": -1}\n\n    def update(iter_idx: int) -&gt; None:\n        idx = min(iter_idx, n_iterations - 1)\n        # Ghosts are iterations 0 through idx-1 (everything before current)\n        new_visible_up_to = idx - 1\n\n        if new_visible_up_to != state[\"visible_up_to\"]:\n            # Show/hide only the iterations that changed\n            if new_visible_up_to &gt; state[\"visible_up_to\"]:\n                # Show newly visible ghosts\n                for i in range(state[\"visible_up_to\"] + 1, new_visible_up_to + 1):\n                    handles[i].visible = True\n            else:\n                # Hide ghosts that should no longer be visible\n                for i in range(new_visible_up_to + 1, state[\"visible_up_to\"] + 1):\n                    handles[i].visible = False\n            state[\"visible_up_to\"] = new_visible_up_to\n\n    return handles, update\n</code></pre>"},{"location":"reference/plotting/viser/scp/#openscvx.plotting.viser.scp.add_scp_iteration_attitudes","title":"<code>add_scp_iteration_attitudes(server: viser.ViserServer, positions: list[np.ndarray], attitudes: list[np.ndarray] | None, axes_length: float = 1.5, axes_radius: float = 0.03, stride: int = 1) -&gt; tuple[list[viser.FrameHandle], UpdateCallback | None]</code>","text":"<p>Add animated attitude frames at each node that update per SCP iteration.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>positions</code> <code>list[ndarray]</code> <p>List of position arrays per iteration, each shape (N, 3)</p> required <code>attitudes</code> <code>list[ndarray] | None</code> <p>List of quaternion arrays per iteration, each shape (N, 4) in wxyz format. If None, returns empty list and None callback.</p> required <code>axes_length</code> <code>float</code> <p>Length of coordinate frame axes</p> <code>1.5</code> <code>axes_radius</code> <code>float</code> <p>Radius of axes cylinders</p> <code>0.03</code> <code>stride</code> <code>int</code> <p>Show attitude frame every <code>stride</code> nodes (1 = all nodes)</p> <code>1</code> <p>Returns:</p> Type Description <code>tuple[list[FrameHandle], UpdateCallback | None]</code> <p>Tuple of (list of frame handles, update_callback)</p> Source code in <code>openscvx/plotting/viser/scp.py</code> <pre><code>def add_scp_iteration_attitudes(\n    server: viser.ViserServer,\n    positions: list[np.ndarray],\n    attitudes: list[np.ndarray] | None,\n    axes_length: float = 1.5,\n    axes_radius: float = 0.03,\n    stride: int = 1,\n) -&gt; tuple[list[viser.FrameHandle], UpdateCallback | None]:\n    \"\"\"Add animated attitude frames at each node that update per SCP iteration.\n\n    Args:\n        server: ViserServer instance\n        positions: List of position arrays per iteration, each shape (N, 3)\n        attitudes: List of quaternion arrays per iteration, each shape (N, 4) in wxyz format.\n            If None, returns empty list and None callback.\n        axes_length: Length of coordinate frame axes\n        axes_radius: Radius of axes cylinders\n        stride: Show attitude frame every `stride` nodes (1 = all nodes)\n\n    Returns:\n        Tuple of (list of frame handles, update_callback)\n    \"\"\"\n    if attitudes is None:\n        return [], None\n\n    n_iterations = len(positions)\n    n_nodes = len(positions[0])\n\n    # Create frame handles for nodes at stride intervals\n    node_indices = list(range(0, n_nodes, stride))\n    handles = []\n\n    for i, node_idx in enumerate(node_indices):\n        handle = server.scene.add_frame(\n            f\"/scp/attitudes/frame_{i}\",\n            wxyz=attitudes[0][node_idx],\n            position=positions[0][node_idx],\n            axes_length=axes_length,\n            axes_radius=axes_radius,\n        )\n        handles.append(handle)\n\n    def update(iter_idx: int) -&gt; None:\n        idx = min(iter_idx, n_iterations - 1)\n        pos = positions[idx]\n        att = attitudes[idx]\n\n        for i, node_idx in enumerate(node_indices):\n            # Handle case where number of nodes changes between iterations\n            if node_idx &lt; len(pos) and node_idx &lt; len(att):\n                handles[i].position = pos[node_idx]\n                handles[i].wxyz = att[node_idx]\n\n    return handles, update\n</code></pre>"},{"location":"reference/plotting/viser/scp/#openscvx.plotting.viser.scp.add_scp_iteration_nodes","title":"<code>add_scp_iteration_nodes(server: viser.ViserServer, positions: list[np.ndarray], colors: list[tuple[int, int, int]] | None = None, point_size: float = 0.3, cmap_name: str = 'viridis') -&gt; tuple[list[viser.PointCloudHandle], UpdateCallback]</code>","text":"<p>Add animated optimization nodes that update per SCP iteration.</p> <p>Pre-buffers point clouds for all iterations and toggles visibility for performance. This avoids transmitting point data on every frame update.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>positions</code> <code>list[ndarray]</code> <p>List of position arrays per iteration, each shape (N, 3)</p> required <code>colors</code> <code>list[tuple[int, int, int]] | None</code> <p>Optional list of RGB colors per iteration. If None, uses viridis colormap.</p> <code>None</code> <code>point_size</code> <code>float</code> <p>Size of node markers</p> <code>0.3</code> <code>cmap_name</code> <code>str</code> <p>Matplotlib colormap name (default: \"viridis\")</p> <code>'viridis'</code> <p>Returns:</p> Type Description <code>tuple[list[PointCloudHandle], UpdateCallback]</code> <p>Tuple of (list of point_handles, update_callback)</p> Source code in <code>openscvx/plotting/viser/scp.py</code> <pre><code>def add_scp_iteration_nodes(\n    server: viser.ViserServer,\n    positions: list[np.ndarray],\n    colors: list[tuple[int, int, int]] | None = None,\n    point_size: float = 0.3,\n    cmap_name: str = \"viridis\",\n) -&gt; tuple[list[viser.PointCloudHandle], UpdateCallback]:\n    \"\"\"Add animated optimization nodes that update per SCP iteration.\n\n    Pre-buffers point clouds for all iterations and toggles visibility for performance.\n    This avoids transmitting point data on every frame update.\n\n    Args:\n        server: ViserServer instance\n        positions: List of position arrays per iteration, each shape (N, 3)\n        colors: Optional list of RGB colors per iteration. If None, uses viridis colormap.\n        point_size: Size of node markers\n        cmap_name: Matplotlib colormap name (default: \"viridis\")\n\n    Returns:\n        Tuple of (list of point_handles, update_callback)\n    \"\"\"\n    n_iterations = len(positions)\n\n    # Default: use viridis colormap\n    if colors is None:\n        cmap = plt.get_cmap(cmap_name)\n        colors = []\n        for i in range(n_iterations):\n            t = i / max(n_iterations - 1, 1)\n            rgb = cmap(t)[:3]\n            colors.append(tuple(int(c * 255) for c in rgb))\n\n    # Convert colors to numpy arrays for viser compatibility\n    colors_np = [np.array([c[0], c[1], c[2]], dtype=np.uint8) for c in colors]\n\n    # Pre-create point clouds for all iterations (only first visible initially)\n    handles = []\n    for i in range(n_iterations):\n        pos = np.asarray(positions[i], dtype=np.float32)\n        handle = server.scene.add_point_cloud(\n            f\"/scp/nodes/iter_{i}\",\n            points=pos,\n            colors=colors_np[i],\n            point_size=point_size,\n            visible=(i == 0),\n        )\n        handles.append(handle)\n\n    # Track current visible iteration to minimize visibility toggles\n    state = {\"current_idx\": 0}\n\n    def update(iter_idx: int) -&gt; None:\n        idx = min(iter_idx, n_iterations - 1)\n        if idx != state[\"current_idx\"]:\n            handles[state[\"current_idx\"]].visible = False\n            handles[idx].visible = True\n            state[\"current_idx\"] = idx\n\n    return handles, update\n</code></pre>"},{"location":"reference/plotting/viser/scp/#openscvx.plotting.viser.scp.add_scp_propagation_lines","title":"<code>add_scp_propagation_lines(server: viser.ViserServer, propagations: list[list[np.ndarray]], line_width: float = 2.0, cmap_name: str = 'viridis') -&gt; tuple[list, UpdateCallback]</code>","text":"<p>Add animated nonlinear propagation lines that update per SCP iteration.</p> <p>Shows the actual integrated trajectory between optimization nodes, revealing defects (gaps) in early iterations that close as SCP converges. All iterations up to the current one are shown with viridis coloring, similar to ghost iterations for nodes.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>ViserServer</code> <p>ViserServer instance</p> required <code>propagations</code> <code>list[list[ndarray]]</code> <p>List of propagation trajectories per iteration from extract_propagation_positions(). Each iteration contains a list of (n_substeps, 3) position arrays, one per segment.</p> required <code>line_width</code> <code>float</code> <p>Width of propagation lines</p> <code>2.0</code> <code>cmap_name</code> <code>str</code> <p>Matplotlib colormap name (default: \"viridis\")</p> <code>'viridis'</code> <p>Returns:</p> Type Description <code>tuple[list, UpdateCallback]</code> <p>Tuple of (list of line handles, update_callback)</p> Source code in <code>openscvx/plotting/viser/scp.py</code> <pre><code>def add_scp_propagation_lines(\n    server: viser.ViserServer,\n    propagations: list[list[np.ndarray]],\n    line_width: float = 2.0,\n    cmap_name: str = \"viridis\",\n) -&gt; tuple[list, UpdateCallback]:\n    \"\"\"Add animated nonlinear propagation lines that update per SCP iteration.\n\n    Shows the actual integrated trajectory between optimization nodes,\n    revealing defects (gaps) in early iterations that close as SCP converges.\n    All iterations up to the current one are shown with viridis coloring,\n    similar to ghost iterations for nodes.\n\n    Args:\n        server: ViserServer instance\n        propagations: List of propagation trajectories per iteration from\n            extract_propagation_positions(). Each iteration contains a list\n            of (n_substeps, 3) position arrays, one per segment.\n        line_width: Width of propagation lines\n        cmap_name: Matplotlib colormap name (default: \"viridis\")\n\n    Returns:\n        Tuple of (list of line handles, update_callback)\n    \"\"\"\n    if not propagations:\n        return [], lambda _: None\n\n    n_iterations = len(propagations)\n    n_segments = len(propagations[0])\n    cmap = plt.get_cmap(cmap_name)\n\n    # Pre-compute colors for each iteration\n    iteration_colors = []\n    for i in range(n_iterations):\n        t = i / max(n_iterations - 1, 1)\n        rgb = cmap(t)[:3]\n        iteration_colors.append(np.array([int(c * 255) for c in rgb], dtype=np.uint8))\n\n    # Create line handles for each (iteration, segment) pair\n    # Structure: handles[iter_idx][seg_idx]\n    all_handles = []\n\n    for iter_idx in range(n_iterations):\n        iter_handles = []\n        color = iteration_colors[iter_idx]\n\n        for seg_idx in range(n_segments):\n            seg_pos = propagations[iter_idx][seg_idx]  # Shape (n_substeps, 3)\n\n            if len(seg_pos) &lt; 2:\n                iter_handles.append(None)\n                continue\n\n            # Create line segments connecting consecutive substeps\n            segments = np.array(\n                [[seg_pos[i], seg_pos[i + 1]] for i in range(len(seg_pos) - 1)],\n                dtype=np.float32,\n            )\n\n            handle = server.scene.add_line_segments(\n                f\"/scp/propagation/iter_{iter_idx}/segment_{seg_idx}\",\n                points=segments,\n                colors=color,\n                line_width=line_width,\n                visible=(iter_idx == 0),  # Only first iteration visible initially\n            )\n            iter_handles.append(handle)\n\n        all_handles.append(iter_handles)\n\n    def update(iter_idx: int) -&gt; None:\n        idx = min(iter_idx, n_iterations - 1)\n\n        # Show all iterations up to and including current, hide the rest\n        for i in range(n_iterations):\n            should_show = i &lt;= idx\n            for handle in all_handles[i]:\n                if handle is not None:\n                    handle.visible = should_show\n\n    return all_handles, update\n</code></pre>"},{"location":"reference/plotting/viser/scp/#openscvx.plotting.viser.scp.extract_propagation_positions","title":"<code>extract_propagation_positions(discretization_history: list[np.ndarray], n_x: int, n_u: int, position_slice: slice, scene_scale: float = 1.0) -&gt; list[list[np.ndarray]]</code>","text":"<p>Extract 3D position trajectories from discretization history.</p> <p>The discretization history contains the multi-shot integration results. Each V matrix has shape (flattened_size, n_timesteps) where: - flattened_size = (N-1) * i4 - i4 = n_x + n_x*n_x + 2*n_x*n_u (state + STM + control influence matrices) - n_timesteps = number of integration substeps</p> <p>Parameters:</p> Name Type Description Default <code>discretization_history</code> <code>list[ndarray]</code> <p>List of V matrices from each SCP iteration</p> required <code>n_x</code> <code>int</code> <p>Number of states</p> required <code>n_u</code> <code>int</code> <p>Number of controls</p> required <code>position_slice</code> <code>slice</code> <p>Slice for extracting position from state vector</p> required <code>scene_scale</code> <code>float</code> <p>Divide positions by this factor for visualization</p> <code>1.0</code> <p>Returns:</p> Type Description <code>list[list[ndarray]]</code> <p>List of propagation trajectories per iteration.</p> <code>list[list[ndarray]]</code> <p>Each iteration contains a list of (n_substeps, 3) arrays, one per segment.</p> Source code in <code>openscvx/plotting/viser/scp.py</code> <pre><code>def extract_propagation_positions(\n    discretization_history: list[np.ndarray],\n    n_x: int,\n    n_u: int,\n    position_slice: slice,\n    scene_scale: float = 1.0,\n) -&gt; list[list[np.ndarray]]:\n    \"\"\"Extract 3D position trajectories from discretization history.\n\n    The discretization history contains the multi-shot integration results.\n    Each V matrix has shape (flattened_size, n_timesteps) where:\n    - flattened_size = (N-1) * i4\n    - i4 = n_x + n_x*n_x + 2*n_x*n_u (state + STM + control influence matrices)\n    - n_timesteps = number of integration substeps\n\n    Args:\n        discretization_history: List of V matrices from each SCP iteration\n        n_x: Number of states\n        n_u: Number of controls\n        position_slice: Slice for extracting position from state vector\n        scene_scale: Divide positions by this factor for visualization\n\n    Returns:\n        List of propagation trajectories per iteration.\n        Each iteration contains a list of (n_substeps, 3) arrays, one per segment.\n    \"\"\"\n    if not discretization_history:\n        return []\n\n    i4 = n_x + n_x * n_x + 2 * n_x * n_u\n    propagations = []\n\n    for V in discretization_history:\n        # V shape: (flattened_size, n_timesteps)\n        n_timesteps = V.shape[1]\n        n_segments = V.shape[0] // i4  # N-1 segments\n\n        iteration_segments = []\n        for seg_idx in range(n_segments):\n            # Extract this segment's data across all timesteps\n            seg_start = seg_idx * i4\n            seg_end = seg_start + i4\n\n            # For each timestep, extract the position from the state\n            segment_positions = []\n            for t_idx in range(n_timesteps):\n                # Get full state at this segment and timestep\n                state = V[seg_start:seg_end, t_idx][:n_x]\n                # Extract position components\n                pos = state[position_slice] / scene_scale\n                segment_positions.append(pos)\n\n            iteration_segments.append(np.array(segment_positions, dtype=np.float32))\n\n        propagations.append(iteration_segments)\n\n    return propagations\n</code></pre>"},{"location":"reference/plotting/viser/server/","title":"server","text":"<p>Viser server setup utilities.</p>"},{"location":"reference/plotting/viser/server/#openscvx.plotting.viser.server.compute_grid_size","title":"<code>compute_grid_size(pos: np.ndarray, padding: float = 1.2) -&gt; float</code>","text":"<p>Compute grid size based on trajectory extent.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>ndarray</code> <p>Position array of shape (N, 3)</p> required <code>padding</code> <code>float</code> <p>Padding factor (1.2 = 20% padding)</p> <code>1.2</code> <p>Returns:</p> Type Description <code>float</code> <p>Grid size (width and height)</p> Source code in <code>openscvx/plotting/viser/server.py</code> <pre><code>def compute_grid_size(pos: np.ndarray, padding: float = 1.2) -&gt; float:\n    \"\"\"Compute grid size based on trajectory extent.\n\n    Args:\n        pos: Position array of shape (N, 3)\n        padding: Padding factor (1.2 = 20% padding)\n\n    Returns:\n        Grid size (width and height)\n    \"\"\"\n    max_x = np.abs(pos[:, 0]).max()\n    max_y = np.abs(pos[:, 1]).max()\n    return max(max_x, max_y) * 2 * padding\n</code></pre>"},{"location":"reference/plotting/viser/server/#openscvx.plotting.viser.server.compute_velocity_colors","title":"<code>compute_velocity_colors(vel: np.ndarray, cmap_name: str = 'viridis') -&gt; np.ndarray</code>","text":"<p>Compute RGB colors based on velocity magnitude.</p> <p>Parameters:</p> Name Type Description Default <code>vel</code> <code>ndarray</code> <p>Velocity array of shape (N, 3)</p> required <code>cmap_name</code> <code>str</code> <p>Matplotlib colormap name</p> <code>'viridis'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of RGB colors with shape (N, 3), values in [0, 255]</p> Source code in <code>openscvx/plotting/viser/server.py</code> <pre><code>def compute_velocity_colors(vel: np.ndarray, cmap_name: str = \"viridis\") -&gt; np.ndarray:\n    \"\"\"Compute RGB colors based on velocity magnitude.\n\n    Args:\n        vel: Velocity array of shape (N, 3)\n        cmap_name: Matplotlib colormap name\n\n    Returns:\n        Array of RGB colors with shape (N, 3), values in [0, 255]\n    \"\"\"\n    vel_norms = np.linalg.norm(vel, axis=1)\n    vel_range = vel_norms.max() - vel_norms.min()\n    if vel_range &lt; 1e-8:\n        vel_normalized = np.zeros_like(vel_norms)\n    else:\n        vel_normalized = (vel_norms - vel_norms.min()) / vel_range\n\n    cmap = plt.get_cmap(cmap_name)\n    colors = np.array([[int(c * 255) for c in cmap(v)[:3]] for v in vel_normalized])\n    return colors\n</code></pre>"},{"location":"reference/plotting/viser/server/#openscvx.plotting.viser.server.create_server","title":"<code>create_server(pos: np.ndarray, dark_mode: bool = True, show_grid: bool = True) -&gt; viser.ViserServer</code>","text":"<p>Create a viser server with basic scene setup.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>ndarray</code> <p>Position array for computing grid size</p> required <code>dark_mode</code> <code>bool</code> <p>Whether to use dark theme</p> <code>True</code> <code>show_grid</code> <code>bool</code> <p>Whether to show the grid (default True)</p> <code>True</code> <p>Returns:</p> Type Description <code>ViserServer</code> <p>ViserServer instance with grid and origin frame</p> Source code in <code>openscvx/plotting/viser/server.py</code> <pre><code>def create_server(\n    pos: np.ndarray,\n    dark_mode: bool = True,\n    show_grid: bool = True,\n) -&gt; viser.ViserServer:\n    \"\"\"Create a viser server with basic scene setup.\n\n    Args:\n        pos: Position array for computing grid size\n        dark_mode: Whether to use dark theme\n        show_grid: Whether to show the grid (default True)\n\n    Returns:\n        ViserServer instance with grid and origin frame\n    \"\"\"\n    server = viser.ViserServer()\n\n    # Configure theme with OpenSCvx branding\n    # TitlebarButton and TitlebarConfig are TypedDict classes (create as plain dicts)\n    buttons = (\n        TitlebarButton(\n            text=\"Getting Started\",\n            icon=\"Description\",\n            href=\"https://haynec.github.io/OpenSCvx/latest/getting-started/\",\n        ),\n        TitlebarButton(\n            text=\"Docs\",\n            icon=\"Description\",\n            href=\"https://haynec.github.io/OpenSCvx/\",\n        ),\n        TitlebarButton(\n            text=\"GitHub\",\n            icon=\"GitHub\",\n            href=\"https://github.com/haynec/OpenSCvx\",\n        ),\n    )\n\n    # Add OpenSCvx logo to titlebar (loaded from GitHub)\n    logo_url = (\n        \"https://raw.githubusercontent.com/haynec/OpenSCvx/main/figures/openscvx_logo_square.png\"\n    )\n    image = TitlebarImage(\n        image_url_light=logo_url,\n        image_url_dark=logo_url,  # Use same logo for both themes\n        image_alt=\"OpenSCvx\",\n        href=\"https://github.com/haynec/OpenSCvx\",\n    )\n\n    titlebar_config = TitlebarConfig(buttons=buttons, image=image)\n\n    server.gui.configure_theme(\n        titlebar_content=titlebar_config,\n        dark_mode=dark_mode,\n    )\n\n    if show_grid:\n        grid_size = compute_grid_size(pos)\n        server.scene.add_grid(\n            \"/grid\",\n            width=grid_size,\n            height=grid_size,\n            position=np.array([0.0, 0.0, 0.0]),\n        )\n    server.scene.add_frame(\n        \"/origin\",\n        wxyz=(1.0, 0.0, 0.0, 0.0),\n        position=(0.0, 0.0, 0.0),\n    )\n\n    return server\n</code></pre>"},{"location":"reference/propagation/","title":"propagation","text":"<p>Trajectory propagation for trajectory optimization.</p> <p>This module provides implementations of trajectory propagation methods that simulate the nonlinear system dynamics forward in time. Propagation is used to evaluate solution quality, verify constraint satisfaction, and generate high-fidelity trajectories from optimized control sequences.</p> Current Implementations <p>Forward Simulation: The default propagation method that integrates the     nonlinear dynamics forward in time using adaptive or fixed-step     numerical integration (via Diffrax). Supports both ZOH and FOH     control interpolation schemes.</p> <p>Planned Architecture (ABC-based):</p> <p>A base class will be introduced to enable pluggable propagation methods. This will enable users to implement custom propagation methods. Future propagators will implement the Propagator interface:</p> <pre><code># propagation/base.py (planned):\nclass Propagator(ABC):\n    def __init__(self, integrator: Integrator):\n        '''Initialize with a numerical integrator.'''\n        self.integrator = integrator\n\n    @abstractmethod\n    def propagate(self, dynamics, x0, u_traj, time_grid) -&gt; Array:\n        '''Propagate trajectory forward in time.\n\n        Args:\n            dynamics: Continuous-time dynamics object\n            x0: Initial state\n            u_traj: Control trajectory\n            time_grid: Time points for dense output\n\n        Returns:\n            State trajectory evaluated at time_grid points\n        '''\n        ...\n</code></pre>"},{"location":"reference/propagation/#openscvx.propagation.get_propagation_solver","title":"<code>get_propagation_solver(state_dot: Dynamics, settings: Config)</code>","text":"<p>Create a propagation solver function.</p> <p>This function creates a solver that propagates the system state using the specified dynamics and settings.</p> <p>Parameters:</p> Name Type Description Default <code>state_dot</code> <code>callable</code> <p>Function computing state derivatives.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings for propagation.</p> required <code>param_map</code> <code>dict</code> <p>Mapping of parameter names to values.</p> required <p>Returns:</p> Name Type Description <code>callable</code> <p>A function that solves the propagation problem.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def get_propagation_solver(state_dot: Dynamics, settings: Config):\n    \"\"\"Create a propagation solver function.\n\n    This function creates a solver that propagates the system state using the\n    specified dynamics and settings.\n\n    Args:\n        state_dot (callable): Function computing state derivatives.\n        settings: Configuration settings for propagation.\n        param_map (dict): Mapping of parameter names to values.\n\n    Returns:\n        callable: A function that solves the propagation problem.\n    \"\"\"\n\n    def propagation_solver(\n        V0, tau_grid, u_cur, u_next, tau_init, node, idx_s, save_time, mask, params\n    ):\n        param_map_update = params\n        return solve_ivp_diffrax_prop(\n            f=prop_aug_dy,\n            tau_final=tau_grid[1],  # scalar\n            y_0=V0,  # shape (n_states,)\n            args=(\n                u_cur,  # shape (1, n_controls)\n                u_next,  # shape (1, n_controls)\n                tau_init,  # shape (1, 1)\n                node,  # shape (1, 1)\n                idx_s,  # int\n                state_dot,  # function or array\n                settings.dis.dis_type,\n                settings.scp.n,\n                param_map_update,\n                # additional named parameters as **kwargs\n            ),\n            tau_0=tau_grid[0],  # scalar\n            solver_name=settings.prp.solver,\n            rtol=settings.prp.rtol,\n            atol=settings.prp.atol,\n            extra_kwargs=settings.prp.args,\n            save_time=save_time,  # shape (MAX_TAU_LEN,)\n            mask=mask,  # shape (MAX_TAU_LEN,), dtype=bool\n        )\n\n    return propagation_solver\n</code></pre>"},{"location":"reference/propagation/#openscvx.propagation.prop_aug_dy","title":"<code>prop_aug_dy(tau: float, x: np.ndarray, u_current: np.ndarray, u_next: np.ndarray, tau_init: float, node: int, idx_s: int, state_dot: callable, dis_type: str, N: int, params) -&gt; np.ndarray</code>","text":"<p>Compute the augmented dynamics for propagation.</p> <p>This function computes the time-scaled dynamics for propagating the system state, taking into account the discretization type (ZOH or FOH) and time dilation.</p> <p>Parameters:</p> Name Type Description Default <code>tau</code> <code>float</code> <p>Current normalized time in [0,1].</p> required <code>x</code> <code>ndarray</code> <p>Current state vector.</p> required <code>u_current</code> <code>ndarray</code> <p>Control input at current node.</p> required <code>u_next</code> <code>ndarray</code> <p>Control input at next node.</p> required <code>tau_init</code> <code>float</code> <p>Initial normalized time.</p> required <code>node</code> <code>int</code> <p>Current node index.</p> required <code>idx_s</code> <code>int</code> <p>Index of time dilation variable in control vector.</p> required <code>state_dot</code> <code>callable</code> <p>Function computing state derivatives.</p> required <code>dis_type</code> <code>str</code> <p>Discretization type (\"ZOH\" or \"FOH\").</p> required <code>N</code> <code>int</code> <p>Number of nodes in trajectory.</p> required <code>params</code> <p>Dictionary of additional parameters passed to state_dot.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Time-scaled state derivatives.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def prop_aug_dy(\n    tau: float,\n    x: np.ndarray,\n    u_current: np.ndarray,\n    u_next: np.ndarray,\n    tau_init: float,\n    node: int,\n    idx_s: int,\n    state_dot: callable,\n    dis_type: str,\n    N: int,\n    params,\n) -&gt; np.ndarray:\n    \"\"\"Compute the augmented dynamics for propagation.\n\n    This function computes the time-scaled dynamics for propagating the system state,\n    taking into account the discretization type (ZOH or FOH) and time dilation.\n\n    Args:\n        tau (float): Current normalized time in [0,1].\n        x (np.ndarray): Current state vector.\n        u_current (np.ndarray): Control input at current node.\n        u_next (np.ndarray): Control input at next node.\n        tau_init (float): Initial normalized time.\n        node (int): Current node index.\n        idx_s (int): Index of time dilation variable in control vector.\n        state_dot (callable): Function computing state derivatives.\n        dis_type (str): Discretization type (\"ZOH\" or \"FOH\").\n        N (int): Number of nodes in trajectory.\n        params: Dictionary of additional parameters passed to state_dot.\n\n    Returns:\n        np.ndarray: Time-scaled state derivatives.\n    \"\"\"\n    x = x[None, :]\n\n    if dis_type == \"ZOH\":\n        beta = 0.0\n    elif dis_type == \"FOH\":\n        beta = (tau - tau_init) * N\n    u = u_current + beta * (u_next - u_current)\n\n    return u[:, idx_s] * state_dot(x, u[:, :-1], node, params).squeeze()\n</code></pre>"},{"location":"reference/propagation/#openscvx.propagation.propagate_trajectory_results","title":"<code>propagate_trajectory_results(params: dict, settings: Config, result: OptimizationResults, propagation_solver: callable, algebraic_prop: Optional[dict] = None) -&gt; OptimizationResults</code>","text":"<p>Propagate the optimal trajectory and compute additional results.</p> <p>This function takes the optimal control solution and propagates it through the nonlinear dynamics to compute the actual state trajectory and other metrics.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>System parameters.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings.</p> required <code>result</code> <code>OptimizationResults</code> <p>Optimization results object.</p> required <code>propagation_solver</code> <code>callable</code> <p>Function for propagating the system state.</p> required <code>algebraic_prop</code> <code>dict</code> <p>Dictionary mapping output names to vmapped JAX functions.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OptimizationResults</code> <code>OptimizationResults</code> <p>Updated results object containing: - t_full: Full time vector - x_full: Full state trajectory - u_full: Full control trajectory - cost: Computed cost - ctcs_violation: CTCS constraint violation - trajectory: Dict containing each variables values at full propagation fidelity</p> Source code in <code>openscvx/propagation/post_processing.py</code> <pre><code>def propagate_trajectory_results(\n    params: dict,\n    settings: Config,\n    result: OptimizationResults,\n    propagation_solver: callable,\n    algebraic_prop: Optional[dict] = None,\n) -&gt; OptimizationResults:\n    \"\"\"Propagate the optimal trajectory and compute additional results.\n\n    This function takes the optimal control solution and propagates it through the\n    nonlinear dynamics to compute the actual state trajectory and other metrics.\n\n    Args:\n        params (dict): System parameters.\n        settings (Config): Configuration settings.\n        result (OptimizationResults): Optimization results object.\n        propagation_solver (callable): Function for propagating the system state.\n        algebraic_prop (dict, optional): Dictionary mapping output names to vmapped JAX functions.\n\n    Returns:\n        OptimizationResults: Updated results object containing:\n            - t_full: Full time vector\n            - x_full: Full state trajectory\n            - u_full: Full control trajectory\n            - cost: Computed cost\n            - ctcs_violation: CTCS constraint violation\n            - trajectory: Dict containing each variables values at full propagation fidelity\n    \"\"\"\n    # Get arrays from result\n    x = result.x\n    u = result.u\n\n    t = np.array(s_to_t(x, u, settings)).squeeze()\n\n    t_full = np.arange(t[0], t[-1], settings.prp.dt)\n\n    tau_vals, u_full = t_to_tau(u, t_full, t, settings)\n\n    # Create a copy of x_prop for propagation to avoid mutating settings\n    # Match free values from initial state to the initial value from the result\n    x_prop_for_propagation = copy.copy(settings.sim.x_prop)\n\n    # Only copy for states that exist in optimization (propagation may have extra states at the end)\n    n_opt_states = x.shape[1]\n    n_prop_states = settings.sim.x_prop.initial.shape[0]\n\n    if n_opt_states == n_prop_states:\n        # Same size - copy all\n        # Use metadata from settings (immutable configuration)\n        mask = jnp.array([t == \"Free\" for t in settings.sim.x.initial_type], dtype=bool)\n        x_prop_for_propagation.initial = jnp.where(mask, x[0, :], settings.sim.x_prop.initial)\n    else:\n        # Propagation has extra states - only copy the overlapping portion\n        # Use metadata from settings (immutable configuration)\n        mask = jnp.array([t == \"Free\" for t in settings.sim.x.initial_type], dtype=bool)\n        x_prop_initial_updated = settings.sim.x_prop.initial.copy()\n        x_prop_initial_updated[:n_opt_states] = jnp.where(\n            mask, x[0, :], settings.sim.x_prop.initial[:n_opt_states]\n        )\n        x_prop_for_propagation.initial = x_prop_initial_updated\n\n    # Temporarily replace x_prop with our modified copy for propagation\n    # Save original to restore after propagation\n    original_x_prop = settings.sim.x_prop\n    settings.sim.x_prop = x_prop_for_propagation\n\n    try:\n        x_full = simulate_nonlinear_time(params, x, u, tau_vals, t, settings, propagation_solver)\n    finally:\n        # Always restore original x_prop, even if propagation fails\n        settings.sim.x_prop = original_x_prop\n\n    # Calculate cost using utility function and metadata from settings\n    cost = calculate_cost_from_boundaries(x, settings.sim.x.initial_type, settings.sim.x.final_type)\n\n    # Calculate CTCS constraint violation\n    ctcs_violation = x_full[-1, settings.sim.ctcs_slice_prop]\n\n    # Build trajectory dictionary with all states and controls\n    trajectory_dict = {}\n\n    # Add all states (user-defined and augmented)\n    for state in result._states:\n        trajectory_dict[state.name] = x_full[:, state._slice]\n\n    # Add all controls (user-defined and augmented)\n    for control in result._controls:\n        trajectory_dict[control.name] = u_full[:, control._slice]\n\n    # Compute algebraic outputs (vmapped over time)\n    if algebraic_prop:\n        for name, output_fn in algebraic_prop.items():\n            # output_fn is vmapped: (T, n_x), (T, n_u), node, params -&gt; (T, output_dim)\n            # Pass node=0 since algebraic outputs shouldn't depend on node index\n            output_values = output_fn(x_full, u_full, 0, params)\n            trajectory_dict[name] = np.asarray(output_values)\n\n    # Update the results object with post-processing data\n    result.t_full = t_full\n    result.x_full = x_full\n    result.u_full = u_full\n    result.cost = cost\n    result.ctcs_violation = ctcs_violation\n    result.trajectory = trajectory_dict\n\n    return result\n</code></pre>"},{"location":"reference/propagation/#openscvx.propagation.s_to_t","title":"<code>s_to_t(x: np.ndarray, u: np.ndarray, settings: Config)</code>","text":"<p>Convert normalized time s to real time t.</p> <p>This function converts the normalized time variable s to real time t based on the discretization type and time dilation factors.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>State trajectory array, shape (N, n_states).</p> required <code>u</code> <code>ndarray</code> <p>Control trajectory array, shape (N, n_controls).</p> required <code>settings</code> <code>Config</code> <p>Configuration settings.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of real time points.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def s_to_t(x: np.ndarray, u: np.ndarray, settings: Config):\n    \"\"\"Convert normalized time s to real time t.\n\n    This function converts the normalized time variable s to real time t\n    based on the discretization type and time dilation factors.\n\n    Args:\n        x: State trajectory array, shape (N, n_states).\n        u: Control trajectory array, shape (N, n_controls).\n        settings (Config): Configuration settings.\n\n    Returns:\n        list: List of real time points.\n    \"\"\"\n    t = [x[:, settings.sim.time_slice][0]]\n    tau = np.linspace(0, 1, settings.scp.n)\n    for k in range(1, settings.scp.n):\n        s_kp = u[k - 1, -1]\n        s_k = u[k, -1]\n        if settings.dis.dis_type == \"ZOH\":\n            t.append(t[k - 1] + (tau[k] - tau[k - 1]) * (s_kp))\n        else:\n            t.append(t[k - 1] + 0.5 * (s_k + s_kp) * (tau[k] - tau[k - 1]))\n    return t\n</code></pre>"},{"location":"reference/propagation/#openscvx.propagation.simulate_nonlinear_time","title":"<code>simulate_nonlinear_time(params, x, u, tau_vals, t, settings, propagation_solver)</code>","text":"<p>Simulate the nonlinear system dynamics over time.</p> <p>This function simulates the system dynamics using the optimal control sequence and returns the resulting state trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <p>System parameters.</p> required <code>x</code> <p>State trajectory array, shape (N, n_states).</p> required <code>u</code> <p>Control trajectory array, shape (N, n_controls).</p> required <code>tau_vals</code> <code>ndarray</code> <p>Normalized time points for simulation.</p> required <code>t</code> <code>ndarray</code> <p>Real time points.</p> required <code>settings</code> <p>Configuration settings.</p> required <code>propagation_solver</code> <code>callable</code> <p>Function for propagating the system state.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Simulated state trajectory.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def simulate_nonlinear_time(params, x, u, tau_vals, t, settings, propagation_solver):\n    \"\"\"Simulate the nonlinear system dynamics over time.\n\n    This function simulates the system dynamics using the optimal control sequence\n    and returns the resulting state trajectory.\n\n    Args:\n        params: System parameters.\n        x: State trajectory array, shape (N, n_states).\n        u: Control trajectory array, shape (N, n_controls).\n        tau_vals (np.ndarray): Normalized time points for simulation.\n        t (np.ndarray): Real time points.\n        settings: Configuration settings.\n        propagation_solver (callable): Function for propagating the system state.\n\n    Returns:\n        np.ndarray: Simulated state trajectory.\n    \"\"\"\n    x_0 = settings.sim.x_prop.initial\n\n    n_segments = settings.scp.n - 1\n    n_states = x_0.shape[0]\n    n_tau = len(tau_vals)\n\n    states = np.empty((n_states, n_tau))\n    tau = np.linspace(0, 1, settings.scp.n)\n\n    # Precompute control interpolation\n    u_interp = np.stack([np.interp(t, t, u[:, i]) for i in range(u.shape[1])], axis=-1)\n\n    # Bin tau_vals into segments of tau\n    tau_inds = np.digitize(tau_vals, tau) - 1\n    tau_inds = np.where(tau_inds == settings.scp.n - 1, settings.scp.n - 2, tau_inds)\n\n    prev_count = 0\n    out_idx = 0\n\n    for k in range(n_segments):\n        controls_current = u_interp[k][None, :]\n        controls_next = u_interp[k + 1][None, :]\n\n        # Mask for tau_vals in current segment\n        mask = (tau_inds &gt;= k) &amp; (tau_inds &lt; k + 1)\n        count = np.sum(mask)\n\n        tau_cur = tau_vals[prev_count : prev_count + count]\n        tau_cur = np.concatenate([tau_cur, np.array([tau[k + 1]])])  # Always include final point\n        count += 1\n\n        # Pad to fixed length\n        pad_len = settings.prp.max_tau_len - count\n        tau_cur_padded = np.pad(tau_cur, (0, pad_len), constant_values=tau[k + 1])\n        mask_padded = np.concatenate([np.ones(count), np.zeros(pad_len)]).astype(bool)\n\n        # Call the solver with padded tau_cur and mask\n        sol = propagation_solver.call(\n            x_0,\n            (tau[k], tau[k + 1]),\n            controls_current,\n            controls_next,\n            np.array([[tau[k]]]),\n            np.array([[k]]),\n            settings.sim.time_dilation_slice.stop,\n            tau_cur_padded,\n            mask_padded,\n            params,\n        )\n\n        # Only store the valid portion (excluding the final point which becomes next x_0)\n        states[:, out_idx : out_idx + count - 1] = sol[: count - 1].T\n        out_idx += count - 1\n        x_0 = sol[count - 1]  # Last value used as next x_0\n\n        prev_count += count - 1\n\n    return states.T\n</code></pre>"},{"location":"reference/propagation/#openscvx.propagation.t_to_tau","title":"<code>t_to_tau(u: np.ndarray, t, t_nodal, settings: Config)</code>","text":"<p>Convert real time t to normalized time tau.</p> <p>This function converts real time t to normalized time tau and interpolates the control inputs accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>ndarray</code> <p>Control trajectory array, shape (N, n_controls).</p> required <code>t</code> <code>ndarray</code> <p>Real time points.</p> required <code>t_nodal</code> <code>ndarray</code> <p>Nodal time points.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(tau, u_interp) where tau is normalized time and u_interp is interpolated controls.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def t_to_tau(u: np.ndarray, t, t_nodal, settings: Config):\n    \"\"\"Convert real time t to normalized time tau.\n\n    This function converts real time t to normalized time tau and interpolates\n    the control inputs accordingly.\n\n    Args:\n        u (np.ndarray): Control trajectory array, shape (N, n_controls).\n        t (np.ndarray): Real time points.\n        t_nodal (np.ndarray): Nodal time points.\n        settings (Config): Configuration settings.\n\n    Returns:\n        tuple: (tau, u_interp) where tau is normalized time and u_interp is interpolated controls.\n    \"\"\"\n    if settings.dis.dis_type == \"ZOH\":\n        # Zero-Order Hold: step interpolation (hold previous value)\n        def u_lam(new_t):\n            # Find the index of the last nodal time &lt;= new_t\n            idx = np.searchsorted(t_nodal, new_t, side=\"right\") - 1\n            idx = np.clip(idx, 0, len(t_nodal) - 1)\n            return u[idx, :]\n    elif settings.dis.dis_type == \"FOH\":\n        # First-Order Hold: linear interpolation\n        def u_lam(new_t):\n            return np.array([np.interp(new_t, t_nodal, u[:, i]) for i in range(u.shape[1])]).T\n    else:\n        raise ValueError(\"Currently unsupported discretization type\")\n\n    u_interp = np.array([u_lam(t_i) for t_i in t])\n\n    tau = np.zeros(len(t))\n    tau_nodal = np.linspace(0, 1, settings.scp.n)\n    for k in range(1, len(t)):\n        k_nodal = np.where(t_nodal &lt; t[k])[0][-1]\n        s_kp = u[k_nodal, -1]\n        tp = t_nodal[k_nodal]\n        tau_p = tau_nodal[k_nodal]\n\n        s_k = u[k_nodal + 1, -1]\n        if settings.dis.dis_type == \"ZOH\":\n            tau[k] = tau_p + (t[k] - tp) / s_kp\n        else:\n            tau[k] = tau_p + 2 * (t[k] - tp) / (s_k + s_kp)\n    return tau, u_interp\n</code></pre>"},{"location":"reference/propagation/post_processing/","title":"post_processing","text":""},{"location":"reference/propagation/post_processing/#openscvx.propagation.post_processing.propagate_trajectory_results","title":"<code>propagate_trajectory_results(params: dict, settings: Config, result: OptimizationResults, propagation_solver: callable, algebraic_prop: Optional[dict] = None) -&gt; OptimizationResults</code>","text":"<p>Propagate the optimal trajectory and compute additional results.</p> <p>This function takes the optimal control solution and propagates it through the nonlinear dynamics to compute the actual state trajectory and other metrics.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>System parameters.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings.</p> required <code>result</code> <code>OptimizationResults</code> <p>Optimization results object.</p> required <code>propagation_solver</code> <code>callable</code> <p>Function for propagating the system state.</p> required <code>algebraic_prop</code> <code>dict</code> <p>Dictionary mapping output names to vmapped JAX functions.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OptimizationResults</code> <code>OptimizationResults</code> <p>Updated results object containing: - t_full: Full time vector - x_full: Full state trajectory - u_full: Full control trajectory - cost: Computed cost - ctcs_violation: CTCS constraint violation - trajectory: Dict containing each variables values at full propagation fidelity</p> Source code in <code>openscvx/propagation/post_processing.py</code> <pre><code>def propagate_trajectory_results(\n    params: dict,\n    settings: Config,\n    result: OptimizationResults,\n    propagation_solver: callable,\n    algebraic_prop: Optional[dict] = None,\n) -&gt; OptimizationResults:\n    \"\"\"Propagate the optimal trajectory and compute additional results.\n\n    This function takes the optimal control solution and propagates it through the\n    nonlinear dynamics to compute the actual state trajectory and other metrics.\n\n    Args:\n        params (dict): System parameters.\n        settings (Config): Configuration settings.\n        result (OptimizationResults): Optimization results object.\n        propagation_solver (callable): Function for propagating the system state.\n        algebraic_prop (dict, optional): Dictionary mapping output names to vmapped JAX functions.\n\n    Returns:\n        OptimizationResults: Updated results object containing:\n            - t_full: Full time vector\n            - x_full: Full state trajectory\n            - u_full: Full control trajectory\n            - cost: Computed cost\n            - ctcs_violation: CTCS constraint violation\n            - trajectory: Dict containing each variables values at full propagation fidelity\n    \"\"\"\n    # Get arrays from result\n    x = result.x\n    u = result.u\n\n    t = np.array(s_to_t(x, u, settings)).squeeze()\n\n    t_full = np.arange(t[0], t[-1], settings.prp.dt)\n\n    tau_vals, u_full = t_to_tau(u, t_full, t, settings)\n\n    # Create a copy of x_prop for propagation to avoid mutating settings\n    # Match free values from initial state to the initial value from the result\n    x_prop_for_propagation = copy.copy(settings.sim.x_prop)\n\n    # Only copy for states that exist in optimization (propagation may have extra states at the end)\n    n_opt_states = x.shape[1]\n    n_prop_states = settings.sim.x_prop.initial.shape[0]\n\n    if n_opt_states == n_prop_states:\n        # Same size - copy all\n        # Use metadata from settings (immutable configuration)\n        mask = jnp.array([t == \"Free\" for t in settings.sim.x.initial_type], dtype=bool)\n        x_prop_for_propagation.initial = jnp.where(mask, x[0, :], settings.sim.x_prop.initial)\n    else:\n        # Propagation has extra states - only copy the overlapping portion\n        # Use metadata from settings (immutable configuration)\n        mask = jnp.array([t == \"Free\" for t in settings.sim.x.initial_type], dtype=bool)\n        x_prop_initial_updated = settings.sim.x_prop.initial.copy()\n        x_prop_initial_updated[:n_opt_states] = jnp.where(\n            mask, x[0, :], settings.sim.x_prop.initial[:n_opt_states]\n        )\n        x_prop_for_propagation.initial = x_prop_initial_updated\n\n    # Temporarily replace x_prop with our modified copy for propagation\n    # Save original to restore after propagation\n    original_x_prop = settings.sim.x_prop\n    settings.sim.x_prop = x_prop_for_propagation\n\n    try:\n        x_full = simulate_nonlinear_time(params, x, u, tau_vals, t, settings, propagation_solver)\n    finally:\n        # Always restore original x_prop, even if propagation fails\n        settings.sim.x_prop = original_x_prop\n\n    # Calculate cost using utility function and metadata from settings\n    cost = calculate_cost_from_boundaries(x, settings.sim.x.initial_type, settings.sim.x.final_type)\n\n    # Calculate CTCS constraint violation\n    ctcs_violation = x_full[-1, settings.sim.ctcs_slice_prop]\n\n    # Build trajectory dictionary with all states and controls\n    trajectory_dict = {}\n\n    # Add all states (user-defined and augmented)\n    for state in result._states:\n        trajectory_dict[state.name] = x_full[:, state._slice]\n\n    # Add all controls (user-defined and augmented)\n    for control in result._controls:\n        trajectory_dict[control.name] = u_full[:, control._slice]\n\n    # Compute algebraic outputs (vmapped over time)\n    if algebraic_prop:\n        for name, output_fn in algebraic_prop.items():\n            # output_fn is vmapped: (T, n_x), (T, n_u), node, params -&gt; (T, output_dim)\n            # Pass node=0 since algebraic outputs shouldn't depend on node index\n            output_values = output_fn(x_full, u_full, 0, params)\n            trajectory_dict[name] = np.asarray(output_values)\n\n    # Update the results object with post-processing data\n    result.t_full = t_full\n    result.x_full = x_full\n    result.u_full = u_full\n    result.cost = cost\n    result.ctcs_violation = ctcs_violation\n    result.trajectory = trajectory_dict\n\n    return result\n</code></pre>"},{"location":"reference/propagation/propagation/","title":"propagation","text":""},{"location":"reference/propagation/propagation/#openscvx.propagation.propagation.get_propagation_solver","title":"<code>get_propagation_solver(state_dot: Dynamics, settings: Config)</code>","text":"<p>Create a propagation solver function.</p> <p>This function creates a solver that propagates the system state using the specified dynamics and settings.</p> <p>Parameters:</p> Name Type Description Default <code>state_dot</code> <code>callable</code> <p>Function computing state derivatives.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings for propagation.</p> required <code>param_map</code> <code>dict</code> <p>Mapping of parameter names to values.</p> required <p>Returns:</p> Name Type Description <code>callable</code> <p>A function that solves the propagation problem.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def get_propagation_solver(state_dot: Dynamics, settings: Config):\n    \"\"\"Create a propagation solver function.\n\n    This function creates a solver that propagates the system state using the\n    specified dynamics and settings.\n\n    Args:\n        state_dot (callable): Function computing state derivatives.\n        settings: Configuration settings for propagation.\n        param_map (dict): Mapping of parameter names to values.\n\n    Returns:\n        callable: A function that solves the propagation problem.\n    \"\"\"\n\n    def propagation_solver(\n        V0, tau_grid, u_cur, u_next, tau_init, node, idx_s, save_time, mask, params\n    ):\n        param_map_update = params\n        return solve_ivp_diffrax_prop(\n            f=prop_aug_dy,\n            tau_final=tau_grid[1],  # scalar\n            y_0=V0,  # shape (n_states,)\n            args=(\n                u_cur,  # shape (1, n_controls)\n                u_next,  # shape (1, n_controls)\n                tau_init,  # shape (1, 1)\n                node,  # shape (1, 1)\n                idx_s,  # int\n                state_dot,  # function or array\n                settings.dis.dis_type,\n                settings.scp.n,\n                param_map_update,\n                # additional named parameters as **kwargs\n            ),\n            tau_0=tau_grid[0],  # scalar\n            solver_name=settings.prp.solver,\n            rtol=settings.prp.rtol,\n            atol=settings.prp.atol,\n            extra_kwargs=settings.prp.args,\n            save_time=save_time,  # shape (MAX_TAU_LEN,)\n            mask=mask,  # shape (MAX_TAU_LEN,), dtype=bool\n        )\n\n    return propagation_solver\n</code></pre>"},{"location":"reference/propagation/propagation/#openscvx.propagation.propagation.prop_aug_dy","title":"<code>prop_aug_dy(tau: float, x: np.ndarray, u_current: np.ndarray, u_next: np.ndarray, tau_init: float, node: int, idx_s: int, state_dot: callable, dis_type: str, N: int, params) -&gt; np.ndarray</code>","text":"<p>Compute the augmented dynamics for propagation.</p> <p>This function computes the time-scaled dynamics for propagating the system state, taking into account the discretization type (ZOH or FOH) and time dilation.</p> <p>Parameters:</p> Name Type Description Default <code>tau</code> <code>float</code> <p>Current normalized time in [0,1].</p> required <code>x</code> <code>ndarray</code> <p>Current state vector.</p> required <code>u_current</code> <code>ndarray</code> <p>Control input at current node.</p> required <code>u_next</code> <code>ndarray</code> <p>Control input at next node.</p> required <code>tau_init</code> <code>float</code> <p>Initial normalized time.</p> required <code>node</code> <code>int</code> <p>Current node index.</p> required <code>idx_s</code> <code>int</code> <p>Index of time dilation variable in control vector.</p> required <code>state_dot</code> <code>callable</code> <p>Function computing state derivatives.</p> required <code>dis_type</code> <code>str</code> <p>Discretization type (\"ZOH\" or \"FOH\").</p> required <code>N</code> <code>int</code> <p>Number of nodes in trajectory.</p> required <code>params</code> <p>Dictionary of additional parameters passed to state_dot.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Time-scaled state derivatives.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def prop_aug_dy(\n    tau: float,\n    x: np.ndarray,\n    u_current: np.ndarray,\n    u_next: np.ndarray,\n    tau_init: float,\n    node: int,\n    idx_s: int,\n    state_dot: callable,\n    dis_type: str,\n    N: int,\n    params,\n) -&gt; np.ndarray:\n    \"\"\"Compute the augmented dynamics for propagation.\n\n    This function computes the time-scaled dynamics for propagating the system state,\n    taking into account the discretization type (ZOH or FOH) and time dilation.\n\n    Args:\n        tau (float): Current normalized time in [0,1].\n        x (np.ndarray): Current state vector.\n        u_current (np.ndarray): Control input at current node.\n        u_next (np.ndarray): Control input at next node.\n        tau_init (float): Initial normalized time.\n        node (int): Current node index.\n        idx_s (int): Index of time dilation variable in control vector.\n        state_dot (callable): Function computing state derivatives.\n        dis_type (str): Discretization type (\"ZOH\" or \"FOH\").\n        N (int): Number of nodes in trajectory.\n        params: Dictionary of additional parameters passed to state_dot.\n\n    Returns:\n        np.ndarray: Time-scaled state derivatives.\n    \"\"\"\n    x = x[None, :]\n\n    if dis_type == \"ZOH\":\n        beta = 0.0\n    elif dis_type == \"FOH\":\n        beta = (tau - tau_init) * N\n    u = u_current + beta * (u_next - u_current)\n\n    return u[:, idx_s] * state_dot(x, u[:, :-1], node, params).squeeze()\n</code></pre>"},{"location":"reference/propagation/propagation/#openscvx.propagation.propagation.s_to_t","title":"<code>s_to_t(x: np.ndarray, u: np.ndarray, settings: Config)</code>","text":"<p>Convert normalized time s to real time t.</p> <p>This function converts the normalized time variable s to real time t based on the discretization type and time dilation factors.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>State trajectory array, shape (N, n_states).</p> required <code>u</code> <code>ndarray</code> <p>Control trajectory array, shape (N, n_controls).</p> required <code>settings</code> <code>Config</code> <p>Configuration settings.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of real time points.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def s_to_t(x: np.ndarray, u: np.ndarray, settings: Config):\n    \"\"\"Convert normalized time s to real time t.\n\n    This function converts the normalized time variable s to real time t\n    based on the discretization type and time dilation factors.\n\n    Args:\n        x: State trajectory array, shape (N, n_states).\n        u: Control trajectory array, shape (N, n_controls).\n        settings (Config): Configuration settings.\n\n    Returns:\n        list: List of real time points.\n    \"\"\"\n    t = [x[:, settings.sim.time_slice][0]]\n    tau = np.linspace(0, 1, settings.scp.n)\n    for k in range(1, settings.scp.n):\n        s_kp = u[k - 1, -1]\n        s_k = u[k, -1]\n        if settings.dis.dis_type == \"ZOH\":\n            t.append(t[k - 1] + (tau[k] - tau[k - 1]) * (s_kp))\n        else:\n            t.append(t[k - 1] + 0.5 * (s_k + s_kp) * (tau[k] - tau[k - 1]))\n    return t\n</code></pre>"},{"location":"reference/propagation/propagation/#openscvx.propagation.propagation.simulate_nonlinear_time","title":"<code>simulate_nonlinear_time(params, x, u, tau_vals, t, settings, propagation_solver)</code>","text":"<p>Simulate the nonlinear system dynamics over time.</p> <p>This function simulates the system dynamics using the optimal control sequence and returns the resulting state trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <p>System parameters.</p> required <code>x</code> <p>State trajectory array, shape (N, n_states).</p> required <code>u</code> <p>Control trajectory array, shape (N, n_controls).</p> required <code>tau_vals</code> <code>ndarray</code> <p>Normalized time points for simulation.</p> required <code>t</code> <code>ndarray</code> <p>Real time points.</p> required <code>settings</code> <p>Configuration settings.</p> required <code>propagation_solver</code> <code>callable</code> <p>Function for propagating the system state.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Simulated state trajectory.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def simulate_nonlinear_time(params, x, u, tau_vals, t, settings, propagation_solver):\n    \"\"\"Simulate the nonlinear system dynamics over time.\n\n    This function simulates the system dynamics using the optimal control sequence\n    and returns the resulting state trajectory.\n\n    Args:\n        params: System parameters.\n        x: State trajectory array, shape (N, n_states).\n        u: Control trajectory array, shape (N, n_controls).\n        tau_vals (np.ndarray): Normalized time points for simulation.\n        t (np.ndarray): Real time points.\n        settings: Configuration settings.\n        propagation_solver (callable): Function for propagating the system state.\n\n    Returns:\n        np.ndarray: Simulated state trajectory.\n    \"\"\"\n    x_0 = settings.sim.x_prop.initial\n\n    n_segments = settings.scp.n - 1\n    n_states = x_0.shape[0]\n    n_tau = len(tau_vals)\n\n    states = np.empty((n_states, n_tau))\n    tau = np.linspace(0, 1, settings.scp.n)\n\n    # Precompute control interpolation\n    u_interp = np.stack([np.interp(t, t, u[:, i]) for i in range(u.shape[1])], axis=-1)\n\n    # Bin tau_vals into segments of tau\n    tau_inds = np.digitize(tau_vals, tau) - 1\n    tau_inds = np.where(tau_inds == settings.scp.n - 1, settings.scp.n - 2, tau_inds)\n\n    prev_count = 0\n    out_idx = 0\n\n    for k in range(n_segments):\n        controls_current = u_interp[k][None, :]\n        controls_next = u_interp[k + 1][None, :]\n\n        # Mask for tau_vals in current segment\n        mask = (tau_inds &gt;= k) &amp; (tau_inds &lt; k + 1)\n        count = np.sum(mask)\n\n        tau_cur = tau_vals[prev_count : prev_count + count]\n        tau_cur = np.concatenate([tau_cur, np.array([tau[k + 1]])])  # Always include final point\n        count += 1\n\n        # Pad to fixed length\n        pad_len = settings.prp.max_tau_len - count\n        tau_cur_padded = np.pad(tau_cur, (0, pad_len), constant_values=tau[k + 1])\n        mask_padded = np.concatenate([np.ones(count), np.zeros(pad_len)]).astype(bool)\n\n        # Call the solver with padded tau_cur and mask\n        sol = propagation_solver.call(\n            x_0,\n            (tau[k], tau[k + 1]),\n            controls_current,\n            controls_next,\n            np.array([[tau[k]]]),\n            np.array([[k]]),\n            settings.sim.time_dilation_slice.stop,\n            tau_cur_padded,\n            mask_padded,\n            params,\n        )\n\n        # Only store the valid portion (excluding the final point which becomes next x_0)\n        states[:, out_idx : out_idx + count - 1] = sol[: count - 1].T\n        out_idx += count - 1\n        x_0 = sol[count - 1]  # Last value used as next x_0\n\n        prev_count += count - 1\n\n    return states.T\n</code></pre>"},{"location":"reference/propagation/propagation/#openscvx.propagation.propagation.t_to_tau","title":"<code>t_to_tau(u: np.ndarray, t, t_nodal, settings: Config)</code>","text":"<p>Convert real time t to normalized time tau.</p> <p>This function converts real time t to normalized time tau and interpolates the control inputs accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>ndarray</code> <p>Control trajectory array, shape (N, n_controls).</p> required <code>t</code> <code>ndarray</code> <p>Real time points.</p> required <code>t_nodal</code> <code>ndarray</code> <p>Nodal time points.</p> required <code>settings</code> <code>Config</code> <p>Configuration settings.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(tau, u_interp) where tau is normalized time and u_interp is interpolated controls.</p> Source code in <code>openscvx/propagation/propagation.py</code> <pre><code>def t_to_tau(u: np.ndarray, t, t_nodal, settings: Config):\n    \"\"\"Convert real time t to normalized time tau.\n\n    This function converts real time t to normalized time tau and interpolates\n    the control inputs accordingly.\n\n    Args:\n        u (np.ndarray): Control trajectory array, shape (N, n_controls).\n        t (np.ndarray): Real time points.\n        t_nodal (np.ndarray): Nodal time points.\n        settings (Config): Configuration settings.\n\n    Returns:\n        tuple: (tau, u_interp) where tau is normalized time and u_interp is interpolated controls.\n    \"\"\"\n    if settings.dis.dis_type == \"ZOH\":\n        # Zero-Order Hold: step interpolation (hold previous value)\n        def u_lam(new_t):\n            # Find the index of the last nodal time &lt;= new_t\n            idx = np.searchsorted(t_nodal, new_t, side=\"right\") - 1\n            idx = np.clip(idx, 0, len(t_nodal) - 1)\n            return u[idx, :]\n    elif settings.dis.dis_type == \"FOH\":\n        # First-Order Hold: linear interpolation\n        def u_lam(new_t):\n            return np.array([np.interp(new_t, t_nodal, u[:, i]) for i in range(u.shape[1])]).T\n    else:\n        raise ValueError(\"Currently unsupported discretization type\")\n\n    u_interp = np.array([u_lam(t_i) for t_i in t])\n\n    tau = np.zeros(len(t))\n    tau_nodal = np.linspace(0, 1, settings.scp.n)\n    for k in range(1, len(t)):\n        k_nodal = np.where(t_nodal &lt; t[k])[0][-1]\n        s_kp = u[k_nodal, -1]\n        tp = t_nodal[k_nodal]\n        tau_p = tau_nodal[k_nodal]\n\n        s_k = u[k_nodal + 1, -1]\n        if settings.dis.dis_type == \"ZOH\":\n            tau[k] = tau_p + (t[k] - tp) / s_kp\n        else:\n            tau[k] = tau_p + 2 * (t[k] - tp) / (s_k + s_kp)\n    return tau, u_interp\n</code></pre>"},{"location":"reference/solvers/","title":"solvers","text":"<p>Convex subproblem solvers for trajectory optimization.</p> <p>This module provides implementations of convex subproblem solvers used within SCvx algorithms. At each iteration of a successive convexification algorithm, the non-convex problem is approximated by a convex subproblem, which is then solved using one of these solver backends.</p> Current Implementations <p>CVXPy Solver: The default solver backend using CVXPy's modeling language     with support for multiple backend solvers (CLARABEL, etc.).     Includes optional code generation via cvxpygen for improved performance.</p> Note <p>CVXPyGen setup logic is currently in :class:<code>Problem</code>. When the <code>ConvexSolver</code> base class is implemented, this setup will move here.</p> <p>Planned Architecture (ABC-based):</p> <p>A base class will be introduced to enable pluggable solver implementations. This will enable users to implement custom solver backends such as:</p> <ul> <li>Direct Clarabel solver (Rust-based, GPU-capable)</li> <li>QPAX (JAX-based QP solver for end-to-end differentiability)</li> <li>OSQP direct interface (specialized for QP structure)</li> <li>Custom embedded solvers for real-time applications</li> <li>Research solvers with specialized structure exploitation</li> </ul> <p>This should also make the solver choice independent of the algorithm choice</p> <p>Future solvers will implement the ConvexSolver interface:</p> <pre><code># solvers/base.py (planned):\nclass ConvexSolver(ABC):\n    @abstractmethod\n    def build_subproblem(self, state: AlgorithmState, lowered: LoweredProblem):\n        '''Build the convex subproblem from current state.'''\n        ...\n\n    @abstractmethod\n    def solve(self) -&gt; OptimizationResults:\n        '''Solve the convex subproblem and return results.'''\n        ...\n</code></pre>"},{"location":"reference/solvers/#openscvx.solvers.optimal_control_problem","title":"<code>optimal_control_problem(settings: Config, lowered: LoweredProblem)</code>","text":"<p>Build the complete optimal control problem with all constraints.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Config</code> <p>Configuration settings for the optimization problem</p> required <code>lowered</code> <code>LoweredProblem</code> <p>LoweredProblem containing ocp_vars and lowered constraints</p> required Source code in <code>openscvx/solvers/cvxpy.py</code> <pre><code>def optimal_control_problem(settings: Config, lowered: \"LoweredProblem\"):\n    \"\"\"Build the complete optimal control problem with all constraints.\n\n    Args:\n        settings: Configuration settings for the optimization problem\n        lowered: LoweredProblem containing ocp_vars and lowered constraints\n    \"\"\"\n    # Extract typed CVXPy variables from LoweredProblem\n    ocp_vars = lowered.ocp_vars\n\n    # Extract variables from the dataclass for easier access\n    w_tr = ocp_vars.w_tr\n    lam_cost = ocp_vars.lam_cost\n    lam_vc = ocp_vars.lam_vc\n    lam_vb = ocp_vars.lam_vb\n    x = ocp_vars.x\n    dx = ocp_vars.dx\n    x_bar = ocp_vars.x_bar\n    x_init = ocp_vars.x_init\n    x_term = ocp_vars.x_term\n    u = ocp_vars.u\n    du = ocp_vars.du\n    u_bar = ocp_vars.u_bar\n    A_d = ocp_vars.A_d\n    B_d = ocp_vars.B_d\n    C_d = ocp_vars.C_d\n    x_prop = ocp_vars.x_prop\n    nu = ocp_vars.nu\n    g = ocp_vars.g\n    grad_g_x = ocp_vars.grad_g_x\n    grad_g_u = ocp_vars.grad_g_u\n    nu_vb = ocp_vars.nu_vb\n    g_cross = ocp_vars.g_cross\n    grad_g_X_cross = ocp_vars.grad_g_X_cross\n    grad_g_U_cross = ocp_vars.grad_g_U_cross\n    nu_vb_cross = ocp_vars.nu_vb_cross\n    S_x = ocp_vars.S_x\n    c_x = ocp_vars.c_x\n    S_u = ocp_vars.S_u\n    c_u = ocp_vars.c_u\n    x_nonscaled = ocp_vars.x_nonscaled\n    u_nonscaled = ocp_vars.u_nonscaled\n    dx_nonscaled = ocp_vars.dx_nonscaled\n    du_nonscaled = ocp_vars.du_nonscaled\n\n    # Extract lowered constraints\n    jax_constraints = lowered.jax_constraints\n    cvxpy_constraints = lowered.cvxpy_constraints\n\n    constr = []\n    cost = lam_cost * 0\n    cost += lam_vb * 0\n\n    #############\n    # CONSTRAINTS\n    #############\n\n    # Linearized nodal constraints (from JAX-lowered non-convex)\n    idx_ncvx = 0\n    if jax_constraints.nodal:\n        for constraint in jax_constraints.nodal:\n            # nodes should already be validated and normalized in preprocessing\n            nodes = constraint.nodes\n            constr += [\n                (\n                    g[idx_ncvx][node]\n                    + grad_g_x[idx_ncvx][node] @ dx[node]\n                    + grad_g_u[idx_ncvx][node] @ du[node]\n                )\n                == nu_vb[idx_ncvx][node]\n                for node in nodes\n            ]\n            idx_ncvx += 1\n\n    # Linearized cross-node constraints (from JAX-lowered non-convex)\n    idx_cross = 0\n    if jax_constraints.cross_node:\n        for constraint in jax_constraints.cross_node:\n            # Linearization: g(X_bar, U_bar) + \u2207g_X @ dX + \u2207g_U @ dU == nu_vb\n            # Sum over all trajectory nodes to couple multiple nodes\n            residual = g_cross[idx_cross]\n            for k in range(settings.scp.n):\n                # Contribution from state at node k\n                residual += grad_g_X_cross[idx_cross][k, :] @ dx[k]\n                # Contribution from control at node k\n                residual += grad_g_U_cross[idx_cross][k, :] @ du[k]\n            # Add constraint: residual == slack variable\n            constr += [residual == nu_vb_cross[idx_cross]]\n            idx_cross += 1\n\n    # Convex constraints (already lowered to CVXPy)\n    if cvxpy_constraints.constraints:\n        constr += cvxpy_constraints.constraints\n\n    for i in range(settings.sim.true_state_slice.start, settings.sim.true_state_slice.stop):\n        if settings.sim.x.initial_type[i] == \"Fix\":\n            constr += [x_nonscaled[0][i] == x_init[i]]  # Initial Boundary Conditions\n        if settings.sim.x.final_type[i] == \"Fix\":\n            constr += [x_nonscaled[-1][i] == x_term[i]]  # Final Boundary Conditions\n        if settings.sim.x.initial_type[i] == \"Minimize\":\n            cost += lam_cost * x_nonscaled[0][i]\n        if settings.sim.x.final_type[i] == \"Minimize\":\n            cost += lam_cost * x_nonscaled[-1][i]\n        if settings.sim.x.initial_type[i] == \"Maximize\":\n            cost -= lam_cost * x_nonscaled[0][i]\n        if settings.sim.x.final_type[i] == \"Maximize\":\n            cost -= lam_cost * x_nonscaled[-1][i]\n\n    if settings.scp.uniform_time_grid:\n        constr += [\n            u_nonscaled[i][settings.sim.time_dilation_slice]\n            == u_nonscaled[i - 1][settings.sim.time_dilation_slice]\n            for i in range(1, settings.scp.n)\n        ]\n\n    constr += [\n        (x[i] - np.linalg.inv(S_x) @ (x_bar[i] - c_x) - dx[i]) == 0 for i in range(settings.scp.n)\n    ]  # State Error\n    constr += [\n        (u[i] - np.linalg.inv(S_u) @ (u_bar[i] - c_u) - du[i]) == 0 for i in range(settings.scp.n)\n    ]  # Control Error\n\n    constr += [\n        x_nonscaled[i]\n        == A_d[i - 1] @ dx_nonscaled[i - 1]\n        + B_d[i - 1] @ du_nonscaled[i - 1]\n        + C_d[i - 1] @ du_nonscaled[i]\n        + x_prop[i - 1]\n        + nu[i - 1]\n        for i in range(1, settings.scp.n)\n    ]  # Dynamics Constraint\n\n    constr += [u_nonscaled[i] &lt;= settings.sim.u.max for i in range(settings.scp.n)]\n    constr += [\n        u_nonscaled[i] &gt;= settings.sim.u.min for i in range(settings.scp.n)\n    ]  # Control Constraints\n\n    # TODO: (norrisg) formalize this\n    constr += [x_nonscaled[i][:] &lt;= settings.sim.x.max for i in range(settings.scp.n)]\n    constr += [\n        x_nonscaled[i][:] &gt;= settings.sim.x.min for i in range(settings.scp.n)\n    ]  # State Constraints (Also implemented in CTCS but included for numerical stability)\n\n    ########\n    # COSTS\n    ########\n\n    cost += sum(\n        w_tr * cp.sum_squares(cp.hstack((dx[i], du[i]))) for i in range(settings.scp.n)\n    )  # Trust Region Cost\n    cost += sum(\n        cp.sum(lam_vc[i - 1] * cp.abs(nu[i - 1])) for i in range(1, settings.scp.n)\n    )  # Virtual Control Slack\n\n    idx_ncvx = 0\n    if jax_constraints.nodal:\n        for constraint in jax_constraints.nodal:\n            cost += lam_vb * cp.sum(cp.pos(nu_vb[idx_ncvx]))\n            idx_ncvx += 1\n\n    # Virtual slack penalty for cross-node constraints\n    idx_cross = 0\n    if jax_constraints.cross_node:\n        for constraint in jax_constraints.cross_node:\n            cost += lam_vb * cp.pos(nu_vb_cross[idx_cross])\n            idx_cross += 1\n\n    for idx, nodes in zip(\n        np.arange(settings.sim.ctcs_slice.start, settings.sim.ctcs_slice.stop),\n        settings.sim.ctcs_node_intervals,\n    ):\n        start_idx = 1 if nodes[0] == 0 else nodes[0]\n        constr += [\n            cp.abs(x_nonscaled[i][idx] - x_nonscaled[i - 1][idx]) &lt;= settings.sim.x.max[idx]\n            for i in range(start_idx, nodes[1])\n        ]\n        constr += [x_nonscaled[0][idx] == 0]\n\n    #########\n    # PROBLEM\n    #########\n    prob = cp.Problem(cp.Minimize(cost), constr)\n    if settings.cvx.cvxpygen:\n        if not CVXPYGEN_AVAILABLE:\n            raise ImportError(\n                \"cvxpygen is required for code generation but not installed. \"\n                \"Install it with: pip install openscvx[cvxpygen] or pip install cvxpygen\"\n            )\n        # Check to see if solver directory exists\n        if not os.path.exists(\"solver\"):\n            cpg.generate_code(prob, solver=settings.cvx.solver, code_dir=\"solver\", wrapper=True)\n        else:\n            # Prompt the use to indicate if they wish to overwrite the solver\n            # directory or use the existing compiled solver\n            if settings.cvx.cvxpygen_override:\n                cpg.generate_code(prob, solver=settings.cvx.solver, code_dir=\"solver\", wrapper=True)\n            else:\n                overwrite = input(\"Solver directory already exists. Overwrite? (y/n): \")\n                if overwrite.lower() == \"y\":\n                    cpg.generate_code(\n                        prob, solver=settings.cvx.solver, code_dir=\"solver\", wrapper=True\n                    )\n                else:\n                    pass\n    return prob\n</code></pre>"},{"location":"reference/solvers/cvxpy/","title":"cvxpy","text":""},{"location":"reference/solvers/cvxpy/#openscvx.solvers.cvxpy.optimal_control_problem","title":"<code>optimal_control_problem(settings: Config, lowered: LoweredProblem)</code>","text":"<p>Build the complete optimal control problem with all constraints.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Config</code> <p>Configuration settings for the optimization problem</p> required <code>lowered</code> <code>LoweredProblem</code> <p>LoweredProblem containing ocp_vars and lowered constraints</p> required Source code in <code>openscvx/solvers/cvxpy.py</code> <pre><code>def optimal_control_problem(settings: Config, lowered: \"LoweredProblem\"):\n    \"\"\"Build the complete optimal control problem with all constraints.\n\n    Args:\n        settings: Configuration settings for the optimization problem\n        lowered: LoweredProblem containing ocp_vars and lowered constraints\n    \"\"\"\n    # Extract typed CVXPy variables from LoweredProblem\n    ocp_vars = lowered.ocp_vars\n\n    # Extract variables from the dataclass for easier access\n    w_tr = ocp_vars.w_tr\n    lam_cost = ocp_vars.lam_cost\n    lam_vc = ocp_vars.lam_vc\n    lam_vb = ocp_vars.lam_vb\n    x = ocp_vars.x\n    dx = ocp_vars.dx\n    x_bar = ocp_vars.x_bar\n    x_init = ocp_vars.x_init\n    x_term = ocp_vars.x_term\n    u = ocp_vars.u\n    du = ocp_vars.du\n    u_bar = ocp_vars.u_bar\n    A_d = ocp_vars.A_d\n    B_d = ocp_vars.B_d\n    C_d = ocp_vars.C_d\n    x_prop = ocp_vars.x_prop\n    nu = ocp_vars.nu\n    g = ocp_vars.g\n    grad_g_x = ocp_vars.grad_g_x\n    grad_g_u = ocp_vars.grad_g_u\n    nu_vb = ocp_vars.nu_vb\n    g_cross = ocp_vars.g_cross\n    grad_g_X_cross = ocp_vars.grad_g_X_cross\n    grad_g_U_cross = ocp_vars.grad_g_U_cross\n    nu_vb_cross = ocp_vars.nu_vb_cross\n    S_x = ocp_vars.S_x\n    c_x = ocp_vars.c_x\n    S_u = ocp_vars.S_u\n    c_u = ocp_vars.c_u\n    x_nonscaled = ocp_vars.x_nonscaled\n    u_nonscaled = ocp_vars.u_nonscaled\n    dx_nonscaled = ocp_vars.dx_nonscaled\n    du_nonscaled = ocp_vars.du_nonscaled\n\n    # Extract lowered constraints\n    jax_constraints = lowered.jax_constraints\n    cvxpy_constraints = lowered.cvxpy_constraints\n\n    constr = []\n    cost = lam_cost * 0\n    cost += lam_vb * 0\n\n    #############\n    # CONSTRAINTS\n    #############\n\n    # Linearized nodal constraints (from JAX-lowered non-convex)\n    idx_ncvx = 0\n    if jax_constraints.nodal:\n        for constraint in jax_constraints.nodal:\n            # nodes should already be validated and normalized in preprocessing\n            nodes = constraint.nodes\n            constr += [\n                (\n                    g[idx_ncvx][node]\n                    + grad_g_x[idx_ncvx][node] @ dx[node]\n                    + grad_g_u[idx_ncvx][node] @ du[node]\n                )\n                == nu_vb[idx_ncvx][node]\n                for node in nodes\n            ]\n            idx_ncvx += 1\n\n    # Linearized cross-node constraints (from JAX-lowered non-convex)\n    idx_cross = 0\n    if jax_constraints.cross_node:\n        for constraint in jax_constraints.cross_node:\n            # Linearization: g(X_bar, U_bar) + \u2207g_X @ dX + \u2207g_U @ dU == nu_vb\n            # Sum over all trajectory nodes to couple multiple nodes\n            residual = g_cross[idx_cross]\n            for k in range(settings.scp.n):\n                # Contribution from state at node k\n                residual += grad_g_X_cross[idx_cross][k, :] @ dx[k]\n                # Contribution from control at node k\n                residual += grad_g_U_cross[idx_cross][k, :] @ du[k]\n            # Add constraint: residual == slack variable\n            constr += [residual == nu_vb_cross[idx_cross]]\n            idx_cross += 1\n\n    # Convex constraints (already lowered to CVXPy)\n    if cvxpy_constraints.constraints:\n        constr += cvxpy_constraints.constraints\n\n    for i in range(settings.sim.true_state_slice.start, settings.sim.true_state_slice.stop):\n        if settings.sim.x.initial_type[i] == \"Fix\":\n            constr += [x_nonscaled[0][i] == x_init[i]]  # Initial Boundary Conditions\n        if settings.sim.x.final_type[i] == \"Fix\":\n            constr += [x_nonscaled[-1][i] == x_term[i]]  # Final Boundary Conditions\n        if settings.sim.x.initial_type[i] == \"Minimize\":\n            cost += lam_cost * x_nonscaled[0][i]\n        if settings.sim.x.final_type[i] == \"Minimize\":\n            cost += lam_cost * x_nonscaled[-1][i]\n        if settings.sim.x.initial_type[i] == \"Maximize\":\n            cost -= lam_cost * x_nonscaled[0][i]\n        if settings.sim.x.final_type[i] == \"Maximize\":\n            cost -= lam_cost * x_nonscaled[-1][i]\n\n    if settings.scp.uniform_time_grid:\n        constr += [\n            u_nonscaled[i][settings.sim.time_dilation_slice]\n            == u_nonscaled[i - 1][settings.sim.time_dilation_slice]\n            for i in range(1, settings.scp.n)\n        ]\n\n    constr += [\n        (x[i] - np.linalg.inv(S_x) @ (x_bar[i] - c_x) - dx[i]) == 0 for i in range(settings.scp.n)\n    ]  # State Error\n    constr += [\n        (u[i] - np.linalg.inv(S_u) @ (u_bar[i] - c_u) - du[i]) == 0 for i in range(settings.scp.n)\n    ]  # Control Error\n\n    constr += [\n        x_nonscaled[i]\n        == A_d[i - 1] @ dx_nonscaled[i - 1]\n        + B_d[i - 1] @ du_nonscaled[i - 1]\n        + C_d[i - 1] @ du_nonscaled[i]\n        + x_prop[i - 1]\n        + nu[i - 1]\n        for i in range(1, settings.scp.n)\n    ]  # Dynamics Constraint\n\n    constr += [u_nonscaled[i] &lt;= settings.sim.u.max for i in range(settings.scp.n)]\n    constr += [\n        u_nonscaled[i] &gt;= settings.sim.u.min for i in range(settings.scp.n)\n    ]  # Control Constraints\n\n    # TODO: (norrisg) formalize this\n    constr += [x_nonscaled[i][:] &lt;= settings.sim.x.max for i in range(settings.scp.n)]\n    constr += [\n        x_nonscaled[i][:] &gt;= settings.sim.x.min for i in range(settings.scp.n)\n    ]  # State Constraints (Also implemented in CTCS but included for numerical stability)\n\n    ########\n    # COSTS\n    ########\n\n    cost += sum(\n        w_tr * cp.sum_squares(cp.hstack((dx[i], du[i]))) for i in range(settings.scp.n)\n    )  # Trust Region Cost\n    cost += sum(\n        cp.sum(lam_vc[i - 1] * cp.abs(nu[i - 1])) for i in range(1, settings.scp.n)\n    )  # Virtual Control Slack\n\n    idx_ncvx = 0\n    if jax_constraints.nodal:\n        for constraint in jax_constraints.nodal:\n            cost += lam_vb * cp.sum(cp.pos(nu_vb[idx_ncvx]))\n            idx_ncvx += 1\n\n    # Virtual slack penalty for cross-node constraints\n    idx_cross = 0\n    if jax_constraints.cross_node:\n        for constraint in jax_constraints.cross_node:\n            cost += lam_vb * cp.pos(nu_vb_cross[idx_cross])\n            idx_cross += 1\n\n    for idx, nodes in zip(\n        np.arange(settings.sim.ctcs_slice.start, settings.sim.ctcs_slice.stop),\n        settings.sim.ctcs_node_intervals,\n    ):\n        start_idx = 1 if nodes[0] == 0 else nodes[0]\n        constr += [\n            cp.abs(x_nonscaled[i][idx] - x_nonscaled[i - 1][idx]) &lt;= settings.sim.x.max[idx]\n            for i in range(start_idx, nodes[1])\n        ]\n        constr += [x_nonscaled[0][idx] == 0]\n\n    #########\n    # PROBLEM\n    #########\n    prob = cp.Problem(cp.Minimize(cost), constr)\n    if settings.cvx.cvxpygen:\n        if not CVXPYGEN_AVAILABLE:\n            raise ImportError(\n                \"cvxpygen is required for code generation but not installed. \"\n                \"Install it with: pip install openscvx[cvxpygen] or pip install cvxpygen\"\n            )\n        # Check to see if solver directory exists\n        if not os.path.exists(\"solver\"):\n            cpg.generate_code(prob, solver=settings.cvx.solver, code_dir=\"solver\", wrapper=True)\n        else:\n            # Prompt the use to indicate if they wish to overwrite the solver\n            # directory or use the existing compiled solver\n            if settings.cvx.cvxpygen_override:\n                cpg.generate_code(prob, solver=settings.cvx.solver, code_dir=\"solver\", wrapper=True)\n            else:\n                overwrite = input(\"Solver directory already exists. Overwrite? (y/n): \")\n                if overwrite.lower() == \"y\":\n                    cpg.generate_code(\n                        prob, solver=settings.cvx.solver, code_dir=\"solver\", wrapper=True\n                    )\n                else:\n                    pass\n    return prob\n</code></pre>"},{"location":"reference/symbolic/","title":"symbolic","text":"<p>Symbolic expression system for trajectory optimization.</p> <p>See openscvx.symbolic.expr for detailed documentation and examples.</p>"},{"location":"reference/symbolic/#openscvx.symbolic.ConstraintSet","title":"<code>ConstraintSet</code>  <code>dataclass</code>","text":"<p>Container for categorized symbolic constraints.</p> <p>This dataclass holds all symbolic constraint types in a structured way, providing type safety and a clear API for accessing constraint categories. This is a pre-lowering container - after lowering, constraints live in LoweredJaxConstraints and LoweredCvxpyConstraints.</p> <p>The constraint set supports two lifecycle stages:</p> <ol> <li>Before preprocessing: Raw constraints live in <code>unsorted</code></li> <li>After preprocessing: <code>unsorted</code> is empty, constraints are categorized</li> </ol> <p>Use <code>is_categorized</code> to check which stage the constraint set is in.</p> <p>Attributes:</p> Name Type Description <code>unsorted</code> <code>List[Union[Constraint, CTCS]]</code> <p>Raw constraints before categorization. Empty after preprocessing.</p> <code>ctcs</code> <code>List[CTCS]</code> <p>CTCS (continuous-time) constraints.</p> <code>nodal</code> <code>List[NodalConstraint]</code> <p>Non-convex nodal constraints (will be lowered to JAX).</p> <code>nodal_convex</code> <code>List[NodalConstraint]</code> <p>Convex nodal constraints (will be lowered to CVXPy).</p> <code>cross_node</code> <code>List[CrossNodeConstraint]</code> <p>Non-convex cross-node constraints (will be lowered to JAX).</p> <code>cross_node_convex</code> <code>List[CrossNodeConstraint]</code> <p>Convex cross-node constraints (will be lowered to CVXPy).</p> Example <p>Before preprocessing (raw constraints)::</p> <pre><code>constraints = ConstraintSet(unsorted=[c1, c2, c3])\nassert not constraints.is_categorized\n</code></pre> <p>After preprocessing (categorized)::</p> <pre><code># preprocess_symbolic_problem drains unsorted -&gt; fills categories\nassert constraints.is_categorized\nfor c in constraints.nodal:\n    # Process non-convex nodal constraints\n    pass\n</code></pre> Source code in <code>openscvx/symbolic/constraint_set.py</code> <pre><code>@dataclass\nclass ConstraintSet:\n    \"\"\"Container for categorized symbolic constraints.\n\n    This dataclass holds all symbolic constraint types in a structured way,\n    providing type safety and a clear API for accessing constraint categories.\n    This is a pre-lowering container - after lowering, constraints live in\n    LoweredJaxConstraints and LoweredCvxpyConstraints.\n\n    The constraint set supports two lifecycle stages:\n\n    1. **Before preprocessing**: Raw constraints live in `unsorted`\n    2. **After preprocessing**: `unsorted` is empty, constraints are categorized\n\n    Use `is_categorized` to check which stage the constraint set is in.\n\n    Attributes:\n        unsorted: Raw constraints before categorization. Empty after preprocessing.\n        ctcs: CTCS (continuous-time) constraints.\n        nodal: Non-convex nodal constraints (will be lowered to JAX).\n        nodal_convex: Convex nodal constraints (will be lowered to CVXPy).\n        cross_node: Non-convex cross-node constraints (will be lowered to JAX).\n        cross_node_convex: Convex cross-node constraints (will be lowered to CVXPy).\n\n    Example:\n        Before preprocessing (raw constraints)::\n\n            constraints = ConstraintSet(unsorted=[c1, c2, c3])\n            assert not constraints.is_categorized\n\n        After preprocessing (categorized)::\n\n            # preprocess_symbolic_problem drains unsorted -&gt; fills categories\n            assert constraints.is_categorized\n            for c in constraints.nodal:\n                # Process non-convex nodal constraints\n                pass\n    \"\"\"\n\n    # Raw constraints before categorization (empty after preprocessing)\n    unsorted: List[Union[\"Constraint\", \"CTCS\"]] = field(default_factory=list)\n\n    # Categorized symbolic constraints (populated by preprocessing)\n    ctcs: List[\"CTCS\"] = field(default_factory=list)\n    nodal: List[\"NodalConstraint\"] = field(default_factory=list)\n    nodal_convex: List[\"NodalConstraint\"] = field(default_factory=list)\n    cross_node: List[\"CrossNodeConstraint\"] = field(default_factory=list)\n    cross_node_convex: List[\"CrossNodeConstraint\"] = field(default_factory=list)\n\n    @property\n    def is_categorized(self) -&gt; bool:\n        \"\"\"True if all constraints have been sorted into categories.\n\n        After preprocessing, `unsorted` should be empty and all constraints\n        should be in their appropriate category lists.\n        \"\"\"\n        return len(self.unsorted) == 0\n\n    def __bool__(self) -&gt; bool:\n        \"\"\"Return True if any constraint list is non-empty.\"\"\"\n        return bool(\n            self.unsorted\n            or self.ctcs\n            or self.nodal\n            or self.nodal_convex\n            or self.cross_node\n            or self.cross_node_convex\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return total number of constraints across all lists.\"\"\"\n        return (\n            len(self.unsorted)\n            + len(self.ctcs)\n            + len(self.nodal)\n            + len(self.nodal_convex)\n            + len(self.cross_node)\n            + len(self.cross_node_convex)\n        )\n</code></pre>"},{"location":"reference/symbolic/#openscvx.symbolic.ConstraintSet.is_categorized","title":"<code>is_categorized: bool</code>  <code>property</code>","text":"<p>True if all constraints have been sorted into categories.</p> <p>After preprocessing, <code>unsorted</code> should be empty and all constraints should be in their appropriate category lists.</p>"},{"location":"reference/symbolic/#openscvx.symbolic.SymbolicProblem","title":"<code>SymbolicProblem</code>  <code>dataclass</code>","text":"<p>Container for symbolic problem specification.</p> <p>This dataclass holds a trajectory optimization problem in symbolic form, either as raw user input or after preprocessing/augmentation. It provides a typed interface for the preprocessing and lowering pipeline.</p> Lifecycle Stages <ol> <li>Before preprocessing: User creates with raw dynamics, states,    controls, and unsorted constraints. Propagation fields are None.</li> <li>After preprocessing: Dynamics and states are augmented (CTCS,    time dilation), constraints are categorized, propagation fields    are populated.</li> </ol> <p>Use <code>is_preprocessed</code> to check whether preprocessing has completed.</p> <p>Attributes:</p> Name Type Description <code>dynamics</code> <code>Expr</code> <p>Symbolic dynamics expression (dx/dt = f(x, u)). After preprocessing, includes CTCS augmented state dynamics.</p> <code>states</code> <code>List[State]</code> <p>List of State objects. After preprocessing, includes time state and CTCS augmented states.</p> <code>controls</code> <code>List[Control]</code> <p>List of Control objects. After preprocessing, includes time dilation control.</p> <code>constraints</code> <code>ConstraintSet</code> <p>ConstraintSet holding all constraints. Before preprocessing, raw constraints live in <code>constraints.unsorted</code>. After preprocessing, constraints are categorized into ctcs, nodal, nodal_convex, etc.</p> <code>parameters</code> <code>Dict[str, any]</code> <p>Dictionary mapping parameter names to numpy arrays.</p> <code>N</code> <code>int</code> <p>Number of discretization nodes.</p> <code>node_intervals</code> <code>List[Tuple[int, int]]</code> <p>List of (start, end) tuples for CTCS constraint intervals. Populated during preprocessing when CTCS constraints are sorted.</p> <code>dynamics_prop</code> <code>Optional[Expr]</code> <p>Propagation dynamics (may include extra states). None before preprocessing, populated after.</p> <code>states_prop</code> <code>Optional[List[State]]</code> <p>Propagation states (may include extra states). None before preprocessing, populated after.</p> <code>controls_prop</code> <code>Optional[List[Control]]</code> <p>Propagation controls (typically same as controls). None before preprocessing, populated after.</p> <code>algebraic_prop</code> <code>Optional[Dict[str, Expr]]</code> <p>Algebraic outputs computed during propagation (no integration). None before preprocessing, populated after.</p> Example <p>Before preprocessing::</p> <pre><code>problem = SymbolicProblem(\n    dynamics=dynamics_expr,\n    states=[x, v],\n    controls=[u],\n    constraints=ConstraintSet(unsorted=[c1, c2, c3]),\n    parameters={\"mass\": 1.0},\n    N=50,\n)\nassert not problem.is_preprocessed\n</code></pre> <p>After preprocessing::</p> <pre><code>processed = preprocess_symbolic_problem(problem, time=time_config)\nassert processed.is_preprocessed\nassert processed.constraints.is_categorized\n# Now ready for lowering\nlowered = lower_symbolic_problem(processed)\n</code></pre> Source code in <code>openscvx/symbolic/problem.py</code> <pre><code>@dataclass\nclass SymbolicProblem:\n    \"\"\"Container for symbolic problem specification.\n\n    This dataclass holds a trajectory optimization problem in symbolic form,\n    either as raw user input or after preprocessing/augmentation. It provides\n    a typed interface for the preprocessing and lowering pipeline.\n\n    Lifecycle Stages:\n        1. **Before preprocessing**: User creates with raw dynamics, states,\n           controls, and unsorted constraints. Propagation fields are None.\n        2. **After preprocessing**: Dynamics and states are augmented (CTCS,\n           time dilation), constraints are categorized, propagation fields\n           are populated.\n\n    Use `is_preprocessed` to check whether preprocessing has completed.\n\n    Attributes:\n        dynamics: Symbolic dynamics expression (dx/dt = f(x, u)).\n            After preprocessing, includes CTCS augmented state dynamics.\n        states: List of State objects. After preprocessing, includes\n            time state and CTCS augmented states.\n        controls: List of Control objects. After preprocessing, includes\n            time dilation control.\n        constraints: ConstraintSet holding all constraints. Before preprocessing,\n            raw constraints live in `constraints.unsorted`. After preprocessing,\n            constraints are categorized into ctcs, nodal, nodal_convex, etc.\n        parameters: Dictionary mapping parameter names to numpy arrays.\n        N: Number of discretization nodes.\n        node_intervals: List of (start, end) tuples for CTCS constraint intervals.\n            Populated during preprocessing when CTCS constraints are sorted.\n\n        dynamics_prop: Propagation dynamics (may include extra states).\n            None before preprocessing, populated after.\n        states_prop: Propagation states (may include extra states).\n            None before preprocessing, populated after.\n        controls_prop: Propagation controls (typically same as controls).\n            None before preprocessing, populated after.\n        algebraic_prop: Algebraic outputs computed during propagation (no integration).\n            None before preprocessing, populated after.\n\n    Example:\n        Before preprocessing::\n\n            problem = SymbolicProblem(\n                dynamics=dynamics_expr,\n                states=[x, v],\n                controls=[u],\n                constraints=ConstraintSet(unsorted=[c1, c2, c3]),\n                parameters={\"mass\": 1.0},\n                N=50,\n            )\n            assert not problem.is_preprocessed\n\n        After preprocessing::\n\n            processed = preprocess_symbolic_problem(problem, time=time_config)\n            assert processed.is_preprocessed\n            assert processed.constraints.is_categorized\n            # Now ready for lowering\n            lowered = lower_symbolic_problem(processed)\n    \"\"\"\n\n    # Core problem specification\n    dynamics: \"Expr\"\n    states: List[\"State\"]\n    controls: List[\"Control\"]\n    constraints: ConstraintSet\n    parameters: Dict[str, any]\n    N: int\n\n    # CTCS node intervals (populated during preprocessing)\n    node_intervals: List[Tuple[int, int]] = field(default_factory=list)\n\n    # Propagation (None before preprocessing, populated after)\n    dynamics_prop: Optional[\"Expr\"] = None\n    states_prop: Optional[List[\"State\"]] = None\n    controls_prop: Optional[List[\"Control\"]] = None\n\n    # Algebraic outputs computed during propagation (no integration)\n    # Maps output names to symbolic expressions\n    algebraic_prop: Optional[Dict[str, \"Expr\"]] = None\n\n    @property\n    def is_preprocessed(self) -&gt; bool:\n        \"\"\"True if the problem has been preprocessed and is ready for lowering.\n\n        A problem is considered preprocessed when:\n        1. All constraints have been categorized (unsorted is empty)\n        2. Propagation dynamics have been set up\n        \"\"\"\n        return self.constraints.is_categorized and self.dynamics_prop is not None\n</code></pre>"},{"location":"reference/symbolic/#openscvx.symbolic.SymbolicProblem.is_preprocessed","title":"<code>is_preprocessed: bool</code>  <code>property</code>","text":"<p>True if the problem has been preprocessed and is ready for lowering.</p> <p>A problem is considered preprocessed when: 1. All constraints have been categorized (unsorted is empty) 2. Propagation dynamics have been set up</p>"},{"location":"reference/symbolic/augmentation/","title":"augmentation","text":"<p>State and dynamics augmentation for continuous-time constraint satisfaction.</p> <p>This module provides utilities for augmenting trajectory optimization problems with additional states and dynamics to handle continuous-time constraint satisfaction (CTCS). The CTCS method enforces path constraints continuously along the trajectory rather than just at discretization nodes.</p> Key functionality <ul> <li>CTCS constraint grouping: Sort and group CTCS constraints by time intervals</li> <li>Constraint separation: Separate CTCS, nodal, and convex constraints</li> <li>Vector decomposition: Decompose vector constraints into scalar components</li> <li>Time augmentation: Add time state with appropriate dynamics and constraints</li> <li>CTCS dynamics augmentation: Add augmented states and time dilation control</li> </ul> <p>The augmentation process transforms the original dynamics x_dot = f(x, u) into an augmented system with additional states for constraint satisfaction and time dilation.</p> Architecture <p>The CTCS method works by:</p> <ol> <li>Grouping constraints by time interval and assigning index (idx)</li> <li>Creating augmented states (one per constraint group)</li> <li>Adding penalty dynamics: aug_dot = penalty(constraint_violation)</li> <li>Adding time dilation control to slow down near constraint boundaries</li> </ol> Example <p>Augmenting dynamics with CTCS constraints::</p> <pre><code>import openscvx as ox\n\n# Define problem\nx = ox.State(\"x\", shape=(3,))\nu = ox.Control(\"u\", shape=(2,))\n\n# Create dynamics\nxdot = u @ A  # Some dynamics expression\n\n# Define path constraint\npath_constraint = (ox.Norm(x) &lt;= 1.0).over((0, 50))  # CTCS constraint\n\n# Augment dynamics with CTCS\nfrom openscvx.symbolic.augmentation import augment_dynamics_with_ctcs\n\nxdot_aug, states_aug, controls_aug = augment_dynamics_with_ctcs(\n    xdot=xdot,\n    states=[x],\n    controls=[u],\n    constraints_ctcs=[path_constraint],\n    N=50\n)\n# xdot_aug now includes augmented state dynamics\n# states_aug includes original states + augmented states\n# controls_aug includes original controls + time dilation\n</code></pre>"},{"location":"reference/symbolic/augmentation/#openscvx.symbolic.augmentation.augment_dynamics_with_ctcs","title":"<code>augment_dynamics_with_ctcs(xdot: Expr, states: List[State], controls: List[Control], constraints_ctcs: List[CTCS], N: int, licq_min: float = 0.0, licq_max: float = 0.0001, time_dilation_factor_min: float = 0.3, time_dilation_factor_max: float = 3.0) -&gt; Tuple[Expr, List[State], List[Control]]</code>","text":"<p>Augment dynamics with continuous-time constraint satisfaction states.</p> <p>Implements the CTCS method by adding augmented states and time dilation control to the original dynamics. For each group of CTCS constraints, an augmented state is created whose dynamics are the penalty function of constraint violations.</p> <p>The CTCS method enforces path constraints continuously by: 1. Creating augmented states with dynamics = penalty(constraint_violation) 2. Constraining augmented states to stay near zero (LICQ condition) 3. Adding time dilation control to slow down near constraint boundaries</p> The augmented dynamics become <p>x_dot = f(x, u) aug_dot = penalty(g(x, u))  # For each constraint group time_dot = time_dilation</p> <p>Parameters:</p> Name Type Description Default <code>xdot</code> <code>Expr</code> <p>Original dynamics expression for states</p> required <code>states</code> <code>List[State]</code> <p>List of state variables (must include a state named \"time\")</p> required <code>controls</code> <code>List[Control]</code> <p>List of control variables</p> required <code>constraints_ctcs</code> <code>List[CTCS]</code> <p>List of CTCS constraints (should be sorted and grouped)</p> required <code>N</code> <code>int</code> <p>Number of discretization nodes</p> required <code>licq_min</code> <code>float</code> <p>Minimum bound for augmented states (default: 0.0)</p> <code>0.0</code> <code>licq_max</code> <code>float</code> <p>Maximum bound for augmented states (default: 1e-4)</p> <code>0.0001</code> <code>time_dilation_factor_min</code> <code>float</code> <p>Minimum time dilation factor (default: 0.3)</p> <code>0.3</code> <code>time_dilation_factor_max</code> <code>float</code> <p>Maximum time dilation factor (default: 3.0)</p> <code>3.0</code> <p>Returns:</p> Type Description <code>Tuple[Expr, List[State], List[Control]]</code> <p>Tuple of: - Augmented dynamics expression (original + augmented state dynamics) - Updated states list (original + augmented states) - Updated controls list (original + time dilation control)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no state named \"time\" is found in the states list</p> Example <p>Augment dynamics with CTCS penalty states:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nu = ox.Control(\"u\", shape=(2,))\ntime = ox.State(\"time\", shape=(1,))\nxdot = u @ A  # Some dynamics\nconstraint = (ox.Norm(x) &lt;= 1.0).over((0, 50))\nxdot_aug, states_aug, controls_aug = augment_dynamics_with_ctcs(\n    xdot=xdot,\n    states=[x, time],\n    controls=[u],\n    constraints_ctcs=[constraint],\n    N=50\n)\n</code></pre> <p>states_aug includes x, time, and _ctcs_aug_0, controls_aug includes u and _time_dilation</p> Source code in <code>openscvx/symbolic/augmentation.py</code> <pre><code>def augment_dynamics_with_ctcs(\n    xdot: Expr,\n    states: List[State],\n    controls: List[Control],\n    constraints_ctcs: List[CTCS],\n    N: int,\n    licq_min: float = 0.0,\n    licq_max: float = 1e-4,\n    time_dilation_factor_min: float = 0.3,\n    time_dilation_factor_max: float = 3.0,\n) -&gt; Tuple[Expr, List[State], List[Control]]:\n    \"\"\"Augment dynamics with continuous-time constraint satisfaction states.\n\n    Implements the CTCS method by adding augmented states and time dilation control\n    to the original dynamics. For each group of CTCS constraints, an augmented state\n    is created whose dynamics are the penalty function of constraint violations.\n\n    The CTCS method enforces path constraints continuously by:\n    1. Creating augmented states with dynamics = penalty(constraint_violation)\n    2. Constraining augmented states to stay near zero (LICQ condition)\n    3. Adding time dilation control to slow down near constraint boundaries\n\n    The augmented dynamics become:\n        x_dot = f(x, u)\n        aug_dot = penalty(g(x, u))  # For each constraint group\n        time_dot = time_dilation\n\n    Args:\n        xdot: Original dynamics expression for states\n        states: List of state variables (must include a state named \"time\")\n        controls: List of control variables\n        constraints_ctcs: List of CTCS constraints (should be sorted and grouped)\n        N: Number of discretization nodes\n        licq_min: Minimum bound for augmented states (default: 0.0)\n        licq_max: Maximum bound for augmented states (default: 1e-4)\n        time_dilation_factor_min: Minimum time dilation factor (default: 0.3)\n        time_dilation_factor_max: Maximum time dilation factor (default: 3.0)\n\n    Returns:\n        Tuple of:\n            - Augmented dynamics expression (original + augmented state dynamics)\n            - Updated states list (original + augmented states)\n            - Updated controls list (original + time dilation control)\n\n    Raises:\n        ValueError: If no state named \"time\" is found in the states list\n\n    Example:\n        Augment dynamics with CTCS penalty states:\n\n            x = ox.State(\"x\", shape=(3,))\n            u = ox.Control(\"u\", shape=(2,))\n            time = ox.State(\"time\", shape=(1,))\n            xdot = u @ A  # Some dynamics\n            constraint = (ox.Norm(x) &lt;= 1.0).over((0, 50))\n            xdot_aug, states_aug, controls_aug = augment_dynamics_with_ctcs(\n                xdot=xdot,\n                states=[x, time],\n                controls=[u],\n                constraints_ctcs=[constraint],\n                N=50\n            )\n\n        states_aug includes x, time, and _ctcs_aug_0,\n        controls_aug includes u and _time_dilation\n    \"\"\"\n    # Copy the original states and controls lists\n    states_augmented = list(states)\n    controls_augmented = list(controls)\n\n    if constraints_ctcs:\n        # Group penalty expressions by idx (constraints should already be sorted)\n        penalty_groups: Dict[int, List[Expr]] = {}\n\n        for ctcs in constraints_ctcs:\n            # Keep the CTCS wrapper intact to preserve node interval information\n            # The JAX lowerer's visit_ctcs() method will handle the conditional logic\n\n            # TODO: In the future, apply scaling here if ctcs has a scaling attribute\n            # if hasattr(ctcs, 'scaling') and ctcs.scaling != 1.0:\n            #     ctcs = scale_ctcs(ctcs, scaling_factor)\n\n            if ctcs.idx not in penalty_groups:\n                penalty_groups[ctcs.idx] = []\n            penalty_groups[ctcs.idx].append(ctcs)\n\n        # Create augmented state expressions for each group\n        augmented_state_exprs = []\n        for idx in sorted(penalty_groups.keys()):\n            penalty_terms = penalty_groups[idx]\n            if len(penalty_terms) == 1:\n                augmented_state_expr = penalty_terms[0]\n            else:\n                augmented_state_expr = Add(*penalty_terms)\n            augmented_state_exprs.append(augmented_state_expr)\n\n        # Calculate number of augmented states from the penalty groups\n        num_augmented_states = len(penalty_groups)\n\n        # Create augmented state variables\n        for idx in range(num_augmented_states):\n            aug_var = State(f\"_ctcs_aug_{idx}\", shape=(1,))\n            aug_var.initial = np.array([licq_min])  # Set initial to respect bounds\n            aug_var.final = [(\"free\", 0)]\n            aug_var.min = np.array([licq_min])\n            aug_var.max = np.array([licq_max])\n            # Set guess to licq_min as well\n            aug_var.guess = np.full([N, 1], licq_min)  # N x num augmented states\n            states_augmented.append(aug_var)\n\n        # Concatenate with original dynamics\n        xdot_aug = Concat(xdot, *augmented_state_exprs)\n    else:\n        xdot_aug = xdot\n\n    time_dilation = Control(\"_time_dilation\", shape=(1,))\n\n    # Set up time dilation bounds and initial guess\n    # Find the time state by name\n    time_state = None\n    for state in states:\n        if state.name == \"time\":\n            time_state = state\n            break\n\n    if time_state is None:\n        raise ValueError(\"No state named 'time' found in states list\")\n\n    time_final = time_state.final[0]\n    time_dilation.min = np.array([time_dilation_factor_min * time_final])\n    time_dilation.max = np.array([time_dilation_factor_max * time_final])\n    time_dilation.guess = np.ones([N, 1]) * time_final\n\n    controls_augmented.append(time_dilation)\n\n    return xdot_aug, states_augmented, controls_augmented\n</code></pre>"},{"location":"reference/symbolic/augmentation/#openscvx.symbolic.augmentation.augment_with_time_state","title":"<code>augment_with_time_state(states: List[State], constraints: ConstraintSet, time_initial: float | tuple, time_final: float | tuple, time_min: float, time_max: float, N: int, time_scaling_min: Optional[float] = None, time_scaling_max: Optional[float] = None) -&gt; Tuple[List[State], ConstraintSet]</code>","text":"<p>Augment problem with a time state variable.</p> <p>Creates a time state variable if one doesn't already exist and adds it to the states list. Also adds CTCS constraints to enforce time bounds continuously throughout the trajectory.</p> <p>The time state tracks physical time along the trajectory and is used for time-optimal control problems. Boundary conditions can be fixed values or free variables with initial guesses.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>List[State]</code> <p>List of State objects (will not be modified, copy is returned)</p> required <code>constraints</code> <code>ConstraintSet</code> <p>ConstraintSet with unsorted constraints (will be modified in place)</p> required <code>time_initial</code> <code>float | tuple</code> <p>Initial time boundary condition: - float: Fixed initial time - tuple: (\"free\", guess) for free initial time with initial guess</p> required <code>time_final</code> <code>float | tuple</code> <p>Final time boundary condition (same format as time_initial)</p> required <code>time_min</code> <code>float</code> <p>Minimum bound for time variable throughout trajectory</p> required <code>time_max</code> <code>float</code> <p>Maximum bound for time variable throughout trajectory</p> required <code>N</code> <code>int</code> <p>Number of discretization nodes (for initial guess generation)</p> required <p>Returns:</p> Type Description <code>Tuple[List[State], ConstraintSet]</code> <p>Tuple of: - Updated states list (original + time state if created) - The same ConstraintSet with time CTCS constraints added to unsorted</p> Note <p>If a state named \"time\" already exists, it is not modified and no constraints are added.</p> Example <p>Get augmented states::</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraints = ConstraintSet()\nstates_aug, constraints = augment_with_time_state(\n    states=[x],\n    constraints=constraints,\n    time_initial=0.0,\n    time_final=(\"free\", 10.0),\n    time_min=0.0,\n    time_max=100.0,\n    N=50\n)\n</code></pre> <p>states_aug now includes time state with initial=0, final=free</p> Source code in <code>openscvx/symbolic/augmentation.py</code> <pre><code>def augment_with_time_state(\n    states: List[State],\n    constraints: ConstraintSet,\n    time_initial: float | tuple,\n    time_final: float | tuple,\n    time_min: float,\n    time_max: float,\n    N: int,\n    time_scaling_min: Optional[float] = None,\n    time_scaling_max: Optional[float] = None,\n) -&gt; Tuple[List[State], ConstraintSet]:\n    \"\"\"Augment problem with a time state variable.\n\n    Creates a time state variable if one doesn't already exist and adds it to the\n    states list. Also adds CTCS constraints to enforce time bounds continuously\n    throughout the trajectory.\n\n    The time state tracks physical time along the trajectory and is used for\n    time-optimal control problems. Boundary conditions can be fixed values or\n    free variables with initial guesses.\n\n    Args:\n        states: List of State objects (will not be modified, copy is returned)\n        constraints: ConstraintSet with unsorted constraints (will be modified in place)\n        time_initial: Initial time boundary condition:\n            - float: Fixed initial time\n            - tuple: (\"free\", guess) for free initial time with initial guess\n        time_final: Final time boundary condition (same format as time_initial)\n        time_min: Minimum bound for time variable throughout trajectory\n        time_max: Maximum bound for time variable throughout trajectory\n        N: Number of discretization nodes (for initial guess generation)\n\n    Returns:\n        Tuple of:\n            - Updated states list (original + time state if created)\n            - The same ConstraintSet with time CTCS constraints added to unsorted\n\n    Note:\n        If a state named \"time\" already exists, it is not modified and no\n        constraints are added.\n\n    Example:\n        Get augmented states::\n\n            x = ox.State(\"x\", shape=(3,))\n            constraints = ConstraintSet()\n            states_aug, constraints = augment_with_time_state(\n                states=[x],\n                constraints=constraints,\n                time_initial=0.0,\n                time_final=(\"free\", 10.0),\n                time_min=0.0,\n                time_max=100.0,\n                N=50\n            )\n\n        states_aug now includes time state with initial=0, final=free\n    \"\"\"\n    # Create copy of states to avoid mutating input\n    states_aug = list(states)\n\n    # Check if a time state already exists\n    time_state = None\n    for state in states_aug:\n        if state.name == \"time\":\n            time_state = state\n            break\n\n    if time_state is None:\n        # Create time State only if it doesn't exist\n        time_state = State(\"time\", shape=(1,))\n        time_state.min = np.array([time_min])\n        time_state.max = np.array([time_max])\n\n        # Set time boundary conditions\n        time_state.initial = [time_initial]\n        time_state.final = [time_final]\n\n        # Create initial guess for time (linear interpolation)\n        time_guess_start = (\n            time_state.initial[0]\n            if isinstance(time_state.initial[0], (int, float))\n            else time_state.initial[0][1]\n        )\n        time_guess_end = (\n            time_state.final[0]\n            if isinstance(time_state.final[0], (int, float))\n            else time_state.final[0][1]\n        )\n        time_state.guess = np.linspace(time_guess_start, time_guess_end, N).reshape(-1, 1)\n\n        # Transfer scaling_min/max from Time object if provided\n        if time_scaling_min is not None:\n            time_state.scaling_min = np.array([time_scaling_min])\n        if time_scaling_max is not None:\n            time_state.scaling_max = np.array([time_scaling_max])\n\n        # Add time state to the list\n        states_aug.append(time_state)\n\n        # Add CTCS constraints for time bounds to unsorted\n        constraints.unsorted.append(CTCS(time_state &lt;= time_state.max))\n        constraints.unsorted.append(CTCS(time_state.min &lt;= time_state))\n\n    return states_aug, constraints\n</code></pre>"},{"location":"reference/symbolic/augmentation/#openscvx.symbolic.augmentation.decompose_vector_nodal_constraints","title":"<code>decompose_vector_nodal_constraints(constraints_nodal: List[NodalConstraint]) -&gt; List[NodalConstraint]</code>","text":"<p>Decompose vector-valued nodal constraints into scalar constraints.</p> <p>Decomposes vector constraints into individual scalar constraints, which is necessary for nonconvex nodal constraints that are lowered to JAX functions. The JAX-to-CVXPY interface expects scalar constraint values at each node.</p> <p>For example, a constraint with shape (3,) is decomposed into 3 separate scalar constraints using indexing. CTCS constraints don't need decomposition since they handle vector values internally.</p> <p>Parameters:</p> Name Type Description Default <code>constraints_nodal</code> <code>List[NodalConstraint]</code> <p>List of NodalConstraint objects (must be canonicalized)</p> required <p>Returns:</p> Type Description <code>List[NodalConstraint]</code> <p>List of NodalConstraint objects with vector constraints decomposed into scalars.</p> <code>List[NodalConstraint]</code> <p>Scalar constraints are passed through unchanged.</p> Note <p>Constraints are assumed to be in canonical form: residual &lt;= 0 or residual == 0, where residual is the lhs of the constraint.</p> Example <p>Decompose vector constraint into 3 constraints:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = (x &lt;= 5).at([0, 10, 20])  # Vector constraint, shape (3,)\ndecomposed = decompose_vector_nodal_constraints([constraint])\n# Returns 3 constraints: x[0] &lt;= 5, x[1] &lt;= 5, x[2] &lt;= 5\n</code></pre> Source code in <code>openscvx/symbolic/augmentation.py</code> <pre><code>def decompose_vector_nodal_constraints(\n    constraints_nodal: List[NodalConstraint],\n) -&gt; List[NodalConstraint]:\n    \"\"\"Decompose vector-valued nodal constraints into scalar constraints.\n\n    Decomposes vector constraints into individual scalar constraints, which is necessary\n    for nonconvex nodal constraints that are lowered to JAX functions. The JAX-to-CVXPY\n    interface expects scalar constraint values at each node.\n\n    For example, a constraint with shape (3,) is decomposed into 3 separate scalar\n    constraints using indexing. CTCS constraints don't need decomposition since they\n    handle vector values internally.\n\n    Args:\n        constraints_nodal (List[NodalConstraint]): List of NodalConstraint objects\n            (must be canonicalized)\n\n    Returns:\n        List of NodalConstraint objects with vector constraints decomposed into scalars.\n        Scalar constraints are passed through unchanged.\n\n    Note:\n        Constraints are assumed to be in canonical form: residual &lt;= 0 or residual == 0,\n        where residual is the lhs of the constraint.\n\n    Example:\n        Decompose vector constraint into 3 constraints:\n\n            x = ox.State(\"x\", shape=(3,))\n            constraint = (x &lt;= 5).at([0, 10, 20])  # Vector constraint, shape (3,)\n            decomposed = decompose_vector_nodal_constraints([constraint])\n            # Returns 3 constraints: x[0] &lt;= 5, x[1] &lt;= 5, x[2] &lt;= 5\n    \"\"\"\n    decomposed_constraints = []\n\n    for nodal_constraint in constraints_nodal:\n        constraint = nodal_constraint.constraint\n        nodes = nodal_constraint.nodes\n\n        try:\n            # Get the shape of the constraint residual\n            # Canonicalized constraints are in form: residual &lt;= 0 or residual == 0\n            residual_shape = constraint.lhs.check_shape()\n\n            # Check if this is a vector constraint\n            # Decompose ALL vector-shaped constraints (including shape=(1,)) to avoid\n            # vmap adding an extra dimension when stacking results\n            if len(residual_shape) &gt; 0:\n                # Vector constraint - decompose into scalar constraints\n                total_elements = int(np.prod(residual_shape))\n\n                for i in range(total_elements):\n                    # Create indexed version: residual[i] &lt;= 0 or residual[i] == 0\n                    indexed_lhs = Index(constraint.lhs, i)\n                    indexed_rhs = constraint.rhs  # Should be Constant(0)\n                    indexed_constraint = constraint.__class__(indexed_lhs, indexed_rhs)\n                    decomposed_constraints.append(NodalConstraint(indexed_constraint, nodes))\n            else:\n                # Scalar constraint - keep as is\n                decomposed_constraints.append(nodal_constraint)\n\n        except Exception:\n            # If shape analysis fails, keep original constraint for backward compatibility\n            decomposed_constraints.append(nodal_constraint)\n\n    return decomposed_constraints\n</code></pre>"},{"location":"reference/symbolic/augmentation/#openscvx.symbolic.augmentation.get_nodal_constraints_from_ctcs","title":"<code>get_nodal_constraints_from_ctcs(constraints_ctcs: List[CTCS]) -&gt; List[tuple[Constraint, tuple[int, int]]]</code>","text":"<p>Extract constraints from CTCS wrappers that should be checked nodally.</p> <p>Some CTCS constraints have the check_nodally flag set, indicating that the underlying constraint should be enforced both continuously (via CTCS) and discretely at the nodes. This function extracts those underlying constraints along with their node intervals.</p> <p>Parameters:</p> Name Type Description Default <code>constraints_ctcs</code> <code>List[CTCS]</code> <p>List of CTCS constraint wrappers</p> required <p>Returns:</p> Type Description <code>List[tuple[Constraint, tuple[int, int]]]</code> <p>List of tuples (constraint, nodes) where: - constraint: The underlying Constraint object from CTCS with check_nodally=True - nodes: The (start, end) interval from the CTCS wrapper</p> Example <p>Extract CTCS constraint that should also be checked at nodes:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = (x &lt;= 5).over((10, 50), check_nodally=True)\nnodal = get_nodal_constraints_from_ctcs([constraint])\n</code></pre> <p>Returns [(x &lt;= 5, (10, 50))] to be enforced at nodes 10 through 49</p> Source code in <code>openscvx/symbolic/augmentation.py</code> <pre><code>def get_nodal_constraints_from_ctcs(\n    constraints_ctcs: List[CTCS],\n) -&gt; List[tuple[Constraint, tuple[int, int]]]:\n    \"\"\"Extract constraints from CTCS wrappers that should be checked nodally.\n\n    Some CTCS constraints have the check_nodally flag set, indicating that the\n    underlying constraint should be enforced both continuously (via CTCS) and\n    discretely at the nodes. This function extracts those underlying constraints\n    along with their node intervals.\n\n    Args:\n        constraints_ctcs: List of CTCS constraint wrappers\n\n    Returns:\n        List of tuples (constraint, nodes) where:\n            - constraint: The underlying Constraint object from CTCS with check_nodally=True\n            - nodes: The (start, end) interval from the CTCS wrapper\n\n    Example:\n        Extract CTCS constraint that should also be checked at nodes:\n\n            x = ox.State(\"x\", shape=(3,))\n            constraint = (x &lt;= 5).over((10, 50), check_nodally=True)\n            nodal = get_nodal_constraints_from_ctcs([constraint])\n\n        Returns [(x &lt;= 5, (10, 50))] to be enforced at nodes 10 through 49\n    \"\"\"\n    nodal_ctcs = []\n    for ctcs in constraints_ctcs:\n        if ctcs.check_nodally:\n            nodal_ctcs.append((ctcs.constraint, ctcs.nodes))\n    return nodal_ctcs\n</code></pre>"},{"location":"reference/symbolic/augmentation/#openscvx.symbolic.augmentation.separate_constraints","title":"<code>separate_constraints(constraint_set: ConstraintSet, n_nodes: int) -&gt; ConstraintSet</code>","text":"<p>Separate and categorize constraints by type and convexity.</p> <p>Moves constraints from <code>constraint_set.unsorted</code> into their appropriate category fields (ctcs, nodal, nodal_convex, cross_node, cross_node_convex).</p> <p>Bare Constraint objects are automatically categorized: - If they contain NodeReferences (from .at(k) calls), they become CrossNodeConstraint - Otherwise, they become NodalConstraint applied at all nodes</p> <p>Constraints within CTCS wrappers that have check_nodally=True are also extracted and added to the nodal constraint lists.</p> <p>Parameters:</p> Name Type Description Default <code>constraint_set</code> <code>ConstraintSet</code> <p>ConstraintSet with raw constraints in <code>unsorted</code> field</p> required <code>n_nodes</code> <code>int</code> <p>Total number of nodes in the trajectory</p> required <p>Returns:</p> Type Description <code>ConstraintSet</code> <p>The same ConstraintSet with <code>unsorted</code> drained and categories populated</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a constraint is not one of the expected types</p> <code>ValueError</code> <p>If a NodalConstraint contains NodeReferences (use bare Constraint instead)</p> <code>ValueError</code> <p>If a CTCS constraint contains NodeReferences</p> Example <p>Separate and categorize constraints::</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint_set = ConstraintSet(unsorted=[\n    (x &lt;= 5).over((0, 50)),           # CTCS\n    (x &gt;= 0).at([0, 10, 20]),         # NodalConstraint\n    ox.Norm(x) &lt;= 1,                  # Bare -&gt; all nodes\n    x.at(5) - x.at(4) &lt;= 0.1,         # Bare with NodeRef -&gt; cross-node\n])\nseparate_constraints(constraint_set, n_nodes=50)\nassert constraint_set.is_categorized\n# Access via: constraint_set.ctcs, constraint_set.nodal, etc.\n</code></pre> Source code in <code>openscvx/symbolic/augmentation.py</code> <pre><code>def separate_constraints(constraint_set: ConstraintSet, n_nodes: int) -&gt; ConstraintSet:\n    \"\"\"Separate and categorize constraints by type and convexity.\n\n    Moves constraints from `constraint_set.unsorted` into their appropriate\n    category fields (ctcs, nodal, nodal_convex, cross_node, cross_node_convex).\n\n    Bare Constraint objects are automatically categorized:\n    - If they contain NodeReferences (from .at(k) calls), they become CrossNodeConstraint\n    - Otherwise, they become NodalConstraint applied at all nodes\n\n    Constraints within CTCS wrappers that have check_nodally=True are also extracted\n    and added to the nodal constraint lists.\n\n    Args:\n        constraint_set: ConstraintSet with raw constraints in `unsorted` field\n        n_nodes: Total number of nodes in the trajectory\n\n    Returns:\n        The same ConstraintSet with `unsorted` drained and categories populated\n\n    Raises:\n        ValueError: If a constraint is not one of the expected types\n        ValueError: If a NodalConstraint contains NodeReferences (use bare Constraint instead)\n        ValueError: If a CTCS constraint contains NodeReferences\n\n    Example:\n        Separate and categorize constraints::\n\n            x = ox.State(\"x\", shape=(3,))\n            constraint_set = ConstraintSet(unsorted=[\n                (x &lt;= 5).over((0, 50)),           # CTCS\n                (x &gt;= 0).at([0, 10, 20]),         # NodalConstraint\n                ox.Norm(x) &lt;= 1,                  # Bare -&gt; all nodes\n                x.at(5) - x.at(4) &lt;= 0.1,         # Bare with NodeRef -&gt; cross-node\n            ])\n            separate_constraints(constraint_set, n_nodes=50)\n            assert constraint_set.is_categorized\n            # Access via: constraint_set.ctcs, constraint_set.nodal, etc.\n    \"\"\"\n    from openscvx.symbolic.lower import _contains_node_reference\n\n    # Process all constraints from unsorted\n    for c in constraint_set.unsorted:\n        if isinstance(c, CTCS):\n            # Validate that CTCS constraints don't contain NodeReferences\n            if _contains_node_reference(c.constraint):\n                raise ValueError(\n                    \"CTCS constraints cannot contain NodeReferences (.at(k)). \"\n                    \"Cross-node constraints should be specified as bare Constraint objects. \"\n                    f\"Constraint: {c.constraint}\"\n                )\n            # Normalize None to full horizon\n            c.nodes = c.nodes or (0, n_nodes)\n            constraint_set.ctcs.append(c)\n\n        elif isinstance(c, NodalConstraint):\n            # NodalConstraint means user explicitly called .at([...])\n            # Cross-node constraints should NOT use .at([...]) wrapper\n            if _contains_node_reference(c.constraint):\n                raise ValueError(\n                    f\"Cross-node constraints should not use .at([...]) wrapper. \"\n                    f\"The constraint already references specific nodes via .at(k) inside the \"\n                    f\"expression. Remove the outer .at([...]) wrapper and use the bare \"\n                    f\"constraint directly. \"\n                    f\"Constraint: {c.constraint}\"\n                )\n\n            # Regular nodal constraint - categorize by convexity\n            if c.constraint.is_convex:\n                constraint_set.nodal_convex.append(c)\n            else:\n                constraint_set.nodal.append(c)\n\n        elif isinstance(c, Constraint):\n            # Bare constraint - check if it's a cross-node constraint\n            if _contains_node_reference(c):\n                # Cross-node constraint: wrap in CrossNodeConstraint\n                cross_node = CrossNodeConstraint(c)\n                if c.is_convex:\n                    constraint_set.cross_node_convex.append(cross_node)\n                else:\n                    constraint_set.cross_node.append(cross_node)\n            else:\n                # Regular constraint: apply at all nodes\n                all_nodes = list(range(n_nodes))\n                nodal_constraint = NodalConstraint(c, all_nodes)\n                if c.is_convex:\n                    constraint_set.nodal_convex.append(nodal_constraint)\n                else:\n                    constraint_set.nodal.append(nodal_constraint)\n\n        else:\n            raise ValueError(\n                \"Constraints must be `Constraint`, `NodalConstraint`, or `CTCS`, \"\n                f\"got {type(c).__name__}\"\n            )\n\n    # Clear unsorted now that all have been categorized\n    constraint_set.unsorted = []\n\n    # Add nodal constraints from CTCS constraints that have check_nodally=True\n    ctcs_nodal_constraints = get_nodal_constraints_from_ctcs(constraint_set.ctcs)\n    for constraint, interval in ctcs_nodal_constraints:\n        # CTCS check_nodally constraints cannot have NodeReferences (validated above)\n        # Convert CTCS interval (start, end) to list of nodes [start, start+1, ..., end-1]\n        interval_nodes = list(range(interval[0], interval[1]))\n        nodal_constraint = NodalConstraint(constraint, interval_nodes)\n\n        if constraint.is_convex:\n            constraint_set.nodal_convex.append(nodal_constraint)\n        else:\n            constraint_set.nodal.append(nodal_constraint)\n\n    # Validate cross-node constraints (bounds and variable consistency)\n    from openscvx.symbolic.preprocessing import validate_cross_node_constraint\n\n    for cross_node_constraint in constraint_set.cross_node + constraint_set.cross_node_convex:\n        validate_cross_node_constraint(cross_node_constraint, n_nodes)\n\n    return constraint_set\n</code></pre>"},{"location":"reference/symbolic/augmentation/#openscvx.symbolic.augmentation.sort_ctcs_constraints","title":"<code>sort_ctcs_constraints(constraints_ctcs: List[CTCS]) -&gt; Tuple[List[CTCS], List[Tuple[int, int]], int]</code>","text":"<p>Sort and group CTCS constraints by time interval and assign indices.</p> <p>Groups CTCS constraints by their time intervals (nodes) and assigns a unique index (idx) to each group. Constraints with the same time interval can share an augmented state (same idx), while constraints with different intervals must have different augmented states.</p> Grouping rules <ul> <li>Constraints with the same node interval can share an idx</li> <li>Constraints with different node intervals must have different idx values</li> <li>idx values must form a contiguous block starting from 0</li> <li>Unspecified idx values are automatically assigned</li> <li>User-specified idx values are validated for consistency</li> </ul> <p>Parameters:</p> Name Type Description Default <code>constraints_ctcs</code> <code>List[CTCS]</code> <p>List of CTCS constraints to sort and group</p> required <p>Returns:</p> Type Description <code>Tuple[List[CTCS], List[Tuple[int, int]], int]</code> <p>Tuple of: - List of CTCS constraints with idx assigned to each - List of node intervals (start, end) in ascending idx order - Number of augmented states needed (number of unique idx values)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If user-specified idx values are inconsistent or non-contiguous</p> Example <p>Sort CTCS constraints by interval and index:</p> <pre><code>constraint1 = (x &lt;= 5).over((0, 50))  # Auto-assigned idx\nconstraint2 = (y &lt;= 10).over((0, 50))  # Same interval, same idx\nconstraint3 = (z &lt;= 15).over((20, 80))  # Different interval, different idx\nsorted_ctcs, intervals, n_aug = sort_ctcs_constraints([c1, c2, c3])\n# constraint1.idx = 0, constraint2.idx = 0, constraint3.idx = 1\n# intervals = [(0, 50), (20, 80)]\n# n_aug = 2\n</code></pre> Source code in <code>openscvx/symbolic/augmentation.py</code> <pre><code>def sort_ctcs_constraints(\n    constraints_ctcs: List[CTCS],\n) -&gt; Tuple[List[CTCS], List[Tuple[int, int]], int]:\n    \"\"\"Sort and group CTCS constraints by time interval and assign indices.\n\n    Groups CTCS constraints by their time intervals (nodes) and assigns a unique\n    index (idx) to each group. Constraints with the same time interval can share\n    an augmented state (same idx), while constraints with different intervals must\n    have different augmented states.\n\n    Grouping rules:\n        - Constraints with the same node interval can share an idx\n        - Constraints with different node intervals must have different idx values\n        - idx values must form a contiguous block starting from 0\n        - Unspecified idx values are automatically assigned\n        - User-specified idx values are validated for consistency\n\n    Args:\n        constraints_ctcs: List of CTCS constraints to sort and group\n\n    Returns:\n        Tuple of:\n            - List of CTCS constraints with idx assigned to each\n            - List of node intervals (start, end) in ascending idx order\n            - Number of augmented states needed (number of unique idx values)\n\n    Raises:\n        ValueError: If user-specified idx values are inconsistent or non-contiguous\n\n    Example:\n        Sort CTCS constraints by interval and index:\n\n            constraint1 = (x &lt;= 5).over((0, 50))  # Auto-assigned idx\n            constraint2 = (y &lt;= 10).over((0, 50))  # Same interval, same idx\n            constraint3 = (z &lt;= 15).over((20, 80))  # Different interval, different idx\n            sorted_ctcs, intervals, n_aug = sort_ctcs_constraints([c1, c2, c3])\n            # constraint1.idx = 0, constraint2.idx = 0, constraint3.idx = 1\n            # intervals = [(0, 50), (20, 80)]\n            # n_aug = 2\n    \"\"\"\n    idx_to_nodes: Dict[int, Tuple[int, int]] = {}\n    next_idx = 0\n\n    for c in constraints_ctcs:\n        key = c.nodes\n\n        if c.idx is not None:\n            # User supplied an identifier: ensure it always points to the same interval\n            if c.idx in idx_to_nodes:\n                if idx_to_nodes[c.idx] != key:\n                    raise ValueError(\n                        f\"idx={c.idx} was first used with interval={idx_to_nodes[c.idx]}, \"\n                        f\"but now you gave it interval={key}\"\n                    )\n            else:\n                # When idx is explicitly provided, always create a separate group\n                # even if nodes are the same - this allows multiple constraint groups\n                # with the same node interval but different idx values\n                idx_to_nodes[c.idx] = key\n        else:\n            # No identifier: see if this interval already has one\n            for existing_id, nodes in idx_to_nodes.items():\n                if nodes == key:\n                    c.idx = existing_id\n                    break\n            else:\n                # Brand-new interval: pick the next free auto-id\n                while next_idx in idx_to_nodes:\n                    next_idx += 1\n                c.idx = next_idx\n                idx_to_nodes[next_idx] = key\n                next_idx += 1\n\n    # Validate that idx values form a contiguous block starting from 0\n    ordered_ids = sorted(idx_to_nodes.keys())\n    expected_ids = list(range(len(ordered_ids)))\n    if ordered_ids != expected_ids:\n        raise ValueError(\n            f\"CTCS constraint idx values must form a contiguous block starting from 0. \"\n            f\"Got {ordered_ids}, expected {expected_ids}\"\n        )\n\n    # Extract intervals in ascending idx order\n    node_intervals = [idx_to_nodes[i] for i in ordered_ids]\n    num_augmented_states = len(ordered_ids)\n\n    return constraints_ctcs, node_intervals, num_augmented_states\n</code></pre>"},{"location":"reference/symbolic/builder/","title":"builder","text":"<p>Symbolic problem preprocessing and augmentation pipeline.</p> <p>This module provides the main preprocessing pipeline for trajectory optimization problems, transforming user-specified symbolic dynamics and constraints into an augmented form ready for compilation to executable code.</p> <p>The preprocessing pipeline is purely symbolic - no code generation occurs here. Instead, it performs validation, canonicalization, and augmentation to prepare the problem for efficient numerical solution.</p> Key functionality <ul> <li>Problem validation: Check shapes, variable names, constraint placement</li> <li>Time handling: Auto-create time state or validate user-provided time</li> <li>Canonicalization: Simplify expressions algebraically</li> <li>Parameter collection: Extract parameter values from expressions</li> <li>Constraint separation: Categorize constraints by type (CTCS, nodal, convex)</li> <li>CTCS augmentation: Add augmented states and time dilation for path constraints</li> <li>Propagation dynamics: Optionally extend dynamics for post-solution propagation</li> </ul> <p>The preprocessing pipeline is purely symbolic - no code generation occurs here.</p> Pipeline stages <ol> <li>Time handling &amp; validation</li> <li>Expression validation (shapes, names, constraint structure)</li> <li>Canonicalization &amp; parameter collection</li> <li>Constraint separation &amp; CTCS augmentation</li> <li>Propagation dynamics creation</li> </ol> <p>See <code>preprocess_symbolic_problem()</code> for the main entry point.</p>"},{"location":"reference/symbolic/builder/#openscvx.symbolic.builder.add_propagation_states","title":"<code>add_propagation_states(dynamics_extra: dict, states_extra: List[State], dynamics_opt: any, states_opt: List[State], controls_opt: List[Control], parameters: Dict[str, any]) -&gt; Tuple</code>","text":"<p>Extend optimization dynamics with additional propagation-only states.</p> <p>This function augments the optimization dynamics with extra states that are only needed for post-solution trajectory propagation and simulation. These states don't affect the optimization but are useful for computing derived quantities like distance traveled, energy consumed, or accumulated cost.</p> <p>Propagation-only states are NOT part of the optimization problem - they are integrated forward after solving using the optimized state and control trajectories. This is more efficient than including them as optimization variables.</p> <p>The user specifies only the ADDITIONAL states and their dynamics. These are appended after all optimization states (user states + time + CTCS augmented states).</p> State ordering in propagation dynamics <p>[user_states, time, ctcs_aug_states, extra_prop_states]</p> <p>Parameters:</p> Name Type Description Default <code>dynamics_extra</code> <code>dict</code> <p>Dictionary mapping extra state names to dynamics expressions. Only specify NEW states, not optimization states. Example: {\"distance\": speed}</p> required <code>states_extra</code> <code>List[State]</code> <p>List of extra State objects for propagation only</p> required <code>dynamics_opt</code> <code>any</code> <p>Augmented optimization dynamics expression (from preprocessing)</p> required <code>states_opt</code> <code>List[State]</code> <p>Augmented optimization states (user + time + CTCS augmented)</p> required <code>controls_opt</code> <code>List[Control]</code> <p>Augmented optimization controls (user + time dilation)</p> required <code>parameters</code> <code>Dict[str, any]</code> <p>Dictionary of parameter values from optimization preprocessing</p> required <p>Returns:</p> Type Description <code>Tuple</code> <p>Tuple containing: - dynamics_prop (Expr): Extended dynamics (optimization + extra) - states_prop (List[State]): Extended states (optimization + extra) - controls_prop (List[Control]): Same as controls_opt - parameters_updated (Dict): Updated parameters including any from extra dynamics</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If extra states conflict with optimization state names or if        validation fails</p> Example <p>Adding distance and energy tracking for propagation::</p> <pre><code>    # After preprocessing, add propagation states\n    import openscvx as ox\n    import numpy as np\n\n    # Define extra states for tracking\n    distance = ox.State(\"distance\", shape=(1,))\n    distance.initial = np.array([0.0])\n\n    energy = ox.State(\"energy\", shape=(1,))\n    energy.initial = np.array([0.0])\n\n    # Define their dynamics (using optimization states/controls)\n    # Assume v and u are optimization states/controls\n    dynamics_extra = {\n        \"distance\": ox.Norm(v),  # Integrate velocity magnitude\n        \"energy\": ox.Norm(u)**2  # Integrate squared control\n    }\n\n    dyn_prop, states_prop, controls_prop, params = add_propagation_states(\n        dynamics_extra=dynamics_extra,\n        states_extra=[distance, energy],\n        dynamics_opt=dynamics_aug,\n        states_opt=states_aug,\n        controls_opt=controls_aug,\n        parameters=parameters\n    )\n\n    # Now states_prop includes all states for forward simulation\n    # distance and energy will be integrated during propagation\n</code></pre> Note <p>The extra states should have initial conditions set, as they will be integrated from these initial values during propagation.</p> Source code in <code>openscvx/symbolic/builder.py</code> <pre><code>def add_propagation_states(\n    dynamics_extra: dict,\n    states_extra: List[State],\n    dynamics_opt: any,\n    states_opt: List[State],\n    controls_opt: List[Control],\n    parameters: Dict[str, any],\n) -&gt; Tuple:\n    \"\"\"Extend optimization dynamics with additional propagation-only states.\n\n    This function augments the optimization dynamics with extra states that are only\n    needed for post-solution trajectory propagation and simulation. These states\n    don't affect the optimization but are useful for computing derived quantities\n    like distance traveled, energy consumed, or accumulated cost.\n\n    Propagation-only states are NOT part of the optimization problem - they are\n    integrated forward after solving using the optimized state and control trajectories.\n    This is more efficient than including them as optimization variables.\n\n    The user specifies only the ADDITIONAL states and their dynamics. These are\n    appended after all optimization states (user states + time + CTCS augmented states).\n\n    State ordering in propagation dynamics:\n        [user_states, time, ctcs_aug_states, extra_prop_states]\n\n    Args:\n        dynamics_extra: Dictionary mapping extra state names to dynamics expressions.\n            Only specify NEW states, not optimization states. Example: {\"distance\": speed}\n        states_extra: List of extra State objects for propagation only\n        dynamics_opt: Augmented optimization dynamics expression (from preprocessing)\n        states_opt: Augmented optimization states (user + time + CTCS augmented)\n        controls_opt: Augmented optimization controls (user + time dilation)\n        parameters: Dictionary of parameter values from optimization preprocessing\n\n    Returns:\n        Tuple containing:\n            - dynamics_prop (Expr): Extended dynamics (optimization + extra)\n            - states_prop (List[State]): Extended states (optimization + extra)\n            - controls_prop (List[Control]): Same as controls_opt\n            - parameters_updated (Dict): Updated parameters including any from extra dynamics\n\n    Raises:\n        ValueError: If extra states conflict with optimization state names or if\n                   validation fails\n\n    Example:\n        Adding distance and energy tracking for propagation::\n\n                # After preprocessing, add propagation states\n                import openscvx as ox\n                import numpy as np\n\n                # Define extra states for tracking\n                distance = ox.State(\"distance\", shape=(1,))\n                distance.initial = np.array([0.0])\n\n                energy = ox.State(\"energy\", shape=(1,))\n                energy.initial = np.array([0.0])\n\n                # Define their dynamics (using optimization states/controls)\n                # Assume v and u are optimization states/controls\n                dynamics_extra = {\n                    \"distance\": ox.Norm(v),  # Integrate velocity magnitude\n                    \"energy\": ox.Norm(u)**2  # Integrate squared control\n                }\n\n                dyn_prop, states_prop, controls_prop, params = add_propagation_states(\n                    dynamics_extra=dynamics_extra,\n                    states_extra=[distance, energy],\n                    dynamics_opt=dynamics_aug,\n                    states_opt=states_aug,\n                    controls_opt=controls_aug,\n                    parameters=parameters\n                )\n\n                # Now states_prop includes all states for forward simulation\n                # distance and energy will be integrated during propagation\n\n    Note:\n        The extra states should have initial conditions set, as they will be\n        integrated from these initial values during propagation.\n    \"\"\"\n\n    # Make copies to avoid mutating inputs\n    states_extra = list(states_extra)\n    dynamics_extra = dict(dynamics_extra)\n    parameters = dict(parameters)\n\n    # ==================== PHASE 1: Validate Extra States ====================\n\n    # Validate that extra states don't conflict with optimization state names\n    opt_state_names = {s.name for s in states_opt}\n    extra_state_names = {s.name for s in states_extra}\n    conflicts = opt_state_names &amp; extra_state_names\n    if conflicts:\n        raise ValueError(\n            f\"Extra propagation states conflict with optimization states: {conflicts}. \"\n            f\"Only specify additional states, not optimization states.\"\n        )\n\n    # Validate dynamics dict for extra states\n    validate_dynamics_dict(dynamics_extra, states_extra)\n    validate_dynamics_dict_dimensions(dynamics_extra, states_extra)\n\n    # ==================== PHASE 2: Process Extra Dynamics ====================\n\n    # Convert extra dynamics to expression\n    _, dynamics_extra_concat = convert_dynamics_dict_to_expr(dynamics_extra, states_extra)\n\n    # Validate and canonicalize\n    validate_variable_names([dynamics_extra_concat])\n\n    # Temporarily assign slices for validation (will be recalculated below)\n    collect_and_assign_slices(states_extra, controls_opt)\n    validate_shapes([dynamics_extra_concat])\n    validate_dynamics_dimension(dynamics_extra_concat, states_extra)\n    dynamics_extra_concat = dynamics_extra_concat.canonicalize()\n\n    # Collect any new parameter values from extra dynamics\n    def collect_param_values(expr):\n        if isinstance(expr, Parameter):\n            if expr.name not in parameters:\n                parameters[expr.name] = expr.value\n\n    traverse(dynamics_extra_concat, collect_param_values)\n\n    # ==================== PHASE 3: Concatenate with Optimization Dynamics ====================\n\n    # Concatenate: {opt dynamics, extra dynamics}\n    from openscvx.symbolic.expr import Concat\n\n    dynamics_prop = Concat(dynamics_opt, dynamics_extra_concat)\n\n    # Manually assign slices to extra states ONLY (don't modify optimization state slices)\n    # Extra states are appended after all optimization states\n    n_opt_states = states_opt[-1]._slice.stop if states_opt else 0\n    start_idx = n_opt_states\n    for state in states_extra:\n        end_idx = start_idx + state.shape[0]\n        state._slice = slice(start_idx, end_idx)\n        start_idx = end_idx\n\n    # Append extra states to optimization states\n    states_prop = states_opt + states_extra\n\n    # Propagation uses same controls as optimization\n    controls_prop = controls_opt\n\n    # ==================== Return Symbolic Outputs ====================\n\n    return (\n        dynamics_prop,\n        states_prop,\n        controls_prop,\n        parameters,\n    )\n</code></pre>"},{"location":"reference/symbolic/builder/#openscvx.symbolic.builder.preprocess_symbolic_problem","title":"<code>preprocess_symbolic_problem(dynamics: dict, constraints: ConstraintSet, states: List[State], controls: List[Control], N: int, time: Time, licq_min: float = 0.0, licq_max: float = 0.0001, time_dilation_factor_min: float = 0.3, time_dilation_factor_max: float = 3.0, dynamics_prop_extra: dict = None, states_prop_extra: List[State] = None, algebraic_prop: dict = None, byof: Optional[dict] = None) -&gt; SymbolicProblem</code>","text":"<p>Preprocess and augment symbolic trajectory optimization problem.</p> <p>This is the main preprocessing pipeline that transforms a user-specified symbolic problem into an augmented form ready for compilation. It performs validation, canonicalization, constraint separation, and CTCS augmentation in a series of well-defined phases.</p> <p>The function is purely symbolic - no code generation or compilation occurs. The output is a SymbolicProblem dataclass that can be lowered to JAX or CVXPy by downstream compilation functions.</p> Pipeline phases <ol> <li>Time handling &amp; validation: Auto-create or validate time state</li> <li>Expression validation: Validate shapes, names, constraints</li> <li>Canonicalization &amp; parameter collection: Simplify and extract parameters</li> <li>Constraint separation &amp; augmentation: Sort constraints and add CTCS states</li> <li>Propagation dynamics creation: Optionally add extra states for simulation</li> </ol> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>dict</code> <p>Dictionary mapping state names to dynamics expressions. Example: {\"x\": v, \"v\": u}</p> required <code>constraints</code> <code>ConstraintSet</code> <p>ConstraintSet with raw constraints in <code>unsorted</code> field. Create with: ConstraintSet(unsorted=[c1, c2, c3])</p> required <code>states</code> <code>List[State]</code> <p>List of user-defined State objects (should NOT include time or CTCS states)</p> required <code>controls</code> <code>List[Control]</code> <p>List of user-defined Control objects (should NOT include time dilation)</p> required <code>N</code> <code>int</code> <p>Number of discretization nodes in the trajectory</p> required <code>time</code> <code>Time</code> <p>Time configuration object specifying time bounds and constraints</p> required <code>licq_min</code> <code>float</code> <p>Minimum bound for CTCS augmented states (default: 0.0)</p> <code>0.0</code> <code>licq_max</code> <code>float</code> <p>Maximum bound for CTCS augmented states (default: 1e-4)</p> <code>0.0001</code> <code>time_dilation_factor_min</code> <code>float</code> <p>Minimum factor for time dilation control (default: 0.3)</p> <code>0.3</code> <code>time_dilation_factor_max</code> <code>float</code> <p>Maximum factor for time dilation control (default: 3.0)</p> <code>3.0</code> <code>dynamics_prop_extra</code> <code>dict</code> <p>Optional dictionary of additional dynamics for propagation-only states (default: None)</p> <code>None</code> <code>states_prop_extra</code> <code>List[State]</code> <p>Optional list of additional State objects for propagation only (default: None)</p> <code>None</code> <code>algebraic_prop</code> <code>dict</code> <p>Optional dictionary of algebraic outputs for propagation (evaluated, not integrated). (default: None)</p> <code>None</code> <code>byof</code> <code>Optional[dict]</code> <p>Optional dict of raw JAX functions for expert users. If byof contains a \"dynamics\" key, it should map state names to raw JAX functions with signature f(x, u, node, params) -&gt; xdot_component. States in byof[\"dynamics\"] should NOT appear in the symbolic dynamics dict.</p> <code>None</code> <p>Returns:</p> Type Description <code>SymbolicProblem</code> <p>SymbolicProblem dataclass with: - dynamics: Augmented dynamics (user + time + CTCS penalties) - states: Augmented states (user + time + CTCS augmented) - controls: Augmented controls (user + time dilation) - constraints: ConstraintSet with is_categorized=True - parameters: Dict of extracted parameter values - node_intervals: List of (start, end) tuples for CTCS intervals - dynamics_prop: Propagation dynamics - states_prop: Propagation states - controls_prop: Propagation controls - algebraic_prop: Algebraic outputs (validated and canonicalized)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails at any stage</p> Example <p>Basic usage with CTCS constraint::</p> <pre><code>import openscvx as ox\nfrom openscvx.symbolic.constraint_set import ConstraintSet\n\nx = ox.State(\"x\", shape=(2,))\nv = ox.State(\"v\", shape=(2,))\nu = ox.Control(\"u\", shape=(2,))\n\ndynamics = {\"x\": v, \"v\": u}\nconstraints = ConstraintSet(unsorted=[\n    (ox.Norm(x) &lt;= 5.0).over((0, 50))\n])\n\nproblem = preprocess_symbolic_problem(\n    dynamics=dynamics,\n    constraints=constraints,\n    states=[x, v],\n    controls=[u],\n    N=50,\n    time=ox.Time(initial=0.0, final=10.0)\n)\n\nassert problem.is_preprocessed\n# problem.dynamics: augmented dynamics expression\n# problem.states: [x, v, time, _ctcs_aug_0]\n# problem.controls: [u, _time_dilation]\nprint([s.name for s in problem.states])\n# ['x', 'v', 'time', '_ctcs_aug_0']\n</code></pre> <p>With propagation-only states::</p> <pre><code>distance = ox.State(\"distance\", shape=(1,))\ndynamics_extra = {\"distance\": ox.Norm(v)}\n\nproblem = preprocess_symbolic_problem(\n    dynamics=dynamics,\n    constraints=constraints,\n    states=[x, v],\n    controls=[u],\n    N=50,\n    time=ox.Time(initial=0.0, final=10.0),\n    dynamics_prop_extra=dynamics_extra,\n    states_prop_extra=[distance]\n)\n\n# Propagation states include distance for post-solve simulation\nprint([s.name for s in problem.states_prop])\n</code></pre> Source code in <code>openscvx/symbolic/builder.py</code> <pre><code>def preprocess_symbolic_problem(\n    dynamics: dict,\n    constraints: ConstraintSet,\n    states: List[State],\n    controls: List[Control],\n    N: int,\n    time: Time,\n    licq_min: float = 0.0,\n    licq_max: float = 1e-4,\n    time_dilation_factor_min: float = 0.3,\n    time_dilation_factor_max: float = 3.0,\n    dynamics_prop_extra: dict = None,\n    states_prop_extra: List[State] = None,\n    algebraic_prop: dict = None,\n    byof: Optional[dict] = None,\n) -&gt; SymbolicProblem:\n    \"\"\"Preprocess and augment symbolic trajectory optimization problem.\n\n    This is the main preprocessing pipeline that transforms a user-specified symbolic\n    problem into an augmented form ready for compilation. It performs validation,\n    canonicalization, constraint separation, and CTCS augmentation in a series of\n    well-defined phases.\n\n    The function is purely symbolic - no code generation or compilation occurs. The\n    output is a SymbolicProblem dataclass that can be lowered to JAX or CVXPy by\n    downstream compilation functions.\n\n    Pipeline phases:\n        1. Time handling &amp; validation: Auto-create or validate time state\n        2. Expression validation: Validate shapes, names, constraints\n        3. Canonicalization &amp; parameter collection: Simplify and extract parameters\n        4. Constraint separation &amp; augmentation: Sort constraints and add CTCS states\n        5. Propagation dynamics creation: Optionally add extra states for simulation\n\n    Args:\n        dynamics: Dictionary mapping state names to dynamics expressions.\n            Example: {\"x\": v, \"v\": u}\n        constraints: ConstraintSet with raw constraints in `unsorted` field.\n            Create with: ConstraintSet(unsorted=[c1, c2, c3])\n        states: List of user-defined State objects (should NOT include time or CTCS states)\n        controls: List of user-defined Control objects (should NOT include time dilation)\n        N: Number of discretization nodes in the trajectory\n        time: Time configuration object specifying time bounds and constraints\n        licq_min: Minimum bound for CTCS augmented states (default: 0.0)\n        licq_max: Maximum bound for CTCS augmented states (default: 1e-4)\n        time_dilation_factor_min: Minimum factor for time dilation control (default: 0.3)\n        time_dilation_factor_max: Maximum factor for time dilation control (default: 3.0)\n        dynamics_prop_extra: Optional dictionary of additional dynamics for propagation-only\n            states (default: None)\n        states_prop_extra: Optional list of additional State objects for propagation only\n            (default: None)\n        algebraic_prop: Optional dictionary of algebraic outputs for propagation\n            (evaluated, not integrated). (default: None)\n        byof: Optional dict of raw JAX functions for expert users. If byof contains\n            a \"dynamics\" key, it should map state names to raw JAX functions with\n            signature f(x, u, node, params) -&gt; xdot_component. States in byof[\"dynamics\"]\n            should NOT appear in the symbolic dynamics dict.\n\n    Returns:\n        SymbolicProblem dataclass with:\n            - dynamics: Augmented dynamics (user + time + CTCS penalties)\n            - states: Augmented states (user + time + CTCS augmented)\n            - controls: Augmented controls (user + time dilation)\n            - constraints: ConstraintSet with is_categorized=True\n            - parameters: Dict of extracted parameter values\n            - node_intervals: List of (start, end) tuples for CTCS intervals\n            - dynamics_prop: Propagation dynamics\n            - states_prop: Propagation states\n            - controls_prop: Propagation controls\n            - algebraic_prop: Algebraic outputs (validated and canonicalized)\n\n    Raises:\n        ValueError: If validation fails at any stage\n\n    Example:\n        Basic usage with CTCS constraint::\n\n            import openscvx as ox\n            from openscvx.symbolic.constraint_set import ConstraintSet\n\n            x = ox.State(\"x\", shape=(2,))\n            v = ox.State(\"v\", shape=(2,))\n            u = ox.Control(\"u\", shape=(2,))\n\n            dynamics = {\"x\": v, \"v\": u}\n            constraints = ConstraintSet(unsorted=[\n                (ox.Norm(x) &lt;= 5.0).over((0, 50))\n            ])\n\n            problem = preprocess_symbolic_problem(\n                dynamics=dynamics,\n                constraints=constraints,\n                states=[x, v],\n                controls=[u],\n                N=50,\n                time=ox.Time(initial=0.0, final=10.0)\n            )\n\n            assert problem.is_preprocessed\n            # problem.dynamics: augmented dynamics expression\n            # problem.states: [x, v, time, _ctcs_aug_0]\n            # problem.controls: [u, _time_dilation]\n            print([s.name for s in problem.states])\n            # ['x', 'v', 'time', '_ctcs_aug_0']\n\n        With propagation-only states::\n\n            distance = ox.State(\"distance\", shape=(1,))\n            dynamics_extra = {\"distance\": ox.Norm(v)}\n\n            problem = preprocess_symbolic_problem(\n                dynamics=dynamics,\n                constraints=constraints,\n                states=[x, v],\n                controls=[u],\n                N=50,\n                time=ox.Time(initial=0.0, final=10.0),\n                dynamics_prop_extra=dynamics_extra,\n                states_prop_extra=[distance]\n            )\n\n            # Propagation states include distance for post-solve simulation\n            print([s.name for s in problem.states_prop])\n    \"\"\"\n\n    # Validate user-provided variables have required attributes\n    validate_boundary_conditions(states)\n    validate_bounds(states + controls)\n\n    # Fill in default guesses for user-provided states\n    # (augmented states get their guesses set by augmentation code)\n    fill_default_guesses(states, N)\n\n    # Validate that all user-provided variables have guesses\n    validate_guesses(states + controls)\n\n    # ==================== PHASE 1: Time Handling &amp; Validation ====================\n\n    # Validate time handling approach and get processed parameters\n    (\n        has_time_state,\n        time_initial,\n        time_final,\n        time_derivative,\n        time_min,\n        time_max,\n    ) = validate_time_parameters(states, time)\n\n    # Augment states with time state if needed (auto-create approach)\n    if not has_time_state:\n        states, constraints = augment_with_time_state(\n            states,\n            constraints,\n            time_initial,\n            time_final,\n            time_min,\n            time_max,\n            N,\n            time_scaling_min=getattr(time, \"scaling_min\", None),\n            time_scaling_max=getattr(time, \"scaling_max\", None),\n        )\n\n    # Add time derivative to dynamics dict (if not already present)\n    # Time derivative is always 1.0 when using Time object\n    dynamics = dict(dynamics)  # Make a copy to avoid mutating the input\n    if \"time\" not in dynamics:\n        dynamics[\"time\"] = 1.0\n\n    # Extract byof dynamics for validation\n    byof_dynamics = byof.get(\"dynamics\", {}) if byof else {}\n\n    # Validate dynamics dict matches state names and dimensions\n    # byof_dynamics states should not be in symbolic dynamics dict\n    validate_dynamics_dict(dynamics, states, byof_dynamics=byof_dynamics)\n\n    # Inject zero placeholders for byof dynamics states\n    # These will be replaced with the actual byof functions at lowering time\n    for state in states:\n        if state.name in byof_dynamics:\n            dynamics[state.name] = Constant(np.zeros(state.shape))\n\n    # Validate dynamics dimensions AFTER injecting placeholders\n    validate_dynamics_dict_dimensions(dynamics, states)\n\n    # Convert dynamics dict to concatenated expression\n    dynamics, dynamics_concat = convert_dynamics_dict_to_expr(dynamics, states)\n\n    # ==================== PHASE 2: Expression Validation ====================\n\n    # Validate all expressions (use unsorted constraints)\n    all_exprs = [dynamics_concat] + constraints.unsorted\n    validate_variable_names(all_exprs)\n    collect_and_assign_slices(states, controls)\n    validate_shapes(all_exprs)\n    validate_constraints_at_root(constraints.unsorted)\n    validate_and_normalize_constraint_nodes(constraints.unsorted, N)\n    validate_dynamics_dimension(dynamics_concat, states)\n\n    # ==================== PHASE 3: Canonicalization &amp; Parameter Collection ====================\n\n    # Canonicalize all expressions after validation\n    dynamics_concat = dynamics_concat.canonicalize()\n    constraints.unsorted = [expr.canonicalize() for expr in constraints.unsorted]\n\n    # Collect parameter values from all constraints and dynamics\n    parameters = {}\n\n    def collect_param_values(expr):\n        if isinstance(expr, Parameter):\n            if expr.name not in parameters:\n                parameters[expr.name] = expr.value\n\n    # Collect from dynamics\n    traverse(dynamics_concat, collect_param_values)\n\n    # Collect from constraints\n    for constraint in constraints.unsorted:\n        traverse(constraint, collect_param_values)\n\n    # ==================== PHASE 4: Constraint Separation &amp; Augmentation ====================\n\n    # Sort and separate constraints by type (drains unsorted -&gt; fills categories)\n    separate_constraints(constraints, N)\n\n    # Decompose vector-valued nodal constraints into scalar constraints\n    # This is necessary for non-convex nodal constraints that get lowered to JAX\n    constraints.nodal = decompose_vector_nodal_constraints(constraints.nodal)\n\n    # Sort CTCS constraints by their idx to get node_intervals\n    constraints.ctcs, node_intervals, _ = sort_ctcs_constraints(constraints.ctcs)\n\n    # Augment dynamics, states, and controls with CTCS constraints, time dilation\n    dynamics_aug, states_aug, controls_aug = augment_dynamics_with_ctcs(\n        dynamics_concat,\n        states,\n        controls,\n        constraints.ctcs,\n        N,\n        licq_min=licq_min,\n        licq_max=licq_max,\n        time_dilation_factor_min=time_dilation_factor_min,\n        time_dilation_factor_max=time_dilation_factor_max,\n    )\n\n    # Assign slices to augmented states and controls in canonical order\n    collect_and_assign_slices(states_aug, controls_aug)\n\n    # ==================== PHASE 5: Create Propagation Dynamics ====================\n\n    # By default, propagation dynamics are the same as optimization dynamics\n    # Use deepcopy to avoid reference issues when lowering\n    from copy import deepcopy\n\n    dynamics_prop = deepcopy(dynamics_aug)\n    states_prop = list(states_aug)  # Shallow copy of list is fine for states\n    controls_prop = list(controls_aug)\n\n    # If user provided extra propagation states, extend propagation dynamics\n    if dynamics_prop_extra is not None and states_prop_extra is not None:\n        (\n            dynamics_prop,\n            states_prop,\n            controls_prop,\n            parameters,\n        ) = add_propagation_states(\n            dynamics_extra=dynamics_prop_extra,\n            states_extra=states_prop_extra,\n            dynamics_opt=dynamics_prop,\n            states_opt=states_prop,\n            controls_opt=controls_prop,\n            parameters=parameters,\n        )\n\n    # ==================== PHASE 6: Process Algebraic Outputs ====================\n\n    # Validate and canonicalize algebraic_prop expressions\n    algebraic_prop_processed = None\n    if algebraic_prop is not None:\n        algebraic_prop_processed = {}\n        for name, expr in algebraic_prop.items():\n            # Validate shape inference works\n            validate_shapes([expr])\n\n            # Canonicalize the expression\n            expr_canonical = expr.canonicalize()\n\n            # Collect any parameter values from output expressions\n            def collect_param_values(e):\n                if isinstance(e, Parameter):\n                    if e.name not in parameters:\n                        parameters[e.name] = e.value\n\n            traverse(expr_canonical, collect_param_values)\n\n            algebraic_prop_processed[name] = expr_canonical\n\n    # ==================== Return SymbolicProblem ====================\n\n    return SymbolicProblem(\n        dynamics=dynamics_aug,\n        states=states_aug,\n        controls=controls_aug,\n        constraints=constraints,\n        parameters=parameters,\n        N=N,\n        node_intervals=node_intervals,\n        dynamics_prop=dynamics_prop,\n        states_prop=states_prop,\n        controls_prop=controls_prop,\n        algebraic_prop=algebraic_prop_processed,\n    )\n</code></pre>"},{"location":"reference/symbolic/constraint_set/","title":"constraint_set","text":"<p>Container for categorized symbolic constraints.</p> <p>This module provides a dataclass to hold all symbolic constraint types in a structured way before they are lowered to JAX/CVXPy.</p>"},{"location":"reference/symbolic/constraint_set/#openscvx.symbolic.constraint_set.ConstraintSet","title":"<code>ConstraintSet</code>  <code>dataclass</code>","text":"<p>Container for categorized symbolic constraints.</p> <p>This dataclass holds all symbolic constraint types in a structured way, providing type safety and a clear API for accessing constraint categories. This is a pre-lowering container - after lowering, constraints live in LoweredJaxConstraints and LoweredCvxpyConstraints.</p> <p>The constraint set supports two lifecycle stages:</p> <ol> <li>Before preprocessing: Raw constraints live in <code>unsorted</code></li> <li>After preprocessing: <code>unsorted</code> is empty, constraints are categorized</li> </ol> <p>Use <code>is_categorized</code> to check which stage the constraint set is in.</p> <p>Attributes:</p> Name Type Description <code>unsorted</code> <code>List[Union[Constraint, CTCS]]</code> <p>Raw constraints before categorization. Empty after preprocessing.</p> <code>ctcs</code> <code>List[CTCS]</code> <p>CTCS (continuous-time) constraints.</p> <code>nodal</code> <code>List[NodalConstraint]</code> <p>Non-convex nodal constraints (will be lowered to JAX).</p> <code>nodal_convex</code> <code>List[NodalConstraint]</code> <p>Convex nodal constraints (will be lowered to CVXPy).</p> <code>cross_node</code> <code>List[CrossNodeConstraint]</code> <p>Non-convex cross-node constraints (will be lowered to JAX).</p> <code>cross_node_convex</code> <code>List[CrossNodeConstraint]</code> <p>Convex cross-node constraints (will be lowered to CVXPy).</p> Example <p>Before preprocessing (raw constraints)::</p> <pre><code>constraints = ConstraintSet(unsorted=[c1, c2, c3])\nassert not constraints.is_categorized\n</code></pre> <p>After preprocessing (categorized)::</p> <pre><code># preprocess_symbolic_problem drains unsorted -&gt; fills categories\nassert constraints.is_categorized\nfor c in constraints.nodal:\n    # Process non-convex nodal constraints\n    pass\n</code></pre> Source code in <code>openscvx/symbolic/constraint_set.py</code> <pre><code>@dataclass\nclass ConstraintSet:\n    \"\"\"Container for categorized symbolic constraints.\n\n    This dataclass holds all symbolic constraint types in a structured way,\n    providing type safety and a clear API for accessing constraint categories.\n    This is a pre-lowering container - after lowering, constraints live in\n    LoweredJaxConstraints and LoweredCvxpyConstraints.\n\n    The constraint set supports two lifecycle stages:\n\n    1. **Before preprocessing**: Raw constraints live in `unsorted`\n    2. **After preprocessing**: `unsorted` is empty, constraints are categorized\n\n    Use `is_categorized` to check which stage the constraint set is in.\n\n    Attributes:\n        unsorted: Raw constraints before categorization. Empty after preprocessing.\n        ctcs: CTCS (continuous-time) constraints.\n        nodal: Non-convex nodal constraints (will be lowered to JAX).\n        nodal_convex: Convex nodal constraints (will be lowered to CVXPy).\n        cross_node: Non-convex cross-node constraints (will be lowered to JAX).\n        cross_node_convex: Convex cross-node constraints (will be lowered to CVXPy).\n\n    Example:\n        Before preprocessing (raw constraints)::\n\n            constraints = ConstraintSet(unsorted=[c1, c2, c3])\n            assert not constraints.is_categorized\n\n        After preprocessing (categorized)::\n\n            # preprocess_symbolic_problem drains unsorted -&gt; fills categories\n            assert constraints.is_categorized\n            for c in constraints.nodal:\n                # Process non-convex nodal constraints\n                pass\n    \"\"\"\n\n    # Raw constraints before categorization (empty after preprocessing)\n    unsorted: List[Union[\"Constraint\", \"CTCS\"]] = field(default_factory=list)\n\n    # Categorized symbolic constraints (populated by preprocessing)\n    ctcs: List[\"CTCS\"] = field(default_factory=list)\n    nodal: List[\"NodalConstraint\"] = field(default_factory=list)\n    nodal_convex: List[\"NodalConstraint\"] = field(default_factory=list)\n    cross_node: List[\"CrossNodeConstraint\"] = field(default_factory=list)\n    cross_node_convex: List[\"CrossNodeConstraint\"] = field(default_factory=list)\n\n    @property\n    def is_categorized(self) -&gt; bool:\n        \"\"\"True if all constraints have been sorted into categories.\n\n        After preprocessing, `unsorted` should be empty and all constraints\n        should be in their appropriate category lists.\n        \"\"\"\n        return len(self.unsorted) == 0\n\n    def __bool__(self) -&gt; bool:\n        \"\"\"Return True if any constraint list is non-empty.\"\"\"\n        return bool(\n            self.unsorted\n            or self.ctcs\n            or self.nodal\n            or self.nodal_convex\n            or self.cross_node\n            or self.cross_node_convex\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return total number of constraints across all lists.\"\"\"\n        return (\n            len(self.unsorted)\n            + len(self.ctcs)\n            + len(self.nodal)\n            + len(self.nodal_convex)\n            + len(self.cross_node)\n            + len(self.cross_node_convex)\n        )\n</code></pre>"},{"location":"reference/symbolic/constraint_set/#openscvx.symbolic.constraint_set.ConstraintSet.is_categorized","title":"<code>is_categorized: bool</code>  <code>property</code>","text":"<p>True if all constraints have been sorted into categories.</p> <p>After preprocessing, <code>unsorted</code> should be empty and all constraints should be in their appropriate category lists.</p>"},{"location":"reference/symbolic/hashing/","title":"hashing","text":"<p>Structural hashing for symbolic problems.</p> <p>This module provides name-invariant hashing for symbolic optimization problems. Two problems with the same mathematical structure will produce the same hash, regardless of the variable names used.</p> <p>This enables efficient caching: if a problem has already been compiled with the same structure, the cached compiled artifacts can be reused.</p>"},{"location":"reference/symbolic/hashing/#openscvx.symbolic.hashing.hash_symbolic_problem","title":"<code>hash_symbolic_problem(problem: SymbolicProblem) -&gt; str</code>","text":"<p>Compute a structural hash of a symbolic optimization problem.</p> <p>This function computes a hash that depends only on the mathematical structure of the problem, not on variable names or runtime values. Two problems with the same: - Dynamics expressions (using _slice for canonical variable positions) - Constraints - State/control shapes and boundary condition types - Parameter shapes - Configuration (N, etc.)</p> <p>will produce the same hash, regardless of what names are used for variables.</p> <p>Notably, the following are NOT included in the hash (allowing solver reuse): - Boundary condition values (initial/final state values) - Bound values (min/max for states and controls) - Parameter values (only shapes are hashed)</p> <p>Parameters:</p> Name Type Description Default <code>problem</code> <code>SymbolicProblem</code> <p>A SymbolicProblem (should be preprocessed for best results,      so that _slice attributes are set on states/controls)</p> required <p>Returns:</p> Type Description <code>str</code> <p>A hex string representing the SHA-256 hash of the problem structure</p> Source code in <code>openscvx/symbolic/hashing.py</code> <pre><code>def hash_symbolic_problem(problem: \"SymbolicProblem\") -&gt; str:\n    \"\"\"Compute a structural hash of a symbolic optimization problem.\n\n    This function computes a hash that depends only on the mathematical structure\n    of the problem, not on variable names or runtime values. Two problems with the same:\n    - Dynamics expressions (using _slice for canonical variable positions)\n    - Constraints\n    - State/control shapes and boundary condition types\n    - Parameter shapes\n    - Configuration (N, etc.)\n\n    will produce the same hash, regardless of what names are used for variables.\n\n    Notably, the following are NOT included in the hash (allowing solver reuse):\n    - Boundary condition values (initial/final state values)\n    - Bound values (min/max for states and controls)\n    - Parameter values (only shapes are hashed)\n\n    Args:\n        problem: A SymbolicProblem (should be preprocessed for best results,\n                 so that _slice attributes are set on states/controls)\n\n    Returns:\n        A hex string representing the SHA-256 hash of the problem structure\n    \"\"\"\n    hasher = hashlib.sha256()\n\n    # Include library version to invalidate cache on version changes\n    hasher.update(f\"openscvx:{__version__}:\".encode())\n\n    # Hash the dynamics\n    hasher.update(b\"dynamics:\")\n    problem.dynamics._hash_into(hasher)\n\n    # Hash propagation dynamics if present\n    if problem.dynamics_prop is not None:\n        hasher.update(b\"dynamics_prop:\")\n        problem.dynamics_prop._hash_into(hasher)\n\n    # Hash all constraints (order-invariant within each category)\n    # We compute individual hashes and sort them so that the same set of\n    # constraints produces the same hash regardless of definition order.\n    hasher.update(b\"constraints:\")\n    for constraint_list in [\n        problem.constraints.ctcs,\n        problem.constraints.nodal,\n        problem.constraints.nodal_convex,\n        problem.constraints.cross_node,\n        problem.constraints.cross_node_convex,\n    ]:\n        # Compute individual hashes for each constraint\n        constraint_hashes = sorted(c.structural_hash() for c in constraint_list)\n        # Hash the count and sorted hashes\n        hasher.update(len(constraint_hashes).to_bytes(4, \"big\"))\n        for h in constraint_hashes:\n            hasher.update(h)\n\n    # Hash all states and controls explicitly to capture metadata (boundary\n    # condition types) that may not appear in expressions. For example, a state\n    # with dynamics dx/dt = 1.0 doesn't appear in the expression tree, but its\n    # boundary condition types still affect the compiled problem structure.\n    hasher.update(b\"states:\")\n    for state in problem.states:\n        state._hash_into(hasher)\n\n    hasher.update(b\"controls:\")\n    for control in problem.controls:\n        control._hash_into(hasher)\n\n    # Hash parameter shapes (not values) from the problem's parameter dict.\n    # This allows the same compiled solver to be reused across parameter sweeps -\n    # only the structure matters for compilation, not the actual values.\n    hasher.update(b\"parameters:\")\n    hasher.update(str(len(problem.parameters)).encode())  # Hash count for structure\n    for name in sorted(problem.parameters.keys()):\n        value = problem.parameters[name]\n        # Only hash shape, not name - maintains name-invariance\n        if isinstance(value, np.ndarray):\n            hasher.update(str(value.shape).encode())\n        else:\n            hasher.update(b\"scalar\")\n\n    # Hash configuration\n    hasher.update(f\"N:{problem.N}\".encode())\n\n    # Hash node intervals for CTCS\n    hasher.update(b\"node_intervals:\")\n    for interval in problem.node_intervals:\n        hasher.update(f\"{interval}\".encode())\n\n    return hasher.hexdigest()\n</code></pre>"},{"location":"reference/symbolic/lower/","title":"lower","text":"<p>Symbolic expression lowering to executable code.</p> <p>This module provides the main entry point for converting symbolic expressions (AST nodes) into executable code for different backends (JAX, CVXPy, etc.). The lowering process translates the symbolic expression tree into functions that can be executed during optimization.</p> Architecture <p>The lowering process follows a visitor pattern where each backend implements a lowerer class (e.g., JaxLowerer, CVXPyLowerer) with visitor methods for each expression type. The <code>lower()</code> function dispatches expression nodes to the appropriate backend.</p> <p>Lowering Flow:</p> <ol> <li>Symbolic expressions are built during problem specification</li> <li>lower_symbolic_expressions() coordinates the full lowering process</li> <li>Backend-specific lowerers convert each expression node to executable code</li> <li>Automatic differentiation creates Jacobians for dynamics and constraints</li> <li>Result is a set of executable functions ready for numerical optimization</li> </ol> Backends <ul> <li>JAX: For dynamics and non-convex constraints (with automatic differentiation)</li> <li>CVXPy: For convex constraints (with disciplined convex programming)</li> </ul> Example <p>Basic lowering to JAX::</p> <pre><code>import openscvx as ox\nfrom openscvx.symbolic.lower import lower_to_jax\n\n# Define symbolic expression\nx = ox.State(\"x\", shape=(3,))\nu = ox.Control(\"u\", shape=(2,))\nexpr = ox.Norm(x)**2 + 0.1 * ox.Norm(u)**2\n\n# Lower to JAX function\nf = lower_to_jax(expr)\n# f is now a callable: f(x_val, u_val, node, params) -&gt; scalar\n</code></pre> <p>Full problem lowering::</p> <pre><code># After building symbolic problem...\nlowered = lower_symbolic_problem(\n    dynamics_aug, states_aug, controls_aug,\n    constraints, parameters, N,\n    dynamics_prop, states_prop, controls_prop\n)\n# Access via LoweredProblem dataclass\ndynamics = lowered.dynamics\njax_constraints = lowered.jax_constraints\n# Now have executable JAX functions with Jacobians\n</code></pre>"},{"location":"reference/symbolic/lower/#openscvx.symbolic.lower.create_cvxpy_variables","title":"<code>create_cvxpy_variables(N: int, n_states: int, n_controls: int, S_x: np.ndarray, c_x: np.ndarray, S_u: np.ndarray, c_u: np.ndarray, n_nodal_constraints: int, n_cross_node_constraints: int) -&gt; CVXPyVariables</code>","text":"<p>Create CVXPy variables and parameters for the optimal control problem.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Number of discretization nodes</p> required <code>n_states</code> <code>int</code> <p>Number of state variables</p> required <code>n_controls</code> <code>int</code> <p>Number of control variables</p> required <code>S_x</code> <code>ndarray</code> <p>State scaling matrix</p> required <code>c_x</code> <code>ndarray</code> <p>State offset vector</p> required <code>S_u</code> <code>ndarray</code> <p>Control scaling matrix</p> required <code>c_u</code> <code>ndarray</code> <p>Control offset vector</p> required <code>n_nodal_constraints</code> <code>int</code> <p>Number of non-convex nodal constraints (for linearization params)</p> required <code>n_cross_node_constraints</code> <code>int</code> <p>Number of non-convex cross-node constraints</p> required <p>Returns:</p> Type Description <code>CVXPyVariables</code> <p>CVXPyVariables dataclass containing all CVXPy variables and parameters for the OCP</p> Source code in <code>openscvx/symbolic/lower.py</code> <pre><code>def create_cvxpy_variables(\n    N: int,\n    n_states: int,\n    n_controls: int,\n    S_x: np.ndarray,\n    c_x: np.ndarray,\n    S_u: np.ndarray,\n    c_u: np.ndarray,\n    n_nodal_constraints: int,\n    n_cross_node_constraints: int,\n) -&gt; CVXPyVariables:\n    \"\"\"Create CVXPy variables and parameters for the optimal control problem.\n\n    Args:\n        N: Number of discretization nodes\n        n_states: Number of state variables\n        n_controls: Number of control variables\n        S_x: State scaling matrix\n        c_x: State offset vector\n        S_u: Control scaling matrix\n        c_u: Control offset vector\n        n_nodal_constraints: Number of non-convex nodal constraints (for linearization params)\n        n_cross_node_constraints: Number of non-convex cross-node constraints\n\n    Returns:\n        CVXPyVariables dataclass containing all CVXPy variables and parameters for the OCP\n    \"\"\"\n    ########################\n    # VARIABLES &amp; PARAMETERS\n    ########################\n\n    inv_S_x = np.linalg.inv(S_x)\n    inv_S_u = np.linalg.inv(S_u)\n\n    # Parameters\n    w_tr = cp.Parameter(nonneg=True, name=\"w_tr\")\n    lam_cost = cp.Parameter(nonneg=True, name=\"lam_cost\")\n    lam_vc = cp.Parameter((N - 1, n_states), nonneg=True, name=\"lam_vc\")\n    lam_vb = cp.Parameter(nonneg=True, name=\"lam_vb\")\n\n    # State\n    x = cp.Variable((N, n_states), name=\"x\")  # Current State\n    dx = cp.Variable((N, n_states), name=\"dx\")  # State Error\n    x_bar = cp.Parameter((N, n_states), name=\"x_bar\")  # Previous SCP State\n    x_init = cp.Parameter(n_states, name=\"x_init\")  # Initial State\n    x_term = cp.Parameter(n_states, name=\"x_term\")  # Final State\n\n    # Control\n    u = cp.Variable((N, n_controls), name=\"u\")  # Current Control\n    du = cp.Variable((N, n_controls), name=\"du\")  # Control Error\n    u_bar = cp.Parameter((N, n_controls), name=\"u_bar\")  # Previous SCP Control\n\n    # Discretized Augmented Dynamics Constraints\n    A_d = cp.Parameter((N - 1, n_states, n_states), name=\"A_d\")\n    B_d = cp.Parameter((N - 1, n_states, n_controls), name=\"B_d\")\n    C_d = cp.Parameter((N - 1, n_states, n_controls), name=\"C_d\")\n    x_prop = cp.Parameter((N - 1, n_states), name=\"x_prop\")\n    nu = cp.Variable((N - 1, n_states), name=\"nu\")  # Virtual Control\n\n    # Linearized Nonconvex Nodal Constraints\n    g = []\n    grad_g_x = []\n    grad_g_u = []\n    nu_vb = []\n    for idx_ncvx in range(n_nodal_constraints):\n        g.append(cp.Parameter(N, name=\"g_\" + str(idx_ncvx)))\n        grad_g_x.append(cp.Parameter((N, n_states), name=\"grad_g_x_\" + str(idx_ncvx)))\n        grad_g_u.append(cp.Parameter((N, n_controls), name=\"grad_g_u_\" + str(idx_ncvx)))\n        nu_vb.append(cp.Variable(N, name=\"nu_vb_\" + str(idx_ncvx)))  # Virtual Control for VB\n\n    # Linearized Cross-Node Constraints\n    g_cross = []\n    grad_g_X_cross = []\n    grad_g_U_cross = []\n    nu_vb_cross = []\n    for idx_cross in range(n_cross_node_constraints):\n        # Cross-node constraints are single constraints with fixed node references\n        g_cross.append(cp.Parameter(name=\"g_cross_\" + str(idx_cross)))\n        grad_g_X_cross.append(cp.Parameter((N, n_states), name=\"grad_g_X_cross_\" + str(idx_cross)))\n        grad_g_U_cross.append(\n            cp.Parameter((N, n_controls), name=\"grad_g_U_cross_\" + str(idx_cross))\n        )\n        nu_vb_cross.append(\n            cp.Variable(name=\"nu_vb_cross_\" + str(idx_cross))\n        )  # Virtual Control for VB\n\n    # Applying the affine scaling to state and control\n    x_nonscaled = []\n    u_nonscaled = []\n    dx_nonscaled = []\n    du_nonscaled = []\n    for k in range(N):\n        x_nonscaled.append(S_x @ x[k] + c_x)\n        u_nonscaled.append(S_u @ u[k] + c_u)\n        dx_nonscaled.append(S_x @ dx[k])\n        du_nonscaled.append(S_u @ du[k])\n\n    return CVXPyVariables(\n        w_tr=w_tr,\n        lam_cost=lam_cost,\n        lam_vc=lam_vc,\n        lam_vb=lam_vb,\n        x=x,\n        dx=dx,\n        x_bar=x_bar,\n        x_init=x_init,\n        x_term=x_term,\n        u=u,\n        du=du,\n        u_bar=u_bar,\n        A_d=A_d,\n        B_d=B_d,\n        C_d=C_d,\n        x_prop=x_prop,\n        nu=nu,\n        g=g,\n        grad_g_x=grad_g_x,\n        grad_g_u=grad_g_u,\n        nu_vb=nu_vb,\n        g_cross=g_cross,\n        grad_g_X_cross=grad_g_X_cross,\n        grad_g_U_cross=grad_g_U_cross,\n        nu_vb_cross=nu_vb_cross,\n        S_x=S_x,\n        inv_S_x=inv_S_x,\n        c_x=c_x,\n        S_u=S_u,\n        inv_S_u=inv_S_u,\n        c_u=c_u,\n        x_nonscaled=x_nonscaled,\n        u_nonscaled=u_nonscaled,\n        dx_nonscaled=dx_nonscaled,\n        du_nonscaled=du_nonscaled,\n    )\n</code></pre>"},{"location":"reference/symbolic/lower/#openscvx.symbolic.lower.lower","title":"<code>lower(expr: Expr, lowerer: Any)</code>","text":"<p>Dispatch an expression node to the appropriate lowerer backend.</p> <p>This is the main entry point for lowering a single symbolic expression to executable code. It delegates to the lowerer's <code>lower()</code> method, which uses the visitor pattern to dispatch based on expression type.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Symbolic expression to lower (any Expr subclass)</p> required <code>lowerer</code> <code>Any</code> <p>Backend lowerer instance (e.g., JaxLowerer, CVXPyLowerer)</p> required <p>Returns:</p> Type Description <p>Backend-specific representation of the expression. For JaxLowerer,</p> <p>returns a callable with signature (x, u, node, params) -&gt; result.</p> <p>For CVXPyLowerer, returns a CVXPy expression object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the lowerer doesn't support the expression type</p> Example <p>Lower an expression to the appropriate backend (here JAX):</p> <pre><code>from openscvx.symbolic.lowerers.jax import JaxLowerer\nx = ox.State(\"x\", shape=(3,))\nexpr = ox.Norm(x)\nlowerer = JaxLowerer()\nf = lower(expr, lowerer)\n</code></pre> <p>f is now callable: f(x_val, u_val, node, params) -&gt; scalar</p> Source code in <code>openscvx/symbolic/lower.py</code> <pre><code>def lower(expr: Expr, lowerer: Any):\n    \"\"\"Dispatch an expression node to the appropriate lowerer backend.\n\n    This is the main entry point for lowering a single symbolic expression to\n    executable code. It delegates to the lowerer's `lower()` method, which\n    uses the visitor pattern to dispatch based on expression type.\n\n    Args:\n        expr: Symbolic expression to lower (any Expr subclass)\n        lowerer: Backend lowerer instance (e.g., JaxLowerer, CVXPyLowerer)\n\n    Returns:\n        Backend-specific representation of the expression. For JaxLowerer,\n        returns a callable with signature (x, u, node, params) -&gt; result.\n        For CVXPyLowerer, returns a CVXPy expression object.\n\n    Raises:\n        NotImplementedError: If the lowerer doesn't support the expression type\n\n    Example:\n        Lower an expression to the appropriate backend (here JAX):\n\n            from openscvx.symbolic.lowerers.jax import JaxLowerer\n            x = ox.State(\"x\", shape=(3,))\n            expr = ox.Norm(x)\n            lowerer = JaxLowerer()\n            f = lower(expr, lowerer)\n\n        f is now callable: f(x_val, u_val, node, params) -&gt; scalar\n    \"\"\"\n    return lowerer.lower(expr)\n</code></pre>"},{"location":"reference/symbolic/lower/#openscvx.symbolic.lower.lower_cvxpy_constraints","title":"<code>lower_cvxpy_constraints(constraints: ConstraintSet, x_cvxpy: List, u_cvxpy: List, parameters: dict = None) -&gt; Tuple[List, dict]</code>","text":"<p>Lower symbolic convex constraints to CVXPy constraints.</p> <p>Converts symbolic convex constraint expressions to CVXPy constraint objects that can be used in the optimal control problem. This function handles both nodal constraints (applied at specific trajectory nodes) and cross-node constraints (relating multiple nodes).</p> <p>Parameters:</p> Name Type Description Default <code>constraints</code> <code>ConstraintSet</code> <p>ConstraintSet containing nodal_convex and cross_node_convex</p> required <code>x_cvxpy</code> <code>List</code> <p>List of CVXPy expressions for state at each node (length N). Typically the x_nonscaled list from create_cvxpy_variables().</p> required <code>u_cvxpy</code> <code>List</code> <p>List of CVXPy expressions for control at each node (length N). Typically the u_nonscaled list from create_cvxpy_variables().</p> required <code>parameters</code> <code>dict</code> <p>Optional dict of parameter values to use for any Parameter expressions in the constraints. If None, uses Parameter default values.</p> <code>None</code> <p>Returns:</p> Type Description <code>List</code> <p>Tuple of:</p> <code>dict</code> <ul> <li>List of CVXPy constraint objects ready for the OCP</li> </ul> <code>Tuple[List, dict]</code> <ul> <li>Dict mapping parameter names to their CVXPy Parameter objects</li> </ul> Example <p>After creating CVXPy variables::</p> <pre><code>ocp_vars = create_cvxpy_variables(settings)\ncvxpy_constraints, cvxpy_params = lower_cvxpy_constraints(\n    constraint_set,\n    ocp_vars.x_nonscaled,\n    ocp_vars.u_nonscaled,\n    parameters,\n)\n</code></pre> Note <p>This function only processes convex constraints (nodal_convex and cross_node_convex). Non-convex constraints are lowered to JAX in lower_symbolic_expressions() and handled via linearization in the SCP.</p> Source code in <code>openscvx/symbolic/lower.py</code> <pre><code>def lower_cvxpy_constraints(\n    constraints: ConstraintSet,\n    x_cvxpy: List,\n    u_cvxpy: List,\n    parameters: dict = None,\n) -&gt; Tuple[List, dict]:\n    \"\"\"Lower symbolic convex constraints to CVXPy constraints.\n\n    Converts symbolic convex constraint expressions to CVXPy constraint objects\n    that can be used in the optimal control problem. This function handles both\n    nodal constraints (applied at specific trajectory nodes) and cross-node\n    constraints (relating multiple nodes).\n\n    Args:\n        constraints: ConstraintSet containing nodal_convex and cross_node_convex\n        x_cvxpy: List of CVXPy expressions for state at each node (length N).\n            Typically the x_nonscaled list from create_cvxpy_variables().\n        u_cvxpy: List of CVXPy expressions for control at each node (length N).\n            Typically the u_nonscaled list from create_cvxpy_variables().\n        parameters: Optional dict of parameter values to use for any Parameter\n            expressions in the constraints. If None, uses Parameter default values.\n\n    Returns:\n        Tuple of:\n        - List of CVXPy constraint objects ready for the OCP\n        - Dict mapping parameter names to their CVXPy Parameter objects\n\n    Example:\n        After creating CVXPy variables::\n\n            ocp_vars = create_cvxpy_variables(settings)\n            cvxpy_constraints, cvxpy_params = lower_cvxpy_constraints(\n                constraint_set,\n                ocp_vars.x_nonscaled,\n                ocp_vars.u_nonscaled,\n                parameters,\n            )\n\n    Note:\n        This function only processes convex constraints (nodal_convex and\n        cross_node_convex). Non-convex constraints are lowered to JAX in\n        lower_symbolic_expressions() and handled via linearization in the SCP.\n    \"\"\"\n    import cvxpy as cp\n\n    from openscvx.symbolic.expr import Parameter, traverse\n    from openscvx.symbolic.expr.control import Control\n    from openscvx.symbolic.expr.state import State\n    from openscvx.symbolic.lowerers.cvxpy import lower_to_cvxpy\n\n    all_constraints = list(constraints.nodal_convex) + list(constraints.cross_node_convex)\n\n    if not all_constraints:\n        return [], {}\n\n    # Collect all unique Parameters across all constraints and create cp.Parameter objects\n    all_params = {}\n\n    def collect_params(expr):\n        if isinstance(expr, Parameter):\n            if expr.name not in all_params:\n                # Use value from params dict if provided, otherwise use Parameter's initial value\n                if parameters and expr.name in parameters:\n                    param_value = parameters[expr.name]\n                else:\n                    param_value = expr.value\n\n                cvx_param = cp.Parameter(expr.shape, value=param_value, name=expr.name)\n                all_params[expr.name] = cvx_param\n\n    # Collect all parameters from all constraints\n    for constraint in all_constraints:\n        traverse(constraint.constraint, collect_params)\n\n    cvxpy_constraints = []\n\n    # Process nodal constraints\n    for constraint in constraints.nodal_convex:\n        # nodes should already be validated and normalized in preprocessing\n        nodes = constraint.nodes\n\n        # Collect all State and Control variables referenced in the constraint\n        state_vars = {}\n        control_vars = {}\n\n        def collect_vars(expr):\n            if isinstance(expr, State):\n                state_vars[expr.name] = expr\n            elif isinstance(expr, Control):\n                control_vars[expr.name] = expr\n\n        traverse(constraint.constraint, collect_vars)\n\n        # Regular nodal constraint: apply at each specified node\n        for node in nodes:\n            # Create variable map for this specific node\n            variable_map = {}\n\n            if state_vars:\n                variable_map[\"x\"] = x_cvxpy[node]\n\n            if control_vars:\n                variable_map[\"u\"] = u_cvxpy[node]\n\n            # Add all CVXPy Parameter objects to the variable map\n            variable_map.update(all_params)\n\n            # Verify all variables have slices (should be guaranteed by preprocessing)\n            for state_name, state_var in state_vars.items():\n                if state_var._slice is None:\n                    raise ValueError(\n                        f\"State variable '{state_name}' has no slice assigned. \"\n                        f\"This indicates a bug in the preprocessing pipeline.\"\n                    )\n\n            for control_name, control_var in control_vars.items():\n                if control_var._slice is None:\n                    raise ValueError(\n                        f\"Control variable '{control_name}' has no slice assigned. \"\n                        f\"This indicates a bug in the preprocessing pipeline.\"\n                    )\n\n            # Lower the constraint to CVXPy\n            cvxpy_constraint = lower_to_cvxpy(constraint.constraint, variable_map)\n            cvxpy_constraints.append(cvxpy_constraint)\n\n    # Process cross-node constraints\n    for constraint in constraints.cross_node_convex:\n        # Collect all State and Control variables referenced in the constraint\n        state_vars = {}\n        control_vars = {}\n\n        def collect_vars(expr):\n            if isinstance(expr, State):\n                state_vars[expr.name] = expr\n            elif isinstance(expr, Control):\n                control_vars[expr.name] = expr\n\n        traverse(constraint.constraint, collect_vars)\n\n        # Cross-node constraint: provide full trajectory\n        variable_map = {}\n\n        # Stack all nodes into (N, n_x) and (N, n_u) matrices\n        if state_vars:\n            variable_map[\"x\"] = cp.vstack(x_cvxpy)\n\n        if control_vars:\n            variable_map[\"u\"] = cp.vstack(u_cvxpy)\n\n        # Add all CVXPy Parameter objects to the variable map\n        variable_map.update(all_params)\n\n        # Verify all variables have slices\n        for state_name, state_var in state_vars.items():\n            if state_var._slice is None:\n                raise ValueError(\n                    f\"State variable '{state_name}' has no slice assigned. \"\n                    f\"This indicates a bug in the preprocessing pipeline.\"\n                )\n\n        for control_name, control_var in control_vars.items():\n            if control_var._slice is None:\n                raise ValueError(\n                    f\"Control variable '{control_name}' has no slice assigned. \"\n                    f\"This indicates a bug in the preprocessing pipeline.\"\n                )\n\n        # Lower the constraint once - NodeReference handles node indexing internally\n        cvxpy_constraint = lower_to_cvxpy(constraint.constraint, variable_map)\n        cvxpy_constraints.append(cvxpy_constraint)\n\n    return cvxpy_constraints, all_params\n</code></pre>"},{"location":"reference/symbolic/lower/#openscvx.symbolic.lower.lower_symbolic_problem","title":"<code>lower_symbolic_problem(problem: SymbolicProblem, byof: Optional[dict] = None) -&gt; LoweredProblem</code>","text":"<p>Lower symbolic problem specification to executable JAX and CVXPy code.</p> <p>This is the main orchestrator for converting a preprocessed SymbolicProblem into executable numerical code. It coordinates the lowering of dynamics, constraints, and state/control interfaces from symbolic AST representations to JAX functions (with automatic differentiation) and CVXPy constraints.</p> <p>This is pure translation - no validation, shape checking, or augmentation occurs here. The input problem must be preprocessed (problem.is_preprocessed == True).</p> <p>Parameters:</p> Name Type Description Default <code>problem</code> <code>SymbolicProblem</code> <p>Preprocessed SymbolicProblem from preprocess_symbolic_problem(). Must have is_preprocessed == True.</p> required <code>byof</code> <code>Optional[dict]</code> <p>Optional dict of raw JAX functions for expert users. Supported keys: - \"nodal_constraints\": List of f(x, u, node, params) -&gt; residual - \"cross_nodal_constraints\": List of f(X, U, params) -&gt; residual - \"ctcs_constraints\": List of dicts with \"constraint_fn\", \"penalty\", \"bounds\"</p> <code>None</code> <p>Returns:</p> Type Description <code>LoweredProblem</code> <p>LoweredProblem dataclass containing lowered problem</p> Example <p>After preprocessing::</p> <pre><code>problem = preprocess_symbolic_problem(...)\nlowered = lower_symbolic_problem(problem)\n\n# Access dynamics\ndx = lowered.dynamics.f(x_val, u_val, node=0, params={...})\n\n# Use CVXPy objects for OCP\nocp = OptimalControlProblem(settings, lowered)\n</code></pre> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If problem.is_preprocessed is False</p> Source code in <code>openscvx/symbolic/lower.py</code> <pre><code>def lower_symbolic_problem(\n    problem: \"SymbolicProblem\", byof: Optional[dict] = None\n) -&gt; LoweredProblem:\n    \"\"\"Lower symbolic problem specification to executable JAX and CVXPy code.\n\n    This is the main orchestrator for converting a preprocessed SymbolicProblem\n    into executable numerical code. It coordinates the lowering of dynamics,\n    constraints, and state/control interfaces from symbolic AST representations\n    to JAX functions (with automatic differentiation) and CVXPy constraints.\n\n    This is pure translation - no validation, shape checking, or augmentation occurs\n    here. The input problem must be preprocessed (problem.is_preprocessed == True).\n\n    Args:\n        problem: Preprocessed SymbolicProblem from preprocess_symbolic_problem().\n            Must have is_preprocessed == True.\n        byof: Optional dict of raw JAX functions for expert users. Supported keys:\n            - \"nodal_constraints\": List of f(x, u, node, params) -&gt; residual\n            - \"cross_nodal_constraints\": List of f(X, U, params) -&gt; residual\n            - \"ctcs_constraints\": List of dicts with \"constraint_fn\", \"penalty\", \"bounds\"\n\n    Returns:\n        LoweredProblem dataclass containing lowered problem\n\n    Example:\n        After preprocessing::\n\n            problem = preprocess_symbolic_problem(...)\n            lowered = lower_symbolic_problem(problem)\n\n            # Access dynamics\n            dx = lowered.dynamics.f(x_val, u_val, node=0, params={...})\n\n            # Use CVXPy objects for OCP\n            ocp = OptimalControlProblem(settings, lowered)\n\n    Raises:\n        AssertionError: If problem.is_preprocessed is False\n    \"\"\"\n    assert problem.is_preprocessed, \"Problem must be preprocessed before lowering\"\n\n    # Create unified state/control interfaces\n    x_unified = unify_states(problem.states, name=\"x\")\n    u_unified = unify_controls(problem.controls)\n    x_prop_unified = unify_states(problem.states_prop, name=\"x_prop\")\n\n    # Lower dynamics to JAX\n    dynamics = _lower_dynamics(problem.dynamics)\n    dynamics_prop = _lower_dynamics(problem.dynamics_prop)\n\n    # Lower non-convex constraints to JAX\n    jax_constraints = _lower_jax_constraints(problem.constraints)\n\n    # Handle byof (bring-your-own-functions) for expert users\n    # This must happen BEFORE CVXPy variable creation since CTCS constraints\n    # augment the state dimension\n    if byof is not None:\n        dynamics, dynamics_prop, jax_constraints, x_unified, x_prop_unified = apply_byof(\n            byof,\n            dynamics,\n            dynamics_prop,\n            jax_constraints,\n            x_unified,\n            x_prop_unified,\n            u_unified,\n            problem.states,\n            problem.states_prop,\n            problem.N,\n        )\n\n    # Create CVXPy variables and lower convex constraints\n    ocp_vars, cvxpy_constraints, cvxpy_params = _lower_cvxpy(\n        problem.constraints, problem.parameters, problem.N, x_unified, u_unified, jax_constraints\n    )\n\n    # Lower algebraic outputs to vmapped JAX functions\n    algebraic_prop_lowered = {}\n    if problem.algebraic_prop:\n        for name, expr in problem.algebraic_prop.items():\n            # Lower expression to JAX function: f(x, u, node, params) -&gt; output\n            output_fn = lower_to_jax(expr)\n            # Vmap over time axis: (T, n_x), (T, n_u) -&gt; (T, output_dim)\n            output_fn_vmapped = jax.vmap(output_fn, in_axes=(0, 0, None, None))\n            algebraic_prop_lowered[name] = output_fn_vmapped\n\n    return LoweredProblem(\n        dynamics=dynamics,\n        dynamics_prop=dynamics_prop,\n        jax_constraints=jax_constraints,\n        cvxpy_constraints=cvxpy_constraints,\n        x_unified=x_unified,\n        u_unified=u_unified,\n        x_prop_unified=x_prop_unified,\n        ocp_vars=ocp_vars,\n        cvxpy_params=cvxpy_params,\n        algebraic_prop=algebraic_prop_lowered,\n    )\n</code></pre>"},{"location":"reference/symbolic/lower/#openscvx.symbolic.lower.lower_to_jax","title":"<code>lower_to_jax(exprs: Union[Expr, Sequence[Expr]]) -&gt; Union[callable, list[callable]]</code>","text":"<p>Lower symbolic expression(s) to JAX callable(s).</p> <p>Convenience wrapper that creates a JaxLowerer and lowers one or more symbolic expressions to JAX functions. The resulting functions can be JIT-compiled and automatically differentiated.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>Union[Expr, Sequence[Expr]]</code> <p>Single expression or sequence of expressions to lower</p> required <p>Returns:</p> Type Description <code>Union[callable, list[callable]]</code> <ul> <li>If exprs is a single Expr: Returns a single callable with signature (x, u, node, params) -&gt; array</li> </ul> <code>Union[callable, list[callable]]</code> <ul> <li>If exprs is a sequence: Returns a list of callables with the same signature</li> </ul> Example <p>Single expression::</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nexpr = ox.Norm(x)**2\nf = lower_to_jax(expr)\n# f(x_val, u_val, node_idx, params_dict) -&gt; scalar\n</code></pre> <p>Multiple expressions::</p> <pre><code>exprs = [ox.Norm(x), ox.Norm(u), x @ A @ x]\nfns = lower_to_jax(exprs)\n# fns is [f1, f2, f3], each with same signature\n</code></pre> Note <p>All returned JAX functions have a uniform signature (x, u, node, params) regardless of whether they use all arguments. This standardization simplifies vectorization and differentiation.</p> Source code in <code>openscvx/symbolic/lower.py</code> <pre><code>def lower_to_jax(exprs: Union[Expr, Sequence[Expr]]) -&gt; Union[callable, list[callable]]:\n    \"\"\"Lower symbolic expression(s) to JAX callable(s).\n\n    Convenience wrapper that creates a JaxLowerer and lowers one or more\n    symbolic expressions to JAX functions. The resulting functions can be\n    JIT-compiled and automatically differentiated.\n\n    Args:\n        exprs: Single expression or sequence of expressions to lower\n\n    Returns:\n        - If exprs is a single Expr: Returns a single callable with signature\n          (x, u, node, params) -&gt; array\n        - If exprs is a sequence: Returns a list of callables with the same signature\n\n    Example:\n        Single expression::\n\n            x = ox.State(\"x\", shape=(3,))\n            expr = ox.Norm(x)**2\n            f = lower_to_jax(expr)\n            # f(x_val, u_val, node_idx, params_dict) -&gt; scalar\n\n        Multiple expressions::\n\n            exprs = [ox.Norm(x), ox.Norm(u), x @ A @ x]\n            fns = lower_to_jax(exprs)\n            # fns is [f1, f2, f3], each with same signature\n\n    Note:\n        All returned JAX functions have a uniform signature\n        (x, u, node, params) regardless of whether they use all arguments.\n        This standardization simplifies vectorization and differentiation.\n    \"\"\"\n    from openscvx.symbolic.lowerers.jax import JaxLowerer\n\n    jl = JaxLowerer()\n    if isinstance(exprs, Expr):\n        return lower(exprs, jl)\n    fns = [lower(e, jl) for e in exprs]\n    return fns\n</code></pre>"},{"location":"reference/symbolic/preprocessing/","title":"preprocessing","text":"<p>Validation and preprocessing utilities for symbolic expressions.</p> <p>This module provides preprocessing and validation functions for symbolic expressions in trajectory optimization problems. These utilities ensure that expressions are well-formed and constraints are properly specified before compilation to solvers.</p> The preprocessing pipeline includes <ul> <li>Shape validation: Ensure all expressions have compatible shapes</li> <li>Variable name validation: Check for unique, non-reserved variable names</li> <li>Constraint validation: Verify constraints appear only at root level</li> <li>Dynamics validation: Check that dynamics match state dimensions</li> <li>Time parameter validation: Validate time configuration</li> <li>Slice assignment: Assign contiguous memory slices to variables</li> </ul> <p>These functions are typically called automatically during problem construction, but can also be used manually for debugging or custom problem setups.</p> Example <p>Validating expressions before problem construction::</p> <pre><code>import openscvx as ox\n\nx = ox.State(\"x\", shape=(3,))\nu = ox.Control(\"u\", shape=(2,))\n\n# Build dynamics and constraints\ndynamics = {\n    \"x\": u  # Will fail validation - dimension mismatch!\n}\n\n# Validate dimensions before creating problem\nfrom openscvx.symbolic.preprocessing import validate_dynamics_dict_dimensions\n\ntry:\n    validate_dynamics_dict_dimensions(dynamics, [x])\nexcept ValueError as e:\n    print(f\"Validation error: {e}\")\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.collect_and_assign_slices","title":"<code>collect_and_assign_slices(states: List[State], controls: List[Control], *, start_index: int = 0) -&gt; Tuple[list[State], list[Control]]</code>","text":"<p>Assign contiguous memory slices to states and controls.</p> <p>This function assigns slice objects to states and controls that determine their positions in the flat decision variable vector. Variables can have either: - Auto-assigned slices: Automatically assigned contiguously based on order - Manual slices: User-specified slices that must be contiguous and non-overlapping</p> <p>If any variables have manual slices, they must: - Start at index 0 (or start_index if specified) - Be contiguous and non-overlapping - Match the variable's flattened dimension</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>List[State]</code> <p>List of State objects in canonical order</p> required <code>controls</code> <code>List[Control]</code> <p>List of Control objects in canonical order</p> required <code>start_index</code> <code>int</code> <p>Starting index for slice assignment (default: 0)</p> <code>0</code> <p>Returns:</p> Type Description <code>Tuple[list[State], list[Control]]</code> <p>Tuple of (states, controls) with slice attributes assigned</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If manual slices are invalid (wrong size, overlapping, not starting at 0)</p> Example <p>x = ox.State(\"x\", shape=(3,)) u = ox.Control(\"u\", shape=(2,)) states, controls = collect_and_assign_slices([x], [u]) print(x._slice)  # slice(0, 3) print(u._slice)  # slice(0, 2)</p> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def collect_and_assign_slices(\n    states: List[State], controls: List[Control], *, start_index: int = 0\n) -&gt; Tuple[list[State], list[Control]]:\n    \"\"\"Assign contiguous memory slices to states and controls.\n\n    This function assigns slice objects to states and controls that determine their\n    positions in the flat decision variable vector. Variables can have either:\n    - Auto-assigned slices: Automatically assigned contiguously based on order\n    - Manual slices: User-specified slices that must be contiguous and non-overlapping\n\n    If any variables have manual slices, they must:\n    - Start at index 0 (or start_index if specified)\n    - Be contiguous and non-overlapping\n    - Match the variable's flattened dimension\n\n    Args:\n        states: List of State objects in canonical order\n        controls: List of Control objects in canonical order\n        start_index: Starting index for slice assignment (default: 0)\n\n    Returns:\n        Tuple of (states, controls) with slice attributes assigned\n\n    Raises:\n        ValueError: If manual slices are invalid (wrong size, overlapping, not starting at 0)\n\n    Example:\n            x = ox.State(\"x\", shape=(3,))\n            u = ox.Control(\"u\", shape=(2,))\n            states, controls = collect_and_assign_slices([x], [u])\n            print(x._slice)  # slice(0, 3)\n            print(u._slice)  # slice(0, 2)\n    \"\"\"\n\n    def assign(vars_list, start_index):\n        # split into manual vs auto\n        manual = [v for v in vars_list if v._slice is not None]\n        auto = [v for v in vars_list if v._slice is None]\n\n        if manual:\n            # 1) shape\u2010match check\n            for v in manual:\n                dim = int(np.prod(v.shape))\n                sl = v._slice\n                if (sl.stop - sl.start) != dim:\n                    raise ValueError(\n                        f\"Manual slice for {v.name!r} is length {sl.stop - sl.start}, \"\n                        f\"but variable has shape {v.shape} (dim {dim})\"\n                    )\n            # sort by the start of their slices\n            manual.sort(key=lambda v: v._slice.start)\n            # 2a) must start at 0\n            if manual[0]._slice.start != start_index:\n                raise ValueError(\"User-defined slices must start at index 0\")\n            # 2b) check contiguity &amp; no overlaps\n            cursor = start_index\n            for v in manual:\n                sl = v._slice\n                dim = int(np.prod(v.shape))\n                if sl.start != cursor or sl.stop != cursor + dim:\n                    raise ValueError(\n                        f\"Manual slice for {v.name!r} must be contiguous and non-overlapping\"\n                    )\n                cursor += dim\n            offset = cursor\n        else:\n            offset = start_index\n\n        # 3) auto-assign the rest\n        for v in auto:\n            dim = int(np.prod(v.shape))\n            v._slice = slice(offset, offset + dim)\n            offset += dim\n\n    # run separately on states (x) and controls (u)\n    assign(states, start_index)\n    assign(controls, start_index)\n\n    # Return the collected variables\n    return states, controls\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.convert_dynamics_dict_to_expr","title":"<code>convert_dynamics_dict_to_expr(dynamics: Dict[str, Expr], states: List[State]) -&gt; Tuple[Dict[str, Expr], Expr]</code>","text":"<p>Convert dynamics dictionary to concatenated expression in canonical order.</p> <p>Converts a dictionary-based dynamics specification to a single concatenated expression that represents the full ODE system x_dot = f(x, u, t). The dynamics are ordered according to the states list to ensure consistent variable ordering.</p> <p>This function also normalizes scalar values (int, float) to Constant expressions.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>Dict[str, Expr]</code> <p>Dictionary mapping state names to their dynamics expressions</p> required <code>states</code> <code>List[State]</code> <p>List of State objects defining the canonical order</p> required <p>Returns:</p> Type Description <code>Tuple[Dict[str, Expr], Expr]</code> <p>Tuple of: - Updated dynamics dictionary (with scalars converted to Constant expressions) - Concatenated dynamics expression ordered by states list</p> Example <p>Convert dynamics dict to a single expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(2,))\ndynamics_dict = {\"x\": x * 2, \"y\": 1.0}  # Scalar for y\nconverted_dict, concat_expr = convert_dynamics_dict_to_expr(\n    dynamics_dict, [x, y]\n)\n# converted_dict[\"y\"] is now Constant(1.0)\n# concat_expr is Concat(x * 2, Constant(1.0))\n</code></pre> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def convert_dynamics_dict_to_expr(\n    dynamics: Dict[str, Expr], states: List[State]\n) -&gt; Tuple[Dict[str, Expr], Expr]:\n    \"\"\"Convert dynamics dictionary to concatenated expression in canonical order.\n\n    Converts a dictionary-based dynamics specification to a single concatenated expression\n    that represents the full ODE system x_dot = f(x, u, t). The dynamics are ordered\n    according to the states list to ensure consistent variable ordering.\n\n    This function also normalizes scalar values (int, float) to Constant expressions.\n\n    Args:\n        dynamics: Dictionary mapping state names to their dynamics expressions\n        states: List of State objects defining the canonical order\n\n    Returns:\n        Tuple of:\n            - Updated dynamics dictionary (with scalars converted to Constant expressions)\n            - Concatenated dynamics expression ordered by states list\n\n    Example:\n        Convert dynamics dict to a single expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(2,))\n            dynamics_dict = {\"x\": x * 2, \"y\": 1.0}  # Scalar for y\n            converted_dict, concat_expr = convert_dynamics_dict_to_expr(\n                dynamics_dict, [x, y]\n            )\n            # converted_dict[\"y\"] is now Constant(1.0)\n            # concat_expr is Concat(x * 2, Constant(1.0))\n    \"\"\"\n    # Create a copy to avoid mutating the input\n    dynamics_converted = dict(dynamics)\n\n    # Convert scalar values to Constant expressions\n    for state_name, dyn_expr in dynamics_converted.items():\n        if isinstance(dyn_expr, (int, float)):\n            dynamics_converted[state_name] = Constant(dyn_expr)\n\n    # Create concatenated expression ordered by states list\n    dynamics_exprs = [dynamics_converted[state.name] for state in states]\n    dynamics_concat = Concat(*dynamics_exprs)\n\n    return dynamics_converted, dynamics_concat\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.fill_default_guesses","title":"<code>fill_default_guesses(states: List[State], N: int) -&gt; None</code>","text":"<p>Fill in default linspace guesses for states with guess=None.</p> <p>For states with both initial and final conditions set, generates a linear interpolation from initial to final values.</p> <p>This function modifies states in-place.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>List[State]</code> <p>List of State objects to fill guesses for</p> required <code>N</code> <code>int</code> <p>Number of discretization nodes</p> required Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def fill_default_guesses(states: List[State], N: int) -&gt; None:\n    \"\"\"Fill in default linspace guesses for states with guess=None.\n\n    For states with both initial and final conditions set, generates a linear\n    interpolation from initial to final values.\n\n    This function modifies states in-place.\n\n    Args:\n        states: List of State objects to fill guesses for\n        N: Number of discretization nodes\n    \"\"\"\n    for state in states:\n        if state.guess is None and state.initial is not None and state.final is not None:\n            # state.initial and state.final are already numpy arrays of values\n            # (the setter handles parsing tuples like (\"free\", value))\n            state.guess = np.linspace(state.initial, state.final, N)\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_and_normalize_constraint_nodes","title":"<code>validate_and_normalize_constraint_nodes(exprs: Union[Expr, list[Expr]], n_nodes: int)</code>","text":"<p>Validate and normalize constraint node specifications.</p> <p>This function validates and normalizes node specifications for constraint wrappers:</p> For NodalConstraint <ul> <li>nodes should be a list of specific node indices: [2, 4, 6, 8]</li> <li>Validates all nodes are within the valid range [0, n_nodes)</li> </ul> <p>For CTCS (Continuous-Time Constraint Satisfaction) constraints:     - nodes should be a tuple of (start, end): (0, 10)     - None is replaced with (0, n_nodes) to apply over entire trajectory     - Validation ensures tuple has exactly 2 elements and start &lt; end     - Validates indices are within trajectory bounds</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>Union[Expr, list[Expr]]</code> <p>Single expression or list of expressions to validate</p> required <code>n_nodes</code> <code>int</code> <p>Total number of nodes in the trajectory</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If node specifications are invalid (out of range, malformed, etc.)</p> Example <p>x = ox.State(\"x\", shape=(3,)) constraint = (x &lt;= 5).at([0, 10, 20])  # NodalConstraint validate_and_normalize_constraint_nodes([constraint], n_nodes=50)  # OK</p> <p>ctcs_constraint = (x &lt;= 5).over((0, 100))  # CTCS validate_and_normalize_constraint_nodes([ctcs_constraint], n_nodes=50)</p> <pre><code># Raises ValueError: Range exceeds trajectory length\n</code></pre> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_and_normalize_constraint_nodes(exprs: Union[Expr, list[Expr]], n_nodes: int):\n    \"\"\"Validate and normalize constraint node specifications.\n\n    This function validates and normalizes node specifications for constraint wrappers:\n\n    For NodalConstraint:\n        - nodes should be a list of specific node indices: [2, 4, 6, 8]\n        - Validates all nodes are within the valid range [0, n_nodes)\n\n    For CTCS (Continuous-Time Constraint Satisfaction) constraints:\n        - nodes should be a tuple of (start, end): (0, 10)\n        - None is replaced with (0, n_nodes) to apply over entire trajectory\n        - Validation ensures tuple has exactly 2 elements and start &lt; end\n        - Validates indices are within trajectory bounds\n\n    Args:\n        exprs: Single expression or list of expressions to validate\n        n_nodes: Total number of nodes in the trajectory\n\n    Raises:\n        ValueError: If node specifications are invalid (out of range, malformed, etc.)\n\n    Example:\n            x = ox.State(\"x\", shape=(3,))\n            constraint = (x &lt;= 5).at([0, 10, 20])  # NodalConstraint\n            validate_and_normalize_constraint_nodes([constraint], n_nodes=50)  # OK\n\n            ctcs_constraint = (x &lt;= 5).over((0, 100))  # CTCS\n            validate_and_normalize_constraint_nodes([ctcs_constraint], n_nodes=50)\n        # Raises ValueError: Range exceeds trajectory length\n    \"\"\"\n\n    # Normalize to list\n    expr_list = exprs if isinstance(exprs, (list, tuple)) else [exprs]\n\n    for expr in expr_list:\n        if isinstance(expr, CTCS):\n            # CTCS constraint validation (already done in __init__, but normalize None)\n            if expr.nodes is None:\n                expr.nodes = (0, n_nodes)\n            elif expr.nodes[0] &gt;= n_nodes or expr.nodes[1] &gt; n_nodes:\n                raise ValueError(\n                    f\"CTCS node range {expr.nodes} exceeds trajectory length {n_nodes}\"\n                )\n\n        elif isinstance(expr, NodalConstraint):\n            # NodalConstraint validation - nodes are already validated in __init__\n            # Just need to check they're within trajectory range\n            for node in expr.nodes:\n                if node &lt; 0 or node &gt;= n_nodes:\n                    raise ValueError(f\"NodalConstraint node {node} is out of range [0, {n_nodes})\")\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_boundary_conditions","title":"<code>validate_boundary_conditions(states: List[State]) -&gt; None</code>","text":"<p>Validate that all states have initial and final boundary conditions set.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>List[State]</code> <p>List of State objects to validate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any state is missing initial or final conditions</p> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_boundary_conditions(states: List[State]) -&gt; None:\n    \"\"\"Validate that all states have initial and final boundary conditions set.\n\n    Args:\n        states: List of State objects to validate\n\n    Raises:\n        ValueError: If any state is missing initial or final conditions\n    \"\"\"\n    for state in states:\n        if state.initial is None:\n            raise ValueError(\n                f\"State '{state.name}' is missing initial condition. \"\n                f\"Please set {state.name}.initial\"\n            )\n        if state.final is None:\n            raise ValueError(\n                f\"State '{state.name}' is missing final condition. Please set {state.name}.final\"\n            )\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_bounds","title":"<code>validate_bounds(variables: List[Variable]) -&gt; None</code>","text":"<p>Validate that all variables have min and max bounds set.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>List[Variable]</code> <p>List of Variable objects (State or Control) to validate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any variable is missing min or max bounds</p> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_bounds(variables: List[Variable]) -&gt; None:\n    \"\"\"Validate that all variables have min and max bounds set.\n\n    Args:\n        variables: List of Variable objects (State or Control) to validate\n\n    Raises:\n        ValueError: If any variable is missing min or max bounds\n    \"\"\"\n    for var in variables:\n        if var.min is None:\n            raise ValueError(\n                f\"Variable '{var.name}' is missing min bound. Please set {var.name}.min\"\n            )\n        if var.max is None:\n            raise ValueError(\n                f\"Variable '{var.name}' is missing max bound. Please set {var.name}.max\"\n            )\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_constraints_at_root","title":"<code>validate_constraints_at_root(exprs: Union[Expr, list[Expr]])</code>","text":"<p>Validate that constraints only appear at the root level of expression trees.</p> <p>Constraints and constraint wrappers (CTCS, NodalConstraint, CrossNodeConstraint) must only appear as top-level expressions, not nested within other expressions. However, constraints inside constraint wrappers are allowed (e.g., the constraint inside CTCS(x &lt;= 5)).</p> <p>This ensures constraints are properly processed during problem compilation and prevents ambiguous constraint specifications.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>Union[Expr, list[Expr]]</code> <p>Single expression or list of expressions to validate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any constraint or constraint wrapper is found at depth &gt; 0</p> Example <p>x = ox.State(\"x\", shape=(3,)) constraint = x &lt;= 5 validate_constraints_at_root([constraint])  # OK - constraint at root</p> <p>bad_expr = ox.Sum(x &lt;= 5)  # Constraint nested inside Sum validate_constraints_at_root([bad_expr])  # Raises ValueError</p> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_constraints_at_root(exprs: Union[Expr, list[Expr]]):\n    \"\"\"Validate that constraints only appear at the root level of expression trees.\n\n    Constraints and constraint wrappers (CTCS, NodalConstraint, CrossNodeConstraint)\n    must only appear as top-level expressions, not nested within other expressions.\n    However, constraints inside constraint wrappers are allowed (e.g., the constraint\n    inside CTCS(x &lt;= 5)).\n\n    This ensures constraints are properly processed during problem compilation and\n    prevents ambiguous constraint specifications.\n\n    Args:\n        exprs: Single expression or list of expressions to validate\n\n    Raises:\n        ValueError: If any constraint or constraint wrapper is found at depth &gt; 0\n\n    Example:\n            x = ox.State(\"x\", shape=(3,))\n            constraint = x &lt;= 5\n            validate_constraints_at_root([constraint])  # OK - constraint at root\n\n            bad_expr = ox.Sum(x &lt;= 5)  # Constraint nested inside Sum\n            validate_constraints_at_root([bad_expr])  # Raises ValueError\n    \"\"\"\n\n    # Define constraint wrappers that must also be at root level\n    CONSTRAINT_WRAPPERS = (CTCS, NodalConstraint, CrossNodeConstraint)\n\n    # normalize to list\n    expr_list = exprs if isinstance(exprs, (list, tuple)) else [exprs]\n\n    for expr in expr_list:\n\n        def visit(node: Expr, depth: int):\n            if depth &gt; 0:\n                if isinstance(node, CONSTRAINT_WRAPPERS):\n                    raise ValueError(\n                        f\"Nested constraint wrapper found at depth {depth!r}: {node!r}; \"\n                        \"constraint wrappers must only appear as top-level roots\"\n                    )\n                elif isinstance(node, Constraint):\n                    raise ValueError(\n                        f\"Nested Constraint found at depth {depth!r}: {node!r}; \"\n                        \"constraints must only appear as top-level roots\"\n                    )\n\n            # If this is a constraint wrapper, don't validate its children\n            # (we allow constraints inside constraint wrappers)\n            if isinstance(node, CONSTRAINT_WRAPPERS):\n                return  # Skip traversing children\n\n            # Otherwise, continue traversing children\n            for child in node.children():\n                visit(child, depth + 1)\n\n        # Start traversal\n        visit(expr, 0)\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_cross_node_constraint","title":"<code>validate_cross_node_constraint(cross_node_constraint, n_nodes: int) -&gt; None</code>","text":"<p>Validate cross-node constraint bounds and variable consistency.</p> <p>This function performs two validations in a single tree traversal:</p> <ol> <li> <p>Bounds checking: Ensures all NodeReference indices are within [0, n_nodes).    Cross-node constraints reference fixed trajectory nodes (e.g., position.at(5)),    and this validates those indices are valid. Negative indices are normalized    (e.g., -1 becomes n_nodes-1) before checking.</p> </li> <li> <p>Variable consistency: Ensures that if ANY variable uses .at(), then ALL    state/control variables must use .at(). Mixing causes shape mismatches during    lowering because:</p> </li> <li>Variables with .at(k) extract single-node values: X[k, :] \u2192 shape (n_x,)</li> <li>Variables without .at() expect full trajectory: X[:, :] \u2192 shape (N, n_x)</li> </ol> <p>Parameters:</p> Name Type Description Default <code>cross_node_constraint</code> <p>The CrossNodeConstraint to validate</p> required <code>n_nodes</code> <code>int</code> <p>Total number of trajectory nodes</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any NodeReference accesses nodes outside [0, n_nodes)</p> <code>ValueError</code> <p>If constraint mixes .at() and non-.at() variables</p> Example <p>Valid cross-node constraint:</p> <pre><code>from openscvx.symbolic.expr import CrossNodeConstraint\n\nposition = State(\"pos\", shape=(3,))\n\n# Valid: all variables use .at(), indices in bounds\nconstraint = CrossNodeConstraint(position.at(5) - position.at(4) &lt;= 0.1)\nvalidate_cross_node_constraint(constraint, n_nodes=10)  # OK\n</code></pre> <p>Invalid - out of bounds:</p> <pre><code># Invalid: node 10 is out of bounds for n_nodes=10\nbad_bounds = CrossNodeConstraint(position.at(0) == position.at(10))\nvalidate_cross_node_constraint(bad_bounds, n_nodes=10)  # Raises ValueError\n</code></pre> <p>Invalid - mixed .at() usage:</p> <pre><code>velocity = State(\"vel\", shape=(3,))\n# Invalid: position uses .at(), velocity doesn't\nbad_mixed = CrossNodeConstraint(position.at(5) - velocity &lt;= 0.1)\nvalidate_cross_node_constraint(bad_mixed, n_nodes=10)  # Raises ValueError\n</code></pre> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_cross_node_constraint(cross_node_constraint, n_nodes: int) -&gt; None:\n    \"\"\"Validate cross-node constraint bounds and variable consistency.\n\n    This function performs two validations in a single tree traversal:\n\n    1. **Bounds checking**: Ensures all NodeReference indices are within [0, n_nodes).\n       Cross-node constraints reference fixed trajectory nodes (e.g., position.at(5)),\n       and this validates those indices are valid. Negative indices are normalized\n       (e.g., -1 becomes n_nodes-1) before checking.\n\n    2. **Variable consistency**: Ensures that if ANY variable uses .at(), then ALL\n       state/control variables must use .at(). Mixing causes shape mismatches during\n       lowering because:\n       - Variables with .at(k) extract single-node values: X[k, :] \u2192 shape (n_x,)\n       - Variables without .at() expect full trajectory: X[:, :] \u2192 shape (N, n_x)\n\n    Args:\n        cross_node_constraint: The CrossNodeConstraint to validate\n        n_nodes: Total number of trajectory nodes\n\n    Raises:\n        ValueError: If any NodeReference accesses nodes outside [0, n_nodes)\n        ValueError: If constraint mixes .at() and non-.at() variables\n\n    Example:\n        Valid cross-node constraint:\n\n            from openscvx.symbolic.expr import CrossNodeConstraint\n\n            position = State(\"pos\", shape=(3,))\n\n            # Valid: all variables use .at(), indices in bounds\n            constraint = CrossNodeConstraint(position.at(5) - position.at(4) &lt;= 0.1)\n            validate_cross_node_constraint(constraint, n_nodes=10)  # OK\n\n        Invalid - out of bounds:\n\n            # Invalid: node 10 is out of bounds for n_nodes=10\n            bad_bounds = CrossNodeConstraint(position.at(0) == position.at(10))\n            validate_cross_node_constraint(bad_bounds, n_nodes=10)  # Raises ValueError\n\n        Invalid - mixed .at() usage:\n\n            velocity = State(\"vel\", shape=(3,))\n            # Invalid: position uses .at(), velocity doesn't\n            bad_mixed = CrossNodeConstraint(position.at(5) - velocity &lt;= 0.1)\n            validate_cross_node_constraint(bad_mixed, n_nodes=10)  # Raises ValueError\n    \"\"\"\n    from openscvx.symbolic.expr import Control, CrossNodeConstraint, NodeReference, State\n\n    if not isinstance(cross_node_constraint, CrossNodeConstraint):\n        raise TypeError(\n            f\"Expected CrossNodeConstraint, got {type(cross_node_constraint).__name__}. \"\n            f\"Bare constraints with NodeReferences should be wrapped in CrossNodeConstraint \"\n            f\"by separate_constraints() before validation.\"\n        )\n\n    constraint = cross_node_constraint.constraint\n\n    # Collect information in a single traversal\n    node_refs = []  # List of (node_idx, normalized_idx) tuples\n    unwrapped_vars = []  # List of variable names without .at()\n\n    def traverse(expr):\n        if isinstance(expr, NodeReference):\n            # Normalize negative indices\n            idx = expr.node_idx\n            normalized_idx = idx if idx &gt;= 0 else n_nodes + idx\n            node_refs.append((idx, normalized_idx))\n            # Don't traverse into children - NodeReference wraps the variable\n            return\n\n        if isinstance(expr, (State, Control)):\n            # Found a bare State/Control not wrapped in NodeReference\n            unwrapped_vars.append(expr.name)\n            return\n\n        # Recurse on children\n        for child in expr.children():\n            traverse(child)\n\n    # Traverse the constraint expression (both sides)\n    traverse(constraint.lhs)\n    traverse(constraint.rhs)\n\n    # Check 1: Bounds validation\n    for orig_idx, normalized_idx in node_refs:\n        if normalized_idx &lt; 0 or normalized_idx &gt;= n_nodes:\n            raise ValueError(\n                f\"Cross-node constraint references invalid node index {orig_idx}. \"\n                f\"Node indices must be in range [0, {n_nodes}) \"\n                f\"(or negative indices in range [-{n_nodes}, -1]). \"\n                f\"Constraint: {constraint}\"\n            )\n\n    # Check 2: Variable consistency - if we have NodeReferences, all vars must use .at()\n    if node_refs and unwrapped_vars:\n        raise ValueError(\n            f\"Cross-node constraint contains NodeReferences (variables with .at(k)) \"\n            f\"but also has variables without .at(): {unwrapped_vars}. \"\n            f\"All state/control variables in cross-node constraints must use .at(k). \"\n            f\"For example, if you use 'position.at(5)', you must also use 'velocity.at(4)' \"\n            f\"instead of just 'velocity'. \"\n            f\"Constraint: {constraint}\"\n        )\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_dynamics_dict","title":"<code>validate_dynamics_dict(dynamics: Dict[str, Expr], states: List[State], byof_dynamics: Optional[Dict[str, callable]] = None) -&gt; None</code>","text":"<p>Validate that dynamics dictionary keys match state names exactly.</p> <p>Ensures that the dynamics dictionary (combined with optional byof dynamics) has exactly the same keys as the state names, with no missing states, no extra keys, and no overlap between symbolic and byof dynamics.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>Dict[str, Expr]</code> <p>Dictionary mapping state names to their dynamics expressions</p> required <code>states</code> <code>List[State]</code> <p>List of State objects</p> required <code>byof_dynamics</code> <code>Optional[Dict[str, callable]]</code> <p>Optional dictionary mapping state names to raw JAX functions. States in byof_dynamics should NOT appear in dynamics dict.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there's a mismatch between state names and dynamics keys, or if a state appears in both dynamics and byof_dynamics.</p> Example <p>x = ox.State(\"x\", shape=(3,)) y = ox.State(\"y\", shape=(2,)) dynamics = {\"x\": x * 2, \"y\": y + 1} validate_dynamics_dict(dynamics, [x, y])  # OK</p> <p>bad_dynamics = {\"x\": x * 2}  # Missing \"y\" validate_dynamics_dict(bad_dynamics, [x, y])  # Raises ValueError</p> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_dynamics_dict(\n    dynamics: Dict[str, Expr],\n    states: List[State],\n    byof_dynamics: Optional[Dict[str, callable]] = None,\n) -&gt; None:\n    \"\"\"Validate that dynamics dictionary keys match state names exactly.\n\n    Ensures that the dynamics dictionary (combined with optional byof dynamics) has\n    exactly the same keys as the state names, with no missing states, no extra keys,\n    and no overlap between symbolic and byof dynamics.\n\n    Args:\n        dynamics: Dictionary mapping state names to their dynamics expressions\n        states: List of State objects\n        byof_dynamics: Optional dictionary mapping state names to raw JAX functions.\n            States in byof_dynamics should NOT appear in dynamics dict.\n\n    Raises:\n        ValueError: If there's a mismatch between state names and dynamics keys,\n            or if a state appears in both dynamics and byof_dynamics.\n\n    Example:\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(2,))\n            dynamics = {\"x\": x * 2, \"y\": y + 1}\n            validate_dynamics_dict(dynamics, [x, y])  # OK\n\n            bad_dynamics = {\"x\": x * 2}  # Missing \"y\"\n            validate_dynamics_dict(bad_dynamics, [x, y])  # Raises ValueError\n\n            # With byof_dynamics (expert user mode)\n            dynamics = {\"x\": x * 2}  # Only symbolic for x\n            byof_dynamics = {\"y\": some_jax_fn}  # Raw JAX for y\n            validate_dynamics_dict(dynamics, [x, y], byof_dynamics)  # OK\n    \"\"\"\n    state_names_set = set(state.name for state in states)\n    symbolic_keys = set(dynamics.keys())\n    byof_keys = set(byof_dynamics.keys()) if byof_dynamics else set()\n\n    # Check for overlap - a state can't be defined in both\n    overlap = symbolic_keys &amp; byof_keys\n    if overlap:\n        raise ValueError(\n            f\"States defined in both symbolic and byof dynamics: {overlap}\\n\"\n            \"Each state must have dynamics in exactly one place.\"\n        )\n\n    # Check coverage - all states must be covered\n    covered = symbolic_keys | byof_keys\n    missing = state_names_set - covered\n    extra = covered - state_names_set\n\n    if missing or extra:\n        error_msg = \"Mismatch between state names and dynamics keys.\\n\"\n        if missing:\n            error_msg += f\"  States missing from dynamics: {missing}\\n\"\n        if extra:\n            error_msg += f\"  Extra keys in dynamics: {extra}\\n\"\n        raise ValueError(error_msg)\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_dynamics_dict--with-byof_dynamics-expert-user-mode","title":"With byof_dynamics (expert user mode)","text":"<p>dynamics = {\"x\": x * 2}  # Only symbolic for x byof_dynamics = {\"y\": some_jax_fn}  # Raw JAX for y validate_dynamics_dict(dynamics, [x, y], byof_dynamics)  # OK</p>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_dynamics_dict_dimensions","title":"<code>validate_dynamics_dict_dimensions(dynamics: Dict[str, Expr], states: List[State]) -&gt; None</code>","text":"<p>Validate that each dynamics expression matches its corresponding state shape.</p> <p>For dictionary-based dynamics specification, ensures that each state's dynamics expression has the same shape as the state itself. This validates that each component of x_dot = f(x, u, t) has the correct dimension.</p> <p>Scalars are normalized to shape (1,) for comparison, matching Concat behavior.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>Dict[str, Expr]</code> <p>Dictionary mapping state names to their dynamics expressions</p> required <code>states</code> <code>List[State]</code> <p>List of State objects</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any dynamics expression dimension doesn't match its state shape</p> Example <p>x = ox.State(\"x\", shape=(3,)) y = ox.State(\"y\", shape=(2,)) u = ox.Control(\"u\", shape=(3,)) dynamics = {\"x\": u, \"y\": y + 1} validate_dynamics_dict_dimensions(dynamics, [x, y])  # OK</p> <p>bad_dynamics = {\"x\": u, \"y\": u}  # y dynamics has wrong shape validate_dynamics_dict_dimensions(bad_dynamics, [x, y])  # Raises ValueError</p> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_dynamics_dict_dimensions(dynamics: Dict[str, Expr], states: List[State]) -&gt; None:\n    \"\"\"Validate that each dynamics expression matches its corresponding state shape.\n\n    For dictionary-based dynamics specification, ensures that each state's dynamics\n    expression has the same shape as the state itself. This validates that each\n    component of x_dot = f(x, u, t) has the correct dimension.\n\n    Scalars are normalized to shape (1,) for comparison, matching Concat behavior.\n\n    Args:\n        dynamics: Dictionary mapping state names to their dynamics expressions\n        states: List of State objects\n\n    Raises:\n        ValueError: If any dynamics expression dimension doesn't match its state shape\n\n    Example:\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(2,))\n            u = ox.Control(\"u\", shape=(3,))\n            dynamics = {\"x\": u, \"y\": y + 1}\n            validate_dynamics_dict_dimensions(dynamics, [x, y])  # OK\n\n            bad_dynamics = {\"x\": u, \"y\": u}  # y dynamics has wrong shape\n            validate_dynamics_dict_dimensions(bad_dynamics, [x, y])  # Raises ValueError\n    \"\"\"\n\n    def normalize_scalars(shape: Tuple[int, ...]) -&gt; Tuple[int, ...]:\n        \"\"\"Normalize shape: scalar () becomes (1,)\"\"\"\n        return (1,) if len(shape) == 0 else shape\n\n    for state in states:\n        dyn_expr = dynamics[state.name]\n        expected_shape = state.shape\n\n        # Handle raw Python numbers (which will be converted to Constant later)\n        if isinstance(dyn_expr, (int, float)):\n            actual_shape = ()  # Scalars have shape ()\n        else:\n            # Compute the shape of the dynamics expression\n            actual_shape = dyn_expr.check_shape()\n\n        # Normalize both shapes for comparison (consistent with Concat behavior)\n        if normalize_scalars(actual_shape) != normalize_scalars(expected_shape):\n            raise ValueError(\n                f\"Dynamics for state '{state.name}' has shape {actual_shape}, \"\n                f\"but state has shape {expected_shape}\"\n            )\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_dynamics_dimension","title":"<code>validate_dynamics_dimension(dynamics_expr: Union[Expr, list[Expr]], states: Union[State, list[State]]) -&gt; None</code>","text":"<p>Validate that dynamics expression dimensions match state dimensions.</p> <p>Ensures that the total dimension of all dynamics expressions matches the total dimension of all states. Each dynamics expression must be a 1D vector, and their combined dimension must equal the sum of all state dimensions.</p> <p>This is essential for ensuring the ODE system x_dot = f(x, u, t) is well-formed.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics_expr</code> <code>Union[Expr, list[Expr]]</code> <p>Single dynamics expression or list of dynamics expressions.           Combined, they represent x_dot = f(x, u, t) for all states.</p> required <code>states</code> <code>Union[State, list[State]]</code> <p>Single state variable or list of state variables that the dynamics describe.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If dimensions don't match or if any dynamics is not a 1D vector</p> Example <p>x = ox.State(\"x\", shape=(3,)) y = ox.State(\"y\", shape=(2,)) dynamics = ox.Concat(x * 2, y + 1)  # Shape (5,) - matches total state dim validate_dynamics_dimension(dynamics, [x, y])  # OK</p> <p>bad_dynamics = x  # Shape (3,) - doesn't match total dim of 5 validate_dynamics_dimension(bad_dynamics, [x, y])  # Raises ValueError</p> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_dynamics_dimension(\n    dynamics_expr: Union[Expr, list[Expr]], states: Union[State, list[State]]\n) -&gt; None:\n    \"\"\"Validate that dynamics expression dimensions match state dimensions.\n\n    Ensures that the total dimension of all dynamics expressions matches the total\n    dimension of all states. Each dynamics expression must be a 1D vector, and their\n    combined dimension must equal the sum of all state dimensions.\n\n    This is essential for ensuring the ODE system x_dot = f(x, u, t) is well-formed.\n\n    Args:\n        dynamics_expr: Single dynamics expression or list of dynamics expressions.\n                      Combined, they represent x_dot = f(x, u, t) for all states.\n        states: Single state variable or list of state variables that the dynamics describe.\n\n    Raises:\n        ValueError: If dimensions don't match or if any dynamics is not a 1D vector\n\n    Example:\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(2,))\n            dynamics = ox.Concat(x * 2, y + 1)  # Shape (5,) - matches total state dim\n            validate_dynamics_dimension(dynamics, [x, y])  # OK\n\n            bad_dynamics = x  # Shape (3,) - doesn't match total dim of 5\n            validate_dynamics_dimension(bad_dynamics, [x, y])  # Raises ValueError\n    \"\"\"\n    # Normalize inputs to lists\n    dynamics_list = dynamics_expr if isinstance(dynamics_expr, (list, tuple)) else [dynamics_expr]\n    states_list = states if isinstance(states, (list, tuple)) else [states]\n\n    # Calculate total state dimension\n    total_state_dim = sum(int(np.prod(state.shape)) for state in states_list)\n\n    # Validate each dynamics expression and calculate total dynamics dimension\n    total_dynamics_dim = 0\n\n    for i, dyn_expr in enumerate(dynamics_list):\n        # Get the shape of this dynamics expression\n        dynamics_shape = dyn_expr.check_shape()\n\n        # Dynamics should be a 1D vector\n        if len(dynamics_shape) != 1:\n            prefix = f\"Dynamics expression {i}\" if len(dynamics_list) &gt; 1 else \"Dynamics expression\"\n            raise ValueError(\n                f\"{prefix} must be 1-dimensional (vector), but got shape {dynamics_shape}\"\n            )\n\n        total_dynamics_dim += dynamics_shape[0]\n\n    # Check that total dynamics dimension matches total state dimension\n    if total_dynamics_dim != total_state_dim:\n        if len(dynamics_list) == 1:\n            raise ValueError(\n                f\"Dynamics dimension mismatch: dynamics has dimension {total_dynamics_dim}, \"\n                f\"but total state dimension is {total_state_dim}. \"\n                f\"States: {[(s.name, s.shape) for s in states_list]}\"\n            )\n        else:\n            dynamics_dims = [dyn.check_shape()[0] for dyn in dynamics_list]\n            raise ValueError(\n                f\"Dynamics dimension mismatch: {len(dynamics_list)} dynamics expressions \"\n                f\"have combined dimension {total_dynamics_dim} {dynamics_dims}, \"\n                f\"but total state dimension is {total_state_dim}. \"\n                f\"States: {[(s.name, s.shape) for s in states_list]}\"\n            )\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_guesses","title":"<code>validate_guesses(variables: List[Variable]) -&gt; None</code>","text":"<p>Validate that all variables have initial guesses set.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>List[Variable]</code> <p>List of Variable objects (State or Control) to validate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any variable is missing a guess</p> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_guesses(variables: List[Variable]) -&gt; None:\n    \"\"\"Validate that all variables have initial guesses set.\n\n    Args:\n        variables: List of Variable objects (State or Control) to validate\n\n    Raises:\n        ValueError: If any variable is missing a guess\n    \"\"\"\n    for var in variables:\n        if var.guess is None:\n            if isinstance(var, Control):\n                raise ValueError(\n                    f\"Control '{var.name}' is missing initial guess. \"\n                    f\"Please set {var.name}.guess (controls require explicit guesses)\"\n                )\n            raise ValueError(\n                f\"State '{var.name}' is missing initial guess. Please set {var.name}.guess\"\n            )\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_shapes","title":"<code>validate_shapes(exprs: Union[Expr, list[Expr]]) -&gt; None</code>","text":"<p>Validate shapes for a single expression or list of expressions.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>Union[Expr, list[Expr]]</code> <p>Single expression or list of expressions to validate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any expression has invalid shapes</p> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_shapes(exprs: Union[Expr, list[Expr]]) -&gt; None:\n    \"\"\"Validate shapes for a single expression or list of expressions.\n\n    Args:\n        exprs: Single expression or list of expressions to validate\n\n    Raises:\n        ValueError: If any expression has invalid shapes\n    \"\"\"\n    exprs = exprs if isinstance(exprs, (list, tuple)) else [exprs]\n    for e in exprs:\n        e.check_shape()  # will raise ValueError if anything's wrong\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_time_parameters","title":"<code>validate_time_parameters(states: List[State], time: Time) -&gt; Tuple[bool, Union[float, tuple, None], Union[float, tuple, None], float, Union[float, None], Union[float, None]]</code>","text":"<p>Validate time parameter usage and configuration.</p> <p>There are two valid approaches for handling time in trajectory optimization:</p> <ol> <li> <p>Auto-create time (recommended): Don't include \"time\" in states, provide Time object.    The time state is automatically created and managed.</p> </li> <li> <p>User-provided time (advanced): Include a \"time\" State in states. The Time object    is ignored and the user has full control over time dynamics.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>List[State]</code> <p>List of State objects</p> required <code>time</code> <code>Time</code> <p>Time configuration object (required, but ignored if time state exists)</p> required <p>Returns:</p> Type Description <code>Tuple[bool, Union[float, tuple, None], Union[float, tuple, None], float, Union[float, None], Union[float, None]]</code> <p>Tuple of (has_time_state, time_initial, time_final, time_derivative, time_min, time_max): - has_time_state: True if user provided a time state - time_initial: Initial time value (None if user-provided time) - time_final: Final time value (None if user-provided time) - time_derivative: Always 1.0 for auto-created time (None if user-provided) - time_min: Minimum time bound (None if user-provided) - time_max: Maximum time bound (None if user-provided)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If Time object is not provided or has invalid type</p> Example <pre><code>(False, 0.0, 10.0, 1.0, None, None)\n\n    # Approach 2: User-provided time\n    x = ox.State(\"x\", shape=(3,))\n    time_state = ox.State(\"time\", shape=())\n    validate_time_parameters([x, time_state], time_obj)\n(True, None, None, None, None, None)\n</code></pre> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_time_parameters(\n    states: List[State],\n    time: \"Time\",\n) -&gt; Tuple[\n    bool,\n    Union[float, tuple, None],\n    Union[float, tuple, None],\n    float,\n    Union[float, None],\n    Union[float, None],\n]:\n    \"\"\"Validate time parameter usage and configuration.\n\n    There are two valid approaches for handling time in trajectory optimization:\n\n    1. Auto-create time (recommended): Don't include \"time\" in states, provide Time object.\n       The time state is automatically created and managed.\n\n    2. User-provided time (advanced): Include a \"time\" State in states. The Time object\n       is ignored and the user has full control over time dynamics.\n\n    Args:\n        states: List of State objects\n        time: Time configuration object (required, but ignored if time state exists)\n\n    Returns:\n        Tuple of (has_time_state, time_initial, time_final, time_derivative, time_min, time_max):\n            - has_time_state: True if user provided a time state\n            - time_initial: Initial time value (None if user-provided time)\n            - time_final: Final time value (None if user-provided time)\n            - time_derivative: Always 1.0 for auto-created time (None if user-provided)\n            - time_min: Minimum time bound (None if user-provided)\n            - time_max: Maximum time bound (None if user-provided)\n\n    Raises:\n        ValueError: If Time object is not provided or has invalid type\n\n    Example:\n            # Approach 1: Auto-create time\n            x = ox.State(\"x\", shape=(3,))\n            time_obj = ox.Time(initial=0.0, final=10.0)\n            validate_time_parameters([x], time_obj)\n        (False, 0.0, 10.0, 1.0, None, None)\n\n            # Approach 2: User-provided time\n            x = ox.State(\"x\", shape=(3,))\n            time_state = ox.State(\"time\", shape=())\n            validate_time_parameters([x, time_state], time_obj)\n        (True, None, None, None, None, None)\n    \"\"\"\n    from openscvx.symbolic.time import Time\n\n    if not isinstance(time, Time):\n        raise ValueError(f\"Expected Time object, but got {type(time).__name__}\")\n\n    has_time_state = any(state.name == \"time\" for state in states)\n\n    if has_time_state:\n        # Approach 2: User-provided time state\n        # Time object is provided but ignored - user handles everything via State\n        # Return None for all time parameters since user handles everything\n        return True, None, None, None, None, None\n    else:\n        # Approach 1: Auto-create time state\n        # Extract values from Time object\n        time_initial = time.initial\n        time_final = time.final\n        time_derivative = 1.0  # Always 1.0 when using Time object\n        time_min = time.min\n        time_max = time.max\n\n        return False, time_initial, time_final, time_derivative, time_min, time_max\n</code></pre>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_time_parameters--approach-1-auto-create-time","title":"Approach 1: Auto-create time","text":"<p>x = ox.State(\"x\", shape=(3,)) time_obj = ox.Time(initial=0.0, final=10.0) validate_time_parameters([x], time_obj)</p>"},{"location":"reference/symbolic/preprocessing/#openscvx.symbolic.preprocessing.validate_variable_names","title":"<code>validate_variable_names(exprs: Iterable[Expr], *, reserved_prefix: str = '_', reserved_names: Set[str] = None) -&gt; None</code>","text":"<p>Validate variable names for uniqueness and reserved name conflicts.</p> <p>This function ensures that all State and Control variable names are: 1. Unique across distinct variable instances 2. Not starting with the reserved prefix (default: \"_\") 3. Not colliding with explicitly reserved names</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>Iterable[Expr]</code> <p>Iterable of expression trees to scan for variables</p> required <code>reserved_prefix</code> <code>str</code> <p>Prefix that user variables cannot start with (default: \"_\")</p> <code>'_'</code> <code>reserved_names</code> <code>Set[str]</code> <p>Set of explicitly reserved names that cannot be used (default: None)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any variable name violates uniqueness or reserved name rules</p> Example <p>x1 = ox.State(\"x\", shape=(3,)) x2 = ox.State(\"x\", shape=(2,))  # Same name, different object validate_variable_names([x1 + x2])  # Raises ValueError: Duplicate name 'x'</p> <p>bad = ox.State(\"internal\", shape=(2,)) validate_variable_names([bad])  # Raises ValueError: Reserved prefix ''</p> Source code in <code>openscvx/symbolic/preprocessing.py</code> <pre><code>def validate_variable_names(\n    exprs: Iterable[Expr],\n    *,\n    reserved_prefix: str = \"_\",\n    reserved_names: Set[str] = None,\n) -&gt; None:\n    \"\"\"Validate variable names for uniqueness and reserved name conflicts.\n\n    This function ensures that all State and Control variable names are:\n    1. Unique across distinct variable instances\n    2. Not starting with the reserved prefix (default: \"_\")\n    3. Not colliding with explicitly reserved names\n\n    Args:\n        exprs: Iterable of expression trees to scan for variables\n        reserved_prefix: Prefix that user variables cannot start with (default: \"_\")\n        reserved_names: Set of explicitly reserved names that cannot be used (default: None)\n\n    Raises:\n        ValueError: If any variable name violates uniqueness or reserved name rules\n\n    Example:\n            x1 = ox.State(\"x\", shape=(3,))\n            x2 = ox.State(\"x\", shape=(2,))  # Same name, different object\n            validate_variable_names([x1 + x2])  # Raises ValueError: Duplicate name 'x'\n\n            bad = ox.State(\"_internal\", shape=(2,))\n            validate_variable_names([bad])  # Raises ValueError: Reserved prefix '_'\n    \"\"\"\n    seen_names = set()\n    seen_ids = set()\n    reserved = set(reserved_names or ())\n\n    def visitor(node):\n        if not isinstance(node, (State, Control)):\n            return\n\n        node_id = id(node)\n        if node_id in seen_ids:\n            # we already checked this exact object\n            return\n\n        name = node.name\n\n        # 1) uniqueness across *different* variables\n        if name in seen_names:\n            raise ValueError(f\"Duplicate variable name: {name!r}\")\n\n        # 2) no leading underscore\n        if name.startswith(reserved_prefix):\n            raise ValueError(\n                f\"Variable name {name!r} is reserved (cannot start with {reserved_prefix!r})\"\n            )\n\n        # 3) no collision with explicit reserved set\n        if name in reserved:\n            raise ValueError(f\"Variable name {name!r} collides with reserved name\")\n\n        seen_names.add(name)\n        seen_ids.add(node_id)\n\n    for e in exprs:\n        traverse(e, visitor)\n</code></pre>"},{"location":"reference/symbolic/problem/","title":"problem","text":"<p>SymbolicProblem dataclass - container for symbolic problem specification.</p> <p>This module provides the SymbolicProblem dataclass that represents a trajectory optimization problem in symbolic form, before lowering to executable code.</p> <p>The SymbolicProblem can represent two lifecycle stages:</p> <ol> <li>Before preprocessing: Raw user input with unsorted constraints</li> <li>After preprocessing: Augmented and validated, ready for lowering</li> </ol> <p>Use <code>is_preprocessed</code> to check which stage the problem is in.</p>"},{"location":"reference/symbolic/problem/#openscvx.symbolic.problem.SymbolicProblem","title":"<code>SymbolicProblem</code>  <code>dataclass</code>","text":"<p>Container for symbolic problem specification.</p> <p>This dataclass holds a trajectory optimization problem in symbolic form, either as raw user input or after preprocessing/augmentation. It provides a typed interface for the preprocessing and lowering pipeline.</p> Lifecycle Stages <ol> <li>Before preprocessing: User creates with raw dynamics, states,    controls, and unsorted constraints. Propagation fields are None.</li> <li>After preprocessing: Dynamics and states are augmented (CTCS,    time dilation), constraints are categorized, propagation fields    are populated.</li> </ol> <p>Use <code>is_preprocessed</code> to check whether preprocessing has completed.</p> <p>Attributes:</p> Name Type Description <code>dynamics</code> <code>Expr</code> <p>Symbolic dynamics expression (dx/dt = f(x, u)). After preprocessing, includes CTCS augmented state dynamics.</p> <code>states</code> <code>List[State]</code> <p>List of State objects. After preprocessing, includes time state and CTCS augmented states.</p> <code>controls</code> <code>List[Control]</code> <p>List of Control objects. After preprocessing, includes time dilation control.</p> <code>constraints</code> <code>ConstraintSet</code> <p>ConstraintSet holding all constraints. Before preprocessing, raw constraints live in <code>constraints.unsorted</code>. After preprocessing, constraints are categorized into ctcs, nodal, nodal_convex, etc.</p> <code>parameters</code> <code>Dict[str, any]</code> <p>Dictionary mapping parameter names to numpy arrays.</p> <code>N</code> <code>int</code> <p>Number of discretization nodes.</p> <code>node_intervals</code> <code>List[Tuple[int, int]]</code> <p>List of (start, end) tuples for CTCS constraint intervals. Populated during preprocessing when CTCS constraints are sorted.</p> <code>dynamics_prop</code> <code>Optional[Expr]</code> <p>Propagation dynamics (may include extra states). None before preprocessing, populated after.</p> <code>states_prop</code> <code>Optional[List[State]]</code> <p>Propagation states (may include extra states). None before preprocessing, populated after.</p> <code>controls_prop</code> <code>Optional[List[Control]]</code> <p>Propagation controls (typically same as controls). None before preprocessing, populated after.</p> <code>algebraic_prop</code> <code>Optional[Dict[str, Expr]]</code> <p>Algebraic outputs computed during propagation (no integration). None before preprocessing, populated after.</p> Example <p>Before preprocessing::</p> <pre><code>problem = SymbolicProblem(\n    dynamics=dynamics_expr,\n    states=[x, v],\n    controls=[u],\n    constraints=ConstraintSet(unsorted=[c1, c2, c3]),\n    parameters={\"mass\": 1.0},\n    N=50,\n)\nassert not problem.is_preprocessed\n</code></pre> <p>After preprocessing::</p> <pre><code>processed = preprocess_symbolic_problem(problem, time=time_config)\nassert processed.is_preprocessed\nassert processed.constraints.is_categorized\n# Now ready for lowering\nlowered = lower_symbolic_problem(processed)\n</code></pre> Source code in <code>openscvx/symbolic/problem.py</code> <pre><code>@dataclass\nclass SymbolicProblem:\n    \"\"\"Container for symbolic problem specification.\n\n    This dataclass holds a trajectory optimization problem in symbolic form,\n    either as raw user input or after preprocessing/augmentation. It provides\n    a typed interface for the preprocessing and lowering pipeline.\n\n    Lifecycle Stages:\n        1. **Before preprocessing**: User creates with raw dynamics, states,\n           controls, and unsorted constraints. Propagation fields are None.\n        2. **After preprocessing**: Dynamics and states are augmented (CTCS,\n           time dilation), constraints are categorized, propagation fields\n           are populated.\n\n    Use `is_preprocessed` to check whether preprocessing has completed.\n\n    Attributes:\n        dynamics: Symbolic dynamics expression (dx/dt = f(x, u)).\n            After preprocessing, includes CTCS augmented state dynamics.\n        states: List of State objects. After preprocessing, includes\n            time state and CTCS augmented states.\n        controls: List of Control objects. After preprocessing, includes\n            time dilation control.\n        constraints: ConstraintSet holding all constraints. Before preprocessing,\n            raw constraints live in `constraints.unsorted`. After preprocessing,\n            constraints are categorized into ctcs, nodal, nodal_convex, etc.\n        parameters: Dictionary mapping parameter names to numpy arrays.\n        N: Number of discretization nodes.\n        node_intervals: List of (start, end) tuples for CTCS constraint intervals.\n            Populated during preprocessing when CTCS constraints are sorted.\n\n        dynamics_prop: Propagation dynamics (may include extra states).\n            None before preprocessing, populated after.\n        states_prop: Propagation states (may include extra states).\n            None before preprocessing, populated after.\n        controls_prop: Propagation controls (typically same as controls).\n            None before preprocessing, populated after.\n        algebraic_prop: Algebraic outputs computed during propagation (no integration).\n            None before preprocessing, populated after.\n\n    Example:\n        Before preprocessing::\n\n            problem = SymbolicProblem(\n                dynamics=dynamics_expr,\n                states=[x, v],\n                controls=[u],\n                constraints=ConstraintSet(unsorted=[c1, c2, c3]),\n                parameters={\"mass\": 1.0},\n                N=50,\n            )\n            assert not problem.is_preprocessed\n\n        After preprocessing::\n\n            processed = preprocess_symbolic_problem(problem, time=time_config)\n            assert processed.is_preprocessed\n            assert processed.constraints.is_categorized\n            # Now ready for lowering\n            lowered = lower_symbolic_problem(processed)\n    \"\"\"\n\n    # Core problem specification\n    dynamics: \"Expr\"\n    states: List[\"State\"]\n    controls: List[\"Control\"]\n    constraints: ConstraintSet\n    parameters: Dict[str, any]\n    N: int\n\n    # CTCS node intervals (populated during preprocessing)\n    node_intervals: List[Tuple[int, int]] = field(default_factory=list)\n\n    # Propagation (None before preprocessing, populated after)\n    dynamics_prop: Optional[\"Expr\"] = None\n    states_prop: Optional[List[\"State\"]] = None\n    controls_prop: Optional[List[\"Control\"]] = None\n\n    # Algebraic outputs computed during propagation (no integration)\n    # Maps output names to symbolic expressions\n    algebraic_prop: Optional[Dict[str, \"Expr\"]] = None\n\n    @property\n    def is_preprocessed(self) -&gt; bool:\n        \"\"\"True if the problem has been preprocessed and is ready for lowering.\n\n        A problem is considered preprocessed when:\n        1. All constraints have been categorized (unsorted is empty)\n        2. Propagation dynamics have been set up\n        \"\"\"\n        return self.constraints.is_categorized and self.dynamics_prop is not None\n</code></pre>"},{"location":"reference/symbolic/problem/#openscvx.symbolic.problem.SymbolicProblem.is_preprocessed","title":"<code>is_preprocessed: bool</code>  <code>property</code>","text":"<p>True if the problem has been preprocessed and is ready for lowering.</p> <p>A problem is considered preprocessed when: 1. All constraints have been categorized (unsorted is empty) 2. Propagation dynamics have been set up</p>"},{"location":"reference/symbolic/time/","title":"time","text":""},{"location":"reference/symbolic/time/#openscvx.symbolic.time.Time","title":"<code>Time</code>","text":"<p>Time configuration for trajectory optimization problems.</p> <p>This class encapsulates time-related parameters for trajectory optimization. The time derivative is internally assumed to be 1.0.</p> <p>Attributes:</p> Name Type Description <code>initial</code> <code>float or tuple</code> <p>Initial time boundary condition. Can be a float (fixed) or tuple like (\"free\", value), (\"minimize\", value), or (\"maximize\", value).</p> <code>final</code> <code>float or tuple</code> <p>Final time boundary condition. Can be a float (fixed) or tuple like (\"free\", value), (\"minimize\", value), or (\"maximize\", value).</p> <code>min</code> <code>float</code> <p>Minimum bound for time variable (required).</p> <code>max</code> <code>float</code> <p>Maximum bound for time variable (required).</p> Example <pre><code># Fixed initial and final time\ntime = Time(initial=0.0, final=10.0, min=0.0, max=20.0)\n\n# Free final time\ntime = Time(initial=0.0, final=(\"free\", 10.0), min=0.0, max=20.0)\n\n# Minimize final time\ntime = Time(initial=0.0, final=(\"minimize\", 10.0), min=0.0, max=20.0)\n\n# Maximize initial time\ntime = Time(initial=(\"maximize\", 0.0), final=10.0, min=0.0, max=20.0)\n</code></pre> Source code in <code>openscvx/symbolic/time.py</code> <pre><code>class Time:\n    \"\"\"Time configuration for trajectory optimization problems.\n\n    This class encapsulates time-related parameters for trajectory optimization.\n    The time derivative is internally assumed to be 1.0.\n\n    Attributes:\n        initial (float or tuple): Initial time boundary condition.\n            Can be a float (fixed) or tuple like (\"free\", value), (\"minimize\", value),\n            or (\"maximize\", value).\n        final (float or tuple): Final time boundary condition.\n            Can be a float (fixed) or tuple like (\"free\", value), (\"minimize\", value),\n            or (\"maximize\", value).\n        min (float): Minimum bound for time variable (required).\n        max (float): Maximum bound for time variable (required).\n\n    Example:\n        ```python\n        # Fixed initial and final time\n        time = Time(initial=0.0, final=10.0, min=0.0, max=20.0)\n\n        # Free final time\n        time = Time(initial=0.0, final=(\"free\", 10.0), min=0.0, max=20.0)\n\n        # Minimize final time\n        time = Time(initial=0.0, final=(\"minimize\", 10.0), min=0.0, max=20.0)\n\n        # Maximize initial time\n        time = Time(initial=(\"maximize\", 0.0), final=10.0, min=0.0, max=20.0)\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        initial: Union[float, tuple],\n        final: Union[float, tuple],\n        min: float,\n        max: float,\n    ):\n        \"\"\"Initialize a Time object.\n\n        Args:\n            initial: Initial time boundary condition (float or tuple).\n                Tuple format: (\"free\", value), (\"minimize\", value), or (\"maximize\", value).\n            final: Final time boundary condition (float or tuple).\n                Tuple format: (\"free\", value), (\"minimize\", value), or (\"maximize\", value).\n            min: Minimum bound for time variable (required).\n            max: Maximum bound for time variable (required).\n\n        Raises:\n            ValueError: If tuple format is invalid.\n        \"\"\"\n        # Validate tuple format if provided\n        for name, value in [(\"initial\", initial), (\"final\", final)]:\n            if isinstance(value, tuple):\n                if len(value) != 2:\n                    raise ValueError(f\"{name} tuple must have exactly 2 elements: (type, value)\")\n                bc_type, bc_value = value\n                if bc_type not in [\"free\", \"minimize\", \"maximize\"]:\n                    raise ValueError(\n                        f\"{name} boundary condition type must be 'free', \"\n                        f\"'minimize', or 'maximize', got '{bc_type}'\"\n                    )\n                if not isinstance(bc_value, (int, float)):\n                    raise ValueError(\n                        f\"{name} boundary condition value must be a number, \"\n                        f\"got {type(bc_value).__name__}\"\n                    )\n\n        self.initial = initial\n        self.final = final\n        self.min = min\n        self.max = max\n        # Time derivative is always 1.0 internally\n        self.derivative = 1.0\n        self._scaling_min = None\n        self._scaling_max = None\n\n    @property\n    def scaling_min(self):\n        \"\"\"Get the scaling minimum bound for the time variable.\n\n        Returns:\n            Scaling minimum value, or None if not set.\n        \"\"\"\n        return self._scaling_min\n\n    @scaling_min.setter\n    def scaling_min(self, val):\n        \"\"\"Set the scaling minimum bound for the time variable.\n\n        Args:\n            val: Scaling minimum value (float or None)\n        \"\"\"\n        self._scaling_min = float(val) if val is not None else None\n\n    @property\n    def scaling_max(self):\n        \"\"\"Get the scaling maximum bound for the time variable.\n\n        Returns:\n            Scaling maximum value, or None if not set.\n        \"\"\"\n        return self._scaling_max\n\n    @scaling_max.setter\n    def scaling_max(self, val):\n        \"\"\"Set the scaling maximum bound for the time variable.\n\n        Args:\n            val: Scaling maximum value (float or None)\n        \"\"\"\n        self._scaling_max = float(val) if val is not None else None\n</code></pre>"},{"location":"reference/symbolic/time/#openscvx.symbolic.time.Time.scaling_max","title":"<code>scaling_max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling maximum bound for the time variable.</p> <p>Returns:</p> Type Description <p>Scaling maximum value, or None if not set.</p>"},{"location":"reference/symbolic/time/#openscvx.symbolic.time.Time.scaling_min","title":"<code>scaling_min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling minimum bound for the time variable.</p> <p>Returns:</p> Type Description <p>Scaling minimum value, or None if not set.</p>"},{"location":"reference/symbolic/time/#openscvx.symbolic.time.Time.__init__","title":"<code>__init__(initial: Union[float, tuple], final: Union[float, tuple], min: float, max: float)</code>","text":"<p>Initialize a Time object.</p> <p>Parameters:</p> Name Type Description Default <code>initial</code> <code>Union[float, tuple]</code> <p>Initial time boundary condition (float or tuple). Tuple format: (\"free\", value), (\"minimize\", value), or (\"maximize\", value).</p> required <code>final</code> <code>Union[float, tuple]</code> <p>Final time boundary condition (float or tuple). Tuple format: (\"free\", value), (\"minimize\", value), or (\"maximize\", value).</p> required <code>min</code> <code>float</code> <p>Minimum bound for time variable (required).</p> required <code>max</code> <code>float</code> <p>Maximum bound for time variable (required).</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If tuple format is invalid.</p> Source code in <code>openscvx/symbolic/time.py</code> <pre><code>def __init__(\n    self,\n    initial: Union[float, tuple],\n    final: Union[float, tuple],\n    min: float,\n    max: float,\n):\n    \"\"\"Initialize a Time object.\n\n    Args:\n        initial: Initial time boundary condition (float or tuple).\n            Tuple format: (\"free\", value), (\"minimize\", value), or (\"maximize\", value).\n        final: Final time boundary condition (float or tuple).\n            Tuple format: (\"free\", value), (\"minimize\", value), or (\"maximize\", value).\n        min: Minimum bound for time variable (required).\n        max: Maximum bound for time variable (required).\n\n    Raises:\n        ValueError: If tuple format is invalid.\n    \"\"\"\n    # Validate tuple format if provided\n    for name, value in [(\"initial\", initial), (\"final\", final)]:\n        if isinstance(value, tuple):\n            if len(value) != 2:\n                raise ValueError(f\"{name} tuple must have exactly 2 elements: (type, value)\")\n            bc_type, bc_value = value\n            if bc_type not in [\"free\", \"minimize\", \"maximize\"]:\n                raise ValueError(\n                    f\"{name} boundary condition type must be 'free', \"\n                    f\"'minimize', or 'maximize', got '{bc_type}'\"\n                )\n            if not isinstance(bc_value, (int, float)):\n                raise ValueError(\n                    f\"{name} boundary condition value must be a number, \"\n                    f\"got {type(bc_value).__name__}\"\n                )\n\n    self.initial = initial\n    self.final = final\n    self.min = min\n    self.max = max\n    # Time derivative is always 1.0 internally\n    self.derivative = 1.0\n    self._scaling_min = None\n    self._scaling_max = None\n</code></pre>"},{"location":"reference/symbolic/unified/","title":"unified","text":"<p>Unification functions for aggregating symbolic State and Control objects.</p> <p>This module provides the unification layer that transforms multiple symbolic State and Control objects into unified representations for numerical optimization.</p> The unification process <ol> <li>Collection: Gathers all State and Control objects from expression trees</li> <li>Sorting: Organizes variables (user-defined first, then augmented)</li> <li>Aggregation: Concatenates bounds, guesses, and boundary conditions</li> <li>Slice Assignment: Assigns each State/Control a slice for indexing</li> <li>Unified Representation: Creates UnifiedState/UnifiedControl objects</li> </ol> <p>This separation allows users to define problems with natural variable names while maintaining efficient vectorized operations during optimization.</p> Example <p>Creating and unifying multiple states::</p> <pre><code>import openscvx as ox\nfrom openscvx.symbolic.unified import unify_states\n\n# Define separate symbolic states\nposition = ox.State(\"position\", shape=(3,), min=-10, max=10)\nvelocity = ox.State(\"velocity\", shape=(3,), min=-5, max=5)\nmass = ox.State(\"mass\", shape=(1,), min=0.1, max=10.0)\n\n# Unify into single state vector\nunified_x = unify_states([position, velocity, mass], name=\"x\")\n\n# Access unified properties\nprint(unified_x.shape)    # (7,) - combined shape\nprint(unified_x.min)      # Combined bounds: [-10, -10, -10, -5, -5, -5, 0.1]\nprint(unified_x.true)     # Access only user-defined states\n</code></pre> <p>Accessing slices after unification::</p> <pre><code># After unification, each State has a slice assigned\nprint(position._slice)    # slice(0, 3)\nprint(velocity._slice)    # slice(3, 6)\nprint(mass._slice)        # slice(6, 7)\n\n# During lowering, these slices extract values from unified vector\nx_unified = jnp.array([1, 2, 3, 4, 5, 6, 7])\nposition_val = x_unified[position._slice]  # [1, 2, 3]\n</code></pre> See Also <ul> <li>UnifiedState: Dataclass for unified state representation (in openscvx.lowered.unified)</li> <li>UnifiedControl: Dataclass for unified control representation (in openscvx.lowered.unified)</li> <li>State: Individual symbolic state variable (symbolic/expr/state.py)</li> <li>Control: Individual symbolic control variable (symbolic/expr/control.py)</li> </ul>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.UnifiedControl","title":"<code>UnifiedControl</code>  <code>dataclass</code>","text":"<p>Unified control vector aggregating multiple Control objects.</p> <p>UnifiedControl is a drop-in replacement for individual Control objects that holds aggregated data from multiple Control instances. It maintains compatibility with optimization infrastructure while providing access to individual control components through slicing.</p> <p>The unified control separates user-defined \"true\" controls from augmented controls added internally (e.g., for time dilation). This separation allows clean access to physical control inputs while supporting advanced features.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the unified control vector</p> <code>shape</code> <code>tuple</code> <p>Combined shape (total_dim,) of all aggregated controls</p> <code>min</code> <code>ndarray</code> <p>Lower bounds for all control variables, shape (total_dim,)</p> <code>max</code> <code>ndarray</code> <p>Upper bounds for all control variables, shape (total_dim,)</p> <code>guess</code> <code>ndarray</code> <p>Initial guess trajectory, shape (num_nodes, total_dim)</p> <code>_true_dim</code> <code>int</code> <p>Number of user-defined control dimensions (excludes augmented)</p> <code>_true_slice</code> <code>slice</code> <p>Slice for extracting true controls from unified vector</p> <code>_augmented_slice</code> <code>slice</code> <p>Slice for extracting augmented controls</p> <code>time_dilation_slice</code> <code>Optional[slice]</code> <p>Slice for time dilation control, if present</p> Properties <p>true: Returns UnifiedControl view containing only true (user-defined) controls augmented: Returns UnifiedControl view containing only augmented controls</p> Example <p>Creating a unified control from multiple Control objects::</p> <pre><code>from openscvx.symbolic.unified import unify_controls\n\nthrust = ox.Control(\"thrust\", shape=(3,), min=0, max=10)\ntorque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n\nunified = unify_controls([thrust, torque], name=\"u\")\nprint(unified.shape)        # (6,)\nprint(unified.min)          # [0, 0, 0, -1, -1, -1]\nprint(unified.true.shape)   # (6,) - all are true controls\nprint(unified.augmented.shape)  # (0,) - no augmented controls\n</code></pre> <p>Appending controls dynamically::</p> <pre><code>unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.0)  # Add scalar control\nprint(unified.shape)  # (1,)\n</code></pre> See Also <ul> <li>unify_controls(): Factory function for creating UnifiedControl from Control list</li> <li>Control: Individual symbolic control variable</li> <li>UnifiedState: Analogous unified state vector</li> </ul> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>@dataclass\nclass UnifiedControl:\n    \"\"\"Unified control vector aggregating multiple Control objects.\n\n    UnifiedControl is a drop-in replacement for individual Control objects that holds\n    aggregated data from multiple Control instances. It maintains compatibility with\n    optimization infrastructure while providing access to individual control components\n    through slicing.\n\n    The unified control separates user-defined \"true\" controls from augmented controls\n    added internally (e.g., for time dilation). This separation allows clean access to\n    physical control inputs while supporting advanced features.\n\n    Attributes:\n        name (str): Name identifier for the unified control vector\n        shape (tuple): Combined shape (total_dim,) of all aggregated controls\n        min (np.ndarray): Lower bounds for all control variables, shape (total_dim,)\n        max (np.ndarray): Upper bounds for all control variables, shape (total_dim,)\n        guess (np.ndarray): Initial guess trajectory, shape (num_nodes, total_dim)\n        _true_dim (int): Number of user-defined control dimensions (excludes augmented)\n        _true_slice (slice): Slice for extracting true controls from unified vector\n        _augmented_slice (slice): Slice for extracting augmented controls\n        time_dilation_slice (Optional[slice]): Slice for time dilation control, if present\n\n    Properties:\n        true: Returns UnifiedControl view containing only true (user-defined) controls\n        augmented: Returns UnifiedControl view containing only augmented controls\n\n    Example:\n        Creating a unified control from multiple Control objects::\n\n            from openscvx.symbolic.unified import unify_controls\n\n            thrust = ox.Control(\"thrust\", shape=(3,), min=0, max=10)\n            torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n\n            unified = unify_controls([thrust, torque], name=\"u\")\n            print(unified.shape)        # (6,)\n            print(unified.min)          # [0, 0, 0, -1, -1, -1]\n            print(unified.true.shape)   # (6,) - all are true controls\n            print(unified.augmented.shape)  # (0,) - no augmented controls\n\n        Appending controls dynamically::\n\n            unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.0)  # Add scalar control\n            print(unified.shape)  # (1,)\n\n    See Also:\n        - unify_controls(): Factory function for creating UnifiedControl from Control list\n        - Control: Individual symbolic control variable\n        - UnifiedState: Analogous unified state vector\n    \"\"\"\n\n    name: str\n    shape: tuple\n    min: Optional[np.ndarray] = None\n    max: Optional[np.ndarray] = None\n    guess: Optional[np.ndarray] = None\n    _true_dim: int = 0\n    _true_slice: Optional[slice] = None\n    _augmented_slice: Optional[slice] = None\n    time_dilation_slice: Optional[slice] = None  # Slice for time dilation control\n    scaling_min: Optional[np.ndarray] = None  # Scaling minimum bounds for unified control\n    scaling_max: Optional[np.ndarray] = None  # Scaling maximum bounds for unified control\n\n    def __post_init__(self):\n        \"\"\"Initialize slices after dataclass creation.\"\"\"\n        if self._true_slice is None:\n            self._true_slice = slice(0, self._true_dim)\n        if self._augmented_slice is None:\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    @property\n    def true(self) -&gt; \"UnifiedControl\":\n        \"\"\"Get the true (user-defined) control variables.\n\n        Returns a view of the unified control containing only user-defined controls,\n        excluding internal augmented controls added for time dilation, etc.\n\n        Returns:\n            UnifiedControl: Sliced view containing only true control variables\n\n        Example:\n            Get true user defined controls::\n\n                unified = unify_controls([thrust, torque, time_dilation], name=\"u\")\n                true_controls = unified.true  # Only thrust and torque\n        \"\"\"\n        return self[self._true_slice]\n\n    @property\n    def augmented(self) -&gt; \"UnifiedControl\":\n        \"\"\"Get the augmented (internal) control variables.\n\n        Returns a view of the unified control containing only augmented controls\n        added internally by the optimization framework (e.g., time dilation control).\n\n        Returns:\n            UnifiedControl: Sliced view containing only augmented control variables\n\n        Example:\n            Get augmented controls::\n\n                unified = unify_controls([thrust, time_dilation], name=\"u\")\n                aug_controls = unified.augmented  # Only time dilation\n        \"\"\"\n        return self[self._augmented_slice]\n\n    def append(\n        self,\n        other: \"Optional[Control | UnifiedControl]\" = None,\n        *,\n        min=-np.inf,\n        max=np.inf,\n        guess=0.0,\n        augmented=False,\n    ):\n        \"\"\"Append another control or create a new control variable.\n\n        This method allows dynamic extension of the unified control, either by appending\n        another Control/UnifiedControl object or by creating a new scalar control variable\n        with specified properties. Modifies the unified control in-place.\n\n        Args:\n            other (Optional[Control | UnifiedControl]): Control object to append. If None,\n                creates a new scalar control variable with properties from keyword args.\n            min (float): Lower bound for new scalar control (default: -inf)\n            max (float): Upper bound for new scalar control (default: inf)\n            guess (float): Initial guess value for new scalar control (default: 0.0)\n            augmented (bool): Whether the appended control is augmented (internal) rather\n                than true (user-defined). Affects _true_dim tracking. Default: False\n\n        Returns:\n            None: Modifies the unified control in-place\n\n        Example:\n            Appending a Control object::\n\n                unified = unify_controls([thrust], name=\"u\")\n                torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n                unified.append(torque)\n                print(unified.shape)  # (6,) - thrust (3) + torque (3)\n\n            Creating new scalar control variables::\n\n                unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\n                unified.append(min=-1, max=1, guess=0.0)  # Add scalar control\n                print(unified.shape)  # (1,)\n        \"\"\"\n        # Import here to avoid circular imports at module level\n        from openscvx.symbolic.expr.control import Control\n\n        if isinstance(other, (Control, UnifiedControl)):\n            # Append another control object\n            new_shape = (self.shape[0] + other.shape[0],)\n\n            # Update bounds\n            if self.min is not None and other.min is not None:\n                new_min = np.concatenate([self.min, other.min])\n            else:\n                new_min = self.min\n\n            if self.max is not None and other.max is not None:\n                new_max = np.concatenate([self.max, other.max])\n            else:\n                new_max = self.max\n\n            # Update guess\n            if self.guess is not None and other.guess is not None:\n                new_guess = np.concatenate([self.guess, other.guess], axis=1)\n            else:\n                new_guess = self.guess\n\n            # Update scaling bounds (if present)\n            if (\n                self.scaling_min is not None\n                and hasattr(other, \"scaling_min\")\n                and other.scaling_min is not None\n            ):\n                new_scaling_min = np.concatenate([self.scaling_min, other.scaling_min])\n            else:\n                new_scaling_min = self.scaling_min\n\n            if (\n                self.scaling_max is not None\n                and hasattr(other, \"scaling_max\")\n                and other.scaling_max is not None\n            ):\n                new_scaling_max = np.concatenate([self.scaling_max, other.scaling_max])\n            else:\n                new_scaling_max = self.scaling_max\n\n            # Update true dimension\n            if not augmented:\n                new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n            else:\n                new_true_dim = self._true_dim\n\n            # Update all attributes in place\n            self.shape = new_shape\n            self.min = new_min\n            self.max = new_max\n            self.guess = new_guess\n            self.scaling_min = new_scaling_min\n            self.scaling_max = new_scaling_max\n            self._true_dim = new_true_dim\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n        else:\n            # Create a single new variable\n            new_shape = (self.shape[0] + 1,)\n\n            # Extend arrays\n            if self.min is not None:\n                self.min = np.concatenate([self.min, np.array([min])])\n            if self.max is not None:\n                self.max = np.concatenate([self.max, np.array([max])])\n            if self.guess is not None:\n                guess_arr = np.full((self.guess.shape[0], 1), guess)\n                self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n            if self.scaling_min is not None:\n                self.scaling_min = np.concatenate([self.scaling_min, np.array([min])])\n            if self.scaling_max is not None:\n                self.scaling_max = np.concatenate([self.scaling_max, np.array([max])])\n\n            # Update dimensions\n            self.shape = new_shape\n            if not augmented:\n                self._true_dim += 1\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    def __getitem__(self, idx):\n        \"\"\"Get a subset of the unified control variables.\n\n        Enables slicing of the unified control to extract subsets of control variables.\n        Returns a new UnifiedControl containing only the sliced dimensions.\n\n        Args:\n            idx (slice): Slice object specifying which control dimensions to extract.\n                Only simple slices with step=1 are supported.\n\n        Returns:\n            UnifiedControl: New unified control containing only the sliced dimensions\n\n        Raises:\n            NotImplementedError: If idx is not a slice, or if step != 1\n\n        Example:\n            Generate unified control object::\n\n                unified = unify_controls([thrust, torque], name=\"u\")\n\n            thrust has shape (3,), torque has shape (3,)::\n\n                first_three = unified[0:3]  # Extract thrust only\n                print(first_three.shape)  # (3,)\n\n        Note:\n            The sliced control maintains all properties (bounds, guesses, etc.) for\n            the selected dimensions. The _true_dim is recalculated based on which\n            dimensions fall within the original true control range.\n        \"\"\"\n        if isinstance(idx, slice):\n            start, stop, step = idx.indices(self.shape[0])\n            if step != 1:\n                raise NotImplementedError(\"Step slicing not supported\")\n\n            new_shape = (stop - start,)\n            new_name = f\"{self.name}[{start}:{stop}]\"\n\n            # Slice all arrays\n            new_min = self.min[idx] if self.min is not None else None\n            new_max = self.max[idx] if self.max is not None else None\n            new_guess = self.guess[:, idx] if self.guess is not None else None\n\n            # Calculate new true dimension\n            new_true_dim = max(0, min(stop, self._true_dim) - max(start, 0))\n\n            return UnifiedControl(\n                name=new_name,\n                shape=new_shape,\n                min=new_min,\n                max=new_max,\n                guess=new_guess,\n                _true_dim=new_true_dim,\n                _true_slice=slice(0, new_true_dim),\n                _augmented_slice=slice(new_true_dim, new_shape[0]),\n            )\n        else:\n            raise NotImplementedError(\"Only slice indexing is supported\")\n\n    def __repr__(self):\n        \"\"\"String representation of the UnifiedControl object.\"\"\"\n        return f\"UnifiedControl('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.UnifiedControl.augmented","title":"<code>augmented: UnifiedControl</code>  <code>property</code>","text":"<p>Get the augmented (internal) control variables.</p> <p>Returns a view of the unified control containing only augmented controls added internally by the optimization framework (e.g., time dilation control).</p> <p>Returns:</p> Name Type Description <code>UnifiedControl</code> <code>UnifiedControl</code> <p>Sliced view containing only augmented control variables</p> Example <p>Get augmented controls::</p> <pre><code>unified = unify_controls([thrust, time_dilation], name=\"u\")\naug_controls = unified.augmented  # Only time dilation\n</code></pre>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.UnifiedControl.true","title":"<code>true: UnifiedControl</code>  <code>property</code>","text":"<p>Get the true (user-defined) control variables.</p> <p>Returns a view of the unified control containing only user-defined controls, excluding internal augmented controls added for time dilation, etc.</p> <p>Returns:</p> Name Type Description <code>UnifiedControl</code> <code>UnifiedControl</code> <p>Sliced view containing only true control variables</p> Example <p>Get true user defined controls::</p> <pre><code>unified = unify_controls([thrust, torque, time_dilation], name=\"u\")\ntrue_controls = unified.true  # Only thrust and torque\n</code></pre>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.UnifiedControl.append","title":"<code>append(other: Optional[Control | UnifiedControl] = None, *, min=-np.inf, max=np.inf, guess=0.0, augmented=False)</code>","text":"<p>Append another control or create a new control variable.</p> <p>This method allows dynamic extension of the unified control, either by appending another Control/UnifiedControl object or by creating a new scalar control variable with specified properties. Modifies the unified control in-place.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Optional[Control | UnifiedControl]</code> <p>Control object to append. If None, creates a new scalar control variable with properties from keyword args.</p> <code>None</code> <code>min</code> <code>float</code> <p>Lower bound for new scalar control (default: -inf)</p> <code>-inf</code> <code>max</code> <code>float</code> <p>Upper bound for new scalar control (default: inf)</p> <code>inf</code> <code>guess</code> <code>float</code> <p>Initial guess value for new scalar control (default: 0.0)</p> <code>0.0</code> <code>augmented</code> <code>bool</code> <p>Whether the appended control is augmented (internal) rather than true (user-defined). Affects _true_dim tracking. Default: False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <p>Modifies the unified control in-place</p> Example <p>Appending a Control object::</p> <pre><code>unified = unify_controls([thrust], name=\"u\")\ntorque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\nunified.append(torque)\nprint(unified.shape)  # (6,) - thrust (3) + torque (3)\n</code></pre> <p>Creating new scalar control variables::</p> <pre><code>unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.0)  # Add scalar control\nprint(unified.shape)  # (1,)\n</code></pre> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>def append(\n    self,\n    other: \"Optional[Control | UnifiedControl]\" = None,\n    *,\n    min=-np.inf,\n    max=np.inf,\n    guess=0.0,\n    augmented=False,\n):\n    \"\"\"Append another control or create a new control variable.\n\n    This method allows dynamic extension of the unified control, either by appending\n    another Control/UnifiedControl object or by creating a new scalar control variable\n    with specified properties. Modifies the unified control in-place.\n\n    Args:\n        other (Optional[Control | UnifiedControl]): Control object to append. If None,\n            creates a new scalar control variable with properties from keyword args.\n        min (float): Lower bound for new scalar control (default: -inf)\n        max (float): Upper bound for new scalar control (default: inf)\n        guess (float): Initial guess value for new scalar control (default: 0.0)\n        augmented (bool): Whether the appended control is augmented (internal) rather\n            than true (user-defined). Affects _true_dim tracking. Default: False\n\n    Returns:\n        None: Modifies the unified control in-place\n\n    Example:\n        Appending a Control object::\n\n            unified = unify_controls([thrust], name=\"u\")\n            torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n            unified.append(torque)\n            print(unified.shape)  # (6,) - thrust (3) + torque (3)\n\n        Creating new scalar control variables::\n\n            unified = UnifiedControl(name=\"u\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.0)  # Add scalar control\n            print(unified.shape)  # (1,)\n    \"\"\"\n    # Import here to avoid circular imports at module level\n    from openscvx.symbolic.expr.control import Control\n\n    if isinstance(other, (Control, UnifiedControl)):\n        # Append another control object\n        new_shape = (self.shape[0] + other.shape[0],)\n\n        # Update bounds\n        if self.min is not None and other.min is not None:\n            new_min = np.concatenate([self.min, other.min])\n        else:\n            new_min = self.min\n\n        if self.max is not None and other.max is not None:\n            new_max = np.concatenate([self.max, other.max])\n        else:\n            new_max = self.max\n\n        # Update guess\n        if self.guess is not None and other.guess is not None:\n            new_guess = np.concatenate([self.guess, other.guess], axis=1)\n        else:\n            new_guess = self.guess\n\n        # Update scaling bounds (if present)\n        if (\n            self.scaling_min is not None\n            and hasattr(other, \"scaling_min\")\n            and other.scaling_min is not None\n        ):\n            new_scaling_min = np.concatenate([self.scaling_min, other.scaling_min])\n        else:\n            new_scaling_min = self.scaling_min\n\n        if (\n            self.scaling_max is not None\n            and hasattr(other, \"scaling_max\")\n            and other.scaling_max is not None\n        ):\n            new_scaling_max = np.concatenate([self.scaling_max, other.scaling_max])\n        else:\n            new_scaling_max = self.scaling_max\n\n        # Update true dimension\n        if not augmented:\n            new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n        else:\n            new_true_dim = self._true_dim\n\n        # Update all attributes in place\n        self.shape = new_shape\n        self.min = new_min\n        self.max = new_max\n        self.guess = new_guess\n        self.scaling_min = new_scaling_min\n        self.scaling_max = new_scaling_max\n        self._true_dim = new_true_dim\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    else:\n        # Create a single new variable\n        new_shape = (self.shape[0] + 1,)\n\n        # Extend arrays\n        if self.min is not None:\n            self.min = np.concatenate([self.min, np.array([min])])\n        if self.max is not None:\n            self.max = np.concatenate([self.max, np.array([max])])\n        if self.guess is not None:\n            guess_arr = np.full((self.guess.shape[0], 1), guess)\n            self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n        if self.scaling_min is not None:\n            self.scaling_min = np.concatenate([self.scaling_min, np.array([min])])\n        if self.scaling_max is not None:\n            self.scaling_max = np.concatenate([self.scaling_max, np.array([max])])\n\n        # Update dimensions\n        self.shape = new_shape\n        if not augmented:\n            self._true_dim += 1\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n</code></pre>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.UnifiedState","title":"<code>UnifiedState</code>  <code>dataclass</code>","text":"<p>Unified state vector aggregating multiple State objects.</p> <p>UnifiedState is a drop-in replacement for individual State objects that holds aggregated data from multiple State instances. It maintains compatibility with optimization infrastructure while providing access to individual state components through slicing.</p> <p>The unified state separates user-defined \"true\" states from augmented states added internally (e.g., for CTCS constraints or time variables). This separation allows clean access to physical states while supporting advanced features.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the unified state vector</p> <code>shape</code> <code>tuple</code> <p>Combined shape (total_dim,) of all aggregated states</p> <code>min</code> <code>ndarray</code> <p>Lower bounds for all state variables, shape (total_dim,)</p> <code>max</code> <code>ndarray</code> <p>Upper bounds for all state variables, shape (total_dim,)</p> <code>guess</code> <code>ndarray</code> <p>Initial guess trajectory, shape (num_nodes, total_dim)</p> <code>initial</code> <code>ndarray</code> <p>Initial boundary conditions, shape (total_dim,)</p> <code>final</code> <code>ndarray</code> <p>Final boundary conditions, shape (total_dim,)</p> <code>_initial</code> <code>ndarray</code> <p>Internal initial values, shape (total_dim,)</p> <code>_final</code> <code>ndarray</code> <p>Internal final values, shape (total_dim,)</p> <code>initial_type</code> <code>ndarray</code> <p>Boundary condition types at t0 (\"Fix\" or \"Free\"), shape (total_dim,), dtype=object</p> <code>final_type</code> <code>ndarray</code> <p>Boundary condition types at tf (\"Fix\" or \"Free\"), shape (total_dim,), dtype=object</p> <code>_true_dim</code> <code>int</code> <p>Number of user-defined state dimensions (excludes augmented)</p> <code>_true_slice</code> <code>slice</code> <p>Slice for extracting true states from unified vector</p> <code>_augmented_slice</code> <code>slice</code> <p>Slice for extracting augmented states</p> <code>time_slice</code> <code>Optional[slice]</code> <p>Slice for time state variable, if present</p> <code>ctcs_slice</code> <code>Optional[slice]</code> <p>Slice for CTCS augmented states, if present</p> Properties <p>true: Returns UnifiedState view containing only true (user-defined) states augmented: Returns UnifiedState view containing only augmented states</p> Example <p>Creating a unified state from multiple State objects::</p> <pre><code>from openscvx.symbolic.unified import unify_states\n\nposition = ox.State(\"pos\", shape=(3,), min=-10, max=10)\nvelocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n\nunified = unify_states([position, velocity], name=\"x\")\nprint(unified.shape)        # (6,)\nprint(unified.min)          # [-10, -10, -10, -5, -5, -5]\nprint(unified.true.shape)   # (6,) - all are true states\nprint(unified.augmented.shape)  # (0,) - no augmented states\n</code></pre> <p>Appending states dynamically::</p> <pre><code>unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.5)  # Add scalar state\nprint(unified.shape)  # (1,)\n</code></pre> See Also <ul> <li>unify_states(): Factory function for creating UnifiedState from State list</li> <li>State: Individual symbolic state variable</li> <li>UnifiedControl: Analogous unified control vector</li> </ul> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>@dataclass\nclass UnifiedState:\n    \"\"\"Unified state vector aggregating multiple State objects.\n\n    UnifiedState is a drop-in replacement for individual State objects that holds\n    aggregated data from multiple State instances. It maintains compatibility with\n    optimization infrastructure while providing access to individual state components\n    through slicing.\n\n    The unified state separates user-defined \"true\" states from augmented states\n    added internally (e.g., for CTCS constraints or time variables). This separation\n    allows clean access to physical states while supporting advanced features.\n\n    Attributes:\n        name (str): Name identifier for the unified state vector\n        shape (tuple): Combined shape (total_dim,) of all aggregated states\n        min (np.ndarray): Lower bounds for all state variables, shape (total_dim,)\n        max (np.ndarray): Upper bounds for all state variables, shape (total_dim,)\n        guess (np.ndarray): Initial guess trajectory, shape (num_nodes, total_dim)\n        initial (np.ndarray): Initial boundary conditions, shape (total_dim,)\n        final (np.ndarray): Final boundary conditions, shape (total_dim,)\n        _initial (np.ndarray): Internal initial values, shape (total_dim,)\n        _final (np.ndarray): Internal final values, shape (total_dim,)\n        initial_type (np.ndarray): Boundary condition types at t0 (\"Fix\" or \"Free\"),\n            shape (total_dim,), dtype=object\n        final_type (np.ndarray): Boundary condition types at tf (\"Fix\" or \"Free\"),\n            shape (total_dim,), dtype=object\n        _true_dim (int): Number of user-defined state dimensions (excludes augmented)\n        _true_slice (slice): Slice for extracting true states from unified vector\n        _augmented_slice (slice): Slice for extracting augmented states\n        time_slice (Optional[slice]): Slice for time state variable, if present\n        ctcs_slice (Optional[slice]): Slice for CTCS augmented states, if present\n\n    Properties:\n        true: Returns UnifiedState view containing only true (user-defined) states\n        augmented: Returns UnifiedState view containing only augmented states\n\n    Example:\n        Creating a unified state from multiple State objects::\n\n            from openscvx.symbolic.unified import unify_states\n\n            position = ox.State(\"pos\", shape=(3,), min=-10, max=10)\n            velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n\n            unified = unify_states([position, velocity], name=\"x\")\n            print(unified.shape)        # (6,)\n            print(unified.min)          # [-10, -10, -10, -5, -5, -5]\n            print(unified.true.shape)   # (6,) - all are true states\n            print(unified.augmented.shape)  # (0,) - no augmented states\n\n        Appending states dynamically::\n\n            unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.5)  # Add scalar state\n            print(unified.shape)  # (1,)\n\n    See Also:\n        - unify_states(): Factory function for creating UnifiedState from State list\n        - State: Individual symbolic state variable\n        - UnifiedControl: Analogous unified control vector\n    \"\"\"\n\n    name: str\n    shape: tuple\n    min: Optional[np.ndarray] = None\n    max: Optional[np.ndarray] = None\n    guess: Optional[np.ndarray] = None\n    initial: Optional[np.ndarray] = None\n    final: Optional[np.ndarray] = None\n    _initial: Optional[np.ndarray] = None\n    _final: Optional[np.ndarray] = None\n    initial_type: Optional[np.ndarray] = None\n    final_type: Optional[np.ndarray] = None\n    _true_dim: int = 0\n    _true_slice: Optional[slice] = None\n    _augmented_slice: Optional[slice] = None\n    time_slice: Optional[slice] = None  # Slice for time state\n    ctcs_slice: Optional[slice] = None  # Slice for CTCS augmented states\n    scaling_min: Optional[np.ndarray] = None  # Scaling minimum bounds for unified state\n    scaling_max: Optional[np.ndarray] = None  # Scaling maximum bounds for unified state\n\n    def __post_init__(self):\n        \"\"\"Initialize slices after dataclass creation.\"\"\"\n        if self._true_slice is None:\n            self._true_slice = slice(0, self._true_dim)\n        if self._augmented_slice is None:\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    @property\n    def true(self) -&gt; \"UnifiedState\":\n        \"\"\"Get the true (user-defined) state variables.\n\n        Returns a view of the unified state containing only user-defined states,\n        excluding internal augmented states added for CTCS, time, etc.\n\n        Returns:\n            UnifiedState: Sliced view containing only true state variables\n\n        Example:\n            Get true user-defined state::\n\n                unified = unify_states([position, velocity, ctcs_aug], name=\"x\")\n                true_states = unified.true  # Only position and velocity\n                true_states.shape  # (6,) if position and velocity are 3D each\n        \"\"\"\n        return self[self._true_slice]\n\n    @property\n    def augmented(self) -&gt; \"UnifiedState\":\n        \"\"\"Get the augmented (internal) state variables.\n\n        Returns a view of the unified state containing only augmented states\n        added internally by the optimization framework (e.g., CTCS penalty states,\n        time variables).\n\n        Returns:\n            UnifiedState: Sliced view containing only augmented state variables\n\n        Example:\n            Get augmented state::\n\n                unified = unify_states([position, ctcs_aug], name=\"x\")\n                aug_states = unified.augmented  # Only CTCS states\n        \"\"\"\n        return self[self._augmented_slice]\n\n    def append(\n        self,\n        other: \"Optional[State | UnifiedState]\" = None,\n        *,\n        min=-np.inf,\n        max=np.inf,\n        guess=0.0,\n        initial=0.0,\n        final=0.0,\n        augmented=False,\n    ):\n        \"\"\"Append another state or create a new state variable.\n\n        This method allows dynamic extension of the unified state, either by appending\n        another State/UnifiedState object or by creating a new scalar state variable\n        with specified properties. Modifies the unified state in-place.\n\n        Args:\n            other (Optional[State | UnifiedState]): State object to append. If None,\n                creates a new scalar state variable with properties from keyword args.\n            min (float): Lower bound for new scalar state (default: -inf)\n            max (float): Upper bound for new scalar state (default: inf)\n            guess (float): Initial guess value for new scalar state (default: 0.0)\n            initial (float): Initial boundary condition for new scalar state (default: 0.0)\n            final (float): Final boundary condition for new scalar state (default: 0.0)\n            augmented (bool): Whether the appended state is augmented (internal) rather\n                than true (user-defined). Affects _true_dim tracking. Default: False\n\n        Returns:\n            None: Modifies the unified state in-place\n\n        Example:\n            Appending a State object::\n\n                unified = unify_states([position], name=\"x\")\n                velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n                unified.append(velocity)\n                print(unified.shape)  # (6,) - position (3) + velocity (3)\n\n            Creating new scalar state variables::\n\n                unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\n                unified.append(min=-1, max=1, guess=0.5)  # Add scalar state\n                unified.append(min=-2, max=2, augmented=True)  # Add augmented state\n                print(unified.shape)  # (2,)\n                print(unified._true_dim)  # 1 (only first is true)\n\n        Note:\n            Maintains the invariant that true states appear before augmented states\n            in the unified vector. When appending augmented states, they are added\n            to the end but don't increment _true_dim.\n        \"\"\"\n        # Import here to avoid circular imports at module level\n        from openscvx.symbolic.expr.state import State\n\n        if isinstance(other, (State, UnifiedState)):\n            # Append another state object\n            new_shape = (self.shape[0] + other.shape[0],)\n\n            # Update bounds\n            if self.min is not None and other.min is not None:\n                new_min = np.concatenate([self.min, other.min])\n            else:\n                new_min = self.min\n\n            if self.max is not None and other.max is not None:\n                new_max = np.concatenate([self.max, other.max])\n            else:\n                new_max = self.max\n\n            # Update guess\n            if self.guess is not None and other.guess is not None:\n                new_guess = np.concatenate([self.guess, other.guess], axis=1)\n            else:\n                new_guess = self.guess\n\n            # Update initial/final conditions\n            if self.initial is not None and other.initial is not None:\n                new_initial = np.concatenate([self.initial, other.initial])\n            else:\n                new_initial = self.initial\n\n            if self.final is not None and other.final is not None:\n                new_final = np.concatenate([self.final, other.final])\n            else:\n                new_final = self.final\n\n            # Update internal arrays\n            if self._initial is not None and other._initial is not None:\n                new__initial = np.concatenate([self._initial, other._initial])\n            else:\n                new__initial = self._initial\n\n            if self._final is not None and other._final is not None:\n                new__final = np.concatenate([self._final, other._final])\n            else:\n                new__final = self._final\n\n            # Update types\n            if self.initial_type is not None and other.initial_type is not None:\n                new_initial_type = np.concatenate([self.initial_type, other.initial_type])\n            else:\n                new_initial_type = self.initial_type\n\n            if self.final_type is not None and other.final_type is not None:\n                new_final_type = np.concatenate([self.final_type, other.final_type])\n            else:\n                new_final_type = self.final_type\n\n            # Update scaling bounds (if present)\n            if (\n                self.scaling_min is not None\n                and hasattr(other, \"scaling_min\")\n                and other.scaling_min is not None\n            ):\n                new_scaling_min = np.concatenate([self.scaling_min, other.scaling_min])\n            else:\n                new_scaling_min = self.scaling_min\n\n            if (\n                self.scaling_max is not None\n                and hasattr(other, \"scaling_max\")\n                and other.scaling_max is not None\n            ):\n                new_scaling_max = np.concatenate([self.scaling_max, other.scaling_max])\n            else:\n                new_scaling_max = self.scaling_max\n\n            # Update true dimension\n            if not augmented:\n                new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n            else:\n                new_true_dim = self._true_dim\n\n            # Update all attributes in place\n            self.shape = new_shape\n            self.min = new_min\n            self.max = new_max\n            self.guess = new_guess\n            self.initial = new_initial\n            self.final = new_final\n            self._initial = new__initial\n            self._final = new__final\n            self.initial_type = new_initial_type\n            self.final_type = new_final_type\n            self.scaling_min = new_scaling_min\n            self.scaling_max = new_scaling_max\n            self._true_dim = new_true_dim\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n        else:\n            # Create a single new variable\n            new_shape = (self.shape[0] + 1,)\n\n            # Extend arrays\n            if self.min is not None:\n                self.min = np.concatenate([self.min, np.array([min])])\n            if self.max is not None:\n                self.max = np.concatenate([self.max, np.array([max])])\n            if self.guess is not None:\n                guess_arr = np.full((self.guess.shape[0], 1), guess)\n                self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n            if self.initial is not None:\n                self.initial = np.concatenate([self.initial, np.array([initial])])\n            if self.final is not None:\n                self.final = np.concatenate([self.final, np.array([final])])\n            if self._initial is not None:\n                self._initial = np.concatenate([self._initial, np.array([initial])])\n            if self._final is not None:\n                self._final = np.concatenate([self._final, np.array([final])])\n            if self.initial_type is not None:\n                self.initial_type = np.concatenate(\n                    [self.initial_type, np.array([\"Fix\"], dtype=object)]\n                )\n            if self.final_type is not None:\n                self.final_type = np.concatenate([self.final_type, np.array([\"Fix\"], dtype=object)])\n            if self.scaling_min is not None:\n                self.scaling_min = np.concatenate([self.scaling_min, np.array([min])])\n            if self.scaling_max is not None:\n                self.scaling_max = np.concatenate([self.scaling_max, np.array([max])])\n\n            # Update dimensions\n            self.shape = new_shape\n            if not augmented:\n                self._true_dim += 1\n            self._true_slice = slice(0, self._true_dim)\n            self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    def __getitem__(self, idx):\n        \"\"\"Get a subset of the unified state variables.\n\n        Enables slicing of the unified state to extract subsets of state variables.\n        Returns a new UnifiedState containing only the sliced dimensions.\n\n        Args:\n            idx (slice): Slice object specifying which state dimensions to extract.\n                Only simple slices with step=1 are supported.\n\n        Returns:\n            UnifiedState: New unified state containing only the sliced dimensions\n\n        Raises:\n            NotImplementedError: If idx is not a slice, or if step != 1\n\n        Example:\n            Generate unified state object::\n\n                unified = unify_states([position, velocity], name=\"x\")\n\n            position has shape (3,), velocity has shape (3,)::\n\n                first_three = unified[0:3]  # Extract position only\n                print(first_three.shape)  # (3,)\n                last_three = unified[3:6]  # Extract velocity only\n                print(last_three.shape)  # (3,)\n\n        Note:\n            The sliced state maintains all properties (bounds, guesses, etc.) for\n            the selected dimensions. The _true_dim is recalculated based on which\n            dimensions fall within the original true state range.\n        \"\"\"\n        if isinstance(idx, slice):\n            start, stop, step = idx.indices(self.shape[0])\n            if step != 1:\n                raise NotImplementedError(\"Step slicing not supported\")\n\n            new_shape = (stop - start,)\n            new_name = f\"{self.name}[{start}:{stop}]\"\n\n            # Slice all arrays\n            new_min = self.min[idx] if self.min is not None else None\n            new_max = self.max[idx] if self.max is not None else None\n            new_guess = self.guess[:, idx] if self.guess is not None else None\n            new_initial = self.initial[idx] if self.initial is not None else None\n            new_final = self.final[idx] if self.final is not None else None\n            new__initial = self._initial[idx] if self._initial is not None else None\n            new__final = self._final[idx] if self._final is not None else None\n            new_initial_type = self.initial_type[idx] if self.initial_type is not None else None\n            new_final_type = self.final_type[idx] if self.final_type is not None else None\n\n            # Calculate new true dimension\n            new_true_dim = max(0, min(stop, self._true_dim) - max(start, 0))\n\n            return UnifiedState(\n                name=new_name,\n                shape=new_shape,\n                min=new_min,\n                max=new_max,\n                guess=new_guess,\n                initial=new_initial,\n                final=new_final,\n                _initial=new__initial,\n                _final=new__final,\n                initial_type=new_initial_type,\n                final_type=new_final_type,\n                _true_dim=new_true_dim,\n                _true_slice=slice(0, new_true_dim),\n                _augmented_slice=slice(new_true_dim, new_shape[0]),\n            )\n        else:\n            raise NotImplementedError(\"Only slice indexing is supported\")\n\n    def __repr__(self):\n        \"\"\"String representation of the UnifiedState object.\"\"\"\n        return f\"UnifiedState('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.UnifiedState.augmented","title":"<code>augmented: UnifiedState</code>  <code>property</code>","text":"<p>Get the augmented (internal) state variables.</p> <p>Returns a view of the unified state containing only augmented states added internally by the optimization framework (e.g., CTCS penalty states, time variables).</p> <p>Returns:</p> Name Type Description <code>UnifiedState</code> <code>UnifiedState</code> <p>Sliced view containing only augmented state variables</p> Example <p>Get augmented state::</p> <pre><code>unified = unify_states([position, ctcs_aug], name=\"x\")\naug_states = unified.augmented  # Only CTCS states\n</code></pre>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.UnifiedState.true","title":"<code>true: UnifiedState</code>  <code>property</code>","text":"<p>Get the true (user-defined) state variables.</p> <p>Returns a view of the unified state containing only user-defined states, excluding internal augmented states added for CTCS, time, etc.</p> <p>Returns:</p> Name Type Description <code>UnifiedState</code> <code>UnifiedState</code> <p>Sliced view containing only true state variables</p> Example <p>Get true user-defined state::</p> <pre><code>unified = unify_states([position, velocity, ctcs_aug], name=\"x\")\ntrue_states = unified.true  # Only position and velocity\ntrue_states.shape  # (6,) if position and velocity are 3D each\n</code></pre>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.UnifiedState.append","title":"<code>append(other: Optional[State | UnifiedState] = None, *, min=-np.inf, max=np.inf, guess=0.0, initial=0.0, final=0.0, augmented=False)</code>","text":"<p>Append another state or create a new state variable.</p> <p>This method allows dynamic extension of the unified state, either by appending another State/UnifiedState object or by creating a new scalar state variable with specified properties. Modifies the unified state in-place.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Optional[State | UnifiedState]</code> <p>State object to append. If None, creates a new scalar state variable with properties from keyword args.</p> <code>None</code> <code>min</code> <code>float</code> <p>Lower bound for new scalar state (default: -inf)</p> <code>-inf</code> <code>max</code> <code>float</code> <p>Upper bound for new scalar state (default: inf)</p> <code>inf</code> <code>guess</code> <code>float</code> <p>Initial guess value for new scalar state (default: 0.0)</p> <code>0.0</code> <code>initial</code> <code>float</code> <p>Initial boundary condition for new scalar state (default: 0.0)</p> <code>0.0</code> <code>final</code> <code>float</code> <p>Final boundary condition for new scalar state (default: 0.0)</p> <code>0.0</code> <code>augmented</code> <code>bool</code> <p>Whether the appended state is augmented (internal) rather than true (user-defined). Affects _true_dim tracking. Default: False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <p>Modifies the unified state in-place</p> Example <p>Appending a State object::</p> <pre><code>unified = unify_states([position], name=\"x\")\nvelocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\nunified.append(velocity)\nprint(unified.shape)  # (6,) - position (3) + velocity (3)\n</code></pre> <p>Creating new scalar state variables::</p> <pre><code>unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\nunified.append(min=-1, max=1, guess=0.5)  # Add scalar state\nunified.append(min=-2, max=2, augmented=True)  # Add augmented state\nprint(unified.shape)  # (2,)\nprint(unified._true_dim)  # 1 (only first is true)\n</code></pre> Note <p>Maintains the invariant that true states appear before augmented states in the unified vector. When appending augmented states, they are added to the end but don't increment _true_dim.</p> Source code in <code>openscvx/lowered/unified.py</code> <pre><code>def append(\n    self,\n    other: \"Optional[State | UnifiedState]\" = None,\n    *,\n    min=-np.inf,\n    max=np.inf,\n    guess=0.0,\n    initial=0.0,\n    final=0.0,\n    augmented=False,\n):\n    \"\"\"Append another state or create a new state variable.\n\n    This method allows dynamic extension of the unified state, either by appending\n    another State/UnifiedState object or by creating a new scalar state variable\n    with specified properties. Modifies the unified state in-place.\n\n    Args:\n        other (Optional[State | UnifiedState]): State object to append. If None,\n            creates a new scalar state variable with properties from keyword args.\n        min (float): Lower bound for new scalar state (default: -inf)\n        max (float): Upper bound for new scalar state (default: inf)\n        guess (float): Initial guess value for new scalar state (default: 0.0)\n        initial (float): Initial boundary condition for new scalar state (default: 0.0)\n        final (float): Final boundary condition for new scalar state (default: 0.0)\n        augmented (bool): Whether the appended state is augmented (internal) rather\n            than true (user-defined). Affects _true_dim tracking. Default: False\n\n    Returns:\n        None: Modifies the unified state in-place\n\n    Example:\n        Appending a State object::\n\n            unified = unify_states([position], name=\"x\")\n            velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n            unified.append(velocity)\n            print(unified.shape)  # (6,) - position (3) + velocity (3)\n\n        Creating new scalar state variables::\n\n            unified = UnifiedState(name=\"x\", shape=(0,), _true_dim=0)\n            unified.append(min=-1, max=1, guess=0.5)  # Add scalar state\n            unified.append(min=-2, max=2, augmented=True)  # Add augmented state\n            print(unified.shape)  # (2,)\n            print(unified._true_dim)  # 1 (only first is true)\n\n    Note:\n        Maintains the invariant that true states appear before augmented states\n        in the unified vector. When appending augmented states, they are added\n        to the end but don't increment _true_dim.\n    \"\"\"\n    # Import here to avoid circular imports at module level\n    from openscvx.symbolic.expr.state import State\n\n    if isinstance(other, (State, UnifiedState)):\n        # Append another state object\n        new_shape = (self.shape[0] + other.shape[0],)\n\n        # Update bounds\n        if self.min is not None and other.min is not None:\n            new_min = np.concatenate([self.min, other.min])\n        else:\n            new_min = self.min\n\n        if self.max is not None and other.max is not None:\n            new_max = np.concatenate([self.max, other.max])\n        else:\n            new_max = self.max\n\n        # Update guess\n        if self.guess is not None and other.guess is not None:\n            new_guess = np.concatenate([self.guess, other.guess], axis=1)\n        else:\n            new_guess = self.guess\n\n        # Update initial/final conditions\n        if self.initial is not None and other.initial is not None:\n            new_initial = np.concatenate([self.initial, other.initial])\n        else:\n            new_initial = self.initial\n\n        if self.final is not None and other.final is not None:\n            new_final = np.concatenate([self.final, other.final])\n        else:\n            new_final = self.final\n\n        # Update internal arrays\n        if self._initial is not None and other._initial is not None:\n            new__initial = np.concatenate([self._initial, other._initial])\n        else:\n            new__initial = self._initial\n\n        if self._final is not None and other._final is not None:\n            new__final = np.concatenate([self._final, other._final])\n        else:\n            new__final = self._final\n\n        # Update types\n        if self.initial_type is not None and other.initial_type is not None:\n            new_initial_type = np.concatenate([self.initial_type, other.initial_type])\n        else:\n            new_initial_type = self.initial_type\n\n        if self.final_type is not None and other.final_type is not None:\n            new_final_type = np.concatenate([self.final_type, other.final_type])\n        else:\n            new_final_type = self.final_type\n\n        # Update scaling bounds (if present)\n        if (\n            self.scaling_min is not None\n            and hasattr(other, \"scaling_min\")\n            and other.scaling_min is not None\n        ):\n            new_scaling_min = np.concatenate([self.scaling_min, other.scaling_min])\n        else:\n            new_scaling_min = self.scaling_min\n\n        if (\n            self.scaling_max is not None\n            and hasattr(other, \"scaling_max\")\n            and other.scaling_max is not None\n        ):\n            new_scaling_max = np.concatenate([self.scaling_max, other.scaling_max])\n        else:\n            new_scaling_max = self.scaling_max\n\n        # Update true dimension\n        if not augmented:\n            new_true_dim = self._true_dim + getattr(other, \"_true_dim\", other.shape[0])\n        else:\n            new_true_dim = self._true_dim\n\n        # Update all attributes in place\n        self.shape = new_shape\n        self.min = new_min\n        self.max = new_max\n        self.guess = new_guess\n        self.initial = new_initial\n        self.final = new_final\n        self._initial = new__initial\n        self._final = new__final\n        self.initial_type = new_initial_type\n        self.final_type = new_final_type\n        self.scaling_min = new_scaling_min\n        self.scaling_max = new_scaling_max\n        self._true_dim = new_true_dim\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n\n    else:\n        # Create a single new variable\n        new_shape = (self.shape[0] + 1,)\n\n        # Extend arrays\n        if self.min is not None:\n            self.min = np.concatenate([self.min, np.array([min])])\n        if self.max is not None:\n            self.max = np.concatenate([self.max, np.array([max])])\n        if self.guess is not None:\n            guess_arr = np.full((self.guess.shape[0], 1), guess)\n            self.guess = np.concatenate([self.guess, guess_arr], axis=1)\n        if self.initial is not None:\n            self.initial = np.concatenate([self.initial, np.array([initial])])\n        if self.final is not None:\n            self.final = np.concatenate([self.final, np.array([final])])\n        if self._initial is not None:\n            self._initial = np.concatenate([self._initial, np.array([initial])])\n        if self._final is not None:\n            self._final = np.concatenate([self._final, np.array([final])])\n        if self.initial_type is not None:\n            self.initial_type = np.concatenate(\n                [self.initial_type, np.array([\"Fix\"], dtype=object)]\n            )\n        if self.final_type is not None:\n            self.final_type = np.concatenate([self.final_type, np.array([\"Fix\"], dtype=object)])\n        if self.scaling_min is not None:\n            self.scaling_min = np.concatenate([self.scaling_min, np.array([min])])\n        if self.scaling_max is not None:\n            self.scaling_max = np.concatenate([self.scaling_max, np.array([max])])\n\n        # Update dimensions\n        self.shape = new_shape\n        if not augmented:\n            self._true_dim += 1\n        self._true_slice = slice(0, self._true_dim)\n        self._augmented_slice = slice(self._true_dim, self.shape[0])\n</code></pre>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.unify_controls","title":"<code>unify_controls(controls: List[Control], name: str = 'unified_control') -&gt; UnifiedControl</code>","text":"<p>Create a UnifiedControl from a list of Control objects.</p> <p>This function is the primary way to aggregate multiple symbolic Control objects into a single unified control vector for numerical optimization. It:</p> <ol> <li>Sorts controls (user-defined first, augmented controls second)</li> <li>Concatenates all control properties (bounds, guesses)</li> <li>Assigns slices to each Control for extracting values from unified vector</li> <li>Identifies special controls (time dilation)</li> <li>Returns a UnifiedControl with all aggregated data</li> </ol> <p>Parameters:</p> Name Type Description Default <code>controls</code> <code>List[Control]</code> <p>List of Control objects to unify. Can include both user-defined controls and augmented controls (names starting with '_').</p> required <code>name</code> <code>str</code> <p>Name identifier for the unified control vector (default: \"unified_control\")</p> <code>'unified_control'</code> <p>Returns:</p> Name Type Description <code>UnifiedControl</code> <code>UnifiedControl</code> <p>Unified control object containing: - Aggregated bounds and guesses - Shape equal to sum of all control shapes - Slices for extracting individual control components - Properties for accessing true vs augmented controls</p> Example <p>Basic unification::</p> <pre><code>import openscvx as ox\nfrom openscvx.symbolic.unified import unify_controls\n\nthrust = ox.Control(\"thrust\", shape=(3,), min=0, max=10)\ntorque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n\nunified = unify_controls([thrust, torque], name=\"u\")\nprint(unified.shape)       # (6,)\nprint(unified._true_dim)   # 6 (all are user controls)\nprint(thrust._slice)       # slice(0, 3) - assigned during unification\nprint(torque._slice)       # slice(3, 6)\n</code></pre> <p>With augmented controls::</p> <pre><code># Time-optimal problems may add time dilation control\ntime_dilation = ox.Control(\"_time_dilation\", shape=(1,))\n\nunified = unify_controls([thrust, torque, time_dilation])\nprint(unified._true_dim)         # 6 (thrust + torque)\nprint(unified.true.shape)        # (6,)\nprint(unified.augmented.shape)   # (1,) - time dilation\n</code></pre> Note <p>After unification, each Control object has its <code>_slice</code> attribute set, which is used during JAX lowering to extract the correct values from the unified control vector.</p> See Also <ul> <li>UnifiedControl: Return type with detailed documentation</li> <li>unify_states(): Analogous function for State objects</li> <li>Control: Individual symbolic control variable</li> </ul> Source code in <code>openscvx/symbolic/unified.py</code> <pre><code>def unify_controls(controls: List[Control], name: str = \"unified_control\") -&gt; UnifiedControl:\n    \"\"\"Create a UnifiedControl from a list of Control objects.\n\n    This function is the primary way to aggregate multiple symbolic Control objects into\n    a single unified control vector for numerical optimization. It:\n\n    1. Sorts controls (user-defined first, augmented controls second)\n    2. Concatenates all control properties (bounds, guesses)\n    3. Assigns slices to each Control for extracting values from unified vector\n    4. Identifies special controls (time dilation)\n    5. Returns a UnifiedControl with all aggregated data\n\n    Args:\n        controls (List[Control]): List of Control objects to unify. Can include both\n            user-defined controls and augmented controls (names starting with '_').\n        name (str): Name identifier for the unified control vector (default: \"unified_control\")\n\n    Returns:\n        UnifiedControl: Unified control object containing:\n            - Aggregated bounds and guesses\n            - Shape equal to sum of all control shapes\n            - Slices for extracting individual control components\n            - Properties for accessing true vs augmented controls\n\n    Example:\n        Basic unification::\n\n            import openscvx as ox\n            from openscvx.symbolic.unified import unify_controls\n\n            thrust = ox.Control(\"thrust\", shape=(3,), min=0, max=10)\n            torque = ox.Control(\"torque\", shape=(3,), min=-1, max=1)\n\n            unified = unify_controls([thrust, torque], name=\"u\")\n            print(unified.shape)       # (6,)\n            print(unified._true_dim)   # 6 (all are user controls)\n            print(thrust._slice)       # slice(0, 3) - assigned during unification\n            print(torque._slice)       # slice(3, 6)\n\n        With augmented controls::\n\n            # Time-optimal problems may add time dilation control\n            time_dilation = ox.Control(\"_time_dilation\", shape=(1,))\n\n            unified = unify_controls([thrust, torque, time_dilation])\n            print(unified._true_dim)         # 6 (thrust + torque)\n            print(unified.true.shape)        # (6,)\n            print(unified.augmented.shape)   # (1,) - time dilation\n\n    Note:\n        After unification, each Control object has its `_slice` attribute set,\n        which is used during JAX lowering to extract the correct values from\n        the unified control vector.\n\n    See Also:\n        - UnifiedControl: Return type with detailed documentation\n        - unify_states(): Analogous function for State objects\n        - Control: Individual symbolic control variable\n    \"\"\"\n    if not controls:\n        return UnifiedControl(name=name, shape=(0,))\n\n    # Sort controls: true controls (not starting with '_') first, then augmented controls\n    # (starting with '_')\n    true_controls = [control for control in controls if not control.name.startswith(\"_\")]\n    augmented_controls = [control for control in controls if control.name.startswith(\"_\")]\n    sorted_controls = true_controls + augmented_controls\n\n    # Calculate total shape\n    total_shape = sum(control.shape[0] for control in sorted_controls)\n\n    # Concatenate all arrays, handling None values properly\n    min_arrays = []\n    max_arrays = []\n    guess_arrays = []\n\n    for control in sorted_controls:\n        if control.min is not None:\n            min_arrays.append(control.min)\n        else:\n            # If min is None, fill with -inf for this control's dimensions\n            min_arrays.append(np.full(control.shape[0], -np.inf))\n\n        if control.max is not None:\n            max_arrays.append(control.max)\n        else:\n            # If max is None, fill with +inf for this control's dimensions\n            max_arrays.append(np.full(control.shape[0], np.inf))\n\n        if control.guess is not None:\n            guess_arrays.append(control.guess)\n\n    # Concatenate arrays if they exist\n    unified_min = np.concatenate(min_arrays) if min_arrays else None\n    unified_max = np.concatenate(max_arrays) if max_arrays else None\n    unified_guess = np.concatenate(guess_arrays, axis=1) if guess_arrays else None\n\n    # Calculate true dimension (only from user-defined controls, not augmented ones)\n    # Since we simplified State/Control classes, all user controls are \"true\" dimensions\n    true_dim = sum(control.shape[0] for control in true_controls)\n\n    # Find time dilation control slice\n    time_dilation_control = next((c for c in sorted_controls if c.name == \"_time_dilation\"), None)\n    time_dilation_slice = time_dilation_control._slice if time_dilation_control else None\n\n    # Aggregate scaling_min and scaling_max from individual controls\n    # Build full arrays using scaling where available, min/max otherwise\n    unified_scaling_min = None\n    unified_scaling_max = None\n\n    # Check if any control has scaling\n    has_any_scaling = any(\n        control.scaling_min is not None or control.scaling_max is not None\n        for control in sorted_controls\n    )\n\n    if has_any_scaling:\n        # Build full scaling arrays\n        scaling_min_list = []\n        scaling_max_list = []\n        for control in sorted_controls:\n            if control.scaling_min is not None:\n                scaling_min_list.append(control.scaling_min)\n            else:\n                # Use min as fallback\n                if control.min is not None:\n                    scaling_min_list.append(control.min)\n                else:\n                    scaling_min_list.append(np.full(control.shape[0], -np.inf))\n\n            if control.scaling_max is not None:\n                scaling_max_list.append(control.scaling_max)\n            else:\n                # Use max as fallback\n                if control.max is not None:\n                    scaling_max_list.append(control.max)\n                else:\n                    scaling_max_list.append(np.full(control.shape[0], np.inf))\n\n        unified_scaling_min = np.concatenate(scaling_min_list)\n        unified_scaling_max = np.concatenate(scaling_max_list)\n\n    return UnifiedControl(\n        name=name,\n        shape=(total_shape,),\n        min=unified_min,\n        max=unified_max,\n        guess=unified_guess,\n        _true_dim=true_dim,\n        _true_slice=slice(0, true_dim),\n        _augmented_slice=slice(true_dim, total_shape),\n        time_dilation_slice=time_dilation_slice,\n        scaling_min=unified_scaling_min,\n        scaling_max=unified_scaling_max,\n    )\n</code></pre>"},{"location":"reference/symbolic/unified/#openscvx.symbolic.unified.unify_states","title":"<code>unify_states(states: List[State], name: str = 'unified_state') -&gt; UnifiedState</code>","text":"<p>Create a UnifiedState from a list of State objects.</p> <p>This function is the primary way to aggregate multiple symbolic State objects into a single unified state vector for numerical optimization. It:</p> <ol> <li>Sorts states (user-defined first, augmented states second)</li> <li>Concatenates all state properties (bounds, guesses, boundary conditions)</li> <li>Assigns slices to each State for extracting values from unified vector</li> <li>Identifies special states (time, CTCS augmented states)</li> <li>Returns a UnifiedState with all aggregated data</li> </ol> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>List[State]</code> <p>List of State objects to unify. Can include both user-defined states and augmented states (names starting with '_').</p> required <code>name</code> <code>str</code> <p>Name identifier for the unified state vector (default: \"unified_state\")</p> <code>'unified_state'</code> <p>Returns:</p> Name Type Description <code>UnifiedState</code> <code>UnifiedState</code> <p>Unified state object containing: - Aggregated bounds, guesses, and boundary conditions - Shape equal to sum of all state shapes - Slices for extracting individual state components - Properties for accessing true vs augmented states</p> Example <p>Basic unification::</p> <pre><code>import openscvx as ox\nfrom openscvx.symbolic.unified import unify_states\n\nposition = ox.State(\"pos\", shape=(3,), min=-10, max=10)\nvelocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n\nunified = unify_states([position, velocity], name=\"x\")\nprint(unified.shape)       # (6,)\nprint(unified._true_dim)   # 6 (all are user states)\nprint(position._slice)     # slice(0, 3) - assigned during unification\nprint(velocity._slice)     # slice(3, 6)\n</code></pre> <p>With augmented states::</p> <pre><code># CTCS or other features may add augmented states\ntime_state = ox.State(\"time\", shape=(1,))\nctcs_aug = ox.State(\"_ctcs_aug_0\", shape=(2,))  # Augmented state\n\nunified = unify_states([position, velocity, time_state, ctcs_aug])\nprint(unified._true_dim)         # 7 (pos + vel + time)\nprint(unified.true.shape)        # (7,)\nprint(unified.augmented.shape)   # (2,) - only CTCS augmented\n</code></pre> Note <p>After unification, each State object has its <code>_slice</code> attribute set, which is used during JAX lowering to extract the correct values from the unified state vector.</p> See Also <ul> <li>UnifiedState: Return type with detailed documentation</li> <li>unify_controls(): Analogous function for Control objects</li> <li>State: Individual symbolic state variable</li> </ul> Source code in <code>openscvx/symbolic/unified.py</code> <pre><code>def unify_states(states: List[State], name: str = \"unified_state\") -&gt; UnifiedState:\n    \"\"\"Create a UnifiedState from a list of State objects.\n\n    This function is the primary way to aggregate multiple symbolic State objects into\n    a single unified state vector for numerical optimization. It:\n\n    1. Sorts states (user-defined first, augmented states second)\n    2. Concatenates all state properties (bounds, guesses, boundary conditions)\n    3. Assigns slices to each State for extracting values from unified vector\n    4. Identifies special states (time, CTCS augmented states)\n    5. Returns a UnifiedState with all aggregated data\n\n    Args:\n        states (List[State]): List of State objects to unify. Can include both\n            user-defined states and augmented states (names starting with '_').\n        name (str): Name identifier for the unified state vector (default: \"unified_state\")\n\n    Returns:\n        UnifiedState: Unified state object containing:\n            - Aggregated bounds, guesses, and boundary conditions\n            - Shape equal to sum of all state shapes\n            - Slices for extracting individual state components\n            - Properties for accessing true vs augmented states\n\n    Example:\n        Basic unification::\n\n            import openscvx as ox\n            from openscvx.symbolic.unified import unify_states\n\n            position = ox.State(\"pos\", shape=(3,), min=-10, max=10)\n            velocity = ox.State(\"vel\", shape=(3,), min=-5, max=5)\n\n            unified = unify_states([position, velocity], name=\"x\")\n            print(unified.shape)       # (6,)\n            print(unified._true_dim)   # 6 (all are user states)\n            print(position._slice)     # slice(0, 3) - assigned during unification\n            print(velocity._slice)     # slice(3, 6)\n\n        With augmented states::\n\n            # CTCS or other features may add augmented states\n            time_state = ox.State(\"time\", shape=(1,))\n            ctcs_aug = ox.State(\"_ctcs_aug_0\", shape=(2,))  # Augmented state\n\n            unified = unify_states([position, velocity, time_state, ctcs_aug])\n            print(unified._true_dim)         # 7 (pos + vel + time)\n            print(unified.true.shape)        # (7,)\n            print(unified.augmented.shape)   # (2,) - only CTCS augmented\n\n    Note:\n        After unification, each State object has its `_slice` attribute set,\n        which is used during JAX lowering to extract the correct values from\n        the unified state vector.\n\n    See Also:\n        - UnifiedState: Return type with detailed documentation\n        - unify_controls(): Analogous function for Control objects\n        - State: Individual symbolic state variable\n    \"\"\"\n    if not states:\n        return UnifiedState(name=name, shape=(0,))\n\n    # Sort states: true states (not starting with '_') first, then augmented states\n    # (starting with '_')\n    true_states = [state for state in states if not state.name.startswith(\"_\")]\n    augmented_states = [state for state in states if state.name.startswith(\"_\")]\n    sorted_states = true_states + augmented_states\n\n    # Calculate total shape\n    total_shape = sum(state.shape[0] for state in sorted_states)\n\n    # Concatenate all arrays, handling None values properly\n    min_arrays = []\n    max_arrays = []\n    guess_arrays = []\n    initial_arrays = []\n    final_arrays = []\n    _initial_arrays = []\n    _final_arrays = []\n    initial_type_arrays = []\n    final_type_arrays = []\n\n    for state in sorted_states:\n        if state.min is not None:\n            min_arrays.append(state.min)\n        else:\n            # If min is None, fill with -inf for this state's dimensions\n            min_arrays.append(np.full(state.shape[0], -np.inf))\n\n        if state.max is not None:\n            max_arrays.append(state.max)\n        else:\n            # If max is None, fill with +inf for this state's dimensions\n            max_arrays.append(np.full(state.shape[0], np.inf))\n\n        if state.guess is not None:\n            guess_arrays.append(state.guess)\n        if state.initial is not None:\n            initial_arrays.append(state.initial)\n        if state.final is not None:\n            final_arrays.append(state.final)\n        if state._initial is not None:\n            _initial_arrays.append(state._initial)\n        if state._final is not None:\n            _final_arrays.append(state._final)\n        if state.initial_type is not None:\n            initial_type_arrays.append(state.initial_type)\n        else:\n            # If initial_type is None, fill with \"Free\" for this state's dimensions\n            initial_type_arrays.append(np.full(state.shape[0], \"Free\", dtype=object))\n\n        if state.final_type is not None:\n            final_type_arrays.append(state.final_type)\n        else:\n            # If final_type is None, fill with \"Free\" for this state's dimensions\n            final_type_arrays.append(np.full(state.shape[0], \"Free\", dtype=object))\n\n    # Concatenate arrays if they exist\n    unified_min = np.concatenate(min_arrays) if min_arrays else None\n    unified_max = np.concatenate(max_arrays) if max_arrays else None\n    unified_guess = np.concatenate(guess_arrays, axis=1) if guess_arrays else None\n    unified_initial = np.concatenate(initial_arrays) if initial_arrays else None\n    unified_final = np.concatenate(final_arrays) if final_arrays else None\n    unified__initial = np.concatenate(_initial_arrays) if _initial_arrays else None\n    unified__final = np.concatenate(_final_arrays) if _final_arrays else None\n    unified_initial_type = np.concatenate(initial_type_arrays) if initial_type_arrays else None\n    unified_final_type = np.concatenate(final_type_arrays) if final_type_arrays else None\n\n    # Calculate true dimension (only from user-defined states, not augmented ones)\n    # Since we simplified State/Control classes, all user states are \"true\" dimensions\n    true_dim = sum(state.shape[0] for state in true_states)\n\n    # Find time state slice\n    time_state = next((s for s in sorted_states if s.name == \"time\"), None)\n    time_slice = time_state._slice if time_state else None\n\n    # Find CTCS augmented states slice\n    ctcs_states = [s for s in sorted_states if s.name.startswith(\"_ctcs_aug_\")]\n    ctcs_slice = (\n        slice(ctcs_states[0]._slice.start, ctcs_states[-1]._slice.stop) if ctcs_states else None\n    )\n\n    # Aggregate scaling_min and scaling_max from individual states\n    # Build full arrays using scaling where available, min/max otherwise\n    unified_scaling_min = None\n    unified_scaling_max = None\n\n    # Check if any state has scaling\n    has_any_scaling = any(\n        state.scaling_min is not None or state.scaling_max is not None for state in sorted_states\n    )\n\n    if has_any_scaling:\n        # Build full scaling arrays\n        scaling_min_list = []\n        scaling_max_list = []\n        for state in sorted_states:\n            if state.scaling_min is not None:\n                scaling_min_list.append(state.scaling_min)\n            else:\n                # Use min as fallback\n                if state.min is not None:\n                    scaling_min_list.append(state.min)\n                else:\n                    scaling_min_list.append(np.full(state.shape[0], -np.inf))\n\n            if state.scaling_max is not None:\n                scaling_max_list.append(state.scaling_max)\n            else:\n                # Use max as fallback\n                if state.max is not None:\n                    scaling_max_list.append(state.max)\n                else:\n                    scaling_max_list.append(np.full(state.shape[0], np.inf))\n\n        unified_scaling_min = np.concatenate(scaling_min_list)\n        unified_scaling_max = np.concatenate(scaling_max_list)\n\n    return UnifiedState(\n        name=name,\n        shape=(total_shape,),\n        min=unified_min,\n        max=unified_max,\n        guess=unified_guess,\n        initial=unified_initial,\n        final=unified_final,\n        _initial=unified__initial,\n        _final=unified__final,\n        initial_type=unified_initial_type,\n        final_type=unified_final_type,\n        _true_dim=true_dim,\n        _true_slice=slice(0, true_dim),\n        _augmented_slice=slice(true_dim, total_shape),\n        time_slice=time_slice,\n        ctcs_slice=ctcs_slice,\n        scaling_min=unified_scaling_min,\n        scaling_max=unified_scaling_max,\n    )\n</code></pre>"},{"location":"reference/symbolic/expr/","title":"expr","text":"<p>Symbolic expression package for trajectory optimization.</p> <p>This package provides a comprehensive symbolic expression system for building optimization problems in openscvx. It implements an Abstract Syntax Tree (AST) framework that allows you to write optimization problems using natural mathematical notation.</p> Example <p>Import the package through the main openscvx module::</p> <pre><code>import openscvx as ox\n\n# Create symbolic variables\nx = ox.Variable(\"x\", shape=(3,))\nu = ox.Control(\"u\", shape=(2,))\n\n# Build expressions\ncost = ox.Norm(x - [1, 2, 3])**2 + 0.1 * ox.Norm(u)**2\nconstraint = x[0] &lt;= 5.0\n</code></pre> Module Organization <p>The package is organized into the following modules:</p> <p>Core Expressions (expr.py):     Base classes and utilities including <code>Expr</code>, <code>Leaf</code>, <code>Parameter</code>, <code>Constant</code>,     and helper functions <code>to_expr</code> and <code>traverse</code>.</p> <p>Arithmetic Operations (arithmetic.py):     Fundamental arithmetic operations including <code>Add</code>, <code>Sub</code>, <code>Mul</code>, <code>Div</code>,     <code>MatMul</code>, <code>Neg</code>, and <code>Power</code>.</p> <p>Array Operations (array.py):     Array manipulation operations including <code>Index</code>, <code>Concat</code>, <code>Stack</code>, <code>Hstack</code>,     and <code>Vstack</code> for indexing, slicing, and combining arrays.</p> <p>Constraints (constraint.py):     Constraint types including <code>Constraint</code>, <code>Equality</code>, <code>Inequality</code>,     <code>NodalConstraint</code>, and <code>CTCS</code> (Continuous-Time Constraint Satisfaction).</p> <p>Optimization Variables (variable.py, state.py, control.py):     <code>Variable</code> for general optimization variables, <code>State</code> for time-varying state     in trajectory problems, and <code>Control</code> for control inputs.</p> <p>Mathematical Functions (math.py):     Trigonometric functions (<code>Sin</code>, <code>Cos</code>), exponential functions (<code>Exp</code>, <code>Log</code>,     <code>Sqrt</code>, <code>Square</code>), and nonlinear functions (<code>PositivePart</code>, <code>Huber</code>,     <code>SmoothReLU</code>, <code>Max</code>).</p> <p>Linear Algebra (linalg.py):     Matrix operations (<code>Transpose</code>, <code>Diag</code>) and reductions (<code>Sum</code>, <code>Norm</code>).</p> <p>Spatial Operations (spatial.py):     6-DOF operations for aerospace and robotics including <code>QDCM</code> (Quaternion to     Direction Cosine Matrix), <code>SSMP</code> (4\u00d74 skew-symmetric matrix for quaternion     dynamics), and <code>SSM</code> (3\u00d73 skew-symmetric matrix for cross products).</p> <p>Lie Algebra Operations (lie.py):     Lie algebra operations for rigid body dynamics. Built-in operators include     <code>AdjointDual</code> (coadjoint for Coriolis/centrifugal forces) and <code>Adjoint</code>     (Lie bracket). jaxlie-backed operators (requires <code>pip install openscvx[lie]</code>)     include <code>SO3Exp</code>, <code>SO3Log</code>, <code>SE3Exp</code>, and <code>SE3Log</code> for exponential and     logarithm maps on rotation and rigid transformation groups.</p> <p>Constraint Specifications (constraint.py):     <code>NodalConstraint</code> for enforcing constraints at discrete nodes and <code>CTCS</code> for     continuous-time constraint satisfaction.</p> <p>Signal Temporal Logic (stl.py):     <code>Or</code> for logical disjunction in task specifications.</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Abs","title":"<code>Abs</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise absolute value function for symbolic expressions.</p> <p>Computes the absolute value (|x|) of each element in the operand. Preserves the shape of the input expression. The absolute value function is convex and DCP-compliant in CVXPy.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply absolute value to</p> Example <p>Define an Abs expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\nabs_x = Abs(x)  # Element-wise |x|\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Abs(Expr):\n    \"\"\"Element-wise absolute value function for symbolic expressions.\n\n    Computes the absolute value (|x|) of each element in the operand. Preserves\n    the shape of the input expression. The absolute value function is convex\n    and DCP-compliant in CVXPy.\n\n    Attributes:\n        operand: Expression to apply absolute value to\n\n    Example:\n        Define an Abs expression:\n\n            x = Variable(\"x\", shape=(3,))\n            abs_x = Abs(x)  # Element-wise |x|\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize an absolute value operation.\n\n        Args:\n            operand: Expression to apply absolute value to\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Abs(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Abs preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"abs({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Abs.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize an absolute value operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to apply absolute value to</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize an absolute value operation.\n\n    Args:\n        operand: Expression to apply absolute value to\n    \"\"\"\n    self.operand = to_expr(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Abs.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Abs preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Abs preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Add","title":"<code>Add</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Addition operation for symbolic expressions.</p> <p>Represents element-wise addition of two or more expressions. Supports broadcasting following NumPy rules. Can be created using the + operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>terms</code> <p>List of expression operands to add together</p> Example <p>Define an Add expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(3,))\nz = x + y + 5  # Creates Add(x, y, Constant(5))\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Add(Expr):\n    \"\"\"Addition operation for symbolic expressions.\n\n    Represents element-wise addition of two or more expressions. Supports broadcasting\n    following NumPy rules. Can be created using the + operator on Expr objects.\n\n    Attributes:\n        terms: List of expression operands to add together\n\n    Example:\n        Define an Add expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(3,))\n            z = x + y + 5  # Creates Add(x, y, Constant(5))\n    \"\"\"\n\n    def __init__(self, *args):\n        \"\"\"Initialize an addition operation.\n\n        Args:\n            *args: Two or more expressions to add together\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(args) &lt; 2:\n            raise ValueError(\"Add requires two or more operands\")\n        self.terms = [to_expr(a) for a in args]\n\n    def children(self):\n        return list(self.terms)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize addition: flatten, fold constants, and eliminate zeros.\n\n        Returns:\n            Expr: Canonical form of the addition expression\n        \"\"\"\n        terms = []\n        const_vals = []\n\n        for t in self.terms:\n            c = t.canonicalize()\n            if isinstance(c, Add):\n                terms.extend(c.terms)\n            elif isinstance(c, Constant):\n                const_vals.append(c.value)\n            else:\n                terms.append(c)\n\n        if const_vals:\n            total = sum(const_vals)\n            # If not all-zero, keep it\n            if not (isinstance(total, np.ndarray) and np.all(total == 0)):\n                terms.append(Constant(total))\n\n        if not terms:\n            return Constant(np.array(0))\n        if len(terms) == 1:\n            return terms[0]\n        return Add(*terms)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n        Returns:\n            tuple: The broadcasted shape of all operands\n\n        Raises:\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Add shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        inner = \" + \".join(repr(e) for e in self.terms)\n        return f\"({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Add.__init__","title":"<code>__init__(*args)</code>","text":"<p>Initialize an addition operation.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Two or more expressions to add together</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two operands are provided</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def __init__(self, *args):\n    \"\"\"Initialize an addition operation.\n\n    Args:\n        *args: Two or more expressions to add together\n\n    Raises:\n        ValueError: If fewer than two operands are provided\n    \"\"\"\n    if len(args) &lt; 2:\n        raise ValueError(\"Add requires two or more operands\")\n    self.terms = [to_expr(a) for a in args]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Add.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize addition: flatten, fold constants, and eliminate zeros.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the addition expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize addition: flatten, fold constants, and eliminate zeros.\n\n    Returns:\n        Expr: Canonical form of the addition expression\n    \"\"\"\n    terms = []\n    const_vals = []\n\n    for t in self.terms:\n        c = t.canonicalize()\n        if isinstance(c, Add):\n            terms.extend(c.terms)\n        elif isinstance(c, Constant):\n            const_vals.append(c.value)\n        else:\n            terms.append(c)\n\n    if const_vals:\n        total = sum(const_vals)\n        # If not all-zero, keep it\n        if not (isinstance(total, np.ndarray) and np.all(total == 0)):\n            terms.append(Constant(total))\n\n    if not terms:\n        return Constant(np.array(0))\n    if len(terms) == 1:\n        return terms[0]\n    return Add(*terms)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Add.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check shape compatibility and compute broadcasted result shape like NumPy.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The broadcasted shape of all operands</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n    Returns:\n        tuple: The broadcasted shape of all operands\n\n    Raises:\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Add shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Adjoint","title":"<code>Adjoint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Adjoint operator ad (Lie bracket) for twist-on-twist action.</p> <p>Computes the adjoint action ad_\u03be\u2081(\u03be\u2082) which represents the Lie bracket [\u03be\u2081, \u03be\u2082] of two twists. This is used for velocity propagation in kinematic chains and acceleration computations.</p> <p>For se(3), given twists \u03be\u2081 = [v\u2081; \u03c9\u2081] and \u03be\u2082 = [v\u2082; \u03c9\u2082]:</p> <pre><code>ad_\u03be\u2081(\u03be\u2082) = [\u03be\u2081, \u03be\u2082] = [ \u03c9\u2081 \u00d7 v\u2082 - \u03c9\u2082 \u00d7 v\u2081 ]\n                        [     \u03c9\u2081 \u00d7 \u03c9\u2082       ]\n</code></pre> <p>Equivalently using the adjoint matrix:</p> <pre><code>ad_\u03be = [ [\u03c9]\u00d7    0   ]\n       [ [v]\u00d7   [\u03c9]\u00d7 ]\n</code></pre> <p>where [\u00b7]\u00d7 denotes the 3x3 skew-symmetric (cross product) matrix.</p> <p>Attributes:</p> Name Type Description <code>twist1</code> <p>First 6D twist vector [v\u2081; \u03c9\u2081]</p> <code>twist2</code> <p>Second 6D twist vector [v\u2082; \u03c9\u2082]</p> Example <p>Compute the Lie bracket of two twists::</p> <pre><code>import openscvx as ox\n\ntwist1 = ox.State(\"twist1\", shape=(6,))\ntwist2 = ox.State(\"twist2\", shape=(6,))\n\nbracket = ox.lie.Adjoint(twist1, twist2)\n</code></pre> <p>Velocity propagation in a kinematic chain::</p> <pre><code># Child link velocity includes parent velocity plus relative motion\n# V_child = Ad_T @ V_parent + joint_twist * q_dot\n</code></pre> Note <p>The adjoint satisfies the Jacobi identity and is antisymmetric: ad_\u03be\u2081(\u03be\u2082) = -ad_\u03be\u2082(\u03be\u2081)</p> See Also <p>AdjointDual: The coadjoint operator for momentum dynamics</p> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>class Adjoint(Expr):\n    \"\"\"Adjoint operator ad (Lie bracket) for twist-on-twist action.\n\n    Computes the adjoint action ad_\u03be\u2081(\u03be\u2082) which represents the Lie bracket\n    [\u03be\u2081, \u03be\u2082] of two twists. This is used for velocity propagation in\n    kinematic chains and acceleration computations.\n\n    For se(3), given twists \u03be\u2081 = [v\u2081; \u03c9\u2081] and \u03be\u2082 = [v\u2082; \u03c9\u2082]:\n\n        ad_\u03be\u2081(\u03be\u2082) = [\u03be\u2081, \u03be\u2082] = [ \u03c9\u2081 \u00d7 v\u2082 - \u03c9\u2082 \u00d7 v\u2081 ]\n                                [     \u03c9\u2081 \u00d7 \u03c9\u2082       ]\n\n    Equivalently using the adjoint matrix:\n\n        ad_\u03be = [ [\u03c9]\u00d7    0   ]\n               [ [v]\u00d7   [\u03c9]\u00d7 ]\n\n    where [\u00b7]\u00d7 denotes the 3x3 skew-symmetric (cross product) matrix.\n\n    Attributes:\n        twist1: First 6D twist vector [v\u2081; \u03c9\u2081]\n        twist2: Second 6D twist vector [v\u2082; \u03c9\u2082]\n\n    Example:\n        Compute the Lie bracket of two twists::\n\n            import openscvx as ox\n\n            twist1 = ox.State(\"twist1\", shape=(6,))\n            twist2 = ox.State(\"twist2\", shape=(6,))\n\n            bracket = ox.lie.Adjoint(twist1, twist2)\n\n        Velocity propagation in a kinematic chain::\n\n            # Child link velocity includes parent velocity plus relative motion\n            # V_child = Ad_T @ V_parent + joint_twist * q_dot\n\n    Note:\n        The adjoint satisfies the Jacobi identity and is antisymmetric:\n        ad_\u03be\u2081(\u03be\u2082) = -ad_\u03be\u2082(\u03be\u2081)\n\n    See Also:\n        AdjointDual: The coadjoint operator for momentum dynamics\n    \"\"\"\n\n    def __init__(self, twist1, twist2):\n        \"\"\"Initialize an adjoint operator.\n\n        Args:\n            twist1: First 6D twist vector [v; \u03c9] with shape (6,)\n            twist2: Second 6D twist vector [v; \u03c9] with shape (6,)\n        \"\"\"\n        self.twist1 = to_expr(twist1)\n        self.twist2 = to_expr(twist2)\n\n    def children(self):\n        return [self.twist1, self.twist2]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        twist1 = self.twist1.canonicalize()\n        twist2 = self.twist2.canonicalize()\n        return Adjoint(twist1, twist2)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that inputs are 6D vectors and return output shape.\n\n        Returns:\n            tuple: Shape (6,) for the resulting Lie bracket\n\n        Raises:\n            ValueError: If either twist does not have shape (6,)\n        \"\"\"\n        twist1_shape = self.twist1.check_shape()\n        twist2_shape = self.twist2.check_shape()\n\n        if twist1_shape != (6,):\n            raise ValueError(f\"Adjoint expects twist1 with shape (6,), got {twist1_shape}\")\n        if twist2_shape != (6,):\n            raise ValueError(f\"Adjoint expects twist2 with shape (6,), got {twist2_shape}\")\n\n        return (6,)\n\n    def __repr__(self):\n        return f\"ad({self.twist1!r}, {self.twist2!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Adjoint.__init__","title":"<code>__init__(twist1, twist2)</code>","text":"<p>Initialize an adjoint operator.</p> <p>Parameters:</p> Name Type Description Default <code>twist1</code> <p>First 6D twist vector [v; \u03c9] with shape (6,)</p> required <code>twist2</code> <p>Second 6D twist vector [v; \u03c9] with shape (6,)</p> required Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def __init__(self, twist1, twist2):\n    \"\"\"Initialize an adjoint operator.\n\n    Args:\n        twist1: First 6D twist vector [v; \u03c9] with shape (6,)\n        twist2: Second 6D twist vector [v; \u03c9] with shape (6,)\n    \"\"\"\n    self.twist1 = to_expr(twist1)\n    self.twist2 = to_expr(twist2)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Adjoint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that inputs are 6D vectors and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (6,) for the resulting Lie bracket</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either twist does not have shape (6,)</p> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that inputs are 6D vectors and return output shape.\n\n    Returns:\n        tuple: Shape (6,) for the resulting Lie bracket\n\n    Raises:\n        ValueError: If either twist does not have shape (6,)\n    \"\"\"\n    twist1_shape = self.twist1.check_shape()\n    twist2_shape = self.twist2.check_shape()\n\n    if twist1_shape != (6,):\n        raise ValueError(f\"Adjoint expects twist1 with shape (6,), got {twist1_shape}\")\n    if twist2_shape != (6,):\n        raise ValueError(f\"Adjoint expects twist2 with shape (6,), got {twist2_shape}\")\n\n    return (6,)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.AdjointDual","title":"<code>AdjointDual</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Coadjoint operator ad* for computing Coriolis and centrifugal forces.</p> <p>Computes the coadjoint action ad*_\u03be(\u03bc) which represents the rate of change of momentum due to body rotation. This is the key term in Newton-Euler dynamics that captures Coriolis and centrifugal effects.</p> <p>For se(3), given twist \u03be = [v; \u03c9] and momentum \u03bc = [f; \u03c4]:</p> <pre><code>ad*_\u03be(\u03bc) = [ \u03c9 \u00d7 f + v \u00d7 \u03c4 ]\n           [     \u03c9 \u00d7 \u03c4     ]\n</code></pre> <p>This appears in the Newton-Euler equations as:</p> <pre><code>M @ \u03be_dot = F_ext - ad*_\u03be(M @ \u03be)\n</code></pre> <p>where M is the spatial inertia matrix and F_ext is the external wrench.</p> <p>Attributes:</p> Name Type Description <code>twist</code> <p>6D twist vector [v; \u03c9] (linear velocity, angular velocity)</p> <code>momentum</code> <p>6D momentum vector [p; L] or [f; \u03c4] (linear, angular)</p> Example <p>Compute the bias force (Coriolis + centrifugal) for rigid body dynamics::</p> <pre><code>import openscvx as ox\n\ntwist = ox.State(\"twist\", shape=(6,))\nM = ox.Parameter(\"M\", shape=(6, 6), value=inertia_matrix)\n\nmomentum = M @ twist\nbias_force = ox.lie.AdjointDual(twist, momentum)\n\n# In dynamics: twist_dot = M_inv @ (wrench - bias_force)\n</code></pre> Note <p>The coadjoint is related to the adjoint by: ad*_\u03be = -(ad_\u03be)^T</p> <p>For the special case of pure rotation (v=0) with diagonal inertia, the angular part reduces to the familiar \u03c9 \u00d7 (J @ \u03c9) term.</p> See Also <p>Adjoint: The adjoint operator for twist-on-twist action SSM: 3x3 skew-symmetric matrix for cross products</p> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>class AdjointDual(Expr):\n    \"\"\"Coadjoint operator ad* for computing Coriolis and centrifugal forces.\n\n    Computes the coadjoint action ad*_\u03be(\u03bc) which represents the rate of change\n    of momentum due to body rotation. This is the key term in Newton-Euler\n    dynamics that captures Coriolis and centrifugal effects.\n\n    For se(3), given twist \u03be = [v; \u03c9] and momentum \u03bc = [f; \u03c4]:\n\n        ad*_\u03be(\u03bc) = [ \u03c9 \u00d7 f + v \u00d7 \u03c4 ]\n                   [     \u03c9 \u00d7 \u03c4     ]\n\n    This appears in the Newton-Euler equations as:\n\n        M @ \u03be_dot = F_ext - ad*_\u03be(M @ \u03be)\n\n    where M is the spatial inertia matrix and F_ext is the external wrench.\n\n    Attributes:\n        twist: 6D twist vector [v; \u03c9] (linear velocity, angular velocity)\n        momentum: 6D momentum vector [p; L] or [f; \u03c4] (linear, angular)\n\n    Example:\n        Compute the bias force (Coriolis + centrifugal) for rigid body dynamics::\n\n            import openscvx as ox\n\n            twist = ox.State(\"twist\", shape=(6,))\n            M = ox.Parameter(\"M\", shape=(6, 6), value=inertia_matrix)\n\n            momentum = M @ twist\n            bias_force = ox.lie.AdjointDual(twist, momentum)\n\n            # In dynamics: twist_dot = M_inv @ (wrench - bias_force)\n\n    Note:\n        The coadjoint is related to the adjoint by: ad*_\u03be = -(ad_\u03be)^T\n\n        For the special case of pure rotation (v=0) with diagonal inertia,\n        the angular part reduces to the familiar \u03c9 \u00d7 (J @ \u03c9) term.\n\n    See Also:\n        Adjoint: The adjoint operator for twist-on-twist action\n        SSM: 3x3 skew-symmetric matrix for cross products\n    \"\"\"\n\n    def __init__(self, twist, momentum):\n        \"\"\"Initialize a coadjoint operator.\n\n        Args:\n            twist: 6D twist vector [v; \u03c9] with shape (6,)\n            momentum: 6D momentum vector [p; L] with shape (6,)\n        \"\"\"\n        self.twist = to_expr(twist)\n        self.momentum = to_expr(momentum)\n\n    def children(self):\n        return [self.twist, self.momentum]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        twist = self.twist.canonicalize()\n        momentum = self.momentum.canonicalize()\n        return AdjointDual(twist, momentum)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that inputs are 6D vectors and return output shape.\n\n        Returns:\n            tuple: Shape (6,) for the resulting coadjoint vector\n\n        Raises:\n            ValueError: If twist or momentum do not have shape (6,)\n        \"\"\"\n        twist_shape = self.twist.check_shape()\n        momentum_shape = self.momentum.check_shape()\n\n        if twist_shape != (6,):\n            raise ValueError(f\"AdjointDual expects twist with shape (6,), got {twist_shape}\")\n        if momentum_shape != (6,):\n            raise ValueError(f\"AdjointDual expects momentum with shape (6,), got {momentum_shape}\")\n\n        return (6,)\n\n    def __repr__(self):\n        return f\"ad_dual({self.twist!r}, {self.momentum!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.AdjointDual.__init__","title":"<code>__init__(twist, momentum)</code>","text":"<p>Initialize a coadjoint operator.</p> <p>Parameters:</p> Name Type Description Default <code>twist</code> <p>6D twist vector [v; \u03c9] with shape (6,)</p> required <code>momentum</code> <p>6D momentum vector [p; L] with shape (6,)</p> required Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def __init__(self, twist, momentum):\n    \"\"\"Initialize a coadjoint operator.\n\n    Args:\n        twist: 6D twist vector [v; \u03c9] with shape (6,)\n        momentum: 6D momentum vector [p; L] with shape (6,)\n    \"\"\"\n    self.twist = to_expr(twist)\n    self.momentum = to_expr(momentum)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.AdjointDual.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that inputs are 6D vectors and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (6,) for the resulting coadjoint vector</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If twist or momentum do not have shape (6,)</p> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that inputs are 6D vectors and return output shape.\n\n    Returns:\n        tuple: Shape (6,) for the resulting coadjoint vector\n\n    Raises:\n        ValueError: If twist or momentum do not have shape (6,)\n    \"\"\"\n    twist_shape = self.twist.check_shape()\n    momentum_shape = self.momentum.check_shape()\n\n    if twist_shape != (6,):\n        raise ValueError(f\"AdjointDual expects twist with shape (6,), got {twist_shape}\")\n    if momentum_shape != (6,):\n        raise ValueError(f\"AdjointDual expects momentum with shape (6,), got {momentum_shape}\")\n\n    return (6,)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Bilerp","title":"<code>Bilerp</code>","text":"<p>               Bases: <code>Expr</code></p> <p>2D bilinear interpolation for symbolic expressions.</p> <p>Performs bilinear interpolation on a regular 2D grid. Given grid points (xp, yp) and corresponding values fp, computes the bilinearly interpolated value at query point (x, y). For values outside the grid, boundary values are returned (clamping, no extrapolation).</p> <p>This is useful for incorporating 2D tabulated data (e.g., engine thrust as a function of altitude and Mach number, aerodynamic coefficients as a function of angle of attack and sideslip) into trajectory optimization.</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Query x-coordinate (symbolic expression)</p> <code>y</code> <p>Query y-coordinate (symbolic expression)</p> <code>xp</code> <p>1D array of x grid coordinates (must be increasing), length N</p> <code>yp</code> <p>1D array of y grid coordinates (must be increasing), length M</p> <code>fp</code> <p>2D array of values with shape (N, M), where fp[i, j] is the value at grid point (xp[i], yp[j])</p> Example <p>Interpolate engine thrust from altitude and Mach number::</p> <pre><code>import openscvx as ox\nimport numpy as np\n\n# Grid coordinates\nalt_grid = np.array([0, 5000, 10000, 15000, 20000])  # meters\nmach_grid = np.array([0.0, 0.5, 1.0, 1.5, 2.0])\n\n# Thrust values: thrust_table[i, j] = thrust at (alt_grid[i], mach_grid[j])\nthrust_table = np.array([...])  # shape (5, 5)\n\naltitude = ox.State(\"altitude\", shape=(1,))\nmach = ox.State(\"mach\", shape=(1,))\n\nthrust = ox.Bilerp(altitude[0], mach[0], alt_grid, mach_grid, thrust_table)\n</code></pre> Note <ul> <li>xp and yp must be strictly increasing</li> <li>fp must have shape (len(xp), len(yp))</li> <li>For query points outside the grid, boundary values are returned</li> <li>This node is only supported in JAX lowering (dynamics/cost), not CVXPy</li> </ul> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Bilerp(Expr):\n    \"\"\"2D bilinear interpolation for symbolic expressions.\n\n    Performs bilinear interpolation on a regular 2D grid. Given grid points\n    (xp, yp) and corresponding values fp, computes the bilinearly interpolated\n    value at query point (x, y). For values outside the grid, boundary values\n    are returned (clamping, no extrapolation).\n\n    This is useful for incorporating 2D tabulated data (e.g., engine thrust\n    as a function of altitude and Mach number, aerodynamic coefficients as\n    a function of angle of attack and sideslip) into trajectory optimization.\n\n    Attributes:\n        x: Query x-coordinate (symbolic expression)\n        y: Query y-coordinate (symbolic expression)\n        xp: 1D array of x grid coordinates (must be increasing), length N\n        yp: 1D array of y grid coordinates (must be increasing), length M\n        fp: 2D array of values with shape (N, M), where fp[i, j] is the\n            value at grid point (xp[i], yp[j])\n\n    Example:\n        Interpolate engine thrust from altitude and Mach number::\n\n            import openscvx as ox\n            import numpy as np\n\n            # Grid coordinates\n            alt_grid = np.array([0, 5000, 10000, 15000, 20000])  # meters\n            mach_grid = np.array([0.0, 0.5, 1.0, 1.5, 2.0])\n\n            # Thrust values: thrust_table[i, j] = thrust at (alt_grid[i], mach_grid[j])\n            thrust_table = np.array([...])  # shape (5, 5)\n\n            altitude = ox.State(\"altitude\", shape=(1,))\n            mach = ox.State(\"mach\", shape=(1,))\n\n            thrust = ox.Bilerp(altitude[0], mach[0], alt_grid, mach_grid, thrust_table)\n\n    Note:\n        - xp and yp must be strictly increasing\n        - fp must have shape (len(xp), len(yp))\n        - For query points outside the grid, boundary values are returned\n        - This node is only supported in JAX lowering (dynamics/cost), not CVXPy\n    \"\"\"\n\n    def __init__(self, x, y, xp, yp, fp):\n        \"\"\"Initialize a 2D bilinear interpolation node.\n\n        Args:\n            x: Query x-coordinate. Can be a scalar symbolic expression.\n            y: Query y-coordinate. Can be a scalar symbolic expression.\n            xp: 1D array of x grid coordinates. Must be increasing.\n            yp: 1D array of y grid coordinates. Must be increasing.\n            fp: 2D array of values with shape (len(xp), len(yp)).\n        \"\"\"\n        self.x = to_expr(x)\n        self.y = to_expr(y)\n        self.xp = to_expr(xp)\n        self.yp = to_expr(yp)\n        self.fp = to_expr(fp)\n\n    def children(self):\n        return [self.x, self.y, self.xp, self.yp, self.fp]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize by canonicalizing all operands.\"\"\"\n        x = self.x.canonicalize()\n        y = self.y.canonicalize()\n        xp = self.xp.canonicalize()\n        yp = self.yp.canonicalize()\n        fp = self.fp.canonicalize()\n        return Bilerp(x, y, xp, yp, fp)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Output shape is scalar (single interpolated value).\n\n        Returns:\n            tuple: Empty tuple (scalar output)\n\n        Raises:\n            ValueError: If grid arrays have invalid shapes\n        \"\"\"\n        xp_shape = self.xp.check_shape()\n        yp_shape = self.yp.check_shape()\n        fp_shape = self.fp.check_shape()\n        x_shape = self.x.check_shape()\n        y_shape = self.y.check_shape()\n\n        if len(xp_shape) != 1:\n            raise ValueError(f\"Bilerp xp must be 1D, got shape {xp_shape}\")\n        if len(yp_shape) != 1:\n            raise ValueError(f\"Bilerp yp must be 1D, got shape {yp_shape}\")\n        if len(fp_shape) != 2:\n            raise ValueError(f\"Bilerp fp must be 2D, got shape {fp_shape}\")\n        if fp_shape != (xp_shape[0], yp_shape[0]):\n            raise ValueError(\n                f\"Bilerp fp shape {fp_shape} must match (len(xp), len(yp)) = \"\n                f\"({xp_shape[0]}, {yp_shape[0]})\"\n            )\n        if x_shape != ():\n            raise ValueError(f\"Bilerp x must be scalar, got shape {x_shape}\")\n        if y_shape != ():\n            raise ValueError(f\"Bilerp y must be scalar, got shape {y_shape}\")\n\n        return ()\n\n    def __repr__(self):\n        return f\"bilerp({self.x!r}, {self.y!r}, {self.xp!r}, {self.yp!r}, {self.fp!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Bilerp.__init__","title":"<code>__init__(x, y, xp, yp, fp)</code>","text":"<p>Initialize a 2D bilinear interpolation node.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>Query x-coordinate. Can be a scalar symbolic expression.</p> required <code>y</code> <p>Query y-coordinate. Can be a scalar symbolic expression.</p> required <code>xp</code> <p>1D array of x grid coordinates. Must be increasing.</p> required <code>yp</code> <p>1D array of y grid coordinates. Must be increasing.</p> required <code>fp</code> <p>2D array of values with shape (len(xp), len(yp)).</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, x, y, xp, yp, fp):\n    \"\"\"Initialize a 2D bilinear interpolation node.\n\n    Args:\n        x: Query x-coordinate. Can be a scalar symbolic expression.\n        y: Query y-coordinate. Can be a scalar symbolic expression.\n        xp: 1D array of x grid coordinates. Must be increasing.\n        yp: 1D array of y grid coordinates. Must be increasing.\n        fp: 2D array of values with shape (len(xp), len(yp)).\n    \"\"\"\n    self.x = to_expr(x)\n    self.y = to_expr(y)\n    self.xp = to_expr(xp)\n    self.yp = to_expr(yp)\n    self.fp = to_expr(fp)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Bilerp.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize by canonicalizing all operands.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize by canonicalizing all operands.\"\"\"\n    x = self.x.canonicalize()\n    y = self.y.canonicalize()\n    xp = self.xp.canonicalize()\n    yp = self.yp.canonicalize()\n    fp = self.fp.canonicalize()\n    return Bilerp(x, y, xp, yp, fp)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Bilerp.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Output shape is scalar (single interpolated value).</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple (scalar output)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If grid arrays have invalid shapes</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Output shape is scalar (single interpolated value).\n\n    Returns:\n        tuple: Empty tuple (scalar output)\n\n    Raises:\n        ValueError: If grid arrays have invalid shapes\n    \"\"\"\n    xp_shape = self.xp.check_shape()\n    yp_shape = self.yp.check_shape()\n    fp_shape = self.fp.check_shape()\n    x_shape = self.x.check_shape()\n    y_shape = self.y.check_shape()\n\n    if len(xp_shape) != 1:\n        raise ValueError(f\"Bilerp xp must be 1D, got shape {xp_shape}\")\n    if len(yp_shape) != 1:\n        raise ValueError(f\"Bilerp yp must be 1D, got shape {yp_shape}\")\n    if len(fp_shape) != 2:\n        raise ValueError(f\"Bilerp fp must be 2D, got shape {fp_shape}\")\n    if fp_shape != (xp_shape[0], yp_shape[0]):\n        raise ValueError(\n            f\"Bilerp fp shape {fp_shape} must match (len(xp), len(yp)) = \"\n            f\"({xp_shape[0]}, {yp_shape[0]})\"\n        )\n    if x_shape != ():\n        raise ValueError(f\"Bilerp x must be scalar, got shape {x_shape}\")\n    if y_shape != ():\n        raise ValueError(f\"Bilerp y must be scalar, got shape {y_shape}\")\n\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Block","title":"<code>Block</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Block matrix/tensor construction from nested arrays of expressions.</p> <p>Assembles a block matrix (or N-D tensor) from a nested list of expressions, analogous to numpy.block(). Each inner list represents a row of blocks, and blocks within the same row are concatenated horizontally, while rows are stacked vertically.</p> <p>This provides a convenient way to construct matrices from sub-expressions without manually nesting Stack/Hstack/Vstack operations.</p> <p>Attributes:</p> Name Type Description <code>blocks</code> <p>Nested list of expressions forming the block structure (each expression can be a scalar, 1D, 2D, or N-D tensor)</p> Example <p>Build a 2D rotation matrix::</p> <pre><code>import openscvx as ox\nfrom openscvx.symbolic.expr.array import Block\n\ntheta = ox.Variable(\"theta\", shape=(1,))\nR = Block([\n    [ox.Cos(theta), -ox.Sin(theta)],\n    [ox.Sin(theta),  ox.Cos(theta)]\n])  # Result shape (2, 2)\n</code></pre> <p>Build a block diagonal matrix::</p> <pre><code>A = ox.State(\"A\", shape=(2, 2))\nB = ox.State(\"B\", shape=(3, 3))\nzeros_23 = ox.Constant(np.zeros((2, 3)))\nzeros_32 = ox.Constant(np.zeros((3, 2)))\nblock_diag = Block([\n    [A, zeros_23],\n    [zeros_32, B]\n])  # Result shape (5, 5)\n</code></pre> <p>Build from scalars and expressions::</p> <pre><code>x = ox.State(\"x\", shape=(1,))\ny = ox.State(\"y\", shape=(1,))\n# Scalars are automatically promoted to 1D arrays\nM = Block([\n    [x, 0],\n    [0, y]\n])  # Result shape (2, 2)\n</code></pre> Note <ul> <li>All blocks in the same row must have the same height (first dimension)</li> <li>All blocks in the same column must have the same width (second dimension)</li> <li>For N-D tensors (3D+), all trailing dimensions must match across all blocks</li> <li>Scalar values and raw Python lists are automatically wrapped via to_expr()</li> <li>1D arrays are treated as row vectors when determining block dimensions</li> <li>N-D tensors are supported for JAX lowering; CVXPy only supports 2D blocks</li> </ul> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Block(Expr):\n    \"\"\"Block matrix/tensor construction from nested arrays of expressions.\n\n    Assembles a block matrix (or N-D tensor) from a nested list of expressions,\n    analogous to numpy.block(). Each inner list represents a row of blocks, and\n    blocks within the same row are concatenated horizontally, while rows are\n    stacked vertically.\n\n    This provides a convenient way to construct matrices from sub-expressions\n    without manually nesting Stack/Hstack/Vstack operations.\n\n    Attributes:\n        blocks: Nested list of expressions forming the block structure (each\n            expression can be a scalar, 1D, 2D, or N-D tensor)\n\n    Example:\n        Build a 2D rotation matrix::\n\n            import openscvx as ox\n            from openscvx.symbolic.expr.array import Block\n\n            theta = ox.Variable(\"theta\", shape=(1,))\n            R = Block([\n                [ox.Cos(theta), -ox.Sin(theta)],\n                [ox.Sin(theta),  ox.Cos(theta)]\n            ])  # Result shape (2, 2)\n\n        Build a block diagonal matrix::\n\n            A = ox.State(\"A\", shape=(2, 2))\n            B = ox.State(\"B\", shape=(3, 3))\n            zeros_23 = ox.Constant(np.zeros((2, 3)))\n            zeros_32 = ox.Constant(np.zeros((3, 2)))\n            block_diag = Block([\n                [A, zeros_23],\n                [zeros_32, B]\n            ])  # Result shape (5, 5)\n\n        Build from scalars and expressions::\n\n            x = ox.State(\"x\", shape=(1,))\n            y = ox.State(\"y\", shape=(1,))\n            # Scalars are automatically promoted to 1D arrays\n            M = Block([\n                [x, 0],\n                [0, y]\n            ])  # Result shape (2, 2)\n\n    Note:\n        - All blocks in the same row must have the same height (first dimension)\n        - All blocks in the same column must have the same width (second dimension)\n        - For N-D tensors (3D+), all trailing dimensions must match across all blocks\n        - Scalar values and raw Python lists are automatically wrapped via to_expr()\n        - 1D arrays are treated as row vectors when determining block dimensions\n        - N-D tensors are supported for JAX lowering; CVXPy only supports 2D blocks\n    \"\"\"\n\n    def __init__(self, blocks):\n        \"\"\"Initialize a block matrix construction.\n\n        Args:\n            blocks: A nested list of expressions. Can be either:\n                    - 2D: [[row1_blocks], [row2_blocks], ...] for multiple rows\n                    - 1D: [block1, block2, ...] for a single row (auto-promoted to [[...]])\n                    Raw values (numbers, lists, numpy arrays) are automatically\n                    converted to Constant expressions.\n\n        Raises:\n            ValueError: If blocks is empty\n        \"\"\"\n        if not blocks:\n            raise ValueError(\"Block requires at least one row\")\n\n        # Auto-promote 1D list to 2D (matching numpy.block behavior)\n        # e.g., Block([a, b]) -&gt; Block([[a, b]])\n        if not isinstance(blocks[0], (list, tuple)):\n            blocks = [blocks]\n\n        # Convert all blocks to expressions\n        self.blocks = [[to_expr(block) for block in row] for row in blocks]\n\n        # Validate consistent row lengths\n        row_lengths = [len(row) for row in self.blocks]\n        if len(set(row_lengths)) &gt; 1:\n            raise ValueError(\n                f\"All rows must have the same number of blocks. Got row lengths: {row_lengths}\"\n            )\n\n    def children(self):\n        \"\"\"Return all block expressions in row-major order.\"\"\"\n        return [block for row in self.blocks for block in row]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize by recursively canonicalizing all blocks.\n\n        If the block contains only a single element ([[a]]), returns the\n        canonicalized element directly to simplify the expression tree.\n        \"\"\"\n        canonical_blocks = [[block.canonicalize() for block in row] for row in self.blocks]\n\n        # Unwrap single-element blocks\n        if len(canonical_blocks) == 1 and len(canonical_blocks[0]) == 1:\n            return canonical_blocks[0][0]\n\n        return Block(canonical_blocks)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Validate block dimensions and compute output shape.\n\n        For 2D blocks, returns (total_rows, total_cols). For N-D blocks,\n        returns the shape after assembling blocks along the first two axes,\n        with trailing dimensions preserved.\n\n        Returns:\n            Tuple representing the assembled block array shape\n\n        Raises:\n            ValueError: If block dimensions are incompatible\n        \"\"\"\n        n_block_rows = len(self.blocks)\n        n_block_cols = len(self.blocks[0])\n\n        # Get shapes of all blocks\n        block_shapes = [[block.check_shape() for block in row] for row in self.blocks]\n\n        # Determine the maximum dimensionality across all blocks\n        max_ndim = max(len(shape) for row in block_shapes for shape in row)\n        max_ndim = max(max_ndim, 2)  # At least 2D for block assembly\n\n        # Normalize shapes: pad to max_ndim by prepending 1s\n        # Scalars () -&gt; (1, 1, ...), 1D (n,) -&gt; (1, n, ...), etc.\n        def normalize_shape(shape):\n            if len(shape) == 0:\n                return (1,) * max_ndim\n            elif len(shape) &lt; max_ndim:\n                # Prepend 1s to match max_ndim\n                return (1,) * (max_ndim - len(shape)) + shape\n            else:\n                return shape\n\n        normalized_shapes = [[normalize_shape(shape) for shape in row] for row in block_shapes]\n\n        # Validate trailing dimensions (dims 2+) match across ALL blocks\n        if max_ndim &gt; 2:\n            trailing_shape = normalized_shapes[0][0][2:]\n            for i, row_shapes in enumerate(normalized_shapes):\n                for j, shape in enumerate(row_shapes):\n                    if shape[2:] != trailing_shape:\n                        raise ValueError(\n                            f\"Block[{i}][{j}] has trailing dimensions {shape[2:]}, \"\n                            f\"but Block[0][0] has {trailing_shape}. \"\n                            f\"All blocks must have matching dimensions beyond the first two.\"\n                        )\n\n        # Compute row heights (first dimension of each row must match)\n        row_heights = []\n        for i, row_shapes in enumerate(normalized_shapes):\n            heights = [s[0] for s in row_shapes]\n            if len(set(heights)) &gt; 1:\n                raise ValueError(\n                    f\"Block row {i} has inconsistent heights: {heights}. \"\n                    f\"All blocks in a row must have the same height.\"\n                )\n            row_heights.append(heights[0])\n\n        # Compute column widths (second dimension of each column must match)\n        col_widths = []\n        for j in range(n_block_cols):\n            widths = [normalized_shapes[i][j][1] for i in range(n_block_rows)]\n            if len(set(widths)) &gt; 1:\n                raise ValueError(\n                    f\"Block column {j} has inconsistent widths: {widths}. \"\n                    f\"All blocks in a column must have the same width.\"\n                )\n            col_widths.append(widths[0])\n\n        total_rows = sum(row_heights)\n        total_cols = sum(col_widths)\n\n        # Return shape with trailing dimensions if present\n        if max_ndim &gt; 2:\n            return (total_rows, total_cols) + normalized_shapes[0][0][2:]\n        return (total_rows, total_cols)\n\n    def __repr__(self):\n        rows_repr = []\n        for row in self.blocks:\n            blocks_repr = \", \".join(repr(block) for block in row)\n            rows_repr.append(f\"[{blocks_repr}]\")\n        inner = \", \".join(rows_repr)\n        return f\"Block([{inner}])\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Block.__init__","title":"<code>__init__(blocks)</code>","text":"<p>Initialize a block matrix construction.</p> <p>Parameters:</p> Name Type Description Default <code>blocks</code> <p>A nested list of expressions. Can be either:     - 2D: [[row1_blocks], [row2_blocks], ...] for multiple rows     - 1D: [block1, block2, ...] for a single row (auto-promoted to [[...]])     Raw values (numbers, lists, numpy arrays) are automatically     converted to Constant expressions.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If blocks is empty</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def __init__(self, blocks):\n    \"\"\"Initialize a block matrix construction.\n\n    Args:\n        blocks: A nested list of expressions. Can be either:\n                - 2D: [[row1_blocks], [row2_blocks], ...] for multiple rows\n                - 1D: [block1, block2, ...] for a single row (auto-promoted to [[...]])\n                Raw values (numbers, lists, numpy arrays) are automatically\n                converted to Constant expressions.\n\n    Raises:\n        ValueError: If blocks is empty\n    \"\"\"\n    if not blocks:\n        raise ValueError(\"Block requires at least one row\")\n\n    # Auto-promote 1D list to 2D (matching numpy.block behavior)\n    # e.g., Block([a, b]) -&gt; Block([[a, b]])\n    if not isinstance(blocks[0], (list, tuple)):\n        blocks = [blocks]\n\n    # Convert all blocks to expressions\n    self.blocks = [[to_expr(block) for block in row] for row in blocks]\n\n    # Validate consistent row lengths\n    row_lengths = [len(row) for row in self.blocks]\n    if len(set(row_lengths)) &gt; 1:\n        raise ValueError(\n            f\"All rows must have the same number of blocks. Got row lengths: {row_lengths}\"\n        )\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Block.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize by recursively canonicalizing all blocks.</p> <p>If the block contains only a single element ([[a]]), returns the canonicalized element directly to simplify the expression tree.</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize by recursively canonicalizing all blocks.\n\n    If the block contains only a single element ([[a]]), returns the\n    canonicalized element directly to simplify the expression tree.\n    \"\"\"\n    canonical_blocks = [[block.canonicalize() for block in row] for row in self.blocks]\n\n    # Unwrap single-element blocks\n    if len(canonical_blocks) == 1 and len(canonical_blocks[0]) == 1:\n        return canonical_blocks[0][0]\n\n    return Block(canonical_blocks)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Block.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate block dimensions and compute output shape.</p> <p>For 2D blocks, returns (total_rows, total_cols). For N-D blocks, returns the shape after assembling blocks along the first two axes, with trailing dimensions preserved.</p> <p>Returns:</p> Type Description <code>Tuple[int, ...]</code> <p>Tuple representing the assembled block array shape</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If block dimensions are incompatible</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Validate block dimensions and compute output shape.\n\n    For 2D blocks, returns (total_rows, total_cols). For N-D blocks,\n    returns the shape after assembling blocks along the first two axes,\n    with trailing dimensions preserved.\n\n    Returns:\n        Tuple representing the assembled block array shape\n\n    Raises:\n        ValueError: If block dimensions are incompatible\n    \"\"\"\n    n_block_rows = len(self.blocks)\n    n_block_cols = len(self.blocks[0])\n\n    # Get shapes of all blocks\n    block_shapes = [[block.check_shape() for block in row] for row in self.blocks]\n\n    # Determine the maximum dimensionality across all blocks\n    max_ndim = max(len(shape) for row in block_shapes for shape in row)\n    max_ndim = max(max_ndim, 2)  # At least 2D for block assembly\n\n    # Normalize shapes: pad to max_ndim by prepending 1s\n    # Scalars () -&gt; (1, 1, ...), 1D (n,) -&gt; (1, n, ...), etc.\n    def normalize_shape(shape):\n        if len(shape) == 0:\n            return (1,) * max_ndim\n        elif len(shape) &lt; max_ndim:\n            # Prepend 1s to match max_ndim\n            return (1,) * (max_ndim - len(shape)) + shape\n        else:\n            return shape\n\n    normalized_shapes = [[normalize_shape(shape) for shape in row] for row in block_shapes]\n\n    # Validate trailing dimensions (dims 2+) match across ALL blocks\n    if max_ndim &gt; 2:\n        trailing_shape = normalized_shapes[0][0][2:]\n        for i, row_shapes in enumerate(normalized_shapes):\n            for j, shape in enumerate(row_shapes):\n                if shape[2:] != trailing_shape:\n                    raise ValueError(\n                        f\"Block[{i}][{j}] has trailing dimensions {shape[2:]}, \"\n                        f\"but Block[0][0] has {trailing_shape}. \"\n                        f\"All blocks must have matching dimensions beyond the first two.\"\n                    )\n\n    # Compute row heights (first dimension of each row must match)\n    row_heights = []\n    for i, row_shapes in enumerate(normalized_shapes):\n        heights = [s[0] for s in row_shapes]\n        if len(set(heights)) &gt; 1:\n            raise ValueError(\n                f\"Block row {i} has inconsistent heights: {heights}. \"\n                f\"All blocks in a row must have the same height.\"\n            )\n        row_heights.append(heights[0])\n\n    # Compute column widths (second dimension of each column must match)\n    col_widths = []\n    for j in range(n_block_cols):\n        widths = [normalized_shapes[i][j][1] for i in range(n_block_rows)]\n        if len(set(widths)) &gt; 1:\n            raise ValueError(\n                f\"Block column {j} has inconsistent widths: {widths}. \"\n                f\"All blocks in a column must have the same width.\"\n            )\n        col_widths.append(widths[0])\n\n    total_rows = sum(row_heights)\n    total_cols = sum(col_widths)\n\n    # Return shape with trailing dimensions if present\n    if max_ndim &gt; 2:\n        return (total_rows, total_cols) + normalized_shapes[0][0][2:]\n    return (total_rows, total_cols)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Block.children","title":"<code>children()</code>","text":"<p>Return all block expressions in row-major order.</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def children(self):\n    \"\"\"Return all block expressions in row-major order.\"\"\"\n    return [block for row in self.blocks for block in row]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.BoundaryType","title":"<code>BoundaryType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of boundary condition types for state variables.</p> <p>This enum allows users to specify boundary conditions using plain strings while maintaining type safety internally. Boundary conditions control how the optimizer handles initial and final state values.</p> <p>Attributes:</p> Name Type Description <code>FIXED</code> <code>str</code> <p>State value is fixed to a specific value</p> <code>FREE</code> <code>str</code> <p>State value is free to be optimized within bounds</p> <code>MINIMIZE</code> <code>str</code> <p>Objective term to minimize the state value</p> <code>MAXIMIZE</code> <code>str</code> <p>Objective term to maximize the state value</p> Example <p>Can use either enum or string:</p> <pre><code>BoundaryType.FIXED\n\"fixed\"  # Equivalent\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>class BoundaryType(str, Enum):\n    \"\"\"Enumeration of boundary condition types for state variables.\n\n    This enum allows users to specify boundary conditions using plain strings\n    while maintaining type safety internally. Boundary conditions control how\n    the optimizer handles initial and final state values.\n\n    Attributes:\n        FIXED (str): State value is fixed to a specific value\n        FREE (str): State value is free to be optimized within bounds\n        MINIMIZE (str): Objective term to minimize the state value\n        MAXIMIZE (str): Objective term to maximize the state value\n\n    Example:\n        Can use either enum or string:\n\n            BoundaryType.FIXED\n            \"fixed\"  # Equivalent\n    \"\"\"\n\n    FIXED = \"fixed\"\n    FREE = \"free\"\n    MINIMIZE = \"minimize\"\n    MAXIMIZE = \"maximize\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CTCS","title":"<code>CTCS</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Continuous-Time Constraint Satisfaction using augmented state dynamics.</p> <p>CTCS enables strict continuous-time constraint enforcement in discretized trajectory optimization by augmenting the state vector with additional states whose dynamics are the constraint violation penalties. By constraining these augmented states to remain at zero throughout the trajectory, the original constraints are guaranteed to be satisfied continuously, not just at discrete nodes.</p> <p>How it works:</p> <ol> <li>Each constraint (in canonical form: lhs &lt;= 0) is wrapped in a penalty function</li> <li>Augmented states s_aug_i are added with dynamics: ds_aug_i/dt = sum(penalty_j(lhs_j))    for all CTCS constraints j in group i</li> <li>Each augmented state is constrained: s_aug_i(t) = 0 for all t (strictly enforced)</li> <li>Since s_aug_i integrates the penalties, s_aug_i = 0 implies all penalties in the    group are zero, which means all constraints in the group are satisfied continuously</li> </ol> <p>Grouping and augmented states:</p> <ul> <li>CTCS constraints with the same node interval are grouped into a single augmented   state by default (their penalties are summed)</li> <li>CTCS constraints with different node intervals create separate augmented states</li> <li>Using the <code>idx</code> parameter explicitly assigns constraints to specific augmented states,   allowing manual control over grouping</li> <li>Each unique group creates one augmented state named <code>_ctcs_aug_0</code>, <code>_ctcs_aug_1</code>, etc.</li> </ul> <p>This is particularly useful for:</p> <ul> <li>Path constraints that must hold throughout the entire trajectory (not just at nodes)</li> <li>Obstacle avoidance where constraint violation between nodes could be catastrophic</li> <li>State limits that should be respected continuously (e.g., altitude &gt; 0 for aircraft)</li> <li>Ensuring smooth, feasible trajectories between discretization points</li> </ul> <p>Penalty functions (applied to constraint violations):</p> <ul> <li>squared_relu: Square(PositivePart(lhs)) - smooth, differentiable (default)</li> <li>huber: Huber(PositivePart(lhs)) - less sensitive to outliers than squared</li> <li>smooth_relu: SmoothReLU(lhs) - smooth approximation of ReLU</li> </ul> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (typically Inequality) to enforce continuously</p> <code>penalty</code> <p>Penalty function type ('squared_relu', 'huber', or 'smooth_relu')</p> <code>nodes</code> <p>Optional (start, end) tuple specifying the interval for enforcement, or None to enforce over the entire trajectory</p> <code>idx</code> <p>Optional grouping index for managing multiple augmented states. CTCS constraints with the same idx and nodes are grouped together, sharing an augmented state. If None, auto-assigned based on node intervals.</p> <code>check_nodally</code> <p>Whether to also enforce the constraint at discrete nodes for additional numerical robustness (creates both continuous and nodal constraints)</p> Example <p>Single augmented state (default behavior - same node interval):</p> <pre><code>altitude = State(\"alt\", shape=(1,))\nconstraints = [\n    (altitude &gt;= 10).over((0, 10)),  # Both constraints share\n    (altitude &lt;= 1000).over((0, 10))  # one augmented state\n]\n</code></pre> <p>Multiple augmented states (different node intervals):</p> <pre><code>constraints = [\n    (altitude &gt;= 10).over((0, 5)),  # Creates _ctcs_aug_0\n    (altitude &gt;= 20).over((5, 10))  # Creates _ctcs_aug_1\n]\n</code></pre> <p>Manual grouping with idx parameter:</p> <pre><code>constraints = [\n    (altitude &gt;= 10).over((0, 10), idx=0),    # Group 0\n    (velocity &lt;= 100).over((0, 10), idx=1),   # Group 1 (separate state)\n    (altitude &lt;= 1000).over((0, 10), idx=0)   # Also group 0\n]\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class CTCS(Expr):\n    \"\"\"Continuous-Time Constraint Satisfaction using augmented state dynamics.\n\n    CTCS enables strict continuous-time constraint enforcement in discretized trajectory\n    optimization by augmenting the state vector with additional states whose dynamics\n    are the constraint violation penalties. By constraining these augmented states to remain\n    at zero throughout the trajectory, the original constraints are guaranteed to be satisfied\n    continuously, not just at discrete nodes.\n\n    **How it works:**\n\n    1. Each constraint (in canonical form: lhs &lt;= 0) is wrapped in a penalty function\n    2. Augmented states s_aug_i are added with dynamics: ds_aug_i/dt = sum(penalty_j(lhs_j))\n       for all CTCS constraints j in group i\n    3. Each augmented state is constrained: s_aug_i(t) = 0 for all t (strictly enforced)\n    4. Since s_aug_i integrates the penalties, s_aug_i = 0 implies all penalties in the\n       group are zero, which means all constraints in the group are satisfied continuously\n\n    **Grouping and augmented states:**\n\n    - CTCS constraints with the **same node interval** are grouped into a single augmented\n      state by default (their penalties are summed)\n    - CTCS constraints with **different node intervals** create separate augmented states\n    - Using the `idx` parameter explicitly assigns constraints to specific augmented states,\n      allowing manual control over grouping\n    - Each unique group creates one augmented state named `_ctcs_aug_0`, `_ctcs_aug_1`, etc.\n\n    This is particularly useful for:\n\n    - Path constraints that must hold throughout the entire trajectory (not just at nodes)\n    - Obstacle avoidance where constraint violation between nodes could be catastrophic\n    - State limits that should be respected continuously (e.g., altitude &gt; 0 for aircraft)\n    - Ensuring smooth, feasible trajectories between discretization points\n\n    **Penalty functions** (applied to constraint violations):\n\n    - **squared_relu**: Square(PositivePart(lhs)) - smooth, differentiable (default)\n    - **huber**: Huber(PositivePart(lhs)) - less sensitive to outliers than squared\n    - **smooth_relu**: SmoothReLU(lhs) - smooth approximation of ReLU\n\n    Attributes:\n        constraint: The wrapped Constraint (typically Inequality) to enforce continuously\n        penalty: Penalty function type ('squared_relu', 'huber', or 'smooth_relu')\n        nodes: Optional (start, end) tuple specifying the interval for enforcement,\n            or None to enforce over the entire trajectory\n        idx: Optional grouping index for managing multiple augmented states.\n            CTCS constraints with the same idx and nodes are grouped together, sharing\n            an augmented state. If None, auto-assigned based on node intervals.\n        check_nodally: Whether to also enforce the constraint at discrete nodes for\n            additional numerical robustness (creates both continuous and nodal constraints)\n\n    Example:\n        Single augmented state (default behavior - same node interval):\n\n            altitude = State(\"alt\", shape=(1,))\n            constraints = [\n                (altitude &gt;= 10).over((0, 10)),  # Both constraints share\n                (altitude &lt;= 1000).over((0, 10))  # one augmented state\n            ]\n\n        Multiple augmented states (different node intervals):\n\n            constraints = [\n                (altitude &gt;= 10).over((0, 5)),  # Creates _ctcs_aug_0\n                (altitude &gt;= 20).over((5, 10))  # Creates _ctcs_aug_1\n            ]\n\n        Manual grouping with idx parameter:\n\n            constraints = [\n                (altitude &gt;= 10).over((0, 10), idx=0),    # Group 0\n                (velocity &lt;= 100).over((0, 10), idx=1),   # Group 1 (separate state)\n                (altitude &lt;= 1000).over((0, 10), idx=0)   # Also group 0\n            ]\n    \"\"\"\n\n    def __init__(\n        self,\n        constraint: Constraint,\n        penalty: str = \"squared_relu\",\n        nodes: Optional[Tuple[int, int]] = None,\n        idx: Optional[int] = None,\n        check_nodally: bool = False,\n    ):\n        \"\"\"Initialize a CTCS constraint.\n\n        Args:\n            constraint: The Constraint to enforce continuously (typically an Inequality)\n            penalty: Penalty function type. Options:\n                - 'squared_relu': Square(PositivePart(lhs)) - default, smooth, differentiable\n                - 'huber': Huber(PositivePart(lhs)) - robust to outliers\n                - 'smooth_relu': SmoothReLU(lhs) - smooth ReLU approximation\n            nodes: Optional (start, end) tuple of node indices defining the enforcement interval.\n                None means enforce over the entire trajectory. Must satisfy start &lt; end.\n                CTCS constraints with the same nodes are automatically grouped together.\n            idx: Optional grouping index for multiple augmented states. Allows organizing\n                multiple CTCS constraints with separate augmented state variables.\n                If None, constraints are auto-grouped by their node intervals.\n                Explicitly setting idx allows manual control over which constraints\n                share an augmented state.\n            check_nodally: If True, also enforce the constraint at discrete nodes for\n                numerical stability (creates both continuous and nodal constraints).\n                Defaults to False.\n\n        Raises:\n            TypeError: If constraint is not a Constraint instance\n            ValueError: If nodes is not None or a 2-tuple of integers\n            ValueError: If nodes[0] &gt;= nodes[1] (invalid interval)\n        \"\"\"\n        if not isinstance(constraint, Constraint):\n            raise TypeError(\"CTCS must wrap a Constraint\")\n\n        # Validate nodes parameter for CTCS\n        if nodes is not None:\n            if not isinstance(nodes, tuple) or len(nodes) != 2:\n                raise ValueError(\n                    \"CTCS constraints must specify nodes as a tuple of (start, end) or None \"\n                    \"for all nodes\"\n                )\n            if not all(isinstance(n, int) for n in nodes):\n                raise ValueError(\"CTCS node indices must be integers\")\n            if nodes[0] &gt;= nodes[1]:\n                raise ValueError(\"CTCS node range must have start &lt; end\")\n\n        self.constraint = constraint\n        self.penalty = penalty\n        self.nodes = nodes  # (start, end) node range or None for all nodes\n        self.idx = idx  # Optional grouping index for multiple augmented states\n        # Whether to also enforce this constraint nodally for numerical stability\n        self.check_nodally = check_nodally\n\n    def children(self):\n        \"\"\"Return the wrapped constraint as the only child.\n\n        Returns:\n            list: Single-element list containing the wrapped constraint\n        \"\"\"\n        return [self.constraint]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the inner constraint while preserving CTCS parameters.\n\n        Returns:\n            CTCS: A new CTCS with canonicalized inner constraint and same parameters\n        \"\"\"\n        canon_constraint = self.constraint.canonicalize()\n        return CTCS(\n            canon_constraint,\n            penalty=self.penalty,\n            nodes=self.nodes,\n            idx=self.idx,\n            check_nodally=self.check_nodally,\n        )\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Validate the constraint and penalty expression shapes.\n\n        CTCS transforms the wrapped constraint into a penalty expression that is\n        summed (integrated) over the trajectory, always producing a scalar result.\n\n        Returns:\n            tuple: Empty tuple () representing scalar shape\n\n        Raises:\n            ValueError: If the wrapped constraint has invalid shape\n            ValueError: If the generated penalty expression is not scalar\n        \"\"\"\n        # First validate the wrapped constraint's shape\n        self.constraint.check_shape()\n\n        # Also validate the penalty expression that would be generated\n        try:\n            penalty_expr = self.penalty_expr()\n            penalty_shape = penalty_expr.check_shape()\n\n            # The penalty expression should always be scalar due to Sum wrapper\n            if penalty_shape != ():\n                raise ValueError(\n                    f\"CTCS penalty expression should be scalar, but got shape {penalty_shape}\"\n                )\n        except Exception as e:\n            # Re-raise with more context about which CTCS node failed\n            raise ValueError(f\"CTCS penalty expression validation failed: {e}\") from e\n\n        # CTCS always produces a scalar due to the Sum in penalty_expr\n        return ()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash CTCS including all its parameters.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"CTCS\")\n        # Hash penalty type\n        hasher.update(self.penalty.encode())\n        # Hash nodes interval\n        if self.nodes is not None:\n            hasher.update(struct.pack(\"&gt;ii\", self.nodes[0], self.nodes[1]))\n        else:\n            hasher.update(b\"None\")\n        # Hash idx\n        if self.idx is not None:\n            hasher.update(struct.pack(\"&gt;i\", self.idx))\n        else:\n            hasher.update(b\"None\")\n        # Hash check_nodally\n        hasher.update(b\"1\" if self.check_nodally else b\"0\")\n        # Hash the wrapped constraint\n        self.constraint._hash_into(hasher)\n\n    def over(self, interval: tuple[int, int]) -&gt; \"CTCS\":\n        \"\"\"Set or update the continuous interval for this CTCS constraint.\n\n        Args:\n            interval: Tuple of (start, end) node indices defining the enforcement interval\n\n        Returns:\n            CTCS: New CTCS constraint with the specified interval\n\n        Example:\n            Define constraint over range:\n\n                constraint = (altitude &gt;= 10).over((0, 50))\n\n            Update interval to cover different range:\n\n                constraint_updated = constraint.over((50, 100))\n        \"\"\"\n        return CTCS(\n            self.constraint,\n            penalty=self.penalty,\n            nodes=interval,\n            idx=self.idx,\n            check_nodally=self.check_nodally,\n        )\n\n    def __repr__(self):\n        \"\"\"String representation of the CTCS constraint.\n\n        Returns:\n            str: String showing constraint, penalty type, and optional parameters\n        \"\"\"\n        parts = [f\"{self.constraint!r}\", f\"penalty={self.penalty!r}\"]\n        if self.nodes is not None:\n            parts.append(f\"nodes={self.nodes}\")\n        if self.idx is not None:\n            parts.append(f\"idx={self.idx}\")\n        if self.check_nodally:\n            parts.append(f\"check_nodally={self.check_nodally}\")\n        return f\"CTCS({', '.join(parts)})\"\n\n    def penalty_expr(self) -&gt; Expr:\n        \"\"\"Build the penalty expression for this CTCS constraint.\n\n        Transforms the constraint's left-hand side (in canonical form: lhs &lt;= 0)\n        into a penalty expression using the specified penalty function. The penalty\n        is zero when the constraint is satisfied and positive when violated.\n\n        This penalty expression becomes part of the dynamics of an augmented state.\n        Multiple CTCS constraints in the same group (same idx) have their penalties\n        summed: ds_aug_i/dt = sum(penalty_j) for all j in group i. By constraining\n        s_aug_i(t) = 0 for all t, we ensure all penalties in the group are zero,\n        which strictly enforces all constraints in the group continuously.\n\n        Returns:\n            Expr: Sum of the penalty function applied to the constraint violation\n\n        Raises:\n            ValueError: If an unknown penalty type is specified\n\n        Note:\n            This method is used internally during problem compilation to create\n            augmented state dynamics. Multiple penalty expressions with the same\n            idx are summed together before being added to the dynamics vector via Concat.\n        \"\"\"\n        lhs = self.constraint.lhs\n\n        if self.penalty == \"squared_relu\":\n            from openscvx.symbolic.expr.math import PositivePart, Square\n\n            penalty = Square(PositivePart(lhs))\n        elif self.penalty == \"huber\":\n            from openscvx.symbolic.expr.math import Huber, PositivePart\n\n            penalty = Huber(PositivePart(lhs))\n        elif self.penalty == \"smooth_relu\":\n            from openscvx.symbolic.expr.math import SmoothReLU\n\n            penalty = SmoothReLU(lhs)\n        else:\n            raise ValueError(f\"Unknown penalty {self.penalty!r}\")\n\n        return Sum(penalty)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CTCS.__init__","title":"<code>__init__(constraint: Constraint, penalty: str = 'squared_relu', nodes: Optional[Tuple[int, int]] = None, idx: Optional[int] = None, check_nodally: bool = False)</code>","text":"<p>Initialize a CTCS constraint.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>Constraint</code> <p>The Constraint to enforce continuously (typically an Inequality)</p> required <code>penalty</code> <code>str</code> <p>Penalty function type. Options: - 'squared_relu': Square(PositivePart(lhs)) - default, smooth, differentiable - 'huber': Huber(PositivePart(lhs)) - robust to outliers - 'smooth_relu': SmoothReLU(lhs) - smooth ReLU approximation</p> <code>'squared_relu'</code> <code>nodes</code> <code>Optional[Tuple[int, int]]</code> <p>Optional (start, end) tuple of node indices defining the enforcement interval. None means enforce over the entire trajectory. Must satisfy start &lt; end. CTCS constraints with the same nodes are automatically grouped together.</p> <code>None</code> <code>idx</code> <code>Optional[int]</code> <p>Optional grouping index for multiple augmented states. Allows organizing multiple CTCS constraints with separate augmented state variables. If None, constraints are auto-grouped by their node intervals. Explicitly setting idx allows manual control over which constraints share an augmented state.</p> <code>None</code> <code>check_nodally</code> <code>bool</code> <p>If True, also enforce the constraint at discrete nodes for numerical stability (creates both continuous and nodal constraints). Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If constraint is not a Constraint instance</p> <code>ValueError</code> <p>If nodes is not None or a 2-tuple of integers</p> <code>ValueError</code> <p>If nodes[0] &gt;= nodes[1] (invalid interval)</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def __init__(\n    self,\n    constraint: Constraint,\n    penalty: str = \"squared_relu\",\n    nodes: Optional[Tuple[int, int]] = None,\n    idx: Optional[int] = None,\n    check_nodally: bool = False,\n):\n    \"\"\"Initialize a CTCS constraint.\n\n    Args:\n        constraint: The Constraint to enforce continuously (typically an Inequality)\n        penalty: Penalty function type. Options:\n            - 'squared_relu': Square(PositivePart(lhs)) - default, smooth, differentiable\n            - 'huber': Huber(PositivePart(lhs)) - robust to outliers\n            - 'smooth_relu': SmoothReLU(lhs) - smooth ReLU approximation\n        nodes: Optional (start, end) tuple of node indices defining the enforcement interval.\n            None means enforce over the entire trajectory. Must satisfy start &lt; end.\n            CTCS constraints with the same nodes are automatically grouped together.\n        idx: Optional grouping index for multiple augmented states. Allows organizing\n            multiple CTCS constraints with separate augmented state variables.\n            If None, constraints are auto-grouped by their node intervals.\n            Explicitly setting idx allows manual control over which constraints\n            share an augmented state.\n        check_nodally: If True, also enforce the constraint at discrete nodes for\n            numerical stability (creates both continuous and nodal constraints).\n            Defaults to False.\n\n    Raises:\n        TypeError: If constraint is not a Constraint instance\n        ValueError: If nodes is not None or a 2-tuple of integers\n        ValueError: If nodes[0] &gt;= nodes[1] (invalid interval)\n    \"\"\"\n    if not isinstance(constraint, Constraint):\n        raise TypeError(\"CTCS must wrap a Constraint\")\n\n    # Validate nodes parameter for CTCS\n    if nodes is not None:\n        if not isinstance(nodes, tuple) or len(nodes) != 2:\n            raise ValueError(\n                \"CTCS constraints must specify nodes as a tuple of (start, end) or None \"\n                \"for all nodes\"\n            )\n        if not all(isinstance(n, int) for n in nodes):\n            raise ValueError(\"CTCS node indices must be integers\")\n        if nodes[0] &gt;= nodes[1]:\n            raise ValueError(\"CTCS node range must have start &lt; end\")\n\n    self.constraint = constraint\n    self.penalty = penalty\n    self.nodes = nodes  # (start, end) node range or None for all nodes\n    self.idx = idx  # Optional grouping index for multiple augmented states\n    # Whether to also enforce this constraint nodally for numerical stability\n    self.check_nodally = check_nodally\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CTCS.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the inner constraint while preserving CTCS parameters.</p> <p>Returns:</p> Name Type Description <code>CTCS</code> <code>Expr</code> <p>A new CTCS with canonicalized inner constraint and same parameters</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the inner constraint while preserving CTCS parameters.\n\n    Returns:\n        CTCS: A new CTCS with canonicalized inner constraint and same parameters\n    \"\"\"\n    canon_constraint = self.constraint.canonicalize()\n    return CTCS(\n        canon_constraint,\n        penalty=self.penalty,\n        nodes=self.nodes,\n        idx=self.idx,\n        check_nodally=self.check_nodally,\n    )\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CTCS.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the constraint and penalty expression shapes.</p> <p>CTCS transforms the wrapped constraint into a penalty expression that is summed (integrated) over the trajectory, always producing a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the wrapped constraint has invalid shape</p> <code>ValueError</code> <p>If the generated penalty expression is not scalar</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Validate the constraint and penalty expression shapes.\n\n    CTCS transforms the wrapped constraint into a penalty expression that is\n    summed (integrated) over the trajectory, always producing a scalar result.\n\n    Returns:\n        tuple: Empty tuple () representing scalar shape\n\n    Raises:\n        ValueError: If the wrapped constraint has invalid shape\n        ValueError: If the generated penalty expression is not scalar\n    \"\"\"\n    # First validate the wrapped constraint's shape\n    self.constraint.check_shape()\n\n    # Also validate the penalty expression that would be generated\n    try:\n        penalty_expr = self.penalty_expr()\n        penalty_shape = penalty_expr.check_shape()\n\n        # The penalty expression should always be scalar due to Sum wrapper\n        if penalty_shape != ():\n            raise ValueError(\n                f\"CTCS penalty expression should be scalar, but got shape {penalty_shape}\"\n            )\n    except Exception as e:\n        # Re-raise with more context about which CTCS node failed\n        raise ValueError(f\"CTCS penalty expression validation failed: {e}\") from e\n\n    # CTCS always produces a scalar due to the Sum in penalty_expr\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CTCS.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def children(self):\n    \"\"\"Return the wrapped constraint as the only child.\n\n    Returns:\n        list: Single-element list containing the wrapped constraint\n    \"\"\"\n    return [self.constraint]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CTCS.over","title":"<code>over(interval: tuple[int, int]) -&gt; CTCS</code>","text":"<p>Set or update the continuous interval for this CTCS constraint.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>tuple[int, int]</code> <p>Tuple of (start, end) node indices defining the enforcement interval</p> required <p>Returns:</p> Name Type Description <code>CTCS</code> <code>CTCS</code> <p>New CTCS constraint with the specified interval</p> Example <p>Define constraint over range:</p> <pre><code>constraint = (altitude &gt;= 10).over((0, 50))\n</code></pre> <p>Update interval to cover different range:</p> <pre><code>constraint_updated = constraint.over((50, 100))\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def over(self, interval: tuple[int, int]) -&gt; \"CTCS\":\n    \"\"\"Set or update the continuous interval for this CTCS constraint.\n\n    Args:\n        interval: Tuple of (start, end) node indices defining the enforcement interval\n\n    Returns:\n        CTCS: New CTCS constraint with the specified interval\n\n    Example:\n        Define constraint over range:\n\n            constraint = (altitude &gt;= 10).over((0, 50))\n\n        Update interval to cover different range:\n\n            constraint_updated = constraint.over((50, 100))\n    \"\"\"\n    return CTCS(\n        self.constraint,\n        penalty=self.penalty,\n        nodes=interval,\n        idx=self.idx,\n        check_nodally=self.check_nodally,\n    )\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CTCS.penalty_expr","title":"<code>penalty_expr() -&gt; Expr</code>","text":"<p>Build the penalty expression for this CTCS constraint.</p> <p>Transforms the constraint's left-hand side (in canonical form: lhs &lt;= 0) into a penalty expression using the specified penalty function. The penalty is zero when the constraint is satisfied and positive when violated.</p> <p>This penalty expression becomes part of the dynamics of an augmented state. Multiple CTCS constraints in the same group (same idx) have their penalties summed: ds_aug_i/dt = sum(penalty_j) for all j in group i. By constraining s_aug_i(t) = 0 for all t, we ensure all penalties in the group are zero, which strictly enforces all constraints in the group continuously.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Sum of the penalty function applied to the constraint violation</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown penalty type is specified</p> Note <p>This method is used internally during problem compilation to create augmented state dynamics. Multiple penalty expressions with the same idx are summed together before being added to the dynamics vector via Concat.</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def penalty_expr(self) -&gt; Expr:\n    \"\"\"Build the penalty expression for this CTCS constraint.\n\n    Transforms the constraint's left-hand side (in canonical form: lhs &lt;= 0)\n    into a penalty expression using the specified penalty function. The penalty\n    is zero when the constraint is satisfied and positive when violated.\n\n    This penalty expression becomes part of the dynamics of an augmented state.\n    Multiple CTCS constraints in the same group (same idx) have their penalties\n    summed: ds_aug_i/dt = sum(penalty_j) for all j in group i. By constraining\n    s_aug_i(t) = 0 for all t, we ensure all penalties in the group are zero,\n    which strictly enforces all constraints in the group continuously.\n\n    Returns:\n        Expr: Sum of the penalty function applied to the constraint violation\n\n    Raises:\n        ValueError: If an unknown penalty type is specified\n\n    Note:\n        This method is used internally during problem compilation to create\n        augmented state dynamics. Multiple penalty expressions with the same\n        idx are summed together before being added to the dynamics vector via Concat.\n    \"\"\"\n    lhs = self.constraint.lhs\n\n    if self.penalty == \"squared_relu\":\n        from openscvx.symbolic.expr.math import PositivePart, Square\n\n        penalty = Square(PositivePart(lhs))\n    elif self.penalty == \"huber\":\n        from openscvx.symbolic.expr.math import Huber, PositivePart\n\n        penalty = Huber(PositivePart(lhs))\n    elif self.penalty == \"smooth_relu\":\n        from openscvx.symbolic.expr.math import SmoothReLU\n\n        penalty = SmoothReLU(lhs)\n    else:\n        raise ValueError(f\"Unknown penalty {self.penalty!r}\")\n\n    return Sum(penalty)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Concat","title":"<code>Concat</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Concatenation operation for symbolic expressions.</p> <p>Concatenates a sequence of expressions along their first dimension. All inputs must have the same rank and matching dimensions except for the first dimension.</p> <p>Attributes:</p> Name Type Description <code>exprs</code> <p>Tuple of expressions to concatenate</p> Example <p>Define a Concat expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(4,))\nz = Concat(x, y)  # Creates Concat(x, y), result shape (7,)\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Concat(Expr):\n    \"\"\"Concatenation operation for symbolic expressions.\n\n    Concatenates a sequence of expressions along their first dimension. All inputs\n    must have the same rank and matching dimensions except for the first dimension.\n\n    Attributes:\n        exprs: Tuple of expressions to concatenate\n\n    Example:\n        Define a Concat expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(4,))\n            z = Concat(x, y)  # Creates Concat(x, y), result shape (7,)\n    \"\"\"\n\n    def __init__(self, *exprs: Expr):\n        \"\"\"Initialize a concatenation operation.\n\n        Args:\n            *exprs: Expressions to concatenate along the first dimension\n        \"\"\"\n        # wrap raw values as Constant if needed\n        self.exprs = [to_expr(e) for e in exprs]\n\n    def children(self):\n        return list(self.exprs)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize concatenation by canonicalizing all operands.\n\n        Returns:\n            Expr: Canonical form of the concatenation expression\n        \"\"\"\n        exprs = [e.canonicalize() for e in self.exprs]\n        return Concat(*exprs)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check concatenation shape compatibility and return result shape.\"\"\"\n        shapes = [e.check_shape() for e in self.exprs]\n        shapes = [(1,) if len(s) == 0 else s for s in shapes]\n        rank = len(shapes[0])\n        if any(len(s) != rank for s in shapes):\n            raise ValueError(f\"Concat rank mismatch: {shapes}\")\n        if any(s[1:] != shapes[0][1:] for s in shapes[1:]):\n            raise ValueError(f\"Concat non-0 dims differ: {shapes}\")\n        return (sum(s[0] for s in shapes),) + shapes[0][1:]\n\n    def __repr__(self):\n        inner = \", \".join(repr(e) for e in self.exprs)\n        return f\"Concat({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Concat.__init__","title":"<code>__init__(*exprs: Expr)</code>","text":"<p>Initialize a concatenation operation.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>Expr</code> <p>Expressions to concatenate along the first dimension</p> <code>()</code> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def __init__(self, *exprs: Expr):\n    \"\"\"Initialize a concatenation operation.\n\n    Args:\n        *exprs: Expressions to concatenate along the first dimension\n    \"\"\"\n    # wrap raw values as Constant if needed\n    self.exprs = [to_expr(e) for e in exprs]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Concat.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize concatenation by canonicalizing all operands.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the concatenation expression</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize concatenation by canonicalizing all operands.\n\n    Returns:\n        Expr: Canonical form of the concatenation expression\n    \"\"\"\n    exprs = [e.canonicalize() for e in self.exprs]\n    return Concat(*exprs)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Concat.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check concatenation shape compatibility and return result shape.</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check concatenation shape compatibility and return result shape.\"\"\"\n    shapes = [e.check_shape() for e in self.exprs]\n    shapes = [(1,) if len(s) == 0 else s for s in shapes]\n    rank = len(shapes[0])\n    if any(len(s) != rank for s in shapes):\n        raise ValueError(f\"Concat rank mismatch: {shapes}\")\n    if any(s[1:] != shapes[0][1:] for s in shapes[1:]):\n        raise ValueError(f\"Concat non-0 dims differ: {shapes}\")\n    return (sum(s[0] for s in shapes),) + shapes[0][1:]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constant","title":"<code>Constant</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Constant value expression.</p> <p>Represents a constant numeric value in the expression tree. Constants are automatically normalized (squeezed) upon construction to ensure consistency.</p> <p>Attributes:</p> Name Type Description <code>value</code> <p>The numpy array representing the constant value (squeezed)</p> Example <p>Define constants:</p> <pre><code>c1 = Constant(5.0)        # Scalar constant\nc2 = Constant([1, 2, 3])  # Vector constant\nc3 = to_expr(10)          # Also creates a Constant\n</code></pre> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class Constant(Expr):\n    \"\"\"Constant value expression.\n\n    Represents a constant numeric value in the expression tree. Constants are\n    automatically normalized (squeezed) upon construction to ensure consistency.\n\n    Attributes:\n        value: The numpy array representing the constant value (squeezed)\n\n    Example:\n        Define constants:\n\n            c1 = Constant(5.0)        # Scalar constant\n            c2 = Constant([1, 2, 3])  # Vector constant\n            c3 = to_expr(10)          # Also creates a Constant\n    \"\"\"\n\n    def __init__(self, value: np.ndarray):\n        \"\"\"Initialize a constant expression.\n\n        Args:\n            value: Numeric value or numpy array to wrap as a constant.\n                   Will be converted to numpy array and squeezed.\n        \"\"\"\n        # Normalize immediately upon construction to ensure consistency\n        # This ensures Constant(5.0) and Constant([5.0]) create identical objects\n        if not isinstance(value, np.ndarray):\n            value = np.array(value, dtype=float)\n        self.value = np.squeeze(value)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Constants are already in canonical form.\n\n        Returns:\n            Expr: Returns self since constants are already canonical\n        \"\"\"\n        return self\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Return the shape of this constant's value.\n\n        Returns:\n            tuple: The shape of the constant's numpy array value\n        \"\"\"\n        # Verify the invariant: constants should already be squeezed during construction\n        original_shape = self.value.shape\n        squeezed_shape = np.squeeze(self.value).shape\n        if original_shape != squeezed_shape:\n            raise ValueError(\n                f\"Constant not properly normalized: has shape {original_shape} \"\n                \"but should have shape {squeezed_shape}. \"\n                \"Constants should be squeezed during construction.\"\n            )\n        return self.value.shape\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash constant by its value.\n\n        Constants are hashed by their actual numeric value, ensuring that\n        expressions with the same constant values produce the same hash.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Constant\")\n        hasher.update(str(self.value.shape).encode())\n        hasher.update(self.value.tobytes())\n\n    def __repr__(self):\n        # Show clean representation - always show as Python values, not numpy arrays\n        if self.value.ndim == 0:\n            # Scalar: show as plain number\n            return f\"Const({self.value.item()!r})\"\n        else:\n            # Array: show as Python list for readability\n            return f\"Const({self.value.tolist()!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constant.__init__","title":"<code>__init__(value: np.ndarray)</code>","text":"<p>Initialize a constant expression.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>ndarray</code> <p>Numeric value or numpy array to wrap as a constant.    Will be converted to numpy array and squeezed.</p> required Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def __init__(self, value: np.ndarray):\n    \"\"\"Initialize a constant expression.\n\n    Args:\n        value: Numeric value or numpy array to wrap as a constant.\n               Will be converted to numpy array and squeezed.\n    \"\"\"\n    # Normalize immediately upon construction to ensure consistency\n    # This ensures Constant(5.0) and Constant([5.0]) create identical objects\n    if not isinstance(value, np.ndarray):\n        value = np.array(value, dtype=float)\n    self.value = np.squeeze(value)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constant.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Constants are already in canonical form.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Returns self since constants are already canonical</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Constants are already in canonical form.\n\n    Returns:\n        Expr: Returns self since constants are already canonical\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constant.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Return the shape of this constant's value.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The shape of the constant's numpy array value</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Return the shape of this constant's value.\n\n    Returns:\n        tuple: The shape of the constant's numpy array value\n    \"\"\"\n    # Verify the invariant: constants should already be squeezed during construction\n    original_shape = self.value.shape\n    squeezed_shape = np.squeeze(self.value).shape\n    if original_shape != squeezed_shape:\n        raise ValueError(\n            f\"Constant not properly normalized: has shape {original_shape} \"\n            \"but should have shape {squeezed_shape}. \"\n            \"Constants should be squeezed during construction.\"\n        )\n    return self.value.shape\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constraint","title":"<code>Constraint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Abstract base class for optimization constraints.</p> <p>Constraints represent relationships between expressions that must be satisfied in the optimization problem. This base class provides common functionality for both equality and inequality constraints.</p> <p>Attributes:</p> Name Type Description <code>lhs</code> <p>Left-hand side expression</p> <code>rhs</code> <p>Right-hand side expression</p> <code>is_convex</code> <p>Flag indicating if the constraint is known to be convex</p> Note <p>Constraints are canonicalized to standard form: (lhs - rhs) {op} 0</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class Constraint(Expr):\n    \"\"\"Abstract base class for optimization constraints.\n\n    Constraints represent relationships between expressions that must be satisfied\n    in the optimization problem. This base class provides common functionality for\n    both equality and inequality constraints.\n\n    Attributes:\n        lhs: Left-hand side expression\n        rhs: Right-hand side expression\n        is_convex: Flag indicating if the constraint is known to be convex\n\n    Note:\n        Constraints are canonicalized to standard form: (lhs - rhs) {op} 0\n    \"\"\"\n\n    def __init__(self, lhs: Expr, rhs: Expr):\n        \"\"\"Initialize a constraint.\n\n        Args:\n            lhs: Left-hand side expression\n            rhs: Right-hand side expression\n        \"\"\"\n        self.lhs = lhs\n        self.rhs = rhs\n        self.is_convex = False\n\n    def children(self):\n        return [self.lhs, self.rhs]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize constraint to standard form: (lhs - rhs) {op} 0.\n\n        This works for both Equality and Inequality by using type(self) to\n        construct the appropriate subclass type.\n        \"\"\"\n        diff = Sub(self.lhs, self.rhs)\n        canon_diff = diff.canonicalize()\n        new_constraint = type(self)(canon_diff, Constant(np.array(0)))\n        new_constraint.is_convex = self.is_convex  # Preserve convex flag\n        return new_constraint\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that constraint operands are broadcastable. Returns scalar shape.\"\"\"\n        L_shape = self.lhs.check_shape()\n        R_shape = self.rhs.check_shape()\n\n        # Figure out their broadcasted shape (or error if incompatible)\n        try:\n            np.broadcast_shapes(L_shape, R_shape)\n        except ValueError as e:\n            constraint_type = type(self).__name__\n            raise ValueError(f\"{constraint_type} not broadcastable: {L_shape} vs {R_shape}\") from e\n\n        # Allow vector constraints - they're interpreted element-wise\n        # Return () as constraints always produce a scalar\n        return ()\n\n    def at(self, nodes: Union[list, tuple]):\n        \"\"\"Apply this constraint only at specific discrete nodes.\n\n        Args:\n            nodes: List of node indices where the constraint should be enforced\n\n        Returns:\n            NodalConstraint wrapping this constraint with node specification\n        \"\"\"\n        if isinstance(nodes, int):\n            nodes = [nodes]\n        return NodalConstraint(self, list(nodes))\n\n    def over(\n        self,\n        interval: tuple[int, int],\n        penalty: str = \"squared_relu\",\n        idx: Optional[int] = None,\n        check_nodally: bool = False,\n    ):\n        \"\"\"Apply this constraint over a continuous interval using CTCS.\n\n        Args:\n            interval: Tuple of (start, end) node indices for the continuous interval\n            penalty: Penalty function type (\"squared_relu\", \"huber\", \"smooth_relu\")\n            idx: Optional grouping index for multiple augmented states\n            check_nodally: Whether to also enforce this constraint nodally\n\n        Returns:\n            CTCS constraint wrapping this constraint with interval specification\n        \"\"\"\n        return CTCS(self, penalty=penalty, nodes=interval, idx=idx, check_nodally=check_nodally)\n\n    def convex(self) -&gt; \"Constraint\":\n        \"\"\"Mark this constraint as convex for CVXPy lowering.\n\n        Returns:\n            Self with convex flag set to True (enables method chaining)\n        \"\"\"\n        self.is_convex = True\n        return self\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constraint.__init__","title":"<code>__init__(lhs: Expr, rhs: Expr)</code>","text":"<p>Initialize a constraint.</p> <p>Parameters:</p> Name Type Description Default <code>lhs</code> <code>Expr</code> <p>Left-hand side expression</p> required <code>rhs</code> <code>Expr</code> <p>Right-hand side expression</p> required Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def __init__(self, lhs: Expr, rhs: Expr):\n    \"\"\"Initialize a constraint.\n\n    Args:\n        lhs: Left-hand side expression\n        rhs: Right-hand side expression\n    \"\"\"\n    self.lhs = lhs\n    self.rhs = rhs\n    self.is_convex = False\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constraint.at","title":"<code>at(nodes: Union[list, tuple])</code>","text":"<p>Apply this constraint only at specific discrete nodes.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>Union[list, tuple]</code> <p>List of node indices where the constraint should be enforced</p> required <p>Returns:</p> Type Description <p>NodalConstraint wrapping this constraint with node specification</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def at(self, nodes: Union[list, tuple]):\n    \"\"\"Apply this constraint only at specific discrete nodes.\n\n    Args:\n        nodes: List of node indices where the constraint should be enforced\n\n    Returns:\n        NodalConstraint wrapping this constraint with node specification\n    \"\"\"\n    if isinstance(nodes, int):\n        nodes = [nodes]\n    return NodalConstraint(self, list(nodes))\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constraint.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize constraint to standard form: (lhs - rhs) {op} 0.</p> <p>This works for both Equality and Inequality by using type(self) to construct the appropriate subclass type.</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize constraint to standard form: (lhs - rhs) {op} 0.\n\n    This works for both Equality and Inequality by using type(self) to\n    construct the appropriate subclass type.\n    \"\"\"\n    diff = Sub(self.lhs, self.rhs)\n    canon_diff = diff.canonicalize()\n    new_constraint = type(self)(canon_diff, Constant(np.array(0)))\n    new_constraint.is_convex = self.is_convex  # Preserve convex flag\n    return new_constraint\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constraint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that constraint operands are broadcastable. Returns scalar shape.</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that constraint operands are broadcastable. Returns scalar shape.\"\"\"\n    L_shape = self.lhs.check_shape()\n    R_shape = self.rhs.check_shape()\n\n    # Figure out their broadcasted shape (or error if incompatible)\n    try:\n        np.broadcast_shapes(L_shape, R_shape)\n    except ValueError as e:\n        constraint_type = type(self).__name__\n        raise ValueError(f\"{constraint_type} not broadcastable: {L_shape} vs {R_shape}\") from e\n\n    # Allow vector constraints - they're interpreted element-wise\n    # Return () as constraints always produce a scalar\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constraint.convex","title":"<code>convex() -&gt; Constraint</code>","text":"<p>Mark this constraint as convex for CVXPy lowering.</p> <p>Returns:</p> Type Description <code>Constraint</code> <p>Self with convex flag set to True (enables method chaining)</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def convex(self) -&gt; \"Constraint\":\n    \"\"\"Mark this constraint as convex for CVXPy lowering.\n\n    Returns:\n        Self with convex flag set to True (enables method chaining)\n    \"\"\"\n    self.is_convex = True\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Constraint.over","title":"<code>over(interval: tuple[int, int], penalty: str = 'squared_relu', idx: Optional[int] = None, check_nodally: bool = False)</code>","text":"<p>Apply this constraint over a continuous interval using CTCS.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>tuple[int, int]</code> <p>Tuple of (start, end) node indices for the continuous interval</p> required <code>penalty</code> <code>str</code> <p>Penalty function type (\"squared_relu\", \"huber\", \"smooth_relu\")</p> <code>'squared_relu'</code> <code>idx</code> <code>Optional[int]</code> <p>Optional grouping index for multiple augmented states</p> <code>None</code> <code>check_nodally</code> <code>bool</code> <p>Whether to also enforce this constraint nodally</p> <code>False</code> <p>Returns:</p> Type Description <p>CTCS constraint wrapping this constraint with interval specification</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def over(\n    self,\n    interval: tuple[int, int],\n    penalty: str = \"squared_relu\",\n    idx: Optional[int] = None,\n    check_nodally: bool = False,\n):\n    \"\"\"Apply this constraint over a continuous interval using CTCS.\n\n    Args:\n        interval: Tuple of (start, end) node indices for the continuous interval\n        penalty: Penalty function type (\"squared_relu\", \"huber\", \"smooth_relu\")\n        idx: Optional grouping index for multiple augmented states\n        check_nodally: Whether to also enforce this constraint nodally\n\n    Returns:\n        CTCS constraint wrapping this constraint with interval specification\n    \"\"\"\n    return CTCS(self, penalty=penalty, nodes=interval, idx=idx, check_nodally=check_nodally)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Control","title":"<code>Control</code>","text":"<p>               Bases: <code>Variable</code></p> <p>Control input variable for trajectory optimization problems.</p> <p>Control represents control input variables (actuator commands) in a trajectory optimization problem. Unlike State variables which evolve according to dynamics, Controls are direct decision variables that the optimizer can freely adjust (within specified bounds) at each time step to influence the system dynamics.</p> <p>Controls are conceptually similar to State variables but simpler - they don't have boundary conditions (initial/final specifications) since controls are typically not constrained at the endpoints. Like States, Controls support:</p> <ul> <li>Min/max bounds to enforce actuator limits</li> <li>Initial trajectory guesses to help the optimizer converge</li> </ul> <p>Common examples of control inputs include:</p> <ul> <li>Thrust magnitude and direction for spacecraft/rockets</li> <li>Throttle settings for engines</li> <li>Steering angles for vehicles</li> <li>Torques for robotic manipulators</li> <li>Force/acceleration commands</li> </ul> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name identifier for this control variable</p> <code>_shape</code> <code>tuple[int, ...]</code> <p>Shape of the control vector (typically 1D like (3,) for 3D thrust)</p> <code>_slice</code> <code>slice | None</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <code>ndarray | None</code> <p>Minimum bounds for each element of the control</p> <code>_max</code> <code>ndarray | None</code> <p>Maximum bounds for each element of the control</p> <code>_guess</code> <code>ndarray | None</code> <p>Initial guess for the control trajectory (n_points, n_controls)</p> Example <p>Scalar throttle control bounded [0, 1]:</p> <pre><code>throttle = Control(\"throttle\", shape=(1,))\nthrottle.min = [0.0]\nthrottle.max = [1.0]\nthrottle.guess = np.full((50, 1), 0.5)  # Start at 50% throttle\n</code></pre> <p>3D thrust vector for spacecraft:</p> <pre><code>thrust = Control(\"thrust\", shape=(3,))\nthrust.min = [-10, -10, 0]    # No downward thrust\nthrust.max = [10, 10, 50]     # Limited thrust\nthrust.guess = np.zeros((50, 3))  # Initialize with zero thrust\n</code></pre> <p>2D steering control (left/right, forward/backward):</p> <pre><code>steer = Control(\"steer\", shape=(2,))\nsteer.min = [-1, -1]\nsteer.max = [1, 1]\nsteer.guess = np.linspace([0, 0], [0, 1], 50)  # Gradual acceleration\n</code></pre> Source code in <code>openscvx/symbolic/expr/control.py</code> <pre><code>class Control(Variable):\n    \"\"\"Control input variable for trajectory optimization problems.\n\n    Control represents control input variables (actuator commands) in a trajectory\n    optimization problem. Unlike State variables which evolve according to dynamics,\n    Controls are direct decision variables that the optimizer can freely adjust\n    (within specified bounds) at each time step to influence the system dynamics.\n\n    Controls are conceptually similar to State variables but simpler - they don't\n    have boundary conditions (initial/final specifications) since controls are\n    typically not constrained at the endpoints. Like States, Controls support:\n\n    - Min/max bounds to enforce actuator limits\n    - Initial trajectory guesses to help the optimizer converge\n\n    Common examples of control inputs include:\n\n    - Thrust magnitude and direction for spacecraft/rockets\n    - Throttle settings for engines\n    - Steering angles for vehicles\n    - Torques for robotic manipulators\n    - Force/acceleration commands\n\n    Attributes:\n        name (str): Unique name identifier for this control variable\n        _shape (tuple[int, ...]): Shape of the control vector (typically 1D like (3,) for 3D thrust)\n        _slice (slice | None): Internal slice information for variable indexing\n        _min (np.ndarray | None): Minimum bounds for each element of the control\n        _max (np.ndarray | None): Maximum bounds for each element of the control\n        _guess (np.ndarray | None): Initial guess for the control trajectory (n_points, n_controls)\n\n    Example:\n        Scalar throttle control bounded [0, 1]:\n\n            throttle = Control(\"throttle\", shape=(1,))\n            throttle.min = [0.0]\n            throttle.max = [1.0]\n            throttle.guess = np.full((50, 1), 0.5)  # Start at 50% throttle\n\n        3D thrust vector for spacecraft:\n\n            thrust = Control(\"thrust\", shape=(3,))\n            thrust.min = [-10, -10, 0]    # No downward thrust\n            thrust.max = [10, 10, 50]     # Limited thrust\n            thrust.guess = np.zeros((50, 3))  # Initialize with zero thrust\n\n        2D steering control (left/right, forward/backward):\n\n            steer = Control(\"steer\", shape=(2,))\n            steer.min = [-1, -1]\n            steer.max = [1, 1]\n            steer.guess = np.linspace([0, 0], [0, 1], 50)  # Gradual acceleration\n    \"\"\"\n\n    def __init__(self, name, shape):\n        \"\"\"Initialize a Control object.\n\n        Args:\n            name: Name identifier for the control variable\n            shape: Shape of the control vector (typically 1D tuple like (3,))\n        \"\"\"\n        super().__init__(name, shape)\n        self._scaling_min = None\n        self._scaling_max = None\n\n    @property\n    def scaling_min(self):\n        \"\"\"Get the scaling minimum bounds for the control variables.\n\n        Returns:\n            Array of scaling minimum values for each control variable element, or None if not set.\n        \"\"\"\n        return self._scaling_min\n\n    @scaling_min.setter\n    def scaling_min(self, val):\n        \"\"\"Set the scaling minimum bounds for the control variables.\n\n        Args:\n            val: Array of scaling minimum values, must match the control shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the control shape\n        \"\"\"\n        if val is None:\n            self._scaling_min = None\n            return\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(\n                f\"Scaling min shape {val.shape} does not match Control shape {self.shape}\"\n            )\n        self._scaling_min = val\n\n    @property\n    def scaling_max(self):\n        \"\"\"Get the scaling maximum bounds for the control variables.\n\n        Returns:\n            Array of scaling maximum values for each control variable element, or None if not set.\n        \"\"\"\n        return self._scaling_max\n\n    @scaling_max.setter\n    def scaling_max(self, val):\n        \"\"\"Set the scaling maximum bounds for the control variables.\n\n        Args:\n            val: Array of scaling maximum values, must match the control shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the control shape\n        \"\"\"\n        if val is None:\n            self._scaling_max = None\n            return\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(\n                f\"Scaling max shape {val.shape} does not match Control shape {self.shape}\"\n            )\n        self._scaling_max = val\n\n    def __repr__(self):\n        \"\"\"String representation of the Control object.\n\n        Returns:\n            Concise string showing the control name and shape.\n        \"\"\"\n        return f\"Control('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Control.scaling_max","title":"<code>scaling_max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling maximum bounds for the control variables.</p> <p>Returns:</p> Type Description <p>Array of scaling maximum values for each control variable element, or None if not set.</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Control.scaling_min","title":"<code>scaling_min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling minimum bounds for the control variables.</p> <p>Returns:</p> Type Description <p>Array of scaling minimum values for each control variable element, or None if not set.</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Control.__init__","title":"<code>__init__(name, shape)</code>","text":"<p>Initialize a Control object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name identifier for the control variable</p> required <code>shape</code> <p>Shape of the control vector (typically 1D tuple like (3,))</p> required Source code in <code>openscvx/symbolic/expr/control.py</code> <pre><code>def __init__(self, name, shape):\n    \"\"\"Initialize a Control object.\n\n    Args:\n        name: Name identifier for the control variable\n        shape: Shape of the control vector (typically 1D tuple like (3,))\n    \"\"\"\n    super().__init__(name, shape)\n    self._scaling_min = None\n    self._scaling_max = None\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Cos","title":"<code>Cos</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise cosine function for symbolic expressions.</p> <p>Computes the cosine of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply cosine function to</p> Example <p>Define a Cos expression:</p> <pre><code>theta = Variable(\"theta\", shape=(3,))\ncos_theta = Cos(theta)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Cos(Expr):\n    \"\"\"Element-wise cosine function for symbolic expressions.\n\n    Computes the cosine of each element in the operand. Preserves the shape\n    of the input expression.\n\n    Attributes:\n        operand: Expression to apply cosine function to\n\n    Example:\n        Define a Cos expression:\n\n            theta = Variable(\"theta\", shape=(3,))\n            cos_theta = Cos(theta)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a cosine operation.\n\n        Args:\n            operand: Expression to apply cosine function to\n        \"\"\"\n        self.operand = operand\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Cos(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Cos preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"(cos({self.operand!r}))\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Cos.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a cosine operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to apply cosine function to</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a cosine operation.\n\n    Args:\n        operand: Expression to apply cosine function to\n    \"\"\"\n    self.operand = operand\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Cos.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Cos preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Cos preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CrossNodeConstraint","title":"<code>CrossNodeConstraint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>A constraint that couples specific trajectory nodes via .at(k) references.</p> <p>Unlike NodalConstraint which applies a constraint pattern at multiple nodes (via vmapping), CrossNodeConstraint is a single constraint with fixed node indices embedded in the expression via NodeReference nodes.</p> <p>CrossNodeConstraint is created automatically when a bare Constraint contains NodeReference nodes (from .at(k) calls). Users should NOT manually wrap cross-node constraints - they are auto-detected during constraint separation.</p> <p>Key differences from NodalConstraint:</p> <ul> <li>NodalConstraint: Same constraint evaluated at multiple nodes via vmapping.   Signature: (x, u, node, params) \u2192 scalar, vmapped to (N, n_x) inputs.</li> <li>CrossNodeConstraint: Single constraint coupling specific fixed nodes.   Signature: (X, U, params) \u2192 scalar, operates on full trajectory arrays.</li> </ul> <p>Lowering:</p> <ul> <li>Non-convex: Lowered to JAX with automatic differentiation for SCP linearization</li> <li>Convex: Lowered to CVXPy and solved directly by the convex solver</li> </ul> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint containing NodeReference nodes</p> Example <p>Rate limit constraint (auto-detected as CrossNodeConstraint):</p> <pre><code>position = State(\"pos\", shape=(3,))\n\n# This creates a CrossNodeConstraint automatically:\nrate_limit = position.at(5) - position.at(4) &lt;= 0.1\n\n# Mark as convex if the constraint is convex:\nrate_limit_convex = (position.at(5) - position.at(4) &lt;= 0.1).convex()\n</code></pre> <p>Creating multiple cross-node constraints with a loop:</p> <pre><code>constraints = []\nfor k in range(1, N):\n    # Each iteration creates one CrossNodeConstraint\n    rate_limit = position.at(k) - position.at(k-1) &lt;= max_step\n    constraints.append(rate_limit)\n</code></pre> Note <p>Do NOT use .at([...]) on cross-node constraints. The nodes are already specified via .at(k) inside the expression. Using .at([...]) will raise an error during constraint separation.</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class CrossNodeConstraint(Expr):\n    \"\"\"A constraint that couples specific trajectory nodes via .at(k) references.\n\n    Unlike NodalConstraint which applies a constraint pattern at multiple nodes\n    (via vmapping), CrossNodeConstraint is a single constraint with fixed node\n    indices embedded in the expression via NodeReference nodes.\n\n    CrossNodeConstraint is created automatically when a bare Constraint contains\n    NodeReference nodes (from .at(k) calls). Users should NOT manually wrap\n    cross-node constraints - they are auto-detected during constraint separation.\n\n    **Key differences from NodalConstraint:**\n\n    - **NodalConstraint**: Same constraint evaluated at multiple nodes via vmapping.\n      Signature: (x, u, node, params) \u2192 scalar, vmapped to (N, n_x) inputs.\n    - **CrossNodeConstraint**: Single constraint coupling specific fixed nodes.\n      Signature: (X, U, params) \u2192 scalar, operates on full trajectory arrays.\n\n    **Lowering:**\n\n    - **Non-convex**: Lowered to JAX with automatic differentiation for SCP linearization\n    - **Convex**: Lowered to CVXPy and solved directly by the convex solver\n\n    Attributes:\n        constraint: The wrapped Constraint containing NodeReference nodes\n\n    Example:\n        Rate limit constraint (auto-detected as CrossNodeConstraint):\n\n            position = State(\"pos\", shape=(3,))\n\n            # This creates a CrossNodeConstraint automatically:\n            rate_limit = position.at(5) - position.at(4) &lt;= 0.1\n\n            # Mark as convex if the constraint is convex:\n            rate_limit_convex = (position.at(5) - position.at(4) &lt;= 0.1).convex()\n\n        Creating multiple cross-node constraints with a loop:\n\n            constraints = []\n            for k in range(1, N):\n                # Each iteration creates one CrossNodeConstraint\n                rate_limit = position.at(k) - position.at(k-1) &lt;= max_step\n                constraints.append(rate_limit)\n\n    Note:\n        Do NOT use .at([...]) on cross-node constraints. The nodes are already\n        specified via .at(k) inside the expression. Using .at([...]) will raise\n        an error during constraint separation.\n    \"\"\"\n\n    def __init__(self, constraint: Constraint):\n        \"\"\"Initialize a CrossNodeConstraint.\n\n        Args:\n            constraint: The Constraint containing NodeReference nodes.\n                Must contain at least one NodeReference (from .at(k) calls).\n\n        Raises:\n            TypeError: If constraint is not a Constraint instance\n        \"\"\"\n        if not isinstance(constraint, Constraint):\n            raise TypeError(\"CrossNodeConstraint must wrap a Constraint\")\n\n        self.constraint = constraint\n\n    @property\n    def is_convex(self) -&gt; bool:\n        \"\"\"Whether the underlying constraint is marked as convex.\n\n        Returns:\n            bool: True if the constraint is convex, False otherwise\n        \"\"\"\n        return self.constraint.is_convex\n\n    def children(self):\n        \"\"\"Return the wrapped constraint as the only child.\n\n        Returns:\n            list: Single-element list containing the wrapped constraint\n        \"\"\"\n        return [self.constraint]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the wrapped constraint.\n\n        Returns:\n            CrossNodeConstraint: A new CrossNodeConstraint with canonicalized inner constraint\n        \"\"\"\n        canon_constraint = self.constraint.canonicalize()\n        return CrossNodeConstraint(canon_constraint)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Validate the wrapped constraint's shape.\n\n        Returns:\n            tuple: Empty tuple () representing scalar shape\n        \"\"\"\n        self.constraint.check_shape()\n        return ()\n\n    def convex(self) -&gt; \"CrossNodeConstraint\":\n        \"\"\"Mark the underlying constraint as convex for CVXPy lowering.\n\n        Returns:\n            Self with underlying constraint's convex flag set to True\n        \"\"\"\n        self.constraint.convex()\n        return self\n\n    def __repr__(self):\n        \"\"\"String representation of the CrossNodeConstraint.\n\n        Returns:\n            str: String showing the wrapped constraint\n        \"\"\"\n        return f\"CrossNodeConstraint({self.constraint!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CrossNodeConstraint.is_convex","title":"<code>is_convex: bool</code>  <code>property</code>","text":"<p>Whether the underlying constraint is marked as convex.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the constraint is convex, False otherwise</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CrossNodeConstraint.__init__","title":"<code>__init__(constraint: Constraint)</code>","text":"<p>Initialize a CrossNodeConstraint.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>Constraint</code> <p>The Constraint containing NodeReference nodes. Must contain at least one NodeReference (from .at(k) calls).</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If constraint is not a Constraint instance</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def __init__(self, constraint: Constraint):\n    \"\"\"Initialize a CrossNodeConstraint.\n\n    Args:\n        constraint: The Constraint containing NodeReference nodes.\n            Must contain at least one NodeReference (from .at(k) calls).\n\n    Raises:\n        TypeError: If constraint is not a Constraint instance\n    \"\"\"\n    if not isinstance(constraint, Constraint):\n        raise TypeError(\"CrossNodeConstraint must wrap a Constraint\")\n\n    self.constraint = constraint\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CrossNodeConstraint.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the wrapped constraint.</p> <p>Returns:</p> Name Type Description <code>CrossNodeConstraint</code> <code>Expr</code> <p>A new CrossNodeConstraint with canonicalized inner constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the wrapped constraint.\n\n    Returns:\n        CrossNodeConstraint: A new CrossNodeConstraint with canonicalized inner constraint\n    \"\"\"\n    canon_constraint = self.constraint.canonicalize()\n    return CrossNodeConstraint(canon_constraint)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CrossNodeConstraint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the wrapped constraint's shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Validate the wrapped constraint's shape.\n\n    Returns:\n        tuple: Empty tuple () representing scalar shape\n    \"\"\"\n    self.constraint.check_shape()\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CrossNodeConstraint.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def children(self):\n    \"\"\"Return the wrapped constraint as the only child.\n\n    Returns:\n        list: Single-element list containing the wrapped constraint\n    \"\"\"\n    return [self.constraint]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.CrossNodeConstraint.convex","title":"<code>convex() -&gt; CrossNodeConstraint</code>","text":"<p>Mark the underlying constraint as convex for CVXPy lowering.</p> <p>Returns:</p> Type Description <code>CrossNodeConstraint</code> <p>Self with underlying constraint's convex flag set to True</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def convex(self) -&gt; \"CrossNodeConstraint\":\n    \"\"\"Mark the underlying constraint as convex for CVXPy lowering.\n\n    Returns:\n        Self with underlying constraint's convex flag set to True\n    \"\"\"\n    self.constraint.convex()\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Diag","title":"<code>Diag</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Diagonal matrix construction from a vector.</p> <p>Creates a square diagonal matrix from a 1D vector. The vector elements become the diagonal entries, with all off-diagonal entries set to zero. This is analogous to numpy.diag() or jax.numpy.diag().</p> Note <p>Currently only supports creating diagonal matrices from vectors. Extracting diagonals from matrices is not yet implemented.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>1D vector expression to place on the diagonal</p> Example <p>Define a Diag:</p> <pre><code>v = Variable(\"v\", shape=(3,))\nD = Diag(v)  # Creates a (3, 3) diagonal matrix\n</code></pre> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>class Diag(Expr):\n    \"\"\"Diagonal matrix construction from a vector.\n\n    Creates a square diagonal matrix from a 1D vector. The vector elements become\n    the diagonal entries, with all off-diagonal entries set to zero. This is\n    analogous to numpy.diag() or jax.numpy.diag().\n\n    Note:\n        Currently only supports creating diagonal matrices from vectors.\n        Extracting diagonals from matrices is not yet implemented.\n\n    Attributes:\n        operand: 1D vector expression to place on the diagonal\n\n    Example:\n        Define a Diag:\n\n            v = Variable(\"v\", shape=(3,))\n            D = Diag(v)  # Creates a (3, 3) diagonal matrix\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a diagonal matrix operation.\n\n        Args:\n            operand: 1D vector expression to place on the diagonal\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Diag(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Diag converts a vector (n,) to a diagonal matrix (n,n).\"\"\"\n        operand_shape = self.operand.check_shape()\n        if len(operand_shape) != 1:\n            raise ValueError(f\"Diag expects a 1D vector, got shape {operand_shape}\")\n        n = operand_shape[0]\n        return (n, n)\n\n    def __repr__(self):\n        return f\"diag({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Diag.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a diagonal matrix operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>1D vector expression to place on the diagonal</p> required Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a diagonal matrix operation.\n\n    Args:\n        operand: 1D vector expression to place on the diagonal\n    \"\"\"\n    self.operand = to_expr(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Diag.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Diag converts a vector (n,) to a diagonal matrix (n,n).</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Diag converts a vector (n,) to a diagonal matrix (n,n).\"\"\"\n    operand_shape = self.operand.check_shape()\n    if len(operand_shape) != 1:\n        raise ValueError(f\"Diag expects a 1D vector, got shape {operand_shape}\")\n    n = operand_shape[0]\n    return (n, n)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Div","title":"<code>Div</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise division operation for symbolic expressions.</p> <p>Represents element-wise division (left / right). Supports broadcasting following NumPy rules. Can be created using the / operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>left</code> <p>Numerator expression</p> <code>right</code> <p>Denominator expression</p> Example <p>Define a Div expression</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(3,))\nz = x / y  # Creates Div(x, y)\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Div(Expr):\n    \"\"\"Element-wise division operation for symbolic expressions.\n\n    Represents element-wise division (left / right). Supports broadcasting\n    following NumPy rules. Can be created using the / operator on Expr objects.\n\n    Attributes:\n        left: Numerator expression\n        right: Denominator expression\n\n    Example:\n        Define a Div expression\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(3,))\n            z = x / y  # Creates Div(x, y)\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\"Initialize a division operation.\n\n        Args:\n            left: Expression for the numerator\n            right: Expression for the denominator\n        \"\"\"\n        self.left = left\n        self.right = right\n\n    def children(self):\n        return [self.left, self.right]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize division: fold constants if both sides are constants.\n\n        Returns:\n            Expr: Canonical form of the division expression\n        \"\"\"\n        lhs = self.left.canonicalize()\n        rhs = self.right.canonicalize()\n        if isinstance(lhs, Constant) and isinstance(rhs, Constant):\n            return Constant(lhs.value / rhs.value)\n        return Div(lhs, rhs)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n        Returns:\n            tuple: The broadcasted shape of both operands\n\n        Raises:\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Div shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        return f\"({self.left!r} / {self.right!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Div.__init__","title":"<code>__init__(left, right)</code>","text":"<p>Initialize a division operation.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <p>Expression for the numerator</p> required <code>right</code> <p>Expression for the denominator</p> required Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def __init__(self, left, right):\n    \"\"\"Initialize a division operation.\n\n    Args:\n        left: Expression for the numerator\n        right: Expression for the denominator\n    \"\"\"\n    self.left = left\n    self.right = right\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Div.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize division: fold constants if both sides are constants.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the division expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize division: fold constants if both sides are constants.\n\n    Returns:\n        Expr: Canonical form of the division expression\n    \"\"\"\n    lhs = self.left.canonicalize()\n    rhs = self.right.canonicalize()\n    if isinstance(lhs, Constant) and isinstance(rhs, Constant):\n        return Constant(lhs.value / rhs.value)\n    return Div(lhs, rhs)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Div.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check shape compatibility and compute broadcasted result shape like NumPy.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The broadcasted shape of both operands</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n    Returns:\n        tuple: The broadcasted shape of both operands\n\n    Raises:\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Div shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Equality","title":"<code>Equality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Equality constraint for optimization problems.</p> <p>Represents an equality constraint: lhs == rhs. Can be created using the == operator on Expr objects.</p> Example <p>Define an Equality constraint:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = x == 0  # Creates Equality(x, Constant(0))\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class Equality(Constraint):\n    \"\"\"Equality constraint for optimization problems.\n\n    Represents an equality constraint: lhs == rhs. Can be created using the ==\n    operator on Expr objects.\n\n    Example:\n        Define an Equality constraint:\n\n            x = ox.State(\"x\", shape=(3,))\n            constraint = x == 0  # Creates Equality(x, Constant(0))\n    \"\"\"\n\n    def __repr__(self):\n        return f\"{self.lhs!r} == {self.rhs!r}\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Exp","title":"<code>Exp</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise exponential function for symbolic expressions.</p> <p>Computes e^x for each element in the operand, where e is Euler's number. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply exponential function to</p> Example <p>Define an Exp expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\nexp_x = Exp(x)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Exp(Expr):\n    \"\"\"Element-wise exponential function for symbolic expressions.\n\n    Computes e^x for each element in the operand, where e is Euler's number.\n    Preserves the shape of the input expression.\n\n    Attributes:\n        operand: Expression to apply exponential function to\n\n    Example:\n        Define an Exp expression:\n\n            x = Variable(\"x\", shape=(3,))\n            exp_x = Exp(x)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize an exponential operation.\n\n        Args:\n            operand: Expression to apply exponential function to\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Exp(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Exp preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"exp({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Exp.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize an exponential operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to apply exponential function to</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize an exponential operation.\n\n    Args:\n        operand: Expression to apply exponential function to\n    \"\"\"\n    self.operand = to_expr(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Exp.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Exp preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Exp preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Expr","title":"<code>Expr</code>","text":"<p>Base class for symbolic expressions in optimization problems.</p> <p>Expr is the foundation of the symbolic expression system in openscvx. It represents nodes in an abstract syntax tree (AST) for mathematical expressions. Expressions support:</p> <ul> <li>Arithmetic operations: +, -, *, /, @, **</li> <li>Comparison operations: ==, &lt;=, &gt;=</li> <li>Indexing and slicing: []</li> <li>Transposition: .T property</li> <li>Shape checking and validation</li> <li>Canonicalization (algebraic simplification)</li> </ul> <p>All Expr subclasses implement a tree structure where each node can have child expressions accessed via the children() method.</p> <p>Attributes:</p> Name Type Description <code>__array_priority__</code> <p>Priority for operations with numpy arrays (set to 1000)</p> Note <p>When used in operations with numpy arrays, Expr objects take precedence, allowing symbolic expressions to wrap numeric values automatically.</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class Expr:\n    \"\"\"Base class for symbolic expressions in optimization problems.\n\n    Expr is the foundation of the symbolic expression system in openscvx. It represents\n    nodes in an abstract syntax tree (AST) for mathematical expressions. Expressions\n    support:\n\n    - Arithmetic operations: +, -, *, /, @, **\n    - Comparison operations: ==, &lt;=, &gt;=\n    - Indexing and slicing: []\n    - Transposition: .T property\n    - Shape checking and validation\n    - Canonicalization (algebraic simplification)\n\n    All Expr subclasses implement a tree structure where each node can have child\n    expressions accessed via the children() method.\n\n    Attributes:\n        __array_priority__: Priority for operations with numpy arrays (set to 1000)\n\n    Note:\n        When used in operations with numpy arrays, Expr objects take precedence,\n        allowing symbolic expressions to wrap numeric values automatically.\n    \"\"\"\n\n    # Give Expr objects higher priority than numpy arrays in operations\n    __array_priority__ = 1000\n\n    def __le__(self, other):\n        from .constraint import Inequality\n\n        return Inequality(self, to_expr(other))\n\n    def __ge__(self, other):\n        from .constraint import Inequality\n\n        return Inequality(to_expr(other), self)\n\n    def __eq__(self, other):\n        from .constraint import Equality\n\n        return Equality(self, to_expr(other))\n\n    def __add__(self, other):\n        from .arithmetic import Add\n\n        return Add(self, to_expr(other))\n\n    def __radd__(self, other):\n        from .arithmetic import Add\n\n        return Add(to_expr(other), self)\n\n    def __sub__(self, other):\n        from .arithmetic import Sub\n\n        return Sub(self, to_expr(other))\n\n    def __rsub__(self, other):\n        # e.g. 5 - a  \u21d2 Sub(Constant(5), a)\n        from .arithmetic import Sub\n\n        return Sub(to_expr(other), self)\n\n    def __truediv__(self, other):\n        from .arithmetic import Div\n\n        return Div(self, to_expr(other))\n\n    def __rtruediv__(self, other):\n        # e.g. 10 / a\n        from .arithmetic import Div\n\n        return Div(to_expr(other), self)\n\n    def __mul__(self, other):\n        from .arithmetic import Mul\n\n        return Mul(self, to_expr(other))\n\n    def __rmul__(self, other):\n        from .arithmetic import Mul\n\n        return Mul(to_expr(other), self)\n\n    def __matmul__(self, other):\n        from .arithmetic import MatMul\n\n        return MatMul(self, to_expr(other))\n\n    def __rmatmul__(self, other):\n        from .arithmetic import MatMul\n\n        return MatMul(to_expr(other), self)\n\n    def __rle__(self, other):\n        # other &lt;= self  =&gt;  Inequality(other, self)\n        from .constraint import Inequality\n\n        return Inequality(to_expr(other), self)\n\n    def __rge__(self, other):\n        # other &gt;= self  =&gt;  Inequality(self, other)\n        from .constraint import Inequality\n\n        return Inequality(self, to_expr(other))\n\n    def __req__(self, other):\n        # other == self  =&gt;  Equality(other, self)\n        from .constraint import Equality\n\n        return Equality(to_expr(other), self)\n\n    def __neg__(self):\n        from .arithmetic import Neg\n\n        return Neg(self)\n\n    def __pow__(self, other):\n        from .arithmetic import Power\n\n        return Power(self, to_expr(other))\n\n    def __rpow__(self, other):\n        from .arithmetic import Power\n\n        return Power(to_expr(other), self)\n\n    def __getitem__(self, idx):\n        from .array import Index\n\n        return Index(self, idx)\n\n    @property\n    def T(self):\n        \"\"\"Transpose property for matrix expressions.\n\n        Returns:\n            Transpose: A Transpose expression wrapping this expression\n\n        Example:\n            Create a transpose:\n\n                A = ox.State(\"A\", shape=(3, 4))\n                A_T = A.T  # Creates Transpose(A), result shape (4, 3)\n        \"\"\"\n        from .linalg import Transpose\n\n        return Transpose(self)\n\n    def at(self, k: int) -&gt; \"NodeReference\":\n        \"\"\"Reference this expression at a specific trajectory node.\n\n        This method enables inter-node constraints where you can reference\n        the value of an expression at different time steps. Common patterns\n        include rate limits and multi-step dependencies.\n\n        Args:\n            k: Absolute node index (integer) in the trajectory.\n               Can be positive (0, 1, 2, ...) or negative (-1 for last node).\n\n        Returns:\n            NodeReference: An expression representing this expression at node k\n\n        Example:\n            Rate limit constraint (applied across trajectory using a loop):\n\n                position = State(\"pos\", shape=(3,))\n\n                # Create rate limit for each node\n                constraints = [\n                    (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n                    for k in range(1, N)\n                ]\n\n            Multi-step dependency:\n\n                state = State(\"x\", shape=(1,))\n\n                # Fibonacci-like recurrence\n                constraints = [\n                    (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n                    for k in range(2, N)\n                ]\n\n        Performance Note:\n            Cross-node constraints use dense Jacobian storage which can be memory-intensive\n            for large N (&gt;100 nodes). See LoweredCrossNodeConstraint documentation for\n            details on memory usage and future sparse Jacobian support.\n        \"\"\"\n        return NodeReference(self, k)\n\n    def children(self):\n        \"\"\"Return the child expressions of this node.\n\n        Returns:\n            list: List of child Expr objects. Empty list for leaf nodes.\n        \"\"\"\n        return []\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"\n        Return a canonical (simplified) form of this expression.\n\n        Canonicalization performs algebraic simplifications such as:\n        - Constant folding (e.g., 2 + 3 \u2192 5)\n        - Identity elimination (e.g., x + 0 \u2192 x, x * 1 \u2192 x)\n        - Flattening nested operations (e.g., Add(Add(a, b), c) \u2192 Add(a, b, c))\n        - Algebraic rewrites (e.g., constraints to standard form)\n\n        Returns:\n            Expr: A canonical version of this expression\n\n        Raises:\n            NotImplementedError: If canonicalization is not implemented for this node type\n        \"\"\"\n        raise NotImplementedError(f\"canonicalize() not implemented for {self.__class__.__name__}\")\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"\n        Compute and validate the shape of this expression.\n\n        This method:\n        1. Recursively checks shapes of all child expressions\n        2. Validates that operations are shape-compatible (e.g., broadcasting rules)\n        3. Returns the output shape of this expression\n\n        For example:\n        - A Parameter with shape (3, 4) returns (3, 4)\n        - MatMul of (3, 4) @ (4, 5) returns (3, 5)\n        - Sum of any shape returns () (scalar)\n        - Add broadcasts shapes like NumPy\n\n        Returns:\n            tuple: The shape of this expression as a tuple of integers.\n                   Empty tuple () represents a scalar.\n\n        Raises:\n            NotImplementedError: If shape checking is not implemented for this node type\n            ValueError: If the expression has invalid shapes (e.g., incompatible dimensions)\n        \"\"\"\n        raise NotImplementedError(f\"check_shape() not implemented for {self.__class__.__name__}\")\n\n    def pretty(self, indent=0):\n        \"\"\"Generate a pretty-printed string representation of the expression tree.\n\n        Creates an indented, hierarchical view of the expression tree structure,\n        useful for debugging and visualization.\n\n        Args:\n            indent: Current indentation level (default: 0)\n\n        Returns:\n            str: Multi-line string representation of the expression tree\n\n        Example:\n            Pretty print an expression:\n\n                expr = (x + y) * z\n                print(expr.pretty())\n                # Mul\n                #   Add\n                #     State\n                #     State\n                #   State\n        \"\"\"\n        pad = \"  \" * indent\n        pad = \"  \" * indent\n        lines = [f\"{pad}{self.__class__.__name__}\"]\n        for child in self.children():\n            lines.append(child.pretty(indent + 1))\n        return \"\\n\".join(lines)\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Contribute this expression's structural identity to a hash.\n\n        This method is used to compute a structural hash of the expression tree\n        that is name-invariant (same structure = same hash regardless of variable names).\n\n        The default implementation hashes the class name and recursively hashes all\n        children. Subclasses with additional attributes (like Norm.ord, Index.index)\n        should override this to include those attributes.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        # Hash the class name to distinguish different node types\n        hasher.update(self.__class__.__name__.encode())\n        # Recursively hash all children\n        for child in self.children():\n            child._hash_into(hasher)\n\n    def structural_hash(self) -&gt; bytes:\n        \"\"\"Compute a structural hash of this expression.\n\n        Returns a hash that depends only on the mathematical structure of the\n        expression, not on variable names. Two expressions that are structurally\n        equivalent (same operations, same variable positions) will have the same hash.\n\n        Returns:\n            bytes: SHA-256 digest of the expression structure\n        \"\"\"\n        hasher = hashlib.sha256()\n        self._hash_into(hasher)\n        return hasher.digest()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Expr.T","title":"<code>T</code>  <code>property</code>","text":"<p>Transpose property for matrix expressions.</p> <p>Returns:</p> Name Type Description <code>Transpose</code> <p>A Transpose expression wrapping this expression</p> Example <p>Create a transpose:</p> <pre><code>A = ox.State(\"A\", shape=(3, 4))\nA_T = A.T  # Creates Transpose(A), result shape (4, 3)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Expr.at","title":"<code>at(k: int) -&gt; NodeReference</code>","text":"<p>Reference this expression at a specific trajectory node.</p> <p>This method enables inter-node constraints where you can reference the value of an expression at different time steps. Common patterns include rate limits and multi-step dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>Absolute node index (integer) in the trajectory. Can be positive (0, 1, 2, ...) or negative (-1 for last node).</p> required <p>Returns:</p> Name Type Description <code>NodeReference</code> <code>NodeReference</code> <p>An expression representing this expression at node k</p> Example <p>Rate limit constraint (applied across trajectory using a loop):</p> <pre><code>position = State(\"pos\", shape=(3,))\n\n# Create rate limit for each node\nconstraints = [\n    (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n    for k in range(1, N)\n]\n</code></pre> <p>Multi-step dependency:</p> <pre><code>state = State(\"x\", shape=(1,))\n\n# Fibonacci-like recurrence\nconstraints = [\n    (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n    for k in range(2, N)\n]\n</code></pre> Performance Note <p>Cross-node constraints use dense Jacobian storage which can be memory-intensive for large N (&gt;100 nodes). See LoweredCrossNodeConstraint documentation for details on memory usage and future sparse Jacobian support.</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def at(self, k: int) -&gt; \"NodeReference\":\n    \"\"\"Reference this expression at a specific trajectory node.\n\n    This method enables inter-node constraints where you can reference\n    the value of an expression at different time steps. Common patterns\n    include rate limits and multi-step dependencies.\n\n    Args:\n        k: Absolute node index (integer) in the trajectory.\n           Can be positive (0, 1, 2, ...) or negative (-1 for last node).\n\n    Returns:\n        NodeReference: An expression representing this expression at node k\n\n    Example:\n        Rate limit constraint (applied across trajectory using a loop):\n\n            position = State(\"pos\", shape=(3,))\n\n            # Create rate limit for each node\n            constraints = [\n                (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n                for k in range(1, N)\n            ]\n\n        Multi-step dependency:\n\n            state = State(\"x\", shape=(1,))\n\n            # Fibonacci-like recurrence\n            constraints = [\n                (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n                for k in range(2, N)\n            ]\n\n    Performance Note:\n        Cross-node constraints use dense Jacobian storage which can be memory-intensive\n        for large N (&gt;100 nodes). See LoweredCrossNodeConstraint documentation for\n        details on memory usage and future sparse Jacobian support.\n    \"\"\"\n    return NodeReference(self, k)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Expr.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Return a canonical (simplified) form of this expression.</p> <p>Canonicalization performs algebraic simplifications such as: - Constant folding (e.g., 2 + 3 \u2192 5) - Identity elimination (e.g., x + 0 \u2192 x, x * 1 \u2192 x) - Flattening nested operations (e.g., Add(Add(a, b), c) \u2192 Add(a, b, c)) - Algebraic rewrites (e.g., constraints to standard form)</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>A canonical version of this expression</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If canonicalization is not implemented for this node type</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"\n    Return a canonical (simplified) form of this expression.\n\n    Canonicalization performs algebraic simplifications such as:\n    - Constant folding (e.g., 2 + 3 \u2192 5)\n    - Identity elimination (e.g., x + 0 \u2192 x, x * 1 \u2192 x)\n    - Flattening nested operations (e.g., Add(Add(a, b), c) \u2192 Add(a, b, c))\n    - Algebraic rewrites (e.g., constraints to standard form)\n\n    Returns:\n        Expr: A canonical version of this expression\n\n    Raises:\n        NotImplementedError: If canonicalization is not implemented for this node type\n    \"\"\"\n    raise NotImplementedError(f\"canonicalize() not implemented for {self.__class__.__name__}\")\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Expr.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Compute and validate the shape of this expression.</p> <p>This method: 1. Recursively checks shapes of all child expressions 2. Validates that operations are shape-compatible (e.g., broadcasting rules) 3. Returns the output shape of this expression</p> <p>For example: - A Parameter with shape (3, 4) returns (3, 4) - MatMul of (3, 4) @ (4, 5) returns (3, 5) - Sum of any shape returns () (scalar) - Add broadcasts shapes like NumPy</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The shape of this expression as a tuple of integers.    Empty tuple () represents a scalar.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If shape checking is not implemented for this node type</p> <code>ValueError</code> <p>If the expression has invalid shapes (e.g., incompatible dimensions)</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"\n    Compute and validate the shape of this expression.\n\n    This method:\n    1. Recursively checks shapes of all child expressions\n    2. Validates that operations are shape-compatible (e.g., broadcasting rules)\n    3. Returns the output shape of this expression\n\n    For example:\n    - A Parameter with shape (3, 4) returns (3, 4)\n    - MatMul of (3, 4) @ (4, 5) returns (3, 5)\n    - Sum of any shape returns () (scalar)\n    - Add broadcasts shapes like NumPy\n\n    Returns:\n        tuple: The shape of this expression as a tuple of integers.\n               Empty tuple () represents a scalar.\n\n    Raises:\n        NotImplementedError: If shape checking is not implemented for this node type\n        ValueError: If the expression has invalid shapes (e.g., incompatible dimensions)\n    \"\"\"\n    raise NotImplementedError(f\"check_shape() not implemented for {self.__class__.__name__}\")\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Expr.children","title":"<code>children()</code>","text":"<p>Return the child expressions of this node.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of child Expr objects. Empty list for leaf nodes.</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def children(self):\n    \"\"\"Return the child expressions of this node.\n\n    Returns:\n        list: List of child Expr objects. Empty list for leaf nodes.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Expr.pretty","title":"<code>pretty(indent=0)</code>","text":"<p>Generate a pretty-printed string representation of the expression tree.</p> <p>Creates an indented, hierarchical view of the expression tree structure, useful for debugging and visualization.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <p>Current indentation level (default: 0)</p> <code>0</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Multi-line string representation of the expression tree</p> Example <p>Pretty print an expression:</p> <pre><code>expr = (x + y) * z\nprint(expr.pretty())\n# Mul\n#   Add\n#     State\n#     State\n#   State\n</code></pre> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def pretty(self, indent=0):\n    \"\"\"Generate a pretty-printed string representation of the expression tree.\n\n    Creates an indented, hierarchical view of the expression tree structure,\n    useful for debugging and visualization.\n\n    Args:\n        indent: Current indentation level (default: 0)\n\n    Returns:\n        str: Multi-line string representation of the expression tree\n\n    Example:\n        Pretty print an expression:\n\n            expr = (x + y) * z\n            print(expr.pretty())\n            # Mul\n            #   Add\n            #     State\n            #     State\n            #   State\n    \"\"\"\n    pad = \"  \" * indent\n    pad = \"  \" * indent\n    lines = [f\"{pad}{self.__class__.__name__}\"]\n    for child in self.children():\n        lines.append(child.pretty(indent + 1))\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Expr.structural_hash","title":"<code>structural_hash() -&gt; bytes</code>","text":"<p>Compute a structural hash of this expression.</p> <p>Returns a hash that depends only on the mathematical structure of the expression, not on variable names. Two expressions that are structurally equivalent (same operations, same variable positions) will have the same hash.</p> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>SHA-256 digest of the expression structure</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def structural_hash(self) -&gt; bytes:\n    \"\"\"Compute a structural hash of this expression.\n\n    Returns a hash that depends only on the mathematical structure of the\n    expression, not on variable names. Two expressions that are structurally\n    equivalent (same operations, same variable positions) will have the same hash.\n\n    Returns:\n        bytes: SHA-256 digest of the expression structure\n    \"\"\"\n    hasher = hashlib.sha256()\n    self._hash_into(hasher)\n    return hasher.digest()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Hstack","title":"<code>Hstack</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Horizontal stacking operation for symbolic expressions.</p> <p>Concatenates expressions horizontally (along columns for 2D arrays). This is analogous to numpy.hstack() or jax.numpy.hstack().</p> <p>Behavior depends on input dimensionality: - 1D arrays: Concatenates along axis 0 (making a longer vector) - 2D arrays: Concatenates along axis 1 (columns), rows must match - Higher-D: Concatenates along axis 1, all other dimensions must match</p> <p>Attributes:</p> Name Type Description <code>arrays</code> <p>List of expressions to stack horizontally</p> Example <p>1D case: concatenate vectors:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(2,))\nh = Hstack([x, y])  # Result shape (5,)\n</code></pre> <p>2D case: concatenate matrices horizontally:</p> <pre><code>A = Variable(\"A\", shape=(3, 4))\nB = Variable(\"B\", shape=(3, 2))\nC = Hstack([A, B])  # Result shape (3, 6)\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Hstack(Expr):\n    \"\"\"Horizontal stacking operation for symbolic expressions.\n\n    Concatenates expressions horizontally (along columns for 2D arrays).\n    This is analogous to numpy.hstack() or jax.numpy.hstack().\n\n    Behavior depends on input dimensionality:\n    - 1D arrays: Concatenates along axis 0 (making a longer vector)\n    - 2D arrays: Concatenates along axis 1 (columns), rows must match\n    - Higher-D: Concatenates along axis 1, all other dimensions must match\n\n    Attributes:\n        arrays: List of expressions to stack horizontally\n\n    Example:\n        1D case: concatenate vectors:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(2,))\n            h = Hstack([x, y])  # Result shape (5,)\n\n        2D case: concatenate matrices horizontally:\n\n            A = Variable(\"A\", shape=(3, 4))\n            B = Variable(\"B\", shape=(3, 2))\n            C = Hstack([A, B])  # Result shape (3, 6)\n    \"\"\"\n\n    def __init__(self, arrays):\n        \"\"\"Initialize a horizontal stack operation.\n\n        Args:\n            arrays: List of expressions to concatenate horizontally\n        \"\"\"\n        self.arrays = [to_expr(arr) for arr in arrays]\n\n    def children(self):\n        return self.arrays\n\n    def canonicalize(self) -&gt; \"Expr\":\n        arrays = [arr.canonicalize() for arr in self.arrays]\n        return Hstack(arrays)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Horizontal stack concatenates arrays along the second axis (columns).\"\"\"\n        if not self.arrays:\n            raise ValueError(\"Hstack requires at least one array\")\n\n        array_shapes = [arr.check_shape() for arr in self.arrays]\n\n        # All arrays must have the same number of dimensions\n        first_ndim = len(array_shapes[0])\n        for i, shape in enumerate(array_shapes[1:], 1):\n            if len(shape) != first_ndim:\n                raise ValueError(\n                    f\"Hstack array {i} has {len(shape)} dimensions, but array 0 has {first_ndim}\"\n                )\n\n        # For 1D arrays, hstack concatenates along axis 0\n        if first_ndim == 1:\n            total_length = sum(shape[0] for shape in array_shapes)\n            return (total_length,)\n\n        # For 2D+ arrays, all dimensions except the second must match\n        first_shape = array_shapes[0]\n        for i, shape in enumerate(array_shapes[1:], 1):\n            if shape[0] != first_shape[0]:\n                raise ValueError(\n                    f\"Hstack array {i} has {shape[0]} rows, but array 0 has {first_shape[0]} rows\"\n                )\n            if shape[2:] != first_shape[2:]:\n                raise ValueError(\n                    f\"Hstack array {i} has trailing dimensions {shape[2:]}, \"\n                    f\"but array 0 has {first_shape[2:]}\"\n                )\n\n        # Result shape: concatenate along axis 1 (columns)\n        total_cols = sum(shape[1] for shape in array_shapes)\n        return (first_shape[0], total_cols) + first_shape[2:]\n\n    def __repr__(self):\n        arrays_repr = \", \".join(repr(arr) for arr in self.arrays)\n        return f\"Hstack([{arrays_repr}])\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Hstack.__init__","title":"<code>__init__(arrays)</code>","text":"<p>Initialize a horizontal stack operation.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <p>List of expressions to concatenate horizontally</p> required Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def __init__(self, arrays):\n    \"\"\"Initialize a horizontal stack operation.\n\n    Args:\n        arrays: List of expressions to concatenate horizontally\n    \"\"\"\n    self.arrays = [to_expr(arr) for arr in arrays]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Hstack.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Horizontal stack concatenates arrays along the second axis (columns).</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Horizontal stack concatenates arrays along the second axis (columns).\"\"\"\n    if not self.arrays:\n        raise ValueError(\"Hstack requires at least one array\")\n\n    array_shapes = [arr.check_shape() for arr in self.arrays]\n\n    # All arrays must have the same number of dimensions\n    first_ndim = len(array_shapes[0])\n    for i, shape in enumerate(array_shapes[1:], 1):\n        if len(shape) != first_ndim:\n            raise ValueError(\n                f\"Hstack array {i} has {len(shape)} dimensions, but array 0 has {first_ndim}\"\n            )\n\n    # For 1D arrays, hstack concatenates along axis 0\n    if first_ndim == 1:\n        total_length = sum(shape[0] for shape in array_shapes)\n        return (total_length,)\n\n    # For 2D+ arrays, all dimensions except the second must match\n    first_shape = array_shapes[0]\n    for i, shape in enumerate(array_shapes[1:], 1):\n        if shape[0] != first_shape[0]:\n            raise ValueError(\n                f\"Hstack array {i} has {shape[0]} rows, but array 0 has {first_shape[0]} rows\"\n            )\n        if shape[2:] != first_shape[2:]:\n            raise ValueError(\n                f\"Hstack array {i} has trailing dimensions {shape[2:]}, \"\n                f\"but array 0 has {first_shape[2:]}\"\n            )\n\n    # Result shape: concatenate along axis 1 (columns)\n    total_cols = sum(shape[1] for shape in array_shapes)\n    return (first_shape[0], total_cols) + first_shape[2:]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Huber","title":"<code>Huber</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Huber penalty function for symbolic expressions.</p> <p>The Huber penalty is a smooth approximation to the absolute value function that is quadratic for small values (|x| &lt; delta) and linear for large values (|x| &gt;= delta). This makes it more robust to outliers than squared penalties while maintaining smoothness.</p> <p>The Huber function is defined as: - (x^2) / (2*delta)           for |x| &lt;= delta - |x| - delta/2               for |x| &gt; delta</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Expression to apply Huber penalty to</p> <code>delta</code> <p>Threshold parameter controlling the transition point (default: 0.25)</p> Example <p>Define a Huber penalty expression:</p> <pre><code>residual = y_measured - y_predicted\npenalty = Huber(residual, delta=0.5)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Huber(Expr):\n    \"\"\"Huber penalty function for symbolic expressions.\n\n    The Huber penalty is a smooth approximation to the absolute value function\n    that is quadratic for small values (|x| &lt; delta) and linear for large values\n    (|x| &gt;= delta). This makes it more robust to outliers than squared penalties\n    while maintaining smoothness.\n\n    The Huber function is defined as:\n    - (x^2) / (2*delta)           for |x| &lt;= delta\n    - |x| - delta/2               for |x| &gt; delta\n\n    Attributes:\n        x: Expression to apply Huber penalty to\n        delta: Threshold parameter controlling the transition point (default: 0.25)\n\n    Example:\n        Define a Huber penalty expression:\n\n            residual = y_measured - y_predicted\n            penalty = Huber(residual, delta=0.5)\n    \"\"\"\n\n    def __init__(self, x, delta: float = 0.25):\n        \"\"\"Initialize a Huber penalty operation.\n\n        Args:\n            x: Expression to apply Huber penalty to\n            delta: Threshold parameter for quadratic-to-linear transition (default: 0.25)\n        \"\"\"\n        self.x = to_expr(x)\n        self.delta = float(delta)\n\n    def children(self):\n        return [self.x]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the operand but preserve delta parameter.\"\"\"\n        x = self.x.canonicalize()\n        return Huber(x, delta=self.delta)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Huber penalty preserves the shape of x.\"\"\"\n        return self.x.check_shape()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Huber including its delta parameter.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Huber\")\n        # Hash delta as bytes\n        hasher.update(struct.pack(\"&gt;d\", self.delta))\n        # Hash the operand\n        self.x._hash_into(hasher)\n\n    def __repr__(self):\n        return f\"huber({self.x!r}, delta={self.delta})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Huber.__init__","title":"<code>__init__(x, delta: float = 0.25)</code>","text":"<p>Initialize a Huber penalty operation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>Expression to apply Huber penalty to</p> required <code>delta</code> <code>float</code> <p>Threshold parameter for quadratic-to-linear transition (default: 0.25)</p> <code>0.25</code> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, x, delta: float = 0.25):\n    \"\"\"Initialize a Huber penalty operation.\n\n    Args:\n        x: Expression to apply Huber penalty to\n        delta: Threshold parameter for quadratic-to-linear transition (default: 0.25)\n    \"\"\"\n    self.x = to_expr(x)\n    self.delta = float(delta)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Huber.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the operand but preserve delta parameter.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the operand but preserve delta parameter.\"\"\"\n    x = self.x.canonicalize()\n    return Huber(x, delta=self.delta)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Huber.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Huber penalty preserves the shape of x.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Huber penalty preserves the shape of x.\"\"\"\n    return self.x.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Index","title":"<code>Index</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Indexing and slicing operation for symbolic expressions.</p> <p>Represents indexing or slicing of an expression using NumPy-style indexing. Can be created using square bracket notation on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>base</code> <p>Expression to index into</p> <code>index</code> <p>Index specification (int, slice, or tuple of indices/slices)</p> Example <p>Define an Index expression:</p> <pre><code>x = ox.State(\"x\", shape=(10,))\ny = x[0:5]  # Creates Index(x, slice(0, 5))\nz = x[3]    # Creates Index(x, 3)\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Index(Expr):\n    \"\"\"Indexing and slicing operation for symbolic expressions.\n\n    Represents indexing or slicing of an expression using NumPy-style indexing.\n    Can be created using square bracket notation on Expr objects.\n\n    Attributes:\n        base: Expression to index into\n        index: Index specification (int, slice, or tuple of indices/slices)\n\n    Example:\n        Define an Index expression:\n\n            x = ox.State(\"x\", shape=(10,))\n            y = x[0:5]  # Creates Index(x, slice(0, 5))\n            z = x[3]    # Creates Index(x, 3)\n    \"\"\"\n\n    def __init__(self, base: Expr, index: Union[int, slice, tuple]):\n        \"\"\"Initialize an indexing operation.\n\n        Args:\n            base: Expression to index into\n            index: NumPy-style index (int, slice, or tuple of indices/slices)\n        \"\"\"\n        self.base = base\n        self.index = index\n\n    def children(self):\n        return [self.base]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize index by canonicalizing the base expression.\n\n        Returns:\n            Expr: Canonical form of the indexing expression\n        \"\"\"\n        base = self.base.canonicalize()\n        return Index(base, self.index)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Compute the shape after indexing.\"\"\"\n        base_shape = self.base.check_shape()\n        dummy = np.zeros(base_shape)\n        try:\n            result = dummy[self.index]\n        except Exception as e:\n            raise ValueError(f\"Bad index {self.index} for shape {base_shape}\") from e\n        return result.shape\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Index including its index specification.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Index\")\n        # Hash the index specification (convert to string for generality)\n        hasher.update(repr(self.index).encode())\n        # Hash the base expression\n        self.base._hash_into(hasher)\n\n    def __repr__(self):\n        return f\"{self.base!r}[{self.index!r}]\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Index.__init__","title":"<code>__init__(base: Expr, index: Union[int, slice, tuple])</code>","text":"<p>Initialize an indexing operation.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>Expr</code> <p>Expression to index into</p> required <code>index</code> <code>Union[int, slice, tuple]</code> <p>NumPy-style index (int, slice, or tuple of indices/slices)</p> required Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def __init__(self, base: Expr, index: Union[int, slice, tuple]):\n    \"\"\"Initialize an indexing operation.\n\n    Args:\n        base: Expression to index into\n        index: NumPy-style index (int, slice, or tuple of indices/slices)\n    \"\"\"\n    self.base = base\n    self.index = index\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Index.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize index by canonicalizing the base expression.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the indexing expression</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize index by canonicalizing the base expression.\n\n    Returns:\n        Expr: Canonical form of the indexing expression\n    \"\"\"\n    base = self.base.canonicalize()\n    return Index(base, self.index)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Index.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Compute the shape after indexing.</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Compute the shape after indexing.\"\"\"\n    base_shape = self.base.check_shape()\n    dummy = np.zeros(base_shape)\n    try:\n        result = dummy[self.index]\n    except Exception as e:\n        raise ValueError(f\"Bad index {self.index} for shape {base_shape}\") from e\n    return result.shape\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Inequality","title":"<code>Inequality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Inequality constraint for optimization problems.</p> <p>Represents an inequality constraint: lhs &lt;= rhs. Can be created using the &lt;= operator on Expr objects.</p> Example <p>Define an Inequality constraint:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = x &lt;= 10  # Creates Inequality(x, Constant(10))\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class Inequality(Constraint):\n    \"\"\"Inequality constraint for optimization problems.\n\n    Represents an inequality constraint: lhs &lt;= rhs. Can be created using the &lt;=\n    operator on Expr objects.\n\n    Example:\n        Define an Inequality constraint:\n\n            x = ox.State(\"x\", shape=(3,))\n            constraint = x &lt;= 10  # Creates Inequality(x, Constant(10))\n    \"\"\"\n\n    def __repr__(self):\n        return f\"{self.lhs!r} &lt;= {self.rhs!r}\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Inv","title":"<code>Inv</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Matrix inverse operation for symbolic expressions.</p> <p>Computes the inverse of a square matrix. For batched inputs with shape (..., M, M), inverts the last two dimensions following jax.numpy.linalg.inv conventions.</p> <p>The canonicalization includes an optimization that eliminates double inverses: Inv(Inv(A)) simplifies to A.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Square matrix expression to invert</p> Example <p>Define matrix inverse expressions::</p> <pre><code>M = Variable(\"M\", shape=(3, 3))\nM_inv = Inv(M)  # Result shape (3, 3)\n\n# Batched case\nM_batch = Variable(\"M_batch\", shape=(5, 3, 3))\nM_batch_inv = Inv(M_batch)  # Result shape (5, 3, 3)\n</code></pre> Note <p>Matrix inverse is non-convex and only supported in JAX lowering. CVXPy lowering will raise NotImplementedError since inv(X) is neither convex nor concave for variable matrices.</p> <p>Warning</p> <p>Solving a matrix inverse inside an optimization loop can be somewhat of an oxymoron and performance may be severly impacted. Consider whether your problem can be reformulated to avoid the inverse.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>class Inv(Expr):\n    \"\"\"Matrix inverse operation for symbolic expressions.\n\n    Computes the inverse of a square matrix. For batched inputs with shape\n    (..., M, M), inverts the last two dimensions following jax.numpy.linalg.inv\n    conventions.\n\n    The canonicalization includes an optimization that eliminates double inverses:\n    Inv(Inv(A)) simplifies to A.\n\n    Attributes:\n        operand: Square matrix expression to invert\n\n    Example:\n        Define matrix inverse expressions::\n\n            M = Variable(\"M\", shape=(3, 3))\n            M_inv = Inv(M)  # Result shape (3, 3)\n\n            # Batched case\n            M_batch = Variable(\"M_batch\", shape=(5, 3, 3))\n            M_batch_inv = Inv(M_batch)  # Result shape (5, 3, 3)\n\n    Note:\n        Matrix inverse is non-convex and only supported in JAX lowering.\n        CVXPy lowering will raise NotImplementedError since inv(X) is neither\n        convex nor concave for variable matrices.\n\n    !!! warning\n        Solving a matrix inverse inside an optimization loop can be somewhat\n        of an oxymoron and performance may be severly impacted.\n        Consider whether your problem can be reformulated to avoid the inverse.\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a matrix inverse operation.\n\n        Args:\n            operand: Square matrix expression to invert. Must have shape\n                (..., M, M) where the last two dimensions are equal.\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the operand with double inverse optimization and constant folding.\"\"\"\n        operand = self.operand.canonicalize()\n\n        # Double inverse optimization: Inv(Inv(A)) = A\n        if isinstance(operand, Inv):\n            return operand.operand\n\n        # Constant folding: compute inverse at canonicalization time\n        if isinstance(operand, Constant):\n            return Constant(np.linalg.inv(operand.value))\n\n        return Inv(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Matrix inverse preserves shape; validates square matrix.\"\"\"\n        operand_shape = self.operand.check_shape()\n\n        if len(operand_shape) &lt; 2:\n            raise ValueError(f\"Inv requires at least a 2D matrix, got shape {operand_shape}\")\n\n        if operand_shape[-1] != operand_shape[-2]:\n            raise ValueError(\n                f\"Inv requires a square matrix (last two dims must be equal), \"\n                f\"got shape {operand_shape}\"\n            )\n\n        return operand_shape\n\n    def __repr__(self):\n        return f\"inv({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Inv.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a matrix inverse operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Square matrix expression to invert. Must have shape (..., M, M) where the last two dimensions are equal.</p> required Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a matrix inverse operation.\n\n    Args:\n        operand: Square matrix expression to invert. Must have shape\n            (..., M, M) where the last two dimensions are equal.\n    \"\"\"\n    self.operand = to_expr(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Inv.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the operand with double inverse optimization and constant folding.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the operand with double inverse optimization and constant folding.\"\"\"\n    operand = self.operand.canonicalize()\n\n    # Double inverse optimization: Inv(Inv(A)) = A\n    if isinstance(operand, Inv):\n        return operand.operand\n\n    # Constant folding: compute inverse at canonicalization time\n    if isinstance(operand, Constant):\n        return Constant(np.linalg.inv(operand.value))\n\n    return Inv(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Inv.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Matrix inverse preserves shape; validates square matrix.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Matrix inverse preserves shape; validates square matrix.\"\"\"\n    operand_shape = self.operand.check_shape()\n\n    if len(operand_shape) &lt; 2:\n        raise ValueError(f\"Inv requires at least a 2D matrix, got shape {operand_shape}\")\n\n    if operand_shape[-1] != operand_shape[-2]:\n        raise ValueError(\n            f\"Inv requires a square matrix (last two dims must be equal), \"\n            f\"got shape {operand_shape}\"\n        )\n\n    return operand_shape\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Leaf","title":"<code>Leaf</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Base class for leaf nodes (terminal expressions) in the symbolic expression tree.</p> <p>Leaf nodes represent named symbolic variables that don't have child expressions. This includes Parameters, Variables, States, and Controls.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the leaf node</p> <code>_shape</code> <code>tuple</code> <p>Shape of the leaf node</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class Leaf(Expr):\n    \"\"\"\n    Base class for leaf nodes (terminal expressions) in the symbolic expression tree.\n\n    Leaf nodes represent named symbolic variables that don't have child expressions.\n    This includes Parameters, Variables, States, and Controls.\n\n    Attributes:\n        name (str): Name identifier for the leaf node\n        _shape (tuple): Shape of the leaf node\n    \"\"\"\n\n    def __init__(self, name: str, shape: tuple = ()):\n        \"\"\"Initialize a Leaf node.\n\n        Args:\n            name (str): Name identifier for the leaf node\n            shape (tuple): Shape of the leaf node\n        \"\"\"\n        super().__init__()\n        self.name = name\n        self._shape = shape\n\n    @property\n    def shape(self):\n        \"\"\"Get the shape of the leaf node.\n\n        Returns:\n            tuple: Shape of the leaf node\n        \"\"\"\n        return self._shape\n\n    def children(self):\n        \"\"\"Leaf nodes have no children.\n\n        Returns:\n            list: Empty list since leaf nodes are terminal\n        \"\"\"\n        return []\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Leaf nodes are already in canonical form.\n\n        Returns:\n            Expr: Returns self since leaf nodes are already canonical\n        \"\"\"\n        return self\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Return the shape of this leaf node.\n\n        Returns:\n            tuple: The shape of the leaf node\n        \"\"\"\n        return self._shape\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash leaf node by class name and shape.\n\n        This base implementation hashes the class name and shape. Subclasses\n        like Variable and Parameter override this to add their specific\n        canonical identifiers (_slice for Variables, value for Parameters).\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(self.__class__.__name__.encode())\n        hasher.update(str(self._shape).encode())\n\n    def __repr__(self):\n        \"\"\"String representation of the leaf node.\n\n        Returns:\n            str: A string describing the leaf node\n        \"\"\"\n        return f\"{self.__class__.__name__}('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Leaf.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Get the shape of the leaf node.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Shape of the leaf node</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Leaf.__init__","title":"<code>__init__(name: str, shape: tuple = ())</code>","text":"<p>Initialize a Leaf node.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name identifier for the leaf node</p> required <code>shape</code> <code>tuple</code> <p>Shape of the leaf node</p> <code>()</code> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def __init__(self, name: str, shape: tuple = ()):\n    \"\"\"Initialize a Leaf node.\n\n    Args:\n        name (str): Name identifier for the leaf node\n        shape (tuple): Shape of the leaf node\n    \"\"\"\n    super().__init__()\n    self.name = name\n    self._shape = shape\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Leaf.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Leaf nodes are already in canonical form.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Returns self since leaf nodes are already canonical</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Leaf nodes are already in canonical form.\n\n    Returns:\n        Expr: Returns self since leaf nodes are already canonical\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Leaf.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Return the shape of this leaf node.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The shape of the leaf node</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Return the shape of this leaf node.\n\n    Returns:\n        tuple: The shape of the leaf node\n    \"\"\"\n    return self._shape\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Leaf.children","title":"<code>children()</code>","text":"<p>Leaf nodes have no children.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Empty list since leaf nodes are terminal</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def children(self):\n    \"\"\"Leaf nodes have no children.\n\n    Returns:\n        list: Empty list since leaf nodes are terminal\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Linterp","title":"<code>Linterp</code>","text":"<p>               Bases: <code>Expr</code></p> <p>1D linear interpolation for symbolic expressions.</p> <p>Computes the linear interpolant of data points (xp, fp) evaluated at x, equivalent to jax.numpy.interp(x, xp, fp). For values outside the data range, the boundary values are returned (no extrapolation).</p> <p>This is useful for incorporating tabulated data (e.g., atmospheric properties, engine thrust curves, aerodynamic coefficients) into trajectory optimization dynamics and constraints.</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Query point(s) at which to evaluate the interpolant (symbolic expression)</p> <code>xp</code> <p>1D array of x-coordinates of data points (must be increasing)</p> <code>fp</code> <p>1D array of y-coordinates of data points (same length as xp)</p> Example <p>Interpolate atmospheric density from altitude table::</p> <pre><code>import openscvx as ox\nimport numpy as np\n\n# US 1976 Standard Atmosphere data\nalt_data = np.array([0, 5000, 10000, 15000, 20000])  # meters\nrho_data = np.array([1.225, 0.736, 0.414, 0.195, 0.089])  # kg/m^3\n\naltitude = ox.State(\"altitude\", shape=(1,))\nrho = ox.Linterp(altitude[0], alt_data, rho_data)\n\n# rho can now be used in dynamics expressions\ndrag = 0.5 * rho * v**2 * Cd * S\n</code></pre> Note <ul> <li>xp must be strictly increasing</li> <li>For query points outside [xp[0], xp[-1]], boundary values are returned</li> </ul> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Linterp(Expr):\n    \"\"\"1D linear interpolation for symbolic expressions.\n\n    Computes the linear interpolant of data points (xp, fp) evaluated at x,\n    equivalent to jax.numpy.interp(x, xp, fp). For values outside the data range,\n    the boundary values are returned (no extrapolation).\n\n    This is useful for incorporating tabulated data (e.g., atmospheric properties,\n    engine thrust curves, aerodynamic coefficients) into trajectory optimization\n    dynamics and constraints.\n\n    Attributes:\n        x: Query point(s) at which to evaluate the interpolant (symbolic expression)\n        xp: 1D array of x-coordinates of data points (must be increasing)\n        fp: 1D array of y-coordinates of data points (same length as xp)\n\n    Example:\n        Interpolate atmospheric density from altitude table::\n\n            import openscvx as ox\n            import numpy as np\n\n            # US 1976 Standard Atmosphere data\n            alt_data = np.array([0, 5000, 10000, 15000, 20000])  # meters\n            rho_data = np.array([1.225, 0.736, 0.414, 0.195, 0.089])  # kg/m^3\n\n            altitude = ox.State(\"altitude\", shape=(1,))\n            rho = ox.Linterp(altitude[0], alt_data, rho_data)\n\n            # rho can now be used in dynamics expressions\n            drag = 0.5 * rho * v**2 * Cd * S\n\n    Note:\n        - xp must be strictly increasing\n        - For query points outside [xp[0], xp[-1]], boundary values are returned\n    \"\"\"\n\n    def __init__(self, x, xp, fp):\n        \"\"\"Initialize a 1D linear interpolation node.\n\n        Args:\n            x: Query point(s) at which to evaluate the interpolant.\n                Can be a scalar or array symbolic expression.\n            xp: 1D array of x-coordinates of data points. Must be increasing.\n                Can be a numpy array or Constant expression.\n            fp: 1D array of y-coordinates of data points. Must have same length as xp.\n                Can be a numpy array or Constant expression.\n        \"\"\"\n        self.x = to_expr(x)\n        self.xp = to_expr(xp)\n        self.fp = to_expr(fp)\n\n    def children(self):\n        return [self.x, self.xp, self.fp]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize by canonicalizing all operands.\"\"\"\n        x = self.x.canonicalize()\n        xp = self.xp.canonicalize()\n        fp = self.fp.canonicalize()\n        return Linterp(x, xp, fp)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Output shape matches the query point shape.\n\n        The interpolation is element-wise over x, so the output has\n        the same shape as the query points.\n\n        Returns:\n            tuple: Shape of the query point x\n\n        Raises:\n            ValueError: If xp and fp have different lengths or are not 1D\n        \"\"\"\n        xp_shape = self.xp.check_shape()\n        fp_shape = self.fp.check_shape()\n\n        if len(xp_shape) != 1:\n            raise ValueError(f\"Linterp xp must be 1D, got shape {xp_shape}\")\n        if len(fp_shape) != 1:\n            raise ValueError(f\"Linterp fp must be 1D, got shape {fp_shape}\")\n        if xp_shape != fp_shape:\n            raise ValueError(\n                f\"Linterp xp and fp must have same length, got {xp_shape} vs {fp_shape}\"\n            )\n\n        return self.x.check_shape()\n\n    def __repr__(self):\n        return f\"linterp({self.x!r}, {self.xp!r}, {self.fp!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Linterp.__init__","title":"<code>__init__(x, xp, fp)</code>","text":"<p>Initialize a 1D linear interpolation node.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>Query point(s) at which to evaluate the interpolant. Can be a scalar or array symbolic expression.</p> required <code>xp</code> <p>1D array of x-coordinates of data points. Must be increasing. Can be a numpy array or Constant expression.</p> required <code>fp</code> <p>1D array of y-coordinates of data points. Must have same length as xp. Can be a numpy array or Constant expression.</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, x, xp, fp):\n    \"\"\"Initialize a 1D linear interpolation node.\n\n    Args:\n        x: Query point(s) at which to evaluate the interpolant.\n            Can be a scalar or array symbolic expression.\n        xp: 1D array of x-coordinates of data points. Must be increasing.\n            Can be a numpy array or Constant expression.\n        fp: 1D array of y-coordinates of data points. Must have same length as xp.\n            Can be a numpy array or Constant expression.\n    \"\"\"\n    self.x = to_expr(x)\n    self.xp = to_expr(xp)\n    self.fp = to_expr(fp)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Linterp.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize by canonicalizing all operands.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize by canonicalizing all operands.\"\"\"\n    x = self.x.canonicalize()\n    xp = self.xp.canonicalize()\n    fp = self.fp.canonicalize()\n    return Linterp(x, xp, fp)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Linterp.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Output shape matches the query point shape.</p> <p>The interpolation is element-wise over x, so the output has the same shape as the query points.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape of the query point x</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If xp and fp have different lengths or are not 1D</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Output shape matches the query point shape.\n\n    The interpolation is element-wise over x, so the output has\n    the same shape as the query points.\n\n    Returns:\n        tuple: Shape of the query point x\n\n    Raises:\n        ValueError: If xp and fp have different lengths or are not 1D\n    \"\"\"\n    xp_shape = self.xp.check_shape()\n    fp_shape = self.fp.check_shape()\n\n    if len(xp_shape) != 1:\n        raise ValueError(f\"Linterp xp must be 1D, got shape {xp_shape}\")\n    if len(fp_shape) != 1:\n        raise ValueError(f\"Linterp fp must be 1D, got shape {fp_shape}\")\n    if xp_shape != fp_shape:\n        raise ValueError(\n            f\"Linterp xp and fp must have same length, got {xp_shape} vs {fp_shape}\"\n        )\n\n    return self.x.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Log","title":"<code>Log</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise natural logarithm function for symbolic expressions.</p> <p>Computes the natural logarithm (base e) of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply logarithm to</p> Example <p>Define a Log expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\nlog_x = Log(x)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Log(Expr):\n    \"\"\"Element-wise natural logarithm function for symbolic expressions.\n\n    Computes the natural logarithm (base e) of each element in the operand.\n    Preserves the shape of the input expression.\n\n    Attributes:\n        operand: Expression to apply logarithm to\n\n    Example:\n        Define a Log expression:\n\n            x = Variable(\"x\", shape=(3,))\n            log_x = Log(x)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a natural logarithm operation.\n\n        Args:\n            operand: Expression to apply logarithm to\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Log(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Log preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"log({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Log.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a natural logarithm operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to apply logarithm to</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a natural logarithm operation.\n\n    Args:\n        operand: Expression to apply logarithm to\n    \"\"\"\n    self.operand = to_expr(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Log.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Log preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Log preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.LogSumExp","title":"<code>LogSumExp</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Log-sum-exp function for symbolic expressions.</p> <p>Computes the log-sum-exp (LSE) of multiple operands, which is a smooth, differentiable approximation to the maximum function. The log-sum-exp is defined as:</p> <pre><code>logsumexp(x\u2081, x\u2082, ..., x\u2099) = log(exp(x\u2081) + exp(x\u2082) + ... + exp(x\u2099))\n</code></pre> <p>This function is numerically stable and is commonly used in optimization as a smooth alternative to the non-differentiable maximum function. It satisfies the inequality:</p> <pre><code>max(x\u2081, x\u2082, ..., x\u2099) \u2264 logsumexp(x\u2081, x\u2082, ..., x\u2099) \u2264 max(x\u2081, x\u2082, ..., x\u2099) + log(n)\n</code></pre> <p>The log-sum-exp is convex and is particularly useful for: - Smooth approximations of maximum constraints - Soft maximum operations in neural networks - Relaxing logical OR operations in STL specifications</p> <p>Attributes:</p> Name Type Description <code>operands</code> <p>List of expressions to compute log-sum-exp over</p> Example <p>Define a LogSumExp expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(3,))\nz = Variable(\"z\", shape=(3,))\nlse = LogSumExp(x, y, z)  # Smooth approximation to max(x, y, z)\n</code></pre> <p>Use in STL relaxation:</p> <pre><code>import openscvx as ox\n# Relax: Or(\u03c6\u2081, \u03c6\u2082) using log-sum-exp\nphi1 = ox.Norm(x - goal1) - 0.5\nphi2 = ox.Norm(x - goal2) - 0.5\nrelaxed_or = LogSumExp(phi1, phi2) &gt;= 0\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class LogSumExp(Expr):\n    \"\"\"Log-sum-exp function for symbolic expressions.\n\n    Computes the log-sum-exp (LSE) of multiple operands, which is a smooth,\n    differentiable approximation to the maximum function. The log-sum-exp is\n    defined as:\n\n        logsumexp(x\u2081, x\u2082, ..., x\u2099) = log(exp(x\u2081) + exp(x\u2082) + ... + exp(x\u2099))\n\n    This function is numerically stable and is commonly used in optimization\n    as a smooth alternative to the non-differentiable maximum function. It\n    satisfies the inequality:\n\n        max(x\u2081, x\u2082, ..., x\u2099) \u2264 logsumexp(x\u2081, x\u2082, ..., x\u2099) \u2264 max(x\u2081, x\u2082, ..., x\u2099) + log(n)\n\n    The log-sum-exp is convex and is particularly useful for:\n    - Smooth approximations of maximum constraints\n    - Soft maximum operations in neural networks\n    - Relaxing logical OR operations in STL specifications\n\n    Attributes:\n        operands: List of expressions to compute log-sum-exp over\n\n    Example:\n        Define a LogSumExp expression:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(3,))\n            z = Variable(\"z\", shape=(3,))\n            lse = LogSumExp(x, y, z)  # Smooth approximation to max(x, y, z)\n\n        Use in STL relaxation:\n\n            import openscvx as ox\n            # Relax: Or(\u03c6\u2081, \u03c6\u2082) using log-sum-exp\n            phi1 = ox.Norm(x - goal1) - 0.5\n            phi2 = ox.Norm(x - goal2) - 0.5\n            relaxed_or = LogSumExp(phi1, phi2) &gt;= 0\n    \"\"\"\n\n    def __init__(self, *args):\n        \"\"\"Initialize a log-sum-exp operation.\n\n        Args:\n            *args: Two or more expressions to compute log-sum-exp over\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(args) &lt; 2:\n            raise ValueError(\"LogSumExp requires two or more operands\")\n        self.operands = [to_expr(a) for a in args]\n\n    def children(self):\n        return list(self.operands)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize log-sum-exp: flatten nested LogSumExp, fold constants.\"\"\"\n        from .expr import Constant\n\n        operands = []\n        const_vals = []\n\n        for op in self.operands:\n            c = op.canonicalize()\n            if isinstance(c, LogSumExp):\n                operands.extend(c.operands)\n            elif isinstance(c, Constant):\n                const_vals.append(c.value)\n            else:\n                operands.append(c)\n\n        # If we have constants, compute their log-sum-exp and keep it\n        if const_vals:\n            # For constants, we can compute logsumexp directly\n            # logsumexp(c1, c2, ..., cn) = log(sum(exp(ci)))\n            exp_vals = [np.exp(v) for v in const_vals]\n            lse_const = np.log(np.sum(exp_vals))\n            operands.append(Constant(lse_const))\n\n        if not operands:\n            raise ValueError(\"LogSumExp must have at least one operand after canonicalization\")\n        if len(operands) == 1:\n            return operands[0]\n        return LogSumExp(*operands)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"LogSumExp broadcasts shapes like NumPy, preserving element-wise shape.\"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"LogSumExp shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        inner = \", \".join(repr(op) for op in self.operands)\n        return f\"logsumexp({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.LogSumExp.__init__","title":"<code>__init__(*args)</code>","text":"<p>Initialize a log-sum-exp operation.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Two or more expressions to compute log-sum-exp over</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two operands are provided</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, *args):\n    \"\"\"Initialize a log-sum-exp operation.\n\n    Args:\n        *args: Two or more expressions to compute log-sum-exp over\n\n    Raises:\n        ValueError: If fewer than two operands are provided\n    \"\"\"\n    if len(args) &lt; 2:\n        raise ValueError(\"LogSumExp requires two or more operands\")\n    self.operands = [to_expr(a) for a in args]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.LogSumExp.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize log-sum-exp: flatten nested LogSumExp, fold constants.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize log-sum-exp: flatten nested LogSumExp, fold constants.\"\"\"\n    from .expr import Constant\n\n    operands = []\n    const_vals = []\n\n    for op in self.operands:\n        c = op.canonicalize()\n        if isinstance(c, LogSumExp):\n            operands.extend(c.operands)\n        elif isinstance(c, Constant):\n            const_vals.append(c.value)\n        else:\n            operands.append(c)\n\n    # If we have constants, compute their log-sum-exp and keep it\n    if const_vals:\n        # For constants, we can compute logsumexp directly\n        # logsumexp(c1, c2, ..., cn) = log(sum(exp(ci)))\n        exp_vals = [np.exp(v) for v in const_vals]\n        lse_const = np.log(np.sum(exp_vals))\n        operands.append(Constant(lse_const))\n\n    if not operands:\n        raise ValueError(\"LogSumExp must have at least one operand after canonicalization\")\n    if len(operands) == 1:\n        return operands[0]\n    return LogSumExp(*operands)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.LogSumExp.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>LogSumExp broadcasts shapes like NumPy, preserving element-wise shape.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"LogSumExp broadcasts shapes like NumPy, preserving element-wise shape.\"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"LogSumExp shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.MatMul","title":"<code>MatMul</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Matrix multiplication operation for symbolic expressions.</p> <p>Represents matrix multiplication following standard linear algebra rules. Can be created using the @ operator on Expr objects. Handles: - Matrix @ Matrix: (m,n) @ (n,k) -&gt; (m,k) - Matrix @ Vector: (m,n) @ (n,) -&gt; (m,) - Vector @ Matrix: (m,) @ (m,n) -&gt; (n,) - Vector @ Vector: (m,) @ (m,) -&gt; scalar</p> <p>Attributes:</p> Name Type Description <code>left</code> <p>Left-hand side expression</p> <code>right</code> <p>Right-hand side expression</p> Example <p>Define a MatMul expression:</p> <pre><code>A = ox.State(\"A\", shape=(3, 4))\nx = ox.State(\"x\", shape=(4,))\ny = A @ x  # Creates MatMul(A, x), result shape (3,)\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class MatMul(Expr):\n    \"\"\"Matrix multiplication operation for symbolic expressions.\n\n    Represents matrix multiplication following standard linear algebra rules.\n    Can be created using the @ operator on Expr objects. Handles:\n    - Matrix @ Matrix: (m,n) @ (n,k) -&gt; (m,k)\n    - Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n    - Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n    - Vector @ Vector: (m,) @ (m,) -&gt; scalar\n\n    Attributes:\n        left: Left-hand side expression\n        right: Right-hand side expression\n\n    Example:\n        Define a MatMul expression:\n\n            A = ox.State(\"A\", shape=(3, 4))\n            x = ox.State(\"x\", shape=(4,))\n            y = A @ x  # Creates MatMul(A, x), result shape (3,)\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\"Initialize a matrix multiplication operation.\n\n        Args:\n            left: Left-hand side expression for matrix multiplication\n            right: Right-hand side expression for matrix multiplication\n        \"\"\"\n        self.left = left\n        self.right = right\n\n    def children(self):\n        return [self.left, self.right]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        left = self.left.canonicalize()\n        right = self.right.canonicalize()\n        return MatMul(left, right)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check matrix multiplication shape compatibility and return result shape.\"\"\"\n        L, R = self.left.check_shape(), self.right.check_shape()\n\n        # Handle different matmul cases:\n        # Matrix @ Matrix: (m,n) @ (n,k) -&gt; (m,k)\n        # Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n        # Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n        # Vector @ Vector: (m,) @ (m,) -&gt; ()\n\n        if len(L) == 0 or len(R) == 0:\n            raise ValueError(f\"MatMul requires at least 1D operands: {L} @ {R}\")\n\n        if len(L) == 1 and len(R) == 1:\n            # Vector @ Vector -&gt; scalar\n            if L[0] != R[0]:\n                raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n            return ()\n        elif len(L) == 1:\n            # Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n            if len(R) &lt; 2 or L[0] != R[-2]:\n                raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n            return R[-1:]\n        elif len(R) == 1:\n            # Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n            if len(L) &lt; 2 or L[-1] != R[0]:\n                raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n            return L[:-1]\n        else:\n            # Matrix @ Matrix: (...,m,n) @ (...,n,k) -&gt; (...,m,k)\n            if len(L) &lt; 2 or len(R) &lt; 2 or L[-1] != R[-2]:\n                raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n            return L[:-1] + (R[-1],)\n\n    def __repr__(self):\n        return f\"({self.left!r} * {self.right!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.MatMul.__init__","title":"<code>__init__(left, right)</code>","text":"<p>Initialize a matrix multiplication operation.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <p>Left-hand side expression for matrix multiplication</p> required <code>right</code> <p>Right-hand side expression for matrix multiplication</p> required Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def __init__(self, left, right):\n    \"\"\"Initialize a matrix multiplication operation.\n\n    Args:\n        left: Left-hand side expression for matrix multiplication\n        right: Right-hand side expression for matrix multiplication\n    \"\"\"\n    self.left = left\n    self.right = right\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.MatMul.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check matrix multiplication shape compatibility and return result shape.</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check matrix multiplication shape compatibility and return result shape.\"\"\"\n    L, R = self.left.check_shape(), self.right.check_shape()\n\n    # Handle different matmul cases:\n    # Matrix @ Matrix: (m,n) @ (n,k) -&gt; (m,k)\n    # Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n    # Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n    # Vector @ Vector: (m,) @ (m,) -&gt; ()\n\n    if len(L) == 0 or len(R) == 0:\n        raise ValueError(f\"MatMul requires at least 1D operands: {L} @ {R}\")\n\n    if len(L) == 1 and len(R) == 1:\n        # Vector @ Vector -&gt; scalar\n        if L[0] != R[0]:\n            raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n        return ()\n    elif len(L) == 1:\n        # Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n        if len(R) &lt; 2 or L[0] != R[-2]:\n            raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n        return R[-1:]\n    elif len(R) == 1:\n        # Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n        if len(L) &lt; 2 or L[-1] != R[0]:\n            raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n        return L[:-1]\n    else:\n        # Matrix @ Matrix: (...,m,n) @ (...,n,k) -&gt; (...,m,k)\n        if len(L) &lt; 2 or len(R) &lt; 2 or L[-1] != R[-2]:\n            raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n        return L[:-1] + (R[-1],)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Max","title":"<code>Max</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise maximum function for symbolic expressions.</p> <p>Computes the element-wise maximum across two or more operands. Supports broadcasting following NumPy rules. During canonicalization, nested Max operations are flattened and constants are folded.</p> <p>Attributes:</p> Name Type Description <code>operands</code> <p>List of expressions to compute maximum over</p> Example <p>Define a Max expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(3,))\nmax_xy = Max(x, y, 0)  # Element-wise max(x, y, 0)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Max(Expr):\n    \"\"\"Element-wise maximum function for symbolic expressions.\n\n    Computes the element-wise maximum across two or more operands. Supports\n    broadcasting following NumPy rules. During canonicalization, nested Max\n    operations are flattened and constants are folded.\n\n    Attributes:\n        operands: List of expressions to compute maximum over\n\n    Example:\n        Define a Max expression:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(3,))\n            max_xy = Max(x, y, 0)  # Element-wise max(x, y, 0)\n    \"\"\"\n\n    def __init__(self, *args):\n        \"\"\"Initialize a maximum operation.\n\n        Args:\n            *args: Two or more expressions to compute maximum over\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(args) &lt; 2:\n            raise ValueError(\"Max requires two or more operands\")\n        self.operands = [to_expr(a) for a in args]\n\n    def children(self):\n        return list(self.operands)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize max: flatten nested Max, fold constants.\"\"\"\n        from .expr import Constant\n\n        operands = []\n        const_vals = []\n\n        for op in self.operands:\n            c = op.canonicalize()\n            if isinstance(c, Max):\n                operands.extend(c.operands)\n            elif isinstance(c, Constant):\n                const_vals.append(c.value)\n            else:\n                operands.append(c)\n\n        # If we have constants, compute their max and keep it\n        if const_vals:\n            max_const = np.maximum.reduce(const_vals)\n            operands.append(Constant(max_const))\n\n        if not operands:\n            raise ValueError(\"Max must have at least one operand after canonicalization\")\n        if len(operands) == 1:\n            return operands[0]\n        return Max(*operands)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Max broadcasts shapes like NumPy.\"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Max shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        inner = \", \".join(repr(op) for op in self.operands)\n        return f\"max({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Max.__init__","title":"<code>__init__(*args)</code>","text":"<p>Initialize a maximum operation.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Two or more expressions to compute maximum over</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two operands are provided</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, *args):\n    \"\"\"Initialize a maximum operation.\n\n    Args:\n        *args: Two or more expressions to compute maximum over\n\n    Raises:\n        ValueError: If fewer than two operands are provided\n    \"\"\"\n    if len(args) &lt; 2:\n        raise ValueError(\"Max requires two or more operands\")\n    self.operands = [to_expr(a) for a in args]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Max.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize max: flatten nested Max, fold constants.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize max: flatten nested Max, fold constants.\"\"\"\n    from .expr import Constant\n\n    operands = []\n    const_vals = []\n\n    for op in self.operands:\n        c = op.canonicalize()\n        if isinstance(c, Max):\n            operands.extend(c.operands)\n        elif isinstance(c, Constant):\n            const_vals.append(c.value)\n        else:\n            operands.append(c)\n\n    # If we have constants, compute their max and keep it\n    if const_vals:\n        max_const = np.maximum.reduce(const_vals)\n        operands.append(Constant(max_const))\n\n    if not operands:\n        raise ValueError(\"Max must have at least one operand after canonicalization\")\n    if len(operands) == 1:\n        return operands[0]\n    return Max(*operands)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Max.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Max broadcasts shapes like NumPy.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Max broadcasts shapes like NumPy.\"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Max shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Mul","title":"<code>Mul</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise multiplication operation for symbolic expressions.</p> <p>Represents element-wise (Hadamard) multiplication of two or more expressions. Supports broadcasting following NumPy rules. Can be created using the * operator on Expr objects. For matrix multiplication, use MatMul or the @ operator.</p> <p>Attributes:</p> Name Type Description <code>factors</code> <p>List of expression operands to multiply together</p> Example <p>Define a Mul expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(3,))\nz = x * y * 2  # Creates Mul(x, y, Constant(2))\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Mul(Expr):\n    \"\"\"Element-wise multiplication operation for symbolic expressions.\n\n    Represents element-wise (Hadamard) multiplication of two or more expressions.\n    Supports broadcasting following NumPy rules. Can be created using the * operator\n    on Expr objects. For matrix multiplication, use MatMul or the @ operator.\n\n    Attributes:\n        factors: List of expression operands to multiply together\n\n    Example:\n        Define a Mul expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(3,))\n            z = x * y * 2  # Creates Mul(x, y, Constant(2))\n    \"\"\"\n\n    def __init__(self, *args):\n        \"\"\"Initialize an element-wise multiplication operation.\n\n        Args:\n            *args: Two or more expressions to multiply together\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(args) &lt; 2:\n            raise ValueError(\"Mul requires two or more operands\")\n        self.factors = [to_expr(a) for a in args]\n\n    def children(self):\n        return list(self.factors)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize multiplication: flatten, fold constants, and eliminating ones.\n\n        Returns:\n            Expr: Canonical form of the multiplication expression\n        \"\"\"\n        factors = []\n        const_vals = []\n\n        for f in self.factors:\n            c = f.canonicalize()\n            if isinstance(c, Mul):\n                factors.extend(c.factors)\n            elif isinstance(c, Constant):\n                const_vals.append(c.value)\n            else:\n                factors.append(c)\n\n        if const_vals:\n            # Multiply constants element-wise (broadcasting), not reducing with prod\n            prod = const_vals[0]\n            for val in const_vals[1:]:\n                prod = prod * val\n\n            # If prod != 1, keep it\n            # Check both scalar and array cases\n            is_identity = False\n            if isinstance(prod, np.ndarray):\n                is_identity = np.all(prod == 1)\n            else:\n                is_identity = prod == 1\n\n            if not is_identity:\n                factors.append(Constant(prod))\n\n        if not factors:\n            return Constant(np.array(1))\n        if len(factors) == 1:\n            return factors[0]\n        return Mul(*factors)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n\n        Returns:\n            tuple: The broadcasted shape of all operands\n\n        Raises:\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Mul shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        inner = \" * \".join(repr(e) for e in self.factors)\n        return f\"({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Mul.__init__","title":"<code>__init__(*args)</code>","text":"<p>Initialize an element-wise multiplication operation.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Two or more expressions to multiply together</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two operands are provided</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def __init__(self, *args):\n    \"\"\"Initialize an element-wise multiplication operation.\n\n    Args:\n        *args: Two or more expressions to multiply together\n\n    Raises:\n        ValueError: If fewer than two operands are provided\n    \"\"\"\n    if len(args) &lt; 2:\n        raise ValueError(\"Mul requires two or more operands\")\n    self.factors = [to_expr(a) for a in args]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Mul.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize multiplication: flatten, fold constants, and eliminating ones.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the multiplication expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize multiplication: flatten, fold constants, and eliminating ones.\n\n    Returns:\n        Expr: Canonical form of the multiplication expression\n    \"\"\"\n    factors = []\n    const_vals = []\n\n    for f in self.factors:\n        c = f.canonicalize()\n        if isinstance(c, Mul):\n            factors.extend(c.factors)\n        elif isinstance(c, Constant):\n            const_vals.append(c.value)\n        else:\n            factors.append(c)\n\n    if const_vals:\n        # Multiply constants element-wise (broadcasting), not reducing with prod\n        prod = const_vals[0]\n        for val in const_vals[1:]:\n            prod = prod * val\n\n        # If prod != 1, keep it\n        # Check both scalar and array cases\n        is_identity = False\n        if isinstance(prod, np.ndarray):\n            is_identity = np.all(prod == 1)\n        else:\n            is_identity = prod == 1\n\n        if not is_identity:\n            factors.append(Constant(prod))\n\n    if not factors:\n        return Constant(np.array(1))\n    if len(factors) == 1:\n        return factors[0]\n    return Mul(*factors)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Mul.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check shape compatibility and compute broadcasted result shape like NumPy.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The broadcasted shape of all operands</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n\n    Returns:\n        tuple: The broadcasted shape of all operands\n\n    Raises:\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Mul shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Neg","title":"<code>Neg</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Negation operation for symbolic expressions.</p> <p>Represents element-wise negation (unary minus). Can be created using the unary - operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to negate</p> Example <p>Define a Neg expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = -x  # Creates Neg(x)\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Neg(Expr):\n    \"\"\"Negation operation for symbolic expressions.\n\n    Represents element-wise negation (unary minus). Can be created using the\n    unary - operator on Expr objects.\n\n    Attributes:\n        operand: Expression to negate\n\n    Example:\n        Define a Neg expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = -x  # Creates Neg(x)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a negation operation.\n\n        Args:\n            operand: Expression to negate\n        \"\"\"\n        self.operand = operand\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize negation: fold constant negations.\n\n        Returns:\n            Expr: Canonical form of the negation expression\n        \"\"\"\n        o = self.operand.canonicalize()\n        if isinstance(o, Constant):\n            return Constant(-o.value)\n        return Neg(o)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Negation preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"(-{self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Neg.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a negation operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to negate</p> required Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a negation operation.\n\n    Args:\n        operand: Expression to negate\n    \"\"\"\n    self.operand = operand\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Neg.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize negation: fold constant negations.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the negation expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize negation: fold constant negations.\n\n    Returns:\n        Expr: Canonical form of the negation expression\n    \"\"\"\n    o = self.operand.canonicalize()\n    if isinstance(o, Constant):\n        return Constant(-o.value)\n    return Neg(o)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Neg.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Negation preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Negation preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodalConstraint","title":"<code>NodalConstraint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Wrapper for constraints enforced only at specific discrete trajectory nodes.</p> <p>NodalConstraint allows selective enforcement of constraints at specific time points (nodes) in a discretized trajectory, rather than enforcing them at every node. This is useful for:</p> <ul> <li>Specifying waypoint constraints (e.g., pass through point X at node 10)</li> <li>Boundary conditions at non-standard locations</li> <li>Reducing computational cost by checking constraints less frequently</li> <li>Enforcing periodic constraints (e.g., every 5th node)</li> </ul> <p>The wrapper maintains clean separation between the constraint's mathematical definition and the specification of where it should be applied during optimization.</p> Note <p>Bare Constraint objects (without .at() or .over()) are automatically converted to NodalConstraints applied at all nodes during preprocessing.</p> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (Equality or Inequality) to enforce</p> <code>nodes</code> <p>List of integer node indices where the constraint is enforced</p> Example <p>Enforce position constraint only at nodes 0, 10, and 20:</p> <pre><code>x = State(\"x\", shape=(3,))\ntarget = [10, 5, 0]\nconstraint = (x == target).at([0, 10, 20])\n</code></pre> <p>Equivalent using NodalConstraint directly:</p> <pre><code>constraint = NodalConstraint(x == target, nodes=[0, 10, 20])\n</code></pre> <p>Periodic constraint enforcement (every 10th node):</p> <pre><code>velocity_limit = (vel &lt;= 100).at(list(range(0, 100, 10)))\n</code></pre> <p>Bare constraints are automatically applied at all nodes. These are equivalent:</p> <pre><code>constraint1 = vel &lt;= 100  # Auto-converted to all nodes\nconstraint2 = (vel &lt;= 100).at(list(range(n_nodes)))\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class NodalConstraint(Expr):\n    \"\"\"Wrapper for constraints enforced only at specific discrete trajectory nodes.\n\n    NodalConstraint allows selective enforcement of constraints at specific time points\n    (nodes) in a discretized trajectory, rather than enforcing them at every node.\n    This is useful for:\n\n    - Specifying waypoint constraints (e.g., pass through point X at node 10)\n    - Boundary conditions at non-standard locations\n    - Reducing computational cost by checking constraints less frequently\n    - Enforcing periodic constraints (e.g., every 5th node)\n\n    The wrapper maintains clean separation between the constraint's mathematical\n    definition and the specification of where it should be applied during optimization.\n\n    Note:\n        Bare Constraint objects (without .at() or .over()) are automatically converted\n        to NodalConstraints applied at all nodes during preprocessing.\n\n    Attributes:\n        constraint: The wrapped Constraint (Equality or Inequality) to enforce\n        nodes: List of integer node indices where the constraint is enforced\n\n    Example:\n        Enforce position constraint only at nodes 0, 10, and 20:\n\n            x = State(\"x\", shape=(3,))\n            target = [10, 5, 0]\n            constraint = (x == target).at([0, 10, 20])\n\n        Equivalent using NodalConstraint directly:\n\n            constraint = NodalConstraint(x == target, nodes=[0, 10, 20])\n\n        Periodic constraint enforcement (every 10th node):\n\n            velocity_limit = (vel &lt;= 100).at(list(range(0, 100, 10)))\n\n        Bare constraints are automatically applied at all nodes.\n        These are equivalent:\n\n            constraint1 = vel &lt;= 100  # Auto-converted to all nodes\n            constraint2 = (vel &lt;= 100).at(list(range(n_nodes)))\n    \"\"\"\n\n    def __init__(self, constraint: Constraint, nodes: list[int]):\n        \"\"\"Initialize a NodalConstraint.\n\n        Args:\n            constraint: The Constraint (Equality or Inequality) to enforce at specified nodes\n            nodes: List of integer node indices where the constraint should be enforced.\n                Automatically converts numpy integers to Python integers.\n\n        Raises:\n            TypeError: If constraint is not a Constraint instance\n            TypeError: If nodes is not a list\n            TypeError: If any node index is not an integer\n\n        Note:\n            Bounds checking for cross-node constraints (those containing NodeReference)\n            is performed later in the pipeline when N is known, via\n            validate_cross_node_constraint_bounds() in preprocessing.py.\n        \"\"\"\n        if not isinstance(constraint, Constraint):\n            raise TypeError(\"NodalConstraint must wrap a Constraint\")\n        if not isinstance(nodes, list):\n            raise TypeError(\"nodes must be a list of integers\")\n\n        # Convert numpy integers to Python integers\n        converted_nodes = []\n        for n in nodes:\n            if isinstance(n, np.integer):\n                converted_nodes.append(int(n))\n            elif isinstance(n, int):\n                converted_nodes.append(n)\n            else:\n                raise TypeError(\"all node indices must be integers\")\n\n        self.constraint = constraint\n        self.nodes = converted_nodes\n\n    def children(self):\n        \"\"\"Return the wrapped constraint as the only child.\n\n        Returns:\n            list: Single-element list containing the wrapped constraint\n        \"\"\"\n        return [self.constraint]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the wrapped constraint while preserving node specification.\n\n        Returns:\n            NodalConstraint: A new NodalConstraint with canonicalized inner constraint\n        \"\"\"\n        canon_constraint = self.constraint.canonicalize()\n        return NodalConstraint(canon_constraint, self.nodes)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Validate the wrapped constraint's shape.\n\n        NodalConstraint wraps a constraint without changing its computational meaning,\n        only specifying where it should be applied. Like all constraints, it produces\n        a scalar result.\n\n        Returns:\n            tuple: Empty tuple () representing scalar shape\n        \"\"\"\n        # Validate the wrapped constraint's shape\n        self.constraint.check_shape()\n\n        # NodalConstraint produces a scalar like any constraint\n        return ()\n\n    def convex(self) -&gt; \"NodalConstraint\":\n        \"\"\"Mark the underlying constraint as convex for CVXPy lowering.\n\n        Returns:\n            Self with underlying constraint's convex flag set to True (enables method chaining)\n\n        Example:\n            Mark a constraint as convex:\n                constraint = (x &lt;= 10).at([0, 5, 10]).convex()\n        \"\"\"\n        self.constraint.convex()\n        return self\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash NodalConstraint including its node list.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"NodalConstraint\")\n        # Hash the nodes list\n        for node in self.nodes:\n            hasher.update(struct.pack(\"&gt;i\", node))\n        hasher.update(b\"|\")  # Separator to distinguish node counts\n        # Hash the wrapped constraint\n        self.constraint._hash_into(hasher)\n\n    def __repr__(self):\n        \"\"\"String representation of the NodalConstraint.\n\n        Returns:\n            str: String showing the wrapped constraint and node indices\n        \"\"\"\n        return f\"NodalConstraint({self.constraint!r}, nodes={self.nodes})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodalConstraint.__init__","title":"<code>__init__(constraint: Constraint, nodes: list[int])</code>","text":"<p>Initialize a NodalConstraint.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>Constraint</code> <p>The Constraint (Equality or Inequality) to enforce at specified nodes</p> required <code>nodes</code> <code>list[int]</code> <p>List of integer node indices where the constraint should be enforced. Automatically converts numpy integers to Python integers.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If constraint is not a Constraint instance</p> <code>TypeError</code> <p>If nodes is not a list</p> <code>TypeError</code> <p>If any node index is not an integer</p> Note <p>Bounds checking for cross-node constraints (those containing NodeReference) is performed later in the pipeline when N is known, via validate_cross_node_constraint_bounds() in preprocessing.py.</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def __init__(self, constraint: Constraint, nodes: list[int]):\n    \"\"\"Initialize a NodalConstraint.\n\n    Args:\n        constraint: The Constraint (Equality or Inequality) to enforce at specified nodes\n        nodes: List of integer node indices where the constraint should be enforced.\n            Automatically converts numpy integers to Python integers.\n\n    Raises:\n        TypeError: If constraint is not a Constraint instance\n        TypeError: If nodes is not a list\n        TypeError: If any node index is not an integer\n\n    Note:\n        Bounds checking for cross-node constraints (those containing NodeReference)\n        is performed later in the pipeline when N is known, via\n        validate_cross_node_constraint_bounds() in preprocessing.py.\n    \"\"\"\n    if not isinstance(constraint, Constraint):\n        raise TypeError(\"NodalConstraint must wrap a Constraint\")\n    if not isinstance(nodes, list):\n        raise TypeError(\"nodes must be a list of integers\")\n\n    # Convert numpy integers to Python integers\n    converted_nodes = []\n    for n in nodes:\n        if isinstance(n, np.integer):\n            converted_nodes.append(int(n))\n        elif isinstance(n, int):\n            converted_nodes.append(n)\n        else:\n            raise TypeError(\"all node indices must be integers\")\n\n    self.constraint = constraint\n    self.nodes = converted_nodes\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodalConstraint.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the wrapped constraint while preserving node specification.</p> <p>Returns:</p> Name Type Description <code>NodalConstraint</code> <code>Expr</code> <p>A new NodalConstraint with canonicalized inner constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the wrapped constraint while preserving node specification.\n\n    Returns:\n        NodalConstraint: A new NodalConstraint with canonicalized inner constraint\n    \"\"\"\n    canon_constraint = self.constraint.canonicalize()\n    return NodalConstraint(canon_constraint, self.nodes)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodalConstraint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the wrapped constraint's shape.</p> <p>NodalConstraint wraps a constraint without changing its computational meaning, only specifying where it should be applied. Like all constraints, it produces a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Validate the wrapped constraint's shape.\n\n    NodalConstraint wraps a constraint without changing its computational meaning,\n    only specifying where it should be applied. Like all constraints, it produces\n    a scalar result.\n\n    Returns:\n        tuple: Empty tuple () representing scalar shape\n    \"\"\"\n    # Validate the wrapped constraint's shape\n    self.constraint.check_shape()\n\n    # NodalConstraint produces a scalar like any constraint\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodalConstraint.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def children(self):\n    \"\"\"Return the wrapped constraint as the only child.\n\n    Returns:\n        list: Single-element list containing the wrapped constraint\n    \"\"\"\n    return [self.constraint]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodalConstraint.convex","title":"<code>convex() -&gt; NodalConstraint</code>","text":"<p>Mark the underlying constraint as convex for CVXPy lowering.</p> <p>Returns:</p> Type Description <code>NodalConstraint</code> <p>Self with underlying constraint's convex flag set to True (enables method chaining)</p> Example <p>Mark a constraint as convex:     constraint = (x &lt;= 10).at([0, 5, 10]).convex()</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def convex(self) -&gt; \"NodalConstraint\":\n    \"\"\"Mark the underlying constraint as convex for CVXPy lowering.\n\n    Returns:\n        Self with underlying constraint's convex flag set to True (enables method chaining)\n\n    Example:\n        Mark a constraint as convex:\n            constraint = (x &lt;= 10).at([0, 5, 10]).convex()\n    \"\"\"\n    self.constraint.convex()\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodeReference","title":"<code>NodeReference</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Reference to a variable at a specific trajectory node.</p> <p>NodeReference enables inter-node constraints by allowing you to reference the value of a state or control variable at a specific discrete time point (node) in the trajectory. This is essential for expressing temporal relationships such as:</p> <ul> <li>Rate limits and smoothness constraints</li> <li>Multi-step dependencies and recurrence relations</li> <li>Constraints coupling specific nodes</li> </ul> <p>Attributes:</p> Name Type Description <code>base</code> <p>The expression (typically a Leaf like State or Control) being referenced</p> <code>node_idx</code> <p>Trajectory node index (integer, can be negative for end-indexing)</p> Example <p>Rate limit across trajectory:</p> <pre><code>position = State(\"pos\", shape=(3,))\n\n# Create rate limit constraints for all nodes\nconstraints = [\n    (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n    for k in range(1, N)\n]\n</code></pre> <p>Multi-step dependency:</p> <pre><code>state = State(\"x\", shape=(1,))\n\n# Fibonacci-like recurrence at each node\nconstraints = [\n    (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n    for k in range(2, N)\n]\n</code></pre> <p>Coupling specific nodes:</p> <pre><code># Constrain distance between nodes 5 and 10\ncoupling = (position.at(10) - position.at(5) &lt;= threshold).at([10])\n</code></pre> Performance Note <p>Cross-node constraints use dense Jacobian storage. For details on memory usage and performance implications, see LoweredCrossNodeConstraint documentation.</p> Note <p>NodeReference is typically created via the <code>.at(k)</code> method on expressions rather than constructed directly.</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class NodeReference(Expr):\n    \"\"\"Reference to a variable at a specific trajectory node.\n\n    NodeReference enables inter-node constraints by allowing you to reference\n    the value of a state or control variable at a specific discrete time point\n    (node) in the trajectory. This is essential for expressing temporal relationships\n    such as:\n\n    - Rate limits and smoothness constraints\n    - Multi-step dependencies and recurrence relations\n    - Constraints coupling specific nodes\n\n    Attributes:\n        base: The expression (typically a Leaf like State or Control) being referenced\n        node_idx: Trajectory node index (integer, can be negative for end-indexing)\n\n    Example:\n        Rate limit across trajectory:\n\n            position = State(\"pos\", shape=(3,))\n\n            # Create rate limit constraints for all nodes\n            constraints = [\n                (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n                for k in range(1, N)\n            ]\n\n        Multi-step dependency:\n\n            state = State(\"x\", shape=(1,))\n\n            # Fibonacci-like recurrence at each node\n            constraints = [\n                (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n                for k in range(2, N)\n            ]\n\n        Coupling specific nodes:\n\n            # Constrain distance between nodes 5 and 10\n            coupling = (position.at(10) - position.at(5) &lt;= threshold).at([10])\n\n    Performance Note:\n        Cross-node constraints use dense Jacobian storage. For details on memory\n        usage and performance implications, see LoweredCrossNodeConstraint documentation.\n\n    Note:\n        NodeReference is typically created via the `.at(k)` method on expressions\n        rather than constructed directly.\n    \"\"\"\n\n    def __init__(self, base: Expr, node_idx: int):\n        \"\"\"Initialize a NodeReference.\n\n        Args:\n            base: Expression to reference at a specific node (typically a Leaf)\n            node_idx: Absolute trajectory node index (integer)\n                     Supports negative indexing (e.g., -1 for last node)\n\n        Raises:\n            TypeError: If node_idx is not an integer\n        \"\"\"\n        if not isinstance(node_idx, int):\n            raise TypeError(f\"Node index must be an integer, got {type(node_idx).__name__}\")\n\n        self.node_idx = node_idx\n        self.base = base\n\n    def children(self):\n        \"\"\"Return the base expression as the only child.\n\n        Returns:\n            list: Single-element list containing the base expression\n        \"\"\"\n        return [self.base]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize by canonicalizing the base expression.\n\n        Returns:\n            NodeReference: A new NodeReference with canonicalized base\n        \"\"\"\n        canon_base = self.base.canonicalize()\n        return NodeReference(canon_base, self.node_idx)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Return the shape of the base expression.\n\n        NodeReference doesn't change the shape of the underlying expression,\n        it just references it at a specific time point.\n\n        Returns:\n            tuple: The shape of the base expression\n        \"\"\"\n        return self.base.check_shape()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash NodeReference including its node index.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"NodeReference\")\n        # Hash the node index (signed int)\n        hasher.update(struct.pack(\"&gt;i\", self.node_idx))\n        # Hash the base expression\n        self.base._hash_into(hasher)\n\n    def __repr__(self):\n        \"\"\"String representation of the NodeReference.\n\n        Returns:\n            str: String showing the base expression and node index\n        \"\"\"\n        return f\"{self.base!r}.at({self.node_idx})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodeReference.__init__","title":"<code>__init__(base: Expr, node_idx: int)</code>","text":"<p>Initialize a NodeReference.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>Expr</code> <p>Expression to reference at a specific node (typically a Leaf)</p> required <code>node_idx</code> <code>int</code> <p>Absolute trajectory node index (integer)      Supports negative indexing (e.g., -1 for last node)</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If node_idx is not an integer</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def __init__(self, base: Expr, node_idx: int):\n    \"\"\"Initialize a NodeReference.\n\n    Args:\n        base: Expression to reference at a specific node (typically a Leaf)\n        node_idx: Absolute trajectory node index (integer)\n                 Supports negative indexing (e.g., -1 for last node)\n\n    Raises:\n        TypeError: If node_idx is not an integer\n    \"\"\"\n    if not isinstance(node_idx, int):\n        raise TypeError(f\"Node index must be an integer, got {type(node_idx).__name__}\")\n\n    self.node_idx = node_idx\n    self.base = base\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodeReference.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize by canonicalizing the base expression.</p> <p>Returns:</p> Name Type Description <code>NodeReference</code> <code>Expr</code> <p>A new NodeReference with canonicalized base</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize by canonicalizing the base expression.\n\n    Returns:\n        NodeReference: A new NodeReference with canonicalized base\n    \"\"\"\n    canon_base = self.base.canonicalize()\n    return NodeReference(canon_base, self.node_idx)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodeReference.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Return the shape of the base expression.</p> <p>NodeReference doesn't change the shape of the underlying expression, it just references it at a specific time point.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The shape of the base expression</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Return the shape of the base expression.\n\n    NodeReference doesn't change the shape of the underlying expression,\n    it just references it at a specific time point.\n\n    Returns:\n        tuple: The shape of the base expression\n    \"\"\"\n    return self.base.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.NodeReference.children","title":"<code>children()</code>","text":"<p>Return the base expression as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the base expression</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def children(self):\n    \"\"\"Return the base expression as the only child.\n\n    Returns:\n        list: Single-element list containing the base expression\n    \"\"\"\n    return [self.base]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Norm","title":"<code>Norm</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Norm operation for symbolic expressions (reduction to scalar).</p> <p>Computes the norm of an expression according to the specified order parameter. This is a reduction operation that always produces a scalar result regardless of the input shape. Supports various norm types following NumPy/SciPy conventions.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to compute norm of</p> <code>ord</code> <p>Norm order specification (default: \"fro\" for Frobenius norm) - \"fro\": Frobenius norm (default) - \"inf\": Infinity norm - 1: L1 norm (sum of absolute values) - 2: L2 norm (Euclidean norm) - Other values as supported by the backend</p> Example <p>Define Norms:</p> <pre><code>x = Variable(\"x\", shape=(3,))\neuclidean_norm = Norm(x, ord=2)  # L2 norm, result is scalar\nA = Variable(\"A\", shape=(3, 4))\nfrobenius_norm = Norm(A)  # Frobenius norm, result is scalar\n</code></pre> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>class Norm(Expr):\n    \"\"\"Norm operation for symbolic expressions (reduction to scalar).\n\n    Computes the norm of an expression according to the specified order parameter.\n    This is a reduction operation that always produces a scalar result regardless\n    of the input shape. Supports various norm types following NumPy/SciPy conventions.\n\n    Attributes:\n        operand: Expression to compute norm of\n        ord: Norm order specification (default: \"fro\" for Frobenius norm)\n            - \"fro\": Frobenius norm (default)\n            - \"inf\": Infinity norm\n            - 1: L1 norm (sum of absolute values)\n            - 2: L2 norm (Euclidean norm)\n            - Other values as supported by the backend\n\n    Example:\n        Define Norms:\n\n            x = Variable(\"x\", shape=(3,))\n            euclidean_norm = Norm(x, ord=2)  # L2 norm, result is scalar\n            A = Variable(\"A\", shape=(3, 4))\n            frobenius_norm = Norm(A)  # Frobenius norm, result is scalar\n    \"\"\"\n\n    def __init__(self, operand, ord=\"fro\"):\n        \"\"\"Initialize a norm operation.\n\n        Args:\n            operand: Expression to compute norm of\n            ord: Norm order specification (default: \"fro\")\n        \"\"\"\n        self.operand = to_expr(operand)\n        self.ord = ord  # Can be \"fro\", \"inf\", 1, 2, etc.\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the operand but preserve the ord parameter.\"\"\"\n        canon_operand = self.operand.canonicalize()\n        return Norm(canon_operand, ord=self.ord)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Norm reduces any shape to a scalar.\"\"\"\n        # Validate that the operand has a valid shape\n        self.operand.check_shape()\n        # Norm always produces a scalar regardless of input shape\n        return ()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Norm including its ord parameter.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Norm\")\n        # Hash the ord parameter\n        hasher.update(repr(self.ord).encode())\n        # Hash the operand\n        self.operand._hash_into(hasher)\n\n    def __repr__(self):\n        return f\"norm({self.operand!r}, ord={self.ord!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Norm.__init__","title":"<code>__init__(operand, ord='fro')</code>","text":"<p>Initialize a norm operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to compute norm of</p> required <code>ord</code> <p>Norm order specification (default: \"fro\")</p> <code>'fro'</code> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def __init__(self, operand, ord=\"fro\"):\n    \"\"\"Initialize a norm operation.\n\n    Args:\n        operand: Expression to compute norm of\n        ord: Norm order specification (default: \"fro\")\n    \"\"\"\n    self.operand = to_expr(operand)\n    self.ord = ord  # Can be \"fro\", \"inf\", 1, 2, etc.\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Norm.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the operand but preserve the ord parameter.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the operand but preserve the ord parameter.\"\"\"\n    canon_operand = self.operand.canonicalize()\n    return Norm(canon_operand, ord=self.ord)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Norm.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Norm reduces any shape to a scalar.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Norm reduces any shape to a scalar.\"\"\"\n    # Validate that the operand has a valid shape\n    self.operand.check_shape()\n    # Norm always produces a scalar regardless of input shape\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Or","title":"<code>Or</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Logical OR operation for disjunctive constraints.</p> <p>Represents a logical disjunction (OR) between multiple constraint expressions. This is particularly useful in STL-based trajectory optimization for expressing choices or alternatives in task specifications. The Or operation is typically relaxed using smooth approximations (e.g., LogSumExp) during optimization.</p> <p>The Or operation allows expressing constraints like:</p> <ul> <li>\"Reach either goal A OR goal B\"</li> <li>\"Avoid obstacle 1 OR obstacle 2\" (at least one must be satisfied)</li> <li>\"Use path 1 OR path 2 OR path 3\"</li> </ul> <p>During optimization, the disjunction is typically approximated using:     Or(\u03c6\u2081, \u03c6\u2082, ..., \u03c6\u2099) \u2248 LSE(\u03c6\u2081, \u03c6\u2082, ..., \u03c6\u2099) \u2265 0</p> <p>where LSE is the LogSumExp (smooth maximum) function.</p> <p>Attributes:</p> Name Type Description <code>operands</code> <p>List of expressions representing the disjunctive clauses</p> Example <p>Use Or STL operator to enforce that robot must reach either of two goal regions:</p> <pre><code>import openscvx as ox\nx = ox.State(\"x\", shape=(2,))\ngoal_a = ox.Parameter(\"goal_a\", shape=(2,), value=[1.0, 1.0])\ngoal_b = ox.Parameter(\"goal_b\", shape=(2,), value=[-1.0, -1.0])\n# Robot is within 0.5 units of either goal\nreach_a = 0.25 - ox.Norm(x - goal_a)**2\nreach_b = 0.25 - ox.Norm(x - goal_b)**2\nreach_either = ox.Or(reach_a, reach_b)\n</code></pre> Note <p>The Or operation produces a scalar result even when operands are vector expressions, as it represents a single logical proposition.</p> See Also <p>LogSumExp: Common smooth approximation for OR operations Max: Hard maximum (non-smooth alternative)</p> Source code in <code>openscvx/symbolic/expr/stl.py</code> <pre><code>class Or(Expr):\n    \"\"\"Logical OR operation for disjunctive constraints.\n\n    Represents a logical disjunction (OR) between multiple constraint expressions.\n    This is particularly useful in STL-based trajectory optimization for expressing\n    choices or alternatives in task specifications. The Or operation is typically\n    relaxed using smooth approximations (e.g., LogSumExp) during optimization.\n\n    The Or operation allows expressing constraints like:\n\n    - \"Reach either goal A OR goal B\"\n    - \"Avoid obstacle 1 OR obstacle 2\" (at least one must be satisfied)\n    - \"Use path 1 OR path 2 OR path 3\"\n\n    During optimization, the disjunction is typically approximated using:\n        Or(\u03c6\u2081, \u03c6\u2082, ..., \u03c6\u2099) \u2248 LSE(\u03c6\u2081, \u03c6\u2082, ..., \u03c6\u2099) \u2265 0\n\n    where LSE is the LogSumExp (smooth maximum) function.\n\n    Attributes:\n        operands: List of expressions representing the disjunctive clauses\n\n    Example:\n        Use Or STL operator to enforce that robot must reach either of two goal regions:\n\n            import openscvx as ox\n            x = ox.State(\"x\", shape=(2,))\n            goal_a = ox.Parameter(\"goal_a\", shape=(2,), value=[1.0, 1.0])\n            goal_b = ox.Parameter(\"goal_b\", shape=(2,), value=[-1.0, -1.0])\n            # Robot is within 0.5 units of either goal\n            reach_a = 0.25 - ox.Norm(x - goal_a)**2\n            reach_b = 0.25 - ox.Norm(x - goal_b)**2\n            reach_either = ox.Or(reach_a, reach_b)\n\n    Note:\n        The Or operation produces a scalar result even when operands are vector\n        expressions, as it represents a single logical proposition.\n\n    See Also:\n        LogSumExp: Common smooth approximation for OR operations\n        Max: Hard maximum (non-smooth alternative)\n    \"\"\"\n\n    def __init__(self, *operands):\n        \"\"\"Initialize a logical OR operation.\n\n        Args:\n            *operands: Two or more expressions to combine with logical OR.\n                      Each operand typically represents a constraint or condition.\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(operands) &lt; 2:\n            raise ValueError(\"Or requires at least two operands\")\n        self.operands = [to_expr(op) for op in operands]\n\n    def children(self):\n        return self.operands\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize by flattening nested Or expressions.\n\n        Flattens nested Or operations into a single flat Or with all clauses\n        at the same level. For example: Or(a, Or(b, c)) \u2192 Or(a, b, c).\n        Also canonicalizes all operands recursively.\n\n        Returns:\n            Expr: Canonical form of the Or expression. If only one operand\n                  remains after canonicalization, returns that operand directly.\n        \"\"\"\n        operands = []\n\n        for operand in self.operands:\n            canonicalized = operand.canonicalize()\n            if isinstance(canonicalized, Or):\n                # Flatten nested Or: Or(a, Or(b, c)) -&gt; Or(a, b, c)\n                operands.extend(canonicalized.operands)\n            else:\n                operands.append(canonicalized)\n\n        # Return simplified Or expression\n        if len(operands) == 1:\n            return operands[0]\n        return Or(*operands)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Validate operand shapes and return result shape.\n\n        Checks that all operands have compatible (broadcastable) shapes. The Or\n        operation supports broadcasting, allowing mixing of scalars and vectors.\n\n        Returns:\n            tuple: Empty tuple () indicating a scalar result, as Or represents\n                   a single logical proposition\n\n        Raises:\n            ValueError: If fewer than two operands exist\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        if len(self.operands) &lt; 2:\n            raise ValueError(\"Or requires at least two operands\")\n\n        # Validate all operands and get their shapes\n        operand_shapes = [operand.check_shape() for operand in self.operands]\n\n        # For logical operations, all operands should be broadcastable\n        # This allows mixing scalars with vectors for element-wise operations\n        try:\n            result_shape = operand_shapes[0]\n            for shape in operand_shapes[1:]:\n                result_shape = np.broadcast_shapes(result_shape, shape)\n        except ValueError as e:\n            raise ValueError(f\"Or operands not broadcastable: {operand_shapes}\") from e\n\n        # Or produces a scalar result (like constraints)\n        return ()\n\n    def __repr__(self):\n        operands_repr = \" | \".join(repr(op) for op in self.operands)\n        return f\"Or({operands_repr})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Or.__init__","title":"<code>__init__(*operands)</code>","text":"<p>Initialize a logical OR operation.</p> <p>Parameters:</p> Name Type Description Default <code>*operands</code> <p>Two or more expressions to combine with logical OR.       Each operand typically represents a constraint or condition.</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two operands are provided</p> Source code in <code>openscvx/symbolic/expr/stl.py</code> <pre><code>def __init__(self, *operands):\n    \"\"\"Initialize a logical OR operation.\n\n    Args:\n        *operands: Two or more expressions to combine with logical OR.\n                  Each operand typically represents a constraint or condition.\n\n    Raises:\n        ValueError: If fewer than two operands are provided\n    \"\"\"\n    if len(operands) &lt; 2:\n        raise ValueError(\"Or requires at least two operands\")\n    self.operands = [to_expr(op) for op in operands]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Or.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize by flattening nested Or expressions.</p> <p>Flattens nested Or operations into a single flat Or with all clauses at the same level. For example: Or(a, Or(b, c)) \u2192 Or(a, b, c). Also canonicalizes all operands recursively.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the Or expression. If only one operand   remains after canonicalization, returns that operand directly.</p> Source code in <code>openscvx/symbolic/expr/stl.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize by flattening nested Or expressions.\n\n    Flattens nested Or operations into a single flat Or with all clauses\n    at the same level. For example: Or(a, Or(b, c)) \u2192 Or(a, b, c).\n    Also canonicalizes all operands recursively.\n\n    Returns:\n        Expr: Canonical form of the Or expression. If only one operand\n              remains after canonicalization, returns that operand directly.\n    \"\"\"\n    operands = []\n\n    for operand in self.operands:\n        canonicalized = operand.canonicalize()\n        if isinstance(canonicalized, Or):\n            # Flatten nested Or: Or(a, Or(b, c)) -&gt; Or(a, b, c)\n            operands.extend(canonicalized.operands)\n        else:\n            operands.append(canonicalized)\n\n    # Return simplified Or expression\n    if len(operands) == 1:\n        return operands[0]\n    return Or(*operands)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Or.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate operand shapes and return result shape.</p> <p>Checks that all operands have compatible (broadcastable) shapes. The Or operation supports broadcasting, allowing mixing of scalars and vectors.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () indicating a scalar result, as Or represents    a single logical proposition</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two operands exist</p> <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/stl.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Validate operand shapes and return result shape.\n\n    Checks that all operands have compatible (broadcastable) shapes. The Or\n    operation supports broadcasting, allowing mixing of scalars and vectors.\n\n    Returns:\n        tuple: Empty tuple () indicating a scalar result, as Or represents\n               a single logical proposition\n\n    Raises:\n        ValueError: If fewer than two operands exist\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    if len(self.operands) &lt; 2:\n        raise ValueError(\"Or requires at least two operands\")\n\n    # Validate all operands and get their shapes\n    operand_shapes = [operand.check_shape() for operand in self.operands]\n\n    # For logical operations, all operands should be broadcastable\n    # This allows mixing scalars with vectors for element-wise operations\n    try:\n        result_shape = operand_shapes[0]\n        for shape in operand_shapes[1:]:\n            result_shape = np.broadcast_shapes(result_shape, shape)\n    except ValueError as e:\n        raise ValueError(f\"Or operands not broadcastable: {operand_shapes}\") from e\n\n    # Or produces a scalar result (like constraints)\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Parameter","title":"<code>Parameter</code>","text":"<p>               Bases: <code>Leaf</code></p> <p>Parameter that can be changed at runtime without recompilation.</p> <p>Parameters are symbolic variables with initial values that can be updated through the problem's parameter dictionary. They allow for efficient parameter sweeps without needing to recompile the optimization problem.</p> Example <p>obs_center = ox.Parameter(\"obs_center\", shape=(3,), value=np.array([1.0, 0.0, 0.0]))</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class Parameter(Leaf):\n    \"\"\"Parameter that can be changed at runtime without recompilation.\n\n    Parameters are symbolic variables with initial values that can be updated\n    through the problem's parameter dictionary. They allow for efficient\n    parameter sweeps without needing to recompile the optimization problem.\n\n    Example:\n        obs_center = ox.Parameter(\"obs_center\", shape=(3,), value=np.array([1.0, 0.0, 0.0]))\n        # Later: problem.parameters[\"obs_center\"] = new_value\n    \"\"\"\n\n    def __init__(self, name: str, shape: tuple = (), value=None):\n        \"\"\"Initialize a Parameter node.\n\n        Args:\n            name (str): Name identifier for the parameter\n            shape (tuple): Shape of the parameter (default: scalar)\n            value: Initial value for the parameter (required)\n        \"\"\"\n        super().__init__(name, shape)\n        if value is None:\n            raise ValueError(f\"Parameter '{name}' requires an initial value\")\n        self.value = np.asarray(value, dtype=float)\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Parameter by its shape only (value-invariant).\n\n        Parameters are hashed by shape only, not by value. This allows the same\n        compiled solver to be reused across parameter sweeps - only the structure\n        matters for compilation, not the actual values.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Parameter\")\n        hasher.update(str(self._shape).encode())\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Parameter--later-problemparametersobs_center-new_value","title":"Later: problem.parameters[\"obs_center\"] = new_value","text":""},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Parameter.__init__","title":"<code>__init__(name: str, shape: tuple = (), value=None)</code>","text":"<p>Initialize a Parameter node.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name identifier for the parameter</p> required <code>shape</code> <code>tuple</code> <p>Shape of the parameter (default: scalar)</p> <code>()</code> <code>value</code> <p>Initial value for the parameter (required)</p> <code>None</code> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def __init__(self, name: str, shape: tuple = (), value=None):\n    \"\"\"Initialize a Parameter node.\n\n    Args:\n        name (str): Name identifier for the parameter\n        shape (tuple): Shape of the parameter (default: scalar)\n        value: Initial value for the parameter (required)\n    \"\"\"\n    super().__init__(name, shape)\n    if value is None:\n        raise ValueError(f\"Parameter '{name}' requires an initial value\")\n    self.value = np.asarray(value, dtype=float)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.PositivePart","title":"<code>PositivePart</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Positive part function for symbolic expressions.</p> <p>Computes max(x, 0) element-wise, effectively zeroing out negative values while preserving positive values. This is also known as the ReLU (Rectified Linear Unit) function and is commonly used as a penalty function building block in optimization.</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Expression to apply positive part function to</p> Example <p>Define a PositivePart expression:</p> <pre><code>constraint_violation = x - 10\npenalty = PositivePart(constraint_violation)  # Penalizes x &gt; 10\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class PositivePart(Expr):\n    \"\"\"Positive part function for symbolic expressions.\n\n    Computes max(x, 0) element-wise, effectively zeroing out negative values\n    while preserving positive values. This is also known as the ReLU (Rectified\n    Linear Unit) function and is commonly used as a penalty function building\n    block in optimization.\n\n    Attributes:\n        x: Expression to apply positive part function to\n\n    Example:\n        Define a PositivePart expression:\n\n            constraint_violation = x - 10\n            penalty = PositivePart(constraint_violation)  # Penalizes x &gt; 10\n    \"\"\"\n\n    def __init__(self, x):\n        \"\"\"Initialize a positive part operation.\n\n        Args:\n            x: Expression to apply positive part function to\n        \"\"\"\n        self.x = to_expr(x)\n\n    def children(self):\n        return [self.x]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        x = self.x.canonicalize()\n        return PositivePart(x)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"pos(x) = max(x, 0) preserves the shape of x.\"\"\"\n        return self.x.check_shape()\n\n    def __repr__(self):\n        return f\"pos({self.x!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.PositivePart.__init__","title":"<code>__init__(x)</code>","text":"<p>Initialize a positive part operation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>Expression to apply positive part function to</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, x):\n    \"\"\"Initialize a positive part operation.\n\n    Args:\n        x: Expression to apply positive part function to\n    \"\"\"\n    self.x = to_expr(x)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.PositivePart.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>pos(x) = max(x, 0) preserves the shape of x.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"pos(x) = max(x, 0) preserves the shape of x.\"\"\"\n    return self.x.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Power","title":"<code>Power</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise power operation for symbolic expressions.</p> <p>Represents element-wise exponentiation (base ** exponent). Supports broadcasting following NumPy rules. Can be created using the ** operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>base</code> <p>Base expression</p> <code>exponent</code> <p>Exponent expression</p> Example <p>Define a Power expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = x ** 2  # Creates Power(x, Constant(2))\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Power(Expr):\n    \"\"\"Element-wise power operation for symbolic expressions.\n\n    Represents element-wise exponentiation (base ** exponent). Supports broadcasting\n    following NumPy rules. Can be created using the ** operator on Expr objects.\n\n    Attributes:\n        base: Base expression\n        exponent: Exponent expression\n\n    Example:\n        Define a Power expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = x ** 2  # Creates Power(x, Constant(2))\n    \"\"\"\n\n    def __init__(self, base, exponent):\n        \"\"\"Initialize a power operation.\n\n        Args:\n            base: Base expression\n            exponent: Exponent expression\n        \"\"\"\n        self.base = to_expr(base)\n        self.exponent = to_expr(exponent)\n\n    def children(self):\n        return [self.base, self.exponent]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize power by canonicalizing base and exponent.\n\n        Returns:\n            Expr: Canonical form of the power expression\n        \"\"\"\n        base = self.base.canonicalize()\n        exponent = self.exponent.canonicalize()\n        return Power(base, exponent)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Power shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        return f\"({self.base!r})**({self.exponent!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Power.__init__","title":"<code>__init__(base, exponent)</code>","text":"<p>Initialize a power operation.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <p>Base expression</p> required <code>exponent</code> <p>Exponent expression</p> required Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def __init__(self, base, exponent):\n    \"\"\"Initialize a power operation.\n\n    Args:\n        base: Base expression\n        exponent: Exponent expression\n    \"\"\"\n    self.base = to_expr(base)\n    self.exponent = to_expr(exponent)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Power.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize power by canonicalizing base and exponent.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the power expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize power by canonicalizing base and exponent.\n\n    Returns:\n        Expr: Canonical form of the power expression\n    \"\"\"\n    base = self.base.canonicalize()\n    exponent = self.exponent.canonicalize()\n    return Power(base, exponent)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.QDCM","title":"<code>QDCM</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Quaternion to Direction Cosine Matrix (DCM) conversion.</p> <p>Converts a unit quaternion representation to a 3x3 direction cosine matrix (also known as a rotation matrix). This operation is commonly used in 6-DOF spacecraft dynamics, aircraft simulation, and robotics applications.</p> <p>The quaternion is expected in scalar-last format: [qx, qy, qz, qw] where qw is the scalar component. The resulting DCM can be used to transform vectors from one reference frame to another.</p> <p>Attributes:</p> Name Type Description <code>q</code> <p>Quaternion expression with shape (4,)</p> Example <p>Use the QDCM to rotate a vector:</p> <pre><code>import openscvx as ox\nq = ox.State(\"q\", shape=(4,))\ndcm = ox.QDCM(q)  # Creates rotation matrix, shape (3, 3)\nv_body = ox.Variable(\"v_body\", shape=(3,))\nv_inertial = dcm @ v_body\n</code></pre> Note <p>The input quaternion does not need to be normalized; the implementation automatically handles normalization during evaluation.</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>class QDCM(Expr):\n    \"\"\"Quaternion to Direction Cosine Matrix (DCM) conversion.\n\n    Converts a unit quaternion representation to a 3x3 direction cosine matrix\n    (also known as a rotation matrix). This operation is commonly used in 6-DOF\n    spacecraft dynamics, aircraft simulation, and robotics applications.\n\n    The quaternion is expected in scalar-last format: [qx, qy, qz, qw] where\n    qw is the scalar component. The resulting DCM can be used to transform vectors\n    from one reference frame to another.\n\n    Attributes:\n        q: Quaternion expression with shape (4,)\n\n    Example:\n        Use the QDCM to rotate a vector:\n\n            import openscvx as ox\n            q = ox.State(\"q\", shape=(4,))\n            dcm = ox.QDCM(q)  # Creates rotation matrix, shape (3, 3)\n            v_body = ox.Variable(\"v_body\", shape=(3,))\n            v_inertial = dcm @ v_body\n\n    Note:\n        The input quaternion does not need to be normalized; the implementation\n        automatically handles normalization during evaluation.\n    \"\"\"\n\n    def __init__(self, q):\n        \"\"\"Initialize a quaternion to DCM conversion.\n\n        Args:\n            q: Quaternion expression with shape (4,) in [qx, qy, qz, qw] format\n        \"\"\"\n        self.q = to_expr(q)\n\n    def children(self):\n        return [self.q]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        q = self.q.canonicalize()\n        return QDCM(q)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a quaternion and return DCM shape.\n\n        Returns:\n            tuple: Shape (3, 3) for the resulting direction cosine matrix\n\n        Raises:\n            ValueError: If quaternion does not have shape (4,)\n        \"\"\"\n        q_shape = self.q.check_shape()\n        if q_shape != (4,):\n            raise ValueError(f\"QDCM expects quaternion with shape (4,), got {q_shape}\")\n        return (3, 3)\n\n    def __repr__(self):\n        return f\"qdcm({self.q!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.QDCM.__init__","title":"<code>__init__(q)</code>","text":"<p>Initialize a quaternion to DCM conversion.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <p>Quaternion expression with shape (4,) in [qx, qy, qz, qw] format</p> required Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>def __init__(self, q):\n    \"\"\"Initialize a quaternion to DCM conversion.\n\n    Args:\n        q: Quaternion expression with shape (4,) in [qx, qy, qz, qw] format\n    \"\"\"\n    self.q = to_expr(q)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.QDCM.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a quaternion and return DCM shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (3, 3) for the resulting direction cosine matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If quaternion does not have shape (4,)</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a quaternion and return DCM shape.\n\n    Returns:\n        tuple: Shape (3, 3) for the resulting direction cosine matrix\n\n    Raises:\n        ValueError: If quaternion does not have shape (4,)\n    \"\"\"\n    q_shape = self.q.check_shape()\n    if q_shape != (4,):\n        raise ValueError(f\"QDCM expects quaternion with shape (4,), got {q_shape}\")\n    return (3, 3)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SE3Adjoint","title":"<code>SE3Adjoint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>SE(3) Adjoint representation Ad_T for transforming twists between frames.</p> <p>Computes the 6\u00d76 adjoint matrix Ad_T that transforms twists from one coordinate frame to another. Given a transformation T_ab from frame A to frame B, the adjoint transforms a twist expressed in frame A to frame B:</p> <pre><code>\u03be_b = Ad_{T_ab} @ \u03be_a\n</code></pre> <p>For SE(3), given T with rotation R and translation p:</p> <pre><code>Ad_T = [ R      0   ]\n       [ [p]\u00d7R  R   ]\n</code></pre> <p>where [p]\u00d7 is the 3\u00d73 skew-symmetric matrix of p.</p> <p>This is essential for:</p> <ul> <li>Velocity propagation through kinematic chains</li> <li>Computing geometric Jacobians for manipulators</li> <li>Recursive Newton-Euler dynamics algorithms</li> </ul> <p>Attributes:</p> Name Type Description <code>transform</code> <p>4\u00d74 homogeneous transformation matrix</p> Example <p>Transform a body twist to the world frame::</p> <pre><code>import openscvx as ox\n\nT_world_body = forward_kinematics(q)  # 4\u00d74 transform\ntwist_body = ox.State(\"twist_body\", shape=(6,))\n\n# Transform twist to world frame\nAd_T = ox.lie.SE3Adjoint(T_world_body)  # 6\u00d76 matrix\ntwist_world = Ad_T @ twist_body\n</code></pre> <p>Compute geometric Jacobian columns::</p> <pre><code># Each column of the geometric Jacobian is Ad_{T_0i} @ \u03be_i\nJ_col_i = ox.lie.SE3Adjoint(T_0_to_i) @ screw_axis_i\n</code></pre> Note <p>The adjoint satisfies: Ad_{T1 @ T2} = Ad_{T1} @ Ad_{T2}</p> See Also <ul> <li>SE3AdjointDual: For transforming wrenches between frames</li> <li>Adjoint: The small adjoint (Lie bracket) for twist-on-twist action</li> </ul> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>class SE3Adjoint(Expr):\n    \"\"\"SE(3) Adjoint representation Ad_T for transforming twists between frames.\n\n    Computes the 6\u00d76 adjoint matrix Ad_T that transforms twists from one\n    coordinate frame to another. Given a transformation T_ab from frame A to\n    frame B, the adjoint transforms a twist expressed in frame A to frame B:\n\n        \u03be_b = Ad_{T_ab} @ \u03be_a\n\n    For SE(3), given T with rotation R and translation p:\n\n        Ad_T = [ R      0   ]\n               [ [p]\u00d7R  R   ]\n\n    where [p]\u00d7 is the 3\u00d73 skew-symmetric matrix of p.\n\n    This is essential for:\n\n    - Velocity propagation through kinematic chains\n    - Computing geometric Jacobians for manipulators\n    - Recursive Newton-Euler dynamics algorithms\n\n    Attributes:\n        transform: 4\u00d74 homogeneous transformation matrix\n\n    Example:\n        Transform a body twist to the world frame::\n\n            import openscvx as ox\n\n            T_world_body = forward_kinematics(q)  # 4\u00d74 transform\n            twist_body = ox.State(\"twist_body\", shape=(6,))\n\n            # Transform twist to world frame\n            Ad_T = ox.lie.SE3Adjoint(T_world_body)  # 6\u00d76 matrix\n            twist_world = Ad_T @ twist_body\n\n        Compute geometric Jacobian columns::\n\n            # Each column of the geometric Jacobian is Ad_{T_0i} @ \u03be_i\n            J_col_i = ox.lie.SE3Adjoint(T_0_to_i) @ screw_axis_i\n\n    Note:\n        The adjoint satisfies: Ad_{T1 @ T2} = Ad_{T1} @ Ad_{T2}\n\n    See Also:\n        - SE3AdjointDual: For transforming wrenches between frames\n        - Adjoint: The small adjoint (Lie bracket) for twist-on-twist action\n    \"\"\"\n\n    def __init__(self, transform):\n        \"\"\"Initialize SE3 Adjoint operator.\n\n        Args:\n            transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n        \"\"\"\n        self.transform = to_expr(transform)\n\n    def children(self):\n        return [self.transform]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        transform = self.transform.canonicalize()\n        return SE3Adjoint(transform)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 4\u00d74 matrix and return output shape.\n\n        Returns:\n            tuple: Shape (6, 6) for the adjoint matrix\n\n        Raises:\n            ValueError: If transform does not have shape (4, 4)\n        \"\"\"\n        transform_shape = self.transform.check_shape()\n        if transform_shape != (4, 4):\n            raise ValueError(\n                f\"SE3Adjoint expects transform with shape (4, 4), got {transform_shape}\"\n            )\n        return (6, 6)\n\n    def __repr__(self):\n        return f\"Ad({self.transform!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SE3Adjoint.__init__","title":"<code>__init__(transform)</code>","text":"<p>Initialize SE3 Adjoint operator.</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <p>4\u00d74 homogeneous transformation matrix with shape (4, 4)</p> required Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def __init__(self, transform):\n    \"\"\"Initialize SE3 Adjoint operator.\n\n    Args:\n        transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n    \"\"\"\n    self.transform = to_expr(transform)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SE3Adjoint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 4\u00d74 matrix and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (6, 6) for the adjoint matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If transform does not have shape (4, 4)</p> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 4\u00d74 matrix and return output shape.\n\n    Returns:\n        tuple: Shape (6, 6) for the adjoint matrix\n\n    Raises:\n        ValueError: If transform does not have shape (4, 4)\n    \"\"\"\n    transform_shape = self.transform.check_shape()\n    if transform_shape != (4, 4):\n        raise ValueError(\n            f\"SE3Adjoint expects transform with shape (4, 4), got {transform_shape}\"\n        )\n    return (6, 6)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SE3AdjointDual","title":"<code>SE3AdjointDual</code>","text":"<p>               Bases: <code>Expr</code></p> <p>SE(3) coadjoint representation Ad*_T for transforming wrenches between frames.</p> <p>Computes the 6\u00d76 coadjoint matrix Ad*_T that transforms wrenches from one coordinate frame to another. Given a transformation T_ab from frame A to frame B, the coadjoint transforms a wrench expressed in frame B to frame A:</p> <pre><code>F_a = Ad*_{T_ab} @ F_b\n</code></pre> <p>For SE(3), given T with rotation R and translation p:</p> <pre><code>Ad*_T = [ R     [p]\u00d7R ]\n        [ 0       R   ]\n</code></pre> <p>This is the transpose-inverse of Ad_T: Ad*_T = (Ad_T)^{-T}</p> <p>This is essential for:</p> <ul> <li>Force/torque propagation in dynamics</li> <li>Transforming wrenches between end-effector and base frames</li> <li>Recursive Newton-Euler dynamics algorithms</li> </ul> <p>Attributes:</p> Name Type Description <code>transform</code> <p>4\u00d74 homogeneous transformation matrix</p> Example <p>Transform a wrench from end-effector to base frame::</p> <pre><code>import openscvx as ox\n\nT_base_ee = forward_kinematics(q)  # 4\u00d74 transform\nwrench_ee = ox.Control(\"wrench_ee\", shape=(6,))\n\n# Transform wrench to base frame\nAd_star_T = ox.lie.SE3AdjointDual(T_base_ee)  # 6\u00d76 matrix\nwrench_base = Ad_star_T @ wrench_ee\n</code></pre> Note <p>The coadjoint is related to the adjoint by: Ad*_T = (Ad_T)^{-T}</p> See Also <ul> <li>SE3Adjoint: For transforming twists between frames</li> <li>AdjointDual: The small coadjoint for Coriolis/centrifugal forces</li> </ul> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>class SE3AdjointDual(Expr):\n    \"\"\"SE(3) coadjoint representation Ad*_T for transforming wrenches between frames.\n\n    Computes the 6\u00d76 coadjoint matrix Ad*_T that transforms wrenches from one\n    coordinate frame to another. Given a transformation T_ab from frame A to\n    frame B, the coadjoint transforms a wrench expressed in frame B to frame A:\n\n        F_a = Ad*_{T_ab} @ F_b\n\n    For SE(3), given T with rotation R and translation p:\n\n        Ad*_T = [ R     [p]\u00d7R ]\n                [ 0       R   ]\n\n    This is the transpose-inverse of Ad_T: Ad*_T = (Ad_T)^{-T}\n\n    This is essential for:\n\n    - Force/torque propagation in dynamics\n    - Transforming wrenches between end-effector and base frames\n    - Recursive Newton-Euler dynamics algorithms\n\n    Attributes:\n        transform: 4\u00d74 homogeneous transformation matrix\n\n    Example:\n        Transform a wrench from end-effector to base frame::\n\n            import openscvx as ox\n\n            T_base_ee = forward_kinematics(q)  # 4\u00d74 transform\n            wrench_ee = ox.Control(\"wrench_ee\", shape=(6,))\n\n            # Transform wrench to base frame\n            Ad_star_T = ox.lie.SE3AdjointDual(T_base_ee)  # 6\u00d76 matrix\n            wrench_base = Ad_star_T @ wrench_ee\n\n    Note:\n        The coadjoint is related to the adjoint by: Ad*_T = (Ad_T)^{-T}\n\n    See Also:\n        - SE3Adjoint: For transforming twists between frames\n        - AdjointDual: The small coadjoint for Coriolis/centrifugal forces\n    \"\"\"\n\n    def __init__(self, transform):\n        \"\"\"Initialize SE3 coadjoint operator.\n\n        Args:\n            transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n        \"\"\"\n        self.transform = to_expr(transform)\n\n    def children(self):\n        return [self.transform]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        transform = self.transform.canonicalize()\n        return SE3AdjointDual(transform)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 4\u00d74 matrix and return output shape.\n\n        Returns:\n            tuple: Shape (6, 6) for the coadjoint matrix\n\n        Raises:\n            ValueError: If transform does not have shape (4, 4)\n        \"\"\"\n        transform_shape = self.transform.check_shape()\n        if transform_shape != (4, 4):\n            raise ValueError(\n                f\"SE3AdjointDual expects transform with shape (4, 4), got {transform_shape}\"\n            )\n        return (6, 6)\n\n    def __repr__(self):\n        return f\"Ad_dual({self.transform!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SE3AdjointDual.__init__","title":"<code>__init__(transform)</code>","text":"<p>Initialize SE3 coadjoint operator.</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <p>4\u00d74 homogeneous transformation matrix with shape (4, 4)</p> required Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def __init__(self, transform):\n    \"\"\"Initialize SE3 coadjoint operator.\n\n    Args:\n        transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n    \"\"\"\n    self.transform = to_expr(transform)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SE3AdjointDual.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 4\u00d74 matrix and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (6, 6) for the coadjoint matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If transform does not have shape (4, 4)</p> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 4\u00d74 matrix and return output shape.\n\n    Returns:\n        tuple: Shape (6, 6) for the coadjoint matrix\n\n    Raises:\n        ValueError: If transform does not have shape (4, 4)\n    \"\"\"\n    transform_shape = self.transform.check_shape()\n    if transform_shape != (4, 4):\n        raise ValueError(\n            f\"SE3AdjointDual expects transform with shape (4, 4), got {transform_shape}\"\n        )\n    return (6, 6)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SE3Exp","title":"<code>SE3Exp</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Exponential map from se(3) twist to SE(3) transformation matrix.</p> <p>Maps a 6D twist vector to a 4\u00d74 homogeneous transformation matrix. Uses jaxlie for numerically robust implementation with proper handling of small angles and translations.</p> <p>The twist \u03be = [v; \u03c9] follows the convention:</p> <ul> <li>v: 3D linear velocity component</li> <li>\u03c9: 3D angular velocity component</li> </ul> <p>This is the key operation for Product of Exponentials (PoE) forward kinematics in robotic manipulators.</p> <p>Attributes:</p> Name Type Description <code>twist</code> <p>6D twist vector [v; \u03c9] with shape (6,)</p> Example <p>Product of Exponentials forward kinematics::</p> <pre><code>import openscvx as ox\nimport numpy as np\n\n# Screw axis for revolute joint about z-axis at origin\nscrew_axis = np.array([0, 0, 0, 0, 0, 1])  # [v; \u03c9]\ntheta = ox.State(\"theta\", shape=(1,))\n\n# Joint transformation\nT = ox.lie.SE3Exp(ox.Constant(screw_axis) * theta)  # 4\u00d74 matrix\n\n# Chain multiple joints\nT_01 = ox.lie.SE3Exp(screw1 * q1)\nT_12 = ox.lie.SE3Exp(screw2 * q2)\nT_02 = T_01 @ T_12\n</code></pre> <p>Extract position from transformation::</p> <pre><code>T_ee = forward_kinematics(joint_angles)\np_ee = T_ee[:3, 3]  # End-effector position\n</code></pre> Note <p>The twist convention [v; \u03c9] matches jaxlie's SE3 tangent parameterization, so no reordering is performed.</p> See Also <ul> <li>SE3Log: Inverse operation (transformation matrix to twist)</li> <li>SO3Exp: Rotation-only exponential map</li> <li>AdjointDual: For dynamics computations with twists</li> </ul> Source code in <code>openscvx/symbolic/expr/lie/se3.py</code> <pre><code>class SE3Exp(Expr):\n    \"\"\"Exponential map from se(3) twist to SE(3) transformation matrix.\n\n    Maps a 6D twist vector to a 4\u00d74 homogeneous transformation matrix.\n    Uses jaxlie for numerically robust implementation with proper handling\n    of small angles and translations.\n\n    The twist \u03be = [v; \u03c9] follows the convention:\n\n    - v: 3D linear velocity component\n    - \u03c9: 3D angular velocity component\n\n    This is the key operation for Product of Exponentials (PoE) forward\n    kinematics in robotic manipulators.\n\n    Attributes:\n        twist: 6D twist vector [v; \u03c9] with shape (6,)\n\n    Example:\n        Product of Exponentials forward kinematics::\n\n            import openscvx as ox\n            import numpy as np\n\n            # Screw axis for revolute joint about z-axis at origin\n            screw_axis = np.array([0, 0, 0, 0, 0, 1])  # [v; \u03c9]\n            theta = ox.State(\"theta\", shape=(1,))\n\n            # Joint transformation\n            T = ox.lie.SE3Exp(ox.Constant(screw_axis) * theta)  # 4\u00d74 matrix\n\n            # Chain multiple joints\n            T_01 = ox.lie.SE3Exp(screw1 * q1)\n            T_12 = ox.lie.SE3Exp(screw2 * q2)\n            T_02 = T_01 @ T_12\n\n        Extract position from transformation::\n\n            T_ee = forward_kinematics(joint_angles)\n            p_ee = T_ee[:3, 3]  # End-effector position\n\n    Note:\n        The twist convention [v; \u03c9] matches jaxlie's SE3 tangent\n        parameterization, so no reordering is performed.\n\n    See Also:\n        - SE3Log: Inverse operation (transformation matrix to twist)\n        - SO3Exp: Rotation-only exponential map\n        - AdjointDual: For dynamics computations with twists\n    \"\"\"\n\n    def __init__(self, twist):\n        \"\"\"Initialize SE3 exponential map.\n\n        Args:\n            twist: 6D twist vector [v; \u03c9] with shape (6,)\n        \"\"\"\n        self.twist = to_expr(twist)\n\n    def children(self):\n        return [self.twist]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        twist = self.twist.canonicalize()\n        return SE3Exp(twist)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 6D vector and return output shape.\n\n        Returns:\n            tuple: Shape (4, 4) for the homogeneous transformation matrix\n\n        Raises:\n            ValueError: If twist does not have shape (6,)\n        \"\"\"\n        twist_shape = self.twist.check_shape()\n        if twist_shape != (6,):\n            raise ValueError(f\"SE3Exp expects twist with shape (6,), got {twist_shape}\")\n        return (4, 4)\n\n    def __repr__(self):\n        return f\"SE3Exp({self.twist!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SE3Exp.__init__","title":"<code>__init__(twist)</code>","text":"<p>Initialize SE3 exponential map.</p> <p>Parameters:</p> Name Type Description Default <code>twist</code> <p>6D twist vector [v; \u03c9] with shape (6,)</p> required Source code in <code>openscvx/symbolic/expr/lie/se3.py</code> <pre><code>def __init__(self, twist):\n    \"\"\"Initialize SE3 exponential map.\n\n    Args:\n        twist: 6D twist vector [v; \u03c9] with shape (6,)\n    \"\"\"\n    self.twist = to_expr(twist)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SE3Exp.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 6D vector and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (4, 4) for the homogeneous transformation matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If twist does not have shape (6,)</p> Source code in <code>openscvx/symbolic/expr/lie/se3.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 6D vector and return output shape.\n\n    Returns:\n        tuple: Shape (4, 4) for the homogeneous transformation matrix\n\n    Raises:\n        ValueError: If twist does not have shape (6,)\n    \"\"\"\n    twist_shape = self.twist.check_shape()\n    if twist_shape != (6,):\n        raise ValueError(f\"SE3Exp expects twist with shape (6,), got {twist_shape}\")\n    return (4, 4)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SE3Log","title":"<code>SE3Log</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Logarithm map from SE(3) transformation matrix to se(3) twist.</p> <p>Maps a 4\u00d74 homogeneous transformation matrix to a 6D twist vector. Uses jaxlie for numerically robust implementation.</p> <p>The output twist \u03be = [v; \u03c9] follows the convention:</p> <ul> <li>v: 3D linear component</li> <li>\u03c9: 3D angular component (rotation vector)</li> </ul> <p>This is useful for computing error metrics between poses in optimization.</p> <p>Attributes:</p> Name Type Description <code>transform</code> <p>4\u00d74 homogeneous transformation matrix with shape (4, 4)</p> Example <p>Compute pose error for trajectory optimization::</p> <pre><code>import openscvx as ox\n\nT_current = forward_kinematics(q)\nT_target = ox.Parameter(\"T_target\", shape=(4, 4), value=goal_pose)\n\n# Relative transformation\nT_error = ox.linalg.inv(T_target) @ T_current\n\n# Convert to twist for error metric\ntwist_error = ox.lie.SE3Log(T_error)\npose_cost = ox.linalg.Norm(twist_error) ** 2\n</code></pre> See Also <ul> <li>SE3Exp: Inverse operation (twist to transformation matrix)</li> <li>SO3Log: Rotation-only logarithm map</li> </ul> Source code in <code>openscvx/symbolic/expr/lie/se3.py</code> <pre><code>class SE3Log(Expr):\n    \"\"\"Logarithm map from SE(3) transformation matrix to se(3) twist.\n\n    Maps a 4\u00d74 homogeneous transformation matrix to a 6D twist vector.\n    Uses jaxlie for numerically robust implementation.\n\n    The output twist \u03be = [v; \u03c9] follows the convention:\n\n    - v: 3D linear component\n    - \u03c9: 3D angular component (rotation vector)\n\n    This is useful for computing error metrics between poses in optimization.\n\n    Attributes:\n        transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n\n    Example:\n        Compute pose error for trajectory optimization::\n\n            import openscvx as ox\n\n            T_current = forward_kinematics(q)\n            T_target = ox.Parameter(\"T_target\", shape=(4, 4), value=goal_pose)\n\n            # Relative transformation\n            T_error = ox.linalg.inv(T_target) @ T_current\n\n            # Convert to twist for error metric\n            twist_error = ox.lie.SE3Log(T_error)\n            pose_cost = ox.linalg.Norm(twist_error) ** 2\n\n    See Also:\n        - SE3Exp: Inverse operation (twist to transformation matrix)\n        - SO3Log: Rotation-only logarithm map\n    \"\"\"\n\n    def __init__(self, transform):\n        \"\"\"Initialize SE3 logarithm map.\n\n        Args:\n            transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n        \"\"\"\n        self.transform = to_expr(transform)\n\n    def children(self):\n        return [self.transform]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        transform = self.transform.canonicalize()\n        return SE3Log(transform)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 4\u00d74 matrix and return output shape.\n\n        Returns:\n            tuple: Shape (6,) for the twist vector\n\n        Raises:\n            ValueError: If transform does not have shape (4, 4)\n        \"\"\"\n        transform_shape = self.transform.check_shape()\n        if transform_shape != (4, 4):\n            raise ValueError(f\"SE3Log expects transform with shape (4, 4), got {transform_shape}\")\n        return (6,)\n\n    def __repr__(self):\n        return f\"SE3Log({self.transform!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SE3Log.__init__","title":"<code>__init__(transform)</code>","text":"<p>Initialize SE3 logarithm map.</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <p>4\u00d74 homogeneous transformation matrix with shape (4, 4)</p> required Source code in <code>openscvx/symbolic/expr/lie/se3.py</code> <pre><code>def __init__(self, transform):\n    \"\"\"Initialize SE3 logarithm map.\n\n    Args:\n        transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n    \"\"\"\n    self.transform = to_expr(transform)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SE3Log.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 4\u00d74 matrix and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (6,) for the twist vector</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If transform does not have shape (4, 4)</p> Source code in <code>openscvx/symbolic/expr/lie/se3.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 4\u00d74 matrix and return output shape.\n\n    Returns:\n        tuple: Shape (6,) for the twist vector\n\n    Raises:\n        ValueError: If transform does not have shape (4, 4)\n    \"\"\"\n    transform_shape = self.transform.check_shape()\n    if transform_shape != (4, 4):\n        raise ValueError(f\"SE3Log expects transform with shape (4, 4), got {transform_shape}\")\n    return (6,)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SO3Exp","title":"<code>SO3Exp</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Exponential map from so(3) to SO(3) rotation matrix.</p> <p>Maps a 3D rotation vector (axis-angle representation) to a 3\u00d73 rotation matrix using the Rodrigues formula. Uses jaxlie for numerically robust implementation with proper handling of small angles.</p> <p>The rotation vector \u03c9 has direction equal to the rotation axis and magnitude equal to the rotation angle in radians.</p> <p>Attributes:</p> Name Type Description <code>omega</code> <p>3D rotation vector with shape (3,)</p> Example <p>Create a rotation about the z-axis::</p> <pre><code>import openscvx as ox\nimport numpy as np\n\n# 90 degree rotation about z\nomega = ox.Constant(np.array([0, 0, np.pi/2]))\nR = ox.lie.SO3Exp(omega)  # 3\u00d73 rotation matrix\n</code></pre> <p>Parameterized rotation for optimization::</p> <pre><code>theta = ox.State(\"theta\", shape=(1,))\naxis = ox.Constant(np.array([0, 0, 1]))  # z-axis\nR = ox.lie.SO3Exp(axis * theta)\n</code></pre> See Also <ul> <li>SO3Log: Inverse operation (rotation matrix to rotation vector)</li> <li>SE3Exp: Full rigid body transformation including translation</li> </ul> Source code in <code>openscvx/symbolic/expr/lie/so3.py</code> <pre><code>class SO3Exp(Expr):\n    \"\"\"Exponential map from so(3) to SO(3) rotation matrix.\n\n    Maps a 3D rotation vector (axis-angle representation) to a 3\u00d73 rotation\n    matrix using the Rodrigues formula. Uses jaxlie for numerically robust\n    implementation with proper handling of small angles.\n\n    The rotation vector \u03c9 has direction equal to the rotation axis and\n    magnitude equal to the rotation angle in radians.\n\n    Attributes:\n        omega: 3D rotation vector with shape (3,)\n\n    Example:\n        Create a rotation about the z-axis::\n\n            import openscvx as ox\n            import numpy as np\n\n            # 90 degree rotation about z\n            omega = ox.Constant(np.array([0, 0, np.pi/2]))\n            R = ox.lie.SO3Exp(omega)  # 3\u00d73 rotation matrix\n\n        Parameterized rotation for optimization::\n\n            theta = ox.State(\"theta\", shape=(1,))\n            axis = ox.Constant(np.array([0, 0, 1]))  # z-axis\n            R = ox.lie.SO3Exp(axis * theta)\n\n    See Also:\n        - SO3Log: Inverse operation (rotation matrix to rotation vector)\n        - SE3Exp: Full rigid body transformation including translation\n    \"\"\"\n\n    def __init__(self, omega):\n        \"\"\"Initialize SO3 exponential map.\n\n        Args:\n            omega: 3D rotation vector (axis \u00d7 angle) with shape (3,)\n        \"\"\"\n        self.omega = to_expr(omega)\n\n    def children(self):\n        return [self.omega]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        omega = self.omega.canonicalize()\n        return SO3Exp(omega)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 3D vector and return output shape.\n\n        Returns:\n            tuple: Shape (3, 3) for the rotation matrix\n\n        Raises:\n            ValueError: If omega does not have shape (3,)\n        \"\"\"\n        omega_shape = self.omega.check_shape()\n        if omega_shape != (3,):\n            raise ValueError(f\"SO3Exp expects omega with shape (3,), got {omega_shape}\")\n        return (3, 3)\n\n    def __repr__(self):\n        return f\"SO3Exp({self.omega!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SO3Exp.__init__","title":"<code>__init__(omega)</code>","text":"<p>Initialize SO3 exponential map.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <p>3D rotation vector (axis \u00d7 angle) with shape (3,)</p> required Source code in <code>openscvx/symbolic/expr/lie/so3.py</code> <pre><code>def __init__(self, omega):\n    \"\"\"Initialize SO3 exponential map.\n\n    Args:\n        omega: 3D rotation vector (axis \u00d7 angle) with shape (3,)\n    \"\"\"\n    self.omega = to_expr(omega)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SO3Exp.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 3D vector and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (3, 3) for the rotation matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If omega does not have shape (3,)</p> Source code in <code>openscvx/symbolic/expr/lie/so3.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 3D vector and return output shape.\n\n    Returns:\n        tuple: Shape (3, 3) for the rotation matrix\n\n    Raises:\n        ValueError: If omega does not have shape (3,)\n    \"\"\"\n    omega_shape = self.omega.check_shape()\n    if omega_shape != (3,):\n        raise ValueError(f\"SO3Exp expects omega with shape (3,), got {omega_shape}\")\n    return (3, 3)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SO3Log","title":"<code>SO3Log</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Logarithm map from SO(3) rotation matrix to so(3) rotation vector.</p> <p>Maps a 3\u00d73 rotation matrix to a 3D rotation vector (axis-angle representation). Uses jaxlie for numerically robust implementation.</p> <p>The output rotation vector \u03c9 has direction equal to the rotation axis and magnitude equal to the rotation angle in radians.</p> <p>Attributes:</p> Name Type Description <code>rotation</code> <p>3\u00d73 rotation matrix with shape (3, 3)</p> Example <p>Extract rotation vector from a rotation matrix::</p> <pre><code>import openscvx as ox\n\nR = ox.State(\"R\", shape=(3, 3))  # Rotation matrix state\nomega = ox.lie.SO3Log(R)  # 3D rotation vector\n</code></pre> See Also <ul> <li>SO3Exp: Inverse operation (rotation vector to rotation matrix)</li> <li>SE3Log: Full rigid body transformation logarithm</li> </ul> Source code in <code>openscvx/symbolic/expr/lie/so3.py</code> <pre><code>class SO3Log(Expr):\n    \"\"\"Logarithm map from SO(3) rotation matrix to so(3) rotation vector.\n\n    Maps a 3\u00d73 rotation matrix to a 3D rotation vector (axis-angle\n    representation). Uses jaxlie for numerically robust implementation.\n\n    The output rotation vector \u03c9 has direction equal to the rotation axis\n    and magnitude equal to the rotation angle in radians.\n\n    Attributes:\n        rotation: 3\u00d73 rotation matrix with shape (3, 3)\n\n    Example:\n        Extract rotation vector from a rotation matrix::\n\n            import openscvx as ox\n\n            R = ox.State(\"R\", shape=(3, 3))  # Rotation matrix state\n            omega = ox.lie.SO3Log(R)  # 3D rotation vector\n\n    See Also:\n        - SO3Exp: Inverse operation (rotation vector to rotation matrix)\n        - SE3Log: Full rigid body transformation logarithm\n    \"\"\"\n\n    def __init__(self, rotation):\n        \"\"\"Initialize SO3 logarithm map.\n\n        Args:\n            rotation: 3\u00d73 rotation matrix with shape (3, 3)\n        \"\"\"\n        self.rotation = to_expr(rotation)\n\n    def children(self):\n        return [self.rotation]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        rotation = self.rotation.canonicalize()\n        return SO3Log(rotation)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 3\u00d73 matrix and return output shape.\n\n        Returns:\n            tuple: Shape (3,) for the rotation vector\n\n        Raises:\n            ValueError: If rotation does not have shape (3, 3)\n        \"\"\"\n        rotation_shape = self.rotation.check_shape()\n        if rotation_shape != (3, 3):\n            raise ValueError(f\"SO3Log expects rotation with shape (3, 3), got {rotation_shape}\")\n        return (3,)\n\n    def __repr__(self):\n        return f\"SO3Log({self.rotation!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SO3Log.__init__","title":"<code>__init__(rotation)</code>","text":"<p>Initialize SO3 logarithm map.</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <p>3\u00d73 rotation matrix with shape (3, 3)</p> required Source code in <code>openscvx/symbolic/expr/lie/so3.py</code> <pre><code>def __init__(self, rotation):\n    \"\"\"Initialize SO3 logarithm map.\n\n    Args:\n        rotation: 3\u00d73 rotation matrix with shape (3, 3)\n    \"\"\"\n    self.rotation = to_expr(rotation)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SO3Log.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 3\u00d73 matrix and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (3,) for the rotation vector</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If rotation does not have shape (3, 3)</p> Source code in <code>openscvx/symbolic/expr/lie/so3.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 3\u00d73 matrix and return output shape.\n\n    Returns:\n        tuple: Shape (3,) for the rotation vector\n\n    Raises:\n        ValueError: If rotation does not have shape (3, 3)\n    \"\"\"\n    rotation_shape = self.rotation.check_shape()\n    if rotation_shape != (3, 3):\n        raise ValueError(f\"SO3Log expects rotation with shape (3, 3), got {rotation_shape}\")\n    return (3,)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SSM","title":"<code>SSM</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Angular rate vector to 3x3 skew-symmetric matrix (cross product matrix).</p> <p>Constructs the 3x3 skew-symmetric matrix [\u03c9]x that represents the cross product operation. For any 3D vector v, the cross product \u03c9 x v can be computed as the matrix-vector product [\u03c9]x @ v.</p> The resulting matrix has the form <p>\u23a1  0  -\u03c9z   \u03c9y \u23a4 \u23a2 \u03c9z    0  -\u03c9x \u23a5 \u23a3-\u03c9y   \u03c9x    0 \u23a6</p> <p>This operation is widely used in: - Rigid body dynamics (angular momentum calculations) - DCM time derivatives: \u1e58 = [\u03c9]x @ R - Velocity kinematics in robotics - Coriolis and centrifugal acceleration terms</p> <p>Attributes:</p> Name Type Description <code>w</code> <p>Angular velocity or 3D vector expression with shape (3,)</p> Example <p>Use the SSM to compute the rotation matrix derivative:</p> <pre><code>import openscvx as ox\nomega = ox.Control(\"omega\", shape=(3,))\nR = ox.State(\"R\", shape=(3, 3))  # Direction cosine matrix\n# DCM time derivative\nR_dot = ox.SSM(omega) @ R\n</code></pre> Note <p>The skew-symmetric property ensures that [\u03c9]x\u1d40 = -[\u03c9]x, which is important for preserving orthogonality in DCM propagation.</p> See Also <p>SSMP: 4x4 skew-symmetric matrix for quaternion dynamics</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>class SSM(Expr):\n    \"\"\"Angular rate vector to 3x3 skew-symmetric matrix (cross product matrix).\n\n    Constructs the 3x3 skew-symmetric matrix [\u03c9]x that represents the cross\n    product operation. For any 3D vector v, the cross product \u03c9 x v can be\n    computed as the matrix-vector product [\u03c9]x @ v.\n\n    The resulting matrix has the form:\n        \u23a1  0  -\u03c9z   \u03c9y \u23a4\n        \u23a2 \u03c9z    0  -\u03c9x \u23a5\n        \u23a3-\u03c9y   \u03c9x    0 \u23a6\n\n    This operation is widely used in:\n    - Rigid body dynamics (angular momentum calculations)\n    - DCM time derivatives: \u1e58 = [\u03c9]x @ R\n    - Velocity kinematics in robotics\n    - Coriolis and centrifugal acceleration terms\n\n    Attributes:\n        w: Angular velocity or 3D vector expression with shape (3,)\n\n    Example:\n        Use the SSM to compute the rotation matrix derivative:\n\n            import openscvx as ox\n            omega = ox.Control(\"omega\", shape=(3,))\n            R = ox.State(\"R\", shape=(3, 3))  # Direction cosine matrix\n            # DCM time derivative\n            R_dot = ox.SSM(omega) @ R\n\n    Note:\n        The skew-symmetric property ensures that [\u03c9]x\u1d40 = -[\u03c9]x, which is\n        important for preserving orthogonality in DCM propagation.\n\n    See Also:\n        SSMP: 4x4 skew-symmetric matrix for quaternion dynamics\n    \"\"\"\n\n    def __init__(self, w):\n        \"\"\"Initialize a vector to skew-symmetric matrix conversion.\n\n        Args:\n            w: 3D vector expression with shape (3,) in [\u03c9x, \u03c9y, \u03c9z] format\n        \"\"\"\n        self.w = to_expr(w)\n\n    def children(self):\n        return [self.w]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        w = self.w.canonicalize()\n        return SSM(w)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 3D vector and return matrix shape.\n\n        Returns:\n            tuple: Shape (3, 3) for the resulting skew-symmetric matrix\n\n        Raises:\n            ValueError: If input vector does not have shape (3,)\n        \"\"\"\n        w_shape = self.w.check_shape()\n        if w_shape != (3,):\n            raise ValueError(f\"SSM expects angular velocity with shape (3,), got {w_shape}\")\n        return (3, 3)\n\n    def __repr__(self):\n        return f\"ssm({self.w!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SSM.__init__","title":"<code>__init__(w)</code>","text":"<p>Initialize a vector to skew-symmetric matrix conversion.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <p>3D vector expression with shape (3,) in [\u03c9x, \u03c9y, \u03c9z] format</p> required Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>def __init__(self, w):\n    \"\"\"Initialize a vector to skew-symmetric matrix conversion.\n\n    Args:\n        w: 3D vector expression with shape (3,) in [\u03c9x, \u03c9y, \u03c9z] format\n    \"\"\"\n    self.w = to_expr(w)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SSM.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 3D vector and return matrix shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (3, 3) for the resulting skew-symmetric matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input vector does not have shape (3,)</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 3D vector and return matrix shape.\n\n    Returns:\n        tuple: Shape (3, 3) for the resulting skew-symmetric matrix\n\n    Raises:\n        ValueError: If input vector does not have shape (3,)\n    \"\"\"\n    w_shape = self.w.check_shape()\n    if w_shape != (3,):\n        raise ValueError(f\"SSM expects angular velocity with shape (3,), got {w_shape}\")\n    return (3, 3)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SSMP","title":"<code>SSMP</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Angular rate to 4x4 skew-symmetric matrix for quaternion dynamics.</p> <p>Constructs the 4x4 skew-symmetric matrix \u03a9(\u03c9) used in quaternion kinematic differential equations. This matrix relates angular velocity to the time derivative of the quaternion:</p> <pre><code>q\u0307 = (1/2) * \u03a9(\u03c9) @ q\n</code></pre> The resulting matrix has the form <p>\u23a1  0   \u03c9z  -\u03c9y   \u03c9x \u23a4 \u23a2-\u03c9z    0   \u03c9x   \u03c9y \u23a5 \u23a2 \u03c9y  -\u03c9x    0   \u03c9z \u23a5 \u23a3-\u03c9x  -\u03c9y  -\u03c9z    0 \u23a6</p> <p>This is particularly useful for formulating quaternion-based attitude dynamics in spacecraft and aircraft trajectory optimization problems.</p> <p>Attributes:</p> Name Type Description <code>w</code> <p>Angular velocity vector expression with shape (3,)</p> Example <p>Use the SSMP to compute the quaternion derivative:</p> <pre><code>import openscvx as ox\nomega = ox.Control(\"omega\", shape=(3,))\nq = ox.State(\"q\", shape=(4,))\n# Quaternion kinematic equation\nq_dot = 0.5 * ox.SSMP(omega) @ q\n</code></pre> See Also <p>SSM: 3x3 skew-symmetric matrix for cross product operations</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>class SSMP(Expr):\n    \"\"\"Angular rate to 4x4 skew-symmetric matrix for quaternion dynamics.\n\n    Constructs the 4x4 skew-symmetric matrix \u03a9(\u03c9) used in quaternion kinematic\n    differential equations. This matrix relates angular velocity to the time\n    derivative of the quaternion:\n\n        q\u0307 = (1/2) * \u03a9(\u03c9) @ q\n\n    The resulting matrix has the form:\n        \u23a1  0   \u03c9z  -\u03c9y   \u03c9x \u23a4\n        \u23a2-\u03c9z    0   \u03c9x   \u03c9y \u23a5\n        \u23a2 \u03c9y  -\u03c9x    0   \u03c9z \u23a5\n        \u23a3-\u03c9x  -\u03c9y  -\u03c9z    0 \u23a6\n\n    This is particularly useful for formulating quaternion-based attitude\n    dynamics in spacecraft and aircraft trajectory optimization problems.\n\n    Attributes:\n        w: Angular velocity vector expression with shape (3,)\n\n    Example:\n        Use the SSMP to compute the quaternion derivative:\n\n            import openscvx as ox\n            omega = ox.Control(\"omega\", shape=(3,))\n            q = ox.State(\"q\", shape=(4,))\n            # Quaternion kinematic equation\n            q_dot = 0.5 * ox.SSMP(omega) @ q\n\n    See Also:\n        SSM: 3x3 skew-symmetric matrix for cross product operations\n    \"\"\"\n\n    def __init__(self, w):\n        \"\"\"Initialize an angular velocity to skew-symmetric matrix conversion.\n\n        Args:\n            w: Angular velocity vector expression with shape (3,) in [\u03c9x, \u03c9y, \u03c9z] format\n        \"\"\"\n        self.w = to_expr(w)\n\n    def children(self):\n        return [self.w]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        w = self.w.canonicalize()\n        return SSMP(w)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 3D angular velocity and return matrix shape.\n\n        Returns:\n            tuple: Shape (4, 4) for the resulting skew-symmetric matrix\n\n        Raises:\n            ValueError: If angular velocity does not have shape (3,)\n        \"\"\"\n        w_shape = self.w.check_shape()\n        if w_shape != (3,):\n            raise ValueError(f\"SSMP expects angular velocity with shape (3,), got {w_shape}\")\n        return (4, 4)\n\n    def __repr__(self):\n        return f\"ssmp({self.w!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SSMP.__init__","title":"<code>__init__(w)</code>","text":"<p>Initialize an angular velocity to skew-symmetric matrix conversion.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <p>Angular velocity vector expression with shape (3,) in [\u03c9x, \u03c9y, \u03c9z] format</p> required Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>def __init__(self, w):\n    \"\"\"Initialize an angular velocity to skew-symmetric matrix conversion.\n\n    Args:\n        w: Angular velocity vector expression with shape (3,) in [\u03c9x, \u03c9y, \u03c9z] format\n    \"\"\"\n    self.w = to_expr(w)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SSMP.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 3D angular velocity and return matrix shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (4, 4) for the resulting skew-symmetric matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If angular velocity does not have shape (3,)</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 3D angular velocity and return matrix shape.\n\n    Returns:\n        tuple: Shape (4, 4) for the resulting skew-symmetric matrix\n\n    Raises:\n        ValueError: If angular velocity does not have shape (3,)\n    \"\"\"\n    w_shape = self.w.check_shape()\n    if w_shape != (3,):\n        raise ValueError(f\"SSMP expects angular velocity with shape (3,), got {w_shape}\")\n    return (4, 4)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sin","title":"<code>Sin</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise sine function for symbolic expressions.</p> <p>Computes the sine of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply sine function to</p> Example <p>Define a Sin expression:</p> <pre><code>theta = Variable(\"theta\", shape=(3,))\nsin_theta = Sin(theta)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Sin(Expr):\n    \"\"\"Element-wise sine function for symbolic expressions.\n\n    Computes the sine of each element in the operand. Preserves the shape\n    of the input expression.\n\n    Attributes:\n        operand: Expression to apply sine function to\n\n    Example:\n        Define a Sin expression:\n\n            theta = Variable(\"theta\", shape=(3,))\n            sin_theta = Sin(theta)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a sine operation.\n\n        Args:\n            operand: Expression to apply sine function to\n        \"\"\"\n        self.operand = operand\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Sin(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Sin preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"(sin({self.operand!r}))\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sin.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a sine operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to apply sine function to</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a sine operation.\n\n    Args:\n        operand: Expression to apply sine function to\n    \"\"\"\n    self.operand = operand\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sin.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Sin preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Sin preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SmoothReLU","title":"<code>SmoothReLU</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Smooth approximation to the ReLU (positive part) function.</p> <p>Computes a smooth, differentiable approximation to max(x, 0) using the formula: sqrt(max(x, 0)^2 + c^2) - c</p> <p>The parameter c controls the smoothness: smaller values give a sharper transition, while larger values produce a smoother approximation. As c approaches 0, this converges to the standard ReLU function.</p> <p>This is particularly useful in optimization contexts where smooth gradients are required, such as in penalty methods for constraint handling (CTCS).</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Expression to apply smooth ReLU to</p> <code>c</code> <p>Smoothing parameter (default: 1e-8)</p> Example <p>Define a smooth ReLU expression:</p> <pre><code>constraint_violation = x - 10\npenalty = SmoothReLU(constraint_violation, c=1e-6)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class SmoothReLU(Expr):\n    \"\"\"Smooth approximation to the ReLU (positive part) function.\n\n    Computes a smooth, differentiable approximation to max(x, 0) using the formula:\n    sqrt(max(x, 0)^2 + c^2) - c\n\n    The parameter c controls the smoothness: smaller values give a sharper\n    transition, while larger values produce a smoother approximation. As c\n    approaches 0, this converges to the standard ReLU function.\n\n    This is particularly useful in optimization contexts where smooth gradients\n    are required, such as in penalty methods for constraint handling (CTCS).\n\n    Attributes:\n        x: Expression to apply smooth ReLU to\n        c: Smoothing parameter (default: 1e-8)\n\n    Example:\n        Define a smooth ReLU expression:\n\n            constraint_violation = x - 10\n            penalty = SmoothReLU(constraint_violation, c=1e-6)\n    \"\"\"\n\n    def __init__(self, x, c: float = 1e-8):\n        \"\"\"Initialize a smooth ReLU operation.\n\n        Args:\n            x: Expression to apply smooth ReLU to\n            c: Smoothing parameter controlling transition sharpness (default: 1e-8)\n        \"\"\"\n        self.x = to_expr(x)\n        self.c = float(c)\n\n    def children(self):\n        return [self.x]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the operand but preserve c parameter.\"\"\"\n        x = self.x.canonicalize()\n        return SmoothReLU(x, c=self.c)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Smooth ReLU preserves the shape of x.\"\"\"\n        return self.x.check_shape()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash SmoothReLU including its c parameter.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"SmoothReLU\")\n        # Hash c as bytes\n        hasher.update(struct.pack(\"&gt;d\", self.c))\n        # Hash the operand\n        self.x._hash_into(hasher)\n\n    def __repr__(self):\n        return f\"smooth_relu({self.x!r}, c={self.c})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SmoothReLU.__init__","title":"<code>__init__(x, c: float = 1e-08)</code>","text":"<p>Initialize a smooth ReLU operation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>Expression to apply smooth ReLU to</p> required <code>c</code> <code>float</code> <p>Smoothing parameter controlling transition sharpness (default: 1e-8)</p> <code>1e-08</code> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, x, c: float = 1e-8):\n    \"\"\"Initialize a smooth ReLU operation.\n\n    Args:\n        x: Expression to apply smooth ReLU to\n        c: Smoothing parameter controlling transition sharpness (default: 1e-8)\n    \"\"\"\n    self.x = to_expr(x)\n    self.c = float(c)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SmoothReLU.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the operand but preserve c parameter.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the operand but preserve c parameter.\"\"\"\n    x = self.x.canonicalize()\n    return SmoothReLU(x, c=self.c)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.SmoothReLU.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Smooth ReLU preserves the shape of x.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Smooth ReLU preserves the shape of x.\"\"\"\n    return self.x.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sqrt","title":"<code>Sqrt</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise square root function for symbolic expressions.</p> <p>Computes the square root of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply square root to</p> Example <p>Define a Sqrt expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\nsqrt_x = Sqrt(x)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Sqrt(Expr):\n    \"\"\"Element-wise square root function for symbolic expressions.\n\n    Computes the square root of each element in the operand. Preserves the\n    shape of the input expression.\n\n    Attributes:\n        operand: Expression to apply square root to\n\n    Example:\n        Define a Sqrt expression:\n\n            x = Variable(\"x\", shape=(3,))\n            sqrt_x = Sqrt(x)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a square root operation.\n\n        Args:\n            operand: Expression to apply square root to\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Sqrt(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Sqrt preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"sqrt({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sqrt.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a square root operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to apply square root to</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a square root operation.\n\n    Args:\n        operand: Expression to apply square root to\n    \"\"\"\n    self.operand = to_expr(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sqrt.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Sqrt preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Sqrt preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Square","title":"<code>Square</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise square function for symbolic expressions.</p> <p>Computes the square (x^2) of each element in the operand. Preserves the shape of the input expression. This is more efficient than using Power(x, 2) for some optimization backends.</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Expression to square</p> Example <p>Define a Square expression:</p> <pre><code>v = Variable(\"v\", shape=(3,))\nv_squared = Square(v)  # Equivalent to v ** 2\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Square(Expr):\n    \"\"\"Element-wise square function for symbolic expressions.\n\n    Computes the square (x^2) of each element in the operand. Preserves the\n    shape of the input expression. This is more efficient than using Power(x, 2)\n    for some optimization backends.\n\n    Attributes:\n        x: Expression to square\n\n    Example:\n        Define a Square expression:\n\n            v = Variable(\"v\", shape=(3,))\n            v_squared = Square(v)  # Equivalent to v ** 2\n    \"\"\"\n\n    def __init__(self, x):\n        \"\"\"Initialize a square operation.\n\n        Args:\n            x: Expression to square\n        \"\"\"\n        self.x = to_expr(x)\n\n    def children(self):\n        return [self.x]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        x = self.x.canonicalize()\n        return Square(x)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"x^2 preserves the shape of x.\"\"\"\n        return self.x.check_shape()\n\n    def __repr__(self):\n        return f\"({self.x!r})^2\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Square.__init__","title":"<code>__init__(x)</code>","text":"<p>Initialize a square operation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>Expression to square</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, x):\n    \"\"\"Initialize a square operation.\n\n    Args:\n        x: Expression to square\n    \"\"\"\n    self.x = to_expr(x)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Square.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>x^2 preserves the shape of x.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"x^2 preserves the shape of x.\"\"\"\n    return self.x.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Stack","title":"<code>Stack</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Stack expressions vertically to create a higher-dimensional array.</p> <p>Stacks a list of expressions along a new first dimension. All input expressions must have the same shape. The result has shape (num_rows, *row_shape).</p> <p>This is similar to numpy.array([row1, row2, ...]) or jax.numpy.stack(rows, axis=0).</p> <p>Attributes:</p> Name Type Description <code>rows</code> <p>List of expressions to stack, each representing a \"row\"</p> Example <p>Leverage stack to combine expressions:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(3,))\nz = Variable(\"z\", shape=(3,))\nstacked = Stack([x, y, z])  # Creates shape (3, 3)\n# Equivalent to: [[x[0], x[1], x[2]],\n#                 [y[0], y[1], y[2]],\n#                 [z[0], z[1], z[2]]]\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Stack(Expr):\n    \"\"\"Stack expressions vertically to create a higher-dimensional array.\n\n    Stacks a list of expressions along a new first dimension. All input expressions\n    must have the same shape. The result has shape (num_rows, *row_shape).\n\n    This is similar to numpy.array([row1, row2, ...]) or jax.numpy.stack(rows, axis=0).\n\n    Attributes:\n        rows: List of expressions to stack, each representing a \"row\"\n\n    Example:\n        Leverage stack to combine expressions:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(3,))\n            z = Variable(\"z\", shape=(3,))\n            stacked = Stack([x, y, z])  # Creates shape (3, 3)\n            # Equivalent to: [[x[0], x[1], x[2]],\n            #                 [y[0], y[1], y[2]],\n            #                 [z[0], z[1], z[2]]]\n    \"\"\"\n\n    def __init__(self, rows):\n        \"\"\"Initialize a stack operation.\n\n        Args:\n            rows: List of expressions to stack along a new first dimension.\n                  All expressions must have the same shape.\n        \"\"\"\n        # rows should be a list of expressions representing each row\n        self.rows = [to_expr(row) for row in rows]\n\n    def children(self):\n        return self.rows\n\n    def canonicalize(self) -&gt; \"Expr\":\n        rows = [row.canonicalize() for row in self.rows]\n        return Stack(rows)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Stack creates a 2D matrix from 1D rows.\"\"\"\n        if not self.rows:\n            raise ValueError(\"Stack requires at least one row\")\n\n        # All rows should have the same shape\n        row_shapes = [row.check_shape() for row in self.rows]\n\n        # Verify all rows have the same shape\n        first_shape = row_shapes[0]\n        for i, shape in enumerate(row_shapes[1:], 1):\n            if shape != first_shape:\n                raise ValueError(\n                    f\"Stack row {i} has shape {shape}, but row 0 has shape {first_shape}\"\n                )\n\n        # Result shape is (num_rows, *row_shape)\n        return (len(self.rows),) + first_shape\n\n    def __repr__(self):\n        rows_repr = \", \".join(repr(row) for row in self.rows)\n        return f\"Stack([{rows_repr}])\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Stack.__init__","title":"<code>__init__(rows)</code>","text":"<p>Initialize a stack operation.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <p>List of expressions to stack along a new first dimension.   All expressions must have the same shape.</p> required Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def __init__(self, rows):\n    \"\"\"Initialize a stack operation.\n\n    Args:\n        rows: List of expressions to stack along a new first dimension.\n              All expressions must have the same shape.\n    \"\"\"\n    # rows should be a list of expressions representing each row\n    self.rows = [to_expr(row) for row in rows]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Stack.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Stack creates a 2D matrix from 1D rows.</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Stack creates a 2D matrix from 1D rows.\"\"\"\n    if not self.rows:\n        raise ValueError(\"Stack requires at least one row\")\n\n    # All rows should have the same shape\n    row_shapes = [row.check_shape() for row in self.rows]\n\n    # Verify all rows have the same shape\n    first_shape = row_shapes[0]\n    for i, shape in enumerate(row_shapes[1:], 1):\n        if shape != first_shape:\n            raise ValueError(\n                f\"Stack row {i} has shape {shape}, but row 0 has shape {first_shape}\"\n            )\n\n    # Result shape is (num_rows, *row_shape)\n    return (len(self.rows),) + first_shape\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.State","title":"<code>State</code>","text":"<p>               Bases: <code>Variable</code></p> <p>State variable with boundary conditions for trajectory optimization.</p> <p>State represents a dynamic state variable in a trajectory optimization problem. Unlike control inputs, states evolve according to dynamics constraints and can have boundary conditions specified at the initial and final time points. Like all Variables, States also support min/max bounds and initial trajectory guesses to help guide the optimization solver toward good solutions.</p> <p>States support four types of boundary conditions:</p> <ul> <li>fixed: State value is constrained to a specific value</li> <li>free: State value is optimized within the specified bounds</li> <li>minimize: Adds a term to the objective function to minimize the state value</li> <li>maximize: Adds a term to the objective function to maximize the state value</li> </ul> <p>Each element of a multi-dimensional state can have different boundary condition types, allowing for fine-grained control over the optimization.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name identifier for this state variable</p> <code>_shape</code> <code>tuple[int, ...]</code> <p>Shape of the state vector (typically 1D like (3,) for 3D position)</p> <code>_slice</code> <code>slice | None</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <code>ndarray | None</code> <p>Minimum bounds for state variables</p> <code>_max</code> <code>ndarray | None</code> <p>Maximum bounds for state variables</p> <code>_guess</code> <code>ndarray | None</code> <p>Initial trajectory guess</p> <code>_initial</code> <code>ndarray | None</code> <p>Initial state values with boundary condition types</p> <code>initial_type</code> <code>ndarray | None</code> <p>Array of boundary condition types for initial state</p> <code>_final</code> <code>ndarray | None</code> <p>Final state values with boundary condition types</p> <code>final_type</code> <code>ndarray | None</code> <p>Array of boundary condition types for final state</p> Example <p>Scalar time state with fixed initial time, minimize final time:</p> <pre><code>time = State(\"time\", (1,))\ntime.min = [0.0]\ntime.max = [10.0]\ntime.initial = [(\"fixed\", 0.0)]\ntime.final = [(\"minimize\", 5.0)]\n</code></pre> <p>3D position state with mixed boundary conditions:</p> <pre><code>pos = State(\"pos\", (3,))\npos.min = [0, 0, 10]\npos.max = [10, 10, 200]\npos.initial = [0, (\"free\", 1), 50]  # x fixed, y free, z fixed\npos.final = [10, (\"free\", 5), (\"maximize\", 150)]  # Maximize final altitude\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>class State(Variable):\n    \"\"\"State variable with boundary conditions for trajectory optimization.\n\n    State represents a dynamic state variable in a trajectory optimization problem.\n    Unlike control inputs, states evolve according to dynamics constraints and can\n    have boundary conditions specified at the initial and final time points.\n    Like all Variables, States also support min/max bounds and initial trajectory\n    guesses to help guide the optimization solver toward good solutions.\n\n    States support four types of boundary conditions:\n\n    - **fixed**: State value is constrained to a specific value\n    - **free**: State value is optimized within the specified bounds\n    - **minimize**: Adds a term to the objective function to minimize the state value\n    - **maximize**: Adds a term to the objective function to maximize the state value\n\n    Each element of a multi-dimensional state can have different boundary condition\n    types, allowing for fine-grained control over the optimization.\n\n    Attributes:\n        name (str): Unique name identifier for this state variable\n        _shape (tuple[int, ...]): Shape of the state vector (typically 1D like (3,) for 3D position)\n        _slice (slice | None): Internal slice information for variable indexing\n        _min (np.ndarray | None): Minimum bounds for state variables\n        _max (np.ndarray | None): Maximum bounds for state variables\n        _guess (np.ndarray | None): Initial trajectory guess\n        _initial (np.ndarray | None): Initial state values with boundary condition types\n        initial_type (np.ndarray | None): Array of boundary condition types for initial state\n        _final (np.ndarray | None): Final state values with boundary condition types\n        final_type (np.ndarray | None): Array of boundary condition types for final state\n\n    Example:\n        Scalar time state with fixed initial time, minimize final time:\n\n            time = State(\"time\", (1,))\n            time.min = [0.0]\n            time.max = [10.0]\n            time.initial = [(\"fixed\", 0.0)]\n            time.final = [(\"minimize\", 5.0)]\n\n        3D position state with mixed boundary conditions:\n\n            pos = State(\"pos\", (3,))\n            pos.min = [0, 0, 10]\n            pos.max = [10, 10, 200]\n            pos.initial = [0, (\"free\", 1), 50]  # x fixed, y free, z fixed\n            pos.final = [10, (\"free\", 5), (\"maximize\", 150)]  # Maximize final altitude\n    \"\"\"\n\n    def __init__(self, name, shape):\n        \"\"\"Initialize a State object.\n\n        Args:\n            name: Name identifier for the state variable\n            shape: Shape of the state vector (typically 1D tuple)\n        \"\"\"\n        super().__init__(name, shape)\n        self._initial = None\n        self.initial_type = None\n        self._final = None\n        self.final_type = None\n        self._scaling_min = None\n        self._scaling_max = None\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash State including boundary condition types.\n\n        Extends Variable._hash_into to include the structural metadata that\n        affects the compiled problem: boundary condition types (fixed, free,\n        minimize, maximize). Values are not hashed as they are runtime parameters.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        # Hash the base Variable attributes (class name, shape, slice)\n        super()._hash_into(hasher)\n        # Hash boundary condition types (these affect constraint structure)\n        if self.initial_type is not None:\n            hasher.update(b\"initial_type:\")\n            hasher.update(str(self.initial_type.tolist()).encode())\n        if self.final_type is not None:\n            hasher.update(b\"final_type:\")\n            hasher.update(str(self.final_type.tolist()).encode())\n\n    @property\n    def min(self):\n        \"\"\"Get the minimum bounds for the state variables.\n\n        Returns:\n            Array of minimum values for each state variable element.\n\n        Example:\n            Get lower bounds:\n\n                pos = State(\"pos\", (3,))\n                pos.min = [0, 0, 10]\n                print(pos.min)  # [0. 0. 10.]\n        \"\"\"\n        return self._min\n\n    @min.setter\n    def min(self, val):\n        \"\"\"Set the minimum bounds for the state variables.\n\n        Bounds are validated against any fixed initial/final conditions to ensure\n        consistency.\n\n        Args:\n            val: Array of minimum values, must match the state shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape, or if fixed\n                boundary conditions violate the bounds\n\n        Example:\n            Set lower bounds:\n\n                pos = State(\"pos\", (3,))\n                pos.min = [0, 0, 10]\n                pos.initial = [0, 5, 15]  # Must satisfy: 0&gt;=0, 5&gt;=0, 15&gt;=10\n        \"\"\"\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(f\"Min shape {val.shape} does not match State shape {self.shape}\")\n        self._min = val\n        self._check_bounds_against_initial_final()\n\n    @property\n    def max(self):\n        \"\"\"Get the maximum bounds for the state variables.\n\n        Returns:\n            Array of maximum values for each state variable element.\n\n        Example:\n            Get upper bounds:\n\n                vel = State(\"vel\", (3,))\n                vel.max = [10, 10, 5]\n                print(vel.max)  # [10. 10. 5.]\n        \"\"\"\n        return self._max\n\n    @max.setter\n    def max(self, val):\n        \"\"\"Set the maximum bounds for the state variables.\n\n        Bounds are validated against any fixed initial/final conditions to ensure\n        consistency.\n\n        Args:\n            val: Array of maximum values, must match the state shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape, or if fixed\n                boundary conditions violate the bounds\n\n        Example:\n            Set upper bounds:\n\n                vel = State(\"vel\", (3,))\n                vel.max = [10, 10, 5]\n                vel.final = [8, 9, 4]  # Must satisfy: 8&lt;=10, 9&lt;=10, 4&lt;=5\n        \"\"\"\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(f\"Max shape {val.shape} does not match State shape {self.shape}\")\n        self._max = val\n        self._check_bounds_against_initial_final()\n\n    def _check_bounds_against_initial_final(self):\n        \"\"\"Validate that fixed boundary conditions respect min/max bounds.\n\n        This internal method is automatically called when bounds or boundary\n        conditions are set to ensure consistency.\n\n        Raises:\n            ValueError: If any fixed initial or final value violates the min/max bounds\n        \"\"\"\n        for field_name, data, types in [\n            (\"initial\", self._initial, self.initial_type),\n            (\"final\", self._final, self.final_type),\n        ]:\n            if data is None or types is None:\n                continue\n            for i, val in np.ndenumerate(data):\n                if types[i] != \"Fix\":\n                    continue\n                min_i = self._min[i] if self._min is not None else -np.inf\n                max_i = self._max[i] if self._max is not None else np.inf\n                if val &lt; min_i:\n                    raise ValueError(\n                        f\"{field_name.capitalize()} Fixed value at index {i[0]} is lower then the \"\n                        f\"min: {val} &lt; {min_i}\"\n                    )\n                if val &gt; max_i:\n                    raise ValueError(\n                        f\"{field_name.capitalize()} Fixed value at index {i[0]} is greater then \"\n                        f\"the max: {val} &gt; {max_i}\"\n                    )\n\n    @property\n    def initial(self):\n        \"\"\"Get the initial state boundary condition values.\n\n        Returns:\n            Array of initial state values (regardless of boundary condition type),\n            or None if not set.\n\n        Note:\n            Use `initial_type` to see the boundary condition types for each element.\n\n        Example:\n            Get initial state boundary conditions:\n\n                x = State(\"x\", (2,))\n                x.initial = [0, (\"free\", 1)]\n                print(x.initial)  # [0. 1.]\n                print(x.initial_type)  # ['Fix' 'Free']\n        \"\"\"\n        return self._initial\n\n    @initial.setter\n    def initial(self, arr):\n        \"\"\"Set the initial state boundary conditions.\n\n        Each element can be specified as either a simple number (defaults to \"fixed\")\n        or a tuple of (type, value) where type specifies the boundary condition.\n\n        Args:\n            arr: Array-like of initial conditions. Each element can be:\n                - A number: Defaults to fixed boundary condition at that value\n                - A tuple (type, value): Where type is one of:\n                    - \"fixed\": Constrain state to this exact value\n                    - \"free\": Let optimizer choose within bounds, initialize at value\n                    - \"minimize\": Add objective term to minimize, initialize at value\n                    - \"maximize\": Add objective term to maximize, initialize at value\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape, if boundary\n                condition type is invalid, or if fixed values violate bounds\n\n        Example:\n            Set initial state boundary conditions:\n\n                pos = State(\"pos\", (3,))\n                pos.min = [0, 0, 0]\n                pos.max = [10, 10, 10]\n                # x fixed at 0, y free (starts at 5), z fixed at 2\n                pos.initial = [0, (\"free\", 5), 2]\n\n            Can also minimize/maximize boundary values:\n\n                time = State(\"t\", (1,))\n                time.initial = [(\"minimize\", 0)]  # Minimize initial time\n        \"\"\"\n        # Convert to list first to handle mixed types properly\n        if not isinstance(arr, (list, tuple)):\n            arr = np.asarray(arr)\n            if arr.shape != self.shape:\n                raise ValueError(f\"Shape mismatch: {arr.shape} != {self.shape}\")\n            arr = arr.tolist()\n\n        # Ensure we have the right number of elements\n        if len(arr) != self.shape[0]:\n            raise ValueError(f\"Length mismatch: got {len(arr)} elements, expected {self.shape[0]}\")\n\n        self._initial = np.zeros(self.shape, dtype=float)\n        self.initial_type = np.full(self.shape, \"Fix\", dtype=object)\n\n        for i, v in enumerate(arr):\n            if isinstance(v, tuple) and len(v) == 2:\n                # Tuple API: (type, value)\n                bc_type_str, bc_value = v\n                try:\n                    bc_type = BoundaryType(bc_type_str)  # Validates the string\n                except ValueError:\n                    valid_types = [t.value for t in BoundaryType]\n                    raise ValueError(\n                        f\"Invalid boundary condition type: {bc_type_str}. \"\n                        f\"Valid types are: {valid_types}\"\n                    )\n                self._initial[i] = float(bc_value)\n                self.initial_type[i] = bc_type.value.capitalize()\n            elif isinstance(v, (int, float, np.number)):\n                # Simple number defaults to fixed\n                self._initial[i] = float(v)\n                self.initial_type[i] = \"Fix\"\n            else:\n                raise ValueError(\n                    f\"Invalid boundary condition format: {v}. \"\n                    f\"Use a number (defaults to fixed) or tuple ('type', value) \"\n                    f\"where type is 'fixed', 'free', 'minimize', or 'maximize'.\"\n                )\n\n        self._check_bounds_against_initial_final()\n\n    @property\n    def final(self):\n        \"\"\"Get the final state boundary condition values.\n\n        Returns:\n            Array of final state values (regardless of boundary condition type),\n            or None if not set.\n\n        Note:\n            Use `final_type` to see the boundary condition types for each element.\n\n        Example:\n            Get final state boundary conditions:\n\n                x = State(\"x\", (2,))\n                x.final = [10, (\"minimize\", 0)]\n                print(x.final)  # [10. 0.]\n                print(x.final_type)  # ['Fix' 'Minimize']\n        \"\"\"\n        return self._final\n\n    @final.setter\n    def final(self, arr):\n        \"\"\"Set the final state boundary conditions.\n\n        Each element can be specified as either a simple number (defaults to \"fixed\")\n        or a tuple of (type, value) where type specifies the boundary condition.\n\n        Args:\n            arr: Array-like of final conditions. Each element can be:\n                - A number: Defaults to fixed boundary condition at that value\n                - A tuple (type, value): Where type is one of:\n                    - \"fixed\": Constrain state to this exact value\n                    - \"free\": Let optimizer choose within bounds, initialize at value\n                    - \"minimize\": Add objective term to minimize, initialize at value\n                    - \"maximize\": Add objective term to maximize, initialize at value\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape, if boundary\n                condition type is invalid, or if fixed values violate bounds\n\n        Example:\n            Set final state boundary conditionis:\n\n                pos = State(\"pos\", (3,))\n                pos.min = [0, 0, 0]\n                pos.max = [10, 10, 10]\n                # x fixed at 10, y free (starts at 5), z maximize altitude\n                pos.final = [10, (\"free\", 5), (\"maximize\", 8)]\n\n            Minimize final time in time-optimal problem:\n\n                time = State(\"t\", (1,))\n                time.final = [(\"minimize\", 10)]\n        \"\"\"\n        # Convert to list first to handle mixed types properly\n        if not isinstance(arr, (list, tuple)):\n            arr = np.asarray(arr)\n            if arr.shape != self.shape:\n                raise ValueError(f\"Shape mismatch: {arr.shape} != {self.shape}\")\n            arr = arr.tolist()\n\n        # Ensure we have the right number of elements\n        if len(arr) != self.shape[0]:\n            raise ValueError(f\"Length mismatch: got {len(arr)} elements, expected {self.shape[0]}\")\n\n        self._final = np.zeros(self.shape, dtype=float)\n        self.final_type = np.full(self.shape, \"Fix\", dtype=object)\n\n        for i, v in enumerate(arr):\n            if isinstance(v, tuple) and len(v) == 2:\n                # Tuple API: (type, value)\n                bc_type_str, bc_value = v\n                try:\n                    bc_type = BoundaryType(bc_type_str)  # Validates the string\n                except ValueError:\n                    valid_types = [t.value for t in BoundaryType]\n                    raise ValueError(\n                        f\"Invalid boundary condition type: {bc_type_str}. \"\n                        f\"Valid types are: {valid_types}\"\n                    )\n                self._final[i] = float(bc_value)\n                self.final_type[i] = bc_type.value.capitalize()\n            elif isinstance(v, (int, float, np.number)):\n                # Simple number defaults to fixed\n                self._final[i] = float(v)\n                self.final_type[i] = \"Fix\"\n            else:\n                raise ValueError(\n                    f\"Invalid boundary condition format: {v}. \"\n                    f\"Use a number (defaults to fixed) or tuple ('type', value) \"\n                    f\"where type is 'fixed', 'free', 'minimize', or 'maximize'.\"\n                )\n\n        self._check_bounds_against_initial_final()\n\n    @property\n    def scaling_min(self):\n        \"\"\"Get the scaling minimum bounds for the state variables.\n\n        Returns:\n            Array of scaling minimum values for each state variable element, or None if not set.\n        \"\"\"\n        return self._scaling_min\n\n    @scaling_min.setter\n    def scaling_min(self, val):\n        \"\"\"Set the scaling minimum bounds for the state variables.\n\n        Args:\n            val: Array of scaling minimum values, must match the state shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape\n        \"\"\"\n        if val is None:\n            self._scaling_min = None\n            return\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(\n                f\"Scaling min shape {val.shape} does not match State shape {self.shape}\"\n            )\n        self._scaling_min = val\n\n    @property\n    def scaling_max(self):\n        \"\"\"Get the scaling maximum bounds for the state variables.\n\n        Returns:\n            Array of scaling maximum values for each state variable element, or None if not set.\n        \"\"\"\n        return self._scaling_max\n\n    @scaling_max.setter\n    def scaling_max(self, val):\n        \"\"\"Set the scaling maximum bounds for the state variables.\n\n        Args:\n            val: Array of scaling maximum values, must match the state shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape\n        \"\"\"\n        if val is None:\n            self._scaling_max = None\n            return\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(\n                f\"Scaling max shape {val.shape} does not match State shape {self.shape}\"\n            )\n        self._scaling_max = val\n\n    def __repr__(self):\n        \"\"\"String representation of the State object.\n\n        Returns:\n            Concise string showing the state name and shape.\n        \"\"\"\n        return f\"State('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.State.final","title":"<code>final</code>  <code>property</code> <code>writable</code>","text":"<p>Get the final state boundary condition values.</p> <p>Returns:</p> Type Description <p>Array of final state values (regardless of boundary condition type),</p> <p>or None if not set.</p> Note <p>Use <code>final_type</code> to see the boundary condition types for each element.</p> Example <p>Get final state boundary conditions:</p> <pre><code>x = State(\"x\", (2,))\nx.final = [10, (\"minimize\", 0)]\nprint(x.final)  # [10. 0.]\nprint(x.final_type)  # ['Fix' 'Minimize']\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.State.initial","title":"<code>initial</code>  <code>property</code> <code>writable</code>","text":"<p>Get the initial state boundary condition values.</p> <p>Returns:</p> Type Description <p>Array of initial state values (regardless of boundary condition type),</p> <p>or None if not set.</p> Note <p>Use <code>initial_type</code> to see the boundary condition types for each element.</p> Example <p>Get initial state boundary conditions:</p> <pre><code>x = State(\"x\", (2,))\nx.initial = [0, (\"free\", 1)]\nprint(x.initial)  # [0. 1.]\nprint(x.initial_type)  # ['Fix' 'Free']\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.State.max","title":"<code>max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the maximum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of maximum values for each state variable element.</p> Example <p>Get upper bounds:</p> <pre><code>vel = State(\"vel\", (3,))\nvel.max = [10, 10, 5]\nprint(vel.max)  # [10. 10. 5.]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.State.min","title":"<code>min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the minimum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of minimum values for each state variable element.</p> Example <p>Get lower bounds:</p> <pre><code>pos = State(\"pos\", (3,))\npos.min = [0, 0, 10]\nprint(pos.min)  # [0. 0. 10.]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.State.scaling_max","title":"<code>scaling_max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling maximum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of scaling maximum values for each state variable element, or None if not set.</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.State.scaling_min","title":"<code>scaling_min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling minimum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of scaling minimum values for each state variable element, or None if not set.</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.State.__init__","title":"<code>__init__(name, shape)</code>","text":"<p>Initialize a State object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name identifier for the state variable</p> required <code>shape</code> <p>Shape of the state vector (typically 1D tuple)</p> required Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def __init__(self, name, shape):\n    \"\"\"Initialize a State object.\n\n    Args:\n        name: Name identifier for the state variable\n        shape: Shape of the state vector (typically 1D tuple)\n    \"\"\"\n    super().__init__(name, shape)\n    self._initial = None\n    self.initial_type = None\n    self._final = None\n    self.final_type = None\n    self._scaling_min = None\n    self._scaling_max = None\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sub","title":"<code>Sub</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Subtraction operation for symbolic expressions.</p> <p>Represents element-wise subtraction (left - right). Supports broadcasting following NumPy rules. Can be created using the - operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>left</code> <p>Left-hand side expression (minuend)</p> <code>right</code> <p>Right-hand side expression (subtrahend)</p> Example <p>Define a Sub expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(3,))\nz = x - y  # Creates Sub(x, y)\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Sub(Expr):\n    \"\"\"Subtraction operation for symbolic expressions.\n\n    Represents element-wise subtraction (left - right). Supports broadcasting\n    following NumPy rules. Can be created using the - operator on Expr objects.\n\n    Attributes:\n        left: Left-hand side expression (minuend)\n        right: Right-hand side expression (subtrahend)\n\n    Example:\n        Define a Sub expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(3,))\n            z = x - y  # Creates Sub(x, y)\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\"Initialize a subtraction operation.\n\n        Args:\n            left: Expression to subtract from (minuend)\n            right: Expression to subtract (subtrahend)\n        \"\"\"\n        self.left = left\n        self.right = right\n\n    def children(self):\n        return [self.left, self.right]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize subtraction: fold constants if both sides are constants.\n\n        Returns:\n            Expr: Canonical form of the subtraction expression\n        \"\"\"\n        left = self.left.canonicalize()\n        right = self.right.canonicalize()\n        if isinstance(left, Constant) and isinstance(right, Constant):\n            return Constant(left.value - right.value)\n        return Sub(left, right)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n        Returns:\n            tuple: The broadcasted shape of all operands\n\n        Raises:\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Sub shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        return f\"({self.left!r} - {self.right!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sub.__init__","title":"<code>__init__(left, right)</code>","text":"<p>Initialize a subtraction operation.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <p>Expression to subtract from (minuend)</p> required <code>right</code> <p>Expression to subtract (subtrahend)</p> required Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def __init__(self, left, right):\n    \"\"\"Initialize a subtraction operation.\n\n    Args:\n        left: Expression to subtract from (minuend)\n        right: Expression to subtract (subtrahend)\n    \"\"\"\n    self.left = left\n    self.right = right\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sub.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize subtraction: fold constants if both sides are constants.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the subtraction expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize subtraction: fold constants if both sides are constants.\n\n    Returns:\n        Expr: Canonical form of the subtraction expression\n    \"\"\"\n    left = self.left.canonicalize()\n    right = self.right.canonicalize()\n    if isinstance(left, Constant) and isinstance(right, Constant):\n        return Constant(left.value - right.value)\n    return Sub(left, right)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sub.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check shape compatibility and compute broadcasted result shape like NumPy.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The broadcasted shape of all operands</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n    Returns:\n        tuple: The broadcasted shape of all operands\n\n    Raises:\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Sub shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sum","title":"<code>Sum</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Sum reduction operation for symbolic expressions.</p> <p>Sums all elements of an expression, reducing it to a scalar. This is a reduction operation that collapses all dimensions.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression whose elements will be summed</p> Example <p>Define a Sum expression::</p> <pre><code>x = ox.State(\"x\", shape=(3, 4))\ntotal = Sum(x)  # Creates Sum(x), result shape ()\n</code></pre> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>class Sum(Expr):\n    \"\"\"Sum reduction operation for symbolic expressions.\n\n    Sums all elements of an expression, reducing it to a scalar. This is a\n    reduction operation that collapses all dimensions.\n\n    Attributes:\n        operand: Expression whose elements will be summed\n\n    Example:\n        Define a Sum expression::\n\n            x = ox.State(\"x\", shape=(3, 4))\n            total = Sum(x)  # Creates Sum(x), result shape ()\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a sum reduction operation.\n\n        Args:\n            operand: Expression to sum over all elements\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize sum: canonicalize the operand.\n\n        Returns:\n            Expr: Canonical form of the sum expression\n        \"\"\"\n        operand = self.operand.canonicalize()\n        return Sum(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Sum reduces any shape to a scalar.\"\"\"\n        # Validate that the operand has a valid shape\n        self.operand.check_shape()\n        # Sum always produces a scalar regardless of input shape\n        return ()\n\n    def __repr__(self):\n        return f\"sum({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sum.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a sum reduction operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to sum over all elements</p> required Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a sum reduction operation.\n\n    Args:\n        operand: Expression to sum over all elements\n    \"\"\"\n    self.operand = to_expr(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sum.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize sum: canonicalize the operand.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the sum expression</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize sum: canonicalize the operand.\n\n    Returns:\n        Expr: Canonical form of the sum expression\n    \"\"\"\n    operand = self.operand.canonicalize()\n    return Sum(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Sum.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Sum reduces any shape to a scalar.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Sum reduces any shape to a scalar.\"\"\"\n    # Validate that the operand has a valid shape\n    self.operand.check_shape()\n    # Sum always produces a scalar regardless of input shape\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Tan","title":"<code>Tan</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise tangent function for symbolic expressions.</p> <p>Computes the tangent of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply tangent function to</p> Example <p>Define a Tan expression:</p> <pre><code>theta = Variable(\"theta\", shape=(3,))\ntan_theta = Tan(theta)\n</code></pre> Note <p>Tan is only supported for JAX lowering. CVXPy lowering will raise NotImplementedError since tangent is not DCP-compliant.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Tan(Expr):\n    \"\"\"Element-wise tangent function for symbolic expressions.\n\n    Computes the tangent of each element in the operand. Preserves the shape\n    of the input expression.\n\n    Attributes:\n        operand: Expression to apply tangent function to\n\n    Example:\n        Define a Tan expression:\n\n            theta = Variable(\"theta\", shape=(3,))\n            tan_theta = Tan(theta)\n\n    Note:\n        Tan is only supported for JAX lowering. CVXPy lowering will raise\n        NotImplementedError since tangent is not DCP-compliant.\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a tangent operation.\n\n        Args:\n            operand: Expression to apply tangent function to\n        \"\"\"\n        self.operand = operand\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Tan(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Tan preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"(tan({self.operand!r}))\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Tan.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a tangent operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to apply tangent function to</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a tangent operation.\n\n    Args:\n        operand: Expression to apply tangent function to\n    \"\"\"\n    self.operand = operand\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Tan.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Tan preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Tan preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Transpose","title":"<code>Transpose</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Matrix transpose operation for symbolic expressions.</p> <p>Transposes the last two dimensions of an expression. For matrices, this swaps rows and columns. For higher-dimensional arrays, it swaps the last two axes. Scalars and vectors are unchanged by transposition.</p> <p>The canonicalization includes an optimization that eliminates double transposes: (A.T).T simplifies to A.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to transpose</p> Example <p>Define Tranpose expressions:</p> <pre><code>A = Variable(\"A\", shape=(3, 4))\nA_T = Transpose(A)  # or A.T, result shape (4, 3)\nv = Variable(\"v\", shape=(5,))\nv_T = Transpose(v)  # result shape (5,) - vectors unchanged\n</code></pre> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>class Transpose(Expr):\n    \"\"\"Matrix transpose operation for symbolic expressions.\n\n    Transposes the last two dimensions of an expression. For matrices, this swaps\n    rows and columns. For higher-dimensional arrays, it swaps the last two axes.\n    Scalars and vectors are unchanged by transposition.\n\n    The canonicalization includes an optimization that eliminates double transposes:\n    (A.T).T simplifies to A.\n\n    Attributes:\n        operand: Expression to transpose\n\n    Example:\n        Define Tranpose expressions:\n\n            A = Variable(\"A\", shape=(3, 4))\n            A_T = Transpose(A)  # or A.T, result shape (4, 3)\n            v = Variable(\"v\", shape=(5,))\n            v_T = Transpose(v)  # result shape (5,) - vectors unchanged\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a transpose operation.\n\n        Args:\n            operand: Expression to transpose\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the operand with double transpose optimization.\"\"\"\n        operand = self.operand.canonicalize()\n\n        # Double transpose optimization: (A.T).T = A\n        if isinstance(operand, Transpose):\n            return operand.operand\n\n        return Transpose(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Matrix transpose operation swaps the last two dimensions.\"\"\"\n        operand_shape = self.operand.check_shape()\n\n        if len(operand_shape) == 0:\n            # Scalar transpose is the scalar itself\n            return ()\n        elif len(operand_shape) == 1:\n            # Vector transpose is the vector itself (row vector remains row vector)\n            return operand_shape\n        elif len(operand_shape) == 2:\n            # Matrix transpose: (m,n) -&gt; (n,m)\n            return (operand_shape[1], operand_shape[0])\n        else:\n            # Higher-dimensional array: transpose last two dimensions\n            # (..., m, n) -&gt; (..., n, m)\n            return operand_shape[:-2] + (operand_shape[-1], operand_shape[-2])\n\n    def __repr__(self):\n        return f\"({self.operand!r}).T\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Transpose.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a transpose operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to transpose</p> required Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a transpose operation.\n\n    Args:\n        operand: Expression to transpose\n    \"\"\"\n    self.operand = to_expr(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Transpose.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the operand with double transpose optimization.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the operand with double transpose optimization.\"\"\"\n    operand = self.operand.canonicalize()\n\n    # Double transpose optimization: (A.T).T = A\n    if isinstance(operand, Transpose):\n        return operand.operand\n\n    return Transpose(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Transpose.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Matrix transpose operation swaps the last two dimensions.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Matrix transpose operation swaps the last two dimensions.\"\"\"\n    operand_shape = self.operand.check_shape()\n\n    if len(operand_shape) == 0:\n        # Scalar transpose is the scalar itself\n        return ()\n    elif len(operand_shape) == 1:\n        # Vector transpose is the vector itself (row vector remains row vector)\n        return operand_shape\n    elif len(operand_shape) == 2:\n        # Matrix transpose: (m,n) -&gt; (n,m)\n        return (operand_shape[1], operand_shape[0])\n    else:\n        # Higher-dimensional array: transpose last two dimensions\n        # (..., m, n) -&gt; (..., n, m)\n        return operand_shape[:-2] + (operand_shape[-1], operand_shape[-2])\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable","title":"<code>Variable</code>","text":"<p>               Bases: <code>Leaf</code></p> <p>Base class for decision variables in optimization problems.</p> <p>Variable represents decision variables (free parameters) in an optimization problem. These are values that the optimizer can adjust to minimize the objective function while satisfying constraints. Variables can have bounds (min/max) and initial guesses to guide the optimization process.</p> <p>Unlike Parameters (which are fixed values that can be changed between solves), Variables are optimized by the solver. In trajectory optimization, Variables typically represent discretized state or control trajectories.</p> Note <p>Variable is typically not instantiated directly. Instead, use the specialized subclasses State (for state variables with boundary conditions) or Control (for control inputs). These provide additional functionality specific to trajectory optimization.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the variable</p> <code>_shape</code> <code>tuple[int, ...]</code> <p>Shape of the variable as a tuple (typically 1D)</p> <code>_slice</code> <code>slice | None</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <code>ndarray | None</code> <p>Minimum bounds for each element of the variable</p> <code>_max</code> <code>ndarray | None</code> <p>Maximum bounds for each element of the variable</p> <code>_guess</code> <code>ndarray | None</code> <p>Initial guess for the variable trajectory (n_points, n_vars)</p> Example Source code in <code>openscvx/symbolic/expr/variable.py</code> <pre><code>class Variable(Leaf):\n    \"\"\"Base class for decision variables in optimization problems.\n\n    Variable represents decision variables (free parameters) in an optimization problem.\n    These are values that the optimizer can adjust to minimize the objective function\n    while satisfying constraints. Variables can have bounds (min/max) and initial guesses\n    to guide the optimization process.\n\n    Unlike Parameters (which are fixed values that can be changed between solves),\n    Variables are optimized by the solver. In trajectory optimization, Variables typically\n    represent discretized state or control trajectories.\n\n    Note:\n        Variable is typically not instantiated directly. Instead, use the specialized\n        subclasses State (for state variables with boundary conditions) or Control\n        (for control inputs). These provide additional functionality specific to\n        trajectory optimization.\n\n    Attributes:\n        name (str): Name identifier for the variable\n        _shape (tuple[int, ...]): Shape of the variable as a tuple (typically 1D)\n        _slice (slice | None): Internal slice information for variable indexing\n        _min (np.ndarray | None): Minimum bounds for each element of the variable\n        _max (np.ndarray | None): Maximum bounds for each element of the variable\n        _guess (np.ndarray | None): Initial guess for the variable trajectory (n_points, n_vars)\n\n    Example:\n            # Typically, use State or Control instead of Variable directly:\n            pos = openscvx.State(\"pos\", shape=(3,))\n            u = openscvx.Control(\"u\", shape=(2,))\n    \"\"\"\n\n    def __init__(self, name, shape):\n        \"\"\"Initialize a Variable object.\n\n        Args:\n            name: Name identifier for the variable\n            shape: Shape of the variable as a tuple (typically 1D like (3,) for 3D vector)\n        \"\"\"\n        super().__init__(name, shape)\n        self._slice = None\n        self._min = None\n        self._max = None\n        self._guess = None\n\n    def __repr__(self):\n        return f\"Var({self.name!r})\"\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Variable using its slice (canonical position, name-invariant).\n\n        Instead of hashing the variable name, we hash the _slice attribute\n        which represents the variable's canonical position in the unified\n        state/control vector. This ensures that two problems with the same\n        structure but different variable names produce the same hash.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(self.__class__.__name__.encode())\n        hasher.update(str(self._shape).encode())\n        # Hash the slice (canonical position) - this is name-invariant\n        if self._slice is not None:\n            hasher.update(f\"slice:{self._slice.start}:{self._slice.stop}\".encode())\n        else:\n            raise RuntimeError(\n                f\"Cannot hash Variable '{self.name}' without _slice attribute. \"\n                \"Hashing should only be called on preprocessed problems where \"\n                \"all Variables have been assigned canonical slice positions.\"\n            )\n\n    @property\n    def min(self):\n        \"\"\"Get the minimum bounds (lower bounds) for the variable.\n\n        Returns:\n            Array of minimum values for each element of the variable, or None if unbounded.\n\n        Example:\n                pos = Variable(\"pos\", shape=(3,))\n                pos.min = [-10, -10, 0]\n                print(pos.min)  # [-10., -10., 0.]\n        \"\"\"\n        return self._min\n\n    @min.setter\n    def min(self, arr):\n        \"\"\"Set the minimum bounds (lower bounds) for the variable.\n\n        The bounds are applied element-wise to each component of the variable.\n        Scalars will be broadcast to match the variable shape.\n\n        Args:\n            arr: Array of minimum values, must be broadcastable to shape (n,)\n                where n is the variable dimension\n\n        Raises:\n            ValueError: If the shape of arr doesn't match the variable shape\n\n        Example:\n                pos = Variable(\"pos\", shape=(3,))\n                pos.min = -10  # Broadcasts to [-10, -10, -10]\n                pos.min = [-5, -10, 0]  # Element-wise bounds\n        \"\"\"\n        arr = np.asarray(arr, dtype=float)\n        if arr.ndim != 1 or arr.shape[0] != self.shape[0]:\n            raise ValueError(\n                f\"{self.__class__.__name__} min must be 1D with shape ({self.shape[0]},), got\"\n                f\" {arr.shape}\"\n            )\n        self._min = arr\n\n    @property\n    def max(self):\n        \"\"\"Get the maximum bounds (upper bounds) for the variable.\n\n        Returns:\n            Array of maximum values for each element of the variable, or None if unbounded.\n\n        Example:\n                vel = Variable(\"vel\", shape=(3,))\n                vel.max = [10, 10, 5]\n                print(vel.max)  # [10., 10., 5.]\n        \"\"\"\n        return self._max\n\n    @max.setter\n    def max(self, arr):\n        \"\"\"Set the maximum bounds (upper bounds) for the variable.\n\n        The bounds are applied element-wise to each component of the variable.\n        Scalars will be broadcast to match the variable shape.\n\n        Args:\n            arr: Array of maximum values, must be broadcastable to shape (n,)\n                where n is the variable dimension\n\n        Raises:\n            ValueError: If the shape of arr doesn't match the variable shape\n\n        Example:\n                vel = Variable(\"vel\", shape=(3,))\n                vel.max = 10  # Broadcasts to [10, 10, 10]\n                vel.max = [15, 10, 5]  # Element-wise bounds\n        \"\"\"\n        arr = np.asarray(arr, dtype=float)\n        if arr.ndim != 1 or arr.shape[0] != self.shape[0]:\n            raise ValueError(\n                f\"{self.__class__.__name__} max must be 1D with shape ({self.shape[0]},), got\"\n                f\" {arr.shape}\"\n            )\n        self._max = arr\n\n    @property\n    def slice(self):\n        \"\"\"Get the slice indexing this variable in the unified state/control vector.\n\n        After preprocessing, each variable is assigned a canonical position in the\n        unified optimization vector. This property returns the slice object that\n        extracts this variable's values from the unified vector.\n\n        This is particularly useful for expert users working with byof (bring-your-own\n        functions) who need to manually index into the unified x and u vectors.\n\n        Returns:\n            slice: Slice object for indexing into unified vector, or None if the\n                variable hasn't been preprocessed yet.\n\n        Example:\n                velocity = ox.State(\"velocity\", shape=(3,))\n                # ... after Problem construction ...\n                print(velocity.slice)  # slice(2, 5) (for example)\n\n                # Use in byof functions\n                def my_constraint(x, u, node, params):\n                    vel = x[velocity.slice]  # Extract velocity from unified state\n                    return jnp.sum(vel**2) - 100  # |v|^2 &lt;= 100\n        \"\"\"\n        return self._slice\n\n    @property\n    def guess(self):\n        \"\"\"Get the initial guess for the variable trajectory.\n\n        The guess provides a starting point for the optimizer. A good initial guess\n        can significantly improve convergence speed and help avoid local minima.\n\n        Returns:\n            2D array of shape (n_points, n_vars) representing the variable trajectory\n            over time, or None if no guess is provided.\n\n        Example:\n                x = Variable(\"x\", shape=(2,))\n                # Linear interpolation from [0,0] to [10,10] over 50 points\n                x.guess = np.linspace([0, 0], [10, 10], 50)\n                print(x.guess.shape)  # (50, 2)\n        \"\"\"\n        return self._guess\n\n    @guess.setter\n    def guess(self, arr):\n        \"\"\"Set the initial guess for the variable trajectory.\n\n        The guess should be a 2D array where each row represents the variable value\n        at a particular time point or trajectory node.\n\n        Args:\n            arr: 2D array of shape (n_points, n_vars) where n_vars matches the\n                variable dimension. Can be fewer points than the final trajectory -\n                the solver will interpolate as needed.\n\n        Raises:\n            ValueError: If the array is not 2D or if the second dimension doesn't\n                match the variable dimension\n\n        Example:\n                pos = Variable(\"pos\", shape=(3,))\n                # Create a straight-line trajectory from origin to target\n                n_points = 50\n                pos.guess = np.linspace([0, 0, 0], [10, 5, 3], n_points)\n        \"\"\"\n        arr = np.asarray(arr, dtype=float)\n        if arr.ndim != 2:\n            raise ValueError(\n                f\"Guess must be a 2D array of shape (n_guess_points, {self.shape[0]}), got shape\"\n                f\" {arr.shape}\"\n            )\n        if arr.shape[1] != self.shape[0]:\n            raise ValueError(\n                f\"Guess must have second dimension equal to variable dimension {self.shape[0]}, got\"\n                f\" {arr.shape[1]}\"\n            )\n        self._guess = arr\n\n    def append(self, other=None, *, min=-np.inf, max=np.inf, guess=0.0):\n        \"\"\"Append a new dimension to this variable or merge with another variable.\n\n        This method extends the variable's dimension by either:\n        1. Appending another Variable object (concatenating their dimensions)\n        2. Adding a single new scalar dimension with specified bounds and guess\n\n        The bounds and guesses of both variables are concatenated appropriately.\n\n        Args:\n            other: Another Variable object to append. If None, adds a single scalar\n                dimension with the specified min/max/guess values.\n            min: Minimum bound for the new dimension (only used if other is None).\n                Defaults to -np.inf (unbounded below).\n            max: Maximum bound for the new dimension (only used if other is None).\n                Defaults to np.inf (unbounded above).\n            guess: Initial guess value for the new dimension (only used if other is None).\n                Defaults to 0.0.\n\n        Example:\n            Create a 2D variable and extend it to 3D:\n\n                pos_xy = Variable(\"pos\", shape=(2,))\n                pos_xy.min = [-10, -10]\n                pos_xy.max = [10, 10]\n                pos_xy.append(min=0, max=100)  # Add z dimension\n                print(pos_xy.shape)  # (3,)\n                print(pos_xy.min)  # [-10., -10., 0.]\n                print(pos_xy.max)  # [10., 10., 100.]\n\n            Merge two variables:\n\n                pos = Variable(\"pos\", shape=(3,))\n                vel = Variable(\"vel\", shape=(3,))\n                pos.append(vel)  # Now pos has shape (6,)\n        \"\"\"\n\n        def process_array(val, is_guess=False):\n            \"\"\"Process input array to ensure correct shape and type.\n\n            Args:\n                val: Input value to process\n                is_guess: Whether the value is a guess array\n\n            Returns:\n                Processed array with correct shape and type\n            \"\"\"\n            arr = np.asarray(val, dtype=float)\n            if is_guess:\n                return np.atleast_2d(arr)\n            return np.atleast_1d(arr)\n\n        if isinstance(other, Variable):\n            self._shape = (self.shape[0] + other.shape[0],)\n\n            if self._min is not None and other._min is not None:\n                self._min = np.concatenate([self._min, process_array(other._min)], axis=0)\n\n            if self._max is not None and other._max is not None:\n                self._max = np.concatenate([self._max, process_array(other._max)], axis=0)\n\n            if self._guess is not None and other._guess is not None:\n                self._guess = np.concatenate(\n                    [self._guess, process_array(other._guess, is_guess=True)], axis=1\n                )\n\n        else:\n            self._shape = (self.shape[0] + 1,)\n\n            if self._min is not None:\n                self._min = np.concatenate([self._min, process_array(min)], axis=0)\n\n            if self._max is not None:\n                self._max = np.concatenate([self._max, process_array(max)], axis=0)\n\n            if self._guess is not None:\n                guess_arr = process_array(guess, is_guess=True)\n                if guess_arr.shape[1] != 1:\n                    guess_arr = guess_arr.T\n                self._guess = np.concatenate([self._guess, guess_arr], axis=1)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable--typically-use-state-or-control-instead-of-variable-directly","title":"Typically, use State or Control instead of Variable directly:","text":"<p>pos = openscvx.State(\"pos\", shape=(3,)) u = openscvx.Control(\"u\", shape=(2,))</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable.guess","title":"<code>guess</code>  <code>property</code> <code>writable</code>","text":"<p>Get the initial guess for the variable trajectory.</p> <p>The guess provides a starting point for the optimizer. A good initial guess can significantly improve convergence speed and help avoid local minima.</p> <p>Returns:</p> Type Description <p>2D array of shape (n_points, n_vars) representing the variable trajectory</p> <p>over time, or None if no guess is provided.</p> Example <p>x = Variable(\"x\", shape=(2,))</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable.guess--linear-interpolation-from-00-to-1010-over-50-points","title":"Linear interpolation from [0,0] to [10,10] over 50 points","text":"<p>x.guess = np.linspace([0, 0], [10, 10], 50) print(x.guess.shape)  # (50, 2)</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable.max","title":"<code>max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the maximum bounds (upper bounds) for the variable.</p> <p>Returns:</p> Type Description <p>Array of maximum values for each element of the variable, or None if unbounded.</p> Example <p>vel = Variable(\"vel\", shape=(3,)) vel.max = [10, 10, 5] print(vel.max)  # [10., 10., 5.]</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable.min","title":"<code>min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the minimum bounds (lower bounds) for the variable.</p> <p>Returns:</p> Type Description <p>Array of minimum values for each element of the variable, or None if unbounded.</p> Example <p>pos = Variable(\"pos\", shape=(3,)) pos.min = [-10, -10, 0] print(pos.min)  # [-10., -10., 0.]</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable.slice","title":"<code>slice</code>  <code>property</code>","text":"<p>Get the slice indexing this variable in the unified state/control vector.</p> <p>After preprocessing, each variable is assigned a canonical position in the unified optimization vector. This property returns the slice object that extracts this variable's values from the unified vector.</p> <p>This is particularly useful for expert users working with byof (bring-your-own functions) who need to manually index into the unified x and u vectors.</p> <p>Returns:</p> Name Type Description <code>slice</code> <p>Slice object for indexing into unified vector, or None if the variable hasn't been preprocessed yet.</p> Example <p>velocity = ox.State(\"velocity\", shape=(3,))</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable.slice--after-problem-construction","title":"... after Problem construction ...","text":"<p>print(velocity.slice)  # slice(2, 5) (for example)</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable.slice--use-in-byof-functions","title":"Use in byof functions","text":"<p>def my_constraint(x, u, node, params):     vel = x[velocity.slice]  # Extract velocity from unified state     return jnp.sum(vel**2) - 100  # |v|^2 &lt;= 100</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable.__init__","title":"<code>__init__(name, shape)</code>","text":"<p>Initialize a Variable object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name identifier for the variable</p> required <code>shape</code> <p>Shape of the variable as a tuple (typically 1D like (3,) for 3D vector)</p> required Source code in <code>openscvx/symbolic/expr/variable.py</code> <pre><code>def __init__(self, name, shape):\n    \"\"\"Initialize a Variable object.\n\n    Args:\n        name: Name identifier for the variable\n        shape: Shape of the variable as a tuple (typically 1D like (3,) for 3D vector)\n    \"\"\"\n    super().__init__(name, shape)\n    self._slice = None\n    self._min = None\n    self._max = None\n    self._guess = None\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Variable.append","title":"<code>append(other=None, *, min=-np.inf, max=np.inf, guess=0.0)</code>","text":"<p>Append a new dimension to this variable or merge with another variable.</p> <p>This method extends the variable's dimension by either: 1. Appending another Variable object (concatenating their dimensions) 2. Adding a single new scalar dimension with specified bounds and guess</p> <p>The bounds and guesses of both variables are concatenated appropriately.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>Another Variable object to append. If None, adds a single scalar dimension with the specified min/max/guess values.</p> <code>None</code> <code>min</code> <p>Minimum bound for the new dimension (only used if other is None). Defaults to -np.inf (unbounded below).</p> <code>-inf</code> <code>max</code> <p>Maximum bound for the new dimension (only used if other is None). Defaults to np.inf (unbounded above).</p> <code>inf</code> <code>guess</code> <p>Initial guess value for the new dimension (only used if other is None). Defaults to 0.0.</p> <code>0.0</code> Example <p>Create a 2D variable and extend it to 3D:</p> <pre><code>pos_xy = Variable(\"pos\", shape=(2,))\npos_xy.min = [-10, -10]\npos_xy.max = [10, 10]\npos_xy.append(min=0, max=100)  # Add z dimension\nprint(pos_xy.shape)  # (3,)\nprint(pos_xy.min)  # [-10., -10., 0.]\nprint(pos_xy.max)  # [10., 10., 100.]\n</code></pre> <p>Merge two variables:</p> <pre><code>pos = Variable(\"pos\", shape=(3,))\nvel = Variable(\"vel\", shape=(3,))\npos.append(vel)  # Now pos has shape (6,)\n</code></pre> Source code in <code>openscvx/symbolic/expr/variable.py</code> <pre><code>def append(self, other=None, *, min=-np.inf, max=np.inf, guess=0.0):\n    \"\"\"Append a new dimension to this variable or merge with another variable.\n\n    This method extends the variable's dimension by either:\n    1. Appending another Variable object (concatenating their dimensions)\n    2. Adding a single new scalar dimension with specified bounds and guess\n\n    The bounds and guesses of both variables are concatenated appropriately.\n\n    Args:\n        other: Another Variable object to append. If None, adds a single scalar\n            dimension with the specified min/max/guess values.\n        min: Minimum bound for the new dimension (only used if other is None).\n            Defaults to -np.inf (unbounded below).\n        max: Maximum bound for the new dimension (only used if other is None).\n            Defaults to np.inf (unbounded above).\n        guess: Initial guess value for the new dimension (only used if other is None).\n            Defaults to 0.0.\n\n    Example:\n        Create a 2D variable and extend it to 3D:\n\n            pos_xy = Variable(\"pos\", shape=(2,))\n            pos_xy.min = [-10, -10]\n            pos_xy.max = [10, 10]\n            pos_xy.append(min=0, max=100)  # Add z dimension\n            print(pos_xy.shape)  # (3,)\n            print(pos_xy.min)  # [-10., -10., 0.]\n            print(pos_xy.max)  # [10., 10., 100.]\n\n        Merge two variables:\n\n            pos = Variable(\"pos\", shape=(3,))\n            vel = Variable(\"vel\", shape=(3,))\n            pos.append(vel)  # Now pos has shape (6,)\n    \"\"\"\n\n    def process_array(val, is_guess=False):\n        \"\"\"Process input array to ensure correct shape and type.\n\n        Args:\n            val: Input value to process\n            is_guess: Whether the value is a guess array\n\n        Returns:\n            Processed array with correct shape and type\n        \"\"\"\n        arr = np.asarray(val, dtype=float)\n        if is_guess:\n            return np.atleast_2d(arr)\n        return np.atleast_1d(arr)\n\n    if isinstance(other, Variable):\n        self._shape = (self.shape[0] + other.shape[0],)\n\n        if self._min is not None and other._min is not None:\n            self._min = np.concatenate([self._min, process_array(other._min)], axis=0)\n\n        if self._max is not None and other._max is not None:\n            self._max = np.concatenate([self._max, process_array(other._max)], axis=0)\n\n        if self._guess is not None and other._guess is not None:\n            self._guess = np.concatenate(\n                [self._guess, process_array(other._guess, is_guess=True)], axis=1\n            )\n\n    else:\n        self._shape = (self.shape[0] + 1,)\n\n        if self._min is not None:\n            self._min = np.concatenate([self._min, process_array(min)], axis=0)\n\n        if self._max is not None:\n            self._max = np.concatenate([self._max, process_array(max)], axis=0)\n\n        if self._guess is not None:\n            guess_arr = process_array(guess, is_guess=True)\n            if guess_arr.shape[1] != 1:\n                guess_arr = guess_arr.T\n            self._guess = np.concatenate([self._guess, guess_arr], axis=1)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Vmap","title":"<code>Vmap</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Vectorized map over batched data in symbolic expressions.</p> <p>Vmap enables data-parallel operations by applying a symbolic expression to each element of a batched array. This is the symbolic equivalent of JAX's jax.vmap, allowing efficient vectorized computation without explicit loops.</p> <p>The expression is defined via a lambda that receives a Placeholder representing a single element from the batch. During lowering, this becomes a jax.vmap call.</p> <p>The behavior depends on the type of <code>batch</code>:</p> <ul> <li>numpy array or Constant: Data is baked into the compiled function   at trace time, equivalent to closure-captured values in BYOF.</li> <li>Parameter: Data is looked up from the params dict at runtime,   allowing the same compiled code to be reused with different values.</li> </ul> <p>Attributes:</p> Name Type Description <code>_batch</code> <p>The data source (Constant or Parameter)</p> <code>_axis</code> <code>int</code> <p>The axis to vmap over (default: 0)</p> <code>_placeholder</code> <code>Placeholder</code> <p>The placeholder used in the expression</p> <code>_child</code> <code>Expr</code> <p>The expression tree built from the user's lambda</p> <code>_is_parameter</code> <code>bool</code> <p>Whether _batch is a Parameter (runtime lookup)</p> Example <p>Compute distances to multiple reference points (baked-in)::</p> <pre><code>position = ox.State(\"position\", shape=(3,))\ninit_poses = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n\ndistances = ox.Vmap(\n    lambda pose: ox.linalg.Norm(position - pose),\n    batch=init_poses\n)\n# distances has shape (3,)\n</code></pre> <p>With runtime-updateable Parameter::</p> <pre><code>refs = ox.Parameter(\"refs\", shape=(10, 3), value=init_poses)\ndist_state = ox.State(\"dist_state\", shape=(10,))\n\ndynamics[\"dist_state\"] = ox.Vmap(\n    lambda pose: ox.linalg.Norm(position - pose),\n    batch=refs\n)\n\n# Later, change the parameter value without recompiling:\nproblem.parameters[\"refs\"] = new_poses\n</code></pre> Note <ul> <li>For static data that won't change, pass a numpy array or Constant   to get closure-equivalent behavior (numerically identical to BYOF).</li> <li>For data that needs to be updated between iterations, use Parameter.</li> </ul> <p>Prefer Constants over Parameters</p> <p>Use a raw numpy array or Constant unless you specifically need to update the vmap data between solves without recompiling.</p> <p>Using a Parameter (runtime lookup) may produce different numerical results compared to using a Constant (baked-in), even when the underlying data is identical. This can manifest as:</p> <ul> <li>Different SCP iteration counts</li> <li>Different convergence behavior</li> <li>In unlucky cases, convergence to a different local solution</li> </ul> <p>This is likely due to JAX/XLA trace and compilation differences between the two code paths. When data is baked in, JAX sees concrete values at trace time. When data is looked up from a params dict at runtime, JAX traces through the dictionary access, potentially producing different XLA compilation or floating-point operation ordering.</p> Source code in <code>openscvx/symbolic/expr/vmap.py</code> <pre><code>class Vmap(Expr):\n    \"\"\"Vectorized map over batched data in symbolic expressions.\n\n    Vmap enables data-parallel operations by applying a symbolic expression\n    to each element of a batched array. This is the symbolic equivalent of\n    JAX's jax.vmap, allowing efficient vectorized computation without\n    explicit loops.\n\n    The expression is defined via a lambda that receives a Placeholder\n    representing a single element from the batch. During lowering, this\n    becomes a jax.vmap call.\n\n    The behavior depends on the type of `batch`:\n\n    - **numpy array or Constant**: Data is baked into the compiled function\n      at trace time, equivalent to closure-captured values in BYOF.\n    - **Parameter**: Data is looked up from the params dict at runtime,\n      allowing the same compiled code to be reused with different values.\n\n    Attributes:\n        _batch: The data source (Constant or Parameter)\n        _axis (int): The axis to vmap over (default: 0)\n        _placeholder (Placeholder): The placeholder used in the expression\n        _child (Expr): The expression tree built from the user's lambda\n        _is_parameter (bool): Whether _batch is a Parameter (runtime lookup)\n\n    Example:\n        Compute distances to multiple reference points (baked-in)::\n\n            position = ox.State(\"position\", shape=(3,))\n            init_poses = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n\n            distances = ox.Vmap(\n                lambda pose: ox.linalg.Norm(position - pose),\n                batch=init_poses\n            )\n            # distances has shape (3,)\n\n        With runtime-updateable Parameter::\n\n            refs = ox.Parameter(\"refs\", shape=(10, 3), value=init_poses)\n            dist_state = ox.State(\"dist_state\", shape=(10,))\n\n            dynamics[\"dist_state\"] = ox.Vmap(\n                lambda pose: ox.linalg.Norm(position - pose),\n                batch=refs\n            )\n\n            # Later, change the parameter value without recompiling:\n            problem.parameters[\"refs\"] = new_poses\n\n    Note:\n        - For static data that won't change, pass a numpy array or Constant\n          to get closure-equivalent behavior (numerically identical to BYOF).\n        - For data that needs to be updated between iterations, use Parameter.\n\n    !!! warning \"Prefer Constants over Parameters\"\n        **Use a raw numpy array or Constant unless you specifically need to\n        update the vmap data between solves without recompiling.**\n\n        Using a Parameter (runtime lookup) may produce **different numerical\n        results** compared to using a Constant (baked-in), even when the\n        underlying data is identical. This can manifest as:\n\n        - Different SCP iteration counts\n        - Different convergence behavior\n        - In unlucky cases, convergence to a different local solution\n\n        This is likely due to JAX/XLA trace and compilation differences between\n        the two code paths. When data is baked in, JAX sees concrete values at\n        trace time. When data is looked up from a params dict at runtime, JAX\n        traces through the dictionary access, potentially producing different\n        XLA compilation or floating-point operation ordering.\n    \"\"\"\n\n    def __init__(\n        self,\n        fn: Callable[[_Placeholder], Expr],\n        batch: Union[np.ndarray, Constant, \"Parameter\"],\n        axis: int = 0,\n    ):\n        \"\"\"Initialize a Vmap expression.\n\n        Args:\n            fn: A callable (typically a lambda) that takes a Placeholder and\n                returns a symbolic expression. The Placeholder represents a\n                single element from the batched data.\n            batch: The batched data to vmap over. Can be:\n                  - numpy array: baked into compiled function (closure-equivalent)\n                  - Constant: baked into compiled function (closure-equivalent)\n                  - Parameter: looked up from params dict at runtime\n            axis: The axis to vmap over. Default is 0 (first axis).\n\n        Example:\n            Baked-in data::\n\n                ox.Vmap(lambda x: ox.linalg.Norm(x), batch=points)\n\n            With Parameter::\n\n                refs = ox.Parameter(\"refs\", shape=(10, 3), value=points)\n                ox.Vmap(lambda ref: ox.linalg.Norm(position - ref), batch=refs)\n        \"\"\"\n        from .expr import Parameter\n\n        # Normalize input: wrap raw arrays in Constant\n        if isinstance(batch, np.ndarray):\n            batch = Constant(batch)\n        elif not isinstance(batch, (Constant, Parameter)):\n            # Try to convert to array then Constant\n            batch = Constant(np.asarray(batch))\n\n        self._batch = batch\n        self._axis = axis\n        self._is_parameter = isinstance(batch, Parameter)\n\n        # Get shape from the appropriate source\n        if self._is_parameter:\n            batch_shape = batch.shape\n        else:\n            # Constant\n            batch_shape = batch.value.shape\n\n        # Compute per-element shape by removing the vmap axis\n        if axis &lt; 0 or axis &gt;= len(batch_shape):\n            raise ValueError(f\"Vmap axis {axis} out of bounds for data with shape {batch_shape}\")\n        per_elem_shape = tuple(s for i, s in enumerate(batch_shape) if i != axis)\n\n        # Create placeholder and build expression tree\n        self._placeholder = _Placeholder(shape=per_elem_shape)\n        self._child = fn(self._placeholder)\n\n    @property\n    def batch(self):\n        \"\"\"The batched data source being vmapped over.\"\"\"\n        return self._batch\n\n    @property\n    def axis(self) -&gt; int:\n        \"\"\"The axis being vmapped over.\"\"\"\n        return self._axis\n\n    @property\n    def placeholder(self) -&gt; _Placeholder:\n        \"\"\"The placeholder used in the inner expression.\"\"\"\n        return self._placeholder\n\n    @property\n    def is_parameter(self) -&gt; bool:\n        \"\"\"Whether the data source is a Parameter (runtime lookup).\"\"\"\n        return self._is_parameter\n\n    def children(self):\n        \"\"\"Return child expressions.\n\n        Returns:\n            list: The vmapped expression and (if Parameter) the data source.\n                  Parameter is included so traverse() finds it for parameter\n                  collection in preprocessing.\n        \"\"\"\n        if self._is_parameter:\n            return [self._child, self._batch]\n        else:\n            return [self._child]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize by canonicalizing the child expression.\n\n        Returns:\n            Vmap: A new Vmap with canonicalized child expression\n        \"\"\"\n        canon_child = self._child.canonicalize()\n        # Create new Vmap with the canonicalized child\n        new_vmap = Vmap.__new__(Vmap)\n        new_vmap._batch = self._batch\n        new_vmap._axis = self._axis\n        new_vmap._placeholder = self._placeholder\n        new_vmap._child = canon_child\n        new_vmap._is_parameter = self._is_parameter\n        return new_vmap\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Compute the output shape of the vmapped expression.\n\n        The output shape is (batch_size,) + inner_shape, where batch_size\n        is the size of the vmap axis and inner_shape is the shape of the\n        child expression.\n\n        Returns:\n            tuple: Output shape after vmapping\n\n        Example:\n            If data has shape (10, 3) and the inner expression produces a\n            scalar (shape ()), the output shape is (10,).\n        \"\"\"\n        inner_shape = self._child.check_shape()\n\n        if self._is_parameter:\n            batch_size = self._batch.shape[self._axis]\n        else:\n            batch_size = self._batch.value.shape[self._axis]\n\n        return (batch_size,) + inner_shape\n\n    def _hash_into(self, hasher):\n        \"\"\"Hash Vmap including data source, axis, and child expression.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Vmap\")\n        hasher.update(str(self._axis).encode())\n        hasher.update(str(self._is_parameter).encode())\n\n        if self._is_parameter:\n            # Hash Parameter by name and shape (not value - value can change)\n            self._batch._hash_into(hasher)\n        else:\n            # Hash Constant by value (baked in, won't change)\n            hasher.update(self._batch.value.tobytes())\n\n        self._child._hash_into(hasher)\n\n    def __repr__(self):\n        \"\"\"String representation of the Vmap expression.\n\n        Returns:\n            str: Description of the Vmap\n        \"\"\"\n        if self._is_parameter:\n            return f\"Vmap(batch=Parameter({self._batch.name!r}), axis={self._axis})\"\n        else:\n            return f\"Vmap(batch=Constant(shape={self._batch.value.shape}), axis={self._axis})\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Vmap.axis","title":"<code>axis: int</code>  <code>property</code>","text":"<p>The axis being vmapped over.</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Vmap.batch","title":"<code>batch</code>  <code>property</code>","text":"<p>The batched data source being vmapped over.</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Vmap.is_parameter","title":"<code>is_parameter: bool</code>  <code>property</code>","text":"<p>Whether the data source is a Parameter (runtime lookup).</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Vmap.placeholder","title":"<code>placeholder: _Placeholder</code>  <code>property</code>","text":"<p>The placeholder used in the inner expression.</p>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Vmap.__init__","title":"<code>__init__(fn: Callable[[_Placeholder], Expr], batch: Union[np.ndarray, Constant, Parameter], axis: int = 0)</code>","text":"<p>Initialize a Vmap expression.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[[_Placeholder], Expr]</code> <p>A callable (typically a lambda) that takes a Placeholder and returns a symbolic expression. The Placeholder represents a single element from the batched data.</p> required <code>batch</code> <code>Union[ndarray, Constant, Parameter]</code> <p>The batched data to vmap over. Can be:   - numpy array: baked into compiled function (closure-equivalent)   - Constant: baked into compiled function (closure-equivalent)   - Parameter: looked up from params dict at runtime</p> required <code>axis</code> <code>int</code> <p>The axis to vmap over. Default is 0 (first axis).</p> <code>0</code> Example <p>Baked-in data::</p> <pre><code>ox.Vmap(lambda x: ox.linalg.Norm(x), batch=points)\n</code></pre> <p>With Parameter::</p> <pre><code>refs = ox.Parameter(\"refs\", shape=(10, 3), value=points)\nox.Vmap(lambda ref: ox.linalg.Norm(position - ref), batch=refs)\n</code></pre> Source code in <code>openscvx/symbolic/expr/vmap.py</code> <pre><code>def __init__(\n    self,\n    fn: Callable[[_Placeholder], Expr],\n    batch: Union[np.ndarray, Constant, \"Parameter\"],\n    axis: int = 0,\n):\n    \"\"\"Initialize a Vmap expression.\n\n    Args:\n        fn: A callable (typically a lambda) that takes a Placeholder and\n            returns a symbolic expression. The Placeholder represents a\n            single element from the batched data.\n        batch: The batched data to vmap over. Can be:\n              - numpy array: baked into compiled function (closure-equivalent)\n              - Constant: baked into compiled function (closure-equivalent)\n              - Parameter: looked up from params dict at runtime\n        axis: The axis to vmap over. Default is 0 (first axis).\n\n    Example:\n        Baked-in data::\n\n            ox.Vmap(lambda x: ox.linalg.Norm(x), batch=points)\n\n        With Parameter::\n\n            refs = ox.Parameter(\"refs\", shape=(10, 3), value=points)\n            ox.Vmap(lambda ref: ox.linalg.Norm(position - ref), batch=refs)\n    \"\"\"\n    from .expr import Parameter\n\n    # Normalize input: wrap raw arrays in Constant\n    if isinstance(batch, np.ndarray):\n        batch = Constant(batch)\n    elif not isinstance(batch, (Constant, Parameter)):\n        # Try to convert to array then Constant\n        batch = Constant(np.asarray(batch))\n\n    self._batch = batch\n    self._axis = axis\n    self._is_parameter = isinstance(batch, Parameter)\n\n    # Get shape from the appropriate source\n    if self._is_parameter:\n        batch_shape = batch.shape\n    else:\n        # Constant\n        batch_shape = batch.value.shape\n\n    # Compute per-element shape by removing the vmap axis\n    if axis &lt; 0 or axis &gt;= len(batch_shape):\n        raise ValueError(f\"Vmap axis {axis} out of bounds for data with shape {batch_shape}\")\n    per_elem_shape = tuple(s for i, s in enumerate(batch_shape) if i != axis)\n\n    # Create placeholder and build expression tree\n    self._placeholder = _Placeholder(shape=per_elem_shape)\n    self._child = fn(self._placeholder)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Vmap.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize by canonicalizing the child expression.</p> <p>Returns:</p> Name Type Description <code>Vmap</code> <code>Expr</code> <p>A new Vmap with canonicalized child expression</p> Source code in <code>openscvx/symbolic/expr/vmap.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize by canonicalizing the child expression.\n\n    Returns:\n        Vmap: A new Vmap with canonicalized child expression\n    \"\"\"\n    canon_child = self._child.canonicalize()\n    # Create new Vmap with the canonicalized child\n    new_vmap = Vmap.__new__(Vmap)\n    new_vmap._batch = self._batch\n    new_vmap._axis = self._axis\n    new_vmap._placeholder = self._placeholder\n    new_vmap._child = canon_child\n    new_vmap._is_parameter = self._is_parameter\n    return new_vmap\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Vmap.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Compute the output shape of the vmapped expression.</p> <p>The output shape is (batch_size,) + inner_shape, where batch_size is the size of the vmap axis and inner_shape is the shape of the child expression.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Output shape after vmapping</p> Example <p>If data has shape (10, 3) and the inner expression produces a scalar (shape ()), the output shape is (10,).</p> Source code in <code>openscvx/symbolic/expr/vmap.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Compute the output shape of the vmapped expression.\n\n    The output shape is (batch_size,) + inner_shape, where batch_size\n    is the size of the vmap axis and inner_shape is the shape of the\n    child expression.\n\n    Returns:\n        tuple: Output shape after vmapping\n\n    Example:\n        If data has shape (10, 3) and the inner expression produces a\n        scalar (shape ()), the output shape is (10,).\n    \"\"\"\n    inner_shape = self._child.check_shape()\n\n    if self._is_parameter:\n        batch_size = self._batch.shape[self._axis]\n    else:\n        batch_size = self._batch.value.shape[self._axis]\n\n    return (batch_size,) + inner_shape\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Vmap.children","title":"<code>children()</code>","text":"<p>Return child expressions.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>The vmapped expression and (if Parameter) the data source.   Parameter is included so traverse() finds it for parameter   collection in preprocessing.</p> Source code in <code>openscvx/symbolic/expr/vmap.py</code> <pre><code>def children(self):\n    \"\"\"Return child expressions.\n\n    Returns:\n        list: The vmapped expression and (if Parameter) the data source.\n              Parameter is included so traverse() finds it for parameter\n              collection in preprocessing.\n    \"\"\"\n    if self._is_parameter:\n        return [self._child, self._batch]\n    else:\n        return [self._child]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Vstack","title":"<code>Vstack</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Vertical stacking operation for symbolic expressions.</p> <p>Concatenates expressions vertically (along rows for 2D arrays). This is analogous to numpy.vstack() or jax.numpy.vstack().</p> <p>All input expressions must have the same number of dimensions, and all dimensions except the first must match. The result concatenates along axis 0 (rows).</p> <p>Attributes:</p> Name Type Description <code>arrays</code> <p>List of expressions to stack vertically</p> Example <p>Stack vectors to create a matrix:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(3,))\nv = Vstack([x, y])  # Result shape (2, 3)\n</code></pre> <p>Stack matrices vertically:</p> <pre><code>A = Variable(\"A\", shape=(3, 4))\nB = Variable(\"B\", shape=(2, 4))\nC = Vstack([A, B])  # Result shape (5, 4)\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Vstack(Expr):\n    \"\"\"Vertical stacking operation for symbolic expressions.\n\n    Concatenates expressions vertically (along rows for 2D arrays).\n    This is analogous to numpy.vstack() or jax.numpy.vstack().\n\n    All input expressions must have the same number of dimensions, and all\n    dimensions except the first must match. The result concatenates along\n    axis 0 (rows).\n\n    Attributes:\n        arrays: List of expressions to stack vertically\n\n    Example:\n        Stack vectors to create a matrix:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(3,))\n            v = Vstack([x, y])  # Result shape (2, 3)\n\n        Stack matrices vertically:\n\n            A = Variable(\"A\", shape=(3, 4))\n            B = Variable(\"B\", shape=(2, 4))\n            C = Vstack([A, B])  # Result shape (5, 4)\n    \"\"\"\n\n    def __init__(self, arrays):\n        \"\"\"Initialize a vertical stack operation.\n\n        Args:\n            arrays: List of expressions to concatenate vertically.\n                    All must have matching dimensions except the first.\n        \"\"\"\n        self.arrays = [to_expr(arr) for arr in arrays]\n\n    def children(self):\n        return self.arrays\n\n    def canonicalize(self) -&gt; \"Expr\":\n        arrays = [arr.canonicalize() for arr in self.arrays]\n        return Vstack(arrays)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Vertical stack concatenates arrays along the first axis (rows).\"\"\"\n        if not self.arrays:\n            raise ValueError(\"Vstack requires at least one array\")\n\n        array_shapes = [arr.check_shape() for arr in self.arrays]\n\n        # All arrays must have the same number of dimensions\n        first_ndim = len(array_shapes[0])\n        for i, shape in enumerate(array_shapes[1:], 1):\n            if len(shape) != first_ndim:\n                raise ValueError(\n                    f\"Vstack array {i} has {len(shape)} dimensions, but array 0 has {first_ndim}\"\n                )\n\n        # All dimensions except the first must match\n        first_shape = array_shapes[0]\n        for i, shape in enumerate(array_shapes[1:], 1):\n            if shape[1:] != first_shape[1:]:\n                raise ValueError(\n                    f\"Vstack array {i} has trailing dimensions {shape[1:]}, \"\n                    f\"but array 0 has {first_shape[1:]}\"\n                )\n\n        # Result shape: concatenate along axis 0 (rows)\n        total_rows = sum(shape[0] for shape in array_shapes)\n        return (total_rows,) + first_shape[1:]\n\n    def __repr__(self):\n        arrays_repr = \", \".join(repr(arr) for arr in self.arrays)\n        return f\"Vstack([{arrays_repr}])\"\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Vstack.__init__","title":"<code>__init__(arrays)</code>","text":"<p>Initialize a vertical stack operation.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <p>List of expressions to concatenate vertically.     All must have matching dimensions except the first.</p> required Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def __init__(self, arrays):\n    \"\"\"Initialize a vertical stack operation.\n\n    Args:\n        arrays: List of expressions to concatenate vertically.\n                All must have matching dimensions except the first.\n    \"\"\"\n    self.arrays = [to_expr(arr) for arr in arrays]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Vstack.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Vertical stack concatenates arrays along the first axis (rows).</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Vertical stack concatenates arrays along the first axis (rows).\"\"\"\n    if not self.arrays:\n        raise ValueError(\"Vstack requires at least one array\")\n\n    array_shapes = [arr.check_shape() for arr in self.arrays]\n\n    # All arrays must have the same number of dimensions\n    first_ndim = len(array_shapes[0])\n    for i, shape in enumerate(array_shapes[1:], 1):\n        if len(shape) != first_ndim:\n            raise ValueError(\n                f\"Vstack array {i} has {len(shape)} dimensions, but array 0 has {first_ndim}\"\n            )\n\n    # All dimensions except the first must match\n    first_shape = array_shapes[0]\n    for i, shape in enumerate(array_shapes[1:], 1):\n        if shape[1:] != first_shape[1:]:\n            raise ValueError(\n                f\"Vstack array {i} has trailing dimensions {shape[1:]}, \"\n                f\"but array 0 has {first_shape[1:]}\"\n            )\n\n    # Result shape: concatenate along axis 0 (rows)\n    total_rows = sum(shape[0] for shape in array_shapes)\n    return (total_rows,) + first_shape[1:]\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Fixed","title":"<code>Fixed(value)</code>","text":"<p>Create a fixed boundary condition tuple.</p> <p>This is a convenience function that returns a tuple (\"fixed\", value) which can be used to explicitly specify fixed boundary conditions for State or Time objects. Note that plain numbers default to fixed, so this is mainly for clarity.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>Fixed value for the boundary condition.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(\"fixed\", value) tuple suitable for use in State.initial, State.final, or Time.initial, Time.final.</p> Example <pre><code>pos = ox.State(\"pos\", (3,))\npos.final = [ox.Fixed(10.0), ox.Free(5.0), ox.Fixed(2.0)]\n\n# Equivalent to:\npos.final = [10.0, ox.Free(5.0), 2.0]  # Plain numbers default to fixed\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def Fixed(value):\n    \"\"\"Create a fixed boundary condition tuple.\n\n    This is a convenience function that returns a tuple (\"fixed\", value) which\n    can be used to explicitly specify fixed boundary conditions for State or Time objects.\n    Note that plain numbers default to fixed, so this is mainly for clarity.\n\n    Args:\n        value: Fixed value for the boundary condition.\n\n    Returns:\n        tuple: (\"fixed\", value) tuple suitable for use in State.initial, State.final,\n            or Time.initial, Time.final.\n\n    Example:\n        ```python\n        pos = ox.State(\"pos\", (3,))\n        pos.final = [ox.Fixed(10.0), ox.Free(5.0), ox.Fixed(2.0)]\n\n        # Equivalent to:\n        pos.final = [10.0, ox.Free(5.0), 2.0]  # Plain numbers default to fixed\n        ```\n    \"\"\"\n    return (\"fixed\", value)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Free","title":"<code>Free(guess)</code>","text":"<p>Create a free boundary condition tuple.</p> <p>This is a convenience function that returns a tuple (\"free\", guess) which can be used to specify free boundary conditions for State or Time objects.</p> <p>Parameters:</p> Name Type Description Default <code>guess</code> <p>Initial guess value for the free variable.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(\"free\", guess) tuple suitable for use in State.initial, State.final, or Time.initial, Time.final.</p> Example <pre><code>pos = ox.State(\"pos\", (3,))\npos.final = [ox.Free(5.0), ox.Free(3.0), 10]  # First two free, third fixed\n\ntime = ox.Time(\n    initial=0.0,\n    final=ox.Free(10.0),\n    min=0.0,\n    max=20.0\n)\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def Free(guess):\n    \"\"\"Create a free boundary condition tuple.\n\n    This is a convenience function that returns a tuple (\"free\", guess) which\n    can be used to specify free boundary conditions for State or Time objects.\n\n    Args:\n        guess: Initial guess value for the free variable.\n\n    Returns:\n        tuple: (\"free\", guess) tuple suitable for use in State.initial, State.final,\n            or Time.initial, Time.final.\n\n    Example:\n        ```python\n        pos = ox.State(\"pos\", (3,))\n        pos.final = [ox.Free(5.0), ox.Free(3.0), 10]  # First two free, third fixed\n\n        time = ox.Time(\n            initial=0.0,\n            final=ox.Free(10.0),\n            min=0.0,\n            max=20.0\n        )\n        ```\n    \"\"\"\n    return (\"free\", guess)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Maximize","title":"<code>Maximize(guess)</code>","text":"<p>Create a maximize boundary condition tuple.</p> <p>This is a convenience function that returns a tuple (\"maximize\", guess) which can be used to specify that a boundary value should be maximized in the objective function for State or Time objects.</p> <p>Parameters:</p> Name Type Description Default <code>guess</code> <p>Initial guess value for the variable to be maximized.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(\"maximize\", guess) tuple suitable for use in State.initial, State.final, or Time.initial, Time.final.</p> Example <pre><code>altitude = ox.State(\"altitude\", (1,))\naltitude.final = [ox.Maximize(100.0)]  # Maximize final altitude\n\ntime = ox.Time(\n    initial=ox.Maximize(0.0),  # Maximize initial time\n    final=10.0,\n    min=0.0,\n    max=20.0\n)\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def Maximize(guess):\n    \"\"\"Create a maximize boundary condition tuple.\n\n    This is a convenience function that returns a tuple (\"maximize\", guess) which\n    can be used to specify that a boundary value should be maximized in the objective\n    function for State or Time objects.\n\n    Args:\n        guess: Initial guess value for the variable to be maximized.\n\n    Returns:\n        tuple: (\"maximize\", guess) tuple suitable for use in State.initial, State.final,\n            or Time.initial, Time.final.\n\n    Example:\n        ```python\n        altitude = ox.State(\"altitude\", (1,))\n        altitude.final = [ox.Maximize(100.0)]  # Maximize final altitude\n\n        time = ox.Time(\n            initial=ox.Maximize(0.0),  # Maximize initial time\n            final=10.0,\n            min=0.0,\n            max=20.0\n        )\n        ```\n    \"\"\"\n    return (\"maximize\", guess)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.Minimize","title":"<code>Minimize(guess)</code>","text":"<p>Create a minimize boundary condition tuple.</p> <p>This is a convenience function that returns a tuple (\"minimize\", guess) which can be used to specify that a boundary value should be minimized in the objective function for State or Time objects.</p> <p>Parameters:</p> Name Type Description Default <code>guess</code> <p>Initial guess value for the variable to be minimized.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(\"minimize\", guess) tuple suitable for use in State.initial, State.final, or Time.initial, Time.final.</p> Example <pre><code>time = ox.Time(\n    initial=0.0,\n    final=ox.Minimize(10.0),  # Minimize final time\n    min=0.0,\n    max=20.0\n)\n\nfuel = ox.State(\"fuel\", (1,))\nfuel.final = [ox.Minimize(0)]  # Minimize final fuel consumption\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def Minimize(guess):\n    \"\"\"Create a minimize boundary condition tuple.\n\n    This is a convenience function that returns a tuple (\"minimize\", guess) which\n    can be used to specify that a boundary value should be minimized in the objective\n    function for State or Time objects.\n\n    Args:\n        guess: Initial guess value for the variable to be minimized.\n\n    Returns:\n        tuple: (\"minimize\", guess) tuple suitable for use in State.initial, State.final,\n            or Time.initial, Time.final.\n\n    Example:\n        ```python\n        time = ox.Time(\n            initial=0.0,\n            final=ox.Minimize(10.0),  # Minimize final time\n            min=0.0,\n            max=20.0\n        )\n\n        fuel = ox.State(\"fuel\", (1,))\n        fuel.final = [ox.Minimize(0)]  # Minimize final fuel consumption\n        ```\n    \"\"\"\n    return (\"minimize\", guess)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.ctcs","title":"<code>ctcs(constraint: Constraint, penalty: str = 'squared_relu', nodes: Optional[Tuple[int, int]] = None, idx: Optional[int] = None, check_nodally: bool = False) -&gt; CTCS</code>","text":"<p>Helper function to create CTCS (Continuous-Time Constraint Satisfaction) constraints.</p> <p>This is a convenience function that creates a CTCS constraint with the same parameters as the CTCS constructor. Useful for functional-style constraint building.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>Constraint</code> <p>The Constraint to enforce continuously</p> required <code>penalty</code> <code>str</code> <p>Penalty function type ('squared_relu', 'huber', or 'smooth_relu'). Defaults to 'squared_relu'.</p> <code>'squared_relu'</code> <code>nodes</code> <code>Optional[Tuple[int, int]]</code> <p>Optional (start, end) tuple of node indices for enforcement interval. None enforces over entire trajectory.</p> <code>None</code> <code>idx</code> <code>Optional[int]</code> <p>Optional grouping index for multiple augmented states</p> <code>None</code> <code>check_nodally</code> <code>bool</code> <p>Whether to also enforce constraint at discrete nodes. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>CTCS</code> <code>CTCS</code> <p>A CTCS constraint wrapping the input constraint</p> Example <p>Using the helper function:</p> <pre><code>from openscvx.symbolic.expr.constraint import ctcs\naltitude_constraint = ctcs(\n    altitude &gt;= 10,\n    penalty=\"huber\",\n    nodes=(0, 100),\n    check_nodally=True\n)\n</code></pre> <p>Equivalent to using CTCS constructor:</p> <pre><code>altitude_constraint = CTCS(altitude &gt;= 10, penalty=\"huber\", nodes=(0, 100))\n</code></pre> <p>Also equivalent to using .over() method on constraint:</p> <pre><code>altitude_constraint = (altitude &gt;= 10).over((0, 100), penalty=\"huber\")\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def ctcs(\n    constraint: Constraint,\n    penalty: str = \"squared_relu\",\n    nodes: Optional[Tuple[int, int]] = None,\n    idx: Optional[int] = None,\n    check_nodally: bool = False,\n) -&gt; CTCS:\n    \"\"\"Helper function to create CTCS (Continuous-Time Constraint Satisfaction) constraints.\n\n    This is a convenience function that creates a CTCS constraint with the same\n    parameters as the CTCS constructor. Useful for functional-style constraint building.\n\n    Args:\n        constraint: The Constraint to enforce continuously\n        penalty: Penalty function type ('squared_relu', 'huber', or 'smooth_relu').\n            Defaults to 'squared_relu'.\n        nodes: Optional (start, end) tuple of node indices for enforcement interval.\n            None enforces over entire trajectory.\n        idx: Optional grouping index for multiple augmented states\n        check_nodally: Whether to also enforce constraint at discrete nodes.\n            Defaults to False.\n\n    Returns:\n        CTCS: A CTCS constraint wrapping the input constraint\n\n    Example:\n        Using the helper function:\n\n            from openscvx.symbolic.expr.constraint import ctcs\n            altitude_constraint = ctcs(\n                altitude &gt;= 10,\n                penalty=\"huber\",\n                nodes=(0, 100),\n                check_nodally=True\n            )\n\n        Equivalent to using CTCS constructor:\n\n            altitude_constraint = CTCS(altitude &gt;= 10, penalty=\"huber\", nodes=(0, 100))\n\n        Also equivalent to using .over() method on constraint:\n\n            altitude_constraint = (altitude &gt;= 10).over((0, 100), penalty=\"huber\")\n    \"\"\"\n    return CTCS(constraint, penalty, nodes, idx, check_nodally)\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.to_expr","title":"<code>to_expr(x: Union[Expr, float, int, np.ndarray]) -&gt; Expr</code>","text":"<p>Convert a value to an Expr if it is not already one.</p> <p>This is a convenience function that wraps numeric values and arrays as Constant expressions, while leaving Expr instances unchanged. Used internally by operators to ensure operands are proper Expr objects.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[Expr, float, int, ndarray]</code> <p>Value to convert - can be an Expr, numeric scalar, or numpy array</p> required <p>Returns:</p> Type Description <code>Expr</code> <p>The input if it's already an Expr, otherwise a Constant wrapping the value</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def to_expr(x: Union[Expr, float, int, np.ndarray]) -&gt; Expr:\n    \"\"\"Convert a value to an Expr if it is not already one.\n\n    This is a convenience function that wraps numeric values and arrays as Constant\n    expressions, while leaving Expr instances unchanged. Used internally by operators\n    to ensure operands are proper Expr objects.\n\n    Args:\n        x: Value to convert - can be an Expr, numeric scalar, or numpy array\n\n    Returns:\n        The input if it's already an Expr, otherwise a Constant wrapping the value\n    \"\"\"\n    return x if isinstance(x, Expr) else Constant(np.array(x))\n</code></pre>"},{"location":"reference/symbolic/expr/#openscvx.symbolic.expr.traverse","title":"<code>traverse(expr: Expr, visit: Callable[[Expr], None])</code>","text":"<p>Depth-first traversal of an expression tree.</p> <p>Visits each node in the expression tree by applying the visit function to the current node, then recursively visiting all children.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Root expression node to start traversal from</p> required <code>visit</code> <code>Callable[[Expr], None]</code> <p>Callback function applied to each node during traversal</p> required Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def traverse(expr: Expr, visit: Callable[[Expr], None]):\n    \"\"\"Depth-first traversal of an expression tree.\n\n    Visits each node in the expression tree by applying the visit function to the\n    current node, then recursively visiting all children.\n\n    Args:\n        expr: Root expression node to start traversal from\n        visit: Callback function applied to each node during traversal\n    \"\"\"\n    visit(expr)\n    for child in expr.children():\n        traverse(child, visit)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/","title":"arithmetic","text":"<p>Arithmetic operations for symbolic expressions.</p> <p>This module provides fundamental arithmetic operations that form the building blocks of symbolic expressions in openscvx. These operations are created automatically through operator overloading on Expr objects.</p> <p>Arithmetic Operations:</p> <ul> <li>Binary operations: <code>Add</code>, <code>Sub</code>, <code>Mul</code>, <code>Div</code>, <code>MatMul</code>, <code>Power</code> - Standard arithmetic</li> <li>Unary operations: <code>Neg</code> - Negation (unary minus)</li> </ul> <p>All arithmetic operations support: - Automatic canonicalization (constant folding, identity elimination, flattening) - Broadcasting following NumPy rules (except MatMul which follows linear algebra rules) - Shape checking and validation</p> Example <p>Arithmetic operations are created via operator overloading::</p> <pre><code>import openscvx as ox\n\nx = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(3,))\n\n# Element-wise operations\nz = x + y           # Creates Add(x, y)\nw = x * 2           # Creates Mul(x, Constant(2))\nneg_x = -x          # Creates Neg(x)\n\n# Matrix multiplication\nA = ox.State(\"A\", shape=(3, 3))\nb = A @ x           # Creates MatMul(A, x)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Add","title":"<code>Add</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Addition operation for symbolic expressions.</p> <p>Represents element-wise addition of two or more expressions. Supports broadcasting following NumPy rules. Can be created using the + operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>terms</code> <p>List of expression operands to add together</p> Example <p>Define an Add expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(3,))\nz = x + y + 5  # Creates Add(x, y, Constant(5))\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Add(Expr):\n    \"\"\"Addition operation for symbolic expressions.\n\n    Represents element-wise addition of two or more expressions. Supports broadcasting\n    following NumPy rules. Can be created using the + operator on Expr objects.\n\n    Attributes:\n        terms: List of expression operands to add together\n\n    Example:\n        Define an Add expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(3,))\n            z = x + y + 5  # Creates Add(x, y, Constant(5))\n    \"\"\"\n\n    def __init__(self, *args):\n        \"\"\"Initialize an addition operation.\n\n        Args:\n            *args: Two or more expressions to add together\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(args) &lt; 2:\n            raise ValueError(\"Add requires two or more operands\")\n        self.terms = [to_expr(a) for a in args]\n\n    def children(self):\n        return list(self.terms)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize addition: flatten, fold constants, and eliminate zeros.\n\n        Returns:\n            Expr: Canonical form of the addition expression\n        \"\"\"\n        terms = []\n        const_vals = []\n\n        for t in self.terms:\n            c = t.canonicalize()\n            if isinstance(c, Add):\n                terms.extend(c.terms)\n            elif isinstance(c, Constant):\n                const_vals.append(c.value)\n            else:\n                terms.append(c)\n\n        if const_vals:\n            total = sum(const_vals)\n            # If not all-zero, keep it\n            if not (isinstance(total, np.ndarray) and np.all(total == 0)):\n                terms.append(Constant(total))\n\n        if not terms:\n            return Constant(np.array(0))\n        if len(terms) == 1:\n            return terms[0]\n        return Add(*terms)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n        Returns:\n            tuple: The broadcasted shape of all operands\n\n        Raises:\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Add shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        inner = \" + \".join(repr(e) for e in self.terms)\n        return f\"({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Add.__init__","title":"<code>__init__(*args)</code>","text":"<p>Initialize an addition operation.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Two or more expressions to add together</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two operands are provided</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def __init__(self, *args):\n    \"\"\"Initialize an addition operation.\n\n    Args:\n        *args: Two or more expressions to add together\n\n    Raises:\n        ValueError: If fewer than two operands are provided\n    \"\"\"\n    if len(args) &lt; 2:\n        raise ValueError(\"Add requires two or more operands\")\n    self.terms = [to_expr(a) for a in args]\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Add.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize addition: flatten, fold constants, and eliminate zeros.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the addition expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize addition: flatten, fold constants, and eliminate zeros.\n\n    Returns:\n        Expr: Canonical form of the addition expression\n    \"\"\"\n    terms = []\n    const_vals = []\n\n    for t in self.terms:\n        c = t.canonicalize()\n        if isinstance(c, Add):\n            terms.extend(c.terms)\n        elif isinstance(c, Constant):\n            const_vals.append(c.value)\n        else:\n            terms.append(c)\n\n    if const_vals:\n        total = sum(const_vals)\n        # If not all-zero, keep it\n        if not (isinstance(total, np.ndarray) and np.all(total == 0)):\n            terms.append(Constant(total))\n\n    if not terms:\n        return Constant(np.array(0))\n    if len(terms) == 1:\n        return terms[0]\n    return Add(*terms)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Add.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check shape compatibility and compute broadcasted result shape like NumPy.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The broadcasted shape of all operands</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n    Returns:\n        tuple: The broadcasted shape of all operands\n\n    Raises:\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Add shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Div","title":"<code>Div</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise division operation for symbolic expressions.</p> <p>Represents element-wise division (left / right). Supports broadcasting following NumPy rules. Can be created using the / operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>left</code> <p>Numerator expression</p> <code>right</code> <p>Denominator expression</p> Example <p>Define a Div expression</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(3,))\nz = x / y  # Creates Div(x, y)\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Div(Expr):\n    \"\"\"Element-wise division operation for symbolic expressions.\n\n    Represents element-wise division (left / right). Supports broadcasting\n    following NumPy rules. Can be created using the / operator on Expr objects.\n\n    Attributes:\n        left: Numerator expression\n        right: Denominator expression\n\n    Example:\n        Define a Div expression\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(3,))\n            z = x / y  # Creates Div(x, y)\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\"Initialize a division operation.\n\n        Args:\n            left: Expression for the numerator\n            right: Expression for the denominator\n        \"\"\"\n        self.left = left\n        self.right = right\n\n    def children(self):\n        return [self.left, self.right]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize division: fold constants if both sides are constants.\n\n        Returns:\n            Expr: Canonical form of the division expression\n        \"\"\"\n        lhs = self.left.canonicalize()\n        rhs = self.right.canonicalize()\n        if isinstance(lhs, Constant) and isinstance(rhs, Constant):\n            return Constant(lhs.value / rhs.value)\n        return Div(lhs, rhs)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n        Returns:\n            tuple: The broadcasted shape of both operands\n\n        Raises:\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Div shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        return f\"({self.left!r} / {self.right!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Div.__init__","title":"<code>__init__(left, right)</code>","text":"<p>Initialize a division operation.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <p>Expression for the numerator</p> required <code>right</code> <p>Expression for the denominator</p> required Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def __init__(self, left, right):\n    \"\"\"Initialize a division operation.\n\n    Args:\n        left: Expression for the numerator\n        right: Expression for the denominator\n    \"\"\"\n    self.left = left\n    self.right = right\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Div.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize division: fold constants if both sides are constants.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the division expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize division: fold constants if both sides are constants.\n\n    Returns:\n        Expr: Canonical form of the division expression\n    \"\"\"\n    lhs = self.left.canonicalize()\n    rhs = self.right.canonicalize()\n    if isinstance(lhs, Constant) and isinstance(rhs, Constant):\n        return Constant(lhs.value / rhs.value)\n    return Div(lhs, rhs)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Div.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check shape compatibility and compute broadcasted result shape like NumPy.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The broadcasted shape of both operands</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n    Returns:\n        tuple: The broadcasted shape of both operands\n\n    Raises:\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Div shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.MatMul","title":"<code>MatMul</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Matrix multiplication operation for symbolic expressions.</p> <p>Represents matrix multiplication following standard linear algebra rules. Can be created using the @ operator on Expr objects. Handles: - Matrix @ Matrix: (m,n) @ (n,k) -&gt; (m,k) - Matrix @ Vector: (m,n) @ (n,) -&gt; (m,) - Vector @ Matrix: (m,) @ (m,n) -&gt; (n,) - Vector @ Vector: (m,) @ (m,) -&gt; scalar</p> <p>Attributes:</p> Name Type Description <code>left</code> <p>Left-hand side expression</p> <code>right</code> <p>Right-hand side expression</p> Example <p>Define a MatMul expression:</p> <pre><code>A = ox.State(\"A\", shape=(3, 4))\nx = ox.State(\"x\", shape=(4,))\ny = A @ x  # Creates MatMul(A, x), result shape (3,)\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class MatMul(Expr):\n    \"\"\"Matrix multiplication operation for symbolic expressions.\n\n    Represents matrix multiplication following standard linear algebra rules.\n    Can be created using the @ operator on Expr objects. Handles:\n    - Matrix @ Matrix: (m,n) @ (n,k) -&gt; (m,k)\n    - Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n    - Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n    - Vector @ Vector: (m,) @ (m,) -&gt; scalar\n\n    Attributes:\n        left: Left-hand side expression\n        right: Right-hand side expression\n\n    Example:\n        Define a MatMul expression:\n\n            A = ox.State(\"A\", shape=(3, 4))\n            x = ox.State(\"x\", shape=(4,))\n            y = A @ x  # Creates MatMul(A, x), result shape (3,)\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\"Initialize a matrix multiplication operation.\n\n        Args:\n            left: Left-hand side expression for matrix multiplication\n            right: Right-hand side expression for matrix multiplication\n        \"\"\"\n        self.left = left\n        self.right = right\n\n    def children(self):\n        return [self.left, self.right]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        left = self.left.canonicalize()\n        right = self.right.canonicalize()\n        return MatMul(left, right)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check matrix multiplication shape compatibility and return result shape.\"\"\"\n        L, R = self.left.check_shape(), self.right.check_shape()\n\n        # Handle different matmul cases:\n        # Matrix @ Matrix: (m,n) @ (n,k) -&gt; (m,k)\n        # Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n        # Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n        # Vector @ Vector: (m,) @ (m,) -&gt; ()\n\n        if len(L) == 0 or len(R) == 0:\n            raise ValueError(f\"MatMul requires at least 1D operands: {L} @ {R}\")\n\n        if len(L) == 1 and len(R) == 1:\n            # Vector @ Vector -&gt; scalar\n            if L[0] != R[0]:\n                raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n            return ()\n        elif len(L) == 1:\n            # Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n            if len(R) &lt; 2 or L[0] != R[-2]:\n                raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n            return R[-1:]\n        elif len(R) == 1:\n            # Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n            if len(L) &lt; 2 or L[-1] != R[0]:\n                raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n            return L[:-1]\n        else:\n            # Matrix @ Matrix: (...,m,n) @ (...,n,k) -&gt; (...,m,k)\n            if len(L) &lt; 2 or len(R) &lt; 2 or L[-1] != R[-2]:\n                raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n            return L[:-1] + (R[-1],)\n\n    def __repr__(self):\n        return f\"({self.left!r} * {self.right!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.MatMul.__init__","title":"<code>__init__(left, right)</code>","text":"<p>Initialize a matrix multiplication operation.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <p>Left-hand side expression for matrix multiplication</p> required <code>right</code> <p>Right-hand side expression for matrix multiplication</p> required Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def __init__(self, left, right):\n    \"\"\"Initialize a matrix multiplication operation.\n\n    Args:\n        left: Left-hand side expression for matrix multiplication\n        right: Right-hand side expression for matrix multiplication\n    \"\"\"\n    self.left = left\n    self.right = right\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.MatMul.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check matrix multiplication shape compatibility and return result shape.</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check matrix multiplication shape compatibility and return result shape.\"\"\"\n    L, R = self.left.check_shape(), self.right.check_shape()\n\n    # Handle different matmul cases:\n    # Matrix @ Matrix: (m,n) @ (n,k) -&gt; (m,k)\n    # Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n    # Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n    # Vector @ Vector: (m,) @ (m,) -&gt; ()\n\n    if len(L) == 0 or len(R) == 0:\n        raise ValueError(f\"MatMul requires at least 1D operands: {L} @ {R}\")\n\n    if len(L) == 1 and len(R) == 1:\n        # Vector @ Vector -&gt; scalar\n        if L[0] != R[0]:\n            raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n        return ()\n    elif len(L) == 1:\n        # Vector @ Matrix: (m,) @ (m,n) -&gt; (n,)\n        if len(R) &lt; 2 or L[0] != R[-2]:\n            raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n        return R[-1:]\n    elif len(R) == 1:\n        # Matrix @ Vector: (m,n) @ (n,) -&gt; (m,)\n        if len(L) &lt; 2 or L[-1] != R[0]:\n            raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n        return L[:-1]\n    else:\n        # Matrix @ Matrix: (...,m,n) @ (...,n,k) -&gt; (...,m,k)\n        if len(L) &lt; 2 or len(R) &lt; 2 or L[-1] != R[-2]:\n            raise ValueError(f\"MatMul incompatible: {L} @ {R}\")\n        return L[:-1] + (R[-1],)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Mul","title":"<code>Mul</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise multiplication operation for symbolic expressions.</p> <p>Represents element-wise (Hadamard) multiplication of two or more expressions. Supports broadcasting following NumPy rules. Can be created using the * operator on Expr objects. For matrix multiplication, use MatMul or the @ operator.</p> <p>Attributes:</p> Name Type Description <code>factors</code> <p>List of expression operands to multiply together</p> Example <p>Define a Mul expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(3,))\nz = x * y * 2  # Creates Mul(x, y, Constant(2))\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Mul(Expr):\n    \"\"\"Element-wise multiplication operation for symbolic expressions.\n\n    Represents element-wise (Hadamard) multiplication of two or more expressions.\n    Supports broadcasting following NumPy rules. Can be created using the * operator\n    on Expr objects. For matrix multiplication, use MatMul or the @ operator.\n\n    Attributes:\n        factors: List of expression operands to multiply together\n\n    Example:\n        Define a Mul expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(3,))\n            z = x * y * 2  # Creates Mul(x, y, Constant(2))\n    \"\"\"\n\n    def __init__(self, *args):\n        \"\"\"Initialize an element-wise multiplication operation.\n\n        Args:\n            *args: Two or more expressions to multiply together\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(args) &lt; 2:\n            raise ValueError(\"Mul requires two or more operands\")\n        self.factors = [to_expr(a) for a in args]\n\n    def children(self):\n        return list(self.factors)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize multiplication: flatten, fold constants, and eliminating ones.\n\n        Returns:\n            Expr: Canonical form of the multiplication expression\n        \"\"\"\n        factors = []\n        const_vals = []\n\n        for f in self.factors:\n            c = f.canonicalize()\n            if isinstance(c, Mul):\n                factors.extend(c.factors)\n            elif isinstance(c, Constant):\n                const_vals.append(c.value)\n            else:\n                factors.append(c)\n\n        if const_vals:\n            # Multiply constants element-wise (broadcasting), not reducing with prod\n            prod = const_vals[0]\n            for val in const_vals[1:]:\n                prod = prod * val\n\n            # If prod != 1, keep it\n            # Check both scalar and array cases\n            is_identity = False\n            if isinstance(prod, np.ndarray):\n                is_identity = np.all(prod == 1)\n            else:\n                is_identity = prod == 1\n\n            if not is_identity:\n                factors.append(Constant(prod))\n\n        if not factors:\n            return Constant(np.array(1))\n        if len(factors) == 1:\n            return factors[0]\n        return Mul(*factors)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n\n        Returns:\n            tuple: The broadcasted shape of all operands\n\n        Raises:\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Mul shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        inner = \" * \".join(repr(e) for e in self.factors)\n        return f\"({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Mul.__init__","title":"<code>__init__(*args)</code>","text":"<p>Initialize an element-wise multiplication operation.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Two or more expressions to multiply together</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two operands are provided</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def __init__(self, *args):\n    \"\"\"Initialize an element-wise multiplication operation.\n\n    Args:\n        *args: Two or more expressions to multiply together\n\n    Raises:\n        ValueError: If fewer than two operands are provided\n    \"\"\"\n    if len(args) &lt; 2:\n        raise ValueError(\"Mul requires two or more operands\")\n    self.factors = [to_expr(a) for a in args]\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Mul.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize multiplication: flatten, fold constants, and eliminating ones.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the multiplication expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize multiplication: flatten, fold constants, and eliminating ones.\n\n    Returns:\n        Expr: Canonical form of the multiplication expression\n    \"\"\"\n    factors = []\n    const_vals = []\n\n    for f in self.factors:\n        c = f.canonicalize()\n        if isinstance(c, Mul):\n            factors.extend(c.factors)\n        elif isinstance(c, Constant):\n            const_vals.append(c.value)\n        else:\n            factors.append(c)\n\n    if const_vals:\n        # Multiply constants element-wise (broadcasting), not reducing with prod\n        prod = const_vals[0]\n        for val in const_vals[1:]:\n            prod = prod * val\n\n        # If prod != 1, keep it\n        # Check both scalar and array cases\n        is_identity = False\n        if isinstance(prod, np.ndarray):\n            is_identity = np.all(prod == 1)\n        else:\n            is_identity = prod == 1\n\n        if not is_identity:\n            factors.append(Constant(prod))\n\n    if not factors:\n        return Constant(np.array(1))\n    if len(factors) == 1:\n        return factors[0]\n    return Mul(*factors)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Mul.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check shape compatibility and compute broadcasted result shape like NumPy.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The broadcasted shape of all operands</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n\n    Returns:\n        tuple: The broadcasted shape of all operands\n\n    Raises:\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Mul shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Neg","title":"<code>Neg</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Negation operation for symbolic expressions.</p> <p>Represents element-wise negation (unary minus). Can be created using the unary - operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to negate</p> Example <p>Define a Neg expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = -x  # Creates Neg(x)\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Neg(Expr):\n    \"\"\"Negation operation for symbolic expressions.\n\n    Represents element-wise negation (unary minus). Can be created using the\n    unary - operator on Expr objects.\n\n    Attributes:\n        operand: Expression to negate\n\n    Example:\n        Define a Neg expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = -x  # Creates Neg(x)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a negation operation.\n\n        Args:\n            operand: Expression to negate\n        \"\"\"\n        self.operand = operand\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize negation: fold constant negations.\n\n        Returns:\n            Expr: Canonical form of the negation expression\n        \"\"\"\n        o = self.operand.canonicalize()\n        if isinstance(o, Constant):\n            return Constant(-o.value)\n        return Neg(o)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Negation preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"(-{self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Neg.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a negation operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to negate</p> required Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a negation operation.\n\n    Args:\n        operand: Expression to negate\n    \"\"\"\n    self.operand = operand\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Neg.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize negation: fold constant negations.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the negation expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize negation: fold constant negations.\n\n    Returns:\n        Expr: Canonical form of the negation expression\n    \"\"\"\n    o = self.operand.canonicalize()\n    if isinstance(o, Constant):\n        return Constant(-o.value)\n    return Neg(o)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Neg.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Negation preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Negation preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Power","title":"<code>Power</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise power operation for symbolic expressions.</p> <p>Represents element-wise exponentiation (base ** exponent). Supports broadcasting following NumPy rules. Can be created using the ** operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>base</code> <p>Base expression</p> <code>exponent</code> <p>Exponent expression</p> Example <p>Define a Power expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = x ** 2  # Creates Power(x, Constant(2))\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Power(Expr):\n    \"\"\"Element-wise power operation for symbolic expressions.\n\n    Represents element-wise exponentiation (base ** exponent). Supports broadcasting\n    following NumPy rules. Can be created using the ** operator on Expr objects.\n\n    Attributes:\n        base: Base expression\n        exponent: Exponent expression\n\n    Example:\n        Define a Power expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = x ** 2  # Creates Power(x, Constant(2))\n    \"\"\"\n\n    def __init__(self, base, exponent):\n        \"\"\"Initialize a power operation.\n\n        Args:\n            base: Base expression\n            exponent: Exponent expression\n        \"\"\"\n        self.base = to_expr(base)\n        self.exponent = to_expr(exponent)\n\n    def children(self):\n        return [self.base, self.exponent]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize power by canonicalizing base and exponent.\n\n        Returns:\n            Expr: Canonical form of the power expression\n        \"\"\"\n        base = self.base.canonicalize()\n        exponent = self.exponent.canonicalize()\n        return Power(base, exponent)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Power shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        return f\"({self.base!r})**({self.exponent!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Power.__init__","title":"<code>__init__(base, exponent)</code>","text":"<p>Initialize a power operation.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <p>Base expression</p> required <code>exponent</code> <p>Exponent expression</p> required Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def __init__(self, base, exponent):\n    \"\"\"Initialize a power operation.\n\n    Args:\n        base: Base expression\n        exponent: Exponent expression\n    \"\"\"\n    self.base = to_expr(base)\n    self.exponent = to_expr(exponent)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Power.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize power by canonicalizing base and exponent.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the power expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize power by canonicalizing base and exponent.\n\n    Returns:\n        Expr: Canonical form of the power expression\n    \"\"\"\n    base = self.base.canonicalize()\n    exponent = self.exponent.canonicalize()\n    return Power(base, exponent)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Sub","title":"<code>Sub</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Subtraction operation for symbolic expressions.</p> <p>Represents element-wise subtraction (left - right). Supports broadcasting following NumPy rules. Can be created using the - operator on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>left</code> <p>Left-hand side expression (minuend)</p> <code>right</code> <p>Right-hand side expression (subtrahend)</p> Example <p>Define a Sub expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(3,))\nz = x - y  # Creates Sub(x, y)\n</code></pre> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>class Sub(Expr):\n    \"\"\"Subtraction operation for symbolic expressions.\n\n    Represents element-wise subtraction (left - right). Supports broadcasting\n    following NumPy rules. Can be created using the - operator on Expr objects.\n\n    Attributes:\n        left: Left-hand side expression (minuend)\n        right: Right-hand side expression (subtrahend)\n\n    Example:\n        Define a Sub expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(3,))\n            z = x - y  # Creates Sub(x, y)\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\"Initialize a subtraction operation.\n\n        Args:\n            left: Expression to subtract from (minuend)\n            right: Expression to subtract (subtrahend)\n        \"\"\"\n        self.left = left\n        self.right = right\n\n    def children(self):\n        return [self.left, self.right]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize subtraction: fold constants if both sides are constants.\n\n        Returns:\n            Expr: Canonical form of the subtraction expression\n        \"\"\"\n        left = self.left.canonicalize()\n        right = self.right.canonicalize()\n        if isinstance(left, Constant) and isinstance(right, Constant):\n            return Constant(left.value - right.value)\n        return Sub(left, right)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n        Returns:\n            tuple: The broadcasted shape of all operands\n\n        Raises:\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Sub shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        return f\"({self.left!r} - {self.right!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Sub.__init__","title":"<code>__init__(left, right)</code>","text":"<p>Initialize a subtraction operation.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <p>Expression to subtract from (minuend)</p> required <code>right</code> <p>Expression to subtract (subtrahend)</p> required Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def __init__(self, left, right):\n    \"\"\"Initialize a subtraction operation.\n\n    Args:\n        left: Expression to subtract from (minuend)\n        right: Expression to subtract (subtrahend)\n    \"\"\"\n    self.left = left\n    self.right = right\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Sub.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize subtraction: fold constants if both sides are constants.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the subtraction expression</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize subtraction: fold constants if both sides are constants.\n\n    Returns:\n        Expr: Canonical form of the subtraction expression\n    \"\"\"\n    left = self.left.canonicalize()\n    right = self.right.canonicalize()\n    if isinstance(left, Constant) and isinstance(right, Constant):\n        return Constant(left.value - right.value)\n    return Sub(left, right)\n</code></pre>"},{"location":"reference/symbolic/expr/arithmetic/#openscvx.symbolic.expr.arithmetic.Sub.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check shape compatibility and compute broadcasted result shape like NumPy.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The broadcasted shape of all operands</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/arithmetic.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check shape compatibility and compute broadcasted result shape like NumPy.\n\n    Returns:\n        tuple: The broadcasted shape of all operands\n\n    Raises:\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Sub shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/array/","title":"array","text":"<p>Array manipulation operations for symbolic expressions.</p> <p>This module provides operations for indexing, slicing, concatenating, and stacking symbolic expressions. These are structural operations that manipulate array shapes and combine or extract array elements, as opposed to mathematical transformations.</p> <p>Key Operations:</p> <ul> <li> <p>Indexing and Slicing:</p> <ul> <li><code>Index</code> - NumPy-style indexing and slicing to extract subarrays</li> </ul> </li> <li> <p>Concatenation:</p> <ul> <li><code>Concat</code> - Concatenate expressions along the first dimension (axis 0)</li> </ul> </li> <li> <p>Stacking:</p> <ul> <li><code>Stack</code> - Stack expressions along a new first dimension</li> <li><code>Hstack</code> - Horizontal stacking (along columns for 2D arrays)</li> <li><code>Vstack</code> - Vertical stacking (along rows for 2D arrays)</li> </ul> </li> <li> <p>Block Matrix Construction:</p> <ul> <li><code>Block</code> - Assemble block matrices from nested arrays (like numpy.block)</li> </ul> </li> </ul> <p>All operations follow NumPy conventions for shapes and indexing behavior, enabling familiar array manipulation patterns in symbolic optimization problems.</p> Example <p>Indexing and slicing arrays::</p> <pre><code>import openscvx as ox\n\nx = ox.State(\"x\", shape=(10,))\nfirst_half = x[0:5]      # Slice: Index(x, slice(0, 5))\nelement = x[3]           # Single element: Index(x, 3)\n\nA = ox.State(\"A\", shape=(5, 4))\nrow = A[2, :]            # Extract row\ncol = A[:, 1]            # Extract column\n</code></pre> <p>Concatenating expressions::</p> <pre><code>from openscvx.symbolic.expr.array import Concat\n\nx = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(4,))\ncombined = Concat(x, y)  # Result shape (7,)\n</code></pre> <p>Stacking to build matrices::</p> <pre><code>from openscvx.symbolic.expr.array import Stack, Hstack, Vstack\n\n# Stack vectors into a matrix\nv1 = ox.State(\"v1\", shape=(3,))\nv2 = ox.State(\"v2\", shape=(3,))\nv3 = ox.State(\"v3\", shape=(3,))\nmatrix = Stack([v1, v2, v3])  # Result shape (3, 3)\n\n# Horizontal stacking (concatenate along columns)\nA = ox.State(\"A\", shape=(3, 4))\nB = ox.State(\"B\", shape=(3, 2))\nwide = Hstack([A, B])    # Result shape (3, 6)\n\n# Vertical stacking (concatenate along rows)\nC = ox.State(\"C\", shape=(2, 4))\ntall = Vstack([A, C])    # Result shape (5, 4)\n</code></pre> <p>Building rotation matrices with Block (recommended)::</p> <pre><code>import openscvx as ox\nfrom openscvx.symbolic.expr.array import Block\n\ntheta = ox.Variable(\"theta\", shape=(1,))\nR = Block([\n    [ox.Cos(theta), -ox.Sin(theta)],\n    [ox.Sin(theta),  ox.Cos(theta)]\n])  # 2D rotation matrix, shape (2, 2)\n</code></pre> <p>Building rotation matrices with stacking (alternative)::</p> <pre><code>import openscvx as ox\nfrom openscvx.symbolic.expr.array import Stack, Hstack\n\ntheta = ox.Variable(\"theta\", shape=(1,))\nR = Stack([\n    Hstack([ox.Cos(theta), -ox.Sin(theta)]),\n    Hstack([ox.Sin(theta), ox.Cos(theta)])\n])  # 2D rotation matrix, shape (2, 2)\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Block","title":"<code>Block</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Block matrix/tensor construction from nested arrays of expressions.</p> <p>Assembles a block matrix (or N-D tensor) from a nested list of expressions, analogous to numpy.block(). Each inner list represents a row of blocks, and blocks within the same row are concatenated horizontally, while rows are stacked vertically.</p> <p>This provides a convenient way to construct matrices from sub-expressions without manually nesting Stack/Hstack/Vstack operations.</p> <p>Attributes:</p> Name Type Description <code>blocks</code> <p>Nested list of expressions forming the block structure (each expression can be a scalar, 1D, 2D, or N-D tensor)</p> Example <p>Build a 2D rotation matrix::</p> <pre><code>import openscvx as ox\nfrom openscvx.symbolic.expr.array import Block\n\ntheta = ox.Variable(\"theta\", shape=(1,))\nR = Block([\n    [ox.Cos(theta), -ox.Sin(theta)],\n    [ox.Sin(theta),  ox.Cos(theta)]\n])  # Result shape (2, 2)\n</code></pre> <p>Build a block diagonal matrix::</p> <pre><code>A = ox.State(\"A\", shape=(2, 2))\nB = ox.State(\"B\", shape=(3, 3))\nzeros_23 = ox.Constant(np.zeros((2, 3)))\nzeros_32 = ox.Constant(np.zeros((3, 2)))\nblock_diag = Block([\n    [A, zeros_23],\n    [zeros_32, B]\n])  # Result shape (5, 5)\n</code></pre> <p>Build from scalars and expressions::</p> <pre><code>x = ox.State(\"x\", shape=(1,))\ny = ox.State(\"y\", shape=(1,))\n# Scalars are automatically promoted to 1D arrays\nM = Block([\n    [x, 0],\n    [0, y]\n])  # Result shape (2, 2)\n</code></pre> Note <ul> <li>All blocks in the same row must have the same height (first dimension)</li> <li>All blocks in the same column must have the same width (second dimension)</li> <li>For N-D tensors (3D+), all trailing dimensions must match across all blocks</li> <li>Scalar values and raw Python lists are automatically wrapped via to_expr()</li> <li>1D arrays are treated as row vectors when determining block dimensions</li> <li>N-D tensors are supported for JAX lowering; CVXPy only supports 2D blocks</li> </ul> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Block(Expr):\n    \"\"\"Block matrix/tensor construction from nested arrays of expressions.\n\n    Assembles a block matrix (or N-D tensor) from a nested list of expressions,\n    analogous to numpy.block(). Each inner list represents a row of blocks, and\n    blocks within the same row are concatenated horizontally, while rows are\n    stacked vertically.\n\n    This provides a convenient way to construct matrices from sub-expressions\n    without manually nesting Stack/Hstack/Vstack operations.\n\n    Attributes:\n        blocks: Nested list of expressions forming the block structure (each\n            expression can be a scalar, 1D, 2D, or N-D tensor)\n\n    Example:\n        Build a 2D rotation matrix::\n\n            import openscvx as ox\n            from openscvx.symbolic.expr.array import Block\n\n            theta = ox.Variable(\"theta\", shape=(1,))\n            R = Block([\n                [ox.Cos(theta), -ox.Sin(theta)],\n                [ox.Sin(theta),  ox.Cos(theta)]\n            ])  # Result shape (2, 2)\n\n        Build a block diagonal matrix::\n\n            A = ox.State(\"A\", shape=(2, 2))\n            B = ox.State(\"B\", shape=(3, 3))\n            zeros_23 = ox.Constant(np.zeros((2, 3)))\n            zeros_32 = ox.Constant(np.zeros((3, 2)))\n            block_diag = Block([\n                [A, zeros_23],\n                [zeros_32, B]\n            ])  # Result shape (5, 5)\n\n        Build from scalars and expressions::\n\n            x = ox.State(\"x\", shape=(1,))\n            y = ox.State(\"y\", shape=(1,))\n            # Scalars are automatically promoted to 1D arrays\n            M = Block([\n                [x, 0],\n                [0, y]\n            ])  # Result shape (2, 2)\n\n    Note:\n        - All blocks in the same row must have the same height (first dimension)\n        - All blocks in the same column must have the same width (second dimension)\n        - For N-D tensors (3D+), all trailing dimensions must match across all blocks\n        - Scalar values and raw Python lists are automatically wrapped via to_expr()\n        - 1D arrays are treated as row vectors when determining block dimensions\n        - N-D tensors are supported for JAX lowering; CVXPy only supports 2D blocks\n    \"\"\"\n\n    def __init__(self, blocks):\n        \"\"\"Initialize a block matrix construction.\n\n        Args:\n            blocks: A nested list of expressions. Can be either:\n                    - 2D: [[row1_blocks], [row2_blocks], ...] for multiple rows\n                    - 1D: [block1, block2, ...] for a single row (auto-promoted to [[...]])\n                    Raw values (numbers, lists, numpy arrays) are automatically\n                    converted to Constant expressions.\n\n        Raises:\n            ValueError: If blocks is empty\n        \"\"\"\n        if not blocks:\n            raise ValueError(\"Block requires at least one row\")\n\n        # Auto-promote 1D list to 2D (matching numpy.block behavior)\n        # e.g., Block([a, b]) -&gt; Block([[a, b]])\n        if not isinstance(blocks[0], (list, tuple)):\n            blocks = [blocks]\n\n        # Convert all blocks to expressions\n        self.blocks = [[to_expr(block) for block in row] for row in blocks]\n\n        # Validate consistent row lengths\n        row_lengths = [len(row) for row in self.blocks]\n        if len(set(row_lengths)) &gt; 1:\n            raise ValueError(\n                f\"All rows must have the same number of blocks. Got row lengths: {row_lengths}\"\n            )\n\n    def children(self):\n        \"\"\"Return all block expressions in row-major order.\"\"\"\n        return [block for row in self.blocks for block in row]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize by recursively canonicalizing all blocks.\n\n        If the block contains only a single element ([[a]]), returns the\n        canonicalized element directly to simplify the expression tree.\n        \"\"\"\n        canonical_blocks = [[block.canonicalize() for block in row] for row in self.blocks]\n\n        # Unwrap single-element blocks\n        if len(canonical_blocks) == 1 and len(canonical_blocks[0]) == 1:\n            return canonical_blocks[0][0]\n\n        return Block(canonical_blocks)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Validate block dimensions and compute output shape.\n\n        For 2D blocks, returns (total_rows, total_cols). For N-D blocks,\n        returns the shape after assembling blocks along the first two axes,\n        with trailing dimensions preserved.\n\n        Returns:\n            Tuple representing the assembled block array shape\n\n        Raises:\n            ValueError: If block dimensions are incompatible\n        \"\"\"\n        n_block_rows = len(self.blocks)\n        n_block_cols = len(self.blocks[0])\n\n        # Get shapes of all blocks\n        block_shapes = [[block.check_shape() for block in row] for row in self.blocks]\n\n        # Determine the maximum dimensionality across all blocks\n        max_ndim = max(len(shape) for row in block_shapes for shape in row)\n        max_ndim = max(max_ndim, 2)  # At least 2D for block assembly\n\n        # Normalize shapes: pad to max_ndim by prepending 1s\n        # Scalars () -&gt; (1, 1, ...), 1D (n,) -&gt; (1, n, ...), etc.\n        def normalize_shape(shape):\n            if len(shape) == 0:\n                return (1,) * max_ndim\n            elif len(shape) &lt; max_ndim:\n                # Prepend 1s to match max_ndim\n                return (1,) * (max_ndim - len(shape)) + shape\n            else:\n                return shape\n\n        normalized_shapes = [[normalize_shape(shape) for shape in row] for row in block_shapes]\n\n        # Validate trailing dimensions (dims 2+) match across ALL blocks\n        if max_ndim &gt; 2:\n            trailing_shape = normalized_shapes[0][0][2:]\n            for i, row_shapes in enumerate(normalized_shapes):\n                for j, shape in enumerate(row_shapes):\n                    if shape[2:] != trailing_shape:\n                        raise ValueError(\n                            f\"Block[{i}][{j}] has trailing dimensions {shape[2:]}, \"\n                            f\"but Block[0][0] has {trailing_shape}. \"\n                            f\"All blocks must have matching dimensions beyond the first two.\"\n                        )\n\n        # Compute row heights (first dimension of each row must match)\n        row_heights = []\n        for i, row_shapes in enumerate(normalized_shapes):\n            heights = [s[0] for s in row_shapes]\n            if len(set(heights)) &gt; 1:\n                raise ValueError(\n                    f\"Block row {i} has inconsistent heights: {heights}. \"\n                    f\"All blocks in a row must have the same height.\"\n                )\n            row_heights.append(heights[0])\n\n        # Compute column widths (second dimension of each column must match)\n        col_widths = []\n        for j in range(n_block_cols):\n            widths = [normalized_shapes[i][j][1] for i in range(n_block_rows)]\n            if len(set(widths)) &gt; 1:\n                raise ValueError(\n                    f\"Block column {j} has inconsistent widths: {widths}. \"\n                    f\"All blocks in a column must have the same width.\"\n                )\n            col_widths.append(widths[0])\n\n        total_rows = sum(row_heights)\n        total_cols = sum(col_widths)\n\n        # Return shape with trailing dimensions if present\n        if max_ndim &gt; 2:\n            return (total_rows, total_cols) + normalized_shapes[0][0][2:]\n        return (total_rows, total_cols)\n\n    def __repr__(self):\n        rows_repr = []\n        for row in self.blocks:\n            blocks_repr = \", \".join(repr(block) for block in row)\n            rows_repr.append(f\"[{blocks_repr}]\")\n        inner = \", \".join(rows_repr)\n        return f\"Block([{inner}])\"\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Block.__init__","title":"<code>__init__(blocks)</code>","text":"<p>Initialize a block matrix construction.</p> <p>Parameters:</p> Name Type Description Default <code>blocks</code> <p>A nested list of expressions. Can be either:     - 2D: [[row1_blocks], [row2_blocks], ...] for multiple rows     - 1D: [block1, block2, ...] for a single row (auto-promoted to [[...]])     Raw values (numbers, lists, numpy arrays) are automatically     converted to Constant expressions.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If blocks is empty</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def __init__(self, blocks):\n    \"\"\"Initialize a block matrix construction.\n\n    Args:\n        blocks: A nested list of expressions. Can be either:\n                - 2D: [[row1_blocks], [row2_blocks], ...] for multiple rows\n                - 1D: [block1, block2, ...] for a single row (auto-promoted to [[...]])\n                Raw values (numbers, lists, numpy arrays) are automatically\n                converted to Constant expressions.\n\n    Raises:\n        ValueError: If blocks is empty\n    \"\"\"\n    if not blocks:\n        raise ValueError(\"Block requires at least one row\")\n\n    # Auto-promote 1D list to 2D (matching numpy.block behavior)\n    # e.g., Block([a, b]) -&gt; Block([[a, b]])\n    if not isinstance(blocks[0], (list, tuple)):\n        blocks = [blocks]\n\n    # Convert all blocks to expressions\n    self.blocks = [[to_expr(block) for block in row] for row in blocks]\n\n    # Validate consistent row lengths\n    row_lengths = [len(row) for row in self.blocks]\n    if len(set(row_lengths)) &gt; 1:\n        raise ValueError(\n            f\"All rows must have the same number of blocks. Got row lengths: {row_lengths}\"\n        )\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Block.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize by recursively canonicalizing all blocks.</p> <p>If the block contains only a single element ([[a]]), returns the canonicalized element directly to simplify the expression tree.</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize by recursively canonicalizing all blocks.\n\n    If the block contains only a single element ([[a]]), returns the\n    canonicalized element directly to simplify the expression tree.\n    \"\"\"\n    canonical_blocks = [[block.canonicalize() for block in row] for row in self.blocks]\n\n    # Unwrap single-element blocks\n    if len(canonical_blocks) == 1 and len(canonical_blocks[0]) == 1:\n        return canonical_blocks[0][0]\n\n    return Block(canonical_blocks)\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Block.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate block dimensions and compute output shape.</p> <p>For 2D blocks, returns (total_rows, total_cols). For N-D blocks, returns the shape after assembling blocks along the first two axes, with trailing dimensions preserved.</p> <p>Returns:</p> Type Description <code>Tuple[int, ...]</code> <p>Tuple representing the assembled block array shape</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If block dimensions are incompatible</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Validate block dimensions and compute output shape.\n\n    For 2D blocks, returns (total_rows, total_cols). For N-D blocks,\n    returns the shape after assembling blocks along the first two axes,\n    with trailing dimensions preserved.\n\n    Returns:\n        Tuple representing the assembled block array shape\n\n    Raises:\n        ValueError: If block dimensions are incompatible\n    \"\"\"\n    n_block_rows = len(self.blocks)\n    n_block_cols = len(self.blocks[0])\n\n    # Get shapes of all blocks\n    block_shapes = [[block.check_shape() for block in row] for row in self.blocks]\n\n    # Determine the maximum dimensionality across all blocks\n    max_ndim = max(len(shape) for row in block_shapes for shape in row)\n    max_ndim = max(max_ndim, 2)  # At least 2D for block assembly\n\n    # Normalize shapes: pad to max_ndim by prepending 1s\n    # Scalars () -&gt; (1, 1, ...), 1D (n,) -&gt; (1, n, ...), etc.\n    def normalize_shape(shape):\n        if len(shape) == 0:\n            return (1,) * max_ndim\n        elif len(shape) &lt; max_ndim:\n            # Prepend 1s to match max_ndim\n            return (1,) * (max_ndim - len(shape)) + shape\n        else:\n            return shape\n\n    normalized_shapes = [[normalize_shape(shape) for shape in row] for row in block_shapes]\n\n    # Validate trailing dimensions (dims 2+) match across ALL blocks\n    if max_ndim &gt; 2:\n        trailing_shape = normalized_shapes[0][0][2:]\n        for i, row_shapes in enumerate(normalized_shapes):\n            for j, shape in enumerate(row_shapes):\n                if shape[2:] != trailing_shape:\n                    raise ValueError(\n                        f\"Block[{i}][{j}] has trailing dimensions {shape[2:]}, \"\n                        f\"but Block[0][0] has {trailing_shape}. \"\n                        f\"All blocks must have matching dimensions beyond the first two.\"\n                    )\n\n    # Compute row heights (first dimension of each row must match)\n    row_heights = []\n    for i, row_shapes in enumerate(normalized_shapes):\n        heights = [s[0] for s in row_shapes]\n        if len(set(heights)) &gt; 1:\n            raise ValueError(\n                f\"Block row {i} has inconsistent heights: {heights}. \"\n                f\"All blocks in a row must have the same height.\"\n            )\n        row_heights.append(heights[0])\n\n    # Compute column widths (second dimension of each column must match)\n    col_widths = []\n    for j in range(n_block_cols):\n        widths = [normalized_shapes[i][j][1] for i in range(n_block_rows)]\n        if len(set(widths)) &gt; 1:\n            raise ValueError(\n                f\"Block column {j} has inconsistent widths: {widths}. \"\n                f\"All blocks in a column must have the same width.\"\n            )\n        col_widths.append(widths[0])\n\n    total_rows = sum(row_heights)\n    total_cols = sum(col_widths)\n\n    # Return shape with trailing dimensions if present\n    if max_ndim &gt; 2:\n        return (total_rows, total_cols) + normalized_shapes[0][0][2:]\n    return (total_rows, total_cols)\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Block.children","title":"<code>children()</code>","text":"<p>Return all block expressions in row-major order.</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def children(self):\n    \"\"\"Return all block expressions in row-major order.\"\"\"\n    return [block for row in self.blocks for block in row]\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Concat","title":"<code>Concat</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Concatenation operation for symbolic expressions.</p> <p>Concatenates a sequence of expressions along their first dimension. All inputs must have the same rank and matching dimensions except for the first dimension.</p> <p>Attributes:</p> Name Type Description <code>exprs</code> <p>Tuple of expressions to concatenate</p> Example <p>Define a Concat expression:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(4,))\nz = Concat(x, y)  # Creates Concat(x, y), result shape (7,)\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Concat(Expr):\n    \"\"\"Concatenation operation for symbolic expressions.\n\n    Concatenates a sequence of expressions along their first dimension. All inputs\n    must have the same rank and matching dimensions except for the first dimension.\n\n    Attributes:\n        exprs: Tuple of expressions to concatenate\n\n    Example:\n        Define a Concat expression:\n\n            x = ox.State(\"x\", shape=(3,))\n            y = ox.State(\"y\", shape=(4,))\n            z = Concat(x, y)  # Creates Concat(x, y), result shape (7,)\n    \"\"\"\n\n    def __init__(self, *exprs: Expr):\n        \"\"\"Initialize a concatenation operation.\n\n        Args:\n            *exprs: Expressions to concatenate along the first dimension\n        \"\"\"\n        # wrap raw values as Constant if needed\n        self.exprs = [to_expr(e) for e in exprs]\n\n    def children(self):\n        return list(self.exprs)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize concatenation by canonicalizing all operands.\n\n        Returns:\n            Expr: Canonical form of the concatenation expression\n        \"\"\"\n        exprs = [e.canonicalize() for e in self.exprs]\n        return Concat(*exprs)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check concatenation shape compatibility and return result shape.\"\"\"\n        shapes = [e.check_shape() for e in self.exprs]\n        shapes = [(1,) if len(s) == 0 else s for s in shapes]\n        rank = len(shapes[0])\n        if any(len(s) != rank for s in shapes):\n            raise ValueError(f\"Concat rank mismatch: {shapes}\")\n        if any(s[1:] != shapes[0][1:] for s in shapes[1:]):\n            raise ValueError(f\"Concat non-0 dims differ: {shapes}\")\n        return (sum(s[0] for s in shapes),) + shapes[0][1:]\n\n    def __repr__(self):\n        inner = \", \".join(repr(e) for e in self.exprs)\n        return f\"Concat({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Concat.__init__","title":"<code>__init__(*exprs: Expr)</code>","text":"<p>Initialize a concatenation operation.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>Expr</code> <p>Expressions to concatenate along the first dimension</p> <code>()</code> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def __init__(self, *exprs: Expr):\n    \"\"\"Initialize a concatenation operation.\n\n    Args:\n        *exprs: Expressions to concatenate along the first dimension\n    \"\"\"\n    # wrap raw values as Constant if needed\n    self.exprs = [to_expr(e) for e in exprs]\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Concat.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize concatenation by canonicalizing all operands.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the concatenation expression</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize concatenation by canonicalizing all operands.\n\n    Returns:\n        Expr: Canonical form of the concatenation expression\n    \"\"\"\n    exprs = [e.canonicalize() for e in self.exprs]\n    return Concat(*exprs)\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Concat.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check concatenation shape compatibility and return result shape.</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check concatenation shape compatibility and return result shape.\"\"\"\n    shapes = [e.check_shape() for e in self.exprs]\n    shapes = [(1,) if len(s) == 0 else s for s in shapes]\n    rank = len(shapes[0])\n    if any(len(s) != rank for s in shapes):\n        raise ValueError(f\"Concat rank mismatch: {shapes}\")\n    if any(s[1:] != shapes[0][1:] for s in shapes[1:]):\n        raise ValueError(f\"Concat non-0 dims differ: {shapes}\")\n    return (sum(s[0] for s in shapes),) + shapes[0][1:]\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Hstack","title":"<code>Hstack</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Horizontal stacking operation for symbolic expressions.</p> <p>Concatenates expressions horizontally (along columns for 2D arrays). This is analogous to numpy.hstack() or jax.numpy.hstack().</p> <p>Behavior depends on input dimensionality: - 1D arrays: Concatenates along axis 0 (making a longer vector) - 2D arrays: Concatenates along axis 1 (columns), rows must match - Higher-D: Concatenates along axis 1, all other dimensions must match</p> <p>Attributes:</p> Name Type Description <code>arrays</code> <p>List of expressions to stack horizontally</p> Example <p>1D case: concatenate vectors:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(2,))\nh = Hstack([x, y])  # Result shape (5,)\n</code></pre> <p>2D case: concatenate matrices horizontally:</p> <pre><code>A = Variable(\"A\", shape=(3, 4))\nB = Variable(\"B\", shape=(3, 2))\nC = Hstack([A, B])  # Result shape (3, 6)\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Hstack(Expr):\n    \"\"\"Horizontal stacking operation for symbolic expressions.\n\n    Concatenates expressions horizontally (along columns for 2D arrays).\n    This is analogous to numpy.hstack() or jax.numpy.hstack().\n\n    Behavior depends on input dimensionality:\n    - 1D arrays: Concatenates along axis 0 (making a longer vector)\n    - 2D arrays: Concatenates along axis 1 (columns), rows must match\n    - Higher-D: Concatenates along axis 1, all other dimensions must match\n\n    Attributes:\n        arrays: List of expressions to stack horizontally\n\n    Example:\n        1D case: concatenate vectors:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(2,))\n            h = Hstack([x, y])  # Result shape (5,)\n\n        2D case: concatenate matrices horizontally:\n\n            A = Variable(\"A\", shape=(3, 4))\n            B = Variable(\"B\", shape=(3, 2))\n            C = Hstack([A, B])  # Result shape (3, 6)\n    \"\"\"\n\n    def __init__(self, arrays):\n        \"\"\"Initialize a horizontal stack operation.\n\n        Args:\n            arrays: List of expressions to concatenate horizontally\n        \"\"\"\n        self.arrays = [to_expr(arr) for arr in arrays]\n\n    def children(self):\n        return self.arrays\n\n    def canonicalize(self) -&gt; \"Expr\":\n        arrays = [arr.canonicalize() for arr in self.arrays]\n        return Hstack(arrays)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Horizontal stack concatenates arrays along the second axis (columns).\"\"\"\n        if not self.arrays:\n            raise ValueError(\"Hstack requires at least one array\")\n\n        array_shapes = [arr.check_shape() for arr in self.arrays]\n\n        # All arrays must have the same number of dimensions\n        first_ndim = len(array_shapes[0])\n        for i, shape in enumerate(array_shapes[1:], 1):\n            if len(shape) != first_ndim:\n                raise ValueError(\n                    f\"Hstack array {i} has {len(shape)} dimensions, but array 0 has {first_ndim}\"\n                )\n\n        # For 1D arrays, hstack concatenates along axis 0\n        if first_ndim == 1:\n            total_length = sum(shape[0] for shape in array_shapes)\n            return (total_length,)\n\n        # For 2D+ arrays, all dimensions except the second must match\n        first_shape = array_shapes[0]\n        for i, shape in enumerate(array_shapes[1:], 1):\n            if shape[0] != first_shape[0]:\n                raise ValueError(\n                    f\"Hstack array {i} has {shape[0]} rows, but array 0 has {first_shape[0]} rows\"\n                )\n            if shape[2:] != first_shape[2:]:\n                raise ValueError(\n                    f\"Hstack array {i} has trailing dimensions {shape[2:]}, \"\n                    f\"but array 0 has {first_shape[2:]}\"\n                )\n\n        # Result shape: concatenate along axis 1 (columns)\n        total_cols = sum(shape[1] for shape in array_shapes)\n        return (first_shape[0], total_cols) + first_shape[2:]\n\n    def __repr__(self):\n        arrays_repr = \", \".join(repr(arr) for arr in self.arrays)\n        return f\"Hstack([{arrays_repr}])\"\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Hstack.__init__","title":"<code>__init__(arrays)</code>","text":"<p>Initialize a horizontal stack operation.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <p>List of expressions to concatenate horizontally</p> required Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def __init__(self, arrays):\n    \"\"\"Initialize a horizontal stack operation.\n\n    Args:\n        arrays: List of expressions to concatenate horizontally\n    \"\"\"\n    self.arrays = [to_expr(arr) for arr in arrays]\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Hstack.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Horizontal stack concatenates arrays along the second axis (columns).</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Horizontal stack concatenates arrays along the second axis (columns).\"\"\"\n    if not self.arrays:\n        raise ValueError(\"Hstack requires at least one array\")\n\n    array_shapes = [arr.check_shape() for arr in self.arrays]\n\n    # All arrays must have the same number of dimensions\n    first_ndim = len(array_shapes[0])\n    for i, shape in enumerate(array_shapes[1:], 1):\n        if len(shape) != first_ndim:\n            raise ValueError(\n                f\"Hstack array {i} has {len(shape)} dimensions, but array 0 has {first_ndim}\"\n            )\n\n    # For 1D arrays, hstack concatenates along axis 0\n    if first_ndim == 1:\n        total_length = sum(shape[0] for shape in array_shapes)\n        return (total_length,)\n\n    # For 2D+ arrays, all dimensions except the second must match\n    first_shape = array_shapes[0]\n    for i, shape in enumerate(array_shapes[1:], 1):\n        if shape[0] != first_shape[0]:\n            raise ValueError(\n                f\"Hstack array {i} has {shape[0]} rows, but array 0 has {first_shape[0]} rows\"\n            )\n        if shape[2:] != first_shape[2:]:\n            raise ValueError(\n                f\"Hstack array {i} has trailing dimensions {shape[2:]}, \"\n                f\"but array 0 has {first_shape[2:]}\"\n            )\n\n    # Result shape: concatenate along axis 1 (columns)\n    total_cols = sum(shape[1] for shape in array_shapes)\n    return (first_shape[0], total_cols) + first_shape[2:]\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Index","title":"<code>Index</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Indexing and slicing operation for symbolic expressions.</p> <p>Represents indexing or slicing of an expression using NumPy-style indexing. Can be created using square bracket notation on Expr objects.</p> <p>Attributes:</p> Name Type Description <code>base</code> <p>Expression to index into</p> <code>index</code> <p>Index specification (int, slice, or tuple of indices/slices)</p> Example <p>Define an Index expression:</p> <pre><code>x = ox.State(\"x\", shape=(10,))\ny = x[0:5]  # Creates Index(x, slice(0, 5))\nz = x[3]    # Creates Index(x, 3)\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Index(Expr):\n    \"\"\"Indexing and slicing operation for symbolic expressions.\n\n    Represents indexing or slicing of an expression using NumPy-style indexing.\n    Can be created using square bracket notation on Expr objects.\n\n    Attributes:\n        base: Expression to index into\n        index: Index specification (int, slice, or tuple of indices/slices)\n\n    Example:\n        Define an Index expression:\n\n            x = ox.State(\"x\", shape=(10,))\n            y = x[0:5]  # Creates Index(x, slice(0, 5))\n            z = x[3]    # Creates Index(x, 3)\n    \"\"\"\n\n    def __init__(self, base: Expr, index: Union[int, slice, tuple]):\n        \"\"\"Initialize an indexing operation.\n\n        Args:\n            base: Expression to index into\n            index: NumPy-style index (int, slice, or tuple of indices/slices)\n        \"\"\"\n        self.base = base\n        self.index = index\n\n    def children(self):\n        return [self.base]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize index by canonicalizing the base expression.\n\n        Returns:\n            Expr: Canonical form of the indexing expression\n        \"\"\"\n        base = self.base.canonicalize()\n        return Index(base, self.index)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Compute the shape after indexing.\"\"\"\n        base_shape = self.base.check_shape()\n        dummy = np.zeros(base_shape)\n        try:\n            result = dummy[self.index]\n        except Exception as e:\n            raise ValueError(f\"Bad index {self.index} for shape {base_shape}\") from e\n        return result.shape\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Index including its index specification.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Index\")\n        # Hash the index specification (convert to string for generality)\n        hasher.update(repr(self.index).encode())\n        # Hash the base expression\n        self.base._hash_into(hasher)\n\n    def __repr__(self):\n        return f\"{self.base!r}[{self.index!r}]\"\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Index.__init__","title":"<code>__init__(base: Expr, index: Union[int, slice, tuple])</code>","text":"<p>Initialize an indexing operation.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>Expr</code> <p>Expression to index into</p> required <code>index</code> <code>Union[int, slice, tuple]</code> <p>NumPy-style index (int, slice, or tuple of indices/slices)</p> required Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def __init__(self, base: Expr, index: Union[int, slice, tuple]):\n    \"\"\"Initialize an indexing operation.\n\n    Args:\n        base: Expression to index into\n        index: NumPy-style index (int, slice, or tuple of indices/slices)\n    \"\"\"\n    self.base = base\n    self.index = index\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Index.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize index by canonicalizing the base expression.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the indexing expression</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize index by canonicalizing the base expression.\n\n    Returns:\n        Expr: Canonical form of the indexing expression\n    \"\"\"\n    base = self.base.canonicalize()\n    return Index(base, self.index)\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Index.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Compute the shape after indexing.</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Compute the shape after indexing.\"\"\"\n    base_shape = self.base.check_shape()\n    dummy = np.zeros(base_shape)\n    try:\n        result = dummy[self.index]\n    except Exception as e:\n        raise ValueError(f\"Bad index {self.index} for shape {base_shape}\") from e\n    return result.shape\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Stack","title":"<code>Stack</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Stack expressions vertically to create a higher-dimensional array.</p> <p>Stacks a list of expressions along a new first dimension. All input expressions must have the same shape. The result has shape (num_rows, *row_shape).</p> <p>This is similar to numpy.array([row1, row2, ...]) or jax.numpy.stack(rows, axis=0).</p> <p>Attributes:</p> Name Type Description <code>rows</code> <p>List of expressions to stack, each representing a \"row\"</p> Example <p>Leverage stack to combine expressions:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(3,))\nz = Variable(\"z\", shape=(3,))\nstacked = Stack([x, y, z])  # Creates shape (3, 3)\n# Equivalent to: [[x[0], x[1], x[2]],\n#                 [y[0], y[1], y[2]],\n#                 [z[0], z[1], z[2]]]\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Stack(Expr):\n    \"\"\"Stack expressions vertically to create a higher-dimensional array.\n\n    Stacks a list of expressions along a new first dimension. All input expressions\n    must have the same shape. The result has shape (num_rows, *row_shape).\n\n    This is similar to numpy.array([row1, row2, ...]) or jax.numpy.stack(rows, axis=0).\n\n    Attributes:\n        rows: List of expressions to stack, each representing a \"row\"\n\n    Example:\n        Leverage stack to combine expressions:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(3,))\n            z = Variable(\"z\", shape=(3,))\n            stacked = Stack([x, y, z])  # Creates shape (3, 3)\n            # Equivalent to: [[x[0], x[1], x[2]],\n            #                 [y[0], y[1], y[2]],\n            #                 [z[0], z[1], z[2]]]\n    \"\"\"\n\n    def __init__(self, rows):\n        \"\"\"Initialize a stack operation.\n\n        Args:\n            rows: List of expressions to stack along a new first dimension.\n                  All expressions must have the same shape.\n        \"\"\"\n        # rows should be a list of expressions representing each row\n        self.rows = [to_expr(row) for row in rows]\n\n    def children(self):\n        return self.rows\n\n    def canonicalize(self) -&gt; \"Expr\":\n        rows = [row.canonicalize() for row in self.rows]\n        return Stack(rows)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Stack creates a 2D matrix from 1D rows.\"\"\"\n        if not self.rows:\n            raise ValueError(\"Stack requires at least one row\")\n\n        # All rows should have the same shape\n        row_shapes = [row.check_shape() for row in self.rows]\n\n        # Verify all rows have the same shape\n        first_shape = row_shapes[0]\n        for i, shape in enumerate(row_shapes[1:], 1):\n            if shape != first_shape:\n                raise ValueError(\n                    f\"Stack row {i} has shape {shape}, but row 0 has shape {first_shape}\"\n                )\n\n        # Result shape is (num_rows, *row_shape)\n        return (len(self.rows),) + first_shape\n\n    def __repr__(self):\n        rows_repr = \", \".join(repr(row) for row in self.rows)\n        return f\"Stack([{rows_repr}])\"\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Stack.__init__","title":"<code>__init__(rows)</code>","text":"<p>Initialize a stack operation.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <p>List of expressions to stack along a new first dimension.   All expressions must have the same shape.</p> required Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def __init__(self, rows):\n    \"\"\"Initialize a stack operation.\n\n    Args:\n        rows: List of expressions to stack along a new first dimension.\n              All expressions must have the same shape.\n    \"\"\"\n    # rows should be a list of expressions representing each row\n    self.rows = [to_expr(row) for row in rows]\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Stack.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Stack creates a 2D matrix from 1D rows.</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Stack creates a 2D matrix from 1D rows.\"\"\"\n    if not self.rows:\n        raise ValueError(\"Stack requires at least one row\")\n\n    # All rows should have the same shape\n    row_shapes = [row.check_shape() for row in self.rows]\n\n    # Verify all rows have the same shape\n    first_shape = row_shapes[0]\n    for i, shape in enumerate(row_shapes[1:], 1):\n        if shape != first_shape:\n            raise ValueError(\n                f\"Stack row {i} has shape {shape}, but row 0 has shape {first_shape}\"\n            )\n\n    # Result shape is (num_rows, *row_shape)\n    return (len(self.rows),) + first_shape\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Vstack","title":"<code>Vstack</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Vertical stacking operation for symbolic expressions.</p> <p>Concatenates expressions vertically (along rows for 2D arrays). This is analogous to numpy.vstack() or jax.numpy.vstack().</p> <p>All input expressions must have the same number of dimensions, and all dimensions except the first must match. The result concatenates along axis 0 (rows).</p> <p>Attributes:</p> Name Type Description <code>arrays</code> <p>List of expressions to stack vertically</p> Example <p>Stack vectors to create a matrix:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(3,))\nv = Vstack([x, y])  # Result shape (2, 3)\n</code></pre> <p>Stack matrices vertically:</p> <pre><code>A = Variable(\"A\", shape=(3, 4))\nB = Variable(\"B\", shape=(2, 4))\nC = Vstack([A, B])  # Result shape (5, 4)\n</code></pre> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>class Vstack(Expr):\n    \"\"\"Vertical stacking operation for symbolic expressions.\n\n    Concatenates expressions vertically (along rows for 2D arrays).\n    This is analogous to numpy.vstack() or jax.numpy.vstack().\n\n    All input expressions must have the same number of dimensions, and all\n    dimensions except the first must match. The result concatenates along\n    axis 0 (rows).\n\n    Attributes:\n        arrays: List of expressions to stack vertically\n\n    Example:\n        Stack vectors to create a matrix:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(3,))\n            v = Vstack([x, y])  # Result shape (2, 3)\n\n        Stack matrices vertically:\n\n            A = Variable(\"A\", shape=(3, 4))\n            B = Variable(\"B\", shape=(2, 4))\n            C = Vstack([A, B])  # Result shape (5, 4)\n    \"\"\"\n\n    def __init__(self, arrays):\n        \"\"\"Initialize a vertical stack operation.\n\n        Args:\n            arrays: List of expressions to concatenate vertically.\n                    All must have matching dimensions except the first.\n        \"\"\"\n        self.arrays = [to_expr(arr) for arr in arrays]\n\n    def children(self):\n        return self.arrays\n\n    def canonicalize(self) -&gt; \"Expr\":\n        arrays = [arr.canonicalize() for arr in self.arrays]\n        return Vstack(arrays)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Vertical stack concatenates arrays along the first axis (rows).\"\"\"\n        if not self.arrays:\n            raise ValueError(\"Vstack requires at least one array\")\n\n        array_shapes = [arr.check_shape() for arr in self.arrays]\n\n        # All arrays must have the same number of dimensions\n        first_ndim = len(array_shapes[0])\n        for i, shape in enumerate(array_shapes[1:], 1):\n            if len(shape) != first_ndim:\n                raise ValueError(\n                    f\"Vstack array {i} has {len(shape)} dimensions, but array 0 has {first_ndim}\"\n                )\n\n        # All dimensions except the first must match\n        first_shape = array_shapes[0]\n        for i, shape in enumerate(array_shapes[1:], 1):\n            if shape[1:] != first_shape[1:]:\n                raise ValueError(\n                    f\"Vstack array {i} has trailing dimensions {shape[1:]}, \"\n                    f\"but array 0 has {first_shape[1:]}\"\n                )\n\n        # Result shape: concatenate along axis 0 (rows)\n        total_rows = sum(shape[0] for shape in array_shapes)\n        return (total_rows,) + first_shape[1:]\n\n    def __repr__(self):\n        arrays_repr = \", \".join(repr(arr) for arr in self.arrays)\n        return f\"Vstack([{arrays_repr}])\"\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Vstack.__init__","title":"<code>__init__(arrays)</code>","text":"<p>Initialize a vertical stack operation.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <p>List of expressions to concatenate vertically.     All must have matching dimensions except the first.</p> required Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def __init__(self, arrays):\n    \"\"\"Initialize a vertical stack operation.\n\n    Args:\n        arrays: List of expressions to concatenate vertically.\n                All must have matching dimensions except the first.\n    \"\"\"\n    self.arrays = [to_expr(arr) for arr in arrays]\n</code></pre>"},{"location":"reference/symbolic/expr/array/#openscvx.symbolic.expr.array.Vstack.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Vertical stack concatenates arrays along the first axis (rows).</p> Source code in <code>openscvx/symbolic/expr/array.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Vertical stack concatenates arrays along the first axis (rows).\"\"\"\n    if not self.arrays:\n        raise ValueError(\"Vstack requires at least one array\")\n\n    array_shapes = [arr.check_shape() for arr in self.arrays]\n\n    # All arrays must have the same number of dimensions\n    first_ndim = len(array_shapes[0])\n    for i, shape in enumerate(array_shapes[1:], 1):\n        if len(shape) != first_ndim:\n            raise ValueError(\n                f\"Vstack array {i} has {len(shape)} dimensions, but array 0 has {first_ndim}\"\n            )\n\n    # All dimensions except the first must match\n    first_shape = array_shapes[0]\n    for i, shape in enumerate(array_shapes[1:], 1):\n        if shape[1:] != first_shape[1:]:\n            raise ValueError(\n                f\"Vstack array {i} has trailing dimensions {shape[1:]}, \"\n                f\"but array 0 has {first_shape[1:]}\"\n            )\n\n    # Result shape: concatenate along axis 0 (rows)\n    total_rows = sum(shape[0] for shape in array_shapes)\n    return (total_rows,) + first_shape[1:]\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/","title":"constraint","text":"<p>Specialized constraint types for trajectory optimization.</p> <p>This module provides advanced constraint specification mechanisms that extend the basic Equality and Inequality constraints. These specialized constraint types enable precise control over when and how constraints are enforced in discretized trajectory optimization problems.</p> Key constraint types <ul> <li>NodalConstraint: Enforces constraints only at specific discrete time points (nodes) along the trajectory. Useful for waypoint constraints, boundary conditions, and reducing computational cost by selective enforcement.</li> <li>CTCS (Continuous-Time Constraint Satisfaction): Guarantees strict constraint satisfaction throughout the entire continuous trajectory, not just at discrete nodes. Works by augmenting the state vector with additional states whose dynamics integrate constraint violation penalties. Essential for safety-critical applications where inter-node violations could be catastrophic.</li> </ul> Example <p>Nodal constraints for waypoints::</p> <pre><code>import openscvx as ox\n\nx = ox.State(\"x\", shape=(3,))\ntarget = [10, 5, 0]\n\n# Enforce position constraint only at specific nodes\nwaypoint_constraint = (x == target).at([0, 10, 20])\n</code></pre> <p>Continuous-time constraint for obstacle avoidance::</p> <pre><code>obstacle_center = ox.Parameter(\"obs\", shape=(2,), value=[5, 5])\nobstacle_radius = 2.0\n\n# Distance from obstacle must be &gt; radius for ALL time\ndistance = ox.Norm(x[:2] - obstacle_center)\nsafety_constraint = (distance &gt;= obstacle_radius).over((0, 100))\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CTCS","title":"<code>CTCS</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Continuous-Time Constraint Satisfaction using augmented state dynamics.</p> <p>CTCS enables strict continuous-time constraint enforcement in discretized trajectory optimization by augmenting the state vector with additional states whose dynamics are the constraint violation penalties. By constraining these augmented states to remain at zero throughout the trajectory, the original constraints are guaranteed to be satisfied continuously, not just at discrete nodes.</p> <p>How it works:</p> <ol> <li>Each constraint (in canonical form: lhs &lt;= 0) is wrapped in a penalty function</li> <li>Augmented states s_aug_i are added with dynamics: ds_aug_i/dt = sum(penalty_j(lhs_j))    for all CTCS constraints j in group i</li> <li>Each augmented state is constrained: s_aug_i(t) = 0 for all t (strictly enforced)</li> <li>Since s_aug_i integrates the penalties, s_aug_i = 0 implies all penalties in the    group are zero, which means all constraints in the group are satisfied continuously</li> </ol> <p>Grouping and augmented states:</p> <ul> <li>CTCS constraints with the same node interval are grouped into a single augmented   state by default (their penalties are summed)</li> <li>CTCS constraints with different node intervals create separate augmented states</li> <li>Using the <code>idx</code> parameter explicitly assigns constraints to specific augmented states,   allowing manual control over grouping</li> <li>Each unique group creates one augmented state named <code>_ctcs_aug_0</code>, <code>_ctcs_aug_1</code>, etc.</li> </ul> <p>This is particularly useful for:</p> <ul> <li>Path constraints that must hold throughout the entire trajectory (not just at nodes)</li> <li>Obstacle avoidance where constraint violation between nodes could be catastrophic</li> <li>State limits that should be respected continuously (e.g., altitude &gt; 0 for aircraft)</li> <li>Ensuring smooth, feasible trajectories between discretization points</li> </ul> <p>Penalty functions (applied to constraint violations):</p> <ul> <li>squared_relu: Square(PositivePart(lhs)) - smooth, differentiable (default)</li> <li>huber: Huber(PositivePart(lhs)) - less sensitive to outliers than squared</li> <li>smooth_relu: SmoothReLU(lhs) - smooth approximation of ReLU</li> </ul> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (typically Inequality) to enforce continuously</p> <code>penalty</code> <p>Penalty function type ('squared_relu', 'huber', or 'smooth_relu')</p> <code>nodes</code> <p>Optional (start, end) tuple specifying the interval for enforcement, or None to enforce over the entire trajectory</p> <code>idx</code> <p>Optional grouping index for managing multiple augmented states. CTCS constraints with the same idx and nodes are grouped together, sharing an augmented state. If None, auto-assigned based on node intervals.</p> <code>check_nodally</code> <p>Whether to also enforce the constraint at discrete nodes for additional numerical robustness (creates both continuous and nodal constraints)</p> Example <p>Single augmented state (default behavior - same node interval):</p> <pre><code>altitude = State(\"alt\", shape=(1,))\nconstraints = [\n    (altitude &gt;= 10).over((0, 10)),  # Both constraints share\n    (altitude &lt;= 1000).over((0, 10))  # one augmented state\n]\n</code></pre> <p>Multiple augmented states (different node intervals):</p> <pre><code>constraints = [\n    (altitude &gt;= 10).over((0, 5)),  # Creates _ctcs_aug_0\n    (altitude &gt;= 20).over((5, 10))  # Creates _ctcs_aug_1\n]\n</code></pre> <p>Manual grouping with idx parameter:</p> <pre><code>constraints = [\n    (altitude &gt;= 10).over((0, 10), idx=0),    # Group 0\n    (velocity &lt;= 100).over((0, 10), idx=1),   # Group 1 (separate state)\n    (altitude &lt;= 1000).over((0, 10), idx=0)   # Also group 0\n]\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class CTCS(Expr):\n    \"\"\"Continuous-Time Constraint Satisfaction using augmented state dynamics.\n\n    CTCS enables strict continuous-time constraint enforcement in discretized trajectory\n    optimization by augmenting the state vector with additional states whose dynamics\n    are the constraint violation penalties. By constraining these augmented states to remain\n    at zero throughout the trajectory, the original constraints are guaranteed to be satisfied\n    continuously, not just at discrete nodes.\n\n    **How it works:**\n\n    1. Each constraint (in canonical form: lhs &lt;= 0) is wrapped in a penalty function\n    2. Augmented states s_aug_i are added with dynamics: ds_aug_i/dt = sum(penalty_j(lhs_j))\n       for all CTCS constraints j in group i\n    3. Each augmented state is constrained: s_aug_i(t) = 0 for all t (strictly enforced)\n    4. Since s_aug_i integrates the penalties, s_aug_i = 0 implies all penalties in the\n       group are zero, which means all constraints in the group are satisfied continuously\n\n    **Grouping and augmented states:**\n\n    - CTCS constraints with the **same node interval** are grouped into a single augmented\n      state by default (their penalties are summed)\n    - CTCS constraints with **different node intervals** create separate augmented states\n    - Using the `idx` parameter explicitly assigns constraints to specific augmented states,\n      allowing manual control over grouping\n    - Each unique group creates one augmented state named `_ctcs_aug_0`, `_ctcs_aug_1`, etc.\n\n    This is particularly useful for:\n\n    - Path constraints that must hold throughout the entire trajectory (not just at nodes)\n    - Obstacle avoidance where constraint violation between nodes could be catastrophic\n    - State limits that should be respected continuously (e.g., altitude &gt; 0 for aircraft)\n    - Ensuring smooth, feasible trajectories between discretization points\n\n    **Penalty functions** (applied to constraint violations):\n\n    - **squared_relu**: Square(PositivePart(lhs)) - smooth, differentiable (default)\n    - **huber**: Huber(PositivePart(lhs)) - less sensitive to outliers than squared\n    - **smooth_relu**: SmoothReLU(lhs) - smooth approximation of ReLU\n\n    Attributes:\n        constraint: The wrapped Constraint (typically Inequality) to enforce continuously\n        penalty: Penalty function type ('squared_relu', 'huber', or 'smooth_relu')\n        nodes: Optional (start, end) tuple specifying the interval for enforcement,\n            or None to enforce over the entire trajectory\n        idx: Optional grouping index for managing multiple augmented states.\n            CTCS constraints with the same idx and nodes are grouped together, sharing\n            an augmented state. If None, auto-assigned based on node intervals.\n        check_nodally: Whether to also enforce the constraint at discrete nodes for\n            additional numerical robustness (creates both continuous and nodal constraints)\n\n    Example:\n        Single augmented state (default behavior - same node interval):\n\n            altitude = State(\"alt\", shape=(1,))\n            constraints = [\n                (altitude &gt;= 10).over((0, 10)),  # Both constraints share\n                (altitude &lt;= 1000).over((0, 10))  # one augmented state\n            ]\n\n        Multiple augmented states (different node intervals):\n\n            constraints = [\n                (altitude &gt;= 10).over((0, 5)),  # Creates _ctcs_aug_0\n                (altitude &gt;= 20).over((5, 10))  # Creates _ctcs_aug_1\n            ]\n\n        Manual grouping with idx parameter:\n\n            constraints = [\n                (altitude &gt;= 10).over((0, 10), idx=0),    # Group 0\n                (velocity &lt;= 100).over((0, 10), idx=1),   # Group 1 (separate state)\n                (altitude &lt;= 1000).over((0, 10), idx=0)   # Also group 0\n            ]\n    \"\"\"\n\n    def __init__(\n        self,\n        constraint: Constraint,\n        penalty: str = \"squared_relu\",\n        nodes: Optional[Tuple[int, int]] = None,\n        idx: Optional[int] = None,\n        check_nodally: bool = False,\n    ):\n        \"\"\"Initialize a CTCS constraint.\n\n        Args:\n            constraint: The Constraint to enforce continuously (typically an Inequality)\n            penalty: Penalty function type. Options:\n                - 'squared_relu': Square(PositivePart(lhs)) - default, smooth, differentiable\n                - 'huber': Huber(PositivePart(lhs)) - robust to outliers\n                - 'smooth_relu': SmoothReLU(lhs) - smooth ReLU approximation\n            nodes: Optional (start, end) tuple of node indices defining the enforcement interval.\n                None means enforce over the entire trajectory. Must satisfy start &lt; end.\n                CTCS constraints with the same nodes are automatically grouped together.\n            idx: Optional grouping index for multiple augmented states. Allows organizing\n                multiple CTCS constraints with separate augmented state variables.\n                If None, constraints are auto-grouped by their node intervals.\n                Explicitly setting idx allows manual control over which constraints\n                share an augmented state.\n            check_nodally: If True, also enforce the constraint at discrete nodes for\n                numerical stability (creates both continuous and nodal constraints).\n                Defaults to False.\n\n        Raises:\n            TypeError: If constraint is not a Constraint instance\n            ValueError: If nodes is not None or a 2-tuple of integers\n            ValueError: If nodes[0] &gt;= nodes[1] (invalid interval)\n        \"\"\"\n        if not isinstance(constraint, Constraint):\n            raise TypeError(\"CTCS must wrap a Constraint\")\n\n        # Validate nodes parameter for CTCS\n        if nodes is not None:\n            if not isinstance(nodes, tuple) or len(nodes) != 2:\n                raise ValueError(\n                    \"CTCS constraints must specify nodes as a tuple of (start, end) or None \"\n                    \"for all nodes\"\n                )\n            if not all(isinstance(n, int) for n in nodes):\n                raise ValueError(\"CTCS node indices must be integers\")\n            if nodes[0] &gt;= nodes[1]:\n                raise ValueError(\"CTCS node range must have start &lt; end\")\n\n        self.constraint = constraint\n        self.penalty = penalty\n        self.nodes = nodes  # (start, end) node range or None for all nodes\n        self.idx = idx  # Optional grouping index for multiple augmented states\n        # Whether to also enforce this constraint nodally for numerical stability\n        self.check_nodally = check_nodally\n\n    def children(self):\n        \"\"\"Return the wrapped constraint as the only child.\n\n        Returns:\n            list: Single-element list containing the wrapped constraint\n        \"\"\"\n        return [self.constraint]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the inner constraint while preserving CTCS parameters.\n\n        Returns:\n            CTCS: A new CTCS with canonicalized inner constraint and same parameters\n        \"\"\"\n        canon_constraint = self.constraint.canonicalize()\n        return CTCS(\n            canon_constraint,\n            penalty=self.penalty,\n            nodes=self.nodes,\n            idx=self.idx,\n            check_nodally=self.check_nodally,\n        )\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Validate the constraint and penalty expression shapes.\n\n        CTCS transforms the wrapped constraint into a penalty expression that is\n        summed (integrated) over the trajectory, always producing a scalar result.\n\n        Returns:\n            tuple: Empty tuple () representing scalar shape\n\n        Raises:\n            ValueError: If the wrapped constraint has invalid shape\n            ValueError: If the generated penalty expression is not scalar\n        \"\"\"\n        # First validate the wrapped constraint's shape\n        self.constraint.check_shape()\n\n        # Also validate the penalty expression that would be generated\n        try:\n            penalty_expr = self.penalty_expr()\n            penalty_shape = penalty_expr.check_shape()\n\n            # The penalty expression should always be scalar due to Sum wrapper\n            if penalty_shape != ():\n                raise ValueError(\n                    f\"CTCS penalty expression should be scalar, but got shape {penalty_shape}\"\n                )\n        except Exception as e:\n            # Re-raise with more context about which CTCS node failed\n            raise ValueError(f\"CTCS penalty expression validation failed: {e}\") from e\n\n        # CTCS always produces a scalar due to the Sum in penalty_expr\n        return ()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash CTCS including all its parameters.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"CTCS\")\n        # Hash penalty type\n        hasher.update(self.penalty.encode())\n        # Hash nodes interval\n        if self.nodes is not None:\n            hasher.update(struct.pack(\"&gt;ii\", self.nodes[0], self.nodes[1]))\n        else:\n            hasher.update(b\"None\")\n        # Hash idx\n        if self.idx is not None:\n            hasher.update(struct.pack(\"&gt;i\", self.idx))\n        else:\n            hasher.update(b\"None\")\n        # Hash check_nodally\n        hasher.update(b\"1\" if self.check_nodally else b\"0\")\n        # Hash the wrapped constraint\n        self.constraint._hash_into(hasher)\n\n    def over(self, interval: tuple[int, int]) -&gt; \"CTCS\":\n        \"\"\"Set or update the continuous interval for this CTCS constraint.\n\n        Args:\n            interval: Tuple of (start, end) node indices defining the enforcement interval\n\n        Returns:\n            CTCS: New CTCS constraint with the specified interval\n\n        Example:\n            Define constraint over range:\n\n                constraint = (altitude &gt;= 10).over((0, 50))\n\n            Update interval to cover different range:\n\n                constraint_updated = constraint.over((50, 100))\n        \"\"\"\n        return CTCS(\n            self.constraint,\n            penalty=self.penalty,\n            nodes=interval,\n            idx=self.idx,\n            check_nodally=self.check_nodally,\n        )\n\n    def __repr__(self):\n        \"\"\"String representation of the CTCS constraint.\n\n        Returns:\n            str: String showing constraint, penalty type, and optional parameters\n        \"\"\"\n        parts = [f\"{self.constraint!r}\", f\"penalty={self.penalty!r}\"]\n        if self.nodes is not None:\n            parts.append(f\"nodes={self.nodes}\")\n        if self.idx is not None:\n            parts.append(f\"idx={self.idx}\")\n        if self.check_nodally:\n            parts.append(f\"check_nodally={self.check_nodally}\")\n        return f\"CTCS({', '.join(parts)})\"\n\n    def penalty_expr(self) -&gt; Expr:\n        \"\"\"Build the penalty expression for this CTCS constraint.\n\n        Transforms the constraint's left-hand side (in canonical form: lhs &lt;= 0)\n        into a penalty expression using the specified penalty function. The penalty\n        is zero when the constraint is satisfied and positive when violated.\n\n        This penalty expression becomes part of the dynamics of an augmented state.\n        Multiple CTCS constraints in the same group (same idx) have their penalties\n        summed: ds_aug_i/dt = sum(penalty_j) for all j in group i. By constraining\n        s_aug_i(t) = 0 for all t, we ensure all penalties in the group are zero,\n        which strictly enforces all constraints in the group continuously.\n\n        Returns:\n            Expr: Sum of the penalty function applied to the constraint violation\n\n        Raises:\n            ValueError: If an unknown penalty type is specified\n\n        Note:\n            This method is used internally during problem compilation to create\n            augmented state dynamics. Multiple penalty expressions with the same\n            idx are summed together before being added to the dynamics vector via Concat.\n        \"\"\"\n        lhs = self.constraint.lhs\n\n        if self.penalty == \"squared_relu\":\n            from openscvx.symbolic.expr.math import PositivePart, Square\n\n            penalty = Square(PositivePart(lhs))\n        elif self.penalty == \"huber\":\n            from openscvx.symbolic.expr.math import Huber, PositivePart\n\n            penalty = Huber(PositivePart(lhs))\n        elif self.penalty == \"smooth_relu\":\n            from openscvx.symbolic.expr.math import SmoothReLU\n\n            penalty = SmoothReLU(lhs)\n        else:\n            raise ValueError(f\"Unknown penalty {self.penalty!r}\")\n\n        return Sum(penalty)\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CTCS.__init__","title":"<code>__init__(constraint: Constraint, penalty: str = 'squared_relu', nodes: Optional[Tuple[int, int]] = None, idx: Optional[int] = None, check_nodally: bool = False)</code>","text":"<p>Initialize a CTCS constraint.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>Constraint</code> <p>The Constraint to enforce continuously (typically an Inequality)</p> required <code>penalty</code> <code>str</code> <p>Penalty function type. Options: - 'squared_relu': Square(PositivePart(lhs)) - default, smooth, differentiable - 'huber': Huber(PositivePart(lhs)) - robust to outliers - 'smooth_relu': SmoothReLU(lhs) - smooth ReLU approximation</p> <code>'squared_relu'</code> <code>nodes</code> <code>Optional[Tuple[int, int]]</code> <p>Optional (start, end) tuple of node indices defining the enforcement interval. None means enforce over the entire trajectory. Must satisfy start &lt; end. CTCS constraints with the same nodes are automatically grouped together.</p> <code>None</code> <code>idx</code> <code>Optional[int]</code> <p>Optional grouping index for multiple augmented states. Allows organizing multiple CTCS constraints with separate augmented state variables. If None, constraints are auto-grouped by their node intervals. Explicitly setting idx allows manual control over which constraints share an augmented state.</p> <code>None</code> <code>check_nodally</code> <code>bool</code> <p>If True, also enforce the constraint at discrete nodes for numerical stability (creates both continuous and nodal constraints). Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If constraint is not a Constraint instance</p> <code>ValueError</code> <p>If nodes is not None or a 2-tuple of integers</p> <code>ValueError</code> <p>If nodes[0] &gt;= nodes[1] (invalid interval)</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def __init__(\n    self,\n    constraint: Constraint,\n    penalty: str = \"squared_relu\",\n    nodes: Optional[Tuple[int, int]] = None,\n    idx: Optional[int] = None,\n    check_nodally: bool = False,\n):\n    \"\"\"Initialize a CTCS constraint.\n\n    Args:\n        constraint: The Constraint to enforce continuously (typically an Inequality)\n        penalty: Penalty function type. Options:\n            - 'squared_relu': Square(PositivePart(lhs)) - default, smooth, differentiable\n            - 'huber': Huber(PositivePart(lhs)) - robust to outliers\n            - 'smooth_relu': SmoothReLU(lhs) - smooth ReLU approximation\n        nodes: Optional (start, end) tuple of node indices defining the enforcement interval.\n            None means enforce over the entire trajectory. Must satisfy start &lt; end.\n            CTCS constraints with the same nodes are automatically grouped together.\n        idx: Optional grouping index for multiple augmented states. Allows organizing\n            multiple CTCS constraints with separate augmented state variables.\n            If None, constraints are auto-grouped by their node intervals.\n            Explicitly setting idx allows manual control over which constraints\n            share an augmented state.\n        check_nodally: If True, also enforce the constraint at discrete nodes for\n            numerical stability (creates both continuous and nodal constraints).\n            Defaults to False.\n\n    Raises:\n        TypeError: If constraint is not a Constraint instance\n        ValueError: If nodes is not None or a 2-tuple of integers\n        ValueError: If nodes[0] &gt;= nodes[1] (invalid interval)\n    \"\"\"\n    if not isinstance(constraint, Constraint):\n        raise TypeError(\"CTCS must wrap a Constraint\")\n\n    # Validate nodes parameter for CTCS\n    if nodes is not None:\n        if not isinstance(nodes, tuple) or len(nodes) != 2:\n            raise ValueError(\n                \"CTCS constraints must specify nodes as a tuple of (start, end) or None \"\n                \"for all nodes\"\n            )\n        if not all(isinstance(n, int) for n in nodes):\n            raise ValueError(\"CTCS node indices must be integers\")\n        if nodes[0] &gt;= nodes[1]:\n            raise ValueError(\"CTCS node range must have start &lt; end\")\n\n    self.constraint = constraint\n    self.penalty = penalty\n    self.nodes = nodes  # (start, end) node range or None for all nodes\n    self.idx = idx  # Optional grouping index for multiple augmented states\n    # Whether to also enforce this constraint nodally for numerical stability\n    self.check_nodally = check_nodally\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CTCS.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the inner constraint while preserving CTCS parameters.</p> <p>Returns:</p> Name Type Description <code>CTCS</code> <code>Expr</code> <p>A new CTCS with canonicalized inner constraint and same parameters</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the inner constraint while preserving CTCS parameters.\n\n    Returns:\n        CTCS: A new CTCS with canonicalized inner constraint and same parameters\n    \"\"\"\n    canon_constraint = self.constraint.canonicalize()\n    return CTCS(\n        canon_constraint,\n        penalty=self.penalty,\n        nodes=self.nodes,\n        idx=self.idx,\n        check_nodally=self.check_nodally,\n    )\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CTCS.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the constraint and penalty expression shapes.</p> <p>CTCS transforms the wrapped constraint into a penalty expression that is summed (integrated) over the trajectory, always producing a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the wrapped constraint has invalid shape</p> <code>ValueError</code> <p>If the generated penalty expression is not scalar</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Validate the constraint and penalty expression shapes.\n\n    CTCS transforms the wrapped constraint into a penalty expression that is\n    summed (integrated) over the trajectory, always producing a scalar result.\n\n    Returns:\n        tuple: Empty tuple () representing scalar shape\n\n    Raises:\n        ValueError: If the wrapped constraint has invalid shape\n        ValueError: If the generated penalty expression is not scalar\n    \"\"\"\n    # First validate the wrapped constraint's shape\n    self.constraint.check_shape()\n\n    # Also validate the penalty expression that would be generated\n    try:\n        penalty_expr = self.penalty_expr()\n        penalty_shape = penalty_expr.check_shape()\n\n        # The penalty expression should always be scalar due to Sum wrapper\n        if penalty_shape != ():\n            raise ValueError(\n                f\"CTCS penalty expression should be scalar, but got shape {penalty_shape}\"\n            )\n    except Exception as e:\n        # Re-raise with more context about which CTCS node failed\n        raise ValueError(f\"CTCS penalty expression validation failed: {e}\") from e\n\n    # CTCS always produces a scalar due to the Sum in penalty_expr\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CTCS.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def children(self):\n    \"\"\"Return the wrapped constraint as the only child.\n\n    Returns:\n        list: Single-element list containing the wrapped constraint\n    \"\"\"\n    return [self.constraint]\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CTCS.over","title":"<code>over(interval: tuple[int, int]) -&gt; CTCS</code>","text":"<p>Set or update the continuous interval for this CTCS constraint.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>tuple[int, int]</code> <p>Tuple of (start, end) node indices defining the enforcement interval</p> required <p>Returns:</p> Name Type Description <code>CTCS</code> <code>CTCS</code> <p>New CTCS constraint with the specified interval</p> Example <p>Define constraint over range:</p> <pre><code>constraint = (altitude &gt;= 10).over((0, 50))\n</code></pre> <p>Update interval to cover different range:</p> <pre><code>constraint_updated = constraint.over((50, 100))\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def over(self, interval: tuple[int, int]) -&gt; \"CTCS\":\n    \"\"\"Set or update the continuous interval for this CTCS constraint.\n\n    Args:\n        interval: Tuple of (start, end) node indices defining the enforcement interval\n\n    Returns:\n        CTCS: New CTCS constraint with the specified interval\n\n    Example:\n        Define constraint over range:\n\n            constraint = (altitude &gt;= 10).over((0, 50))\n\n        Update interval to cover different range:\n\n            constraint_updated = constraint.over((50, 100))\n    \"\"\"\n    return CTCS(\n        self.constraint,\n        penalty=self.penalty,\n        nodes=interval,\n        idx=self.idx,\n        check_nodally=self.check_nodally,\n    )\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CTCS.penalty_expr","title":"<code>penalty_expr() -&gt; Expr</code>","text":"<p>Build the penalty expression for this CTCS constraint.</p> <p>Transforms the constraint's left-hand side (in canonical form: lhs &lt;= 0) into a penalty expression using the specified penalty function. The penalty is zero when the constraint is satisfied and positive when violated.</p> <p>This penalty expression becomes part of the dynamics of an augmented state. Multiple CTCS constraints in the same group (same idx) have their penalties summed: ds_aug_i/dt = sum(penalty_j) for all j in group i. By constraining s_aug_i(t) = 0 for all t, we ensure all penalties in the group are zero, which strictly enforces all constraints in the group continuously.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Sum of the penalty function applied to the constraint violation</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown penalty type is specified</p> Note <p>This method is used internally during problem compilation to create augmented state dynamics. Multiple penalty expressions with the same idx are summed together before being added to the dynamics vector via Concat.</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def penalty_expr(self) -&gt; Expr:\n    \"\"\"Build the penalty expression for this CTCS constraint.\n\n    Transforms the constraint's left-hand side (in canonical form: lhs &lt;= 0)\n    into a penalty expression using the specified penalty function. The penalty\n    is zero when the constraint is satisfied and positive when violated.\n\n    This penalty expression becomes part of the dynamics of an augmented state.\n    Multiple CTCS constraints in the same group (same idx) have their penalties\n    summed: ds_aug_i/dt = sum(penalty_j) for all j in group i. By constraining\n    s_aug_i(t) = 0 for all t, we ensure all penalties in the group are zero,\n    which strictly enforces all constraints in the group continuously.\n\n    Returns:\n        Expr: Sum of the penalty function applied to the constraint violation\n\n    Raises:\n        ValueError: If an unknown penalty type is specified\n\n    Note:\n        This method is used internally during problem compilation to create\n        augmented state dynamics. Multiple penalty expressions with the same\n        idx are summed together before being added to the dynamics vector via Concat.\n    \"\"\"\n    lhs = self.constraint.lhs\n\n    if self.penalty == \"squared_relu\":\n        from openscvx.symbolic.expr.math import PositivePart, Square\n\n        penalty = Square(PositivePart(lhs))\n    elif self.penalty == \"huber\":\n        from openscvx.symbolic.expr.math import Huber, PositivePart\n\n        penalty = Huber(PositivePart(lhs))\n    elif self.penalty == \"smooth_relu\":\n        from openscvx.symbolic.expr.math import SmoothReLU\n\n        penalty = SmoothReLU(lhs)\n    else:\n        raise ValueError(f\"Unknown penalty {self.penalty!r}\")\n\n    return Sum(penalty)\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.Constraint","title":"<code>Constraint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Abstract base class for optimization constraints.</p> <p>Constraints represent relationships between expressions that must be satisfied in the optimization problem. This base class provides common functionality for both equality and inequality constraints.</p> <p>Attributes:</p> Name Type Description <code>lhs</code> <p>Left-hand side expression</p> <code>rhs</code> <p>Right-hand side expression</p> <code>is_convex</code> <p>Flag indicating if the constraint is known to be convex</p> Note <p>Constraints are canonicalized to standard form: (lhs - rhs) {op} 0</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class Constraint(Expr):\n    \"\"\"Abstract base class for optimization constraints.\n\n    Constraints represent relationships between expressions that must be satisfied\n    in the optimization problem. This base class provides common functionality for\n    both equality and inequality constraints.\n\n    Attributes:\n        lhs: Left-hand side expression\n        rhs: Right-hand side expression\n        is_convex: Flag indicating if the constraint is known to be convex\n\n    Note:\n        Constraints are canonicalized to standard form: (lhs - rhs) {op} 0\n    \"\"\"\n\n    def __init__(self, lhs: Expr, rhs: Expr):\n        \"\"\"Initialize a constraint.\n\n        Args:\n            lhs: Left-hand side expression\n            rhs: Right-hand side expression\n        \"\"\"\n        self.lhs = lhs\n        self.rhs = rhs\n        self.is_convex = False\n\n    def children(self):\n        return [self.lhs, self.rhs]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize constraint to standard form: (lhs - rhs) {op} 0.\n\n        This works for both Equality and Inequality by using type(self) to\n        construct the appropriate subclass type.\n        \"\"\"\n        diff = Sub(self.lhs, self.rhs)\n        canon_diff = diff.canonicalize()\n        new_constraint = type(self)(canon_diff, Constant(np.array(0)))\n        new_constraint.is_convex = self.is_convex  # Preserve convex flag\n        return new_constraint\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that constraint operands are broadcastable. Returns scalar shape.\"\"\"\n        L_shape = self.lhs.check_shape()\n        R_shape = self.rhs.check_shape()\n\n        # Figure out their broadcasted shape (or error if incompatible)\n        try:\n            np.broadcast_shapes(L_shape, R_shape)\n        except ValueError as e:\n            constraint_type = type(self).__name__\n            raise ValueError(f\"{constraint_type} not broadcastable: {L_shape} vs {R_shape}\") from e\n\n        # Allow vector constraints - they're interpreted element-wise\n        # Return () as constraints always produce a scalar\n        return ()\n\n    def at(self, nodes: Union[list, tuple]):\n        \"\"\"Apply this constraint only at specific discrete nodes.\n\n        Args:\n            nodes: List of node indices where the constraint should be enforced\n\n        Returns:\n            NodalConstraint wrapping this constraint with node specification\n        \"\"\"\n        if isinstance(nodes, int):\n            nodes = [nodes]\n        return NodalConstraint(self, list(nodes))\n\n    def over(\n        self,\n        interval: tuple[int, int],\n        penalty: str = \"squared_relu\",\n        idx: Optional[int] = None,\n        check_nodally: bool = False,\n    ):\n        \"\"\"Apply this constraint over a continuous interval using CTCS.\n\n        Args:\n            interval: Tuple of (start, end) node indices for the continuous interval\n            penalty: Penalty function type (\"squared_relu\", \"huber\", \"smooth_relu\")\n            idx: Optional grouping index for multiple augmented states\n            check_nodally: Whether to also enforce this constraint nodally\n\n        Returns:\n            CTCS constraint wrapping this constraint with interval specification\n        \"\"\"\n        return CTCS(self, penalty=penalty, nodes=interval, idx=idx, check_nodally=check_nodally)\n\n    def convex(self) -&gt; \"Constraint\":\n        \"\"\"Mark this constraint as convex for CVXPy lowering.\n\n        Returns:\n            Self with convex flag set to True (enables method chaining)\n        \"\"\"\n        self.is_convex = True\n        return self\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.Constraint.__init__","title":"<code>__init__(lhs: Expr, rhs: Expr)</code>","text":"<p>Initialize a constraint.</p> <p>Parameters:</p> Name Type Description Default <code>lhs</code> <code>Expr</code> <p>Left-hand side expression</p> required <code>rhs</code> <code>Expr</code> <p>Right-hand side expression</p> required Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def __init__(self, lhs: Expr, rhs: Expr):\n    \"\"\"Initialize a constraint.\n\n    Args:\n        lhs: Left-hand side expression\n        rhs: Right-hand side expression\n    \"\"\"\n    self.lhs = lhs\n    self.rhs = rhs\n    self.is_convex = False\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.Constraint.at","title":"<code>at(nodes: Union[list, tuple])</code>","text":"<p>Apply this constraint only at specific discrete nodes.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>Union[list, tuple]</code> <p>List of node indices where the constraint should be enforced</p> required <p>Returns:</p> Type Description <p>NodalConstraint wrapping this constraint with node specification</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def at(self, nodes: Union[list, tuple]):\n    \"\"\"Apply this constraint only at specific discrete nodes.\n\n    Args:\n        nodes: List of node indices where the constraint should be enforced\n\n    Returns:\n        NodalConstraint wrapping this constraint with node specification\n    \"\"\"\n    if isinstance(nodes, int):\n        nodes = [nodes]\n    return NodalConstraint(self, list(nodes))\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.Constraint.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize constraint to standard form: (lhs - rhs) {op} 0.</p> <p>This works for both Equality and Inequality by using type(self) to construct the appropriate subclass type.</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize constraint to standard form: (lhs - rhs) {op} 0.\n\n    This works for both Equality and Inequality by using type(self) to\n    construct the appropriate subclass type.\n    \"\"\"\n    diff = Sub(self.lhs, self.rhs)\n    canon_diff = diff.canonicalize()\n    new_constraint = type(self)(canon_diff, Constant(np.array(0)))\n    new_constraint.is_convex = self.is_convex  # Preserve convex flag\n    return new_constraint\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.Constraint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that constraint operands are broadcastable. Returns scalar shape.</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that constraint operands are broadcastable. Returns scalar shape.\"\"\"\n    L_shape = self.lhs.check_shape()\n    R_shape = self.rhs.check_shape()\n\n    # Figure out their broadcasted shape (or error if incompatible)\n    try:\n        np.broadcast_shapes(L_shape, R_shape)\n    except ValueError as e:\n        constraint_type = type(self).__name__\n        raise ValueError(f\"{constraint_type} not broadcastable: {L_shape} vs {R_shape}\") from e\n\n    # Allow vector constraints - they're interpreted element-wise\n    # Return () as constraints always produce a scalar\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.Constraint.convex","title":"<code>convex() -&gt; Constraint</code>","text":"<p>Mark this constraint as convex for CVXPy lowering.</p> <p>Returns:</p> Type Description <code>Constraint</code> <p>Self with convex flag set to True (enables method chaining)</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def convex(self) -&gt; \"Constraint\":\n    \"\"\"Mark this constraint as convex for CVXPy lowering.\n\n    Returns:\n        Self with convex flag set to True (enables method chaining)\n    \"\"\"\n    self.is_convex = True\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.Constraint.over","title":"<code>over(interval: tuple[int, int], penalty: str = 'squared_relu', idx: Optional[int] = None, check_nodally: bool = False)</code>","text":"<p>Apply this constraint over a continuous interval using CTCS.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>tuple[int, int]</code> <p>Tuple of (start, end) node indices for the continuous interval</p> required <code>penalty</code> <code>str</code> <p>Penalty function type (\"squared_relu\", \"huber\", \"smooth_relu\")</p> <code>'squared_relu'</code> <code>idx</code> <code>Optional[int]</code> <p>Optional grouping index for multiple augmented states</p> <code>None</code> <code>check_nodally</code> <code>bool</code> <p>Whether to also enforce this constraint nodally</p> <code>False</code> <p>Returns:</p> Type Description <p>CTCS constraint wrapping this constraint with interval specification</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def over(\n    self,\n    interval: tuple[int, int],\n    penalty: str = \"squared_relu\",\n    idx: Optional[int] = None,\n    check_nodally: bool = False,\n):\n    \"\"\"Apply this constraint over a continuous interval using CTCS.\n\n    Args:\n        interval: Tuple of (start, end) node indices for the continuous interval\n        penalty: Penalty function type (\"squared_relu\", \"huber\", \"smooth_relu\")\n        idx: Optional grouping index for multiple augmented states\n        check_nodally: Whether to also enforce this constraint nodally\n\n    Returns:\n        CTCS constraint wrapping this constraint with interval specification\n    \"\"\"\n    return CTCS(self, penalty=penalty, nodes=interval, idx=idx, check_nodally=check_nodally)\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CrossNodeConstraint","title":"<code>CrossNodeConstraint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>A constraint that couples specific trajectory nodes via .at(k) references.</p> <p>Unlike NodalConstraint which applies a constraint pattern at multiple nodes (via vmapping), CrossNodeConstraint is a single constraint with fixed node indices embedded in the expression via NodeReference nodes.</p> <p>CrossNodeConstraint is created automatically when a bare Constraint contains NodeReference nodes (from .at(k) calls). Users should NOT manually wrap cross-node constraints - they are auto-detected during constraint separation.</p> <p>Key differences from NodalConstraint:</p> <ul> <li>NodalConstraint: Same constraint evaluated at multiple nodes via vmapping.   Signature: (x, u, node, params) \u2192 scalar, vmapped to (N, n_x) inputs.</li> <li>CrossNodeConstraint: Single constraint coupling specific fixed nodes.   Signature: (X, U, params) \u2192 scalar, operates on full trajectory arrays.</li> </ul> <p>Lowering:</p> <ul> <li>Non-convex: Lowered to JAX with automatic differentiation for SCP linearization</li> <li>Convex: Lowered to CVXPy and solved directly by the convex solver</li> </ul> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint containing NodeReference nodes</p> Example <p>Rate limit constraint (auto-detected as CrossNodeConstraint):</p> <pre><code>position = State(\"pos\", shape=(3,))\n\n# This creates a CrossNodeConstraint automatically:\nrate_limit = position.at(5) - position.at(4) &lt;= 0.1\n\n# Mark as convex if the constraint is convex:\nrate_limit_convex = (position.at(5) - position.at(4) &lt;= 0.1).convex()\n</code></pre> <p>Creating multiple cross-node constraints with a loop:</p> <pre><code>constraints = []\nfor k in range(1, N):\n    # Each iteration creates one CrossNodeConstraint\n    rate_limit = position.at(k) - position.at(k-1) &lt;= max_step\n    constraints.append(rate_limit)\n</code></pre> Note <p>Do NOT use .at([...]) on cross-node constraints. The nodes are already specified via .at(k) inside the expression. Using .at([...]) will raise an error during constraint separation.</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class CrossNodeConstraint(Expr):\n    \"\"\"A constraint that couples specific trajectory nodes via .at(k) references.\n\n    Unlike NodalConstraint which applies a constraint pattern at multiple nodes\n    (via vmapping), CrossNodeConstraint is a single constraint with fixed node\n    indices embedded in the expression via NodeReference nodes.\n\n    CrossNodeConstraint is created automatically when a bare Constraint contains\n    NodeReference nodes (from .at(k) calls). Users should NOT manually wrap\n    cross-node constraints - they are auto-detected during constraint separation.\n\n    **Key differences from NodalConstraint:**\n\n    - **NodalConstraint**: Same constraint evaluated at multiple nodes via vmapping.\n      Signature: (x, u, node, params) \u2192 scalar, vmapped to (N, n_x) inputs.\n    - **CrossNodeConstraint**: Single constraint coupling specific fixed nodes.\n      Signature: (X, U, params) \u2192 scalar, operates on full trajectory arrays.\n\n    **Lowering:**\n\n    - **Non-convex**: Lowered to JAX with automatic differentiation for SCP linearization\n    - **Convex**: Lowered to CVXPy and solved directly by the convex solver\n\n    Attributes:\n        constraint: The wrapped Constraint containing NodeReference nodes\n\n    Example:\n        Rate limit constraint (auto-detected as CrossNodeConstraint):\n\n            position = State(\"pos\", shape=(3,))\n\n            # This creates a CrossNodeConstraint automatically:\n            rate_limit = position.at(5) - position.at(4) &lt;= 0.1\n\n            # Mark as convex if the constraint is convex:\n            rate_limit_convex = (position.at(5) - position.at(4) &lt;= 0.1).convex()\n\n        Creating multiple cross-node constraints with a loop:\n\n            constraints = []\n            for k in range(1, N):\n                # Each iteration creates one CrossNodeConstraint\n                rate_limit = position.at(k) - position.at(k-1) &lt;= max_step\n                constraints.append(rate_limit)\n\n    Note:\n        Do NOT use .at([...]) on cross-node constraints. The nodes are already\n        specified via .at(k) inside the expression. Using .at([...]) will raise\n        an error during constraint separation.\n    \"\"\"\n\n    def __init__(self, constraint: Constraint):\n        \"\"\"Initialize a CrossNodeConstraint.\n\n        Args:\n            constraint: The Constraint containing NodeReference nodes.\n                Must contain at least one NodeReference (from .at(k) calls).\n\n        Raises:\n            TypeError: If constraint is not a Constraint instance\n        \"\"\"\n        if not isinstance(constraint, Constraint):\n            raise TypeError(\"CrossNodeConstraint must wrap a Constraint\")\n\n        self.constraint = constraint\n\n    @property\n    def is_convex(self) -&gt; bool:\n        \"\"\"Whether the underlying constraint is marked as convex.\n\n        Returns:\n            bool: True if the constraint is convex, False otherwise\n        \"\"\"\n        return self.constraint.is_convex\n\n    def children(self):\n        \"\"\"Return the wrapped constraint as the only child.\n\n        Returns:\n            list: Single-element list containing the wrapped constraint\n        \"\"\"\n        return [self.constraint]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the wrapped constraint.\n\n        Returns:\n            CrossNodeConstraint: A new CrossNodeConstraint with canonicalized inner constraint\n        \"\"\"\n        canon_constraint = self.constraint.canonicalize()\n        return CrossNodeConstraint(canon_constraint)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Validate the wrapped constraint's shape.\n\n        Returns:\n            tuple: Empty tuple () representing scalar shape\n        \"\"\"\n        self.constraint.check_shape()\n        return ()\n\n    def convex(self) -&gt; \"CrossNodeConstraint\":\n        \"\"\"Mark the underlying constraint as convex for CVXPy lowering.\n\n        Returns:\n            Self with underlying constraint's convex flag set to True\n        \"\"\"\n        self.constraint.convex()\n        return self\n\n    def __repr__(self):\n        \"\"\"String representation of the CrossNodeConstraint.\n\n        Returns:\n            str: String showing the wrapped constraint\n        \"\"\"\n        return f\"CrossNodeConstraint({self.constraint!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CrossNodeConstraint.is_convex","title":"<code>is_convex: bool</code>  <code>property</code>","text":"<p>Whether the underlying constraint is marked as convex.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the constraint is convex, False otherwise</p>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CrossNodeConstraint.__init__","title":"<code>__init__(constraint: Constraint)</code>","text":"<p>Initialize a CrossNodeConstraint.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>Constraint</code> <p>The Constraint containing NodeReference nodes. Must contain at least one NodeReference (from .at(k) calls).</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If constraint is not a Constraint instance</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def __init__(self, constraint: Constraint):\n    \"\"\"Initialize a CrossNodeConstraint.\n\n    Args:\n        constraint: The Constraint containing NodeReference nodes.\n            Must contain at least one NodeReference (from .at(k) calls).\n\n    Raises:\n        TypeError: If constraint is not a Constraint instance\n    \"\"\"\n    if not isinstance(constraint, Constraint):\n        raise TypeError(\"CrossNodeConstraint must wrap a Constraint\")\n\n    self.constraint = constraint\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CrossNodeConstraint.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the wrapped constraint.</p> <p>Returns:</p> Name Type Description <code>CrossNodeConstraint</code> <code>Expr</code> <p>A new CrossNodeConstraint with canonicalized inner constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the wrapped constraint.\n\n    Returns:\n        CrossNodeConstraint: A new CrossNodeConstraint with canonicalized inner constraint\n    \"\"\"\n    canon_constraint = self.constraint.canonicalize()\n    return CrossNodeConstraint(canon_constraint)\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CrossNodeConstraint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the wrapped constraint's shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Validate the wrapped constraint's shape.\n\n    Returns:\n        tuple: Empty tuple () representing scalar shape\n    \"\"\"\n    self.constraint.check_shape()\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CrossNodeConstraint.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def children(self):\n    \"\"\"Return the wrapped constraint as the only child.\n\n    Returns:\n        list: Single-element list containing the wrapped constraint\n    \"\"\"\n    return [self.constraint]\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.CrossNodeConstraint.convex","title":"<code>convex() -&gt; CrossNodeConstraint</code>","text":"<p>Mark the underlying constraint as convex for CVXPy lowering.</p> <p>Returns:</p> Type Description <code>CrossNodeConstraint</code> <p>Self with underlying constraint's convex flag set to True</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def convex(self) -&gt; \"CrossNodeConstraint\":\n    \"\"\"Mark the underlying constraint as convex for CVXPy lowering.\n\n    Returns:\n        Self with underlying constraint's convex flag set to True\n    \"\"\"\n    self.constraint.convex()\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.Equality","title":"<code>Equality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Equality constraint for optimization problems.</p> <p>Represents an equality constraint: lhs == rhs. Can be created using the == operator on Expr objects.</p> Example <p>Define an Equality constraint:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = x == 0  # Creates Equality(x, Constant(0))\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class Equality(Constraint):\n    \"\"\"Equality constraint for optimization problems.\n\n    Represents an equality constraint: lhs == rhs. Can be created using the ==\n    operator on Expr objects.\n\n    Example:\n        Define an Equality constraint:\n\n            x = ox.State(\"x\", shape=(3,))\n            constraint = x == 0  # Creates Equality(x, Constant(0))\n    \"\"\"\n\n    def __repr__(self):\n        return f\"{self.lhs!r} == {self.rhs!r}\"\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.Inequality","title":"<code>Inequality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Inequality constraint for optimization problems.</p> <p>Represents an inequality constraint: lhs &lt;= rhs. Can be created using the &lt;= operator on Expr objects.</p> Example <p>Define an Inequality constraint:</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nconstraint = x &lt;= 10  # Creates Inequality(x, Constant(10))\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class Inequality(Constraint):\n    \"\"\"Inequality constraint for optimization problems.\n\n    Represents an inequality constraint: lhs &lt;= rhs. Can be created using the &lt;=\n    operator on Expr objects.\n\n    Example:\n        Define an Inequality constraint:\n\n            x = ox.State(\"x\", shape=(3,))\n            constraint = x &lt;= 10  # Creates Inequality(x, Constant(10))\n    \"\"\"\n\n    def __repr__(self):\n        return f\"{self.lhs!r} &lt;= {self.rhs!r}\"\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.NodalConstraint","title":"<code>NodalConstraint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Wrapper for constraints enforced only at specific discrete trajectory nodes.</p> <p>NodalConstraint allows selective enforcement of constraints at specific time points (nodes) in a discretized trajectory, rather than enforcing them at every node. This is useful for:</p> <ul> <li>Specifying waypoint constraints (e.g., pass through point X at node 10)</li> <li>Boundary conditions at non-standard locations</li> <li>Reducing computational cost by checking constraints less frequently</li> <li>Enforcing periodic constraints (e.g., every 5th node)</li> </ul> <p>The wrapper maintains clean separation between the constraint's mathematical definition and the specification of where it should be applied during optimization.</p> Note <p>Bare Constraint objects (without .at() or .over()) are automatically converted to NodalConstraints applied at all nodes during preprocessing.</p> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (Equality or Inequality) to enforce</p> <code>nodes</code> <p>List of integer node indices where the constraint is enforced</p> Example <p>Enforce position constraint only at nodes 0, 10, and 20:</p> <pre><code>x = State(\"x\", shape=(3,))\ntarget = [10, 5, 0]\nconstraint = (x == target).at([0, 10, 20])\n</code></pre> <p>Equivalent using NodalConstraint directly:</p> <pre><code>constraint = NodalConstraint(x == target, nodes=[0, 10, 20])\n</code></pre> <p>Periodic constraint enforcement (every 10th node):</p> <pre><code>velocity_limit = (vel &lt;= 100).at(list(range(0, 100, 10)))\n</code></pre> <p>Bare constraints are automatically applied at all nodes. These are equivalent:</p> <pre><code>constraint1 = vel &lt;= 100  # Auto-converted to all nodes\nconstraint2 = (vel &lt;= 100).at(list(range(n_nodes)))\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>class NodalConstraint(Expr):\n    \"\"\"Wrapper for constraints enforced only at specific discrete trajectory nodes.\n\n    NodalConstraint allows selective enforcement of constraints at specific time points\n    (nodes) in a discretized trajectory, rather than enforcing them at every node.\n    This is useful for:\n\n    - Specifying waypoint constraints (e.g., pass through point X at node 10)\n    - Boundary conditions at non-standard locations\n    - Reducing computational cost by checking constraints less frequently\n    - Enforcing periodic constraints (e.g., every 5th node)\n\n    The wrapper maintains clean separation between the constraint's mathematical\n    definition and the specification of where it should be applied during optimization.\n\n    Note:\n        Bare Constraint objects (without .at() or .over()) are automatically converted\n        to NodalConstraints applied at all nodes during preprocessing.\n\n    Attributes:\n        constraint: The wrapped Constraint (Equality or Inequality) to enforce\n        nodes: List of integer node indices where the constraint is enforced\n\n    Example:\n        Enforce position constraint only at nodes 0, 10, and 20:\n\n            x = State(\"x\", shape=(3,))\n            target = [10, 5, 0]\n            constraint = (x == target).at([0, 10, 20])\n\n        Equivalent using NodalConstraint directly:\n\n            constraint = NodalConstraint(x == target, nodes=[0, 10, 20])\n\n        Periodic constraint enforcement (every 10th node):\n\n            velocity_limit = (vel &lt;= 100).at(list(range(0, 100, 10)))\n\n        Bare constraints are automatically applied at all nodes.\n        These are equivalent:\n\n            constraint1 = vel &lt;= 100  # Auto-converted to all nodes\n            constraint2 = (vel &lt;= 100).at(list(range(n_nodes)))\n    \"\"\"\n\n    def __init__(self, constraint: Constraint, nodes: list[int]):\n        \"\"\"Initialize a NodalConstraint.\n\n        Args:\n            constraint: The Constraint (Equality or Inequality) to enforce at specified nodes\n            nodes: List of integer node indices where the constraint should be enforced.\n                Automatically converts numpy integers to Python integers.\n\n        Raises:\n            TypeError: If constraint is not a Constraint instance\n            TypeError: If nodes is not a list\n            TypeError: If any node index is not an integer\n\n        Note:\n            Bounds checking for cross-node constraints (those containing NodeReference)\n            is performed later in the pipeline when N is known, via\n            validate_cross_node_constraint_bounds() in preprocessing.py.\n        \"\"\"\n        if not isinstance(constraint, Constraint):\n            raise TypeError(\"NodalConstraint must wrap a Constraint\")\n        if not isinstance(nodes, list):\n            raise TypeError(\"nodes must be a list of integers\")\n\n        # Convert numpy integers to Python integers\n        converted_nodes = []\n        for n in nodes:\n            if isinstance(n, np.integer):\n                converted_nodes.append(int(n))\n            elif isinstance(n, int):\n                converted_nodes.append(n)\n            else:\n                raise TypeError(\"all node indices must be integers\")\n\n        self.constraint = constraint\n        self.nodes = converted_nodes\n\n    def children(self):\n        \"\"\"Return the wrapped constraint as the only child.\n\n        Returns:\n            list: Single-element list containing the wrapped constraint\n        \"\"\"\n        return [self.constraint]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the wrapped constraint while preserving node specification.\n\n        Returns:\n            NodalConstraint: A new NodalConstraint with canonicalized inner constraint\n        \"\"\"\n        canon_constraint = self.constraint.canonicalize()\n        return NodalConstraint(canon_constraint, self.nodes)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Validate the wrapped constraint's shape.\n\n        NodalConstraint wraps a constraint without changing its computational meaning,\n        only specifying where it should be applied. Like all constraints, it produces\n        a scalar result.\n\n        Returns:\n            tuple: Empty tuple () representing scalar shape\n        \"\"\"\n        # Validate the wrapped constraint's shape\n        self.constraint.check_shape()\n\n        # NodalConstraint produces a scalar like any constraint\n        return ()\n\n    def convex(self) -&gt; \"NodalConstraint\":\n        \"\"\"Mark the underlying constraint as convex for CVXPy lowering.\n\n        Returns:\n            Self with underlying constraint's convex flag set to True (enables method chaining)\n\n        Example:\n            Mark a constraint as convex:\n                constraint = (x &lt;= 10).at([0, 5, 10]).convex()\n        \"\"\"\n        self.constraint.convex()\n        return self\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash NodalConstraint including its node list.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"NodalConstraint\")\n        # Hash the nodes list\n        for node in self.nodes:\n            hasher.update(struct.pack(\"&gt;i\", node))\n        hasher.update(b\"|\")  # Separator to distinguish node counts\n        # Hash the wrapped constraint\n        self.constraint._hash_into(hasher)\n\n    def __repr__(self):\n        \"\"\"String representation of the NodalConstraint.\n\n        Returns:\n            str: String showing the wrapped constraint and node indices\n        \"\"\"\n        return f\"NodalConstraint({self.constraint!r}, nodes={self.nodes})\"\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.NodalConstraint.__init__","title":"<code>__init__(constraint: Constraint, nodes: list[int])</code>","text":"<p>Initialize a NodalConstraint.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>Constraint</code> <p>The Constraint (Equality or Inequality) to enforce at specified nodes</p> required <code>nodes</code> <code>list[int]</code> <p>List of integer node indices where the constraint should be enforced. Automatically converts numpy integers to Python integers.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If constraint is not a Constraint instance</p> <code>TypeError</code> <p>If nodes is not a list</p> <code>TypeError</code> <p>If any node index is not an integer</p> Note <p>Bounds checking for cross-node constraints (those containing NodeReference) is performed later in the pipeline when N is known, via validate_cross_node_constraint_bounds() in preprocessing.py.</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def __init__(self, constraint: Constraint, nodes: list[int]):\n    \"\"\"Initialize a NodalConstraint.\n\n    Args:\n        constraint: The Constraint (Equality or Inequality) to enforce at specified nodes\n        nodes: List of integer node indices where the constraint should be enforced.\n            Automatically converts numpy integers to Python integers.\n\n    Raises:\n        TypeError: If constraint is not a Constraint instance\n        TypeError: If nodes is not a list\n        TypeError: If any node index is not an integer\n\n    Note:\n        Bounds checking for cross-node constraints (those containing NodeReference)\n        is performed later in the pipeline when N is known, via\n        validate_cross_node_constraint_bounds() in preprocessing.py.\n    \"\"\"\n    if not isinstance(constraint, Constraint):\n        raise TypeError(\"NodalConstraint must wrap a Constraint\")\n    if not isinstance(nodes, list):\n        raise TypeError(\"nodes must be a list of integers\")\n\n    # Convert numpy integers to Python integers\n    converted_nodes = []\n    for n in nodes:\n        if isinstance(n, np.integer):\n            converted_nodes.append(int(n))\n        elif isinstance(n, int):\n            converted_nodes.append(n)\n        else:\n            raise TypeError(\"all node indices must be integers\")\n\n    self.constraint = constraint\n    self.nodes = converted_nodes\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.NodalConstraint.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the wrapped constraint while preserving node specification.</p> <p>Returns:</p> Name Type Description <code>NodalConstraint</code> <code>Expr</code> <p>A new NodalConstraint with canonicalized inner constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the wrapped constraint while preserving node specification.\n\n    Returns:\n        NodalConstraint: A new NodalConstraint with canonicalized inner constraint\n    \"\"\"\n    canon_constraint = self.constraint.canonicalize()\n    return NodalConstraint(canon_constraint, self.nodes)\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.NodalConstraint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the wrapped constraint's shape.</p> <p>NodalConstraint wraps a constraint without changing its computational meaning, only specifying where it should be applied. Like all constraints, it produces a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Validate the wrapped constraint's shape.\n\n    NodalConstraint wraps a constraint without changing its computational meaning,\n    only specifying where it should be applied. Like all constraints, it produces\n    a scalar result.\n\n    Returns:\n        tuple: Empty tuple () representing scalar shape\n    \"\"\"\n    # Validate the wrapped constraint's shape\n    self.constraint.check_shape()\n\n    # NodalConstraint produces a scalar like any constraint\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.NodalConstraint.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def children(self):\n    \"\"\"Return the wrapped constraint as the only child.\n\n    Returns:\n        list: Single-element list containing the wrapped constraint\n    \"\"\"\n    return [self.constraint]\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.NodalConstraint.convex","title":"<code>convex() -&gt; NodalConstraint</code>","text":"<p>Mark the underlying constraint as convex for CVXPy lowering.</p> <p>Returns:</p> Type Description <code>NodalConstraint</code> <p>Self with underlying constraint's convex flag set to True (enables method chaining)</p> Example <p>Mark a constraint as convex:     constraint = (x &lt;= 10).at([0, 5, 10]).convex()</p> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def convex(self) -&gt; \"NodalConstraint\":\n    \"\"\"Mark the underlying constraint as convex for CVXPy lowering.\n\n    Returns:\n        Self with underlying constraint's convex flag set to True (enables method chaining)\n\n    Example:\n        Mark a constraint as convex:\n            constraint = (x &lt;= 10).at([0, 5, 10]).convex()\n    \"\"\"\n    self.constraint.convex()\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/constraint/#openscvx.symbolic.expr.constraint.ctcs","title":"<code>ctcs(constraint: Constraint, penalty: str = 'squared_relu', nodes: Optional[Tuple[int, int]] = None, idx: Optional[int] = None, check_nodally: bool = False) -&gt; CTCS</code>","text":"<p>Helper function to create CTCS (Continuous-Time Constraint Satisfaction) constraints.</p> <p>This is a convenience function that creates a CTCS constraint with the same parameters as the CTCS constructor. Useful for functional-style constraint building.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>Constraint</code> <p>The Constraint to enforce continuously</p> required <code>penalty</code> <code>str</code> <p>Penalty function type ('squared_relu', 'huber', or 'smooth_relu'). Defaults to 'squared_relu'.</p> <code>'squared_relu'</code> <code>nodes</code> <code>Optional[Tuple[int, int]]</code> <p>Optional (start, end) tuple of node indices for enforcement interval. None enforces over entire trajectory.</p> <code>None</code> <code>idx</code> <code>Optional[int]</code> <p>Optional grouping index for multiple augmented states</p> <code>None</code> <code>check_nodally</code> <code>bool</code> <p>Whether to also enforce constraint at discrete nodes. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>CTCS</code> <code>CTCS</code> <p>A CTCS constraint wrapping the input constraint</p> Example <p>Using the helper function:</p> <pre><code>from openscvx.symbolic.expr.constraint import ctcs\naltitude_constraint = ctcs(\n    altitude &gt;= 10,\n    penalty=\"huber\",\n    nodes=(0, 100),\n    check_nodally=True\n)\n</code></pre> <p>Equivalent to using CTCS constructor:</p> <pre><code>altitude_constraint = CTCS(altitude &gt;= 10, penalty=\"huber\", nodes=(0, 100))\n</code></pre> <p>Also equivalent to using .over() method on constraint:</p> <pre><code>altitude_constraint = (altitude &gt;= 10).over((0, 100), penalty=\"huber\")\n</code></pre> Source code in <code>openscvx/symbolic/expr/constraint.py</code> <pre><code>def ctcs(\n    constraint: Constraint,\n    penalty: str = \"squared_relu\",\n    nodes: Optional[Tuple[int, int]] = None,\n    idx: Optional[int] = None,\n    check_nodally: bool = False,\n) -&gt; CTCS:\n    \"\"\"Helper function to create CTCS (Continuous-Time Constraint Satisfaction) constraints.\n\n    This is a convenience function that creates a CTCS constraint with the same\n    parameters as the CTCS constructor. Useful for functional-style constraint building.\n\n    Args:\n        constraint: The Constraint to enforce continuously\n        penalty: Penalty function type ('squared_relu', 'huber', or 'smooth_relu').\n            Defaults to 'squared_relu'.\n        nodes: Optional (start, end) tuple of node indices for enforcement interval.\n            None enforces over entire trajectory.\n        idx: Optional grouping index for multiple augmented states\n        check_nodally: Whether to also enforce constraint at discrete nodes.\n            Defaults to False.\n\n    Returns:\n        CTCS: A CTCS constraint wrapping the input constraint\n\n    Example:\n        Using the helper function:\n\n            from openscvx.symbolic.expr.constraint import ctcs\n            altitude_constraint = ctcs(\n                altitude &gt;= 10,\n                penalty=\"huber\",\n                nodes=(0, 100),\n                check_nodally=True\n            )\n\n        Equivalent to using CTCS constructor:\n\n            altitude_constraint = CTCS(altitude &gt;= 10, penalty=\"huber\", nodes=(0, 100))\n\n        Also equivalent to using .over() method on constraint:\n\n            altitude_constraint = (altitude &gt;= 10).over((0, 100), penalty=\"huber\")\n    \"\"\"\n    return CTCS(constraint, penalty, nodes, idx, check_nodally)\n</code></pre>"},{"location":"reference/symbolic/expr/control/","title":"control","text":""},{"location":"reference/symbolic/expr/control/#openscvx.symbolic.expr.control.Control","title":"<code>Control</code>","text":"<p>               Bases: <code>Variable</code></p> <p>Control input variable for trajectory optimization problems.</p> <p>Control represents control input variables (actuator commands) in a trajectory optimization problem. Unlike State variables which evolve according to dynamics, Controls are direct decision variables that the optimizer can freely adjust (within specified bounds) at each time step to influence the system dynamics.</p> <p>Controls are conceptually similar to State variables but simpler - they don't have boundary conditions (initial/final specifications) since controls are typically not constrained at the endpoints. Like States, Controls support:</p> <ul> <li>Min/max bounds to enforce actuator limits</li> <li>Initial trajectory guesses to help the optimizer converge</li> </ul> <p>Common examples of control inputs include:</p> <ul> <li>Thrust magnitude and direction for spacecraft/rockets</li> <li>Throttle settings for engines</li> <li>Steering angles for vehicles</li> <li>Torques for robotic manipulators</li> <li>Force/acceleration commands</li> </ul> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name identifier for this control variable</p> <code>_shape</code> <code>tuple[int, ...]</code> <p>Shape of the control vector (typically 1D like (3,) for 3D thrust)</p> <code>_slice</code> <code>slice | None</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <code>ndarray | None</code> <p>Minimum bounds for each element of the control</p> <code>_max</code> <code>ndarray | None</code> <p>Maximum bounds for each element of the control</p> <code>_guess</code> <code>ndarray | None</code> <p>Initial guess for the control trajectory (n_points, n_controls)</p> Example <p>Scalar throttle control bounded [0, 1]:</p> <pre><code>throttle = Control(\"throttle\", shape=(1,))\nthrottle.min = [0.0]\nthrottle.max = [1.0]\nthrottle.guess = np.full((50, 1), 0.5)  # Start at 50% throttle\n</code></pre> <p>3D thrust vector for spacecraft:</p> <pre><code>thrust = Control(\"thrust\", shape=(3,))\nthrust.min = [-10, -10, 0]    # No downward thrust\nthrust.max = [10, 10, 50]     # Limited thrust\nthrust.guess = np.zeros((50, 3))  # Initialize with zero thrust\n</code></pre> <p>2D steering control (left/right, forward/backward):</p> <pre><code>steer = Control(\"steer\", shape=(2,))\nsteer.min = [-1, -1]\nsteer.max = [1, 1]\nsteer.guess = np.linspace([0, 0], [0, 1], 50)  # Gradual acceleration\n</code></pre> Source code in <code>openscvx/symbolic/expr/control.py</code> <pre><code>class Control(Variable):\n    \"\"\"Control input variable for trajectory optimization problems.\n\n    Control represents control input variables (actuator commands) in a trajectory\n    optimization problem. Unlike State variables which evolve according to dynamics,\n    Controls are direct decision variables that the optimizer can freely adjust\n    (within specified bounds) at each time step to influence the system dynamics.\n\n    Controls are conceptually similar to State variables but simpler - they don't\n    have boundary conditions (initial/final specifications) since controls are\n    typically not constrained at the endpoints. Like States, Controls support:\n\n    - Min/max bounds to enforce actuator limits\n    - Initial trajectory guesses to help the optimizer converge\n\n    Common examples of control inputs include:\n\n    - Thrust magnitude and direction for spacecraft/rockets\n    - Throttle settings for engines\n    - Steering angles for vehicles\n    - Torques for robotic manipulators\n    - Force/acceleration commands\n\n    Attributes:\n        name (str): Unique name identifier for this control variable\n        _shape (tuple[int, ...]): Shape of the control vector (typically 1D like (3,) for 3D thrust)\n        _slice (slice | None): Internal slice information for variable indexing\n        _min (np.ndarray | None): Minimum bounds for each element of the control\n        _max (np.ndarray | None): Maximum bounds for each element of the control\n        _guess (np.ndarray | None): Initial guess for the control trajectory (n_points, n_controls)\n\n    Example:\n        Scalar throttle control bounded [0, 1]:\n\n            throttle = Control(\"throttle\", shape=(1,))\n            throttle.min = [0.0]\n            throttle.max = [1.0]\n            throttle.guess = np.full((50, 1), 0.5)  # Start at 50% throttle\n\n        3D thrust vector for spacecraft:\n\n            thrust = Control(\"thrust\", shape=(3,))\n            thrust.min = [-10, -10, 0]    # No downward thrust\n            thrust.max = [10, 10, 50]     # Limited thrust\n            thrust.guess = np.zeros((50, 3))  # Initialize with zero thrust\n\n        2D steering control (left/right, forward/backward):\n\n            steer = Control(\"steer\", shape=(2,))\n            steer.min = [-1, -1]\n            steer.max = [1, 1]\n            steer.guess = np.linspace([0, 0], [0, 1], 50)  # Gradual acceleration\n    \"\"\"\n\n    def __init__(self, name, shape):\n        \"\"\"Initialize a Control object.\n\n        Args:\n            name: Name identifier for the control variable\n            shape: Shape of the control vector (typically 1D tuple like (3,))\n        \"\"\"\n        super().__init__(name, shape)\n        self._scaling_min = None\n        self._scaling_max = None\n\n    @property\n    def scaling_min(self):\n        \"\"\"Get the scaling minimum bounds for the control variables.\n\n        Returns:\n            Array of scaling minimum values for each control variable element, or None if not set.\n        \"\"\"\n        return self._scaling_min\n\n    @scaling_min.setter\n    def scaling_min(self, val):\n        \"\"\"Set the scaling minimum bounds for the control variables.\n\n        Args:\n            val: Array of scaling minimum values, must match the control shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the control shape\n        \"\"\"\n        if val is None:\n            self._scaling_min = None\n            return\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(\n                f\"Scaling min shape {val.shape} does not match Control shape {self.shape}\"\n            )\n        self._scaling_min = val\n\n    @property\n    def scaling_max(self):\n        \"\"\"Get the scaling maximum bounds for the control variables.\n\n        Returns:\n            Array of scaling maximum values for each control variable element, or None if not set.\n        \"\"\"\n        return self._scaling_max\n\n    @scaling_max.setter\n    def scaling_max(self, val):\n        \"\"\"Set the scaling maximum bounds for the control variables.\n\n        Args:\n            val: Array of scaling maximum values, must match the control shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the control shape\n        \"\"\"\n        if val is None:\n            self._scaling_max = None\n            return\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(\n                f\"Scaling max shape {val.shape} does not match Control shape {self.shape}\"\n            )\n        self._scaling_max = val\n\n    def __repr__(self):\n        \"\"\"String representation of the Control object.\n\n        Returns:\n            Concise string showing the control name and shape.\n        \"\"\"\n        return f\"Control('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/symbolic/expr/control/#openscvx.symbolic.expr.control.Control.scaling_max","title":"<code>scaling_max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling maximum bounds for the control variables.</p> <p>Returns:</p> Type Description <p>Array of scaling maximum values for each control variable element, or None if not set.</p>"},{"location":"reference/symbolic/expr/control/#openscvx.symbolic.expr.control.Control.scaling_min","title":"<code>scaling_min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling minimum bounds for the control variables.</p> <p>Returns:</p> Type Description <p>Array of scaling minimum values for each control variable element, or None if not set.</p>"},{"location":"reference/symbolic/expr/control/#openscvx.symbolic.expr.control.Control.__init__","title":"<code>__init__(name, shape)</code>","text":"<p>Initialize a Control object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name identifier for the control variable</p> required <code>shape</code> <p>Shape of the control vector (typically 1D tuple like (3,))</p> required Source code in <code>openscvx/symbolic/expr/control.py</code> <pre><code>def __init__(self, name, shape):\n    \"\"\"Initialize a Control object.\n\n    Args:\n        name: Name identifier for the control variable\n        shape: Shape of the control vector (typically 1D tuple like (3,))\n    \"\"\"\n    super().__init__(name, shape)\n    self._scaling_min = None\n    self._scaling_max = None\n</code></pre>"},{"location":"reference/symbolic/expr/expr/","title":"expr","text":"<p>Core symbolic expression system for trajectory optimization.</p> <p>This module provides the foundation for openscvx's symbolic expression framework, implementing an Abstract Syntax Tree (AST) representation for mathematical expressions used in optimization problems. The expression system enables:</p> <ul> <li>Declarative problem specification: Write optimization problems using familiar     mathematical notation with operator overloading (+, -, , /, @, *, etc.)</li> <li>Automatic differentiation: Expressions are automatically differentiated during     compilation to solver-specific formats</li> <li>Shape checking: Static validation of tensor dimensions before optimization</li> <li>Canonicalization: Algebraic simplification for more efficient compilation</li> <li>Multiple backends: Expressions can be compiled to CVXPy, JAX, or custom solvers</li> </ul> Architecture <p>The expression system is built around an AST where each node is an <code>Expr</code> subclass:</p> <ul> <li>Leaf nodes: <code>Parameter</code>, <code>Variable</code>, <code>State</code>, <code>Control</code> - symbolic values</li> <li>Arithmetic operations: <code>Add</code>, <code>Sub</code>, <code>Mul</code>, <code>Div</code>, <code>MatMul</code>, <code>Power</code>, <code>Neg</code></li> <li>Array operations: <code>Index</code>, <code>Concat</code>, <code>Stack</code>, <code>Hstack</code>, <code>Vstack</code></li> <li>Linear algebra: <code>Transpose</code>, <code>Diag</code>, <code>Sum</code>, <code>Norm</code></li> <li>Constraints: <code>Equality</code>, <code>Inequality</code></li> <li>Functions: <code>Sin</code>, <code>Cos</code>, <code>Exp</code>, <code>Log</code>, <code>Sqrt</code>, etc.</li> </ul> <p>Each expression node implements:</p> <ul> <li><code>children()</code>: Returns child expressions in the AST</li> <li><code>canonicalize()</code>: Returns a simplified/normalized version</li> <li><code>check_shape()</code>: Validates and returns the output shape</li> </ul> Example <p>Creating symbolic variables and expressions::</p> <pre><code>import openscvx as ox\n\n# Define symbolic variables\nx = ox.State(\"x\", shape=(3,))\nA = ox.Parameter(\"A\", shape=(3, 3), value=np.eye(3))\n\n# Build expressions using natural syntax\nexpr = A @ x + 5\nconstraint = ox.Norm(x) &lt;= 1.0\n\n# Expressions form an AST\nprint(expr.pretty())  # Visualize the tree structure\n</code></pre> <p>Shape checking with automatic validation::</p> <pre><code>x = ox.State(\"x\", shape=(3,))\ny = ox.State(\"y\", shape=(4,))\n\n# This will raise ValueError during shape checking\ntry:\n    expr = x + y  # Shapes (3,) and (4,) not broadcastable\n    expr.check_shape()\nexcept ValueError as e:\n    print(f\"Shape error: {e}\")\n</code></pre> <p>Algebraic canonicalization::</p> <pre><code>x = ox.State(\"x\", shape=(3,))\nexpr = x + 0 + (1 * x)\ncanonical = expr.canonicalize()  # Simplifies to: x + x\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Constant","title":"<code>Constant</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Constant value expression.</p> <p>Represents a constant numeric value in the expression tree. Constants are automatically normalized (squeezed) upon construction to ensure consistency.</p> <p>Attributes:</p> Name Type Description <code>value</code> <p>The numpy array representing the constant value (squeezed)</p> Example <p>Define constants:</p> <pre><code>c1 = Constant(5.0)        # Scalar constant\nc2 = Constant([1, 2, 3])  # Vector constant\nc3 = to_expr(10)          # Also creates a Constant\n</code></pre> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class Constant(Expr):\n    \"\"\"Constant value expression.\n\n    Represents a constant numeric value in the expression tree. Constants are\n    automatically normalized (squeezed) upon construction to ensure consistency.\n\n    Attributes:\n        value: The numpy array representing the constant value (squeezed)\n\n    Example:\n        Define constants:\n\n            c1 = Constant(5.0)        # Scalar constant\n            c2 = Constant([1, 2, 3])  # Vector constant\n            c3 = to_expr(10)          # Also creates a Constant\n    \"\"\"\n\n    def __init__(self, value: np.ndarray):\n        \"\"\"Initialize a constant expression.\n\n        Args:\n            value: Numeric value or numpy array to wrap as a constant.\n                   Will be converted to numpy array and squeezed.\n        \"\"\"\n        # Normalize immediately upon construction to ensure consistency\n        # This ensures Constant(5.0) and Constant([5.0]) create identical objects\n        if not isinstance(value, np.ndarray):\n            value = np.array(value, dtype=float)\n        self.value = np.squeeze(value)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Constants are already in canonical form.\n\n        Returns:\n            Expr: Returns self since constants are already canonical\n        \"\"\"\n        return self\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Return the shape of this constant's value.\n\n        Returns:\n            tuple: The shape of the constant's numpy array value\n        \"\"\"\n        # Verify the invariant: constants should already be squeezed during construction\n        original_shape = self.value.shape\n        squeezed_shape = np.squeeze(self.value).shape\n        if original_shape != squeezed_shape:\n            raise ValueError(\n                f\"Constant not properly normalized: has shape {original_shape} \"\n                \"but should have shape {squeezed_shape}. \"\n                \"Constants should be squeezed during construction.\"\n            )\n        return self.value.shape\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash constant by its value.\n\n        Constants are hashed by their actual numeric value, ensuring that\n        expressions with the same constant values produce the same hash.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Constant\")\n        hasher.update(str(self.value.shape).encode())\n        hasher.update(self.value.tobytes())\n\n    def __repr__(self):\n        # Show clean representation - always show as Python values, not numpy arrays\n        if self.value.ndim == 0:\n            # Scalar: show as plain number\n            return f\"Const({self.value.item()!r})\"\n        else:\n            # Array: show as Python list for readability\n            return f\"Const({self.value.tolist()!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Constant.__init__","title":"<code>__init__(value: np.ndarray)</code>","text":"<p>Initialize a constant expression.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>ndarray</code> <p>Numeric value or numpy array to wrap as a constant.    Will be converted to numpy array and squeezed.</p> required Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def __init__(self, value: np.ndarray):\n    \"\"\"Initialize a constant expression.\n\n    Args:\n        value: Numeric value or numpy array to wrap as a constant.\n               Will be converted to numpy array and squeezed.\n    \"\"\"\n    # Normalize immediately upon construction to ensure consistency\n    # This ensures Constant(5.0) and Constant([5.0]) create identical objects\n    if not isinstance(value, np.ndarray):\n        value = np.array(value, dtype=float)\n    self.value = np.squeeze(value)\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Constant.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Constants are already in canonical form.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Returns self since constants are already canonical</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Constants are already in canonical form.\n\n    Returns:\n        Expr: Returns self since constants are already canonical\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Constant.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Return the shape of this constant's value.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The shape of the constant's numpy array value</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Return the shape of this constant's value.\n\n    Returns:\n        tuple: The shape of the constant's numpy array value\n    \"\"\"\n    # Verify the invariant: constants should already be squeezed during construction\n    original_shape = self.value.shape\n    squeezed_shape = np.squeeze(self.value).shape\n    if original_shape != squeezed_shape:\n        raise ValueError(\n            f\"Constant not properly normalized: has shape {original_shape} \"\n            \"but should have shape {squeezed_shape}. \"\n            \"Constants should be squeezed during construction.\"\n        )\n    return self.value.shape\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Expr","title":"<code>Expr</code>","text":"<p>Base class for symbolic expressions in optimization problems.</p> <p>Expr is the foundation of the symbolic expression system in openscvx. It represents nodes in an abstract syntax tree (AST) for mathematical expressions. Expressions support:</p> <ul> <li>Arithmetic operations: +, -, *, /, @, **</li> <li>Comparison operations: ==, &lt;=, &gt;=</li> <li>Indexing and slicing: []</li> <li>Transposition: .T property</li> <li>Shape checking and validation</li> <li>Canonicalization (algebraic simplification)</li> </ul> <p>All Expr subclasses implement a tree structure where each node can have child expressions accessed via the children() method.</p> <p>Attributes:</p> Name Type Description <code>__array_priority__</code> <p>Priority for operations with numpy arrays (set to 1000)</p> Note <p>When used in operations with numpy arrays, Expr objects take precedence, allowing symbolic expressions to wrap numeric values automatically.</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class Expr:\n    \"\"\"Base class for symbolic expressions in optimization problems.\n\n    Expr is the foundation of the symbolic expression system in openscvx. It represents\n    nodes in an abstract syntax tree (AST) for mathematical expressions. Expressions\n    support:\n\n    - Arithmetic operations: +, -, *, /, @, **\n    - Comparison operations: ==, &lt;=, &gt;=\n    - Indexing and slicing: []\n    - Transposition: .T property\n    - Shape checking and validation\n    - Canonicalization (algebraic simplification)\n\n    All Expr subclasses implement a tree structure where each node can have child\n    expressions accessed via the children() method.\n\n    Attributes:\n        __array_priority__: Priority for operations with numpy arrays (set to 1000)\n\n    Note:\n        When used in operations with numpy arrays, Expr objects take precedence,\n        allowing symbolic expressions to wrap numeric values automatically.\n    \"\"\"\n\n    # Give Expr objects higher priority than numpy arrays in operations\n    __array_priority__ = 1000\n\n    def __le__(self, other):\n        from .constraint import Inequality\n\n        return Inequality(self, to_expr(other))\n\n    def __ge__(self, other):\n        from .constraint import Inequality\n\n        return Inequality(to_expr(other), self)\n\n    def __eq__(self, other):\n        from .constraint import Equality\n\n        return Equality(self, to_expr(other))\n\n    def __add__(self, other):\n        from .arithmetic import Add\n\n        return Add(self, to_expr(other))\n\n    def __radd__(self, other):\n        from .arithmetic import Add\n\n        return Add(to_expr(other), self)\n\n    def __sub__(self, other):\n        from .arithmetic import Sub\n\n        return Sub(self, to_expr(other))\n\n    def __rsub__(self, other):\n        # e.g. 5 - a  \u21d2 Sub(Constant(5), a)\n        from .arithmetic import Sub\n\n        return Sub(to_expr(other), self)\n\n    def __truediv__(self, other):\n        from .arithmetic import Div\n\n        return Div(self, to_expr(other))\n\n    def __rtruediv__(self, other):\n        # e.g. 10 / a\n        from .arithmetic import Div\n\n        return Div(to_expr(other), self)\n\n    def __mul__(self, other):\n        from .arithmetic import Mul\n\n        return Mul(self, to_expr(other))\n\n    def __rmul__(self, other):\n        from .arithmetic import Mul\n\n        return Mul(to_expr(other), self)\n\n    def __matmul__(self, other):\n        from .arithmetic import MatMul\n\n        return MatMul(self, to_expr(other))\n\n    def __rmatmul__(self, other):\n        from .arithmetic import MatMul\n\n        return MatMul(to_expr(other), self)\n\n    def __rle__(self, other):\n        # other &lt;= self  =&gt;  Inequality(other, self)\n        from .constraint import Inequality\n\n        return Inequality(to_expr(other), self)\n\n    def __rge__(self, other):\n        # other &gt;= self  =&gt;  Inequality(self, other)\n        from .constraint import Inequality\n\n        return Inequality(self, to_expr(other))\n\n    def __req__(self, other):\n        # other == self  =&gt;  Equality(other, self)\n        from .constraint import Equality\n\n        return Equality(to_expr(other), self)\n\n    def __neg__(self):\n        from .arithmetic import Neg\n\n        return Neg(self)\n\n    def __pow__(self, other):\n        from .arithmetic import Power\n\n        return Power(self, to_expr(other))\n\n    def __rpow__(self, other):\n        from .arithmetic import Power\n\n        return Power(to_expr(other), self)\n\n    def __getitem__(self, idx):\n        from .array import Index\n\n        return Index(self, idx)\n\n    @property\n    def T(self):\n        \"\"\"Transpose property for matrix expressions.\n\n        Returns:\n            Transpose: A Transpose expression wrapping this expression\n\n        Example:\n            Create a transpose:\n\n                A = ox.State(\"A\", shape=(3, 4))\n                A_T = A.T  # Creates Transpose(A), result shape (4, 3)\n        \"\"\"\n        from .linalg import Transpose\n\n        return Transpose(self)\n\n    def at(self, k: int) -&gt; \"NodeReference\":\n        \"\"\"Reference this expression at a specific trajectory node.\n\n        This method enables inter-node constraints where you can reference\n        the value of an expression at different time steps. Common patterns\n        include rate limits and multi-step dependencies.\n\n        Args:\n            k: Absolute node index (integer) in the trajectory.\n               Can be positive (0, 1, 2, ...) or negative (-1 for last node).\n\n        Returns:\n            NodeReference: An expression representing this expression at node k\n\n        Example:\n            Rate limit constraint (applied across trajectory using a loop):\n\n                position = State(\"pos\", shape=(3,))\n\n                # Create rate limit for each node\n                constraints = [\n                    (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n                    for k in range(1, N)\n                ]\n\n            Multi-step dependency:\n\n                state = State(\"x\", shape=(1,))\n\n                # Fibonacci-like recurrence\n                constraints = [\n                    (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n                    for k in range(2, N)\n                ]\n\n        Performance Note:\n            Cross-node constraints use dense Jacobian storage which can be memory-intensive\n            for large N (&gt;100 nodes). See LoweredCrossNodeConstraint documentation for\n            details on memory usage and future sparse Jacobian support.\n        \"\"\"\n        return NodeReference(self, k)\n\n    def children(self):\n        \"\"\"Return the child expressions of this node.\n\n        Returns:\n            list: List of child Expr objects. Empty list for leaf nodes.\n        \"\"\"\n        return []\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"\n        Return a canonical (simplified) form of this expression.\n\n        Canonicalization performs algebraic simplifications such as:\n        - Constant folding (e.g., 2 + 3 \u2192 5)\n        - Identity elimination (e.g., x + 0 \u2192 x, x * 1 \u2192 x)\n        - Flattening nested operations (e.g., Add(Add(a, b), c) \u2192 Add(a, b, c))\n        - Algebraic rewrites (e.g., constraints to standard form)\n\n        Returns:\n            Expr: A canonical version of this expression\n\n        Raises:\n            NotImplementedError: If canonicalization is not implemented for this node type\n        \"\"\"\n        raise NotImplementedError(f\"canonicalize() not implemented for {self.__class__.__name__}\")\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"\n        Compute and validate the shape of this expression.\n\n        This method:\n        1. Recursively checks shapes of all child expressions\n        2. Validates that operations are shape-compatible (e.g., broadcasting rules)\n        3. Returns the output shape of this expression\n\n        For example:\n        - A Parameter with shape (3, 4) returns (3, 4)\n        - MatMul of (3, 4) @ (4, 5) returns (3, 5)\n        - Sum of any shape returns () (scalar)\n        - Add broadcasts shapes like NumPy\n\n        Returns:\n            tuple: The shape of this expression as a tuple of integers.\n                   Empty tuple () represents a scalar.\n\n        Raises:\n            NotImplementedError: If shape checking is not implemented for this node type\n            ValueError: If the expression has invalid shapes (e.g., incompatible dimensions)\n        \"\"\"\n        raise NotImplementedError(f\"check_shape() not implemented for {self.__class__.__name__}\")\n\n    def pretty(self, indent=0):\n        \"\"\"Generate a pretty-printed string representation of the expression tree.\n\n        Creates an indented, hierarchical view of the expression tree structure,\n        useful for debugging and visualization.\n\n        Args:\n            indent: Current indentation level (default: 0)\n\n        Returns:\n            str: Multi-line string representation of the expression tree\n\n        Example:\n            Pretty print an expression:\n\n                expr = (x + y) * z\n                print(expr.pretty())\n                # Mul\n                #   Add\n                #     State\n                #     State\n                #   State\n        \"\"\"\n        pad = \"  \" * indent\n        pad = \"  \" * indent\n        lines = [f\"{pad}{self.__class__.__name__}\"]\n        for child in self.children():\n            lines.append(child.pretty(indent + 1))\n        return \"\\n\".join(lines)\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Contribute this expression's structural identity to a hash.\n\n        This method is used to compute a structural hash of the expression tree\n        that is name-invariant (same structure = same hash regardless of variable names).\n\n        The default implementation hashes the class name and recursively hashes all\n        children. Subclasses with additional attributes (like Norm.ord, Index.index)\n        should override this to include those attributes.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        # Hash the class name to distinguish different node types\n        hasher.update(self.__class__.__name__.encode())\n        # Recursively hash all children\n        for child in self.children():\n            child._hash_into(hasher)\n\n    def structural_hash(self) -&gt; bytes:\n        \"\"\"Compute a structural hash of this expression.\n\n        Returns a hash that depends only on the mathematical structure of the\n        expression, not on variable names. Two expressions that are structurally\n        equivalent (same operations, same variable positions) will have the same hash.\n\n        Returns:\n            bytes: SHA-256 digest of the expression structure\n        \"\"\"\n        hasher = hashlib.sha256()\n        self._hash_into(hasher)\n        return hasher.digest()\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Expr.T","title":"<code>T</code>  <code>property</code>","text":"<p>Transpose property for matrix expressions.</p> <p>Returns:</p> Name Type Description <code>Transpose</code> <p>A Transpose expression wrapping this expression</p> Example <p>Create a transpose:</p> <pre><code>A = ox.State(\"A\", shape=(3, 4))\nA_T = A.T  # Creates Transpose(A), result shape (4, 3)\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Expr.at","title":"<code>at(k: int) -&gt; NodeReference</code>","text":"<p>Reference this expression at a specific trajectory node.</p> <p>This method enables inter-node constraints where you can reference the value of an expression at different time steps. Common patterns include rate limits and multi-step dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>Absolute node index (integer) in the trajectory. Can be positive (0, 1, 2, ...) or negative (-1 for last node).</p> required <p>Returns:</p> Name Type Description <code>NodeReference</code> <code>NodeReference</code> <p>An expression representing this expression at node k</p> Example <p>Rate limit constraint (applied across trajectory using a loop):</p> <pre><code>position = State(\"pos\", shape=(3,))\n\n# Create rate limit for each node\nconstraints = [\n    (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n    for k in range(1, N)\n]\n</code></pre> <p>Multi-step dependency:</p> <pre><code>state = State(\"x\", shape=(1,))\n\n# Fibonacci-like recurrence\nconstraints = [\n    (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n    for k in range(2, N)\n]\n</code></pre> Performance Note <p>Cross-node constraints use dense Jacobian storage which can be memory-intensive for large N (&gt;100 nodes). See LoweredCrossNodeConstraint documentation for details on memory usage and future sparse Jacobian support.</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def at(self, k: int) -&gt; \"NodeReference\":\n    \"\"\"Reference this expression at a specific trajectory node.\n\n    This method enables inter-node constraints where you can reference\n    the value of an expression at different time steps. Common patterns\n    include rate limits and multi-step dependencies.\n\n    Args:\n        k: Absolute node index (integer) in the trajectory.\n           Can be positive (0, 1, 2, ...) or negative (-1 for last node).\n\n    Returns:\n        NodeReference: An expression representing this expression at node k\n\n    Example:\n        Rate limit constraint (applied across trajectory using a loop):\n\n            position = State(\"pos\", shape=(3,))\n\n            # Create rate limit for each node\n            constraints = [\n                (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n                for k in range(1, N)\n            ]\n\n        Multi-step dependency:\n\n            state = State(\"x\", shape=(1,))\n\n            # Fibonacci-like recurrence\n            constraints = [\n                (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n                for k in range(2, N)\n            ]\n\n    Performance Note:\n        Cross-node constraints use dense Jacobian storage which can be memory-intensive\n        for large N (&gt;100 nodes). See LoweredCrossNodeConstraint documentation for\n        details on memory usage and future sparse Jacobian support.\n    \"\"\"\n    return NodeReference(self, k)\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Expr.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Return a canonical (simplified) form of this expression.</p> <p>Canonicalization performs algebraic simplifications such as: - Constant folding (e.g., 2 + 3 \u2192 5) - Identity elimination (e.g., x + 0 \u2192 x, x * 1 \u2192 x) - Flattening nested operations (e.g., Add(Add(a, b), c) \u2192 Add(a, b, c)) - Algebraic rewrites (e.g., constraints to standard form)</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>A canonical version of this expression</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If canonicalization is not implemented for this node type</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"\n    Return a canonical (simplified) form of this expression.\n\n    Canonicalization performs algebraic simplifications such as:\n    - Constant folding (e.g., 2 + 3 \u2192 5)\n    - Identity elimination (e.g., x + 0 \u2192 x, x * 1 \u2192 x)\n    - Flattening nested operations (e.g., Add(Add(a, b), c) \u2192 Add(a, b, c))\n    - Algebraic rewrites (e.g., constraints to standard form)\n\n    Returns:\n        Expr: A canonical version of this expression\n\n    Raises:\n        NotImplementedError: If canonicalization is not implemented for this node type\n    \"\"\"\n    raise NotImplementedError(f\"canonicalize() not implemented for {self.__class__.__name__}\")\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Expr.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Compute and validate the shape of this expression.</p> <p>This method: 1. Recursively checks shapes of all child expressions 2. Validates that operations are shape-compatible (e.g., broadcasting rules) 3. Returns the output shape of this expression</p> <p>For example: - A Parameter with shape (3, 4) returns (3, 4) - MatMul of (3, 4) @ (4, 5) returns (3, 5) - Sum of any shape returns () (scalar) - Add broadcasts shapes like NumPy</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The shape of this expression as a tuple of integers.    Empty tuple () represents a scalar.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If shape checking is not implemented for this node type</p> <code>ValueError</code> <p>If the expression has invalid shapes (e.g., incompatible dimensions)</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"\n    Compute and validate the shape of this expression.\n\n    This method:\n    1. Recursively checks shapes of all child expressions\n    2. Validates that operations are shape-compatible (e.g., broadcasting rules)\n    3. Returns the output shape of this expression\n\n    For example:\n    - A Parameter with shape (3, 4) returns (3, 4)\n    - MatMul of (3, 4) @ (4, 5) returns (3, 5)\n    - Sum of any shape returns () (scalar)\n    - Add broadcasts shapes like NumPy\n\n    Returns:\n        tuple: The shape of this expression as a tuple of integers.\n               Empty tuple () represents a scalar.\n\n    Raises:\n        NotImplementedError: If shape checking is not implemented for this node type\n        ValueError: If the expression has invalid shapes (e.g., incompatible dimensions)\n    \"\"\"\n    raise NotImplementedError(f\"check_shape() not implemented for {self.__class__.__name__}\")\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Expr.children","title":"<code>children()</code>","text":"<p>Return the child expressions of this node.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of child Expr objects. Empty list for leaf nodes.</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def children(self):\n    \"\"\"Return the child expressions of this node.\n\n    Returns:\n        list: List of child Expr objects. Empty list for leaf nodes.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Expr.pretty","title":"<code>pretty(indent=0)</code>","text":"<p>Generate a pretty-printed string representation of the expression tree.</p> <p>Creates an indented, hierarchical view of the expression tree structure, useful for debugging and visualization.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <p>Current indentation level (default: 0)</p> <code>0</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Multi-line string representation of the expression tree</p> Example <p>Pretty print an expression:</p> <pre><code>expr = (x + y) * z\nprint(expr.pretty())\n# Mul\n#   Add\n#     State\n#     State\n#   State\n</code></pre> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def pretty(self, indent=0):\n    \"\"\"Generate a pretty-printed string representation of the expression tree.\n\n    Creates an indented, hierarchical view of the expression tree structure,\n    useful for debugging and visualization.\n\n    Args:\n        indent: Current indentation level (default: 0)\n\n    Returns:\n        str: Multi-line string representation of the expression tree\n\n    Example:\n        Pretty print an expression:\n\n            expr = (x + y) * z\n            print(expr.pretty())\n            # Mul\n            #   Add\n            #     State\n            #     State\n            #   State\n    \"\"\"\n    pad = \"  \" * indent\n    pad = \"  \" * indent\n    lines = [f\"{pad}{self.__class__.__name__}\"]\n    for child in self.children():\n        lines.append(child.pretty(indent + 1))\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Expr.structural_hash","title":"<code>structural_hash() -&gt; bytes</code>","text":"<p>Compute a structural hash of this expression.</p> <p>Returns a hash that depends only on the mathematical structure of the expression, not on variable names. Two expressions that are structurally equivalent (same operations, same variable positions) will have the same hash.</p> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>SHA-256 digest of the expression structure</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def structural_hash(self) -&gt; bytes:\n    \"\"\"Compute a structural hash of this expression.\n\n    Returns a hash that depends only on the mathematical structure of the\n    expression, not on variable names. Two expressions that are structurally\n    equivalent (same operations, same variable positions) will have the same hash.\n\n    Returns:\n        bytes: SHA-256 digest of the expression structure\n    \"\"\"\n    hasher = hashlib.sha256()\n    self._hash_into(hasher)\n    return hasher.digest()\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Leaf","title":"<code>Leaf</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Base class for leaf nodes (terminal expressions) in the symbolic expression tree.</p> <p>Leaf nodes represent named symbolic variables that don't have child expressions. This includes Parameters, Variables, States, and Controls.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the leaf node</p> <code>_shape</code> <code>tuple</code> <p>Shape of the leaf node</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class Leaf(Expr):\n    \"\"\"\n    Base class for leaf nodes (terminal expressions) in the symbolic expression tree.\n\n    Leaf nodes represent named symbolic variables that don't have child expressions.\n    This includes Parameters, Variables, States, and Controls.\n\n    Attributes:\n        name (str): Name identifier for the leaf node\n        _shape (tuple): Shape of the leaf node\n    \"\"\"\n\n    def __init__(self, name: str, shape: tuple = ()):\n        \"\"\"Initialize a Leaf node.\n\n        Args:\n            name (str): Name identifier for the leaf node\n            shape (tuple): Shape of the leaf node\n        \"\"\"\n        super().__init__()\n        self.name = name\n        self._shape = shape\n\n    @property\n    def shape(self):\n        \"\"\"Get the shape of the leaf node.\n\n        Returns:\n            tuple: Shape of the leaf node\n        \"\"\"\n        return self._shape\n\n    def children(self):\n        \"\"\"Leaf nodes have no children.\n\n        Returns:\n            list: Empty list since leaf nodes are terminal\n        \"\"\"\n        return []\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Leaf nodes are already in canonical form.\n\n        Returns:\n            Expr: Returns self since leaf nodes are already canonical\n        \"\"\"\n        return self\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Return the shape of this leaf node.\n\n        Returns:\n            tuple: The shape of the leaf node\n        \"\"\"\n        return self._shape\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash leaf node by class name and shape.\n\n        This base implementation hashes the class name and shape. Subclasses\n        like Variable and Parameter override this to add their specific\n        canonical identifiers (_slice for Variables, value for Parameters).\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(self.__class__.__name__.encode())\n        hasher.update(str(self._shape).encode())\n\n    def __repr__(self):\n        \"\"\"String representation of the leaf node.\n\n        Returns:\n            str: A string describing the leaf node\n        \"\"\"\n        return f\"{self.__class__.__name__}('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Leaf.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Get the shape of the leaf node.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Shape of the leaf node</p>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Leaf.__init__","title":"<code>__init__(name: str, shape: tuple = ())</code>","text":"<p>Initialize a Leaf node.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name identifier for the leaf node</p> required <code>shape</code> <code>tuple</code> <p>Shape of the leaf node</p> <code>()</code> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def __init__(self, name: str, shape: tuple = ()):\n    \"\"\"Initialize a Leaf node.\n\n    Args:\n        name (str): Name identifier for the leaf node\n        shape (tuple): Shape of the leaf node\n    \"\"\"\n    super().__init__()\n    self.name = name\n    self._shape = shape\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Leaf.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Leaf nodes are already in canonical form.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Returns self since leaf nodes are already canonical</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Leaf nodes are already in canonical form.\n\n    Returns:\n        Expr: Returns self since leaf nodes are already canonical\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Leaf.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Return the shape of this leaf node.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The shape of the leaf node</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Return the shape of this leaf node.\n\n    Returns:\n        tuple: The shape of the leaf node\n    \"\"\"\n    return self._shape\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Leaf.children","title":"<code>children()</code>","text":"<p>Leaf nodes have no children.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Empty list since leaf nodes are terminal</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def children(self):\n    \"\"\"Leaf nodes have no children.\n\n    Returns:\n        list: Empty list since leaf nodes are terminal\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.NodeReference","title":"<code>NodeReference</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Reference to a variable at a specific trajectory node.</p> <p>NodeReference enables inter-node constraints by allowing you to reference the value of a state or control variable at a specific discrete time point (node) in the trajectory. This is essential for expressing temporal relationships such as:</p> <ul> <li>Rate limits and smoothness constraints</li> <li>Multi-step dependencies and recurrence relations</li> <li>Constraints coupling specific nodes</li> </ul> <p>Attributes:</p> Name Type Description <code>base</code> <p>The expression (typically a Leaf like State or Control) being referenced</p> <code>node_idx</code> <p>Trajectory node index (integer, can be negative for end-indexing)</p> Example <p>Rate limit across trajectory:</p> <pre><code>position = State(\"pos\", shape=(3,))\n\n# Create rate limit constraints for all nodes\nconstraints = [\n    (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n    for k in range(1, N)\n]\n</code></pre> <p>Multi-step dependency:</p> <pre><code>state = State(\"x\", shape=(1,))\n\n# Fibonacci-like recurrence at each node\nconstraints = [\n    (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n    for k in range(2, N)\n]\n</code></pre> <p>Coupling specific nodes:</p> <pre><code># Constrain distance between nodes 5 and 10\ncoupling = (position.at(10) - position.at(5) &lt;= threshold).at([10])\n</code></pre> Performance Note <p>Cross-node constraints use dense Jacobian storage. For details on memory usage and performance implications, see LoweredCrossNodeConstraint documentation.</p> Note <p>NodeReference is typically created via the <code>.at(k)</code> method on expressions rather than constructed directly.</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class NodeReference(Expr):\n    \"\"\"Reference to a variable at a specific trajectory node.\n\n    NodeReference enables inter-node constraints by allowing you to reference\n    the value of a state or control variable at a specific discrete time point\n    (node) in the trajectory. This is essential for expressing temporal relationships\n    such as:\n\n    - Rate limits and smoothness constraints\n    - Multi-step dependencies and recurrence relations\n    - Constraints coupling specific nodes\n\n    Attributes:\n        base: The expression (typically a Leaf like State or Control) being referenced\n        node_idx: Trajectory node index (integer, can be negative for end-indexing)\n\n    Example:\n        Rate limit across trajectory:\n\n            position = State(\"pos\", shape=(3,))\n\n            # Create rate limit constraints for all nodes\n            constraints = [\n                (ox.linalg.Norm(position.at(k) - position.at(k-1)) &lt;= 0.1).at([k])\n                for k in range(1, N)\n            ]\n\n        Multi-step dependency:\n\n            state = State(\"x\", shape=(1,))\n\n            # Fibonacci-like recurrence at each node\n            constraints = [\n                (state.at(k) == state.at(k-1) + state.at(k-2)).at([k])\n                for k in range(2, N)\n            ]\n\n        Coupling specific nodes:\n\n            # Constrain distance between nodes 5 and 10\n            coupling = (position.at(10) - position.at(5) &lt;= threshold).at([10])\n\n    Performance Note:\n        Cross-node constraints use dense Jacobian storage. For details on memory\n        usage and performance implications, see LoweredCrossNodeConstraint documentation.\n\n    Note:\n        NodeReference is typically created via the `.at(k)` method on expressions\n        rather than constructed directly.\n    \"\"\"\n\n    def __init__(self, base: Expr, node_idx: int):\n        \"\"\"Initialize a NodeReference.\n\n        Args:\n            base: Expression to reference at a specific node (typically a Leaf)\n            node_idx: Absolute trajectory node index (integer)\n                     Supports negative indexing (e.g., -1 for last node)\n\n        Raises:\n            TypeError: If node_idx is not an integer\n        \"\"\"\n        if not isinstance(node_idx, int):\n            raise TypeError(f\"Node index must be an integer, got {type(node_idx).__name__}\")\n\n        self.node_idx = node_idx\n        self.base = base\n\n    def children(self):\n        \"\"\"Return the base expression as the only child.\n\n        Returns:\n            list: Single-element list containing the base expression\n        \"\"\"\n        return [self.base]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize by canonicalizing the base expression.\n\n        Returns:\n            NodeReference: A new NodeReference with canonicalized base\n        \"\"\"\n        canon_base = self.base.canonicalize()\n        return NodeReference(canon_base, self.node_idx)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Return the shape of the base expression.\n\n        NodeReference doesn't change the shape of the underlying expression,\n        it just references it at a specific time point.\n\n        Returns:\n            tuple: The shape of the base expression\n        \"\"\"\n        return self.base.check_shape()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash NodeReference including its node index.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"NodeReference\")\n        # Hash the node index (signed int)\n        hasher.update(struct.pack(\"&gt;i\", self.node_idx))\n        # Hash the base expression\n        self.base._hash_into(hasher)\n\n    def __repr__(self):\n        \"\"\"String representation of the NodeReference.\n\n        Returns:\n            str: String showing the base expression and node index\n        \"\"\"\n        return f\"{self.base!r}.at({self.node_idx})\"\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.NodeReference.__init__","title":"<code>__init__(base: Expr, node_idx: int)</code>","text":"<p>Initialize a NodeReference.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>Expr</code> <p>Expression to reference at a specific node (typically a Leaf)</p> required <code>node_idx</code> <code>int</code> <p>Absolute trajectory node index (integer)      Supports negative indexing (e.g., -1 for last node)</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If node_idx is not an integer</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def __init__(self, base: Expr, node_idx: int):\n    \"\"\"Initialize a NodeReference.\n\n    Args:\n        base: Expression to reference at a specific node (typically a Leaf)\n        node_idx: Absolute trajectory node index (integer)\n                 Supports negative indexing (e.g., -1 for last node)\n\n    Raises:\n        TypeError: If node_idx is not an integer\n    \"\"\"\n    if not isinstance(node_idx, int):\n        raise TypeError(f\"Node index must be an integer, got {type(node_idx).__name__}\")\n\n    self.node_idx = node_idx\n    self.base = base\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.NodeReference.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize by canonicalizing the base expression.</p> <p>Returns:</p> Name Type Description <code>NodeReference</code> <code>Expr</code> <p>A new NodeReference with canonicalized base</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize by canonicalizing the base expression.\n\n    Returns:\n        NodeReference: A new NodeReference with canonicalized base\n    \"\"\"\n    canon_base = self.base.canonicalize()\n    return NodeReference(canon_base, self.node_idx)\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.NodeReference.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Return the shape of the base expression.</p> <p>NodeReference doesn't change the shape of the underlying expression, it just references it at a specific time point.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>The shape of the base expression</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Return the shape of the base expression.\n\n    NodeReference doesn't change the shape of the underlying expression,\n    it just references it at a specific time point.\n\n    Returns:\n        tuple: The shape of the base expression\n    \"\"\"\n    return self.base.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.NodeReference.children","title":"<code>children()</code>","text":"<p>Return the base expression as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the base expression</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def children(self):\n    \"\"\"Return the base expression as the only child.\n\n    Returns:\n        list: Single-element list containing the base expression\n    \"\"\"\n    return [self.base]\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Parameter","title":"<code>Parameter</code>","text":"<p>               Bases: <code>Leaf</code></p> <p>Parameter that can be changed at runtime without recompilation.</p> <p>Parameters are symbolic variables with initial values that can be updated through the problem's parameter dictionary. They allow for efficient parameter sweeps without needing to recompile the optimization problem.</p> Example <p>obs_center = ox.Parameter(\"obs_center\", shape=(3,), value=np.array([1.0, 0.0, 0.0]))</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>class Parameter(Leaf):\n    \"\"\"Parameter that can be changed at runtime without recompilation.\n\n    Parameters are symbolic variables with initial values that can be updated\n    through the problem's parameter dictionary. They allow for efficient\n    parameter sweeps without needing to recompile the optimization problem.\n\n    Example:\n        obs_center = ox.Parameter(\"obs_center\", shape=(3,), value=np.array([1.0, 0.0, 0.0]))\n        # Later: problem.parameters[\"obs_center\"] = new_value\n    \"\"\"\n\n    def __init__(self, name: str, shape: tuple = (), value=None):\n        \"\"\"Initialize a Parameter node.\n\n        Args:\n            name (str): Name identifier for the parameter\n            shape (tuple): Shape of the parameter (default: scalar)\n            value: Initial value for the parameter (required)\n        \"\"\"\n        super().__init__(name, shape)\n        if value is None:\n            raise ValueError(f\"Parameter '{name}' requires an initial value\")\n        self.value = np.asarray(value, dtype=float)\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Parameter by its shape only (value-invariant).\n\n        Parameters are hashed by shape only, not by value. This allows the same\n        compiled solver to be reused across parameter sweeps - only the structure\n        matters for compilation, not the actual values.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Parameter\")\n        hasher.update(str(self._shape).encode())\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Parameter--later-problemparametersobs_center-new_value","title":"Later: problem.parameters[\"obs_center\"] = new_value","text":""},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.Parameter.__init__","title":"<code>__init__(name: str, shape: tuple = (), value=None)</code>","text":"<p>Initialize a Parameter node.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name identifier for the parameter</p> required <code>shape</code> <code>tuple</code> <p>Shape of the parameter (default: scalar)</p> <code>()</code> <code>value</code> <p>Initial value for the parameter (required)</p> <code>None</code> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def __init__(self, name: str, shape: tuple = (), value=None):\n    \"\"\"Initialize a Parameter node.\n\n    Args:\n        name (str): Name identifier for the parameter\n        shape (tuple): Shape of the parameter (default: scalar)\n        value: Initial value for the parameter (required)\n    \"\"\"\n    super().__init__(name, shape)\n    if value is None:\n        raise ValueError(f\"Parameter '{name}' requires an initial value\")\n    self.value = np.asarray(value, dtype=float)\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.to_expr","title":"<code>to_expr(x: Union[Expr, float, int, np.ndarray]) -&gt; Expr</code>","text":"<p>Convert a value to an Expr if it is not already one.</p> <p>This is a convenience function that wraps numeric values and arrays as Constant expressions, while leaving Expr instances unchanged. Used internally by operators to ensure operands are proper Expr objects.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[Expr, float, int, ndarray]</code> <p>Value to convert - can be an Expr, numeric scalar, or numpy array</p> required <p>Returns:</p> Type Description <code>Expr</code> <p>The input if it's already an Expr, otherwise a Constant wrapping the value</p> Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def to_expr(x: Union[Expr, float, int, np.ndarray]) -&gt; Expr:\n    \"\"\"Convert a value to an Expr if it is not already one.\n\n    This is a convenience function that wraps numeric values and arrays as Constant\n    expressions, while leaving Expr instances unchanged. Used internally by operators\n    to ensure operands are proper Expr objects.\n\n    Args:\n        x: Value to convert - can be an Expr, numeric scalar, or numpy array\n\n    Returns:\n        The input if it's already an Expr, otherwise a Constant wrapping the value\n    \"\"\"\n    return x if isinstance(x, Expr) else Constant(np.array(x))\n</code></pre>"},{"location":"reference/symbolic/expr/expr/#openscvx.symbolic.expr.expr.traverse","title":"<code>traverse(expr: Expr, visit: Callable[[Expr], None])</code>","text":"<p>Depth-first traversal of an expression tree.</p> <p>Visits each node in the expression tree by applying the visit function to the current node, then recursively visiting all children.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Root expression node to start traversal from</p> required <code>visit</code> <code>Callable[[Expr], None]</code> <p>Callback function applied to each node during traversal</p> required Source code in <code>openscvx/symbolic/expr/expr.py</code> <pre><code>def traverse(expr: Expr, visit: Callable[[Expr], None]):\n    \"\"\"Depth-first traversal of an expression tree.\n\n    Visits each node in the expression tree by applying the visit function to the\n    current node, then recursively visiting all children.\n\n    Args:\n        expr: Root expression node to start traversal from\n        visit: Callback function applied to each node during traversal\n    \"\"\"\n    visit(expr)\n    for child in expr.children():\n        traverse(child, visit)\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/","title":"linalg","text":"<p>Linear algebra operations for symbolic expressions.</p> <p>This module provides essential linear algebra operations for matrix and vector manipulation in optimization problems. Operations follow NumPy/JAX conventions for shapes and broadcasting behavior.</p> Key Operations <ul> <li>Matrix Operations:<ul> <li><code>Transpose</code> - Matrix/tensor transposition (swaps last two dimensions)</li> <li><code>Diag</code> - Construct diagonal matrix from vector</li> <li><code>Inv</code> - Matrix inverse (square matrices only, JAX lowering only)</li> </ul> </li> <li>Reductions:<ul> <li><code>Sum</code> - Sum all elements of an array (reduces to scalar)</li> <li><code>Norm</code> - Euclidean (L2) norm and other norms of vectors/matrices</li> </ul> </li> </ul> Note <p>For array manipulation operations like stacking and concatenation, see the <code>array</code> module.</p> Example <p>Matrix transposition and diagonal matrices::</p> <pre><code>import openscvx as ox\nimport numpy as np\n\n# Transpose a matrix\nA = ox.State(\"A\", shape=(3, 4))\nA_T = A.T  # Result shape (4, 3)\n\n# Create a diagonal matrix\nv = ox.State(\"v\", shape=(5,))\nD = ox.Diag(v)  # Result shape (5, 5)\n</code></pre> <p>Reduction operations::</p> <pre><code>x = ox.State(\"x\", shape=(3, 4))\n\n# Sum all elements\ntotal = ox.Sum(x)  # Result is scalar\n\n# Compute norm\nmagnitude = ox.Norm(x)  # Result is scalar\n</code></pre> <p>Computing kinetic energy with norms::</p> <pre><code>v = ox.State(\"v\", shape=(3,))  # Velocity vector\nm = 10.0  # Mass\nkinetic_energy = 0.5 * m * ox.Norm(v)**2\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Diag","title":"<code>Diag</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Diagonal matrix construction from a vector.</p> <p>Creates a square diagonal matrix from a 1D vector. The vector elements become the diagonal entries, with all off-diagonal entries set to zero. This is analogous to numpy.diag() or jax.numpy.diag().</p> Note <p>Currently only supports creating diagonal matrices from vectors. Extracting diagonals from matrices is not yet implemented.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>1D vector expression to place on the diagonal</p> Example <p>Define a Diag:</p> <pre><code>v = Variable(\"v\", shape=(3,))\nD = Diag(v)  # Creates a (3, 3) diagonal matrix\n</code></pre> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>class Diag(Expr):\n    \"\"\"Diagonal matrix construction from a vector.\n\n    Creates a square diagonal matrix from a 1D vector. The vector elements become\n    the diagonal entries, with all off-diagonal entries set to zero. This is\n    analogous to numpy.diag() or jax.numpy.diag().\n\n    Note:\n        Currently only supports creating diagonal matrices from vectors.\n        Extracting diagonals from matrices is not yet implemented.\n\n    Attributes:\n        operand: 1D vector expression to place on the diagonal\n\n    Example:\n        Define a Diag:\n\n            v = Variable(\"v\", shape=(3,))\n            D = Diag(v)  # Creates a (3, 3) diagonal matrix\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a diagonal matrix operation.\n\n        Args:\n            operand: 1D vector expression to place on the diagonal\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Diag(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Diag converts a vector (n,) to a diagonal matrix (n,n).\"\"\"\n        operand_shape = self.operand.check_shape()\n        if len(operand_shape) != 1:\n            raise ValueError(f\"Diag expects a 1D vector, got shape {operand_shape}\")\n        n = operand_shape[0]\n        return (n, n)\n\n    def __repr__(self):\n        return f\"diag({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Diag.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a diagonal matrix operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>1D vector expression to place on the diagonal</p> required Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a diagonal matrix operation.\n\n    Args:\n        operand: 1D vector expression to place on the diagonal\n    \"\"\"\n    self.operand = to_expr(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Diag.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Diag converts a vector (n,) to a diagonal matrix (n,n).</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Diag converts a vector (n,) to a diagonal matrix (n,n).\"\"\"\n    operand_shape = self.operand.check_shape()\n    if len(operand_shape) != 1:\n        raise ValueError(f\"Diag expects a 1D vector, got shape {operand_shape}\")\n    n = operand_shape[0]\n    return (n, n)\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Inv","title":"<code>Inv</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Matrix inverse operation for symbolic expressions.</p> <p>Computes the inverse of a square matrix. For batched inputs with shape (..., M, M), inverts the last two dimensions following jax.numpy.linalg.inv conventions.</p> <p>The canonicalization includes an optimization that eliminates double inverses: Inv(Inv(A)) simplifies to A.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Square matrix expression to invert</p> Example <p>Define matrix inverse expressions::</p> <pre><code>M = Variable(\"M\", shape=(3, 3))\nM_inv = Inv(M)  # Result shape (3, 3)\n\n# Batched case\nM_batch = Variable(\"M_batch\", shape=(5, 3, 3))\nM_batch_inv = Inv(M_batch)  # Result shape (5, 3, 3)\n</code></pre> Note <p>Matrix inverse is non-convex and only supported in JAX lowering. CVXPy lowering will raise NotImplementedError since inv(X) is neither convex nor concave for variable matrices.</p> <p>Warning</p> <p>Solving a matrix inverse inside an optimization loop can be somewhat of an oxymoron and performance may be severly impacted. Consider whether your problem can be reformulated to avoid the inverse.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>class Inv(Expr):\n    \"\"\"Matrix inverse operation for symbolic expressions.\n\n    Computes the inverse of a square matrix. For batched inputs with shape\n    (..., M, M), inverts the last two dimensions following jax.numpy.linalg.inv\n    conventions.\n\n    The canonicalization includes an optimization that eliminates double inverses:\n    Inv(Inv(A)) simplifies to A.\n\n    Attributes:\n        operand: Square matrix expression to invert\n\n    Example:\n        Define matrix inverse expressions::\n\n            M = Variable(\"M\", shape=(3, 3))\n            M_inv = Inv(M)  # Result shape (3, 3)\n\n            # Batched case\n            M_batch = Variable(\"M_batch\", shape=(5, 3, 3))\n            M_batch_inv = Inv(M_batch)  # Result shape (5, 3, 3)\n\n    Note:\n        Matrix inverse is non-convex and only supported in JAX lowering.\n        CVXPy lowering will raise NotImplementedError since inv(X) is neither\n        convex nor concave for variable matrices.\n\n    !!! warning\n        Solving a matrix inverse inside an optimization loop can be somewhat\n        of an oxymoron and performance may be severly impacted.\n        Consider whether your problem can be reformulated to avoid the inverse.\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a matrix inverse operation.\n\n        Args:\n            operand: Square matrix expression to invert. Must have shape\n                (..., M, M) where the last two dimensions are equal.\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the operand with double inverse optimization and constant folding.\"\"\"\n        operand = self.operand.canonicalize()\n\n        # Double inverse optimization: Inv(Inv(A)) = A\n        if isinstance(operand, Inv):\n            return operand.operand\n\n        # Constant folding: compute inverse at canonicalization time\n        if isinstance(operand, Constant):\n            return Constant(np.linalg.inv(operand.value))\n\n        return Inv(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Matrix inverse preserves shape; validates square matrix.\"\"\"\n        operand_shape = self.operand.check_shape()\n\n        if len(operand_shape) &lt; 2:\n            raise ValueError(f\"Inv requires at least a 2D matrix, got shape {operand_shape}\")\n\n        if operand_shape[-1] != operand_shape[-2]:\n            raise ValueError(\n                f\"Inv requires a square matrix (last two dims must be equal), \"\n                f\"got shape {operand_shape}\"\n            )\n\n        return operand_shape\n\n    def __repr__(self):\n        return f\"inv({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Inv.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a matrix inverse operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Square matrix expression to invert. Must have shape (..., M, M) where the last two dimensions are equal.</p> required Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a matrix inverse operation.\n\n    Args:\n        operand: Square matrix expression to invert. Must have shape\n            (..., M, M) where the last two dimensions are equal.\n    \"\"\"\n    self.operand = to_expr(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Inv.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the operand with double inverse optimization and constant folding.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the operand with double inverse optimization and constant folding.\"\"\"\n    operand = self.operand.canonicalize()\n\n    # Double inverse optimization: Inv(Inv(A)) = A\n    if isinstance(operand, Inv):\n        return operand.operand\n\n    # Constant folding: compute inverse at canonicalization time\n    if isinstance(operand, Constant):\n        return Constant(np.linalg.inv(operand.value))\n\n    return Inv(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Inv.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Matrix inverse preserves shape; validates square matrix.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Matrix inverse preserves shape; validates square matrix.\"\"\"\n    operand_shape = self.operand.check_shape()\n\n    if len(operand_shape) &lt; 2:\n        raise ValueError(f\"Inv requires at least a 2D matrix, got shape {operand_shape}\")\n\n    if operand_shape[-1] != operand_shape[-2]:\n        raise ValueError(\n            f\"Inv requires a square matrix (last two dims must be equal), \"\n            f\"got shape {operand_shape}\"\n        )\n\n    return operand_shape\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Norm","title":"<code>Norm</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Norm operation for symbolic expressions (reduction to scalar).</p> <p>Computes the norm of an expression according to the specified order parameter. This is a reduction operation that always produces a scalar result regardless of the input shape. Supports various norm types following NumPy/SciPy conventions.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to compute norm of</p> <code>ord</code> <p>Norm order specification (default: \"fro\" for Frobenius norm) - \"fro\": Frobenius norm (default) - \"inf\": Infinity norm - 1: L1 norm (sum of absolute values) - 2: L2 norm (Euclidean norm) - Other values as supported by the backend</p> Example <p>Define Norms:</p> <pre><code>x = Variable(\"x\", shape=(3,))\neuclidean_norm = Norm(x, ord=2)  # L2 norm, result is scalar\nA = Variable(\"A\", shape=(3, 4))\nfrobenius_norm = Norm(A)  # Frobenius norm, result is scalar\n</code></pre> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>class Norm(Expr):\n    \"\"\"Norm operation for symbolic expressions (reduction to scalar).\n\n    Computes the norm of an expression according to the specified order parameter.\n    This is a reduction operation that always produces a scalar result regardless\n    of the input shape. Supports various norm types following NumPy/SciPy conventions.\n\n    Attributes:\n        operand: Expression to compute norm of\n        ord: Norm order specification (default: \"fro\" for Frobenius norm)\n            - \"fro\": Frobenius norm (default)\n            - \"inf\": Infinity norm\n            - 1: L1 norm (sum of absolute values)\n            - 2: L2 norm (Euclidean norm)\n            - Other values as supported by the backend\n\n    Example:\n        Define Norms:\n\n            x = Variable(\"x\", shape=(3,))\n            euclidean_norm = Norm(x, ord=2)  # L2 norm, result is scalar\n            A = Variable(\"A\", shape=(3, 4))\n            frobenius_norm = Norm(A)  # Frobenius norm, result is scalar\n    \"\"\"\n\n    def __init__(self, operand, ord=\"fro\"):\n        \"\"\"Initialize a norm operation.\n\n        Args:\n            operand: Expression to compute norm of\n            ord: Norm order specification (default: \"fro\")\n        \"\"\"\n        self.operand = to_expr(operand)\n        self.ord = ord  # Can be \"fro\", \"inf\", 1, 2, etc.\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the operand but preserve the ord parameter.\"\"\"\n        canon_operand = self.operand.canonicalize()\n        return Norm(canon_operand, ord=self.ord)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Norm reduces any shape to a scalar.\"\"\"\n        # Validate that the operand has a valid shape\n        self.operand.check_shape()\n        # Norm always produces a scalar regardless of input shape\n        return ()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Norm including its ord parameter.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Norm\")\n        # Hash the ord parameter\n        hasher.update(repr(self.ord).encode())\n        # Hash the operand\n        self.operand._hash_into(hasher)\n\n    def __repr__(self):\n        return f\"norm({self.operand!r}, ord={self.ord!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Norm.__init__","title":"<code>__init__(operand, ord='fro')</code>","text":"<p>Initialize a norm operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to compute norm of</p> required <code>ord</code> <p>Norm order specification (default: \"fro\")</p> <code>'fro'</code> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def __init__(self, operand, ord=\"fro\"):\n    \"\"\"Initialize a norm operation.\n\n    Args:\n        operand: Expression to compute norm of\n        ord: Norm order specification (default: \"fro\")\n    \"\"\"\n    self.operand = to_expr(operand)\n    self.ord = ord  # Can be \"fro\", \"inf\", 1, 2, etc.\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Norm.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the operand but preserve the ord parameter.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the operand but preserve the ord parameter.\"\"\"\n    canon_operand = self.operand.canonicalize()\n    return Norm(canon_operand, ord=self.ord)\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Norm.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Norm reduces any shape to a scalar.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Norm reduces any shape to a scalar.\"\"\"\n    # Validate that the operand has a valid shape\n    self.operand.check_shape()\n    # Norm always produces a scalar regardless of input shape\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Sum","title":"<code>Sum</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Sum reduction operation for symbolic expressions.</p> <p>Sums all elements of an expression, reducing it to a scalar. This is a reduction operation that collapses all dimensions.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression whose elements will be summed</p> Example <p>Define a Sum expression::</p> <pre><code>x = ox.State(\"x\", shape=(3, 4))\ntotal = Sum(x)  # Creates Sum(x), result shape ()\n</code></pre> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>class Sum(Expr):\n    \"\"\"Sum reduction operation for symbolic expressions.\n\n    Sums all elements of an expression, reducing it to a scalar. This is a\n    reduction operation that collapses all dimensions.\n\n    Attributes:\n        operand: Expression whose elements will be summed\n\n    Example:\n        Define a Sum expression::\n\n            x = ox.State(\"x\", shape=(3, 4))\n            total = Sum(x)  # Creates Sum(x), result shape ()\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a sum reduction operation.\n\n        Args:\n            operand: Expression to sum over all elements\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize sum: canonicalize the operand.\n\n        Returns:\n            Expr: Canonical form of the sum expression\n        \"\"\"\n        operand = self.operand.canonicalize()\n        return Sum(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Sum reduces any shape to a scalar.\"\"\"\n        # Validate that the operand has a valid shape\n        self.operand.check_shape()\n        # Sum always produces a scalar regardless of input shape\n        return ()\n\n    def __repr__(self):\n        return f\"sum({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Sum.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a sum reduction operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to sum over all elements</p> required Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a sum reduction operation.\n\n    Args:\n        operand: Expression to sum over all elements\n    \"\"\"\n    self.operand = to_expr(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Sum.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize sum: canonicalize the operand.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the sum expression</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize sum: canonicalize the operand.\n\n    Returns:\n        Expr: Canonical form of the sum expression\n    \"\"\"\n    operand = self.operand.canonicalize()\n    return Sum(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Sum.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Sum reduces any shape to a scalar.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Sum reduces any shape to a scalar.\"\"\"\n    # Validate that the operand has a valid shape\n    self.operand.check_shape()\n    # Sum always produces a scalar regardless of input shape\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Transpose","title":"<code>Transpose</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Matrix transpose operation for symbolic expressions.</p> <p>Transposes the last two dimensions of an expression. For matrices, this swaps rows and columns. For higher-dimensional arrays, it swaps the last two axes. Scalars and vectors are unchanged by transposition.</p> <p>The canonicalization includes an optimization that eliminates double transposes: (A.T).T simplifies to A.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to transpose</p> Example <p>Define Tranpose expressions:</p> <pre><code>A = Variable(\"A\", shape=(3, 4))\nA_T = Transpose(A)  # or A.T, result shape (4, 3)\nv = Variable(\"v\", shape=(5,))\nv_T = Transpose(v)  # result shape (5,) - vectors unchanged\n</code></pre> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>class Transpose(Expr):\n    \"\"\"Matrix transpose operation for symbolic expressions.\n\n    Transposes the last two dimensions of an expression. For matrices, this swaps\n    rows and columns. For higher-dimensional arrays, it swaps the last two axes.\n    Scalars and vectors are unchanged by transposition.\n\n    The canonicalization includes an optimization that eliminates double transposes:\n    (A.T).T simplifies to A.\n\n    Attributes:\n        operand: Expression to transpose\n\n    Example:\n        Define Tranpose expressions:\n\n            A = Variable(\"A\", shape=(3, 4))\n            A_T = Transpose(A)  # or A.T, result shape (4, 3)\n            v = Variable(\"v\", shape=(5,))\n            v_T = Transpose(v)  # result shape (5,) - vectors unchanged\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a transpose operation.\n\n        Args:\n            operand: Expression to transpose\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the operand with double transpose optimization.\"\"\"\n        operand = self.operand.canonicalize()\n\n        # Double transpose optimization: (A.T).T = A\n        if isinstance(operand, Transpose):\n            return operand.operand\n\n        return Transpose(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Matrix transpose operation swaps the last two dimensions.\"\"\"\n        operand_shape = self.operand.check_shape()\n\n        if len(operand_shape) == 0:\n            # Scalar transpose is the scalar itself\n            return ()\n        elif len(operand_shape) == 1:\n            # Vector transpose is the vector itself (row vector remains row vector)\n            return operand_shape\n        elif len(operand_shape) == 2:\n            # Matrix transpose: (m,n) -&gt; (n,m)\n            return (operand_shape[1], operand_shape[0])\n        else:\n            # Higher-dimensional array: transpose last two dimensions\n            # (..., m, n) -&gt; (..., n, m)\n            return operand_shape[:-2] + (operand_shape[-1], operand_shape[-2])\n\n    def __repr__(self):\n        return f\"({self.operand!r}).T\"\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Transpose.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a transpose operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to transpose</p> required Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a transpose operation.\n\n    Args:\n        operand: Expression to transpose\n    \"\"\"\n    self.operand = to_expr(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Transpose.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the operand with double transpose optimization.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the operand with double transpose optimization.\"\"\"\n    operand = self.operand.canonicalize()\n\n    # Double transpose optimization: (A.T).T = A\n    if isinstance(operand, Transpose):\n        return operand.operand\n\n    return Transpose(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/linalg/#openscvx.symbolic.expr.linalg.Transpose.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Matrix transpose operation swaps the last two dimensions.</p> Source code in <code>openscvx/symbolic/expr/linalg.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Matrix transpose operation swaps the last two dimensions.\"\"\"\n    operand_shape = self.operand.check_shape()\n\n    if len(operand_shape) == 0:\n        # Scalar transpose is the scalar itself\n        return ()\n    elif len(operand_shape) == 1:\n        # Vector transpose is the vector itself (row vector remains row vector)\n        return operand_shape\n    elif len(operand_shape) == 2:\n        # Matrix transpose: (m,n) -&gt; (n,m)\n        return (operand_shape[1], operand_shape[0])\n    else:\n        # Higher-dimensional array: transpose last two dimensions\n        # (..., m, n) -&gt; (..., n, m)\n        return operand_shape[:-2] + (operand_shape[-1], operand_shape[-2])\n</code></pre>"},{"location":"reference/symbolic/expr/math/","title":"math","text":"<p>Mathematical functions for symbolic expressions.</p> <p>This module provides common mathematical operations used in optimization problems, including trigonometric functions, exponential functions, and smooth approximations of non-differentiable operations. All functions are element-wise and preserve the shape of their inputs.</p> Function Categories <ul> <li>Trigonometric: <code>Sin</code>, <code>Cos</code>, <code>Tan</code> - Standard trigonometric functions</li> <li>Exponential and Roots: <code>Exp</code>, <code>Log</code>, <code>Sqrt</code>, <code>Square</code> - Exponential, logarithm, square     root, and squaring operations</li> <li>Absolute Value: <code>Abs</code> - Element-wise absolute value function</li> <li>Smooth Approximations: <code>PositivePart</code>, <code>Huber</code>, <code>SmoothReLU</code> - Smooth, differentiable     approximations of non-smooth functions like max(0, x) and absolute value</li> <li>Reductions: <code>Max</code> - Maximum over elements</li> <li>Smooth Maximum: <code>LogSumExp</code> - Log-sum-exp function, a smooth approximation to maximum</li> </ul> Example <p>Using trigonometric functions in dynamics::</p> <pre><code>import openscvx as ox\n\n# Pendulum dynamics: theta_ddot = -g/L * sin(theta)\ntheta = ox.State(\"theta\", shape=(1,))\ntheta_dot = ox.State(\"theta_dot\", shape=(1,))\ng, L = 9.81, 1.0\n\ntheta_ddot = -(g / L) * ox.Sin(theta)\n</code></pre> <p>Smooth penalty functions for constraints::</p> <pre><code># Soft constraint using smooth ReLU\nx = ox.Variable(\"x\", shape=(3,))\npenalty = ox.SmoothReLU(ox.Norm(x) - 1.0)  # Penalize norm &gt; 1\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Abs","title":"<code>Abs</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise absolute value function for symbolic expressions.</p> <p>Computes the absolute value (|x|) of each element in the operand. Preserves the shape of the input expression. The absolute value function is convex and DCP-compliant in CVXPy.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply absolute value to</p> Example <p>Define an Abs expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\nabs_x = Abs(x)  # Element-wise |x|\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Abs(Expr):\n    \"\"\"Element-wise absolute value function for symbolic expressions.\n\n    Computes the absolute value (|x|) of each element in the operand. Preserves\n    the shape of the input expression. The absolute value function is convex\n    and DCP-compliant in CVXPy.\n\n    Attributes:\n        operand: Expression to apply absolute value to\n\n    Example:\n        Define an Abs expression:\n\n            x = Variable(\"x\", shape=(3,))\n            abs_x = Abs(x)  # Element-wise |x|\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize an absolute value operation.\n\n        Args:\n            operand: Expression to apply absolute value to\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Abs(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Abs preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"abs({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Abs.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize an absolute value operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to apply absolute value to</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize an absolute value operation.\n\n    Args:\n        operand: Expression to apply absolute value to\n    \"\"\"\n    self.operand = to_expr(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Abs.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Abs preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Abs preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Bilerp","title":"<code>Bilerp</code>","text":"<p>               Bases: <code>Expr</code></p> <p>2D bilinear interpolation for symbolic expressions.</p> <p>Performs bilinear interpolation on a regular 2D grid. Given grid points (xp, yp) and corresponding values fp, computes the bilinearly interpolated value at query point (x, y). For values outside the grid, boundary values are returned (clamping, no extrapolation).</p> <p>This is useful for incorporating 2D tabulated data (e.g., engine thrust as a function of altitude and Mach number, aerodynamic coefficients as a function of angle of attack and sideslip) into trajectory optimization.</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Query x-coordinate (symbolic expression)</p> <code>y</code> <p>Query y-coordinate (symbolic expression)</p> <code>xp</code> <p>1D array of x grid coordinates (must be increasing), length N</p> <code>yp</code> <p>1D array of y grid coordinates (must be increasing), length M</p> <code>fp</code> <p>2D array of values with shape (N, M), where fp[i, j] is the value at grid point (xp[i], yp[j])</p> Example <p>Interpolate engine thrust from altitude and Mach number::</p> <pre><code>import openscvx as ox\nimport numpy as np\n\n# Grid coordinates\nalt_grid = np.array([0, 5000, 10000, 15000, 20000])  # meters\nmach_grid = np.array([0.0, 0.5, 1.0, 1.5, 2.0])\n\n# Thrust values: thrust_table[i, j] = thrust at (alt_grid[i], mach_grid[j])\nthrust_table = np.array([...])  # shape (5, 5)\n\naltitude = ox.State(\"altitude\", shape=(1,))\nmach = ox.State(\"mach\", shape=(1,))\n\nthrust = ox.Bilerp(altitude[0], mach[0], alt_grid, mach_grid, thrust_table)\n</code></pre> Note <ul> <li>xp and yp must be strictly increasing</li> <li>fp must have shape (len(xp), len(yp))</li> <li>For query points outside the grid, boundary values are returned</li> <li>This node is only supported in JAX lowering (dynamics/cost), not CVXPy</li> </ul> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Bilerp(Expr):\n    \"\"\"2D bilinear interpolation for symbolic expressions.\n\n    Performs bilinear interpolation on a regular 2D grid. Given grid points\n    (xp, yp) and corresponding values fp, computes the bilinearly interpolated\n    value at query point (x, y). For values outside the grid, boundary values\n    are returned (clamping, no extrapolation).\n\n    This is useful for incorporating 2D tabulated data (e.g., engine thrust\n    as a function of altitude and Mach number, aerodynamic coefficients as\n    a function of angle of attack and sideslip) into trajectory optimization.\n\n    Attributes:\n        x: Query x-coordinate (symbolic expression)\n        y: Query y-coordinate (symbolic expression)\n        xp: 1D array of x grid coordinates (must be increasing), length N\n        yp: 1D array of y grid coordinates (must be increasing), length M\n        fp: 2D array of values with shape (N, M), where fp[i, j] is the\n            value at grid point (xp[i], yp[j])\n\n    Example:\n        Interpolate engine thrust from altitude and Mach number::\n\n            import openscvx as ox\n            import numpy as np\n\n            # Grid coordinates\n            alt_grid = np.array([0, 5000, 10000, 15000, 20000])  # meters\n            mach_grid = np.array([0.0, 0.5, 1.0, 1.5, 2.0])\n\n            # Thrust values: thrust_table[i, j] = thrust at (alt_grid[i], mach_grid[j])\n            thrust_table = np.array([...])  # shape (5, 5)\n\n            altitude = ox.State(\"altitude\", shape=(1,))\n            mach = ox.State(\"mach\", shape=(1,))\n\n            thrust = ox.Bilerp(altitude[0], mach[0], alt_grid, mach_grid, thrust_table)\n\n    Note:\n        - xp and yp must be strictly increasing\n        - fp must have shape (len(xp), len(yp))\n        - For query points outside the grid, boundary values are returned\n        - This node is only supported in JAX lowering (dynamics/cost), not CVXPy\n    \"\"\"\n\n    def __init__(self, x, y, xp, yp, fp):\n        \"\"\"Initialize a 2D bilinear interpolation node.\n\n        Args:\n            x: Query x-coordinate. Can be a scalar symbolic expression.\n            y: Query y-coordinate. Can be a scalar symbolic expression.\n            xp: 1D array of x grid coordinates. Must be increasing.\n            yp: 1D array of y grid coordinates. Must be increasing.\n            fp: 2D array of values with shape (len(xp), len(yp)).\n        \"\"\"\n        self.x = to_expr(x)\n        self.y = to_expr(y)\n        self.xp = to_expr(xp)\n        self.yp = to_expr(yp)\n        self.fp = to_expr(fp)\n\n    def children(self):\n        return [self.x, self.y, self.xp, self.yp, self.fp]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize by canonicalizing all operands.\"\"\"\n        x = self.x.canonicalize()\n        y = self.y.canonicalize()\n        xp = self.xp.canonicalize()\n        yp = self.yp.canonicalize()\n        fp = self.fp.canonicalize()\n        return Bilerp(x, y, xp, yp, fp)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Output shape is scalar (single interpolated value).\n\n        Returns:\n            tuple: Empty tuple (scalar output)\n\n        Raises:\n            ValueError: If grid arrays have invalid shapes\n        \"\"\"\n        xp_shape = self.xp.check_shape()\n        yp_shape = self.yp.check_shape()\n        fp_shape = self.fp.check_shape()\n        x_shape = self.x.check_shape()\n        y_shape = self.y.check_shape()\n\n        if len(xp_shape) != 1:\n            raise ValueError(f\"Bilerp xp must be 1D, got shape {xp_shape}\")\n        if len(yp_shape) != 1:\n            raise ValueError(f\"Bilerp yp must be 1D, got shape {yp_shape}\")\n        if len(fp_shape) != 2:\n            raise ValueError(f\"Bilerp fp must be 2D, got shape {fp_shape}\")\n        if fp_shape != (xp_shape[0], yp_shape[0]):\n            raise ValueError(\n                f\"Bilerp fp shape {fp_shape} must match (len(xp), len(yp)) = \"\n                f\"({xp_shape[0]}, {yp_shape[0]})\"\n            )\n        if x_shape != ():\n            raise ValueError(f\"Bilerp x must be scalar, got shape {x_shape}\")\n        if y_shape != ():\n            raise ValueError(f\"Bilerp y must be scalar, got shape {y_shape}\")\n\n        return ()\n\n    def __repr__(self):\n        return f\"bilerp({self.x!r}, {self.y!r}, {self.xp!r}, {self.yp!r}, {self.fp!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Bilerp.__init__","title":"<code>__init__(x, y, xp, yp, fp)</code>","text":"<p>Initialize a 2D bilinear interpolation node.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>Query x-coordinate. Can be a scalar symbolic expression.</p> required <code>y</code> <p>Query y-coordinate. Can be a scalar symbolic expression.</p> required <code>xp</code> <p>1D array of x grid coordinates. Must be increasing.</p> required <code>yp</code> <p>1D array of y grid coordinates. Must be increasing.</p> required <code>fp</code> <p>2D array of values with shape (len(xp), len(yp)).</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, x, y, xp, yp, fp):\n    \"\"\"Initialize a 2D bilinear interpolation node.\n\n    Args:\n        x: Query x-coordinate. Can be a scalar symbolic expression.\n        y: Query y-coordinate. Can be a scalar symbolic expression.\n        xp: 1D array of x grid coordinates. Must be increasing.\n        yp: 1D array of y grid coordinates. Must be increasing.\n        fp: 2D array of values with shape (len(xp), len(yp)).\n    \"\"\"\n    self.x = to_expr(x)\n    self.y = to_expr(y)\n    self.xp = to_expr(xp)\n    self.yp = to_expr(yp)\n    self.fp = to_expr(fp)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Bilerp.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize by canonicalizing all operands.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize by canonicalizing all operands.\"\"\"\n    x = self.x.canonicalize()\n    y = self.y.canonicalize()\n    xp = self.xp.canonicalize()\n    yp = self.yp.canonicalize()\n    fp = self.fp.canonicalize()\n    return Bilerp(x, y, xp, yp, fp)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Bilerp.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Output shape is scalar (single interpolated value).</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple (scalar output)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If grid arrays have invalid shapes</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Output shape is scalar (single interpolated value).\n\n    Returns:\n        tuple: Empty tuple (scalar output)\n\n    Raises:\n        ValueError: If grid arrays have invalid shapes\n    \"\"\"\n    xp_shape = self.xp.check_shape()\n    yp_shape = self.yp.check_shape()\n    fp_shape = self.fp.check_shape()\n    x_shape = self.x.check_shape()\n    y_shape = self.y.check_shape()\n\n    if len(xp_shape) != 1:\n        raise ValueError(f\"Bilerp xp must be 1D, got shape {xp_shape}\")\n    if len(yp_shape) != 1:\n        raise ValueError(f\"Bilerp yp must be 1D, got shape {yp_shape}\")\n    if len(fp_shape) != 2:\n        raise ValueError(f\"Bilerp fp must be 2D, got shape {fp_shape}\")\n    if fp_shape != (xp_shape[0], yp_shape[0]):\n        raise ValueError(\n            f\"Bilerp fp shape {fp_shape} must match (len(xp), len(yp)) = \"\n            f\"({xp_shape[0]}, {yp_shape[0]})\"\n        )\n    if x_shape != ():\n        raise ValueError(f\"Bilerp x must be scalar, got shape {x_shape}\")\n    if y_shape != ():\n        raise ValueError(f\"Bilerp y must be scalar, got shape {y_shape}\")\n\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Cos","title":"<code>Cos</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise cosine function for symbolic expressions.</p> <p>Computes the cosine of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply cosine function to</p> Example <p>Define a Cos expression:</p> <pre><code>theta = Variable(\"theta\", shape=(3,))\ncos_theta = Cos(theta)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Cos(Expr):\n    \"\"\"Element-wise cosine function for symbolic expressions.\n\n    Computes the cosine of each element in the operand. Preserves the shape\n    of the input expression.\n\n    Attributes:\n        operand: Expression to apply cosine function to\n\n    Example:\n        Define a Cos expression:\n\n            theta = Variable(\"theta\", shape=(3,))\n            cos_theta = Cos(theta)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a cosine operation.\n\n        Args:\n            operand: Expression to apply cosine function to\n        \"\"\"\n        self.operand = operand\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Cos(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Cos preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"(cos({self.operand!r}))\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Cos.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a cosine operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to apply cosine function to</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a cosine operation.\n\n    Args:\n        operand: Expression to apply cosine function to\n    \"\"\"\n    self.operand = operand\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Cos.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Cos preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Cos preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Exp","title":"<code>Exp</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise exponential function for symbolic expressions.</p> <p>Computes e^x for each element in the operand, where e is Euler's number. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply exponential function to</p> Example <p>Define an Exp expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\nexp_x = Exp(x)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Exp(Expr):\n    \"\"\"Element-wise exponential function for symbolic expressions.\n\n    Computes e^x for each element in the operand, where e is Euler's number.\n    Preserves the shape of the input expression.\n\n    Attributes:\n        operand: Expression to apply exponential function to\n\n    Example:\n        Define an Exp expression:\n\n            x = Variable(\"x\", shape=(3,))\n            exp_x = Exp(x)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize an exponential operation.\n\n        Args:\n            operand: Expression to apply exponential function to\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Exp(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Exp preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"exp({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Exp.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize an exponential operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to apply exponential function to</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize an exponential operation.\n\n    Args:\n        operand: Expression to apply exponential function to\n    \"\"\"\n    self.operand = to_expr(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Exp.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Exp preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Exp preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Huber","title":"<code>Huber</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Huber penalty function for symbolic expressions.</p> <p>The Huber penalty is a smooth approximation to the absolute value function that is quadratic for small values (|x| &lt; delta) and linear for large values (|x| &gt;= delta). This makes it more robust to outliers than squared penalties while maintaining smoothness.</p> <p>The Huber function is defined as: - (x^2) / (2*delta)           for |x| &lt;= delta - |x| - delta/2               for |x| &gt; delta</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Expression to apply Huber penalty to</p> <code>delta</code> <p>Threshold parameter controlling the transition point (default: 0.25)</p> Example <p>Define a Huber penalty expression:</p> <pre><code>residual = y_measured - y_predicted\npenalty = Huber(residual, delta=0.5)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Huber(Expr):\n    \"\"\"Huber penalty function for symbolic expressions.\n\n    The Huber penalty is a smooth approximation to the absolute value function\n    that is quadratic for small values (|x| &lt; delta) and linear for large values\n    (|x| &gt;= delta). This makes it more robust to outliers than squared penalties\n    while maintaining smoothness.\n\n    The Huber function is defined as:\n    - (x^2) / (2*delta)           for |x| &lt;= delta\n    - |x| - delta/2               for |x| &gt; delta\n\n    Attributes:\n        x: Expression to apply Huber penalty to\n        delta: Threshold parameter controlling the transition point (default: 0.25)\n\n    Example:\n        Define a Huber penalty expression:\n\n            residual = y_measured - y_predicted\n            penalty = Huber(residual, delta=0.5)\n    \"\"\"\n\n    def __init__(self, x, delta: float = 0.25):\n        \"\"\"Initialize a Huber penalty operation.\n\n        Args:\n            x: Expression to apply Huber penalty to\n            delta: Threshold parameter for quadratic-to-linear transition (default: 0.25)\n        \"\"\"\n        self.x = to_expr(x)\n        self.delta = float(delta)\n\n    def children(self):\n        return [self.x]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the operand but preserve delta parameter.\"\"\"\n        x = self.x.canonicalize()\n        return Huber(x, delta=self.delta)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Huber penalty preserves the shape of x.\"\"\"\n        return self.x.check_shape()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Huber including its delta parameter.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Huber\")\n        # Hash delta as bytes\n        hasher.update(struct.pack(\"&gt;d\", self.delta))\n        # Hash the operand\n        self.x._hash_into(hasher)\n\n    def __repr__(self):\n        return f\"huber({self.x!r}, delta={self.delta})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Huber.__init__","title":"<code>__init__(x, delta: float = 0.25)</code>","text":"<p>Initialize a Huber penalty operation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>Expression to apply Huber penalty to</p> required <code>delta</code> <code>float</code> <p>Threshold parameter for quadratic-to-linear transition (default: 0.25)</p> <code>0.25</code> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, x, delta: float = 0.25):\n    \"\"\"Initialize a Huber penalty operation.\n\n    Args:\n        x: Expression to apply Huber penalty to\n        delta: Threshold parameter for quadratic-to-linear transition (default: 0.25)\n    \"\"\"\n    self.x = to_expr(x)\n    self.delta = float(delta)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Huber.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the operand but preserve delta parameter.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the operand but preserve delta parameter.\"\"\"\n    x = self.x.canonicalize()\n    return Huber(x, delta=self.delta)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Huber.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Huber penalty preserves the shape of x.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Huber penalty preserves the shape of x.\"\"\"\n    return self.x.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Linterp","title":"<code>Linterp</code>","text":"<p>               Bases: <code>Expr</code></p> <p>1D linear interpolation for symbolic expressions.</p> <p>Computes the linear interpolant of data points (xp, fp) evaluated at x, equivalent to jax.numpy.interp(x, xp, fp). For values outside the data range, the boundary values are returned (no extrapolation).</p> <p>This is useful for incorporating tabulated data (e.g., atmospheric properties, engine thrust curves, aerodynamic coefficients) into trajectory optimization dynamics and constraints.</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Query point(s) at which to evaluate the interpolant (symbolic expression)</p> <code>xp</code> <p>1D array of x-coordinates of data points (must be increasing)</p> <code>fp</code> <p>1D array of y-coordinates of data points (same length as xp)</p> Example <p>Interpolate atmospheric density from altitude table::</p> <pre><code>import openscvx as ox\nimport numpy as np\n\n# US 1976 Standard Atmosphere data\nalt_data = np.array([0, 5000, 10000, 15000, 20000])  # meters\nrho_data = np.array([1.225, 0.736, 0.414, 0.195, 0.089])  # kg/m^3\n\naltitude = ox.State(\"altitude\", shape=(1,))\nrho = ox.Linterp(altitude[0], alt_data, rho_data)\n\n# rho can now be used in dynamics expressions\ndrag = 0.5 * rho * v**2 * Cd * S\n</code></pre> Note <ul> <li>xp must be strictly increasing</li> <li>For query points outside [xp[0], xp[-1]], boundary values are returned</li> </ul> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Linterp(Expr):\n    \"\"\"1D linear interpolation for symbolic expressions.\n\n    Computes the linear interpolant of data points (xp, fp) evaluated at x,\n    equivalent to jax.numpy.interp(x, xp, fp). For values outside the data range,\n    the boundary values are returned (no extrapolation).\n\n    This is useful for incorporating tabulated data (e.g., atmospheric properties,\n    engine thrust curves, aerodynamic coefficients) into trajectory optimization\n    dynamics and constraints.\n\n    Attributes:\n        x: Query point(s) at which to evaluate the interpolant (symbolic expression)\n        xp: 1D array of x-coordinates of data points (must be increasing)\n        fp: 1D array of y-coordinates of data points (same length as xp)\n\n    Example:\n        Interpolate atmospheric density from altitude table::\n\n            import openscvx as ox\n            import numpy as np\n\n            # US 1976 Standard Atmosphere data\n            alt_data = np.array([0, 5000, 10000, 15000, 20000])  # meters\n            rho_data = np.array([1.225, 0.736, 0.414, 0.195, 0.089])  # kg/m^3\n\n            altitude = ox.State(\"altitude\", shape=(1,))\n            rho = ox.Linterp(altitude[0], alt_data, rho_data)\n\n            # rho can now be used in dynamics expressions\n            drag = 0.5 * rho * v**2 * Cd * S\n\n    Note:\n        - xp must be strictly increasing\n        - For query points outside [xp[0], xp[-1]], boundary values are returned\n    \"\"\"\n\n    def __init__(self, x, xp, fp):\n        \"\"\"Initialize a 1D linear interpolation node.\n\n        Args:\n            x: Query point(s) at which to evaluate the interpolant.\n                Can be a scalar or array symbolic expression.\n            xp: 1D array of x-coordinates of data points. Must be increasing.\n                Can be a numpy array or Constant expression.\n            fp: 1D array of y-coordinates of data points. Must have same length as xp.\n                Can be a numpy array or Constant expression.\n        \"\"\"\n        self.x = to_expr(x)\n        self.xp = to_expr(xp)\n        self.fp = to_expr(fp)\n\n    def children(self):\n        return [self.x, self.xp, self.fp]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize by canonicalizing all operands.\"\"\"\n        x = self.x.canonicalize()\n        xp = self.xp.canonicalize()\n        fp = self.fp.canonicalize()\n        return Linterp(x, xp, fp)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Output shape matches the query point shape.\n\n        The interpolation is element-wise over x, so the output has\n        the same shape as the query points.\n\n        Returns:\n            tuple: Shape of the query point x\n\n        Raises:\n            ValueError: If xp and fp have different lengths or are not 1D\n        \"\"\"\n        xp_shape = self.xp.check_shape()\n        fp_shape = self.fp.check_shape()\n\n        if len(xp_shape) != 1:\n            raise ValueError(f\"Linterp xp must be 1D, got shape {xp_shape}\")\n        if len(fp_shape) != 1:\n            raise ValueError(f\"Linterp fp must be 1D, got shape {fp_shape}\")\n        if xp_shape != fp_shape:\n            raise ValueError(\n                f\"Linterp xp and fp must have same length, got {xp_shape} vs {fp_shape}\"\n            )\n\n        return self.x.check_shape()\n\n    def __repr__(self):\n        return f\"linterp({self.x!r}, {self.xp!r}, {self.fp!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Linterp.__init__","title":"<code>__init__(x, xp, fp)</code>","text":"<p>Initialize a 1D linear interpolation node.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>Query point(s) at which to evaluate the interpolant. Can be a scalar or array symbolic expression.</p> required <code>xp</code> <p>1D array of x-coordinates of data points. Must be increasing. Can be a numpy array or Constant expression.</p> required <code>fp</code> <p>1D array of y-coordinates of data points. Must have same length as xp. Can be a numpy array or Constant expression.</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, x, xp, fp):\n    \"\"\"Initialize a 1D linear interpolation node.\n\n    Args:\n        x: Query point(s) at which to evaluate the interpolant.\n            Can be a scalar or array symbolic expression.\n        xp: 1D array of x-coordinates of data points. Must be increasing.\n            Can be a numpy array or Constant expression.\n        fp: 1D array of y-coordinates of data points. Must have same length as xp.\n            Can be a numpy array or Constant expression.\n    \"\"\"\n    self.x = to_expr(x)\n    self.xp = to_expr(xp)\n    self.fp = to_expr(fp)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Linterp.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize by canonicalizing all operands.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize by canonicalizing all operands.\"\"\"\n    x = self.x.canonicalize()\n    xp = self.xp.canonicalize()\n    fp = self.fp.canonicalize()\n    return Linterp(x, xp, fp)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Linterp.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Output shape matches the query point shape.</p> <p>The interpolation is element-wise over x, so the output has the same shape as the query points.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape of the query point x</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If xp and fp have different lengths or are not 1D</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Output shape matches the query point shape.\n\n    The interpolation is element-wise over x, so the output has\n    the same shape as the query points.\n\n    Returns:\n        tuple: Shape of the query point x\n\n    Raises:\n        ValueError: If xp and fp have different lengths or are not 1D\n    \"\"\"\n    xp_shape = self.xp.check_shape()\n    fp_shape = self.fp.check_shape()\n\n    if len(xp_shape) != 1:\n        raise ValueError(f\"Linterp xp must be 1D, got shape {xp_shape}\")\n    if len(fp_shape) != 1:\n        raise ValueError(f\"Linterp fp must be 1D, got shape {fp_shape}\")\n    if xp_shape != fp_shape:\n        raise ValueError(\n            f\"Linterp xp and fp must have same length, got {xp_shape} vs {fp_shape}\"\n        )\n\n    return self.x.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Log","title":"<code>Log</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise natural logarithm function for symbolic expressions.</p> <p>Computes the natural logarithm (base e) of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply logarithm to</p> Example <p>Define a Log expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\nlog_x = Log(x)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Log(Expr):\n    \"\"\"Element-wise natural logarithm function for symbolic expressions.\n\n    Computes the natural logarithm (base e) of each element in the operand.\n    Preserves the shape of the input expression.\n\n    Attributes:\n        operand: Expression to apply logarithm to\n\n    Example:\n        Define a Log expression:\n\n            x = Variable(\"x\", shape=(3,))\n            log_x = Log(x)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a natural logarithm operation.\n\n        Args:\n            operand: Expression to apply logarithm to\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Log(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Log preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"log({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Log.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a natural logarithm operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to apply logarithm to</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a natural logarithm operation.\n\n    Args:\n        operand: Expression to apply logarithm to\n    \"\"\"\n    self.operand = to_expr(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Log.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Log preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Log preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.LogSumExp","title":"<code>LogSumExp</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Log-sum-exp function for symbolic expressions.</p> <p>Computes the log-sum-exp (LSE) of multiple operands, which is a smooth, differentiable approximation to the maximum function. The log-sum-exp is defined as:</p> <pre><code>logsumexp(x\u2081, x\u2082, ..., x\u2099) = log(exp(x\u2081) + exp(x\u2082) + ... + exp(x\u2099))\n</code></pre> <p>This function is numerically stable and is commonly used in optimization as a smooth alternative to the non-differentiable maximum function. It satisfies the inequality:</p> <pre><code>max(x\u2081, x\u2082, ..., x\u2099) \u2264 logsumexp(x\u2081, x\u2082, ..., x\u2099) \u2264 max(x\u2081, x\u2082, ..., x\u2099) + log(n)\n</code></pre> <p>The log-sum-exp is convex and is particularly useful for: - Smooth approximations of maximum constraints - Soft maximum operations in neural networks - Relaxing logical OR operations in STL specifications</p> <p>Attributes:</p> Name Type Description <code>operands</code> <p>List of expressions to compute log-sum-exp over</p> Example <p>Define a LogSumExp expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(3,))\nz = Variable(\"z\", shape=(3,))\nlse = LogSumExp(x, y, z)  # Smooth approximation to max(x, y, z)\n</code></pre> <p>Use in STL relaxation:</p> <pre><code>import openscvx as ox\n# Relax: Or(\u03c6\u2081, \u03c6\u2082) using log-sum-exp\nphi1 = ox.Norm(x - goal1) - 0.5\nphi2 = ox.Norm(x - goal2) - 0.5\nrelaxed_or = LogSumExp(phi1, phi2) &gt;= 0\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class LogSumExp(Expr):\n    \"\"\"Log-sum-exp function for symbolic expressions.\n\n    Computes the log-sum-exp (LSE) of multiple operands, which is a smooth,\n    differentiable approximation to the maximum function. The log-sum-exp is\n    defined as:\n\n        logsumexp(x\u2081, x\u2082, ..., x\u2099) = log(exp(x\u2081) + exp(x\u2082) + ... + exp(x\u2099))\n\n    This function is numerically stable and is commonly used in optimization\n    as a smooth alternative to the non-differentiable maximum function. It\n    satisfies the inequality:\n\n        max(x\u2081, x\u2082, ..., x\u2099) \u2264 logsumexp(x\u2081, x\u2082, ..., x\u2099) \u2264 max(x\u2081, x\u2082, ..., x\u2099) + log(n)\n\n    The log-sum-exp is convex and is particularly useful for:\n    - Smooth approximations of maximum constraints\n    - Soft maximum operations in neural networks\n    - Relaxing logical OR operations in STL specifications\n\n    Attributes:\n        operands: List of expressions to compute log-sum-exp over\n\n    Example:\n        Define a LogSumExp expression:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(3,))\n            z = Variable(\"z\", shape=(3,))\n            lse = LogSumExp(x, y, z)  # Smooth approximation to max(x, y, z)\n\n        Use in STL relaxation:\n\n            import openscvx as ox\n            # Relax: Or(\u03c6\u2081, \u03c6\u2082) using log-sum-exp\n            phi1 = ox.Norm(x - goal1) - 0.5\n            phi2 = ox.Norm(x - goal2) - 0.5\n            relaxed_or = LogSumExp(phi1, phi2) &gt;= 0\n    \"\"\"\n\n    def __init__(self, *args):\n        \"\"\"Initialize a log-sum-exp operation.\n\n        Args:\n            *args: Two or more expressions to compute log-sum-exp over\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(args) &lt; 2:\n            raise ValueError(\"LogSumExp requires two or more operands\")\n        self.operands = [to_expr(a) for a in args]\n\n    def children(self):\n        return list(self.operands)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize log-sum-exp: flatten nested LogSumExp, fold constants.\"\"\"\n        from .expr import Constant\n\n        operands = []\n        const_vals = []\n\n        for op in self.operands:\n            c = op.canonicalize()\n            if isinstance(c, LogSumExp):\n                operands.extend(c.operands)\n            elif isinstance(c, Constant):\n                const_vals.append(c.value)\n            else:\n                operands.append(c)\n\n        # If we have constants, compute their log-sum-exp and keep it\n        if const_vals:\n            # For constants, we can compute logsumexp directly\n            # logsumexp(c1, c2, ..., cn) = log(sum(exp(ci)))\n            exp_vals = [np.exp(v) for v in const_vals]\n            lse_const = np.log(np.sum(exp_vals))\n            operands.append(Constant(lse_const))\n\n        if not operands:\n            raise ValueError(\"LogSumExp must have at least one operand after canonicalization\")\n        if len(operands) == 1:\n            return operands[0]\n        return LogSumExp(*operands)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"LogSumExp broadcasts shapes like NumPy, preserving element-wise shape.\"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"LogSumExp shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        inner = \", \".join(repr(op) for op in self.operands)\n        return f\"logsumexp({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.LogSumExp.__init__","title":"<code>__init__(*args)</code>","text":"<p>Initialize a log-sum-exp operation.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Two or more expressions to compute log-sum-exp over</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two operands are provided</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, *args):\n    \"\"\"Initialize a log-sum-exp operation.\n\n    Args:\n        *args: Two or more expressions to compute log-sum-exp over\n\n    Raises:\n        ValueError: If fewer than two operands are provided\n    \"\"\"\n    if len(args) &lt; 2:\n        raise ValueError(\"LogSumExp requires two or more operands\")\n    self.operands = [to_expr(a) for a in args]\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.LogSumExp.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize log-sum-exp: flatten nested LogSumExp, fold constants.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize log-sum-exp: flatten nested LogSumExp, fold constants.\"\"\"\n    from .expr import Constant\n\n    operands = []\n    const_vals = []\n\n    for op in self.operands:\n        c = op.canonicalize()\n        if isinstance(c, LogSumExp):\n            operands.extend(c.operands)\n        elif isinstance(c, Constant):\n            const_vals.append(c.value)\n        else:\n            operands.append(c)\n\n    # If we have constants, compute their log-sum-exp and keep it\n    if const_vals:\n        # For constants, we can compute logsumexp directly\n        # logsumexp(c1, c2, ..., cn) = log(sum(exp(ci)))\n        exp_vals = [np.exp(v) for v in const_vals]\n        lse_const = np.log(np.sum(exp_vals))\n        operands.append(Constant(lse_const))\n\n    if not operands:\n        raise ValueError(\"LogSumExp must have at least one operand after canonicalization\")\n    if len(operands) == 1:\n        return operands[0]\n    return LogSumExp(*operands)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.LogSumExp.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>LogSumExp broadcasts shapes like NumPy, preserving element-wise shape.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"LogSumExp broadcasts shapes like NumPy, preserving element-wise shape.\"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"LogSumExp shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Max","title":"<code>Max</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise maximum function for symbolic expressions.</p> <p>Computes the element-wise maximum across two or more operands. Supports broadcasting following NumPy rules. During canonicalization, nested Max operations are flattened and constants are folded.</p> <p>Attributes:</p> Name Type Description <code>operands</code> <p>List of expressions to compute maximum over</p> Example <p>Define a Max expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\ny = Variable(\"y\", shape=(3,))\nmax_xy = Max(x, y, 0)  # Element-wise max(x, y, 0)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Max(Expr):\n    \"\"\"Element-wise maximum function for symbolic expressions.\n\n    Computes the element-wise maximum across two or more operands. Supports\n    broadcasting following NumPy rules. During canonicalization, nested Max\n    operations are flattened and constants are folded.\n\n    Attributes:\n        operands: List of expressions to compute maximum over\n\n    Example:\n        Define a Max expression:\n\n            x = Variable(\"x\", shape=(3,))\n            y = Variable(\"y\", shape=(3,))\n            max_xy = Max(x, y, 0)  # Element-wise max(x, y, 0)\n    \"\"\"\n\n    def __init__(self, *args):\n        \"\"\"Initialize a maximum operation.\n\n        Args:\n            *args: Two or more expressions to compute maximum over\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(args) &lt; 2:\n            raise ValueError(\"Max requires two or more operands\")\n        self.operands = [to_expr(a) for a in args]\n\n    def children(self):\n        return list(self.operands)\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize max: flatten nested Max, fold constants.\"\"\"\n        from .expr import Constant\n\n        operands = []\n        const_vals = []\n\n        for op in self.operands:\n            c = op.canonicalize()\n            if isinstance(c, Max):\n                operands.extend(c.operands)\n            elif isinstance(c, Constant):\n                const_vals.append(c.value)\n            else:\n                operands.append(c)\n\n        # If we have constants, compute their max and keep it\n        if const_vals:\n            max_const = np.maximum.reduce(const_vals)\n            operands.append(Constant(max_const))\n\n        if not operands:\n            raise ValueError(\"Max must have at least one operand after canonicalization\")\n        if len(operands) == 1:\n            return operands[0]\n        return Max(*operands)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Max broadcasts shapes like NumPy.\"\"\"\n        shapes = [child.check_shape() for child in self.children()]\n        try:\n            return np.broadcast_shapes(*shapes)\n        except ValueError as e:\n            raise ValueError(f\"Max shapes not broadcastable: {shapes}\") from e\n\n    def __repr__(self):\n        inner = \", \".join(repr(op) for op in self.operands)\n        return f\"max({inner})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Max.__init__","title":"<code>__init__(*args)</code>","text":"<p>Initialize a maximum operation.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Two or more expressions to compute maximum over</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two operands are provided</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, *args):\n    \"\"\"Initialize a maximum operation.\n\n    Args:\n        *args: Two or more expressions to compute maximum over\n\n    Raises:\n        ValueError: If fewer than two operands are provided\n    \"\"\"\n    if len(args) &lt; 2:\n        raise ValueError(\"Max requires two or more operands\")\n    self.operands = [to_expr(a) for a in args]\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Max.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize max: flatten nested Max, fold constants.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize max: flatten nested Max, fold constants.\"\"\"\n    from .expr import Constant\n\n    operands = []\n    const_vals = []\n\n    for op in self.operands:\n        c = op.canonicalize()\n        if isinstance(c, Max):\n            operands.extend(c.operands)\n        elif isinstance(c, Constant):\n            const_vals.append(c.value)\n        else:\n            operands.append(c)\n\n    # If we have constants, compute their max and keep it\n    if const_vals:\n        max_const = np.maximum.reduce(const_vals)\n        operands.append(Constant(max_const))\n\n    if not operands:\n        raise ValueError(\"Max must have at least one operand after canonicalization\")\n    if len(operands) == 1:\n        return operands[0]\n    return Max(*operands)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Max.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Max broadcasts shapes like NumPy.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Max broadcasts shapes like NumPy.\"\"\"\n    shapes = [child.check_shape() for child in self.children()]\n    try:\n        return np.broadcast_shapes(*shapes)\n    except ValueError as e:\n        raise ValueError(f\"Max shapes not broadcastable: {shapes}\") from e\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.PositivePart","title":"<code>PositivePart</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Positive part function for symbolic expressions.</p> <p>Computes max(x, 0) element-wise, effectively zeroing out negative values while preserving positive values. This is also known as the ReLU (Rectified Linear Unit) function and is commonly used as a penalty function building block in optimization.</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Expression to apply positive part function to</p> Example <p>Define a PositivePart expression:</p> <pre><code>constraint_violation = x - 10\npenalty = PositivePart(constraint_violation)  # Penalizes x &gt; 10\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class PositivePart(Expr):\n    \"\"\"Positive part function for symbolic expressions.\n\n    Computes max(x, 0) element-wise, effectively zeroing out negative values\n    while preserving positive values. This is also known as the ReLU (Rectified\n    Linear Unit) function and is commonly used as a penalty function building\n    block in optimization.\n\n    Attributes:\n        x: Expression to apply positive part function to\n\n    Example:\n        Define a PositivePart expression:\n\n            constraint_violation = x - 10\n            penalty = PositivePart(constraint_violation)  # Penalizes x &gt; 10\n    \"\"\"\n\n    def __init__(self, x):\n        \"\"\"Initialize a positive part operation.\n\n        Args:\n            x: Expression to apply positive part function to\n        \"\"\"\n        self.x = to_expr(x)\n\n    def children(self):\n        return [self.x]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        x = self.x.canonicalize()\n        return PositivePart(x)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"pos(x) = max(x, 0) preserves the shape of x.\"\"\"\n        return self.x.check_shape()\n\n    def __repr__(self):\n        return f\"pos({self.x!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.PositivePart.__init__","title":"<code>__init__(x)</code>","text":"<p>Initialize a positive part operation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>Expression to apply positive part function to</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, x):\n    \"\"\"Initialize a positive part operation.\n\n    Args:\n        x: Expression to apply positive part function to\n    \"\"\"\n    self.x = to_expr(x)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.PositivePart.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>pos(x) = max(x, 0) preserves the shape of x.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"pos(x) = max(x, 0) preserves the shape of x.\"\"\"\n    return self.x.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Sin","title":"<code>Sin</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise sine function for symbolic expressions.</p> <p>Computes the sine of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply sine function to</p> Example <p>Define a Sin expression:</p> <pre><code>theta = Variable(\"theta\", shape=(3,))\nsin_theta = Sin(theta)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Sin(Expr):\n    \"\"\"Element-wise sine function for symbolic expressions.\n\n    Computes the sine of each element in the operand. Preserves the shape\n    of the input expression.\n\n    Attributes:\n        operand: Expression to apply sine function to\n\n    Example:\n        Define a Sin expression:\n\n            theta = Variable(\"theta\", shape=(3,))\n            sin_theta = Sin(theta)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a sine operation.\n\n        Args:\n            operand: Expression to apply sine function to\n        \"\"\"\n        self.operand = operand\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Sin(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Sin preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"(sin({self.operand!r}))\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Sin.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a sine operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to apply sine function to</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a sine operation.\n\n    Args:\n        operand: Expression to apply sine function to\n    \"\"\"\n    self.operand = operand\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Sin.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Sin preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Sin preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.SmoothReLU","title":"<code>SmoothReLU</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Smooth approximation to the ReLU (positive part) function.</p> <p>Computes a smooth, differentiable approximation to max(x, 0) using the formula: sqrt(max(x, 0)^2 + c^2) - c</p> <p>The parameter c controls the smoothness: smaller values give a sharper transition, while larger values produce a smoother approximation. As c approaches 0, this converges to the standard ReLU function.</p> <p>This is particularly useful in optimization contexts where smooth gradients are required, such as in penalty methods for constraint handling (CTCS).</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Expression to apply smooth ReLU to</p> <code>c</code> <p>Smoothing parameter (default: 1e-8)</p> Example <p>Define a smooth ReLU expression:</p> <pre><code>constraint_violation = x - 10\npenalty = SmoothReLU(constraint_violation, c=1e-6)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class SmoothReLU(Expr):\n    \"\"\"Smooth approximation to the ReLU (positive part) function.\n\n    Computes a smooth, differentiable approximation to max(x, 0) using the formula:\n    sqrt(max(x, 0)^2 + c^2) - c\n\n    The parameter c controls the smoothness: smaller values give a sharper\n    transition, while larger values produce a smoother approximation. As c\n    approaches 0, this converges to the standard ReLU function.\n\n    This is particularly useful in optimization contexts where smooth gradients\n    are required, such as in penalty methods for constraint handling (CTCS).\n\n    Attributes:\n        x: Expression to apply smooth ReLU to\n        c: Smoothing parameter (default: 1e-8)\n\n    Example:\n        Define a smooth ReLU expression:\n\n            constraint_violation = x - 10\n            penalty = SmoothReLU(constraint_violation, c=1e-6)\n    \"\"\"\n\n    def __init__(self, x, c: float = 1e-8):\n        \"\"\"Initialize a smooth ReLU operation.\n\n        Args:\n            x: Expression to apply smooth ReLU to\n            c: Smoothing parameter controlling transition sharpness (default: 1e-8)\n        \"\"\"\n        self.x = to_expr(x)\n        self.c = float(c)\n\n    def children(self):\n        return [self.x]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize the operand but preserve c parameter.\"\"\"\n        x = self.x.canonicalize()\n        return SmoothReLU(x, c=self.c)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Smooth ReLU preserves the shape of x.\"\"\"\n        return self.x.check_shape()\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash SmoothReLU including its c parameter.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"SmoothReLU\")\n        # Hash c as bytes\n        hasher.update(struct.pack(\"&gt;d\", self.c))\n        # Hash the operand\n        self.x._hash_into(hasher)\n\n    def __repr__(self):\n        return f\"smooth_relu({self.x!r}, c={self.c})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.SmoothReLU.__init__","title":"<code>__init__(x, c: float = 1e-08)</code>","text":"<p>Initialize a smooth ReLU operation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>Expression to apply smooth ReLU to</p> required <code>c</code> <code>float</code> <p>Smoothing parameter controlling transition sharpness (default: 1e-8)</p> <code>1e-08</code> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, x, c: float = 1e-8):\n    \"\"\"Initialize a smooth ReLU operation.\n\n    Args:\n        x: Expression to apply smooth ReLU to\n        c: Smoothing parameter controlling transition sharpness (default: 1e-8)\n    \"\"\"\n    self.x = to_expr(x)\n    self.c = float(c)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.SmoothReLU.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the operand but preserve c parameter.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize the operand but preserve c parameter.\"\"\"\n    x = self.x.canonicalize()\n    return SmoothReLU(x, c=self.c)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.SmoothReLU.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Smooth ReLU preserves the shape of x.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Smooth ReLU preserves the shape of x.\"\"\"\n    return self.x.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Sqrt","title":"<code>Sqrt</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise square root function for symbolic expressions.</p> <p>Computes the square root of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply square root to</p> Example <p>Define a Sqrt expression:</p> <pre><code>x = Variable(\"x\", shape=(3,))\nsqrt_x = Sqrt(x)\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Sqrt(Expr):\n    \"\"\"Element-wise square root function for symbolic expressions.\n\n    Computes the square root of each element in the operand. Preserves the\n    shape of the input expression.\n\n    Attributes:\n        operand: Expression to apply square root to\n\n    Example:\n        Define a Sqrt expression:\n\n            x = Variable(\"x\", shape=(3,))\n            sqrt_x = Sqrt(x)\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a square root operation.\n\n        Args:\n            operand: Expression to apply square root to\n        \"\"\"\n        self.operand = to_expr(operand)\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Sqrt(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Sqrt preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"sqrt({self.operand!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Sqrt.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a square root operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to apply square root to</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a square root operation.\n\n    Args:\n        operand: Expression to apply square root to\n    \"\"\"\n    self.operand = to_expr(operand)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Sqrt.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Sqrt preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Sqrt preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Square","title":"<code>Square</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise square function for symbolic expressions.</p> <p>Computes the square (x^2) of each element in the operand. Preserves the shape of the input expression. This is more efficient than using Power(x, 2) for some optimization backends.</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>Expression to square</p> Example <p>Define a Square expression:</p> <pre><code>v = Variable(\"v\", shape=(3,))\nv_squared = Square(v)  # Equivalent to v ** 2\n</code></pre> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Square(Expr):\n    \"\"\"Element-wise square function for symbolic expressions.\n\n    Computes the square (x^2) of each element in the operand. Preserves the\n    shape of the input expression. This is more efficient than using Power(x, 2)\n    for some optimization backends.\n\n    Attributes:\n        x: Expression to square\n\n    Example:\n        Define a Square expression:\n\n            v = Variable(\"v\", shape=(3,))\n            v_squared = Square(v)  # Equivalent to v ** 2\n    \"\"\"\n\n    def __init__(self, x):\n        \"\"\"Initialize a square operation.\n\n        Args:\n            x: Expression to square\n        \"\"\"\n        self.x = to_expr(x)\n\n    def children(self):\n        return [self.x]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        x = self.x.canonicalize()\n        return Square(x)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"x^2 preserves the shape of x.\"\"\"\n        return self.x.check_shape()\n\n    def __repr__(self):\n        return f\"({self.x!r})^2\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Square.__init__","title":"<code>__init__(x)</code>","text":"<p>Initialize a square operation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>Expression to square</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, x):\n    \"\"\"Initialize a square operation.\n\n    Args:\n        x: Expression to square\n    \"\"\"\n    self.x = to_expr(x)\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Square.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>x^2 preserves the shape of x.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"x^2 preserves the shape of x.\"\"\"\n    return self.x.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Tan","title":"<code>Tan</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Element-wise tangent function for symbolic expressions.</p> <p>Computes the tangent of each element in the operand. Preserves the shape of the input expression.</p> <p>Attributes:</p> Name Type Description <code>operand</code> <p>Expression to apply tangent function to</p> Example <p>Define a Tan expression:</p> <pre><code>theta = Variable(\"theta\", shape=(3,))\ntan_theta = Tan(theta)\n</code></pre> Note <p>Tan is only supported for JAX lowering. CVXPy lowering will raise NotImplementedError since tangent is not DCP-compliant.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>class Tan(Expr):\n    \"\"\"Element-wise tangent function for symbolic expressions.\n\n    Computes the tangent of each element in the operand. Preserves the shape\n    of the input expression.\n\n    Attributes:\n        operand: Expression to apply tangent function to\n\n    Example:\n        Define a Tan expression:\n\n            theta = Variable(\"theta\", shape=(3,))\n            tan_theta = Tan(theta)\n\n    Note:\n        Tan is only supported for JAX lowering. CVXPy lowering will raise\n        NotImplementedError since tangent is not DCP-compliant.\n    \"\"\"\n\n    def __init__(self, operand):\n        \"\"\"Initialize a tangent operation.\n\n        Args:\n            operand: Expression to apply tangent function to\n        \"\"\"\n        self.operand = operand\n\n    def children(self):\n        return [self.operand]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        operand = self.operand.canonicalize()\n        return Tan(operand)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Tan preserves the shape of its operand.\"\"\"\n        return self.operand.check_shape()\n\n    def __repr__(self):\n        return f\"(tan({self.operand!r}))\"\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Tan.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a tangent operation.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <p>Expression to apply tangent function to</p> required Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def __init__(self, operand):\n    \"\"\"Initialize a tangent operation.\n\n    Args:\n        operand: Expression to apply tangent function to\n    \"\"\"\n    self.operand = operand\n</code></pre>"},{"location":"reference/symbolic/expr/math/#openscvx.symbolic.expr.math.Tan.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Tan preserves the shape of its operand.</p> Source code in <code>openscvx/symbolic/expr/math.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Tan preserves the shape of its operand.\"\"\"\n    return self.operand.check_shape()\n</code></pre>"},{"location":"reference/symbolic/expr/spatial/","title":"spatial","text":"<p>Spatial and 6-DOF utility operations for trajectory optimization.</p> <p>This module provides efficient symbolic expression nodes for common 6-DOF (six degree of freedom) operations used in aerospace and robotics applications. These operations directly map to optimized JAX implementations for high-performance evaluation.</p>"},{"location":"reference/symbolic/expr/spatial/#openscvx.symbolic.expr.spatial.QDCM","title":"<code>QDCM</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Quaternion to Direction Cosine Matrix (DCM) conversion.</p> <p>Converts a unit quaternion representation to a 3x3 direction cosine matrix (also known as a rotation matrix). This operation is commonly used in 6-DOF spacecraft dynamics, aircraft simulation, and robotics applications.</p> <p>The quaternion is expected in scalar-last format: [qx, qy, qz, qw] where qw is the scalar component. The resulting DCM can be used to transform vectors from one reference frame to another.</p> <p>Attributes:</p> Name Type Description <code>q</code> <p>Quaternion expression with shape (4,)</p> Example <p>Use the QDCM to rotate a vector:</p> <pre><code>import openscvx as ox\nq = ox.State(\"q\", shape=(4,))\ndcm = ox.QDCM(q)  # Creates rotation matrix, shape (3, 3)\nv_body = ox.Variable(\"v_body\", shape=(3,))\nv_inertial = dcm @ v_body\n</code></pre> Note <p>The input quaternion does not need to be normalized; the implementation automatically handles normalization during evaluation.</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>class QDCM(Expr):\n    \"\"\"Quaternion to Direction Cosine Matrix (DCM) conversion.\n\n    Converts a unit quaternion representation to a 3x3 direction cosine matrix\n    (also known as a rotation matrix). This operation is commonly used in 6-DOF\n    spacecraft dynamics, aircraft simulation, and robotics applications.\n\n    The quaternion is expected in scalar-last format: [qx, qy, qz, qw] where\n    qw is the scalar component. The resulting DCM can be used to transform vectors\n    from one reference frame to another.\n\n    Attributes:\n        q: Quaternion expression with shape (4,)\n\n    Example:\n        Use the QDCM to rotate a vector:\n\n            import openscvx as ox\n            q = ox.State(\"q\", shape=(4,))\n            dcm = ox.QDCM(q)  # Creates rotation matrix, shape (3, 3)\n            v_body = ox.Variable(\"v_body\", shape=(3,))\n            v_inertial = dcm @ v_body\n\n    Note:\n        The input quaternion does not need to be normalized; the implementation\n        automatically handles normalization during evaluation.\n    \"\"\"\n\n    def __init__(self, q):\n        \"\"\"Initialize a quaternion to DCM conversion.\n\n        Args:\n            q: Quaternion expression with shape (4,) in [qx, qy, qz, qw] format\n        \"\"\"\n        self.q = to_expr(q)\n\n    def children(self):\n        return [self.q]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        q = self.q.canonicalize()\n        return QDCM(q)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a quaternion and return DCM shape.\n\n        Returns:\n            tuple: Shape (3, 3) for the resulting direction cosine matrix\n\n        Raises:\n            ValueError: If quaternion does not have shape (4,)\n        \"\"\"\n        q_shape = self.q.check_shape()\n        if q_shape != (4,):\n            raise ValueError(f\"QDCM expects quaternion with shape (4,), got {q_shape}\")\n        return (3, 3)\n\n    def __repr__(self):\n        return f\"qdcm({self.q!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/spatial/#openscvx.symbolic.expr.spatial.QDCM.__init__","title":"<code>__init__(q)</code>","text":"<p>Initialize a quaternion to DCM conversion.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <p>Quaternion expression with shape (4,) in [qx, qy, qz, qw] format</p> required Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>def __init__(self, q):\n    \"\"\"Initialize a quaternion to DCM conversion.\n\n    Args:\n        q: Quaternion expression with shape (4,) in [qx, qy, qz, qw] format\n    \"\"\"\n    self.q = to_expr(q)\n</code></pre>"},{"location":"reference/symbolic/expr/spatial/#openscvx.symbolic.expr.spatial.QDCM.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a quaternion and return DCM shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (3, 3) for the resulting direction cosine matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If quaternion does not have shape (4,)</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a quaternion and return DCM shape.\n\n    Returns:\n        tuple: Shape (3, 3) for the resulting direction cosine matrix\n\n    Raises:\n        ValueError: If quaternion does not have shape (4,)\n    \"\"\"\n    q_shape = self.q.check_shape()\n    if q_shape != (4,):\n        raise ValueError(f\"QDCM expects quaternion with shape (4,), got {q_shape}\")\n    return (3, 3)\n</code></pre>"},{"location":"reference/symbolic/expr/spatial/#openscvx.symbolic.expr.spatial.SSM","title":"<code>SSM</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Angular rate vector to 3x3 skew-symmetric matrix (cross product matrix).</p> <p>Constructs the 3x3 skew-symmetric matrix [\u03c9]x that represents the cross product operation. For any 3D vector v, the cross product \u03c9 x v can be computed as the matrix-vector product [\u03c9]x @ v.</p> The resulting matrix has the form <p>\u23a1  0  -\u03c9z   \u03c9y \u23a4 \u23a2 \u03c9z    0  -\u03c9x \u23a5 \u23a3-\u03c9y   \u03c9x    0 \u23a6</p> <p>This operation is widely used in: - Rigid body dynamics (angular momentum calculations) - DCM time derivatives: \u1e58 = [\u03c9]x @ R - Velocity kinematics in robotics - Coriolis and centrifugal acceleration terms</p> <p>Attributes:</p> Name Type Description <code>w</code> <p>Angular velocity or 3D vector expression with shape (3,)</p> Example <p>Use the SSM to compute the rotation matrix derivative:</p> <pre><code>import openscvx as ox\nomega = ox.Control(\"omega\", shape=(3,))\nR = ox.State(\"R\", shape=(3, 3))  # Direction cosine matrix\n# DCM time derivative\nR_dot = ox.SSM(omega) @ R\n</code></pre> Note <p>The skew-symmetric property ensures that [\u03c9]x\u1d40 = -[\u03c9]x, which is important for preserving orthogonality in DCM propagation.</p> See Also <p>SSMP: 4x4 skew-symmetric matrix for quaternion dynamics</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>class SSM(Expr):\n    \"\"\"Angular rate vector to 3x3 skew-symmetric matrix (cross product matrix).\n\n    Constructs the 3x3 skew-symmetric matrix [\u03c9]x that represents the cross\n    product operation. For any 3D vector v, the cross product \u03c9 x v can be\n    computed as the matrix-vector product [\u03c9]x @ v.\n\n    The resulting matrix has the form:\n        \u23a1  0  -\u03c9z   \u03c9y \u23a4\n        \u23a2 \u03c9z    0  -\u03c9x \u23a5\n        \u23a3-\u03c9y   \u03c9x    0 \u23a6\n\n    This operation is widely used in:\n    - Rigid body dynamics (angular momentum calculations)\n    - DCM time derivatives: \u1e58 = [\u03c9]x @ R\n    - Velocity kinematics in robotics\n    - Coriolis and centrifugal acceleration terms\n\n    Attributes:\n        w: Angular velocity or 3D vector expression with shape (3,)\n\n    Example:\n        Use the SSM to compute the rotation matrix derivative:\n\n            import openscvx as ox\n            omega = ox.Control(\"omega\", shape=(3,))\n            R = ox.State(\"R\", shape=(3, 3))  # Direction cosine matrix\n            # DCM time derivative\n            R_dot = ox.SSM(omega) @ R\n\n    Note:\n        The skew-symmetric property ensures that [\u03c9]x\u1d40 = -[\u03c9]x, which is\n        important for preserving orthogonality in DCM propagation.\n\n    See Also:\n        SSMP: 4x4 skew-symmetric matrix for quaternion dynamics\n    \"\"\"\n\n    def __init__(self, w):\n        \"\"\"Initialize a vector to skew-symmetric matrix conversion.\n\n        Args:\n            w: 3D vector expression with shape (3,) in [\u03c9x, \u03c9y, \u03c9z] format\n        \"\"\"\n        self.w = to_expr(w)\n\n    def children(self):\n        return [self.w]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        w = self.w.canonicalize()\n        return SSM(w)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 3D vector and return matrix shape.\n\n        Returns:\n            tuple: Shape (3, 3) for the resulting skew-symmetric matrix\n\n        Raises:\n            ValueError: If input vector does not have shape (3,)\n        \"\"\"\n        w_shape = self.w.check_shape()\n        if w_shape != (3,):\n            raise ValueError(f\"SSM expects angular velocity with shape (3,), got {w_shape}\")\n        return (3, 3)\n\n    def __repr__(self):\n        return f\"ssm({self.w!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/spatial/#openscvx.symbolic.expr.spatial.SSM.__init__","title":"<code>__init__(w)</code>","text":"<p>Initialize a vector to skew-symmetric matrix conversion.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <p>3D vector expression with shape (3,) in [\u03c9x, \u03c9y, \u03c9z] format</p> required Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>def __init__(self, w):\n    \"\"\"Initialize a vector to skew-symmetric matrix conversion.\n\n    Args:\n        w: 3D vector expression with shape (3,) in [\u03c9x, \u03c9y, \u03c9z] format\n    \"\"\"\n    self.w = to_expr(w)\n</code></pre>"},{"location":"reference/symbolic/expr/spatial/#openscvx.symbolic.expr.spatial.SSM.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 3D vector and return matrix shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (3, 3) for the resulting skew-symmetric matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input vector does not have shape (3,)</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 3D vector and return matrix shape.\n\n    Returns:\n        tuple: Shape (3, 3) for the resulting skew-symmetric matrix\n\n    Raises:\n        ValueError: If input vector does not have shape (3,)\n    \"\"\"\n    w_shape = self.w.check_shape()\n    if w_shape != (3,):\n        raise ValueError(f\"SSM expects angular velocity with shape (3,), got {w_shape}\")\n    return (3, 3)\n</code></pre>"},{"location":"reference/symbolic/expr/spatial/#openscvx.symbolic.expr.spatial.SSMP","title":"<code>SSMP</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Angular rate to 4x4 skew-symmetric matrix for quaternion dynamics.</p> <p>Constructs the 4x4 skew-symmetric matrix \u03a9(\u03c9) used in quaternion kinematic differential equations. This matrix relates angular velocity to the time derivative of the quaternion:</p> <pre><code>q\u0307 = (1/2) * \u03a9(\u03c9) @ q\n</code></pre> The resulting matrix has the form <p>\u23a1  0   \u03c9z  -\u03c9y   \u03c9x \u23a4 \u23a2-\u03c9z    0   \u03c9x   \u03c9y \u23a5 \u23a2 \u03c9y  -\u03c9x    0   \u03c9z \u23a5 \u23a3-\u03c9x  -\u03c9y  -\u03c9z    0 \u23a6</p> <p>This is particularly useful for formulating quaternion-based attitude dynamics in spacecraft and aircraft trajectory optimization problems.</p> <p>Attributes:</p> Name Type Description <code>w</code> <p>Angular velocity vector expression with shape (3,)</p> Example <p>Use the SSMP to compute the quaternion derivative:</p> <pre><code>import openscvx as ox\nomega = ox.Control(\"omega\", shape=(3,))\nq = ox.State(\"q\", shape=(4,))\n# Quaternion kinematic equation\nq_dot = 0.5 * ox.SSMP(omega) @ q\n</code></pre> See Also <p>SSM: 3x3 skew-symmetric matrix for cross product operations</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>class SSMP(Expr):\n    \"\"\"Angular rate to 4x4 skew-symmetric matrix for quaternion dynamics.\n\n    Constructs the 4x4 skew-symmetric matrix \u03a9(\u03c9) used in quaternion kinematic\n    differential equations. This matrix relates angular velocity to the time\n    derivative of the quaternion:\n\n        q\u0307 = (1/2) * \u03a9(\u03c9) @ q\n\n    The resulting matrix has the form:\n        \u23a1  0   \u03c9z  -\u03c9y   \u03c9x \u23a4\n        \u23a2-\u03c9z    0   \u03c9x   \u03c9y \u23a5\n        \u23a2 \u03c9y  -\u03c9x    0   \u03c9z \u23a5\n        \u23a3-\u03c9x  -\u03c9y  -\u03c9z    0 \u23a6\n\n    This is particularly useful for formulating quaternion-based attitude\n    dynamics in spacecraft and aircraft trajectory optimization problems.\n\n    Attributes:\n        w: Angular velocity vector expression with shape (3,)\n\n    Example:\n        Use the SSMP to compute the quaternion derivative:\n\n            import openscvx as ox\n            omega = ox.Control(\"omega\", shape=(3,))\n            q = ox.State(\"q\", shape=(4,))\n            # Quaternion kinematic equation\n            q_dot = 0.5 * ox.SSMP(omega) @ q\n\n    See Also:\n        SSM: 3x3 skew-symmetric matrix for cross product operations\n    \"\"\"\n\n    def __init__(self, w):\n        \"\"\"Initialize an angular velocity to skew-symmetric matrix conversion.\n\n        Args:\n            w: Angular velocity vector expression with shape (3,) in [\u03c9x, \u03c9y, \u03c9z] format\n        \"\"\"\n        self.w = to_expr(w)\n\n    def children(self):\n        return [self.w]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        w = self.w.canonicalize()\n        return SSMP(w)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 3D angular velocity and return matrix shape.\n\n        Returns:\n            tuple: Shape (4, 4) for the resulting skew-symmetric matrix\n\n        Raises:\n            ValueError: If angular velocity does not have shape (3,)\n        \"\"\"\n        w_shape = self.w.check_shape()\n        if w_shape != (3,):\n            raise ValueError(f\"SSMP expects angular velocity with shape (3,), got {w_shape}\")\n        return (4, 4)\n\n    def __repr__(self):\n        return f\"ssmp({self.w!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/spatial/#openscvx.symbolic.expr.spatial.SSMP.__init__","title":"<code>__init__(w)</code>","text":"<p>Initialize an angular velocity to skew-symmetric matrix conversion.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <p>Angular velocity vector expression with shape (3,) in [\u03c9x, \u03c9y, \u03c9z] format</p> required Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>def __init__(self, w):\n    \"\"\"Initialize an angular velocity to skew-symmetric matrix conversion.\n\n    Args:\n        w: Angular velocity vector expression with shape (3,) in [\u03c9x, \u03c9y, \u03c9z] format\n    \"\"\"\n    self.w = to_expr(w)\n</code></pre>"},{"location":"reference/symbolic/expr/spatial/#openscvx.symbolic.expr.spatial.SSMP.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 3D angular velocity and return matrix shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (4, 4) for the resulting skew-symmetric matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If angular velocity does not have shape (3,)</p> Source code in <code>openscvx/symbolic/expr/spatial.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 3D angular velocity and return matrix shape.\n\n    Returns:\n        tuple: Shape (4, 4) for the resulting skew-symmetric matrix\n\n    Raises:\n        ValueError: If angular velocity does not have shape (3,)\n    \"\"\"\n    w_shape = self.w.check_shape()\n    if w_shape != (3,):\n        raise ValueError(f\"SSMP expects angular velocity with shape (3,), got {w_shape}\")\n    return (4, 4)\n</code></pre>"},{"location":"reference/symbolic/expr/state/","title":"state","text":""},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.BoundaryType","title":"<code>BoundaryType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of boundary condition types for state variables.</p> <p>This enum allows users to specify boundary conditions using plain strings while maintaining type safety internally. Boundary conditions control how the optimizer handles initial and final state values.</p> <p>Attributes:</p> Name Type Description <code>FIXED</code> <code>str</code> <p>State value is fixed to a specific value</p> <code>FREE</code> <code>str</code> <p>State value is free to be optimized within bounds</p> <code>MINIMIZE</code> <code>str</code> <p>Objective term to minimize the state value</p> <code>MAXIMIZE</code> <code>str</code> <p>Objective term to maximize the state value</p> Example <p>Can use either enum or string:</p> <pre><code>BoundaryType.FIXED\n\"fixed\"  # Equivalent\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>class BoundaryType(str, Enum):\n    \"\"\"Enumeration of boundary condition types for state variables.\n\n    This enum allows users to specify boundary conditions using plain strings\n    while maintaining type safety internally. Boundary conditions control how\n    the optimizer handles initial and final state values.\n\n    Attributes:\n        FIXED (str): State value is fixed to a specific value\n        FREE (str): State value is free to be optimized within bounds\n        MINIMIZE (str): Objective term to minimize the state value\n        MAXIMIZE (str): Objective term to maximize the state value\n\n    Example:\n        Can use either enum or string:\n\n            BoundaryType.FIXED\n            \"fixed\"  # Equivalent\n    \"\"\"\n\n    FIXED = \"fixed\"\n    FREE = \"free\"\n    MINIMIZE = \"minimize\"\n    MAXIMIZE = \"maximize\"\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.State","title":"<code>State</code>","text":"<p>               Bases: <code>Variable</code></p> <p>State variable with boundary conditions for trajectory optimization.</p> <p>State represents a dynamic state variable in a trajectory optimization problem. Unlike control inputs, states evolve according to dynamics constraints and can have boundary conditions specified at the initial and final time points. Like all Variables, States also support min/max bounds and initial trajectory guesses to help guide the optimization solver toward good solutions.</p> <p>States support four types of boundary conditions:</p> <ul> <li>fixed: State value is constrained to a specific value</li> <li>free: State value is optimized within the specified bounds</li> <li>minimize: Adds a term to the objective function to minimize the state value</li> <li>maximize: Adds a term to the objective function to maximize the state value</li> </ul> <p>Each element of a multi-dimensional state can have different boundary condition types, allowing for fine-grained control over the optimization.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name identifier for this state variable</p> <code>_shape</code> <code>tuple[int, ...]</code> <p>Shape of the state vector (typically 1D like (3,) for 3D position)</p> <code>_slice</code> <code>slice | None</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <code>ndarray | None</code> <p>Minimum bounds for state variables</p> <code>_max</code> <code>ndarray | None</code> <p>Maximum bounds for state variables</p> <code>_guess</code> <code>ndarray | None</code> <p>Initial trajectory guess</p> <code>_initial</code> <code>ndarray | None</code> <p>Initial state values with boundary condition types</p> <code>initial_type</code> <code>ndarray | None</code> <p>Array of boundary condition types for initial state</p> <code>_final</code> <code>ndarray | None</code> <p>Final state values with boundary condition types</p> <code>final_type</code> <code>ndarray | None</code> <p>Array of boundary condition types for final state</p> Example <p>Scalar time state with fixed initial time, minimize final time:</p> <pre><code>time = State(\"time\", (1,))\ntime.min = [0.0]\ntime.max = [10.0]\ntime.initial = [(\"fixed\", 0.0)]\ntime.final = [(\"minimize\", 5.0)]\n</code></pre> <p>3D position state with mixed boundary conditions:</p> <pre><code>pos = State(\"pos\", (3,))\npos.min = [0, 0, 10]\npos.max = [10, 10, 200]\npos.initial = [0, (\"free\", 1), 50]  # x fixed, y free, z fixed\npos.final = [10, (\"free\", 5), (\"maximize\", 150)]  # Maximize final altitude\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>class State(Variable):\n    \"\"\"State variable with boundary conditions for trajectory optimization.\n\n    State represents a dynamic state variable in a trajectory optimization problem.\n    Unlike control inputs, states evolve according to dynamics constraints and can\n    have boundary conditions specified at the initial and final time points.\n    Like all Variables, States also support min/max bounds and initial trajectory\n    guesses to help guide the optimization solver toward good solutions.\n\n    States support four types of boundary conditions:\n\n    - **fixed**: State value is constrained to a specific value\n    - **free**: State value is optimized within the specified bounds\n    - **minimize**: Adds a term to the objective function to minimize the state value\n    - **maximize**: Adds a term to the objective function to maximize the state value\n\n    Each element of a multi-dimensional state can have different boundary condition\n    types, allowing for fine-grained control over the optimization.\n\n    Attributes:\n        name (str): Unique name identifier for this state variable\n        _shape (tuple[int, ...]): Shape of the state vector (typically 1D like (3,) for 3D position)\n        _slice (slice | None): Internal slice information for variable indexing\n        _min (np.ndarray | None): Minimum bounds for state variables\n        _max (np.ndarray | None): Maximum bounds for state variables\n        _guess (np.ndarray | None): Initial trajectory guess\n        _initial (np.ndarray | None): Initial state values with boundary condition types\n        initial_type (np.ndarray | None): Array of boundary condition types for initial state\n        _final (np.ndarray | None): Final state values with boundary condition types\n        final_type (np.ndarray | None): Array of boundary condition types for final state\n\n    Example:\n        Scalar time state with fixed initial time, minimize final time:\n\n            time = State(\"time\", (1,))\n            time.min = [0.0]\n            time.max = [10.0]\n            time.initial = [(\"fixed\", 0.0)]\n            time.final = [(\"minimize\", 5.0)]\n\n        3D position state with mixed boundary conditions:\n\n            pos = State(\"pos\", (3,))\n            pos.min = [0, 0, 10]\n            pos.max = [10, 10, 200]\n            pos.initial = [0, (\"free\", 1), 50]  # x fixed, y free, z fixed\n            pos.final = [10, (\"free\", 5), (\"maximize\", 150)]  # Maximize final altitude\n    \"\"\"\n\n    def __init__(self, name, shape):\n        \"\"\"Initialize a State object.\n\n        Args:\n            name: Name identifier for the state variable\n            shape: Shape of the state vector (typically 1D tuple)\n        \"\"\"\n        super().__init__(name, shape)\n        self._initial = None\n        self.initial_type = None\n        self._final = None\n        self.final_type = None\n        self._scaling_min = None\n        self._scaling_max = None\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash State including boundary condition types.\n\n        Extends Variable._hash_into to include the structural metadata that\n        affects the compiled problem: boundary condition types (fixed, free,\n        minimize, maximize). Values are not hashed as they are runtime parameters.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        # Hash the base Variable attributes (class name, shape, slice)\n        super()._hash_into(hasher)\n        # Hash boundary condition types (these affect constraint structure)\n        if self.initial_type is not None:\n            hasher.update(b\"initial_type:\")\n            hasher.update(str(self.initial_type.tolist()).encode())\n        if self.final_type is not None:\n            hasher.update(b\"final_type:\")\n            hasher.update(str(self.final_type.tolist()).encode())\n\n    @property\n    def min(self):\n        \"\"\"Get the minimum bounds for the state variables.\n\n        Returns:\n            Array of minimum values for each state variable element.\n\n        Example:\n            Get lower bounds:\n\n                pos = State(\"pos\", (3,))\n                pos.min = [0, 0, 10]\n                print(pos.min)  # [0. 0. 10.]\n        \"\"\"\n        return self._min\n\n    @min.setter\n    def min(self, val):\n        \"\"\"Set the minimum bounds for the state variables.\n\n        Bounds are validated against any fixed initial/final conditions to ensure\n        consistency.\n\n        Args:\n            val: Array of minimum values, must match the state shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape, or if fixed\n                boundary conditions violate the bounds\n\n        Example:\n            Set lower bounds:\n\n                pos = State(\"pos\", (3,))\n                pos.min = [0, 0, 10]\n                pos.initial = [0, 5, 15]  # Must satisfy: 0&gt;=0, 5&gt;=0, 15&gt;=10\n        \"\"\"\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(f\"Min shape {val.shape} does not match State shape {self.shape}\")\n        self._min = val\n        self._check_bounds_against_initial_final()\n\n    @property\n    def max(self):\n        \"\"\"Get the maximum bounds for the state variables.\n\n        Returns:\n            Array of maximum values for each state variable element.\n\n        Example:\n            Get upper bounds:\n\n                vel = State(\"vel\", (3,))\n                vel.max = [10, 10, 5]\n                print(vel.max)  # [10. 10. 5.]\n        \"\"\"\n        return self._max\n\n    @max.setter\n    def max(self, val):\n        \"\"\"Set the maximum bounds for the state variables.\n\n        Bounds are validated against any fixed initial/final conditions to ensure\n        consistency.\n\n        Args:\n            val: Array of maximum values, must match the state shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape, or if fixed\n                boundary conditions violate the bounds\n\n        Example:\n            Set upper bounds:\n\n                vel = State(\"vel\", (3,))\n                vel.max = [10, 10, 5]\n                vel.final = [8, 9, 4]  # Must satisfy: 8&lt;=10, 9&lt;=10, 4&lt;=5\n        \"\"\"\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(f\"Max shape {val.shape} does not match State shape {self.shape}\")\n        self._max = val\n        self._check_bounds_against_initial_final()\n\n    def _check_bounds_against_initial_final(self):\n        \"\"\"Validate that fixed boundary conditions respect min/max bounds.\n\n        This internal method is automatically called when bounds or boundary\n        conditions are set to ensure consistency.\n\n        Raises:\n            ValueError: If any fixed initial or final value violates the min/max bounds\n        \"\"\"\n        for field_name, data, types in [\n            (\"initial\", self._initial, self.initial_type),\n            (\"final\", self._final, self.final_type),\n        ]:\n            if data is None or types is None:\n                continue\n            for i, val in np.ndenumerate(data):\n                if types[i] != \"Fix\":\n                    continue\n                min_i = self._min[i] if self._min is not None else -np.inf\n                max_i = self._max[i] if self._max is not None else np.inf\n                if val &lt; min_i:\n                    raise ValueError(\n                        f\"{field_name.capitalize()} Fixed value at index {i[0]} is lower then the \"\n                        f\"min: {val} &lt; {min_i}\"\n                    )\n                if val &gt; max_i:\n                    raise ValueError(\n                        f\"{field_name.capitalize()} Fixed value at index {i[0]} is greater then \"\n                        f\"the max: {val} &gt; {max_i}\"\n                    )\n\n    @property\n    def initial(self):\n        \"\"\"Get the initial state boundary condition values.\n\n        Returns:\n            Array of initial state values (regardless of boundary condition type),\n            or None if not set.\n\n        Note:\n            Use `initial_type` to see the boundary condition types for each element.\n\n        Example:\n            Get initial state boundary conditions:\n\n                x = State(\"x\", (2,))\n                x.initial = [0, (\"free\", 1)]\n                print(x.initial)  # [0. 1.]\n                print(x.initial_type)  # ['Fix' 'Free']\n        \"\"\"\n        return self._initial\n\n    @initial.setter\n    def initial(self, arr):\n        \"\"\"Set the initial state boundary conditions.\n\n        Each element can be specified as either a simple number (defaults to \"fixed\")\n        or a tuple of (type, value) where type specifies the boundary condition.\n\n        Args:\n            arr: Array-like of initial conditions. Each element can be:\n                - A number: Defaults to fixed boundary condition at that value\n                - A tuple (type, value): Where type is one of:\n                    - \"fixed\": Constrain state to this exact value\n                    - \"free\": Let optimizer choose within bounds, initialize at value\n                    - \"minimize\": Add objective term to minimize, initialize at value\n                    - \"maximize\": Add objective term to maximize, initialize at value\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape, if boundary\n                condition type is invalid, or if fixed values violate bounds\n\n        Example:\n            Set initial state boundary conditions:\n\n                pos = State(\"pos\", (3,))\n                pos.min = [0, 0, 0]\n                pos.max = [10, 10, 10]\n                # x fixed at 0, y free (starts at 5), z fixed at 2\n                pos.initial = [0, (\"free\", 5), 2]\n\n            Can also minimize/maximize boundary values:\n\n                time = State(\"t\", (1,))\n                time.initial = [(\"minimize\", 0)]  # Minimize initial time\n        \"\"\"\n        # Convert to list first to handle mixed types properly\n        if not isinstance(arr, (list, tuple)):\n            arr = np.asarray(arr)\n            if arr.shape != self.shape:\n                raise ValueError(f\"Shape mismatch: {arr.shape} != {self.shape}\")\n            arr = arr.tolist()\n\n        # Ensure we have the right number of elements\n        if len(arr) != self.shape[0]:\n            raise ValueError(f\"Length mismatch: got {len(arr)} elements, expected {self.shape[0]}\")\n\n        self._initial = np.zeros(self.shape, dtype=float)\n        self.initial_type = np.full(self.shape, \"Fix\", dtype=object)\n\n        for i, v in enumerate(arr):\n            if isinstance(v, tuple) and len(v) == 2:\n                # Tuple API: (type, value)\n                bc_type_str, bc_value = v\n                try:\n                    bc_type = BoundaryType(bc_type_str)  # Validates the string\n                except ValueError:\n                    valid_types = [t.value for t in BoundaryType]\n                    raise ValueError(\n                        f\"Invalid boundary condition type: {bc_type_str}. \"\n                        f\"Valid types are: {valid_types}\"\n                    )\n                self._initial[i] = float(bc_value)\n                self.initial_type[i] = bc_type.value.capitalize()\n            elif isinstance(v, (int, float, np.number)):\n                # Simple number defaults to fixed\n                self._initial[i] = float(v)\n                self.initial_type[i] = \"Fix\"\n            else:\n                raise ValueError(\n                    f\"Invalid boundary condition format: {v}. \"\n                    f\"Use a number (defaults to fixed) or tuple ('type', value) \"\n                    f\"where type is 'fixed', 'free', 'minimize', or 'maximize'.\"\n                )\n\n        self._check_bounds_against_initial_final()\n\n    @property\n    def final(self):\n        \"\"\"Get the final state boundary condition values.\n\n        Returns:\n            Array of final state values (regardless of boundary condition type),\n            or None if not set.\n\n        Note:\n            Use `final_type` to see the boundary condition types for each element.\n\n        Example:\n            Get final state boundary conditions:\n\n                x = State(\"x\", (2,))\n                x.final = [10, (\"minimize\", 0)]\n                print(x.final)  # [10. 0.]\n                print(x.final_type)  # ['Fix' 'Minimize']\n        \"\"\"\n        return self._final\n\n    @final.setter\n    def final(self, arr):\n        \"\"\"Set the final state boundary conditions.\n\n        Each element can be specified as either a simple number (defaults to \"fixed\")\n        or a tuple of (type, value) where type specifies the boundary condition.\n\n        Args:\n            arr: Array-like of final conditions. Each element can be:\n                - A number: Defaults to fixed boundary condition at that value\n                - A tuple (type, value): Where type is one of:\n                    - \"fixed\": Constrain state to this exact value\n                    - \"free\": Let optimizer choose within bounds, initialize at value\n                    - \"minimize\": Add objective term to minimize, initialize at value\n                    - \"maximize\": Add objective term to maximize, initialize at value\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape, if boundary\n                condition type is invalid, or if fixed values violate bounds\n\n        Example:\n            Set final state boundary conditionis:\n\n                pos = State(\"pos\", (3,))\n                pos.min = [0, 0, 0]\n                pos.max = [10, 10, 10]\n                # x fixed at 10, y free (starts at 5), z maximize altitude\n                pos.final = [10, (\"free\", 5), (\"maximize\", 8)]\n\n            Minimize final time in time-optimal problem:\n\n                time = State(\"t\", (1,))\n                time.final = [(\"minimize\", 10)]\n        \"\"\"\n        # Convert to list first to handle mixed types properly\n        if not isinstance(arr, (list, tuple)):\n            arr = np.asarray(arr)\n            if arr.shape != self.shape:\n                raise ValueError(f\"Shape mismatch: {arr.shape} != {self.shape}\")\n            arr = arr.tolist()\n\n        # Ensure we have the right number of elements\n        if len(arr) != self.shape[0]:\n            raise ValueError(f\"Length mismatch: got {len(arr)} elements, expected {self.shape[0]}\")\n\n        self._final = np.zeros(self.shape, dtype=float)\n        self.final_type = np.full(self.shape, \"Fix\", dtype=object)\n\n        for i, v in enumerate(arr):\n            if isinstance(v, tuple) and len(v) == 2:\n                # Tuple API: (type, value)\n                bc_type_str, bc_value = v\n                try:\n                    bc_type = BoundaryType(bc_type_str)  # Validates the string\n                except ValueError:\n                    valid_types = [t.value for t in BoundaryType]\n                    raise ValueError(\n                        f\"Invalid boundary condition type: {bc_type_str}. \"\n                        f\"Valid types are: {valid_types}\"\n                    )\n                self._final[i] = float(bc_value)\n                self.final_type[i] = bc_type.value.capitalize()\n            elif isinstance(v, (int, float, np.number)):\n                # Simple number defaults to fixed\n                self._final[i] = float(v)\n                self.final_type[i] = \"Fix\"\n            else:\n                raise ValueError(\n                    f\"Invalid boundary condition format: {v}. \"\n                    f\"Use a number (defaults to fixed) or tuple ('type', value) \"\n                    f\"where type is 'fixed', 'free', 'minimize', or 'maximize'.\"\n                )\n\n        self._check_bounds_against_initial_final()\n\n    @property\n    def scaling_min(self):\n        \"\"\"Get the scaling minimum bounds for the state variables.\n\n        Returns:\n            Array of scaling minimum values for each state variable element, or None if not set.\n        \"\"\"\n        return self._scaling_min\n\n    @scaling_min.setter\n    def scaling_min(self, val):\n        \"\"\"Set the scaling minimum bounds for the state variables.\n\n        Args:\n            val: Array of scaling minimum values, must match the state shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape\n        \"\"\"\n        if val is None:\n            self._scaling_min = None\n            return\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(\n                f\"Scaling min shape {val.shape} does not match State shape {self.shape}\"\n            )\n        self._scaling_min = val\n\n    @property\n    def scaling_max(self):\n        \"\"\"Get the scaling maximum bounds for the state variables.\n\n        Returns:\n            Array of scaling maximum values for each state variable element, or None if not set.\n        \"\"\"\n        return self._scaling_max\n\n    @scaling_max.setter\n    def scaling_max(self, val):\n        \"\"\"Set the scaling maximum bounds for the state variables.\n\n        Args:\n            val: Array of scaling maximum values, must match the state shape exactly\n\n        Raises:\n            ValueError: If the shape doesn't match the state shape\n        \"\"\"\n        if val is None:\n            self._scaling_max = None\n            return\n        val = np.asarray(val, dtype=float)\n        if val.shape != self.shape:\n            raise ValueError(\n                f\"Scaling max shape {val.shape} does not match State shape {self.shape}\"\n            )\n        self._scaling_max = val\n\n    def __repr__(self):\n        \"\"\"String representation of the State object.\n\n        Returns:\n            Concise string showing the state name and shape.\n        \"\"\"\n        return f\"State('{self.name}', shape={self.shape})\"\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.State.final","title":"<code>final</code>  <code>property</code> <code>writable</code>","text":"<p>Get the final state boundary condition values.</p> <p>Returns:</p> Type Description <p>Array of final state values (regardless of boundary condition type),</p> <p>or None if not set.</p> Note <p>Use <code>final_type</code> to see the boundary condition types for each element.</p> Example <p>Get final state boundary conditions:</p> <pre><code>x = State(\"x\", (2,))\nx.final = [10, (\"minimize\", 0)]\nprint(x.final)  # [10. 0.]\nprint(x.final_type)  # ['Fix' 'Minimize']\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.State.initial","title":"<code>initial</code>  <code>property</code> <code>writable</code>","text":"<p>Get the initial state boundary condition values.</p> <p>Returns:</p> Type Description <p>Array of initial state values (regardless of boundary condition type),</p> <p>or None if not set.</p> Note <p>Use <code>initial_type</code> to see the boundary condition types for each element.</p> Example <p>Get initial state boundary conditions:</p> <pre><code>x = State(\"x\", (2,))\nx.initial = [0, (\"free\", 1)]\nprint(x.initial)  # [0. 1.]\nprint(x.initial_type)  # ['Fix' 'Free']\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.State.max","title":"<code>max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the maximum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of maximum values for each state variable element.</p> Example <p>Get upper bounds:</p> <pre><code>vel = State(\"vel\", (3,))\nvel.max = [10, 10, 5]\nprint(vel.max)  # [10. 10. 5.]\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.State.min","title":"<code>min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the minimum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of minimum values for each state variable element.</p> Example <p>Get lower bounds:</p> <pre><code>pos = State(\"pos\", (3,))\npos.min = [0, 0, 10]\nprint(pos.min)  # [0. 0. 10.]\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.State.scaling_max","title":"<code>scaling_max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling maximum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of scaling maximum values for each state variable element, or None if not set.</p>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.State.scaling_min","title":"<code>scaling_min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the scaling minimum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of scaling minimum values for each state variable element, or None if not set.</p>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.State.__init__","title":"<code>__init__(name, shape)</code>","text":"<p>Initialize a State object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name identifier for the state variable</p> required <code>shape</code> <p>Shape of the state vector (typically 1D tuple)</p> required Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def __init__(self, name, shape):\n    \"\"\"Initialize a State object.\n\n    Args:\n        name: Name identifier for the state variable\n        shape: Shape of the state vector (typically 1D tuple)\n    \"\"\"\n    super().__init__(name, shape)\n    self._initial = None\n    self.initial_type = None\n    self._final = None\n    self.final_type = None\n    self._scaling_min = None\n    self._scaling_max = None\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.Fixed","title":"<code>Fixed(value)</code>","text":"<p>Create a fixed boundary condition tuple.</p> <p>This is a convenience function that returns a tuple (\"fixed\", value) which can be used to explicitly specify fixed boundary conditions for State or Time objects. Note that plain numbers default to fixed, so this is mainly for clarity.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>Fixed value for the boundary condition.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(\"fixed\", value) tuple suitable for use in State.initial, State.final, or Time.initial, Time.final.</p> Example <pre><code>pos = ox.State(\"pos\", (3,))\npos.final = [ox.Fixed(10.0), ox.Free(5.0), ox.Fixed(2.0)]\n\n# Equivalent to:\npos.final = [10.0, ox.Free(5.0), 2.0]  # Plain numbers default to fixed\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def Fixed(value):\n    \"\"\"Create a fixed boundary condition tuple.\n\n    This is a convenience function that returns a tuple (\"fixed\", value) which\n    can be used to explicitly specify fixed boundary conditions for State or Time objects.\n    Note that plain numbers default to fixed, so this is mainly for clarity.\n\n    Args:\n        value: Fixed value for the boundary condition.\n\n    Returns:\n        tuple: (\"fixed\", value) tuple suitable for use in State.initial, State.final,\n            or Time.initial, Time.final.\n\n    Example:\n        ```python\n        pos = ox.State(\"pos\", (3,))\n        pos.final = [ox.Fixed(10.0), ox.Free(5.0), ox.Fixed(2.0)]\n\n        # Equivalent to:\n        pos.final = [10.0, ox.Free(5.0), 2.0]  # Plain numbers default to fixed\n        ```\n    \"\"\"\n    return (\"fixed\", value)\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.Free","title":"<code>Free(guess)</code>","text":"<p>Create a free boundary condition tuple.</p> <p>This is a convenience function that returns a tuple (\"free\", guess) which can be used to specify free boundary conditions for State or Time objects.</p> <p>Parameters:</p> Name Type Description Default <code>guess</code> <p>Initial guess value for the free variable.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(\"free\", guess) tuple suitable for use in State.initial, State.final, or Time.initial, Time.final.</p> Example <pre><code>pos = ox.State(\"pos\", (3,))\npos.final = [ox.Free(5.0), ox.Free(3.0), 10]  # First two free, third fixed\n\ntime = ox.Time(\n    initial=0.0,\n    final=ox.Free(10.0),\n    min=0.0,\n    max=20.0\n)\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def Free(guess):\n    \"\"\"Create a free boundary condition tuple.\n\n    This is a convenience function that returns a tuple (\"free\", guess) which\n    can be used to specify free boundary conditions for State or Time objects.\n\n    Args:\n        guess: Initial guess value for the free variable.\n\n    Returns:\n        tuple: (\"free\", guess) tuple suitable for use in State.initial, State.final,\n            or Time.initial, Time.final.\n\n    Example:\n        ```python\n        pos = ox.State(\"pos\", (3,))\n        pos.final = [ox.Free(5.0), ox.Free(3.0), 10]  # First two free, third fixed\n\n        time = ox.Time(\n            initial=0.0,\n            final=ox.Free(10.0),\n            min=0.0,\n            max=20.0\n        )\n        ```\n    \"\"\"\n    return (\"free\", guess)\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.Maximize","title":"<code>Maximize(guess)</code>","text":"<p>Create a maximize boundary condition tuple.</p> <p>This is a convenience function that returns a tuple (\"maximize\", guess) which can be used to specify that a boundary value should be maximized in the objective function for State or Time objects.</p> <p>Parameters:</p> Name Type Description Default <code>guess</code> <p>Initial guess value for the variable to be maximized.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(\"maximize\", guess) tuple suitable for use in State.initial, State.final, or Time.initial, Time.final.</p> Example <pre><code>altitude = ox.State(\"altitude\", (1,))\naltitude.final = [ox.Maximize(100.0)]  # Maximize final altitude\n\ntime = ox.Time(\n    initial=ox.Maximize(0.0),  # Maximize initial time\n    final=10.0,\n    min=0.0,\n    max=20.0\n)\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def Maximize(guess):\n    \"\"\"Create a maximize boundary condition tuple.\n\n    This is a convenience function that returns a tuple (\"maximize\", guess) which\n    can be used to specify that a boundary value should be maximized in the objective\n    function for State or Time objects.\n\n    Args:\n        guess: Initial guess value for the variable to be maximized.\n\n    Returns:\n        tuple: (\"maximize\", guess) tuple suitable for use in State.initial, State.final,\n            or Time.initial, Time.final.\n\n    Example:\n        ```python\n        altitude = ox.State(\"altitude\", (1,))\n        altitude.final = [ox.Maximize(100.0)]  # Maximize final altitude\n\n        time = ox.Time(\n            initial=ox.Maximize(0.0),  # Maximize initial time\n            final=10.0,\n            min=0.0,\n            max=20.0\n        )\n        ```\n    \"\"\"\n    return (\"maximize\", guess)\n</code></pre>"},{"location":"reference/symbolic/expr/state/#openscvx.symbolic.expr.state.Minimize","title":"<code>Minimize(guess)</code>","text":"<p>Create a minimize boundary condition tuple.</p> <p>This is a convenience function that returns a tuple (\"minimize\", guess) which can be used to specify that a boundary value should be minimized in the objective function for State or Time objects.</p> <p>Parameters:</p> Name Type Description Default <code>guess</code> <p>Initial guess value for the variable to be minimized.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(\"minimize\", guess) tuple suitable for use in State.initial, State.final, or Time.initial, Time.final.</p> Example <pre><code>time = ox.Time(\n    initial=0.0,\n    final=ox.Minimize(10.0),  # Minimize final time\n    min=0.0,\n    max=20.0\n)\n\nfuel = ox.State(\"fuel\", (1,))\nfuel.final = [ox.Minimize(0)]  # Minimize final fuel consumption\n</code></pre> Source code in <code>openscvx/symbolic/expr/state.py</code> <pre><code>def Minimize(guess):\n    \"\"\"Create a minimize boundary condition tuple.\n\n    This is a convenience function that returns a tuple (\"minimize\", guess) which\n    can be used to specify that a boundary value should be minimized in the objective\n    function for State or Time objects.\n\n    Args:\n        guess: Initial guess value for the variable to be minimized.\n\n    Returns:\n        tuple: (\"minimize\", guess) tuple suitable for use in State.initial, State.final,\n            or Time.initial, Time.final.\n\n    Example:\n        ```python\n        time = ox.Time(\n            initial=0.0,\n            final=ox.Minimize(10.0),  # Minimize final time\n            min=0.0,\n            max=20.0\n        )\n\n        fuel = ox.State(\"fuel\", (1,))\n        fuel.final = [ox.Minimize(0)]  # Minimize final fuel consumption\n        ```\n    \"\"\"\n    return (\"minimize\", guess)\n</code></pre>"},{"location":"reference/symbolic/expr/stl/","title":"stl","text":"<p>Signal Temporal Logic (STL) operations for trajectory optimization.</p> <p>This module provides symbolic expression nodes for Signal Temporal Logic (STL) operations, enabling the specification of complex temporal and logical constraints in optimization problems. STL is particularly useful for robotics and autonomous systems where tasks involve temporal reasoning.</p>"},{"location":"reference/symbolic/expr/stl/#openscvx.symbolic.expr.stl.Or","title":"<code>Or</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Logical OR operation for disjunctive constraints.</p> <p>Represents a logical disjunction (OR) between multiple constraint expressions. This is particularly useful in STL-based trajectory optimization for expressing choices or alternatives in task specifications. The Or operation is typically relaxed using smooth approximations (e.g., LogSumExp) during optimization.</p> <p>The Or operation allows expressing constraints like:</p> <ul> <li>\"Reach either goal A OR goal B\"</li> <li>\"Avoid obstacle 1 OR obstacle 2\" (at least one must be satisfied)</li> <li>\"Use path 1 OR path 2 OR path 3\"</li> </ul> <p>During optimization, the disjunction is typically approximated using:     Or(\u03c6\u2081, \u03c6\u2082, ..., \u03c6\u2099) \u2248 LSE(\u03c6\u2081, \u03c6\u2082, ..., \u03c6\u2099) \u2265 0</p> <p>where LSE is the LogSumExp (smooth maximum) function.</p> <p>Attributes:</p> Name Type Description <code>operands</code> <p>List of expressions representing the disjunctive clauses</p> Example <p>Use Or STL operator to enforce that robot must reach either of two goal regions:</p> <pre><code>import openscvx as ox\nx = ox.State(\"x\", shape=(2,))\ngoal_a = ox.Parameter(\"goal_a\", shape=(2,), value=[1.0, 1.0])\ngoal_b = ox.Parameter(\"goal_b\", shape=(2,), value=[-1.0, -1.0])\n# Robot is within 0.5 units of either goal\nreach_a = 0.25 - ox.Norm(x - goal_a)**2\nreach_b = 0.25 - ox.Norm(x - goal_b)**2\nreach_either = ox.Or(reach_a, reach_b)\n</code></pre> Note <p>The Or operation produces a scalar result even when operands are vector expressions, as it represents a single logical proposition.</p> See Also <p>LogSumExp: Common smooth approximation for OR operations Max: Hard maximum (non-smooth alternative)</p> Source code in <code>openscvx/symbolic/expr/stl.py</code> <pre><code>class Or(Expr):\n    \"\"\"Logical OR operation for disjunctive constraints.\n\n    Represents a logical disjunction (OR) between multiple constraint expressions.\n    This is particularly useful in STL-based trajectory optimization for expressing\n    choices or alternatives in task specifications. The Or operation is typically\n    relaxed using smooth approximations (e.g., LogSumExp) during optimization.\n\n    The Or operation allows expressing constraints like:\n\n    - \"Reach either goal A OR goal B\"\n    - \"Avoid obstacle 1 OR obstacle 2\" (at least one must be satisfied)\n    - \"Use path 1 OR path 2 OR path 3\"\n\n    During optimization, the disjunction is typically approximated using:\n        Or(\u03c6\u2081, \u03c6\u2082, ..., \u03c6\u2099) \u2248 LSE(\u03c6\u2081, \u03c6\u2082, ..., \u03c6\u2099) \u2265 0\n\n    where LSE is the LogSumExp (smooth maximum) function.\n\n    Attributes:\n        operands: List of expressions representing the disjunctive clauses\n\n    Example:\n        Use Or STL operator to enforce that robot must reach either of two goal regions:\n\n            import openscvx as ox\n            x = ox.State(\"x\", shape=(2,))\n            goal_a = ox.Parameter(\"goal_a\", shape=(2,), value=[1.0, 1.0])\n            goal_b = ox.Parameter(\"goal_b\", shape=(2,), value=[-1.0, -1.0])\n            # Robot is within 0.5 units of either goal\n            reach_a = 0.25 - ox.Norm(x - goal_a)**2\n            reach_b = 0.25 - ox.Norm(x - goal_b)**2\n            reach_either = ox.Or(reach_a, reach_b)\n\n    Note:\n        The Or operation produces a scalar result even when operands are vector\n        expressions, as it represents a single logical proposition.\n\n    See Also:\n        LogSumExp: Common smooth approximation for OR operations\n        Max: Hard maximum (non-smooth alternative)\n    \"\"\"\n\n    def __init__(self, *operands):\n        \"\"\"Initialize a logical OR operation.\n\n        Args:\n            *operands: Two or more expressions to combine with logical OR.\n                      Each operand typically represents a constraint or condition.\n\n        Raises:\n            ValueError: If fewer than two operands are provided\n        \"\"\"\n        if len(operands) &lt; 2:\n            raise ValueError(\"Or requires at least two operands\")\n        self.operands = [to_expr(op) for op in operands]\n\n    def children(self):\n        return self.operands\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize by flattening nested Or expressions.\n\n        Flattens nested Or operations into a single flat Or with all clauses\n        at the same level. For example: Or(a, Or(b, c)) \u2192 Or(a, b, c).\n        Also canonicalizes all operands recursively.\n\n        Returns:\n            Expr: Canonical form of the Or expression. If only one operand\n                  remains after canonicalization, returns that operand directly.\n        \"\"\"\n        operands = []\n\n        for operand in self.operands:\n            canonicalized = operand.canonicalize()\n            if isinstance(canonicalized, Or):\n                # Flatten nested Or: Or(a, Or(b, c)) -&gt; Or(a, b, c)\n                operands.extend(canonicalized.operands)\n            else:\n                operands.append(canonicalized)\n\n        # Return simplified Or expression\n        if len(operands) == 1:\n            return operands[0]\n        return Or(*operands)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Validate operand shapes and return result shape.\n\n        Checks that all operands have compatible (broadcastable) shapes. The Or\n        operation supports broadcasting, allowing mixing of scalars and vectors.\n\n        Returns:\n            tuple: Empty tuple () indicating a scalar result, as Or represents\n                   a single logical proposition\n\n        Raises:\n            ValueError: If fewer than two operands exist\n            ValueError: If operand shapes are not broadcastable\n        \"\"\"\n        if len(self.operands) &lt; 2:\n            raise ValueError(\"Or requires at least two operands\")\n\n        # Validate all operands and get their shapes\n        operand_shapes = [operand.check_shape() for operand in self.operands]\n\n        # For logical operations, all operands should be broadcastable\n        # This allows mixing scalars with vectors for element-wise operations\n        try:\n            result_shape = operand_shapes[0]\n            for shape in operand_shapes[1:]:\n                result_shape = np.broadcast_shapes(result_shape, shape)\n        except ValueError as e:\n            raise ValueError(f\"Or operands not broadcastable: {operand_shapes}\") from e\n\n        # Or produces a scalar result (like constraints)\n        return ()\n\n    def __repr__(self):\n        operands_repr = \" | \".join(repr(op) for op in self.operands)\n        return f\"Or({operands_repr})\"\n</code></pre>"},{"location":"reference/symbolic/expr/stl/#openscvx.symbolic.expr.stl.Or.__init__","title":"<code>__init__(*operands)</code>","text":"<p>Initialize a logical OR operation.</p> <p>Parameters:</p> Name Type Description Default <code>*operands</code> <p>Two or more expressions to combine with logical OR.       Each operand typically represents a constraint or condition.</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two operands are provided</p> Source code in <code>openscvx/symbolic/expr/stl.py</code> <pre><code>def __init__(self, *operands):\n    \"\"\"Initialize a logical OR operation.\n\n    Args:\n        *operands: Two or more expressions to combine with logical OR.\n                  Each operand typically represents a constraint or condition.\n\n    Raises:\n        ValueError: If fewer than two operands are provided\n    \"\"\"\n    if len(operands) &lt; 2:\n        raise ValueError(\"Or requires at least two operands\")\n    self.operands = [to_expr(op) for op in operands]\n</code></pre>"},{"location":"reference/symbolic/expr/stl/#openscvx.symbolic.expr.stl.Or.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize by flattening nested Or expressions.</p> <p>Flattens nested Or operations into a single flat Or with all clauses at the same level. For example: Or(a, Or(b, c)) \u2192 Or(a, b, c). Also canonicalizes all operands recursively.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Canonical form of the Or expression. If only one operand   remains after canonicalization, returns that operand directly.</p> Source code in <code>openscvx/symbolic/expr/stl.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize by flattening nested Or expressions.\n\n    Flattens nested Or operations into a single flat Or with all clauses\n    at the same level. For example: Or(a, Or(b, c)) \u2192 Or(a, b, c).\n    Also canonicalizes all operands recursively.\n\n    Returns:\n        Expr: Canonical form of the Or expression. If only one operand\n              remains after canonicalization, returns that operand directly.\n    \"\"\"\n    operands = []\n\n    for operand in self.operands:\n        canonicalized = operand.canonicalize()\n        if isinstance(canonicalized, Or):\n            # Flatten nested Or: Or(a, Or(b, c)) -&gt; Or(a, b, c)\n            operands.extend(canonicalized.operands)\n        else:\n            operands.append(canonicalized)\n\n    # Return simplified Or expression\n    if len(operands) == 1:\n        return operands[0]\n    return Or(*operands)\n</code></pre>"},{"location":"reference/symbolic/expr/stl/#openscvx.symbolic.expr.stl.Or.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate operand shapes and return result shape.</p> <p>Checks that all operands have compatible (broadcastable) shapes. The Or operation supports broadcasting, allowing mixing of scalars and vectors.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () indicating a scalar result, as Or represents    a single logical proposition</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two operands exist</p> <code>ValueError</code> <p>If operand shapes are not broadcastable</p> Source code in <code>openscvx/symbolic/expr/stl.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Validate operand shapes and return result shape.\n\n    Checks that all operands have compatible (broadcastable) shapes. The Or\n    operation supports broadcasting, allowing mixing of scalars and vectors.\n\n    Returns:\n        tuple: Empty tuple () indicating a scalar result, as Or represents\n               a single logical proposition\n\n    Raises:\n        ValueError: If fewer than two operands exist\n        ValueError: If operand shapes are not broadcastable\n    \"\"\"\n    if len(self.operands) &lt; 2:\n        raise ValueError(\"Or requires at least two operands\")\n\n    # Validate all operands and get their shapes\n    operand_shapes = [operand.check_shape() for operand in self.operands]\n\n    # For logical operations, all operands should be broadcastable\n    # This allows mixing scalars with vectors for element-wise operations\n    try:\n        result_shape = operand_shapes[0]\n        for shape in operand_shapes[1:]:\n            result_shape = np.broadcast_shapes(result_shape, shape)\n    except ValueError as e:\n        raise ValueError(f\"Or operands not broadcastable: {operand_shapes}\") from e\n\n    # Or produces a scalar result (like constraints)\n    return ()\n</code></pre>"},{"location":"reference/symbolic/expr/variable/","title":"variable","text":""},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable","title":"<code>Variable</code>","text":"<p>               Bases: <code>Leaf</code></p> <p>Base class for decision variables in optimization problems.</p> <p>Variable represents decision variables (free parameters) in an optimization problem. These are values that the optimizer can adjust to minimize the objective function while satisfying constraints. Variables can have bounds (min/max) and initial guesses to guide the optimization process.</p> <p>Unlike Parameters (which are fixed values that can be changed between solves), Variables are optimized by the solver. In trajectory optimization, Variables typically represent discretized state or control trajectories.</p> Note <p>Variable is typically not instantiated directly. Instead, use the specialized subclasses State (for state variables with boundary conditions) or Control (for control inputs). These provide additional functionality specific to trajectory optimization.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the variable</p> <code>_shape</code> <code>tuple[int, ...]</code> <p>Shape of the variable as a tuple (typically 1D)</p> <code>_slice</code> <code>slice | None</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <code>ndarray | None</code> <p>Minimum bounds for each element of the variable</p> <code>_max</code> <code>ndarray | None</code> <p>Maximum bounds for each element of the variable</p> <code>_guess</code> <code>ndarray | None</code> <p>Initial guess for the variable trajectory (n_points, n_vars)</p> Example Source code in <code>openscvx/symbolic/expr/variable.py</code> <pre><code>class Variable(Leaf):\n    \"\"\"Base class for decision variables in optimization problems.\n\n    Variable represents decision variables (free parameters) in an optimization problem.\n    These are values that the optimizer can adjust to minimize the objective function\n    while satisfying constraints. Variables can have bounds (min/max) and initial guesses\n    to guide the optimization process.\n\n    Unlike Parameters (which are fixed values that can be changed between solves),\n    Variables are optimized by the solver. In trajectory optimization, Variables typically\n    represent discretized state or control trajectories.\n\n    Note:\n        Variable is typically not instantiated directly. Instead, use the specialized\n        subclasses State (for state variables with boundary conditions) or Control\n        (for control inputs). These provide additional functionality specific to\n        trajectory optimization.\n\n    Attributes:\n        name (str): Name identifier for the variable\n        _shape (tuple[int, ...]): Shape of the variable as a tuple (typically 1D)\n        _slice (slice | None): Internal slice information for variable indexing\n        _min (np.ndarray | None): Minimum bounds for each element of the variable\n        _max (np.ndarray | None): Maximum bounds for each element of the variable\n        _guess (np.ndarray | None): Initial guess for the variable trajectory (n_points, n_vars)\n\n    Example:\n            # Typically, use State or Control instead of Variable directly:\n            pos = openscvx.State(\"pos\", shape=(3,))\n            u = openscvx.Control(\"u\", shape=(2,))\n    \"\"\"\n\n    def __init__(self, name, shape):\n        \"\"\"Initialize a Variable object.\n\n        Args:\n            name: Name identifier for the variable\n            shape: Shape of the variable as a tuple (typically 1D like (3,) for 3D vector)\n        \"\"\"\n        super().__init__(name, shape)\n        self._slice = None\n        self._min = None\n        self._max = None\n        self._guess = None\n\n    def __repr__(self):\n        return f\"Var({self.name!r})\"\n\n    def _hash_into(self, hasher: \"hashlib._Hash\") -&gt; None:\n        \"\"\"Hash Variable using its slice (canonical position, name-invariant).\n\n        Instead of hashing the variable name, we hash the _slice attribute\n        which represents the variable's canonical position in the unified\n        state/control vector. This ensures that two problems with the same\n        structure but different variable names produce the same hash.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(self.__class__.__name__.encode())\n        hasher.update(str(self._shape).encode())\n        # Hash the slice (canonical position) - this is name-invariant\n        if self._slice is not None:\n            hasher.update(f\"slice:{self._slice.start}:{self._slice.stop}\".encode())\n        else:\n            raise RuntimeError(\n                f\"Cannot hash Variable '{self.name}' without _slice attribute. \"\n                \"Hashing should only be called on preprocessed problems where \"\n                \"all Variables have been assigned canonical slice positions.\"\n            )\n\n    @property\n    def min(self):\n        \"\"\"Get the minimum bounds (lower bounds) for the variable.\n\n        Returns:\n            Array of minimum values for each element of the variable, or None if unbounded.\n\n        Example:\n                pos = Variable(\"pos\", shape=(3,))\n                pos.min = [-10, -10, 0]\n                print(pos.min)  # [-10., -10., 0.]\n        \"\"\"\n        return self._min\n\n    @min.setter\n    def min(self, arr):\n        \"\"\"Set the minimum bounds (lower bounds) for the variable.\n\n        The bounds are applied element-wise to each component of the variable.\n        Scalars will be broadcast to match the variable shape.\n\n        Args:\n            arr: Array of minimum values, must be broadcastable to shape (n,)\n                where n is the variable dimension\n\n        Raises:\n            ValueError: If the shape of arr doesn't match the variable shape\n\n        Example:\n                pos = Variable(\"pos\", shape=(3,))\n                pos.min = -10  # Broadcasts to [-10, -10, -10]\n                pos.min = [-5, -10, 0]  # Element-wise bounds\n        \"\"\"\n        arr = np.asarray(arr, dtype=float)\n        if arr.ndim != 1 or arr.shape[0] != self.shape[0]:\n            raise ValueError(\n                f\"{self.__class__.__name__} min must be 1D with shape ({self.shape[0]},), got\"\n                f\" {arr.shape}\"\n            )\n        self._min = arr\n\n    @property\n    def max(self):\n        \"\"\"Get the maximum bounds (upper bounds) for the variable.\n\n        Returns:\n            Array of maximum values for each element of the variable, or None if unbounded.\n\n        Example:\n                vel = Variable(\"vel\", shape=(3,))\n                vel.max = [10, 10, 5]\n                print(vel.max)  # [10., 10., 5.]\n        \"\"\"\n        return self._max\n\n    @max.setter\n    def max(self, arr):\n        \"\"\"Set the maximum bounds (upper bounds) for the variable.\n\n        The bounds are applied element-wise to each component of the variable.\n        Scalars will be broadcast to match the variable shape.\n\n        Args:\n            arr: Array of maximum values, must be broadcastable to shape (n,)\n                where n is the variable dimension\n\n        Raises:\n            ValueError: If the shape of arr doesn't match the variable shape\n\n        Example:\n                vel = Variable(\"vel\", shape=(3,))\n                vel.max = 10  # Broadcasts to [10, 10, 10]\n                vel.max = [15, 10, 5]  # Element-wise bounds\n        \"\"\"\n        arr = np.asarray(arr, dtype=float)\n        if arr.ndim != 1 or arr.shape[0] != self.shape[0]:\n            raise ValueError(\n                f\"{self.__class__.__name__} max must be 1D with shape ({self.shape[0]},), got\"\n                f\" {arr.shape}\"\n            )\n        self._max = arr\n\n    @property\n    def slice(self):\n        \"\"\"Get the slice indexing this variable in the unified state/control vector.\n\n        After preprocessing, each variable is assigned a canonical position in the\n        unified optimization vector. This property returns the slice object that\n        extracts this variable's values from the unified vector.\n\n        This is particularly useful for expert users working with byof (bring-your-own\n        functions) who need to manually index into the unified x and u vectors.\n\n        Returns:\n            slice: Slice object for indexing into unified vector, or None if the\n                variable hasn't been preprocessed yet.\n\n        Example:\n                velocity = ox.State(\"velocity\", shape=(3,))\n                # ... after Problem construction ...\n                print(velocity.slice)  # slice(2, 5) (for example)\n\n                # Use in byof functions\n                def my_constraint(x, u, node, params):\n                    vel = x[velocity.slice]  # Extract velocity from unified state\n                    return jnp.sum(vel**2) - 100  # |v|^2 &lt;= 100\n        \"\"\"\n        return self._slice\n\n    @property\n    def guess(self):\n        \"\"\"Get the initial guess for the variable trajectory.\n\n        The guess provides a starting point for the optimizer. A good initial guess\n        can significantly improve convergence speed and help avoid local minima.\n\n        Returns:\n            2D array of shape (n_points, n_vars) representing the variable trajectory\n            over time, or None if no guess is provided.\n\n        Example:\n                x = Variable(\"x\", shape=(2,))\n                # Linear interpolation from [0,0] to [10,10] over 50 points\n                x.guess = np.linspace([0, 0], [10, 10], 50)\n                print(x.guess.shape)  # (50, 2)\n        \"\"\"\n        return self._guess\n\n    @guess.setter\n    def guess(self, arr):\n        \"\"\"Set the initial guess for the variable trajectory.\n\n        The guess should be a 2D array where each row represents the variable value\n        at a particular time point or trajectory node.\n\n        Args:\n            arr: 2D array of shape (n_points, n_vars) where n_vars matches the\n                variable dimension. Can be fewer points than the final trajectory -\n                the solver will interpolate as needed.\n\n        Raises:\n            ValueError: If the array is not 2D or if the second dimension doesn't\n                match the variable dimension\n\n        Example:\n                pos = Variable(\"pos\", shape=(3,))\n                # Create a straight-line trajectory from origin to target\n                n_points = 50\n                pos.guess = np.linspace([0, 0, 0], [10, 5, 3], n_points)\n        \"\"\"\n        arr = np.asarray(arr, dtype=float)\n        if arr.ndim != 2:\n            raise ValueError(\n                f\"Guess must be a 2D array of shape (n_guess_points, {self.shape[0]}), got shape\"\n                f\" {arr.shape}\"\n            )\n        if arr.shape[1] != self.shape[0]:\n            raise ValueError(\n                f\"Guess must have second dimension equal to variable dimension {self.shape[0]}, got\"\n                f\" {arr.shape[1]}\"\n            )\n        self._guess = arr\n\n    def append(self, other=None, *, min=-np.inf, max=np.inf, guess=0.0):\n        \"\"\"Append a new dimension to this variable or merge with another variable.\n\n        This method extends the variable's dimension by either:\n        1. Appending another Variable object (concatenating their dimensions)\n        2. Adding a single new scalar dimension with specified bounds and guess\n\n        The bounds and guesses of both variables are concatenated appropriately.\n\n        Args:\n            other: Another Variable object to append. If None, adds a single scalar\n                dimension with the specified min/max/guess values.\n            min: Minimum bound for the new dimension (only used if other is None).\n                Defaults to -np.inf (unbounded below).\n            max: Maximum bound for the new dimension (only used if other is None).\n                Defaults to np.inf (unbounded above).\n            guess: Initial guess value for the new dimension (only used if other is None).\n                Defaults to 0.0.\n\n        Example:\n            Create a 2D variable and extend it to 3D:\n\n                pos_xy = Variable(\"pos\", shape=(2,))\n                pos_xy.min = [-10, -10]\n                pos_xy.max = [10, 10]\n                pos_xy.append(min=0, max=100)  # Add z dimension\n                print(pos_xy.shape)  # (3,)\n                print(pos_xy.min)  # [-10., -10., 0.]\n                print(pos_xy.max)  # [10., 10., 100.]\n\n            Merge two variables:\n\n                pos = Variable(\"pos\", shape=(3,))\n                vel = Variable(\"vel\", shape=(3,))\n                pos.append(vel)  # Now pos has shape (6,)\n        \"\"\"\n\n        def process_array(val, is_guess=False):\n            \"\"\"Process input array to ensure correct shape and type.\n\n            Args:\n                val: Input value to process\n                is_guess: Whether the value is a guess array\n\n            Returns:\n                Processed array with correct shape and type\n            \"\"\"\n            arr = np.asarray(val, dtype=float)\n            if is_guess:\n                return np.atleast_2d(arr)\n            return np.atleast_1d(arr)\n\n        if isinstance(other, Variable):\n            self._shape = (self.shape[0] + other.shape[0],)\n\n            if self._min is not None and other._min is not None:\n                self._min = np.concatenate([self._min, process_array(other._min)], axis=0)\n\n            if self._max is not None and other._max is not None:\n                self._max = np.concatenate([self._max, process_array(other._max)], axis=0)\n\n            if self._guess is not None and other._guess is not None:\n                self._guess = np.concatenate(\n                    [self._guess, process_array(other._guess, is_guess=True)], axis=1\n                )\n\n        else:\n            self._shape = (self.shape[0] + 1,)\n\n            if self._min is not None:\n                self._min = np.concatenate([self._min, process_array(min)], axis=0)\n\n            if self._max is not None:\n                self._max = np.concatenate([self._max, process_array(max)], axis=0)\n\n            if self._guess is not None:\n                guess_arr = process_array(guess, is_guess=True)\n                if guess_arr.shape[1] != 1:\n                    guess_arr = guess_arr.T\n                self._guess = np.concatenate([self._guess, guess_arr], axis=1)\n</code></pre>"},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable--typically-use-state-or-control-instead-of-variable-directly","title":"Typically, use State or Control instead of Variable directly:","text":"<p>pos = openscvx.State(\"pos\", shape=(3,)) u = openscvx.Control(\"u\", shape=(2,))</p>"},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable.guess","title":"<code>guess</code>  <code>property</code> <code>writable</code>","text":"<p>Get the initial guess for the variable trajectory.</p> <p>The guess provides a starting point for the optimizer. A good initial guess can significantly improve convergence speed and help avoid local minima.</p> <p>Returns:</p> Type Description <p>2D array of shape (n_points, n_vars) representing the variable trajectory</p> <p>over time, or None if no guess is provided.</p> Example <p>x = Variable(\"x\", shape=(2,))</p>"},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable.guess--linear-interpolation-from-00-to-1010-over-50-points","title":"Linear interpolation from [0,0] to [10,10] over 50 points","text":"<p>x.guess = np.linspace([0, 0], [10, 10], 50) print(x.guess.shape)  # (50, 2)</p>"},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable.max","title":"<code>max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the maximum bounds (upper bounds) for the variable.</p> <p>Returns:</p> Type Description <p>Array of maximum values for each element of the variable, or None if unbounded.</p> Example <p>vel = Variable(\"vel\", shape=(3,)) vel.max = [10, 10, 5] print(vel.max)  # [10., 10., 5.]</p>"},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable.min","title":"<code>min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the minimum bounds (lower bounds) for the variable.</p> <p>Returns:</p> Type Description <p>Array of minimum values for each element of the variable, or None if unbounded.</p> Example <p>pos = Variable(\"pos\", shape=(3,)) pos.min = [-10, -10, 0] print(pos.min)  # [-10., -10., 0.]</p>"},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable.slice","title":"<code>slice</code>  <code>property</code>","text":"<p>Get the slice indexing this variable in the unified state/control vector.</p> <p>After preprocessing, each variable is assigned a canonical position in the unified optimization vector. This property returns the slice object that extracts this variable's values from the unified vector.</p> <p>This is particularly useful for expert users working with byof (bring-your-own functions) who need to manually index into the unified x and u vectors.</p> <p>Returns:</p> Name Type Description <code>slice</code> <p>Slice object for indexing into unified vector, or None if the variable hasn't been preprocessed yet.</p> Example <p>velocity = ox.State(\"velocity\", shape=(3,))</p>"},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable.slice--after-problem-construction","title":"... after Problem construction ...","text":"<p>print(velocity.slice)  # slice(2, 5) (for example)</p>"},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable.slice--use-in-byof-functions","title":"Use in byof functions","text":"<p>def my_constraint(x, u, node, params):     vel = x[velocity.slice]  # Extract velocity from unified state     return jnp.sum(vel**2) - 100  # |v|^2 &lt;= 100</p>"},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable.__init__","title":"<code>__init__(name, shape)</code>","text":"<p>Initialize a Variable object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name identifier for the variable</p> required <code>shape</code> <p>Shape of the variable as a tuple (typically 1D like (3,) for 3D vector)</p> required Source code in <code>openscvx/symbolic/expr/variable.py</code> <pre><code>def __init__(self, name, shape):\n    \"\"\"Initialize a Variable object.\n\n    Args:\n        name: Name identifier for the variable\n        shape: Shape of the variable as a tuple (typically 1D like (3,) for 3D vector)\n    \"\"\"\n    super().__init__(name, shape)\n    self._slice = None\n    self._min = None\n    self._max = None\n    self._guess = None\n</code></pre>"},{"location":"reference/symbolic/expr/variable/#openscvx.symbolic.expr.variable.Variable.append","title":"<code>append(other=None, *, min=-np.inf, max=np.inf, guess=0.0)</code>","text":"<p>Append a new dimension to this variable or merge with another variable.</p> <p>This method extends the variable's dimension by either: 1. Appending another Variable object (concatenating their dimensions) 2. Adding a single new scalar dimension with specified bounds and guess</p> <p>The bounds and guesses of both variables are concatenated appropriately.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>Another Variable object to append. If None, adds a single scalar dimension with the specified min/max/guess values.</p> <code>None</code> <code>min</code> <p>Minimum bound for the new dimension (only used if other is None). Defaults to -np.inf (unbounded below).</p> <code>-inf</code> <code>max</code> <p>Maximum bound for the new dimension (only used if other is None). Defaults to np.inf (unbounded above).</p> <code>inf</code> <code>guess</code> <p>Initial guess value for the new dimension (only used if other is None). Defaults to 0.0.</p> <code>0.0</code> Example <p>Create a 2D variable and extend it to 3D:</p> <pre><code>pos_xy = Variable(\"pos\", shape=(2,))\npos_xy.min = [-10, -10]\npos_xy.max = [10, 10]\npos_xy.append(min=0, max=100)  # Add z dimension\nprint(pos_xy.shape)  # (3,)\nprint(pos_xy.min)  # [-10., -10., 0.]\nprint(pos_xy.max)  # [10., 10., 100.]\n</code></pre> <p>Merge two variables:</p> <pre><code>pos = Variable(\"pos\", shape=(3,))\nvel = Variable(\"vel\", shape=(3,))\npos.append(vel)  # Now pos has shape (6,)\n</code></pre> Source code in <code>openscvx/symbolic/expr/variable.py</code> <pre><code>def append(self, other=None, *, min=-np.inf, max=np.inf, guess=0.0):\n    \"\"\"Append a new dimension to this variable or merge with another variable.\n\n    This method extends the variable's dimension by either:\n    1. Appending another Variable object (concatenating their dimensions)\n    2. Adding a single new scalar dimension with specified bounds and guess\n\n    The bounds and guesses of both variables are concatenated appropriately.\n\n    Args:\n        other: Another Variable object to append. If None, adds a single scalar\n            dimension with the specified min/max/guess values.\n        min: Minimum bound for the new dimension (only used if other is None).\n            Defaults to -np.inf (unbounded below).\n        max: Maximum bound for the new dimension (only used if other is None).\n            Defaults to np.inf (unbounded above).\n        guess: Initial guess value for the new dimension (only used if other is None).\n            Defaults to 0.0.\n\n    Example:\n        Create a 2D variable and extend it to 3D:\n\n            pos_xy = Variable(\"pos\", shape=(2,))\n            pos_xy.min = [-10, -10]\n            pos_xy.max = [10, 10]\n            pos_xy.append(min=0, max=100)  # Add z dimension\n            print(pos_xy.shape)  # (3,)\n            print(pos_xy.min)  # [-10., -10., 0.]\n            print(pos_xy.max)  # [10., 10., 100.]\n\n        Merge two variables:\n\n            pos = Variable(\"pos\", shape=(3,))\n            vel = Variable(\"vel\", shape=(3,))\n            pos.append(vel)  # Now pos has shape (6,)\n    \"\"\"\n\n    def process_array(val, is_guess=False):\n        \"\"\"Process input array to ensure correct shape and type.\n\n        Args:\n            val: Input value to process\n            is_guess: Whether the value is a guess array\n\n        Returns:\n            Processed array with correct shape and type\n        \"\"\"\n        arr = np.asarray(val, dtype=float)\n        if is_guess:\n            return np.atleast_2d(arr)\n        return np.atleast_1d(arr)\n\n    if isinstance(other, Variable):\n        self._shape = (self.shape[0] + other.shape[0],)\n\n        if self._min is not None and other._min is not None:\n            self._min = np.concatenate([self._min, process_array(other._min)], axis=0)\n\n        if self._max is not None and other._max is not None:\n            self._max = np.concatenate([self._max, process_array(other._max)], axis=0)\n\n        if self._guess is not None and other._guess is not None:\n            self._guess = np.concatenate(\n                [self._guess, process_array(other._guess, is_guess=True)], axis=1\n            )\n\n    else:\n        self._shape = (self.shape[0] + 1,)\n\n        if self._min is not None:\n            self._min = np.concatenate([self._min, process_array(min)], axis=0)\n\n        if self._max is not None:\n            self._max = np.concatenate([self._max, process_array(max)], axis=0)\n\n        if self._guess is not None:\n            guess_arr = process_array(guess, is_guess=True)\n            if guess_arr.shape[1] != 1:\n                guess_arr = guess_arr.T\n            self._guess = np.concatenate([self._guess, guess_arr], axis=1)\n</code></pre>"},{"location":"reference/symbolic/expr/vmap/","title":"vmap","text":"<p>Vmap expression for data-parallel operations.</p> <p>This module provides symbolic support for JAX's vmap (vectorized map) operation, enabling efficient data-parallel computations over batched data within the symbolic expression framework.</p> <p>Vmap supports two modes based on the type of <code>batch</code>:</p> <ul> <li>Constant/array: Values baked into the compiled function at trace time,   equivalent to closure-captured values in BYOF. Use for static data.</li> <li>Parameter: Values looked up from params dict at runtime, allowing   updates between SCP iterations. Use for data that may change.</li> </ul> Example <p>Compute distances from a position to multiple reference points::</p> <pre><code>import openscvx as ox\nimport numpy as np\n\nposition = ox.State(\"position\", shape=(3,))\ninit_poses = np.random.randn(10, 3)  # 10 reference points\n\n# Option 1: Baked-in data (closure-equivalent)\ndistances = ox.Vmap(\n    lambda pose: ox.linalg.Norm(position - pose),\n    batch=init_poses  # or batch=ox.Constant(init_poses)\n)\n\n# Option 2: Runtime-updateable Parameter\nrefs = ox.Parameter(\"refs\", shape=(10, 3), value=init_poses)\ndistances = ox.Vmap(\n    lambda pose: ox.linalg.Norm(position - pose),\n    batch=refs\n)\n</code></pre>"},{"location":"reference/symbolic/expr/vmap/#openscvx.symbolic.expr.vmap.Vmap","title":"<code>Vmap</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Vectorized map over batched data in symbolic expressions.</p> <p>Vmap enables data-parallel operations by applying a symbolic expression to each element of a batched array. This is the symbolic equivalent of JAX's jax.vmap, allowing efficient vectorized computation without explicit loops.</p> <p>The expression is defined via a lambda that receives a Placeholder representing a single element from the batch. During lowering, this becomes a jax.vmap call.</p> <p>The behavior depends on the type of <code>batch</code>:</p> <ul> <li>numpy array or Constant: Data is baked into the compiled function   at trace time, equivalent to closure-captured values in BYOF.</li> <li>Parameter: Data is looked up from the params dict at runtime,   allowing the same compiled code to be reused with different values.</li> </ul> <p>Attributes:</p> Name Type Description <code>_batch</code> <p>The data source (Constant or Parameter)</p> <code>_axis</code> <code>int</code> <p>The axis to vmap over (default: 0)</p> <code>_placeholder</code> <code>Placeholder</code> <p>The placeholder used in the expression</p> <code>_child</code> <code>Expr</code> <p>The expression tree built from the user's lambda</p> <code>_is_parameter</code> <code>bool</code> <p>Whether _batch is a Parameter (runtime lookup)</p> Example <p>Compute distances to multiple reference points (baked-in)::</p> <pre><code>position = ox.State(\"position\", shape=(3,))\ninit_poses = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n\ndistances = ox.Vmap(\n    lambda pose: ox.linalg.Norm(position - pose),\n    batch=init_poses\n)\n# distances has shape (3,)\n</code></pre> <p>With runtime-updateable Parameter::</p> <pre><code>refs = ox.Parameter(\"refs\", shape=(10, 3), value=init_poses)\ndist_state = ox.State(\"dist_state\", shape=(10,))\n\ndynamics[\"dist_state\"] = ox.Vmap(\n    lambda pose: ox.linalg.Norm(position - pose),\n    batch=refs\n)\n\n# Later, change the parameter value without recompiling:\nproblem.parameters[\"refs\"] = new_poses\n</code></pre> Note <ul> <li>For static data that won't change, pass a numpy array or Constant   to get closure-equivalent behavior (numerically identical to BYOF).</li> <li>For data that needs to be updated between iterations, use Parameter.</li> </ul> <p>Prefer Constants over Parameters</p> <p>Use a raw numpy array or Constant unless you specifically need to update the vmap data between solves without recompiling.</p> <p>Using a Parameter (runtime lookup) may produce different numerical results compared to using a Constant (baked-in), even when the underlying data is identical. This can manifest as:</p> <ul> <li>Different SCP iteration counts</li> <li>Different convergence behavior</li> <li>In unlucky cases, convergence to a different local solution</li> </ul> <p>This is likely due to JAX/XLA trace and compilation differences between the two code paths. When data is baked in, JAX sees concrete values at trace time. When data is looked up from a params dict at runtime, JAX traces through the dictionary access, potentially producing different XLA compilation or floating-point operation ordering.</p> Source code in <code>openscvx/symbolic/expr/vmap.py</code> <pre><code>class Vmap(Expr):\n    \"\"\"Vectorized map over batched data in symbolic expressions.\n\n    Vmap enables data-parallel operations by applying a symbolic expression\n    to each element of a batched array. This is the symbolic equivalent of\n    JAX's jax.vmap, allowing efficient vectorized computation without\n    explicit loops.\n\n    The expression is defined via a lambda that receives a Placeholder\n    representing a single element from the batch. During lowering, this\n    becomes a jax.vmap call.\n\n    The behavior depends on the type of `batch`:\n\n    - **numpy array or Constant**: Data is baked into the compiled function\n      at trace time, equivalent to closure-captured values in BYOF.\n    - **Parameter**: Data is looked up from the params dict at runtime,\n      allowing the same compiled code to be reused with different values.\n\n    Attributes:\n        _batch: The data source (Constant or Parameter)\n        _axis (int): The axis to vmap over (default: 0)\n        _placeholder (Placeholder): The placeholder used in the expression\n        _child (Expr): The expression tree built from the user's lambda\n        _is_parameter (bool): Whether _batch is a Parameter (runtime lookup)\n\n    Example:\n        Compute distances to multiple reference points (baked-in)::\n\n            position = ox.State(\"position\", shape=(3,))\n            init_poses = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n\n            distances = ox.Vmap(\n                lambda pose: ox.linalg.Norm(position - pose),\n                batch=init_poses\n            )\n            # distances has shape (3,)\n\n        With runtime-updateable Parameter::\n\n            refs = ox.Parameter(\"refs\", shape=(10, 3), value=init_poses)\n            dist_state = ox.State(\"dist_state\", shape=(10,))\n\n            dynamics[\"dist_state\"] = ox.Vmap(\n                lambda pose: ox.linalg.Norm(position - pose),\n                batch=refs\n            )\n\n            # Later, change the parameter value without recompiling:\n            problem.parameters[\"refs\"] = new_poses\n\n    Note:\n        - For static data that won't change, pass a numpy array or Constant\n          to get closure-equivalent behavior (numerically identical to BYOF).\n        - For data that needs to be updated between iterations, use Parameter.\n\n    !!! warning \"Prefer Constants over Parameters\"\n        **Use a raw numpy array or Constant unless you specifically need to\n        update the vmap data between solves without recompiling.**\n\n        Using a Parameter (runtime lookup) may produce **different numerical\n        results** compared to using a Constant (baked-in), even when the\n        underlying data is identical. This can manifest as:\n\n        - Different SCP iteration counts\n        - Different convergence behavior\n        - In unlucky cases, convergence to a different local solution\n\n        This is likely due to JAX/XLA trace and compilation differences between\n        the two code paths. When data is baked in, JAX sees concrete values at\n        trace time. When data is looked up from a params dict at runtime, JAX\n        traces through the dictionary access, potentially producing different\n        XLA compilation or floating-point operation ordering.\n    \"\"\"\n\n    def __init__(\n        self,\n        fn: Callable[[_Placeholder], Expr],\n        batch: Union[np.ndarray, Constant, \"Parameter\"],\n        axis: int = 0,\n    ):\n        \"\"\"Initialize a Vmap expression.\n\n        Args:\n            fn: A callable (typically a lambda) that takes a Placeholder and\n                returns a symbolic expression. The Placeholder represents a\n                single element from the batched data.\n            batch: The batched data to vmap over. Can be:\n                  - numpy array: baked into compiled function (closure-equivalent)\n                  - Constant: baked into compiled function (closure-equivalent)\n                  - Parameter: looked up from params dict at runtime\n            axis: The axis to vmap over. Default is 0 (first axis).\n\n        Example:\n            Baked-in data::\n\n                ox.Vmap(lambda x: ox.linalg.Norm(x), batch=points)\n\n            With Parameter::\n\n                refs = ox.Parameter(\"refs\", shape=(10, 3), value=points)\n                ox.Vmap(lambda ref: ox.linalg.Norm(position - ref), batch=refs)\n        \"\"\"\n        from .expr import Parameter\n\n        # Normalize input: wrap raw arrays in Constant\n        if isinstance(batch, np.ndarray):\n            batch = Constant(batch)\n        elif not isinstance(batch, (Constant, Parameter)):\n            # Try to convert to array then Constant\n            batch = Constant(np.asarray(batch))\n\n        self._batch = batch\n        self._axis = axis\n        self._is_parameter = isinstance(batch, Parameter)\n\n        # Get shape from the appropriate source\n        if self._is_parameter:\n            batch_shape = batch.shape\n        else:\n            # Constant\n            batch_shape = batch.value.shape\n\n        # Compute per-element shape by removing the vmap axis\n        if axis &lt; 0 or axis &gt;= len(batch_shape):\n            raise ValueError(f\"Vmap axis {axis} out of bounds for data with shape {batch_shape}\")\n        per_elem_shape = tuple(s for i, s in enumerate(batch_shape) if i != axis)\n\n        # Create placeholder and build expression tree\n        self._placeholder = _Placeholder(shape=per_elem_shape)\n        self._child = fn(self._placeholder)\n\n    @property\n    def batch(self):\n        \"\"\"The batched data source being vmapped over.\"\"\"\n        return self._batch\n\n    @property\n    def axis(self) -&gt; int:\n        \"\"\"The axis being vmapped over.\"\"\"\n        return self._axis\n\n    @property\n    def placeholder(self) -&gt; _Placeholder:\n        \"\"\"The placeholder used in the inner expression.\"\"\"\n        return self._placeholder\n\n    @property\n    def is_parameter(self) -&gt; bool:\n        \"\"\"Whether the data source is a Parameter (runtime lookup).\"\"\"\n        return self._is_parameter\n\n    def children(self):\n        \"\"\"Return child expressions.\n\n        Returns:\n            list: The vmapped expression and (if Parameter) the data source.\n                  Parameter is included so traverse() finds it for parameter\n                  collection in preprocessing.\n        \"\"\"\n        if self._is_parameter:\n            return [self._child, self._batch]\n        else:\n            return [self._child]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        \"\"\"Canonicalize by canonicalizing the child expression.\n\n        Returns:\n            Vmap: A new Vmap with canonicalized child expression\n        \"\"\"\n        canon_child = self._child.canonicalize()\n        # Create new Vmap with the canonicalized child\n        new_vmap = Vmap.__new__(Vmap)\n        new_vmap._batch = self._batch\n        new_vmap._axis = self._axis\n        new_vmap._placeholder = self._placeholder\n        new_vmap._child = canon_child\n        new_vmap._is_parameter = self._is_parameter\n        return new_vmap\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Compute the output shape of the vmapped expression.\n\n        The output shape is (batch_size,) + inner_shape, where batch_size\n        is the size of the vmap axis and inner_shape is the shape of the\n        child expression.\n\n        Returns:\n            tuple: Output shape after vmapping\n\n        Example:\n            If data has shape (10, 3) and the inner expression produces a\n            scalar (shape ()), the output shape is (10,).\n        \"\"\"\n        inner_shape = self._child.check_shape()\n\n        if self._is_parameter:\n            batch_size = self._batch.shape[self._axis]\n        else:\n            batch_size = self._batch.value.shape[self._axis]\n\n        return (batch_size,) + inner_shape\n\n    def _hash_into(self, hasher):\n        \"\"\"Hash Vmap including data source, axis, and child expression.\n\n        Args:\n            hasher: A hashlib hash object to update\n        \"\"\"\n        hasher.update(b\"Vmap\")\n        hasher.update(str(self._axis).encode())\n        hasher.update(str(self._is_parameter).encode())\n\n        if self._is_parameter:\n            # Hash Parameter by name and shape (not value - value can change)\n            self._batch._hash_into(hasher)\n        else:\n            # Hash Constant by value (baked in, won't change)\n            hasher.update(self._batch.value.tobytes())\n\n        self._child._hash_into(hasher)\n\n    def __repr__(self):\n        \"\"\"String representation of the Vmap expression.\n\n        Returns:\n            str: Description of the Vmap\n        \"\"\"\n        if self._is_parameter:\n            return f\"Vmap(batch=Parameter({self._batch.name!r}), axis={self._axis})\"\n        else:\n            return f\"Vmap(batch=Constant(shape={self._batch.value.shape}), axis={self._axis})\"\n</code></pre>"},{"location":"reference/symbolic/expr/vmap/#openscvx.symbolic.expr.vmap.Vmap.axis","title":"<code>axis: int</code>  <code>property</code>","text":"<p>The axis being vmapped over.</p>"},{"location":"reference/symbolic/expr/vmap/#openscvx.symbolic.expr.vmap.Vmap.batch","title":"<code>batch</code>  <code>property</code>","text":"<p>The batched data source being vmapped over.</p>"},{"location":"reference/symbolic/expr/vmap/#openscvx.symbolic.expr.vmap.Vmap.is_parameter","title":"<code>is_parameter: bool</code>  <code>property</code>","text":"<p>Whether the data source is a Parameter (runtime lookup).</p>"},{"location":"reference/symbolic/expr/vmap/#openscvx.symbolic.expr.vmap.Vmap.placeholder","title":"<code>placeholder: _Placeholder</code>  <code>property</code>","text":"<p>The placeholder used in the inner expression.</p>"},{"location":"reference/symbolic/expr/vmap/#openscvx.symbolic.expr.vmap.Vmap.__init__","title":"<code>__init__(fn: Callable[[_Placeholder], Expr], batch: Union[np.ndarray, Constant, Parameter], axis: int = 0)</code>","text":"<p>Initialize a Vmap expression.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[[_Placeholder], Expr]</code> <p>A callable (typically a lambda) that takes a Placeholder and returns a symbolic expression. The Placeholder represents a single element from the batched data.</p> required <code>batch</code> <code>Union[ndarray, Constant, Parameter]</code> <p>The batched data to vmap over. Can be:   - numpy array: baked into compiled function (closure-equivalent)   - Constant: baked into compiled function (closure-equivalent)   - Parameter: looked up from params dict at runtime</p> required <code>axis</code> <code>int</code> <p>The axis to vmap over. Default is 0 (first axis).</p> <code>0</code> Example <p>Baked-in data::</p> <pre><code>ox.Vmap(lambda x: ox.linalg.Norm(x), batch=points)\n</code></pre> <p>With Parameter::</p> <pre><code>refs = ox.Parameter(\"refs\", shape=(10, 3), value=points)\nox.Vmap(lambda ref: ox.linalg.Norm(position - ref), batch=refs)\n</code></pre> Source code in <code>openscvx/symbolic/expr/vmap.py</code> <pre><code>def __init__(\n    self,\n    fn: Callable[[_Placeholder], Expr],\n    batch: Union[np.ndarray, Constant, \"Parameter\"],\n    axis: int = 0,\n):\n    \"\"\"Initialize a Vmap expression.\n\n    Args:\n        fn: A callable (typically a lambda) that takes a Placeholder and\n            returns a symbolic expression. The Placeholder represents a\n            single element from the batched data.\n        batch: The batched data to vmap over. Can be:\n              - numpy array: baked into compiled function (closure-equivalent)\n              - Constant: baked into compiled function (closure-equivalent)\n              - Parameter: looked up from params dict at runtime\n        axis: The axis to vmap over. Default is 0 (first axis).\n\n    Example:\n        Baked-in data::\n\n            ox.Vmap(lambda x: ox.linalg.Norm(x), batch=points)\n\n        With Parameter::\n\n            refs = ox.Parameter(\"refs\", shape=(10, 3), value=points)\n            ox.Vmap(lambda ref: ox.linalg.Norm(position - ref), batch=refs)\n    \"\"\"\n    from .expr import Parameter\n\n    # Normalize input: wrap raw arrays in Constant\n    if isinstance(batch, np.ndarray):\n        batch = Constant(batch)\n    elif not isinstance(batch, (Constant, Parameter)):\n        # Try to convert to array then Constant\n        batch = Constant(np.asarray(batch))\n\n    self._batch = batch\n    self._axis = axis\n    self._is_parameter = isinstance(batch, Parameter)\n\n    # Get shape from the appropriate source\n    if self._is_parameter:\n        batch_shape = batch.shape\n    else:\n        # Constant\n        batch_shape = batch.value.shape\n\n    # Compute per-element shape by removing the vmap axis\n    if axis &lt; 0 or axis &gt;= len(batch_shape):\n        raise ValueError(f\"Vmap axis {axis} out of bounds for data with shape {batch_shape}\")\n    per_elem_shape = tuple(s for i, s in enumerate(batch_shape) if i != axis)\n\n    # Create placeholder and build expression tree\n    self._placeholder = _Placeholder(shape=per_elem_shape)\n    self._child = fn(self._placeholder)\n</code></pre>"},{"location":"reference/symbolic/expr/vmap/#openscvx.symbolic.expr.vmap.Vmap.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize by canonicalizing the child expression.</p> <p>Returns:</p> Name Type Description <code>Vmap</code> <code>Expr</code> <p>A new Vmap with canonicalized child expression</p> Source code in <code>openscvx/symbolic/expr/vmap.py</code> <pre><code>def canonicalize(self) -&gt; \"Expr\":\n    \"\"\"Canonicalize by canonicalizing the child expression.\n\n    Returns:\n        Vmap: A new Vmap with canonicalized child expression\n    \"\"\"\n    canon_child = self._child.canonicalize()\n    # Create new Vmap with the canonicalized child\n    new_vmap = Vmap.__new__(Vmap)\n    new_vmap._batch = self._batch\n    new_vmap._axis = self._axis\n    new_vmap._placeholder = self._placeholder\n    new_vmap._child = canon_child\n    new_vmap._is_parameter = self._is_parameter\n    return new_vmap\n</code></pre>"},{"location":"reference/symbolic/expr/vmap/#openscvx.symbolic.expr.vmap.Vmap.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Compute the output shape of the vmapped expression.</p> <p>The output shape is (batch_size,) + inner_shape, where batch_size is the size of the vmap axis and inner_shape is the shape of the child expression.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Output shape after vmapping</p> Example <p>If data has shape (10, 3) and the inner expression produces a scalar (shape ()), the output shape is (10,).</p> Source code in <code>openscvx/symbolic/expr/vmap.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Compute the output shape of the vmapped expression.\n\n    The output shape is (batch_size,) + inner_shape, where batch_size\n    is the size of the vmap axis and inner_shape is the shape of the\n    child expression.\n\n    Returns:\n        tuple: Output shape after vmapping\n\n    Example:\n        If data has shape (10, 3) and the inner expression produces a\n        scalar (shape ()), the output shape is (10,).\n    \"\"\"\n    inner_shape = self._child.check_shape()\n\n    if self._is_parameter:\n        batch_size = self._batch.shape[self._axis]\n    else:\n        batch_size = self._batch.value.shape[self._axis]\n\n    return (batch_size,) + inner_shape\n</code></pre>"},{"location":"reference/symbolic/expr/vmap/#openscvx.symbolic.expr.vmap.Vmap.children","title":"<code>children()</code>","text":"<p>Return child expressions.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>The vmapped expression and (if Parameter) the data source.   Parameter is included so traverse() finds it for parameter   collection in preprocessing.</p> Source code in <code>openscvx/symbolic/expr/vmap.py</code> <pre><code>def children(self):\n    \"\"\"Return child expressions.\n\n    Returns:\n        list: The vmapped expression and (if Parameter) the data source.\n              Parameter is included so traverse() finds it for parameter\n              collection in preprocessing.\n    \"\"\"\n    if self._is_parameter:\n        return [self._child, self._batch]\n    else:\n        return [self._child]\n</code></pre>"},{"location":"reference/symbolic/expr/lie/","title":"lie","text":"<p>Lie algebra operations for rigid body dynamics.</p> <p>This module provides symbolic expression nodes for Lie algebra operations commonly used in 6-DOF rigid body dynamics, robotics, and geometric mechanics. These operations enable elegant formulations of Newton-Euler dynamics using spatial vectors (twists and wrenches).</p> <p>The module provides two tiers of functionality:</p> <p>Built-in operators work out of the box and include adjoint/coadjoint operators for dynamics (e.g. <code>Adjoint</code>, <code>AdjointDual</code>) and frame transformations (e.g. <code>SE3Adjoint</code>, <code>SE3AdjointDual</code>).</p> <p>jaxlie-backed operators require <code>pip install openscvx[lie]</code> and provide exponential/logarithm maps for SO(3) and SE(3) groups (e.g. <code>SO3Exp</code>, <code>SO3Log</code>, <code>SE3Exp</code>, <code>SE3Log</code>).</p> Conventions <ul> <li>Twist (spatial velocity): \u03be = [v; \u03c9] where v \u2208 \u211d\u00b3 is linear velocity   and \u03c9 \u2208 \u211d\u00b3 is angular velocity (both in body frame)</li> <li>Wrench (spatial force): F = [f; \u03c4] where f \u2208 \u211d\u00b3 is force and \u03c4 \u2208 \u211d\u00b3   is torque (both in body frame)</li> </ul> Note <p>The twist convention [v; \u03c9] (linear first, angular second) matches jaxlie's SE3 tangent parameterization, so no reordering is needed during lowering.</p> Example <p>Newton-Euler dynamics for a rigid body using the coadjoint operator::</p> <pre><code>import openscvx as ox\n\ntwist = ox.State(\"twist\", shape=(6,))\nM = ox.Parameter(\"M\", shape=(6, 6), value=spatial_inertia)\nwrench = ox.Control(\"wrench\", shape=(6,))\n\nmomentum = M @ twist\nbias_force = ox.lie.AdjointDual(twist, momentum)\ntwist_dot = M_inv @ (wrench - bias_force)\n</code></pre> <p>Product of Exponentials forward kinematics (requires jaxlie)::</p> <pre><code>screw_axis = ox.Constant(np.array([0, 0, 0, 0, 0, 1]))\ntheta = ox.State(\"theta\", shape=(1,))\nT_joint = ox.lie.SE3Exp(screw_axis * theta)  # 4\u00d74 matrix\n</code></pre> References <ul> <li>Murray, Li, Sastry: \"A Mathematical Introduction to Robotic Manipulation\"</li> <li>Featherstone: \"Rigid Body Dynamics Algorithms\"</li> <li>Sola et al.: \"A micro Lie theory for state estimation in robotics\"</li> </ul>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.Adjoint","title":"<code>Adjoint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Adjoint operator ad (Lie bracket) for twist-on-twist action.</p> <p>Computes the adjoint action ad_\u03be\u2081(\u03be\u2082) which represents the Lie bracket [\u03be\u2081, \u03be\u2082] of two twists. This is used for velocity propagation in kinematic chains and acceleration computations.</p> <p>For se(3), given twists \u03be\u2081 = [v\u2081; \u03c9\u2081] and \u03be\u2082 = [v\u2082; \u03c9\u2082]:</p> <pre><code>ad_\u03be\u2081(\u03be\u2082) = [\u03be\u2081, \u03be\u2082] = [ \u03c9\u2081 \u00d7 v\u2082 - \u03c9\u2082 \u00d7 v\u2081 ]\n                        [     \u03c9\u2081 \u00d7 \u03c9\u2082       ]\n</code></pre> <p>Equivalently using the adjoint matrix:</p> <pre><code>ad_\u03be = [ [\u03c9]\u00d7    0   ]\n       [ [v]\u00d7   [\u03c9]\u00d7 ]\n</code></pre> <p>where [\u00b7]\u00d7 denotes the 3x3 skew-symmetric (cross product) matrix.</p> <p>Attributes:</p> Name Type Description <code>twist1</code> <p>First 6D twist vector [v\u2081; \u03c9\u2081]</p> <code>twist2</code> <p>Second 6D twist vector [v\u2082; \u03c9\u2082]</p> Example <p>Compute the Lie bracket of two twists::</p> <pre><code>import openscvx as ox\n\ntwist1 = ox.State(\"twist1\", shape=(6,))\ntwist2 = ox.State(\"twist2\", shape=(6,))\n\nbracket = ox.lie.Adjoint(twist1, twist2)\n</code></pre> <p>Velocity propagation in a kinematic chain::</p> <pre><code># Child link velocity includes parent velocity plus relative motion\n# V_child = Ad_T @ V_parent + joint_twist * q_dot\n</code></pre> Note <p>The adjoint satisfies the Jacobi identity and is antisymmetric: ad_\u03be\u2081(\u03be\u2082) = -ad_\u03be\u2082(\u03be\u2081)</p> See Also <p>AdjointDual: The coadjoint operator for momentum dynamics</p> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>class Adjoint(Expr):\n    \"\"\"Adjoint operator ad (Lie bracket) for twist-on-twist action.\n\n    Computes the adjoint action ad_\u03be\u2081(\u03be\u2082) which represents the Lie bracket\n    [\u03be\u2081, \u03be\u2082] of two twists. This is used for velocity propagation in\n    kinematic chains and acceleration computations.\n\n    For se(3), given twists \u03be\u2081 = [v\u2081; \u03c9\u2081] and \u03be\u2082 = [v\u2082; \u03c9\u2082]:\n\n        ad_\u03be\u2081(\u03be\u2082) = [\u03be\u2081, \u03be\u2082] = [ \u03c9\u2081 \u00d7 v\u2082 - \u03c9\u2082 \u00d7 v\u2081 ]\n                                [     \u03c9\u2081 \u00d7 \u03c9\u2082       ]\n\n    Equivalently using the adjoint matrix:\n\n        ad_\u03be = [ [\u03c9]\u00d7    0   ]\n               [ [v]\u00d7   [\u03c9]\u00d7 ]\n\n    where [\u00b7]\u00d7 denotes the 3x3 skew-symmetric (cross product) matrix.\n\n    Attributes:\n        twist1: First 6D twist vector [v\u2081; \u03c9\u2081]\n        twist2: Second 6D twist vector [v\u2082; \u03c9\u2082]\n\n    Example:\n        Compute the Lie bracket of two twists::\n\n            import openscvx as ox\n\n            twist1 = ox.State(\"twist1\", shape=(6,))\n            twist2 = ox.State(\"twist2\", shape=(6,))\n\n            bracket = ox.lie.Adjoint(twist1, twist2)\n\n        Velocity propagation in a kinematic chain::\n\n            # Child link velocity includes parent velocity plus relative motion\n            # V_child = Ad_T @ V_parent + joint_twist * q_dot\n\n    Note:\n        The adjoint satisfies the Jacobi identity and is antisymmetric:\n        ad_\u03be\u2081(\u03be\u2082) = -ad_\u03be\u2082(\u03be\u2081)\n\n    See Also:\n        AdjointDual: The coadjoint operator for momentum dynamics\n    \"\"\"\n\n    def __init__(self, twist1, twist2):\n        \"\"\"Initialize an adjoint operator.\n\n        Args:\n            twist1: First 6D twist vector [v; \u03c9] with shape (6,)\n            twist2: Second 6D twist vector [v; \u03c9] with shape (6,)\n        \"\"\"\n        self.twist1 = to_expr(twist1)\n        self.twist2 = to_expr(twist2)\n\n    def children(self):\n        return [self.twist1, self.twist2]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        twist1 = self.twist1.canonicalize()\n        twist2 = self.twist2.canonicalize()\n        return Adjoint(twist1, twist2)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that inputs are 6D vectors and return output shape.\n\n        Returns:\n            tuple: Shape (6,) for the resulting Lie bracket\n\n        Raises:\n            ValueError: If either twist does not have shape (6,)\n        \"\"\"\n        twist1_shape = self.twist1.check_shape()\n        twist2_shape = self.twist2.check_shape()\n\n        if twist1_shape != (6,):\n            raise ValueError(f\"Adjoint expects twist1 with shape (6,), got {twist1_shape}\")\n        if twist2_shape != (6,):\n            raise ValueError(f\"Adjoint expects twist2 with shape (6,), got {twist2_shape}\")\n\n        return (6,)\n\n    def __repr__(self):\n        return f\"ad({self.twist1!r}, {self.twist2!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.Adjoint.__init__","title":"<code>__init__(twist1, twist2)</code>","text":"<p>Initialize an adjoint operator.</p> <p>Parameters:</p> Name Type Description Default <code>twist1</code> <p>First 6D twist vector [v; \u03c9] with shape (6,)</p> required <code>twist2</code> <p>Second 6D twist vector [v; \u03c9] with shape (6,)</p> required Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def __init__(self, twist1, twist2):\n    \"\"\"Initialize an adjoint operator.\n\n    Args:\n        twist1: First 6D twist vector [v; \u03c9] with shape (6,)\n        twist2: Second 6D twist vector [v; \u03c9] with shape (6,)\n    \"\"\"\n    self.twist1 = to_expr(twist1)\n    self.twist2 = to_expr(twist2)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.Adjoint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that inputs are 6D vectors and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (6,) for the resulting Lie bracket</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either twist does not have shape (6,)</p> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that inputs are 6D vectors and return output shape.\n\n    Returns:\n        tuple: Shape (6,) for the resulting Lie bracket\n\n    Raises:\n        ValueError: If either twist does not have shape (6,)\n    \"\"\"\n    twist1_shape = self.twist1.check_shape()\n    twist2_shape = self.twist2.check_shape()\n\n    if twist1_shape != (6,):\n        raise ValueError(f\"Adjoint expects twist1 with shape (6,), got {twist1_shape}\")\n    if twist2_shape != (6,):\n        raise ValueError(f\"Adjoint expects twist2 with shape (6,), got {twist2_shape}\")\n\n    return (6,)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.AdjointDual","title":"<code>AdjointDual</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Coadjoint operator ad* for computing Coriolis and centrifugal forces.</p> <p>Computes the coadjoint action ad*_\u03be(\u03bc) which represents the rate of change of momentum due to body rotation. This is the key term in Newton-Euler dynamics that captures Coriolis and centrifugal effects.</p> <p>For se(3), given twist \u03be = [v; \u03c9] and momentum \u03bc = [f; \u03c4]:</p> <pre><code>ad*_\u03be(\u03bc) = [ \u03c9 \u00d7 f + v \u00d7 \u03c4 ]\n           [     \u03c9 \u00d7 \u03c4     ]\n</code></pre> <p>This appears in the Newton-Euler equations as:</p> <pre><code>M @ \u03be_dot = F_ext - ad*_\u03be(M @ \u03be)\n</code></pre> <p>where M is the spatial inertia matrix and F_ext is the external wrench.</p> <p>Attributes:</p> Name Type Description <code>twist</code> <p>6D twist vector [v; \u03c9] (linear velocity, angular velocity)</p> <code>momentum</code> <p>6D momentum vector [p; L] or [f; \u03c4] (linear, angular)</p> Example <p>Compute the bias force (Coriolis + centrifugal) for rigid body dynamics::</p> <pre><code>import openscvx as ox\n\ntwist = ox.State(\"twist\", shape=(6,))\nM = ox.Parameter(\"M\", shape=(6, 6), value=inertia_matrix)\n\nmomentum = M @ twist\nbias_force = ox.lie.AdjointDual(twist, momentum)\n\n# In dynamics: twist_dot = M_inv @ (wrench - bias_force)\n</code></pre> Note <p>The coadjoint is related to the adjoint by: ad*_\u03be = -(ad_\u03be)^T</p> <p>For the special case of pure rotation (v=0) with diagonal inertia, the angular part reduces to the familiar \u03c9 \u00d7 (J @ \u03c9) term.</p> See Also <p>Adjoint: The adjoint operator for twist-on-twist action SSM: 3x3 skew-symmetric matrix for cross products</p> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>class AdjointDual(Expr):\n    \"\"\"Coadjoint operator ad* for computing Coriolis and centrifugal forces.\n\n    Computes the coadjoint action ad*_\u03be(\u03bc) which represents the rate of change\n    of momentum due to body rotation. This is the key term in Newton-Euler\n    dynamics that captures Coriolis and centrifugal effects.\n\n    For se(3), given twist \u03be = [v; \u03c9] and momentum \u03bc = [f; \u03c4]:\n\n        ad*_\u03be(\u03bc) = [ \u03c9 \u00d7 f + v \u00d7 \u03c4 ]\n                   [     \u03c9 \u00d7 \u03c4     ]\n\n    This appears in the Newton-Euler equations as:\n\n        M @ \u03be_dot = F_ext - ad*_\u03be(M @ \u03be)\n\n    where M is the spatial inertia matrix and F_ext is the external wrench.\n\n    Attributes:\n        twist: 6D twist vector [v; \u03c9] (linear velocity, angular velocity)\n        momentum: 6D momentum vector [p; L] or [f; \u03c4] (linear, angular)\n\n    Example:\n        Compute the bias force (Coriolis + centrifugal) for rigid body dynamics::\n\n            import openscvx as ox\n\n            twist = ox.State(\"twist\", shape=(6,))\n            M = ox.Parameter(\"M\", shape=(6, 6), value=inertia_matrix)\n\n            momentum = M @ twist\n            bias_force = ox.lie.AdjointDual(twist, momentum)\n\n            # In dynamics: twist_dot = M_inv @ (wrench - bias_force)\n\n    Note:\n        The coadjoint is related to the adjoint by: ad*_\u03be = -(ad_\u03be)^T\n\n        For the special case of pure rotation (v=0) with diagonal inertia,\n        the angular part reduces to the familiar \u03c9 \u00d7 (J @ \u03c9) term.\n\n    See Also:\n        Adjoint: The adjoint operator for twist-on-twist action\n        SSM: 3x3 skew-symmetric matrix for cross products\n    \"\"\"\n\n    def __init__(self, twist, momentum):\n        \"\"\"Initialize a coadjoint operator.\n\n        Args:\n            twist: 6D twist vector [v; \u03c9] with shape (6,)\n            momentum: 6D momentum vector [p; L] with shape (6,)\n        \"\"\"\n        self.twist = to_expr(twist)\n        self.momentum = to_expr(momentum)\n\n    def children(self):\n        return [self.twist, self.momentum]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        twist = self.twist.canonicalize()\n        momentum = self.momentum.canonicalize()\n        return AdjointDual(twist, momentum)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that inputs are 6D vectors and return output shape.\n\n        Returns:\n            tuple: Shape (6,) for the resulting coadjoint vector\n\n        Raises:\n            ValueError: If twist or momentum do not have shape (6,)\n        \"\"\"\n        twist_shape = self.twist.check_shape()\n        momentum_shape = self.momentum.check_shape()\n\n        if twist_shape != (6,):\n            raise ValueError(f\"AdjointDual expects twist with shape (6,), got {twist_shape}\")\n        if momentum_shape != (6,):\n            raise ValueError(f\"AdjointDual expects momentum with shape (6,), got {momentum_shape}\")\n\n        return (6,)\n\n    def __repr__(self):\n        return f\"ad_dual({self.twist!r}, {self.momentum!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.AdjointDual.__init__","title":"<code>__init__(twist, momentum)</code>","text":"<p>Initialize a coadjoint operator.</p> <p>Parameters:</p> Name Type Description Default <code>twist</code> <p>6D twist vector [v; \u03c9] with shape (6,)</p> required <code>momentum</code> <p>6D momentum vector [p; L] with shape (6,)</p> required Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def __init__(self, twist, momentum):\n    \"\"\"Initialize a coadjoint operator.\n\n    Args:\n        twist: 6D twist vector [v; \u03c9] with shape (6,)\n        momentum: 6D momentum vector [p; L] with shape (6,)\n    \"\"\"\n    self.twist = to_expr(twist)\n    self.momentum = to_expr(momentum)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.AdjointDual.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that inputs are 6D vectors and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (6,) for the resulting coadjoint vector</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If twist or momentum do not have shape (6,)</p> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that inputs are 6D vectors and return output shape.\n\n    Returns:\n        tuple: Shape (6,) for the resulting coadjoint vector\n\n    Raises:\n        ValueError: If twist or momentum do not have shape (6,)\n    \"\"\"\n    twist_shape = self.twist.check_shape()\n    momentum_shape = self.momentum.check_shape()\n\n    if twist_shape != (6,):\n        raise ValueError(f\"AdjointDual expects twist with shape (6,), got {twist_shape}\")\n    if momentum_shape != (6,):\n        raise ValueError(f\"AdjointDual expects momentum with shape (6,), got {momentum_shape}\")\n\n    return (6,)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.SE3Adjoint","title":"<code>SE3Adjoint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>SE(3) Adjoint representation Ad_T for transforming twists between frames.</p> <p>Computes the 6\u00d76 adjoint matrix Ad_T that transforms twists from one coordinate frame to another. Given a transformation T_ab from frame A to frame B, the adjoint transforms a twist expressed in frame A to frame B:</p> <pre><code>\u03be_b = Ad_{T_ab} @ \u03be_a\n</code></pre> <p>For SE(3), given T with rotation R and translation p:</p> <pre><code>Ad_T = [ R      0   ]\n       [ [p]\u00d7R  R   ]\n</code></pre> <p>where [p]\u00d7 is the 3\u00d73 skew-symmetric matrix of p.</p> <p>This is essential for:</p> <ul> <li>Velocity propagation through kinematic chains</li> <li>Computing geometric Jacobians for manipulators</li> <li>Recursive Newton-Euler dynamics algorithms</li> </ul> <p>Attributes:</p> Name Type Description <code>transform</code> <p>4\u00d74 homogeneous transformation matrix</p> Example <p>Transform a body twist to the world frame::</p> <pre><code>import openscvx as ox\n\nT_world_body = forward_kinematics(q)  # 4\u00d74 transform\ntwist_body = ox.State(\"twist_body\", shape=(6,))\n\n# Transform twist to world frame\nAd_T = ox.lie.SE3Adjoint(T_world_body)  # 6\u00d76 matrix\ntwist_world = Ad_T @ twist_body\n</code></pre> <p>Compute geometric Jacobian columns::</p> <pre><code># Each column of the geometric Jacobian is Ad_{T_0i} @ \u03be_i\nJ_col_i = ox.lie.SE3Adjoint(T_0_to_i) @ screw_axis_i\n</code></pre> Note <p>The adjoint satisfies: Ad_{T1 @ T2} = Ad_{T1} @ Ad_{T2}</p> See Also <ul> <li>SE3AdjointDual: For transforming wrenches between frames</li> <li>Adjoint: The small adjoint (Lie bracket) for twist-on-twist action</li> </ul> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>class SE3Adjoint(Expr):\n    \"\"\"SE(3) Adjoint representation Ad_T for transforming twists between frames.\n\n    Computes the 6\u00d76 adjoint matrix Ad_T that transforms twists from one\n    coordinate frame to another. Given a transformation T_ab from frame A to\n    frame B, the adjoint transforms a twist expressed in frame A to frame B:\n\n        \u03be_b = Ad_{T_ab} @ \u03be_a\n\n    For SE(3), given T with rotation R and translation p:\n\n        Ad_T = [ R      0   ]\n               [ [p]\u00d7R  R   ]\n\n    where [p]\u00d7 is the 3\u00d73 skew-symmetric matrix of p.\n\n    This is essential for:\n\n    - Velocity propagation through kinematic chains\n    - Computing geometric Jacobians for manipulators\n    - Recursive Newton-Euler dynamics algorithms\n\n    Attributes:\n        transform: 4\u00d74 homogeneous transformation matrix\n\n    Example:\n        Transform a body twist to the world frame::\n\n            import openscvx as ox\n\n            T_world_body = forward_kinematics(q)  # 4\u00d74 transform\n            twist_body = ox.State(\"twist_body\", shape=(6,))\n\n            # Transform twist to world frame\n            Ad_T = ox.lie.SE3Adjoint(T_world_body)  # 6\u00d76 matrix\n            twist_world = Ad_T @ twist_body\n\n        Compute geometric Jacobian columns::\n\n            # Each column of the geometric Jacobian is Ad_{T_0i} @ \u03be_i\n            J_col_i = ox.lie.SE3Adjoint(T_0_to_i) @ screw_axis_i\n\n    Note:\n        The adjoint satisfies: Ad_{T1 @ T2} = Ad_{T1} @ Ad_{T2}\n\n    See Also:\n        - SE3AdjointDual: For transforming wrenches between frames\n        - Adjoint: The small adjoint (Lie bracket) for twist-on-twist action\n    \"\"\"\n\n    def __init__(self, transform):\n        \"\"\"Initialize SE3 Adjoint operator.\n\n        Args:\n            transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n        \"\"\"\n        self.transform = to_expr(transform)\n\n    def children(self):\n        return [self.transform]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        transform = self.transform.canonicalize()\n        return SE3Adjoint(transform)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 4\u00d74 matrix and return output shape.\n\n        Returns:\n            tuple: Shape (6, 6) for the adjoint matrix\n\n        Raises:\n            ValueError: If transform does not have shape (4, 4)\n        \"\"\"\n        transform_shape = self.transform.check_shape()\n        if transform_shape != (4, 4):\n            raise ValueError(\n                f\"SE3Adjoint expects transform with shape (4, 4), got {transform_shape}\"\n            )\n        return (6, 6)\n\n    def __repr__(self):\n        return f\"Ad({self.transform!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.SE3Adjoint.__init__","title":"<code>__init__(transform)</code>","text":"<p>Initialize SE3 Adjoint operator.</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <p>4\u00d74 homogeneous transformation matrix with shape (4, 4)</p> required Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def __init__(self, transform):\n    \"\"\"Initialize SE3 Adjoint operator.\n\n    Args:\n        transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n    \"\"\"\n    self.transform = to_expr(transform)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.SE3Adjoint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 4\u00d74 matrix and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (6, 6) for the adjoint matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If transform does not have shape (4, 4)</p> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 4\u00d74 matrix and return output shape.\n\n    Returns:\n        tuple: Shape (6, 6) for the adjoint matrix\n\n    Raises:\n        ValueError: If transform does not have shape (4, 4)\n    \"\"\"\n    transform_shape = self.transform.check_shape()\n    if transform_shape != (4, 4):\n        raise ValueError(\n            f\"SE3Adjoint expects transform with shape (4, 4), got {transform_shape}\"\n        )\n    return (6, 6)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.SE3AdjointDual","title":"<code>SE3AdjointDual</code>","text":"<p>               Bases: <code>Expr</code></p> <p>SE(3) coadjoint representation Ad*_T for transforming wrenches between frames.</p> <p>Computes the 6\u00d76 coadjoint matrix Ad*_T that transforms wrenches from one coordinate frame to another. Given a transformation T_ab from frame A to frame B, the coadjoint transforms a wrench expressed in frame B to frame A:</p> <pre><code>F_a = Ad*_{T_ab} @ F_b\n</code></pre> <p>For SE(3), given T with rotation R and translation p:</p> <pre><code>Ad*_T = [ R     [p]\u00d7R ]\n        [ 0       R   ]\n</code></pre> <p>This is the transpose-inverse of Ad_T: Ad*_T = (Ad_T)^{-T}</p> <p>This is essential for:</p> <ul> <li>Force/torque propagation in dynamics</li> <li>Transforming wrenches between end-effector and base frames</li> <li>Recursive Newton-Euler dynamics algorithms</li> </ul> <p>Attributes:</p> Name Type Description <code>transform</code> <p>4\u00d74 homogeneous transformation matrix</p> Example <p>Transform a wrench from end-effector to base frame::</p> <pre><code>import openscvx as ox\n\nT_base_ee = forward_kinematics(q)  # 4\u00d74 transform\nwrench_ee = ox.Control(\"wrench_ee\", shape=(6,))\n\n# Transform wrench to base frame\nAd_star_T = ox.lie.SE3AdjointDual(T_base_ee)  # 6\u00d76 matrix\nwrench_base = Ad_star_T @ wrench_ee\n</code></pre> Note <p>The coadjoint is related to the adjoint by: Ad*_T = (Ad_T)^{-T}</p> See Also <ul> <li>SE3Adjoint: For transforming twists between frames</li> <li>AdjointDual: The small coadjoint for Coriolis/centrifugal forces</li> </ul> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>class SE3AdjointDual(Expr):\n    \"\"\"SE(3) coadjoint representation Ad*_T for transforming wrenches between frames.\n\n    Computes the 6\u00d76 coadjoint matrix Ad*_T that transforms wrenches from one\n    coordinate frame to another. Given a transformation T_ab from frame A to\n    frame B, the coadjoint transforms a wrench expressed in frame B to frame A:\n\n        F_a = Ad*_{T_ab} @ F_b\n\n    For SE(3), given T with rotation R and translation p:\n\n        Ad*_T = [ R     [p]\u00d7R ]\n                [ 0       R   ]\n\n    This is the transpose-inverse of Ad_T: Ad*_T = (Ad_T)^{-T}\n\n    This is essential for:\n\n    - Force/torque propagation in dynamics\n    - Transforming wrenches between end-effector and base frames\n    - Recursive Newton-Euler dynamics algorithms\n\n    Attributes:\n        transform: 4\u00d74 homogeneous transformation matrix\n\n    Example:\n        Transform a wrench from end-effector to base frame::\n\n            import openscvx as ox\n\n            T_base_ee = forward_kinematics(q)  # 4\u00d74 transform\n            wrench_ee = ox.Control(\"wrench_ee\", shape=(6,))\n\n            # Transform wrench to base frame\n            Ad_star_T = ox.lie.SE3AdjointDual(T_base_ee)  # 6\u00d76 matrix\n            wrench_base = Ad_star_T @ wrench_ee\n\n    Note:\n        The coadjoint is related to the adjoint by: Ad*_T = (Ad_T)^{-T}\n\n    See Also:\n        - SE3Adjoint: For transforming twists between frames\n        - AdjointDual: The small coadjoint for Coriolis/centrifugal forces\n    \"\"\"\n\n    def __init__(self, transform):\n        \"\"\"Initialize SE3 coadjoint operator.\n\n        Args:\n            transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n        \"\"\"\n        self.transform = to_expr(transform)\n\n    def children(self):\n        return [self.transform]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        transform = self.transform.canonicalize()\n        return SE3AdjointDual(transform)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 4\u00d74 matrix and return output shape.\n\n        Returns:\n            tuple: Shape (6, 6) for the coadjoint matrix\n\n        Raises:\n            ValueError: If transform does not have shape (4, 4)\n        \"\"\"\n        transform_shape = self.transform.check_shape()\n        if transform_shape != (4, 4):\n            raise ValueError(\n                f\"SE3AdjointDual expects transform with shape (4, 4), got {transform_shape}\"\n            )\n        return (6, 6)\n\n    def __repr__(self):\n        return f\"Ad_dual({self.transform!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.SE3AdjointDual.__init__","title":"<code>__init__(transform)</code>","text":"<p>Initialize SE3 coadjoint operator.</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <p>4\u00d74 homogeneous transformation matrix with shape (4, 4)</p> required Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def __init__(self, transform):\n    \"\"\"Initialize SE3 coadjoint operator.\n\n    Args:\n        transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n    \"\"\"\n    self.transform = to_expr(transform)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.SE3AdjointDual.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 4\u00d74 matrix and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (6, 6) for the coadjoint matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If transform does not have shape (4, 4)</p> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 4\u00d74 matrix and return output shape.\n\n    Returns:\n        tuple: Shape (6, 6) for the coadjoint matrix\n\n    Raises:\n        ValueError: If transform does not have shape (4, 4)\n    \"\"\"\n    transform_shape = self.transform.check_shape()\n    if transform_shape != (4, 4):\n        raise ValueError(\n            f\"SE3AdjointDual expects transform with shape (4, 4), got {transform_shape}\"\n        )\n    return (6, 6)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.SE3Exp","title":"<code>SE3Exp</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Exponential map from se(3) twist to SE(3) transformation matrix.</p> <p>Maps a 6D twist vector to a 4\u00d74 homogeneous transformation matrix. Uses jaxlie for numerically robust implementation with proper handling of small angles and translations.</p> <p>The twist \u03be = [v; \u03c9] follows the convention:</p> <ul> <li>v: 3D linear velocity component</li> <li>\u03c9: 3D angular velocity component</li> </ul> <p>This is the key operation for Product of Exponentials (PoE) forward kinematics in robotic manipulators.</p> <p>Attributes:</p> Name Type Description <code>twist</code> <p>6D twist vector [v; \u03c9] with shape (6,)</p> Example <p>Product of Exponentials forward kinematics::</p> <pre><code>import openscvx as ox\nimport numpy as np\n\n# Screw axis for revolute joint about z-axis at origin\nscrew_axis = np.array([0, 0, 0, 0, 0, 1])  # [v; \u03c9]\ntheta = ox.State(\"theta\", shape=(1,))\n\n# Joint transformation\nT = ox.lie.SE3Exp(ox.Constant(screw_axis) * theta)  # 4\u00d74 matrix\n\n# Chain multiple joints\nT_01 = ox.lie.SE3Exp(screw1 * q1)\nT_12 = ox.lie.SE3Exp(screw2 * q2)\nT_02 = T_01 @ T_12\n</code></pre> <p>Extract position from transformation::</p> <pre><code>T_ee = forward_kinematics(joint_angles)\np_ee = T_ee[:3, 3]  # End-effector position\n</code></pre> Note <p>The twist convention [v; \u03c9] matches jaxlie's SE3 tangent parameterization, so no reordering is performed.</p> See Also <ul> <li>SE3Log: Inverse operation (transformation matrix to twist)</li> <li>SO3Exp: Rotation-only exponential map</li> <li>AdjointDual: For dynamics computations with twists</li> </ul> Source code in <code>openscvx/symbolic/expr/lie/se3.py</code> <pre><code>class SE3Exp(Expr):\n    \"\"\"Exponential map from se(3) twist to SE(3) transformation matrix.\n\n    Maps a 6D twist vector to a 4\u00d74 homogeneous transformation matrix.\n    Uses jaxlie for numerically robust implementation with proper handling\n    of small angles and translations.\n\n    The twist \u03be = [v; \u03c9] follows the convention:\n\n    - v: 3D linear velocity component\n    - \u03c9: 3D angular velocity component\n\n    This is the key operation for Product of Exponentials (PoE) forward\n    kinematics in robotic manipulators.\n\n    Attributes:\n        twist: 6D twist vector [v; \u03c9] with shape (6,)\n\n    Example:\n        Product of Exponentials forward kinematics::\n\n            import openscvx as ox\n            import numpy as np\n\n            # Screw axis for revolute joint about z-axis at origin\n            screw_axis = np.array([0, 0, 0, 0, 0, 1])  # [v; \u03c9]\n            theta = ox.State(\"theta\", shape=(1,))\n\n            # Joint transformation\n            T = ox.lie.SE3Exp(ox.Constant(screw_axis) * theta)  # 4\u00d74 matrix\n\n            # Chain multiple joints\n            T_01 = ox.lie.SE3Exp(screw1 * q1)\n            T_12 = ox.lie.SE3Exp(screw2 * q2)\n            T_02 = T_01 @ T_12\n\n        Extract position from transformation::\n\n            T_ee = forward_kinematics(joint_angles)\n            p_ee = T_ee[:3, 3]  # End-effector position\n\n    Note:\n        The twist convention [v; \u03c9] matches jaxlie's SE3 tangent\n        parameterization, so no reordering is performed.\n\n    See Also:\n        - SE3Log: Inverse operation (transformation matrix to twist)\n        - SO3Exp: Rotation-only exponential map\n        - AdjointDual: For dynamics computations with twists\n    \"\"\"\n\n    def __init__(self, twist):\n        \"\"\"Initialize SE3 exponential map.\n\n        Args:\n            twist: 6D twist vector [v; \u03c9] with shape (6,)\n        \"\"\"\n        self.twist = to_expr(twist)\n\n    def children(self):\n        return [self.twist]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        twist = self.twist.canonicalize()\n        return SE3Exp(twist)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 6D vector and return output shape.\n\n        Returns:\n            tuple: Shape (4, 4) for the homogeneous transformation matrix\n\n        Raises:\n            ValueError: If twist does not have shape (6,)\n        \"\"\"\n        twist_shape = self.twist.check_shape()\n        if twist_shape != (6,):\n            raise ValueError(f\"SE3Exp expects twist with shape (6,), got {twist_shape}\")\n        return (4, 4)\n\n    def __repr__(self):\n        return f\"SE3Exp({self.twist!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.SE3Exp.__init__","title":"<code>__init__(twist)</code>","text":"<p>Initialize SE3 exponential map.</p> <p>Parameters:</p> Name Type Description Default <code>twist</code> <p>6D twist vector [v; \u03c9] with shape (6,)</p> required Source code in <code>openscvx/symbolic/expr/lie/se3.py</code> <pre><code>def __init__(self, twist):\n    \"\"\"Initialize SE3 exponential map.\n\n    Args:\n        twist: 6D twist vector [v; \u03c9] with shape (6,)\n    \"\"\"\n    self.twist = to_expr(twist)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.SE3Exp.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 6D vector and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (4, 4) for the homogeneous transformation matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If twist does not have shape (6,)</p> Source code in <code>openscvx/symbolic/expr/lie/se3.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 6D vector and return output shape.\n\n    Returns:\n        tuple: Shape (4, 4) for the homogeneous transformation matrix\n\n    Raises:\n        ValueError: If twist does not have shape (6,)\n    \"\"\"\n    twist_shape = self.twist.check_shape()\n    if twist_shape != (6,):\n        raise ValueError(f\"SE3Exp expects twist with shape (6,), got {twist_shape}\")\n    return (4, 4)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.SE3Log","title":"<code>SE3Log</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Logarithm map from SE(3) transformation matrix to se(3) twist.</p> <p>Maps a 4\u00d74 homogeneous transformation matrix to a 6D twist vector. Uses jaxlie for numerically robust implementation.</p> <p>The output twist \u03be = [v; \u03c9] follows the convention:</p> <ul> <li>v: 3D linear component</li> <li>\u03c9: 3D angular component (rotation vector)</li> </ul> <p>This is useful for computing error metrics between poses in optimization.</p> <p>Attributes:</p> Name Type Description <code>transform</code> <p>4\u00d74 homogeneous transformation matrix with shape (4, 4)</p> Example <p>Compute pose error for trajectory optimization::</p> <pre><code>import openscvx as ox\n\nT_current = forward_kinematics(q)\nT_target = ox.Parameter(\"T_target\", shape=(4, 4), value=goal_pose)\n\n# Relative transformation\nT_error = ox.linalg.inv(T_target) @ T_current\n\n# Convert to twist for error metric\ntwist_error = ox.lie.SE3Log(T_error)\npose_cost = ox.linalg.Norm(twist_error) ** 2\n</code></pre> See Also <ul> <li>SE3Exp: Inverse operation (twist to transformation matrix)</li> <li>SO3Log: Rotation-only logarithm map</li> </ul> Source code in <code>openscvx/symbolic/expr/lie/se3.py</code> <pre><code>class SE3Log(Expr):\n    \"\"\"Logarithm map from SE(3) transformation matrix to se(3) twist.\n\n    Maps a 4\u00d74 homogeneous transformation matrix to a 6D twist vector.\n    Uses jaxlie for numerically robust implementation.\n\n    The output twist \u03be = [v; \u03c9] follows the convention:\n\n    - v: 3D linear component\n    - \u03c9: 3D angular component (rotation vector)\n\n    This is useful for computing error metrics between poses in optimization.\n\n    Attributes:\n        transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n\n    Example:\n        Compute pose error for trajectory optimization::\n\n            import openscvx as ox\n\n            T_current = forward_kinematics(q)\n            T_target = ox.Parameter(\"T_target\", shape=(4, 4), value=goal_pose)\n\n            # Relative transformation\n            T_error = ox.linalg.inv(T_target) @ T_current\n\n            # Convert to twist for error metric\n            twist_error = ox.lie.SE3Log(T_error)\n            pose_cost = ox.linalg.Norm(twist_error) ** 2\n\n    See Also:\n        - SE3Exp: Inverse operation (twist to transformation matrix)\n        - SO3Log: Rotation-only logarithm map\n    \"\"\"\n\n    def __init__(self, transform):\n        \"\"\"Initialize SE3 logarithm map.\n\n        Args:\n            transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n        \"\"\"\n        self.transform = to_expr(transform)\n\n    def children(self):\n        return [self.transform]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        transform = self.transform.canonicalize()\n        return SE3Log(transform)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 4\u00d74 matrix and return output shape.\n\n        Returns:\n            tuple: Shape (6,) for the twist vector\n\n        Raises:\n            ValueError: If transform does not have shape (4, 4)\n        \"\"\"\n        transform_shape = self.transform.check_shape()\n        if transform_shape != (4, 4):\n            raise ValueError(f\"SE3Log expects transform with shape (4, 4), got {transform_shape}\")\n        return (6,)\n\n    def __repr__(self):\n        return f\"SE3Log({self.transform!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.SE3Log.__init__","title":"<code>__init__(transform)</code>","text":"<p>Initialize SE3 logarithm map.</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <p>4\u00d74 homogeneous transformation matrix with shape (4, 4)</p> required Source code in <code>openscvx/symbolic/expr/lie/se3.py</code> <pre><code>def __init__(self, transform):\n    \"\"\"Initialize SE3 logarithm map.\n\n    Args:\n        transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n    \"\"\"\n    self.transform = to_expr(transform)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.SE3Log.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 4\u00d74 matrix and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (6,) for the twist vector</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If transform does not have shape (4, 4)</p> Source code in <code>openscvx/symbolic/expr/lie/se3.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 4\u00d74 matrix and return output shape.\n\n    Returns:\n        tuple: Shape (6,) for the twist vector\n\n    Raises:\n        ValueError: If transform does not have shape (4, 4)\n    \"\"\"\n    transform_shape = self.transform.check_shape()\n    if transform_shape != (4, 4):\n        raise ValueError(f\"SE3Log expects transform with shape (4, 4), got {transform_shape}\")\n    return (6,)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.SO3Exp","title":"<code>SO3Exp</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Exponential map from so(3) to SO(3) rotation matrix.</p> <p>Maps a 3D rotation vector (axis-angle representation) to a 3\u00d73 rotation matrix using the Rodrigues formula. Uses jaxlie for numerically robust implementation with proper handling of small angles.</p> <p>The rotation vector \u03c9 has direction equal to the rotation axis and magnitude equal to the rotation angle in radians.</p> <p>Attributes:</p> Name Type Description <code>omega</code> <p>3D rotation vector with shape (3,)</p> Example <p>Create a rotation about the z-axis::</p> <pre><code>import openscvx as ox\nimport numpy as np\n\n# 90 degree rotation about z\nomega = ox.Constant(np.array([0, 0, np.pi/2]))\nR = ox.lie.SO3Exp(omega)  # 3\u00d73 rotation matrix\n</code></pre> <p>Parameterized rotation for optimization::</p> <pre><code>theta = ox.State(\"theta\", shape=(1,))\naxis = ox.Constant(np.array([0, 0, 1]))  # z-axis\nR = ox.lie.SO3Exp(axis * theta)\n</code></pre> See Also <ul> <li>SO3Log: Inverse operation (rotation matrix to rotation vector)</li> <li>SE3Exp: Full rigid body transformation including translation</li> </ul> Source code in <code>openscvx/symbolic/expr/lie/so3.py</code> <pre><code>class SO3Exp(Expr):\n    \"\"\"Exponential map from so(3) to SO(3) rotation matrix.\n\n    Maps a 3D rotation vector (axis-angle representation) to a 3\u00d73 rotation\n    matrix using the Rodrigues formula. Uses jaxlie for numerically robust\n    implementation with proper handling of small angles.\n\n    The rotation vector \u03c9 has direction equal to the rotation axis and\n    magnitude equal to the rotation angle in radians.\n\n    Attributes:\n        omega: 3D rotation vector with shape (3,)\n\n    Example:\n        Create a rotation about the z-axis::\n\n            import openscvx as ox\n            import numpy as np\n\n            # 90 degree rotation about z\n            omega = ox.Constant(np.array([0, 0, np.pi/2]))\n            R = ox.lie.SO3Exp(omega)  # 3\u00d73 rotation matrix\n\n        Parameterized rotation for optimization::\n\n            theta = ox.State(\"theta\", shape=(1,))\n            axis = ox.Constant(np.array([0, 0, 1]))  # z-axis\n            R = ox.lie.SO3Exp(axis * theta)\n\n    See Also:\n        - SO3Log: Inverse operation (rotation matrix to rotation vector)\n        - SE3Exp: Full rigid body transformation including translation\n    \"\"\"\n\n    def __init__(self, omega):\n        \"\"\"Initialize SO3 exponential map.\n\n        Args:\n            omega: 3D rotation vector (axis \u00d7 angle) with shape (3,)\n        \"\"\"\n        self.omega = to_expr(omega)\n\n    def children(self):\n        return [self.omega]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        omega = self.omega.canonicalize()\n        return SO3Exp(omega)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 3D vector and return output shape.\n\n        Returns:\n            tuple: Shape (3, 3) for the rotation matrix\n\n        Raises:\n            ValueError: If omega does not have shape (3,)\n        \"\"\"\n        omega_shape = self.omega.check_shape()\n        if omega_shape != (3,):\n            raise ValueError(f\"SO3Exp expects omega with shape (3,), got {omega_shape}\")\n        return (3, 3)\n\n    def __repr__(self):\n        return f\"SO3Exp({self.omega!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.SO3Exp.__init__","title":"<code>__init__(omega)</code>","text":"<p>Initialize SO3 exponential map.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <p>3D rotation vector (axis \u00d7 angle) with shape (3,)</p> required Source code in <code>openscvx/symbolic/expr/lie/so3.py</code> <pre><code>def __init__(self, omega):\n    \"\"\"Initialize SO3 exponential map.\n\n    Args:\n        omega: 3D rotation vector (axis \u00d7 angle) with shape (3,)\n    \"\"\"\n    self.omega = to_expr(omega)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.SO3Exp.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 3D vector and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (3, 3) for the rotation matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If omega does not have shape (3,)</p> Source code in <code>openscvx/symbolic/expr/lie/so3.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 3D vector and return output shape.\n\n    Returns:\n        tuple: Shape (3, 3) for the rotation matrix\n\n    Raises:\n        ValueError: If omega does not have shape (3,)\n    \"\"\"\n    omega_shape = self.omega.check_shape()\n    if omega_shape != (3,):\n        raise ValueError(f\"SO3Exp expects omega with shape (3,), got {omega_shape}\")\n    return (3, 3)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.SO3Log","title":"<code>SO3Log</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Logarithm map from SO(3) rotation matrix to so(3) rotation vector.</p> <p>Maps a 3\u00d73 rotation matrix to a 3D rotation vector (axis-angle representation). Uses jaxlie for numerically robust implementation.</p> <p>The output rotation vector \u03c9 has direction equal to the rotation axis and magnitude equal to the rotation angle in radians.</p> <p>Attributes:</p> Name Type Description <code>rotation</code> <p>3\u00d73 rotation matrix with shape (3, 3)</p> Example <p>Extract rotation vector from a rotation matrix::</p> <pre><code>import openscvx as ox\n\nR = ox.State(\"R\", shape=(3, 3))  # Rotation matrix state\nomega = ox.lie.SO3Log(R)  # 3D rotation vector\n</code></pre> See Also <ul> <li>SO3Exp: Inverse operation (rotation vector to rotation matrix)</li> <li>SE3Log: Full rigid body transformation logarithm</li> </ul> Source code in <code>openscvx/symbolic/expr/lie/so3.py</code> <pre><code>class SO3Log(Expr):\n    \"\"\"Logarithm map from SO(3) rotation matrix to so(3) rotation vector.\n\n    Maps a 3\u00d73 rotation matrix to a 3D rotation vector (axis-angle\n    representation). Uses jaxlie for numerically robust implementation.\n\n    The output rotation vector \u03c9 has direction equal to the rotation axis\n    and magnitude equal to the rotation angle in radians.\n\n    Attributes:\n        rotation: 3\u00d73 rotation matrix with shape (3, 3)\n\n    Example:\n        Extract rotation vector from a rotation matrix::\n\n            import openscvx as ox\n\n            R = ox.State(\"R\", shape=(3, 3))  # Rotation matrix state\n            omega = ox.lie.SO3Log(R)  # 3D rotation vector\n\n    See Also:\n        - SO3Exp: Inverse operation (rotation vector to rotation matrix)\n        - SE3Log: Full rigid body transformation logarithm\n    \"\"\"\n\n    def __init__(self, rotation):\n        \"\"\"Initialize SO3 logarithm map.\n\n        Args:\n            rotation: 3\u00d73 rotation matrix with shape (3, 3)\n        \"\"\"\n        self.rotation = to_expr(rotation)\n\n    def children(self):\n        return [self.rotation]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        rotation = self.rotation.canonicalize()\n        return SO3Log(rotation)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 3\u00d73 matrix and return output shape.\n\n        Returns:\n            tuple: Shape (3,) for the rotation vector\n\n        Raises:\n            ValueError: If rotation does not have shape (3, 3)\n        \"\"\"\n        rotation_shape = self.rotation.check_shape()\n        if rotation_shape != (3, 3):\n            raise ValueError(f\"SO3Log expects rotation with shape (3, 3), got {rotation_shape}\")\n        return (3,)\n\n    def __repr__(self):\n        return f\"SO3Log({self.rotation!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.SO3Log.__init__","title":"<code>__init__(rotation)</code>","text":"<p>Initialize SO3 logarithm map.</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <p>3\u00d73 rotation matrix with shape (3, 3)</p> required Source code in <code>openscvx/symbolic/expr/lie/so3.py</code> <pre><code>def __init__(self, rotation):\n    \"\"\"Initialize SO3 logarithm map.\n\n    Args:\n        rotation: 3\u00d73 rotation matrix with shape (3, 3)\n    \"\"\"\n    self.rotation = to_expr(rotation)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/#openscvx.symbolic.expr.lie.SO3Log.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 3\u00d73 matrix and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (3,) for the rotation vector</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If rotation does not have shape (3, 3)</p> Source code in <code>openscvx/symbolic/expr/lie/so3.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 3\u00d73 matrix and return output shape.\n\n    Returns:\n        tuple: Shape (3,) for the rotation vector\n\n    Raises:\n        ValueError: If rotation does not have shape (3, 3)\n    \"\"\"\n    rotation_shape = self.rotation.check_shape()\n    if rotation_shape != (3, 3):\n        raise ValueError(f\"SO3Log expects rotation with shape (3, 3), got {rotation_shape}\")\n    return (3,)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/adjoint/","title":"adjoint","text":"<p>Adjoint and coadjoint operators for rigid body dynamics.</p> <p>This module provides the core Lie algebra operators for 6-DOF rigid body dynamics. These operators require no external dependencies and work with the standard openscvx installation.</p> The module uses the following conventions <ul> <li>Twist (spatial velocity): \u03be = [v; \u03c9] where v \u2208 \u211d\u00b3 is linear velocity   and \u03c9 \u2208 \u211d\u00b3 is angular velocity (both in body frame)</li> <li>Wrench (spatial force): F = [f; \u03c4] where f \u2208 \u211d\u00b3 is force and \u03c4 \u2208 \u211d\u00b3   is torque (both in body frame)</li> <li>Momentum: \u03bc = [p; L] where p \u2208 \u211d\u00b3 is linear momentum and L \u2208 \u211d\u00b3   is angular momentum</li> </ul>"},{"location":"reference/symbolic/expr/lie/adjoint/#openscvx.symbolic.expr.lie.adjoint.Adjoint","title":"<code>Adjoint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Adjoint operator ad (Lie bracket) for twist-on-twist action.</p> <p>Computes the adjoint action ad_\u03be\u2081(\u03be\u2082) which represents the Lie bracket [\u03be\u2081, \u03be\u2082] of two twists. This is used for velocity propagation in kinematic chains and acceleration computations.</p> <p>For se(3), given twists \u03be\u2081 = [v\u2081; \u03c9\u2081] and \u03be\u2082 = [v\u2082; \u03c9\u2082]:</p> <pre><code>ad_\u03be\u2081(\u03be\u2082) = [\u03be\u2081, \u03be\u2082] = [ \u03c9\u2081 \u00d7 v\u2082 - \u03c9\u2082 \u00d7 v\u2081 ]\n                        [     \u03c9\u2081 \u00d7 \u03c9\u2082       ]\n</code></pre> <p>Equivalently using the adjoint matrix:</p> <pre><code>ad_\u03be = [ [\u03c9]\u00d7    0   ]\n       [ [v]\u00d7   [\u03c9]\u00d7 ]\n</code></pre> <p>where [\u00b7]\u00d7 denotes the 3x3 skew-symmetric (cross product) matrix.</p> <p>Attributes:</p> Name Type Description <code>twist1</code> <p>First 6D twist vector [v\u2081; \u03c9\u2081]</p> <code>twist2</code> <p>Second 6D twist vector [v\u2082; \u03c9\u2082]</p> Example <p>Compute the Lie bracket of two twists::</p> <pre><code>import openscvx as ox\n\ntwist1 = ox.State(\"twist1\", shape=(6,))\ntwist2 = ox.State(\"twist2\", shape=(6,))\n\nbracket = ox.lie.Adjoint(twist1, twist2)\n</code></pre> <p>Velocity propagation in a kinematic chain::</p> <pre><code># Child link velocity includes parent velocity plus relative motion\n# V_child = Ad_T @ V_parent + joint_twist * q_dot\n</code></pre> Note <p>The adjoint satisfies the Jacobi identity and is antisymmetric: ad_\u03be\u2081(\u03be\u2082) = -ad_\u03be\u2082(\u03be\u2081)</p> See Also <p>AdjointDual: The coadjoint operator for momentum dynamics</p> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>class Adjoint(Expr):\n    \"\"\"Adjoint operator ad (Lie bracket) for twist-on-twist action.\n\n    Computes the adjoint action ad_\u03be\u2081(\u03be\u2082) which represents the Lie bracket\n    [\u03be\u2081, \u03be\u2082] of two twists. This is used for velocity propagation in\n    kinematic chains and acceleration computations.\n\n    For se(3), given twists \u03be\u2081 = [v\u2081; \u03c9\u2081] and \u03be\u2082 = [v\u2082; \u03c9\u2082]:\n\n        ad_\u03be\u2081(\u03be\u2082) = [\u03be\u2081, \u03be\u2082] = [ \u03c9\u2081 \u00d7 v\u2082 - \u03c9\u2082 \u00d7 v\u2081 ]\n                                [     \u03c9\u2081 \u00d7 \u03c9\u2082       ]\n\n    Equivalently using the adjoint matrix:\n\n        ad_\u03be = [ [\u03c9]\u00d7    0   ]\n               [ [v]\u00d7   [\u03c9]\u00d7 ]\n\n    where [\u00b7]\u00d7 denotes the 3x3 skew-symmetric (cross product) matrix.\n\n    Attributes:\n        twist1: First 6D twist vector [v\u2081; \u03c9\u2081]\n        twist2: Second 6D twist vector [v\u2082; \u03c9\u2082]\n\n    Example:\n        Compute the Lie bracket of two twists::\n\n            import openscvx as ox\n\n            twist1 = ox.State(\"twist1\", shape=(6,))\n            twist2 = ox.State(\"twist2\", shape=(6,))\n\n            bracket = ox.lie.Adjoint(twist1, twist2)\n\n        Velocity propagation in a kinematic chain::\n\n            # Child link velocity includes parent velocity plus relative motion\n            # V_child = Ad_T @ V_parent + joint_twist * q_dot\n\n    Note:\n        The adjoint satisfies the Jacobi identity and is antisymmetric:\n        ad_\u03be\u2081(\u03be\u2082) = -ad_\u03be\u2082(\u03be\u2081)\n\n    See Also:\n        AdjointDual: The coadjoint operator for momentum dynamics\n    \"\"\"\n\n    def __init__(self, twist1, twist2):\n        \"\"\"Initialize an adjoint operator.\n\n        Args:\n            twist1: First 6D twist vector [v; \u03c9] with shape (6,)\n            twist2: Second 6D twist vector [v; \u03c9] with shape (6,)\n        \"\"\"\n        self.twist1 = to_expr(twist1)\n        self.twist2 = to_expr(twist2)\n\n    def children(self):\n        return [self.twist1, self.twist2]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        twist1 = self.twist1.canonicalize()\n        twist2 = self.twist2.canonicalize()\n        return Adjoint(twist1, twist2)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that inputs are 6D vectors and return output shape.\n\n        Returns:\n            tuple: Shape (6,) for the resulting Lie bracket\n\n        Raises:\n            ValueError: If either twist does not have shape (6,)\n        \"\"\"\n        twist1_shape = self.twist1.check_shape()\n        twist2_shape = self.twist2.check_shape()\n\n        if twist1_shape != (6,):\n            raise ValueError(f\"Adjoint expects twist1 with shape (6,), got {twist1_shape}\")\n        if twist2_shape != (6,):\n            raise ValueError(f\"Adjoint expects twist2 with shape (6,), got {twist2_shape}\")\n\n        return (6,)\n\n    def __repr__(self):\n        return f\"ad({self.twist1!r}, {self.twist2!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/lie/adjoint/#openscvx.symbolic.expr.lie.adjoint.Adjoint.__init__","title":"<code>__init__(twist1, twist2)</code>","text":"<p>Initialize an adjoint operator.</p> <p>Parameters:</p> Name Type Description Default <code>twist1</code> <p>First 6D twist vector [v; \u03c9] with shape (6,)</p> required <code>twist2</code> <p>Second 6D twist vector [v; \u03c9] with shape (6,)</p> required Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def __init__(self, twist1, twist2):\n    \"\"\"Initialize an adjoint operator.\n\n    Args:\n        twist1: First 6D twist vector [v; \u03c9] with shape (6,)\n        twist2: Second 6D twist vector [v; \u03c9] with shape (6,)\n    \"\"\"\n    self.twist1 = to_expr(twist1)\n    self.twist2 = to_expr(twist2)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/adjoint/#openscvx.symbolic.expr.lie.adjoint.Adjoint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that inputs are 6D vectors and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (6,) for the resulting Lie bracket</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either twist does not have shape (6,)</p> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that inputs are 6D vectors and return output shape.\n\n    Returns:\n        tuple: Shape (6,) for the resulting Lie bracket\n\n    Raises:\n        ValueError: If either twist does not have shape (6,)\n    \"\"\"\n    twist1_shape = self.twist1.check_shape()\n    twist2_shape = self.twist2.check_shape()\n\n    if twist1_shape != (6,):\n        raise ValueError(f\"Adjoint expects twist1 with shape (6,), got {twist1_shape}\")\n    if twist2_shape != (6,):\n        raise ValueError(f\"Adjoint expects twist2 with shape (6,), got {twist2_shape}\")\n\n    return (6,)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/adjoint/#openscvx.symbolic.expr.lie.adjoint.AdjointDual","title":"<code>AdjointDual</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Coadjoint operator ad* for computing Coriolis and centrifugal forces.</p> <p>Computes the coadjoint action ad*_\u03be(\u03bc) which represents the rate of change of momentum due to body rotation. This is the key term in Newton-Euler dynamics that captures Coriolis and centrifugal effects.</p> <p>For se(3), given twist \u03be = [v; \u03c9] and momentum \u03bc = [f; \u03c4]:</p> <pre><code>ad*_\u03be(\u03bc) = [ \u03c9 \u00d7 f + v \u00d7 \u03c4 ]\n           [     \u03c9 \u00d7 \u03c4     ]\n</code></pre> <p>This appears in the Newton-Euler equations as:</p> <pre><code>M @ \u03be_dot = F_ext - ad*_\u03be(M @ \u03be)\n</code></pre> <p>where M is the spatial inertia matrix and F_ext is the external wrench.</p> <p>Attributes:</p> Name Type Description <code>twist</code> <p>6D twist vector [v; \u03c9] (linear velocity, angular velocity)</p> <code>momentum</code> <p>6D momentum vector [p; L] or [f; \u03c4] (linear, angular)</p> Example <p>Compute the bias force (Coriolis + centrifugal) for rigid body dynamics::</p> <pre><code>import openscvx as ox\n\ntwist = ox.State(\"twist\", shape=(6,))\nM = ox.Parameter(\"M\", shape=(6, 6), value=inertia_matrix)\n\nmomentum = M @ twist\nbias_force = ox.lie.AdjointDual(twist, momentum)\n\n# In dynamics: twist_dot = M_inv @ (wrench - bias_force)\n</code></pre> Note <p>The coadjoint is related to the adjoint by: ad*_\u03be = -(ad_\u03be)^T</p> <p>For the special case of pure rotation (v=0) with diagonal inertia, the angular part reduces to the familiar \u03c9 \u00d7 (J @ \u03c9) term.</p> See Also <p>Adjoint: The adjoint operator for twist-on-twist action SSM: 3x3 skew-symmetric matrix for cross products</p> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>class AdjointDual(Expr):\n    \"\"\"Coadjoint operator ad* for computing Coriolis and centrifugal forces.\n\n    Computes the coadjoint action ad*_\u03be(\u03bc) which represents the rate of change\n    of momentum due to body rotation. This is the key term in Newton-Euler\n    dynamics that captures Coriolis and centrifugal effects.\n\n    For se(3), given twist \u03be = [v; \u03c9] and momentum \u03bc = [f; \u03c4]:\n\n        ad*_\u03be(\u03bc) = [ \u03c9 \u00d7 f + v \u00d7 \u03c4 ]\n                   [     \u03c9 \u00d7 \u03c4     ]\n\n    This appears in the Newton-Euler equations as:\n\n        M @ \u03be_dot = F_ext - ad*_\u03be(M @ \u03be)\n\n    where M is the spatial inertia matrix and F_ext is the external wrench.\n\n    Attributes:\n        twist: 6D twist vector [v; \u03c9] (linear velocity, angular velocity)\n        momentum: 6D momentum vector [p; L] or [f; \u03c4] (linear, angular)\n\n    Example:\n        Compute the bias force (Coriolis + centrifugal) for rigid body dynamics::\n\n            import openscvx as ox\n\n            twist = ox.State(\"twist\", shape=(6,))\n            M = ox.Parameter(\"M\", shape=(6, 6), value=inertia_matrix)\n\n            momentum = M @ twist\n            bias_force = ox.lie.AdjointDual(twist, momentum)\n\n            # In dynamics: twist_dot = M_inv @ (wrench - bias_force)\n\n    Note:\n        The coadjoint is related to the adjoint by: ad*_\u03be = -(ad_\u03be)^T\n\n        For the special case of pure rotation (v=0) with diagonal inertia,\n        the angular part reduces to the familiar \u03c9 \u00d7 (J @ \u03c9) term.\n\n    See Also:\n        Adjoint: The adjoint operator for twist-on-twist action\n        SSM: 3x3 skew-symmetric matrix for cross products\n    \"\"\"\n\n    def __init__(self, twist, momentum):\n        \"\"\"Initialize a coadjoint operator.\n\n        Args:\n            twist: 6D twist vector [v; \u03c9] with shape (6,)\n            momentum: 6D momentum vector [p; L] with shape (6,)\n        \"\"\"\n        self.twist = to_expr(twist)\n        self.momentum = to_expr(momentum)\n\n    def children(self):\n        return [self.twist, self.momentum]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        twist = self.twist.canonicalize()\n        momentum = self.momentum.canonicalize()\n        return AdjointDual(twist, momentum)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that inputs are 6D vectors and return output shape.\n\n        Returns:\n            tuple: Shape (6,) for the resulting coadjoint vector\n\n        Raises:\n            ValueError: If twist or momentum do not have shape (6,)\n        \"\"\"\n        twist_shape = self.twist.check_shape()\n        momentum_shape = self.momentum.check_shape()\n\n        if twist_shape != (6,):\n            raise ValueError(f\"AdjointDual expects twist with shape (6,), got {twist_shape}\")\n        if momentum_shape != (6,):\n            raise ValueError(f\"AdjointDual expects momentum with shape (6,), got {momentum_shape}\")\n\n        return (6,)\n\n    def __repr__(self):\n        return f\"ad_dual({self.twist!r}, {self.momentum!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/lie/adjoint/#openscvx.symbolic.expr.lie.adjoint.AdjointDual.__init__","title":"<code>__init__(twist, momentum)</code>","text":"<p>Initialize a coadjoint operator.</p> <p>Parameters:</p> Name Type Description Default <code>twist</code> <p>6D twist vector [v; \u03c9] with shape (6,)</p> required <code>momentum</code> <p>6D momentum vector [p; L] with shape (6,)</p> required Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def __init__(self, twist, momentum):\n    \"\"\"Initialize a coadjoint operator.\n\n    Args:\n        twist: 6D twist vector [v; \u03c9] with shape (6,)\n        momentum: 6D momentum vector [p; L] with shape (6,)\n    \"\"\"\n    self.twist = to_expr(twist)\n    self.momentum = to_expr(momentum)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/adjoint/#openscvx.symbolic.expr.lie.adjoint.AdjointDual.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that inputs are 6D vectors and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (6,) for the resulting coadjoint vector</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If twist or momentum do not have shape (6,)</p> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that inputs are 6D vectors and return output shape.\n\n    Returns:\n        tuple: Shape (6,) for the resulting coadjoint vector\n\n    Raises:\n        ValueError: If twist or momentum do not have shape (6,)\n    \"\"\"\n    twist_shape = self.twist.check_shape()\n    momentum_shape = self.momentum.check_shape()\n\n    if twist_shape != (6,):\n        raise ValueError(f\"AdjointDual expects twist with shape (6,), got {twist_shape}\")\n    if momentum_shape != (6,):\n        raise ValueError(f\"AdjointDual expects momentum with shape (6,), got {momentum_shape}\")\n\n    return (6,)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/adjoint/#openscvx.symbolic.expr.lie.adjoint.SE3Adjoint","title":"<code>SE3Adjoint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>SE(3) Adjoint representation Ad_T for transforming twists between frames.</p> <p>Computes the 6\u00d76 adjoint matrix Ad_T that transforms twists from one coordinate frame to another. Given a transformation T_ab from frame A to frame B, the adjoint transforms a twist expressed in frame A to frame B:</p> <pre><code>\u03be_b = Ad_{T_ab} @ \u03be_a\n</code></pre> <p>For SE(3), given T with rotation R and translation p:</p> <pre><code>Ad_T = [ R      0   ]\n       [ [p]\u00d7R  R   ]\n</code></pre> <p>where [p]\u00d7 is the 3\u00d73 skew-symmetric matrix of p.</p> <p>This is essential for:</p> <ul> <li>Velocity propagation through kinematic chains</li> <li>Computing geometric Jacobians for manipulators</li> <li>Recursive Newton-Euler dynamics algorithms</li> </ul> <p>Attributes:</p> Name Type Description <code>transform</code> <p>4\u00d74 homogeneous transformation matrix</p> Example <p>Transform a body twist to the world frame::</p> <pre><code>import openscvx as ox\n\nT_world_body = forward_kinematics(q)  # 4\u00d74 transform\ntwist_body = ox.State(\"twist_body\", shape=(6,))\n\n# Transform twist to world frame\nAd_T = ox.lie.SE3Adjoint(T_world_body)  # 6\u00d76 matrix\ntwist_world = Ad_T @ twist_body\n</code></pre> <p>Compute geometric Jacobian columns::</p> <pre><code># Each column of the geometric Jacobian is Ad_{T_0i} @ \u03be_i\nJ_col_i = ox.lie.SE3Adjoint(T_0_to_i) @ screw_axis_i\n</code></pre> Note <p>The adjoint satisfies: Ad_{T1 @ T2} = Ad_{T1} @ Ad_{T2}</p> See Also <ul> <li>SE3AdjointDual: For transforming wrenches between frames</li> <li>Adjoint: The small adjoint (Lie bracket) for twist-on-twist action</li> </ul> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>class SE3Adjoint(Expr):\n    \"\"\"SE(3) Adjoint representation Ad_T for transforming twists between frames.\n\n    Computes the 6\u00d76 adjoint matrix Ad_T that transforms twists from one\n    coordinate frame to another. Given a transformation T_ab from frame A to\n    frame B, the adjoint transforms a twist expressed in frame A to frame B:\n\n        \u03be_b = Ad_{T_ab} @ \u03be_a\n\n    For SE(3), given T with rotation R and translation p:\n\n        Ad_T = [ R      0   ]\n               [ [p]\u00d7R  R   ]\n\n    where [p]\u00d7 is the 3\u00d73 skew-symmetric matrix of p.\n\n    This is essential for:\n\n    - Velocity propagation through kinematic chains\n    - Computing geometric Jacobians for manipulators\n    - Recursive Newton-Euler dynamics algorithms\n\n    Attributes:\n        transform: 4\u00d74 homogeneous transformation matrix\n\n    Example:\n        Transform a body twist to the world frame::\n\n            import openscvx as ox\n\n            T_world_body = forward_kinematics(q)  # 4\u00d74 transform\n            twist_body = ox.State(\"twist_body\", shape=(6,))\n\n            # Transform twist to world frame\n            Ad_T = ox.lie.SE3Adjoint(T_world_body)  # 6\u00d76 matrix\n            twist_world = Ad_T @ twist_body\n\n        Compute geometric Jacobian columns::\n\n            # Each column of the geometric Jacobian is Ad_{T_0i} @ \u03be_i\n            J_col_i = ox.lie.SE3Adjoint(T_0_to_i) @ screw_axis_i\n\n    Note:\n        The adjoint satisfies: Ad_{T1 @ T2} = Ad_{T1} @ Ad_{T2}\n\n    See Also:\n        - SE3AdjointDual: For transforming wrenches between frames\n        - Adjoint: The small adjoint (Lie bracket) for twist-on-twist action\n    \"\"\"\n\n    def __init__(self, transform):\n        \"\"\"Initialize SE3 Adjoint operator.\n\n        Args:\n            transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n        \"\"\"\n        self.transform = to_expr(transform)\n\n    def children(self):\n        return [self.transform]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        transform = self.transform.canonicalize()\n        return SE3Adjoint(transform)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 4\u00d74 matrix and return output shape.\n\n        Returns:\n            tuple: Shape (6, 6) for the adjoint matrix\n\n        Raises:\n            ValueError: If transform does not have shape (4, 4)\n        \"\"\"\n        transform_shape = self.transform.check_shape()\n        if transform_shape != (4, 4):\n            raise ValueError(\n                f\"SE3Adjoint expects transform with shape (4, 4), got {transform_shape}\"\n            )\n        return (6, 6)\n\n    def __repr__(self):\n        return f\"Ad({self.transform!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/lie/adjoint/#openscvx.symbolic.expr.lie.adjoint.SE3Adjoint.__init__","title":"<code>__init__(transform)</code>","text":"<p>Initialize SE3 Adjoint operator.</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <p>4\u00d74 homogeneous transformation matrix with shape (4, 4)</p> required Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def __init__(self, transform):\n    \"\"\"Initialize SE3 Adjoint operator.\n\n    Args:\n        transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n    \"\"\"\n    self.transform = to_expr(transform)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/adjoint/#openscvx.symbolic.expr.lie.adjoint.SE3Adjoint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 4\u00d74 matrix and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (6, 6) for the adjoint matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If transform does not have shape (4, 4)</p> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 4\u00d74 matrix and return output shape.\n\n    Returns:\n        tuple: Shape (6, 6) for the adjoint matrix\n\n    Raises:\n        ValueError: If transform does not have shape (4, 4)\n    \"\"\"\n    transform_shape = self.transform.check_shape()\n    if transform_shape != (4, 4):\n        raise ValueError(\n            f\"SE3Adjoint expects transform with shape (4, 4), got {transform_shape}\"\n        )\n    return (6, 6)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/adjoint/#openscvx.symbolic.expr.lie.adjoint.SE3AdjointDual","title":"<code>SE3AdjointDual</code>","text":"<p>               Bases: <code>Expr</code></p> <p>SE(3) coadjoint representation Ad*_T for transforming wrenches between frames.</p> <p>Computes the 6\u00d76 coadjoint matrix Ad*_T that transforms wrenches from one coordinate frame to another. Given a transformation T_ab from frame A to frame B, the coadjoint transforms a wrench expressed in frame B to frame A:</p> <pre><code>F_a = Ad*_{T_ab} @ F_b\n</code></pre> <p>For SE(3), given T with rotation R and translation p:</p> <pre><code>Ad*_T = [ R     [p]\u00d7R ]\n        [ 0       R   ]\n</code></pre> <p>This is the transpose-inverse of Ad_T: Ad*_T = (Ad_T)^{-T}</p> <p>This is essential for:</p> <ul> <li>Force/torque propagation in dynamics</li> <li>Transforming wrenches between end-effector and base frames</li> <li>Recursive Newton-Euler dynamics algorithms</li> </ul> <p>Attributes:</p> Name Type Description <code>transform</code> <p>4\u00d74 homogeneous transformation matrix</p> Example <p>Transform a wrench from end-effector to base frame::</p> <pre><code>import openscvx as ox\n\nT_base_ee = forward_kinematics(q)  # 4\u00d74 transform\nwrench_ee = ox.Control(\"wrench_ee\", shape=(6,))\n\n# Transform wrench to base frame\nAd_star_T = ox.lie.SE3AdjointDual(T_base_ee)  # 6\u00d76 matrix\nwrench_base = Ad_star_T @ wrench_ee\n</code></pre> Note <p>The coadjoint is related to the adjoint by: Ad*_T = (Ad_T)^{-T}</p> See Also <ul> <li>SE3Adjoint: For transforming twists between frames</li> <li>AdjointDual: The small coadjoint for Coriolis/centrifugal forces</li> </ul> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>class SE3AdjointDual(Expr):\n    \"\"\"SE(3) coadjoint representation Ad*_T for transforming wrenches between frames.\n\n    Computes the 6\u00d76 coadjoint matrix Ad*_T that transforms wrenches from one\n    coordinate frame to another. Given a transformation T_ab from frame A to\n    frame B, the coadjoint transforms a wrench expressed in frame B to frame A:\n\n        F_a = Ad*_{T_ab} @ F_b\n\n    For SE(3), given T with rotation R and translation p:\n\n        Ad*_T = [ R     [p]\u00d7R ]\n                [ 0       R   ]\n\n    This is the transpose-inverse of Ad_T: Ad*_T = (Ad_T)^{-T}\n\n    This is essential for:\n\n    - Force/torque propagation in dynamics\n    - Transforming wrenches between end-effector and base frames\n    - Recursive Newton-Euler dynamics algorithms\n\n    Attributes:\n        transform: 4\u00d74 homogeneous transformation matrix\n\n    Example:\n        Transform a wrench from end-effector to base frame::\n\n            import openscvx as ox\n\n            T_base_ee = forward_kinematics(q)  # 4\u00d74 transform\n            wrench_ee = ox.Control(\"wrench_ee\", shape=(6,))\n\n            # Transform wrench to base frame\n            Ad_star_T = ox.lie.SE3AdjointDual(T_base_ee)  # 6\u00d76 matrix\n            wrench_base = Ad_star_T @ wrench_ee\n\n    Note:\n        The coadjoint is related to the adjoint by: Ad*_T = (Ad_T)^{-T}\n\n    See Also:\n        - SE3Adjoint: For transforming twists between frames\n        - AdjointDual: The small coadjoint for Coriolis/centrifugal forces\n    \"\"\"\n\n    def __init__(self, transform):\n        \"\"\"Initialize SE3 coadjoint operator.\n\n        Args:\n            transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n        \"\"\"\n        self.transform = to_expr(transform)\n\n    def children(self):\n        return [self.transform]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        transform = self.transform.canonicalize()\n        return SE3AdjointDual(transform)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 4\u00d74 matrix and return output shape.\n\n        Returns:\n            tuple: Shape (6, 6) for the coadjoint matrix\n\n        Raises:\n            ValueError: If transform does not have shape (4, 4)\n        \"\"\"\n        transform_shape = self.transform.check_shape()\n        if transform_shape != (4, 4):\n            raise ValueError(\n                f\"SE3AdjointDual expects transform with shape (4, 4), got {transform_shape}\"\n            )\n        return (6, 6)\n\n    def __repr__(self):\n        return f\"Ad_dual({self.transform!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/lie/adjoint/#openscvx.symbolic.expr.lie.adjoint.SE3AdjointDual.__init__","title":"<code>__init__(transform)</code>","text":"<p>Initialize SE3 coadjoint operator.</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <p>4\u00d74 homogeneous transformation matrix with shape (4, 4)</p> required Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def __init__(self, transform):\n    \"\"\"Initialize SE3 coadjoint operator.\n\n    Args:\n        transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n    \"\"\"\n    self.transform = to_expr(transform)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/adjoint/#openscvx.symbolic.expr.lie.adjoint.SE3AdjointDual.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 4\u00d74 matrix and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (6, 6) for the coadjoint matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If transform does not have shape (4, 4)</p> Source code in <code>openscvx/symbolic/expr/lie/adjoint.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 4\u00d74 matrix and return output shape.\n\n    Returns:\n        tuple: Shape (6, 6) for the coadjoint matrix\n\n    Raises:\n        ValueError: If transform does not have shape (4, 4)\n    \"\"\"\n    transform_shape = self.transform.check_shape()\n    if transform_shape != (4, 4):\n        raise ValueError(\n            f\"SE3AdjointDual expects transform with shape (4, 4), got {transform_shape}\"\n        )\n    return (6, 6)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/se3/","title":"se3","text":"<p>SE(3) Lie group operations for rigid body transformations.</p> <p>This module provides exponential and logarithm maps for the SE(3) rigid transformation group, enabling twist to transformation matrix conversions and vice versa. These are essential for Product of Exponentials (PoE) forward kinematics in robotic manipulators.</p> <p>Requires jaxlie: pip install openscvx[lie]</p> Note <p>The twist convention [v; \u03c9] (linear first, angular second) matches jaxlie's SE3 tangent parameterization, so no reordering is needed during lowering.</p>"},{"location":"reference/symbolic/expr/lie/se3/#openscvx.symbolic.expr.lie.se3.SE3Exp","title":"<code>SE3Exp</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Exponential map from se(3) twist to SE(3) transformation matrix.</p> <p>Maps a 6D twist vector to a 4\u00d74 homogeneous transformation matrix. Uses jaxlie for numerically robust implementation with proper handling of small angles and translations.</p> <p>The twist \u03be = [v; \u03c9] follows the convention:</p> <ul> <li>v: 3D linear velocity component</li> <li>\u03c9: 3D angular velocity component</li> </ul> <p>This is the key operation for Product of Exponentials (PoE) forward kinematics in robotic manipulators.</p> <p>Attributes:</p> Name Type Description <code>twist</code> <p>6D twist vector [v; \u03c9] with shape (6,)</p> Example <p>Product of Exponentials forward kinematics::</p> <pre><code>import openscvx as ox\nimport numpy as np\n\n# Screw axis for revolute joint about z-axis at origin\nscrew_axis = np.array([0, 0, 0, 0, 0, 1])  # [v; \u03c9]\ntheta = ox.State(\"theta\", shape=(1,))\n\n# Joint transformation\nT = ox.lie.SE3Exp(ox.Constant(screw_axis) * theta)  # 4\u00d74 matrix\n\n# Chain multiple joints\nT_01 = ox.lie.SE3Exp(screw1 * q1)\nT_12 = ox.lie.SE3Exp(screw2 * q2)\nT_02 = T_01 @ T_12\n</code></pre> <p>Extract position from transformation::</p> <pre><code>T_ee = forward_kinematics(joint_angles)\np_ee = T_ee[:3, 3]  # End-effector position\n</code></pre> Note <p>The twist convention [v; \u03c9] matches jaxlie's SE3 tangent parameterization, so no reordering is performed.</p> See Also <ul> <li>SE3Log: Inverse operation (transformation matrix to twist)</li> <li>SO3Exp: Rotation-only exponential map</li> <li>AdjointDual: For dynamics computations with twists</li> </ul> Source code in <code>openscvx/symbolic/expr/lie/se3.py</code> <pre><code>class SE3Exp(Expr):\n    \"\"\"Exponential map from se(3) twist to SE(3) transformation matrix.\n\n    Maps a 6D twist vector to a 4\u00d74 homogeneous transformation matrix.\n    Uses jaxlie for numerically robust implementation with proper handling\n    of small angles and translations.\n\n    The twist \u03be = [v; \u03c9] follows the convention:\n\n    - v: 3D linear velocity component\n    - \u03c9: 3D angular velocity component\n\n    This is the key operation for Product of Exponentials (PoE) forward\n    kinematics in robotic manipulators.\n\n    Attributes:\n        twist: 6D twist vector [v; \u03c9] with shape (6,)\n\n    Example:\n        Product of Exponentials forward kinematics::\n\n            import openscvx as ox\n            import numpy as np\n\n            # Screw axis for revolute joint about z-axis at origin\n            screw_axis = np.array([0, 0, 0, 0, 0, 1])  # [v; \u03c9]\n            theta = ox.State(\"theta\", shape=(1,))\n\n            # Joint transformation\n            T = ox.lie.SE3Exp(ox.Constant(screw_axis) * theta)  # 4\u00d74 matrix\n\n            # Chain multiple joints\n            T_01 = ox.lie.SE3Exp(screw1 * q1)\n            T_12 = ox.lie.SE3Exp(screw2 * q2)\n            T_02 = T_01 @ T_12\n\n        Extract position from transformation::\n\n            T_ee = forward_kinematics(joint_angles)\n            p_ee = T_ee[:3, 3]  # End-effector position\n\n    Note:\n        The twist convention [v; \u03c9] matches jaxlie's SE3 tangent\n        parameterization, so no reordering is performed.\n\n    See Also:\n        - SE3Log: Inverse operation (transformation matrix to twist)\n        - SO3Exp: Rotation-only exponential map\n        - AdjointDual: For dynamics computations with twists\n    \"\"\"\n\n    def __init__(self, twist):\n        \"\"\"Initialize SE3 exponential map.\n\n        Args:\n            twist: 6D twist vector [v; \u03c9] with shape (6,)\n        \"\"\"\n        self.twist = to_expr(twist)\n\n    def children(self):\n        return [self.twist]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        twist = self.twist.canonicalize()\n        return SE3Exp(twist)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 6D vector and return output shape.\n\n        Returns:\n            tuple: Shape (4, 4) for the homogeneous transformation matrix\n\n        Raises:\n            ValueError: If twist does not have shape (6,)\n        \"\"\"\n        twist_shape = self.twist.check_shape()\n        if twist_shape != (6,):\n            raise ValueError(f\"SE3Exp expects twist with shape (6,), got {twist_shape}\")\n        return (4, 4)\n\n    def __repr__(self):\n        return f\"SE3Exp({self.twist!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/lie/se3/#openscvx.symbolic.expr.lie.se3.SE3Exp.__init__","title":"<code>__init__(twist)</code>","text":"<p>Initialize SE3 exponential map.</p> <p>Parameters:</p> Name Type Description Default <code>twist</code> <p>6D twist vector [v; \u03c9] with shape (6,)</p> required Source code in <code>openscvx/symbolic/expr/lie/se3.py</code> <pre><code>def __init__(self, twist):\n    \"\"\"Initialize SE3 exponential map.\n\n    Args:\n        twist: 6D twist vector [v; \u03c9] with shape (6,)\n    \"\"\"\n    self.twist = to_expr(twist)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/se3/#openscvx.symbolic.expr.lie.se3.SE3Exp.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 6D vector and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (4, 4) for the homogeneous transformation matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If twist does not have shape (6,)</p> Source code in <code>openscvx/symbolic/expr/lie/se3.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 6D vector and return output shape.\n\n    Returns:\n        tuple: Shape (4, 4) for the homogeneous transformation matrix\n\n    Raises:\n        ValueError: If twist does not have shape (6,)\n    \"\"\"\n    twist_shape = self.twist.check_shape()\n    if twist_shape != (6,):\n        raise ValueError(f\"SE3Exp expects twist with shape (6,), got {twist_shape}\")\n    return (4, 4)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/se3/#openscvx.symbolic.expr.lie.se3.SE3Log","title":"<code>SE3Log</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Logarithm map from SE(3) transformation matrix to se(3) twist.</p> <p>Maps a 4\u00d74 homogeneous transformation matrix to a 6D twist vector. Uses jaxlie for numerically robust implementation.</p> <p>The output twist \u03be = [v; \u03c9] follows the convention:</p> <ul> <li>v: 3D linear component</li> <li>\u03c9: 3D angular component (rotation vector)</li> </ul> <p>This is useful for computing error metrics between poses in optimization.</p> <p>Attributes:</p> Name Type Description <code>transform</code> <p>4\u00d74 homogeneous transformation matrix with shape (4, 4)</p> Example <p>Compute pose error for trajectory optimization::</p> <pre><code>import openscvx as ox\n\nT_current = forward_kinematics(q)\nT_target = ox.Parameter(\"T_target\", shape=(4, 4), value=goal_pose)\n\n# Relative transformation\nT_error = ox.linalg.inv(T_target) @ T_current\n\n# Convert to twist for error metric\ntwist_error = ox.lie.SE3Log(T_error)\npose_cost = ox.linalg.Norm(twist_error) ** 2\n</code></pre> See Also <ul> <li>SE3Exp: Inverse operation (twist to transformation matrix)</li> <li>SO3Log: Rotation-only logarithm map</li> </ul> Source code in <code>openscvx/symbolic/expr/lie/se3.py</code> <pre><code>class SE3Log(Expr):\n    \"\"\"Logarithm map from SE(3) transformation matrix to se(3) twist.\n\n    Maps a 4\u00d74 homogeneous transformation matrix to a 6D twist vector.\n    Uses jaxlie for numerically robust implementation.\n\n    The output twist \u03be = [v; \u03c9] follows the convention:\n\n    - v: 3D linear component\n    - \u03c9: 3D angular component (rotation vector)\n\n    This is useful for computing error metrics between poses in optimization.\n\n    Attributes:\n        transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n\n    Example:\n        Compute pose error for trajectory optimization::\n\n            import openscvx as ox\n\n            T_current = forward_kinematics(q)\n            T_target = ox.Parameter(\"T_target\", shape=(4, 4), value=goal_pose)\n\n            # Relative transformation\n            T_error = ox.linalg.inv(T_target) @ T_current\n\n            # Convert to twist for error metric\n            twist_error = ox.lie.SE3Log(T_error)\n            pose_cost = ox.linalg.Norm(twist_error) ** 2\n\n    See Also:\n        - SE3Exp: Inverse operation (twist to transformation matrix)\n        - SO3Log: Rotation-only logarithm map\n    \"\"\"\n\n    def __init__(self, transform):\n        \"\"\"Initialize SE3 logarithm map.\n\n        Args:\n            transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n        \"\"\"\n        self.transform = to_expr(transform)\n\n    def children(self):\n        return [self.transform]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        transform = self.transform.canonicalize()\n        return SE3Log(transform)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 4\u00d74 matrix and return output shape.\n\n        Returns:\n            tuple: Shape (6,) for the twist vector\n\n        Raises:\n            ValueError: If transform does not have shape (4, 4)\n        \"\"\"\n        transform_shape = self.transform.check_shape()\n        if transform_shape != (4, 4):\n            raise ValueError(f\"SE3Log expects transform with shape (4, 4), got {transform_shape}\")\n        return (6,)\n\n    def __repr__(self):\n        return f\"SE3Log({self.transform!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/lie/se3/#openscvx.symbolic.expr.lie.se3.SE3Log.__init__","title":"<code>__init__(transform)</code>","text":"<p>Initialize SE3 logarithm map.</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <p>4\u00d74 homogeneous transformation matrix with shape (4, 4)</p> required Source code in <code>openscvx/symbolic/expr/lie/se3.py</code> <pre><code>def __init__(self, transform):\n    \"\"\"Initialize SE3 logarithm map.\n\n    Args:\n        transform: 4\u00d74 homogeneous transformation matrix with shape (4, 4)\n    \"\"\"\n    self.transform = to_expr(transform)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/se3/#openscvx.symbolic.expr.lie.se3.SE3Log.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 4\u00d74 matrix and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (6,) for the twist vector</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If transform does not have shape (4, 4)</p> Source code in <code>openscvx/symbolic/expr/lie/se3.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 4\u00d74 matrix and return output shape.\n\n    Returns:\n        tuple: Shape (6,) for the twist vector\n\n    Raises:\n        ValueError: If transform does not have shape (4, 4)\n    \"\"\"\n    transform_shape = self.transform.check_shape()\n    if transform_shape != (4, 4):\n        raise ValueError(f\"SE3Log expects transform with shape (4, 4), got {transform_shape}\")\n    return (6,)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/so3/","title":"so3","text":"<p>SO(3) Lie group operations for rotation matrices.</p> <p>This module provides exponential and logarithm maps for the SO(3) rotation group, enabling axis-angle to rotation matrix conversions and vice versa.</p> <p>Requires jaxlie: pip install openscvx[lie]</p>"},{"location":"reference/symbolic/expr/lie/so3/#openscvx.symbolic.expr.lie.so3.SO3Exp","title":"<code>SO3Exp</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Exponential map from so(3) to SO(3) rotation matrix.</p> <p>Maps a 3D rotation vector (axis-angle representation) to a 3\u00d73 rotation matrix using the Rodrigues formula. Uses jaxlie for numerically robust implementation with proper handling of small angles.</p> <p>The rotation vector \u03c9 has direction equal to the rotation axis and magnitude equal to the rotation angle in radians.</p> <p>Attributes:</p> Name Type Description <code>omega</code> <p>3D rotation vector with shape (3,)</p> Example <p>Create a rotation about the z-axis::</p> <pre><code>import openscvx as ox\nimport numpy as np\n\n# 90 degree rotation about z\nomega = ox.Constant(np.array([0, 0, np.pi/2]))\nR = ox.lie.SO3Exp(omega)  # 3\u00d73 rotation matrix\n</code></pre> <p>Parameterized rotation for optimization::</p> <pre><code>theta = ox.State(\"theta\", shape=(1,))\naxis = ox.Constant(np.array([0, 0, 1]))  # z-axis\nR = ox.lie.SO3Exp(axis * theta)\n</code></pre> See Also <ul> <li>SO3Log: Inverse operation (rotation matrix to rotation vector)</li> <li>SE3Exp: Full rigid body transformation including translation</li> </ul> Source code in <code>openscvx/symbolic/expr/lie/so3.py</code> <pre><code>class SO3Exp(Expr):\n    \"\"\"Exponential map from so(3) to SO(3) rotation matrix.\n\n    Maps a 3D rotation vector (axis-angle representation) to a 3\u00d73 rotation\n    matrix using the Rodrigues formula. Uses jaxlie for numerically robust\n    implementation with proper handling of small angles.\n\n    The rotation vector \u03c9 has direction equal to the rotation axis and\n    magnitude equal to the rotation angle in radians.\n\n    Attributes:\n        omega: 3D rotation vector with shape (3,)\n\n    Example:\n        Create a rotation about the z-axis::\n\n            import openscvx as ox\n            import numpy as np\n\n            # 90 degree rotation about z\n            omega = ox.Constant(np.array([0, 0, np.pi/2]))\n            R = ox.lie.SO3Exp(omega)  # 3\u00d73 rotation matrix\n\n        Parameterized rotation for optimization::\n\n            theta = ox.State(\"theta\", shape=(1,))\n            axis = ox.Constant(np.array([0, 0, 1]))  # z-axis\n            R = ox.lie.SO3Exp(axis * theta)\n\n    See Also:\n        - SO3Log: Inverse operation (rotation matrix to rotation vector)\n        - SE3Exp: Full rigid body transformation including translation\n    \"\"\"\n\n    def __init__(self, omega):\n        \"\"\"Initialize SO3 exponential map.\n\n        Args:\n            omega: 3D rotation vector (axis \u00d7 angle) with shape (3,)\n        \"\"\"\n        self.omega = to_expr(omega)\n\n    def children(self):\n        return [self.omega]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        omega = self.omega.canonicalize()\n        return SO3Exp(omega)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 3D vector and return output shape.\n\n        Returns:\n            tuple: Shape (3, 3) for the rotation matrix\n\n        Raises:\n            ValueError: If omega does not have shape (3,)\n        \"\"\"\n        omega_shape = self.omega.check_shape()\n        if omega_shape != (3,):\n            raise ValueError(f\"SO3Exp expects omega with shape (3,), got {omega_shape}\")\n        return (3, 3)\n\n    def __repr__(self):\n        return f\"SO3Exp({self.omega!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/lie/so3/#openscvx.symbolic.expr.lie.so3.SO3Exp.__init__","title":"<code>__init__(omega)</code>","text":"<p>Initialize SO3 exponential map.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <p>3D rotation vector (axis \u00d7 angle) with shape (3,)</p> required Source code in <code>openscvx/symbolic/expr/lie/so3.py</code> <pre><code>def __init__(self, omega):\n    \"\"\"Initialize SO3 exponential map.\n\n    Args:\n        omega: 3D rotation vector (axis \u00d7 angle) with shape (3,)\n    \"\"\"\n    self.omega = to_expr(omega)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/so3/#openscvx.symbolic.expr.lie.so3.SO3Exp.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 3D vector and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (3, 3) for the rotation matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If omega does not have shape (3,)</p> Source code in <code>openscvx/symbolic/expr/lie/so3.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 3D vector and return output shape.\n\n    Returns:\n        tuple: Shape (3, 3) for the rotation matrix\n\n    Raises:\n        ValueError: If omega does not have shape (3,)\n    \"\"\"\n    omega_shape = self.omega.check_shape()\n    if omega_shape != (3,):\n        raise ValueError(f\"SO3Exp expects omega with shape (3,), got {omega_shape}\")\n    return (3, 3)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/so3/#openscvx.symbolic.expr.lie.so3.SO3Log","title":"<code>SO3Log</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Logarithm map from SO(3) rotation matrix to so(3) rotation vector.</p> <p>Maps a 3\u00d73 rotation matrix to a 3D rotation vector (axis-angle representation). Uses jaxlie for numerically robust implementation.</p> <p>The output rotation vector \u03c9 has direction equal to the rotation axis and magnitude equal to the rotation angle in radians.</p> <p>Attributes:</p> Name Type Description <code>rotation</code> <p>3\u00d73 rotation matrix with shape (3, 3)</p> Example <p>Extract rotation vector from a rotation matrix::</p> <pre><code>import openscvx as ox\n\nR = ox.State(\"R\", shape=(3, 3))  # Rotation matrix state\nomega = ox.lie.SO3Log(R)  # 3D rotation vector\n</code></pre> See Also <ul> <li>SO3Exp: Inverse operation (rotation vector to rotation matrix)</li> <li>SE3Log: Full rigid body transformation logarithm</li> </ul> Source code in <code>openscvx/symbolic/expr/lie/so3.py</code> <pre><code>class SO3Log(Expr):\n    \"\"\"Logarithm map from SO(3) rotation matrix to so(3) rotation vector.\n\n    Maps a 3\u00d73 rotation matrix to a 3D rotation vector (axis-angle\n    representation). Uses jaxlie for numerically robust implementation.\n\n    The output rotation vector \u03c9 has direction equal to the rotation axis\n    and magnitude equal to the rotation angle in radians.\n\n    Attributes:\n        rotation: 3\u00d73 rotation matrix with shape (3, 3)\n\n    Example:\n        Extract rotation vector from a rotation matrix::\n\n            import openscvx as ox\n\n            R = ox.State(\"R\", shape=(3, 3))  # Rotation matrix state\n            omega = ox.lie.SO3Log(R)  # 3D rotation vector\n\n    See Also:\n        - SO3Exp: Inverse operation (rotation vector to rotation matrix)\n        - SE3Log: Full rigid body transformation logarithm\n    \"\"\"\n\n    def __init__(self, rotation):\n        \"\"\"Initialize SO3 logarithm map.\n\n        Args:\n            rotation: 3\u00d73 rotation matrix with shape (3, 3)\n        \"\"\"\n        self.rotation = to_expr(rotation)\n\n    def children(self):\n        return [self.rotation]\n\n    def canonicalize(self) -&gt; \"Expr\":\n        rotation = self.rotation.canonicalize()\n        return SO3Log(rotation)\n\n    def check_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"Check that input is a 3\u00d73 matrix and return output shape.\n\n        Returns:\n            tuple: Shape (3,) for the rotation vector\n\n        Raises:\n            ValueError: If rotation does not have shape (3, 3)\n        \"\"\"\n        rotation_shape = self.rotation.check_shape()\n        if rotation_shape != (3, 3):\n            raise ValueError(f\"SO3Log expects rotation with shape (3, 3), got {rotation_shape}\")\n        return (3,)\n\n    def __repr__(self):\n        return f\"SO3Log({self.rotation!r})\"\n</code></pre>"},{"location":"reference/symbolic/expr/lie/so3/#openscvx.symbolic.expr.lie.so3.SO3Log.__init__","title":"<code>__init__(rotation)</code>","text":"<p>Initialize SO3 logarithm map.</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <p>3\u00d73 rotation matrix with shape (3, 3)</p> required Source code in <code>openscvx/symbolic/expr/lie/so3.py</code> <pre><code>def __init__(self, rotation):\n    \"\"\"Initialize SO3 logarithm map.\n\n    Args:\n        rotation: 3\u00d73 rotation matrix with shape (3, 3)\n    \"\"\"\n    self.rotation = to_expr(rotation)\n</code></pre>"},{"location":"reference/symbolic/expr/lie/so3/#openscvx.symbolic.expr.lie.so3.SO3Log.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Check that input is a 3\u00d73 matrix and return output shape.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Shape (3,) for the rotation vector</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If rotation does not have shape (3, 3)</p> Source code in <code>openscvx/symbolic/expr/lie/so3.py</code> <pre><code>def check_shape(self) -&gt; Tuple[int, ...]:\n    \"\"\"Check that input is a 3\u00d73 matrix and return output shape.\n\n    Returns:\n        tuple: Shape (3,) for the rotation vector\n\n    Raises:\n        ValueError: If rotation does not have shape (3, 3)\n    \"\"\"\n    rotation_shape = self.rotation.check_shape()\n    if rotation_shape != (3, 3):\n        raise ValueError(f\"SO3Log expects rotation with shape (3, 3), got {rotation_shape}\")\n    return (3,)\n</code></pre>"},{"location":"reference/symbolic/lowerers/","title":"lowerers","text":"<p>Lowering backends for converting symbolic expressions to executable code.</p> <p>This package contains backend implementations that translate openscvx's symbolic expression AST into executable code for different computational frameworks. The lowering process is a compilation step that happens after symbolic problem construction but before numerical optimization.</p> Architecture <p>All lowerers in this package follow a common visitor pattern:</p> <ol> <li>Visitor Pattern: Each backend defines visitor methods for each expression    type, registered via the @visitor decorator</li> <li>Recursive Lowering: Visitors recursively lower child expressions and    compose backend-specific operations</li> <li>Centralized Dispatch: The dispatch() function routes expressions to    their registered visitor methods</li> <li>Type Safety: Each visitor is strongly typed to its backend's output format</li> </ol> Available Backends <ul> <li>jax: Lowers to JAX functions with automatic differentiation support</li> <li>cvxpy: Lowers to CVXPy expressions for disciplined convex programming</li> </ul> <p>See individual backend modules for detailed documentation and usage examples.</p> For Contributors <p>Adding a New Backend</p> <p>To add a new lowering backend:</p> <ol> <li> <p>Create a new module in this package (e.g., <code>mybackend.py</code>)</p> </li> <li> <p>Implement the visitor pattern::</p> <p>from typing import Dict, Type, Callable, Any from openscvx.symbolic.expr import Expr</p> <p>_MYBACKEND_VISITORS: Dict[Type[Expr], Callable] = {}</p> <p>def visitor(expr_cls: Type[Expr]):     '''Decorator to register visitor methods.'''     def register(fn: Callable):         _MYBACKEND_VISITORS[expr_cls] = fn         return fn     return register</p> <p>def dispatch(lowerer: Any, expr: Expr):     '''Dispatch expression to registered visitor.'''     fn = MYBACKEND_VISITORS.get(type(expr))     if fn is None:         raise NotImplementedError(             f\"{lowerer.__class_.name} has no visitor for {type(expr).name}\"         )     return fn(lowerer, expr)</p> </li> <li> <p>Create the lowerer class::</p> <p>class MyBackendLowerer:     '''Lower symbolic expressions to MyBackend format.'''</p> <pre><code>def lower(self, expr: Expr):\n    '''Main entry point for lowering.'''\n    return dispatch(self, expr)\n\n@visitor(Constant)\ndef _visit_constant(self, node: Constant):\n    # Convert to backend representation\n    return mybackend.constant(node.value)\n\n@visitor(Add)\ndef _visit_add(self, node: Add):\n    # Recursively lower and combine\n    terms = [self.lower(t) for t in node.terms]\n    return mybackend.add(*terms)\n\n# Implement visitors for all expression types...\n</code></pre> </li> <li> <p>Add convenience wrapper::</p> <p>def lower_to_mybackend(expr: Expr, **kwargs):     '''Convenience function for lowering to MyBackend.'''     lowerer = MyBackendLowerer(**kwargs)     return lowerer.lower(expr)</p> </li> <li> <p>Document thoroughly - Follow the documentation patterns in jax.py    and cvxpy.py, including module docstring, class docstring, and method    docstrings for all visitor methods.</p> </li> </ol> <p>Key Design Patterns</p> <ul> <li>Use private method names for visitors: <code>_visit_*</code> (not part of public API)</li> <li>Recursively lower child expressions using <code>self.lower()</code></li> <li>Keep visitor methods stateless when possible</li> <li>Handle edge cases (scalars, empty arrays, etc.)</li> <li>Document mathematical properties and backend-specific constraints</li> </ul> <p>Adding Support for New Expression Types</p> <p>See the \"For Contributors\" sections in the existing backend modules for detailed guidance on adding visitor methods for new expression types.</p> See Also <ul> <li>openscvx.symbolic.lower: Main lowering orchestration functions</li> <li>openscvx.symbolic.expr: Symbolic expression AST definitions</li> <li>openscvx.symbolic.lowerers.jax: JAX backend documentation and implementation</li> <li>openscvx.symbolic.lowerers.cvxpy: CVXPy backend documentation and implementation</li> </ul>"},{"location":"reference/symbolic/lowerers/cvxpy/","title":"cvxpy","text":"<p>CVXPy backend for lowering symbolic expressions to CVXPy format.</p> <p>This module implements the CVXPy lowering backend that converts symbolic expression AST nodes into CVXPy expressions for convex optimization. The lowering uses a visitor pattern where each expression type has a corresponding visitor method.</p> Architecture <p>The CVXPy lowerer follows a visitor pattern with centralized registration:</p> <ol> <li>Visitor Registration: The @visitor decorator registers handler functions    for each expression type in the _CVXPY_VISITORS dictionary</li> <li>Dispatch: The dispatch() function looks up and calls the appropriate    visitor based on the expression's type</li> <li>Recursive Lowering: Each visitor recursively lowers child expressions    and composes CVXPy operations</li> <li>Translation Only: This module only translates expressions; CVXPy itself    validates DCP (Disciplined Convex Programming) rules when the problem is    constructed/solved</li> </ol> Key Features <ul> <li>Expression Translation: Converts symbolic AST to CVXPy expression format</li> <li>Variable Management: Maps symbolic States/Controls to CVXPy variables   through a variable_map dictionary</li> <li>Parameter Support: Handles both constant parameters and CVXPy Parameters   for efficient parameter sweeps</li> <li>Constraint Generation: Produces CVXPy constraint objects from symbolic   equality and inequality expressions</li> </ul> Backend Usage <p>CVXPy lowering is used for convex constraints in the SCP subproblem. Unlike JAX lowering (which happens early during problem construction), CVXPy lowering occurs later during Problem.initialize() when CVXPy variables are available. See lower_symbolic_expressions() in symbolic/lower.py for details.</p> CVXPy Variable Mapping <p>The lowerer requires a variable_map dictionary that maps symbolic variable names to CVXPy expressions. For trajectory optimization::</p> <pre><code>variable_map = {\n    \"x\": cvxpy.Variable((n_x,)),  # State vector\n    \"u\": cvxpy.Variable((n_u,)),  # Control vector\n    \"param_name\": cvxpy.Parameter((3,)),  # Runtime parameters\n}\n</code></pre> <p>States and Controls use their slices (assigned during unification) to extract the correct portion of the unified x and u vectors.</p> Example <p>Basic usage::</p> <pre><code>import cvxpy as cp\nfrom openscvx.symbolic.lowerers.cvxpy import CvxpyLowerer\nimport openscvx as ox\n\n# Create symbolic expression\nx = ox.State(\"x\", shape=(3,))\nu = ox.Control(\"u\", shape=(2,))\nexpr = ox.Norm(x)**2 + 0.1 * ox.Norm(u)**2\n\n# Create CVXPy variables\ncvx_x = cp.Variable(3)\ncvx_u = cp.Variable(2)\n\n# Lower to CVXPy\nlowerer = CvxpyLowerer(variable_map={\"x\": cvx_x, \"u\": cvx_u})\ncvx_expr = lowerer.lower(expr)\n\n# Use in optimization problem\nprob = cp.Problem(cp.Minimize(cvx_expr), constraints=[...])\nprob.solve()\n</code></pre> <p>Constraint lowering::</p> <pre><code># Symbolic constraint\nconstraint = ox.Norm(x) &lt;= 1.0\n\n# Lower to CVXPy constraint\ncvx_constraint = lowerer.lower(constraint)\n\n# Add to problem\nprob = cp.Problem(cp.Minimize(cost), constraints=[cvx_constraint])\n</code></pre> For Contributors <p>Adding Support for New Expression Types</p> <p>To add support for a new symbolic expression type to CVXPy lowering:</p> <ol> <li> <p>Define the visitor method in CvxpyLowerer with the @visitor decorator::</p> <p>@visitor(MyNewExpr) def _visit_my_new_expr(self, node: MyNewExpr) -&gt; cp.Expression:     # Lower child expressions recursively     operand = self.lower(node.operand)</p> <pre><code># Return CVXPy expression\nreturn cp.my_operation(operand)\n</code></pre> </li> <li> <p>Key requirements:</p> <ul> <li>Use the @visitor(ExprType) decorator to register the handler</li> <li>Method name should be visit (private, lowercase, snake_case) <li>Recursively lower all child expressions using self.lower()</li> <li>Return a cp.Expression or cp.Constraint object</li> <li>Use cp.* operations for CVXPy atoms</li> <li> <p>DCP considerations:</p> <ul> <li>This module only translates; CVXPy validates DCP rules</li> <li>Document the mathematical properties in the docstring (convex, concave, affine)</li> <li>For non-DCP operations, raise NotImplementedError with helpful message</li> <li>See _visit_sin, _visit_cos, _visit_ctcs for examples</li> </ul> </li> <li> <p>Example patterns:</p> <ul> <li>Unary operation: <code>return cp.my_func(self.lower(node.operand))</code></li> <li>Binary operation: <code>return self.lower(node.left) + self.lower(node.right)</code></li> <li>Constraints: <code>return self.lower(node.lhs) &lt;= self.lower(node.rhs)</code></li> <li>Not supported: Raise NotImplementedError with guidance</li> </ul> </li> <li> <p>Testing: Ensure your visitor works with:</p> <ul> <li>Simple expressions: Direct lowering to cp.Expression</li> <li>Constraint validation: CVXPy accepts the result</li> <li>DCP checking: CVXPy's problem.solve() validates correctly</li> </ul> </li> See Also <ul> <li>lower_to_cvxpy(): Convenience wrapper for single expression lowering</li> <li>JaxLowerer: Alternative backend for non-convex constraints and dynamics</li> <li>lower_symbolic_expressions(): Main orchestrator in symbolic/lower.py</li> <li>CVXPy documentation: https://www.cvxpy.org/</li> </ul>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer","title":"<code>CvxpyLowerer</code>","text":"<p>CVXPy backend for lowering symbolic expressions to disciplined convex programs.</p> <p>This class implements the visitor pattern for converting symbolic expression AST nodes to CVXPy expressions and constraints. Each expression type has a corresponding visitor method decorated with @visitor that handles the lowering logic.</p> <p>The lowering process is recursive: each visitor lowers its child expressions first, then composes them into a CVXPy operation. CVXPy will validate DCP (Disciplined Convex Programming) compliance when the problem is constructed.</p> <p>Attributes:</p> Name Type Description <code>variable_map</code> <code>dict</code> <p>Dictionary mapping variable names to CVXPy expressions. Must include \"x\" for states and \"u\" for controls. May include parameter names mapped to CVXPy Parameter objects or constants.</p> Example <p>Lower an expression to CVXPy:</p> <pre><code>import cvxpy as cp\nlowerer = CvxpyLowerer(variable_map={\n    \"x\": cp.Variable(3),\n    \"u\": cp.Variable(2),\n})\nexpr = ox.Norm(x)**2 + 0.1 * ox.Norm(u)**2\ncvx_expr = lowerer.lower(expr)\n</code></pre> Note <p>The lowerer is stateful (stores variable_map) unlike JaxLowerer which is stateless. Variables must be registered before lowering expressions that reference them.</p> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>class CvxpyLowerer:\n    \"\"\"CVXPy backend for lowering symbolic expressions to disciplined convex programs.\n\n    This class implements the visitor pattern for converting symbolic expression\n    AST nodes to CVXPy expressions and constraints. Each expression type has a\n    corresponding visitor method decorated with @visitor that handles the lowering\n    logic.\n\n    The lowering process is recursive: each visitor lowers its child expressions\n    first, then composes them into a CVXPy operation. CVXPy will validate DCP\n    (Disciplined Convex Programming) compliance when the problem is constructed.\n\n    Attributes:\n        variable_map (dict): Dictionary mapping variable names to CVXPy expressions.\n            Must include \"x\" for states and \"u\" for controls. May include parameter\n            names mapped to CVXPy Parameter objects or constants.\n\n    Example:\n        Lower an expression to CVXPy:\n\n            import cvxpy as cp\n            lowerer = CvxpyLowerer(variable_map={\n                \"x\": cp.Variable(3),\n                \"u\": cp.Variable(2),\n            })\n            expr = ox.Norm(x)**2 + 0.1 * ox.Norm(u)**2\n            cvx_expr = lowerer.lower(expr)\n\n    Note:\n        The lowerer is stateful (stores variable_map) unlike JaxLowerer which\n        is stateless. Variables must be registered before lowering expressions\n        that reference them.\n    \"\"\"\n\n    def __init__(self, variable_map: Dict[str, cp.Expression] = None):\n        \"\"\"Initialize the CVXPy lowerer.\n\n        Args:\n            variable_map: Dictionary mapping variable names to CVXPy expressions.\n                For State/Control objects, keys should be \"x\" and \"u\" respectively.\n                For Parameter objects, keys should match their names. If None, an\n                empty dictionary is created.\n\n        Example:\n            Initialize the CVXPy lowerer with the variable map:\n\n                cvx_x = cp.Variable(3, name=\"x\")\n                cvx_u = cp.Variable(2, name=\"u\")\n                lowerer = CvxpyLowerer({\"x\": cvx_x, \"u\": cvx_u})\n        \"\"\"\n        self.variable_map = variable_map or {}\n\n    def lower(self, expr: Expr) -&gt; cp.Expression:\n        \"\"\"Lower a symbolic expression to a CVXPy expression.\n\n        Main entry point for lowering. Delegates to dispatch() which looks up\n        the appropriate visitor method based on the expression type.\n\n        Args:\n            expr: Symbolic expression to lower (any Expr subclass)\n\n        Returns:\n            CVXPy expression or constraint object. For arithmetic expressions,\n            returns cp.Expression. For Equality/Inequality, returns cp.Constraint.\n\n        Raises:\n            NotImplementedError: If no visitor exists for the expression type\n            ValueError: If required variables are not in variable_map\n\n        Example:\n            Lower an expression to a CVXPy expression:\n\n                lowerer = CvxpyLowerer(variable_map={\"x\": cvx_x, \"u\": cvx_u})\n                x = ox.State(\"x\", shape=(3,))\n                expr = ox.Norm(x)\n                cvx_expr = lowerer.lower(expr)\n        \"\"\"\n        return dispatch(self, expr)\n\n    def register_variable(self, name: str, cvx_expr: cp.Expression):\n        \"\"\"Register a CVXPy variable/expression for use in lowering.\n\n        Adds or updates a variable in the variable_map. Useful for dynamically\n        adding variables after the lowerer has been created.\n\n        Args:\n            name: Variable name (e.g., \"x\", \"u\", or parameter name)\n            cvx_expr: CVXPy expression to associate with the name\n\n        Example:\n            Register a variable:\n\n                lowerer = CvxpyLowerer()\n                lowerer.register_variable(\"x\", cp.Variable(3))\n                lowerer.register_variable(\"obs_center\", cp.Parameter(3))\n        \"\"\"\n        self.variable_map[name] = cvx_expr\n\n    @visitor(Constant)\n    def _visit_constant(self, node: Constant) -&gt; cp.Expression:\n        \"\"\"Lower a constant value to a CVXPy constant.\n\n        Wraps the constant's numpy array value in a CVXPy Constant expression.\n\n        Args:\n            node: Constant expression node\n\n        Returns:\n            CVXPy constant expression wrapping the value\n        \"\"\"\n        return cp.Constant(node.value)\n\n    @visitor(State)\n    def _visit_state(self, node: State) -&gt; cp.Expression:\n        \"\"\"Lower a state variable to a CVXPy expression.\n\n        Extracts the appropriate slice from the unified state vector \"x\" using\n        the slice assigned during unification. The \"x\" variable must exist in\n        the variable_map.\n\n        Args:\n            node: State expression node\n\n        Returns:\n            CVXPy expression representing the state slice: x[slice]\n\n        Raises:\n            ValueError: If \"x\" is not found in variable_map\n        \"\"\"\n        if \"x\" not in self.variable_map:\n            raise ValueError(\"State vector 'x' not found in variable_map.\")\n\n        cvx_var = self.variable_map[\"x\"]\n\n        # If the state has a slice assigned, apply it\n        if node._slice is not None:\n            return cvx_var[node._slice]\n        return cvx_var\n\n    @visitor(Control)\n    def _visit_control(self, node: Control) -&gt; cp.Expression:\n        \"\"\"Lower a control variable to a CVXPy expression.\n\n        Extracts the appropriate slice from the unified control vector \"u\" using\n        the slice assigned during unification. The \"u\" variable must exist in\n        the variable_map.\n\n        Args:\n            node: Control expression node\n\n        Returns:\n            CVXPy expression representing the control slice: u[slice]\n\n        Raises:\n            ValueError: If \"u\" is not found in variable_map\n        \"\"\"\n        if \"u\" not in self.variable_map:\n            raise ValueError(\"Control vector 'u' not found in variable_map.\")\n\n        cvx_var = self.variable_map[\"u\"]\n\n        # If the control has a slice assigned, apply it\n        if node._slice is not None:\n            return cvx_var[node._slice]\n        return cvx_var\n\n    @visitor(NodeReference)\n    def _visit_node_reference(self, node: \"NodeReference\") -&gt; cp.Expression:\n        \"\"\"Lower NodeReference - extract value at a specific trajectory node.\n\n        NodeReference enables cross-node constraints by referencing state/control\n        values at specific discrete time points. This requires the variable_map to\n        contain full trajectory arrays (N, n_x) or (N, n_u) rather than single-node\n        vectors.\n\n        Args:\n            node: NodeReference expression with base and node_idx\n\n        Returns:\n            CVXPy expression representing the variable at the specified node:\n            x[node_idx, slice] or u[node_idx, slice]\n\n        Raises:\n            ValueError: If the required trajectory variable is not in variable_map\n            ValueError: If the base variable has no slice assigned\n            NotImplementedError: If the base is a compound expression\n\n        Example:\n            For cross-node constraint: position.at(5) - position.at(4) &lt;= 0.1\n\n            variable_map = {\n                \"x\": cp.vstack([x_nonscaled[k] for k in range(N)]),  # (N, n_x)\n            }\n            # position.at(5) lowers to x[5, position._slice]\n\n        Note:\n            The node_idx is already resolved to an absolute integer index during\n            expression construction, so negative indices are already handled.\n        \"\"\"\n        from openscvx.symbolic.expr.control import Control\n        from openscvx.symbolic.expr.state import State\n\n        idx = node.node_idx\n\n        if isinstance(node.base, State):\n            if \"x\" not in self.variable_map:\n                raise ValueError(\n                    \"State vector 'x' not found in variable_map. \"\n                    \"For cross-node constraints, 'x' must be the full trajectory (N, n_x).\"\n                )\n\n            cvx_var = self.variable_map[\"x\"]  # Should be (N, n_x) for cross-node constraints\n\n            # Apply slice if state has one assigned\n            if node.base._slice is not None:\n                return cvx_var[idx, node.base._slice]\n            else:\n                # No slice means this is the entire unified state vector\n                return cvx_var[idx, :]\n\n        elif isinstance(node.base, Control):\n            if \"u\" not in self.variable_map:\n                raise ValueError(\n                    \"Control vector 'u' not found in variable_map. \"\n                    \"For cross-node constraints, 'u' must be the full trajectory (N, n_u).\"\n                )\n\n            cvx_var = self.variable_map[\"u\"]  # Should be (N, n_u) for cross-node constraints\n\n            # Apply slice if control has one assigned\n            if node.base._slice is not None:\n                return cvx_var[idx, node.base._slice]\n            else:\n                # No slice means this is the entire unified control vector\n                return cvx_var[idx, :]\n\n        else:\n            # Compound expression (e.g., position[0].at(5))\n            # This is more complex - would need to lower base in single-node context\n            raise NotImplementedError(\n                \"Compound expressions in NodeReference are not yet supported for CVXPy lowering. \"\n                f\"Base expression type: {type(node.base).__name__}. \"\n                \"Only State and Control NodeReferences are currently supported.\"\n            )\n\n    @visitor(CrossNodeConstraint)\n    def _visit_cross_node_constraint(self, node: CrossNodeConstraint) -&gt; cp.Constraint:\n        \"\"\"Lower CrossNodeConstraint to CVXPy constraint.\n\n        CrossNodeConstraint wraps constraints that reference multiple trajectory\n        nodes via NodeReference (e.g., rate limits like x.at(k) - x.at(k-1) &lt;= r).\n\n        For CVXPy lowering, this simply lowers the inner constraint. The NodeReference\n        nodes within the constraint will handle extracting values from the full\n        trajectory arrays (which must be provided in variable_map as \"x\" and \"u\").\n\n        Args:\n            node: CrossNodeConstraint expression wrapping the inner constraint\n\n        Returns:\n            CVXPy constraint object\n\n        Note:\n            The variable_map must contain full trajectory arrays:\n                - \"x\": (N, n_x) CVXPy expression (e.g., cp.vstack(x_nonscaled))\n                - \"u\": (N, n_u) CVXPy expression (e.g., cp.vstack(u_nonscaled))\n\n            NodeReference visitors will index into these arrays using the fixed\n            node indices baked into the expression.\n\n        Example:\n            For constraint: position.at(5) - position.at(4) &lt;= max_step\n\n            With variable_map = {\"x\": cp.vstack([x[k] for k in range(N)])}\n\n            The lowered constraint evaluates:\n                x[5, pos_slice] - x[4, pos_slice] &lt;= max_step\n        \"\"\"\n        # Simply lower the inner constraint - NodeReference handles indexing\n        return self.lower(node.constraint)\n\n    @visitor(Parameter)\n    def _visit_parameter(self, node: Parameter) -&gt; cp.Expression:\n        \"\"\"Lower a parameter to a CVXPy expression.\n\n        Parameters are looked up by name in the variable_map. They can be mapped\n        to CVXPy Parameter objects (for efficient parameter sweeps) or constants.\n\n        Args:\n            node: Parameter expression node\n\n        Returns:\n            CVXPy expression from variable_map (Parameter or constant)\n\n        Raises:\n            ValueError: If parameter name is not found in variable_map\n\n        Note:\n            For parameter sweeps without recompilation, map to cp.Parameter.\n            For fixed values, map to cp.Constant or numpy arrays.\n        \"\"\"\n        param_name = node.name\n        if param_name in self.variable_map:\n            return self.variable_map[param_name]\n        else:\n            raise ValueError(\n                f\"Parameter '{param_name}' not found in variable_map. \"\n                f\"Add it during CVXPy lowering or use cp.Parameter for parameter sweeps.\"\n            )\n\n    @visitor(Add)\n    def _visit_add(self, node: Add) -&gt; cp.Expression:\n        \"\"\"Lower addition to CVXPy expression.\n\n        Recursively lowers all terms and composes them with element-wise addition.\n        Addition is affine and always DCP-compliant.\n\n        Args:\n            node: Add expression node with multiple terms\n\n        Returns:\n            CVXPy expression representing the sum of all terms\n        \"\"\"\n        terms = [self.lower(term) for term in node.terms]\n        result = terms[0]\n        for term in terms[1:]:\n            result = result + term\n        return result\n\n    @visitor(Sub)\n    def _visit_sub(self, node: Sub) -&gt; cp.Expression:\n        \"\"\"Lower subtraction to CVXPy expression (element-wise left - right).\n\n        Subtraction is affine and always DCP-compliant.\n\n        Args:\n            node: Sub expression node\n\n        Returns:\n            CVXPy expression representing left - right\n        \"\"\"\n        left = self.lower(node.left)\n        right = self.lower(node.right)\n        return left - right\n\n    @visitor(Mul)\n    def _visit_mul(self, node: Mul) -&gt; cp.Expression:\n        \"\"\"Lower element-wise multiplication to CVXPy expression.\n\n        Element-wise multiplication is DCP-compliant when at least one operand\n        is constant. For quadratic forms, use MatMul instead.\n\n        Args:\n            node: Mul expression node with multiple factors\n\n        Returns:\n            CVXPy expression representing element-wise product\n\n        Note:\n            For convex optimization, typically one factor should be constant.\n            CVXPy will raise a DCP error if the composition violates DCP rules.\n        \"\"\"\n        factors = [self.lower(factor) for factor in node.factors]\n        result = factors[0]\n        for factor in factors[1:]:\n            result = result * factor\n        return result\n\n    @visitor(Div)\n    def _visit_div(self, node: Div) -&gt; cp.Expression:\n        \"\"\"Lower element-wise division to CVXPy expression.\n\n        Division is DCP-compliant when the denominator is constant or when\n        the numerator is constant and the denominator is concave.\n\n        Args:\n            node: Div expression node\n\n        Returns:\n            CVXPy expression representing left / right\n\n        Note:\n            CVXPy will raise a DCP error if the division violates DCP rules.\n        \"\"\"\n        left = self.lower(node.left)\n        right = self.lower(node.right)\n        return left / right\n\n    @visitor(MatMul)\n    def _visit_matmul(self, node: MatMul) -&gt; cp.Expression:\n        \"\"\"Lower matrix multiplication to CVXPy expression using @ operator.\n\n        Matrix multiplication is DCP-compliant when at least one operand is\n        constant. Used for quadratic forms like x.T @ Q @ x.\n\n        Args:\n            node: MatMul expression node\n\n        Returns:\n            CVXPy expression representing left @ right\n        \"\"\"\n        left = self.lower(node.left)\n        right = self.lower(node.right)\n        return left @ right\n\n    @visitor(Neg)\n    def _visit_neg(self, node: Neg) -&gt; cp.Expression:\n        \"\"\"Lower negation (unary minus) to CVXPy expression.\n\n        Negation preserves DCP properties (negating convex gives concave).\n\n        Args:\n            node: Neg expression node\n\n        Returns:\n            CVXPy expression representing -operand\n        \"\"\"\n        operand = self.lower(node.operand)\n        return -operand\n\n    @visitor(Sum)\n    def _visit_sum(self, node: Sum) -&gt; cp.Expression:\n        \"\"\"Lower sum reduction to CVXPy expression (sums all elements).\n\n        Sum preserves DCP properties (sum of convex is convex).\n\n        Args:\n            node: Sum expression node\n\n        Returns:\n            CVXPy scalar expression representing the sum of all elements\n        \"\"\"\n        operand = self.lower(node.operand)\n        return cp.sum(operand)\n\n    @visitor(Norm)\n    def _visit_norm(self, node: Norm) -&gt; cp.Expression:\n        \"\"\"Lower norm operation to CVXPy expression.\n\n        Norms are convex functions and commonly used in convex optimization.\n        Supports all CVXPy norm types (1, 2, inf, \"fro\", etc.).\n\n        Args:\n            node: Norm expression node with ord attribute\n\n        Returns:\n            CVXPy expression representing the norm of the operand\n\n        Note:\n            Common norms: ord=2 (Euclidean), ord=1 (Manhattan), ord=\"inf\"\n        \"\"\"\n        operand = self.lower(node.operand)\n        return cp.norm(operand, node.ord)\n\n    @visitor(Index)\n    def _visit_index(self, node: Index) -&gt; cp.Expression:\n        \"\"\"Lower indexing/slicing operation to CVXPy expression.\n\n        Indexing preserves DCP properties (indexing into convex is convex).\n\n        Args:\n            node: Index expression node\n\n        Returns:\n            CVXPy expression representing base[index]\n        \"\"\"\n        base = self.lower(node.base)\n        return base[node.index]\n\n    @visitor(Concat)\n    def _visit_concat(self, node: Concat) -&gt; cp.Expression:\n        \"\"\"Lower concatenation to CVXPy expression.\n\n        Concatenates expressions horizontally along axis 0. Scalars are\n        promoted to 1D arrays before concatenation. Preserves DCP properties.\n\n        Args:\n            node: Concat expression node\n\n        Returns:\n            CVXPy expression representing horizontal concatenation\n\n        Note:\n            Uses cp.hstack for concatenation. Scalars are reshaped to (1,).\n        \"\"\"\n        exprs = [self.lower(child) for child in node.exprs]\n        # Ensure all expressions are at least 1D for concatenation\n        exprs_1d = []\n        for expr in exprs:\n            if expr.ndim == 0:  # scalar\n                exprs_1d.append(cp.reshape(expr, (1,), order=\"C\"))\n            else:\n                exprs_1d.append(expr)\n        return cp.hstack(exprs_1d)\n\n    @visitor(Sin)\n    def _visit_sin(self, node: Sin) -&gt; cp.Expression:\n        \"\"\"Raise NotImplementedError for sine function.\n\n        Sine is not DCP-compliant in CVXPy as it is neither convex nor concave.\n\n        Args:\n            node: Sin expression node\n\n        Raises:\n            NotImplementedError: Always raised since sine is not DCP-compliant\n\n        Note:\n            For constraints involving trigonometric functions:\n            - Use piecewise-linear approximations, or\n            - Handle in the JAX dynamics/constraint layer instead of CVXPy\n        \"\"\"\n        raise NotImplementedError(\n            \"Trigonometric functions like Sin are not DCP-compliant in CVXPy. \"\n            \"Consider using piecewise-linear approximations or handle these constraints \"\n            \"in the dynamics (JAX) layer instead.\"\n        )\n\n    @visitor(Cos)\n    def _visit_cos(self, node: Cos) -&gt; cp.Expression:\n        \"\"\"Raise NotImplementedError for cosine function.\n\n        Cosine is not DCP-compliant in CVXPy as it is neither convex nor concave.\n\n        Args:\n            node: Cos expression node\n\n        Raises:\n            NotImplementedError: Always raised since cosine is not DCP-compliant\n\n        Note:\n            For constraints involving trigonometric functions:\n            - Use piecewise-linear approximations, or\n            - Handle in the JAX dynamics/constraint layer instead of CVXPy\n        \"\"\"\n        raise NotImplementedError(\n            \"Trigonometric functions like Cos are not DCP-compliant in CVXPy. \"\n            \"Consider using piecewise-linear approximations or handle these constraints \"\n            \"in the dynamics (JAX) layer instead.\"\n        )\n\n    @visitor(Tan)\n    def _visit_tan(self, node: Tan) -&gt; cp.Expression:\n        \"\"\"Raise NotImplementedError for tangent function.\n\n        Tangent is not DCP-compliant in CVXPy as it is neither convex nor concave.\n\n        Args:\n            node: Tan expression node\n\n        Raises:\n            NotImplementedError: Always raised since tangent is not DCP-compliant\n\n        Note:\n            For constraints involving trigonometric functions:\n            - Use piecewise-linear approximations, or\n            - Handle in the JAX dynamics/constraint layer instead of CVXPy\n        \"\"\"\n        raise NotImplementedError(\n            \"Trigonometric functions like Tan are not DCP-compliant in CVXPy. \"\n            \"Consider using piecewise-linear approximations or handle these constraints \"\n            \"in the dynamics (JAX) layer instead.\"\n        )\n\n    @visitor(Exp)\n    def _visit_exp(self, node: Exp) -&gt; cp.Expression:\n        \"\"\"Lower exponential function to CVXPy expression.\n\n        Exponential is a convex function and DCP-compliant when used in\n        appropriate contexts (e.g., minimizing exp(x) or constraints like\n        exp(x) &lt;= c).\n\n        Args:\n            node: Exp expression node\n\n        Returns:\n            CVXPy expression representing exp(operand)\n\n        Note:\n            Exponential is convex increasing, so it's valid in:\n            - Objective: minimize exp(x)\n            - Constraints: exp(x) &lt;= c (convex constraint)\n        \"\"\"\n        operand = self.lower(node.operand)\n        return cp.exp(operand)\n\n    @visitor(Log)\n    def _visit_log(self, node: Log) -&gt; cp.Expression:\n        \"\"\"Lower natural logarithm to CVXPy expression.\n\n        Logarithm is a concave function and DCP-compliant when used in\n        appropriate contexts (e.g., maximizing log(x) or constraints like\n        log(x) &gt;= c).\n\n        Args:\n            node: Log expression node\n\n        Returns:\n            CVXPy expression representing log(operand)\n\n        Note:\n            Logarithm is concave increasing, so it's valid in:\n            - Objective: maximize log(x)\n            - Constraints: log(x) &gt;= c (concave constraint, or equivalently c &lt;= log(x))\n        \"\"\"\n        operand = self.lower(node.operand)\n        return cp.log(operand)\n\n    @visitor(Abs)\n    def _visit_abs(self, node: Abs) -&gt; cp.Expression:\n        \"\"\"Lower absolute value to CVXPy expression.\n\n        Absolute value is a convex function and DCP-compliant when used in\n        appropriate contexts (e.g., minimizing |x| or constraints like |x| &lt;= c).\n\n        Args:\n            node: Abs expression node\n\n        Returns:\n            CVXPy expression representing |operand|\n\n        Note:\n            Absolute value is convex, so it's valid in:\n            - Objective: minimize abs(x)\n            - Constraints: abs(x) &lt;= c (convex constraint)\n        \"\"\"\n        operand = self.lower(node.operand)\n        return cp.abs(operand)\n\n    @visitor(Equality)\n    def _visit_equality(self, node: Equality) -&gt; cp.Constraint:\n        \"\"\"Lower equality constraint to CVXPy constraint (lhs == rhs).\n\n        Equality constraints require affine expressions on both sides for\n        DCP compliance.\n\n        Args:\n            node: Equality constraint node\n\n        Returns:\n            CVXPy equality constraint object\n\n        Note:\n            For DCP compliance, both lhs and rhs must be affine. CVXPy will\n            raise a DCP error if either side is non-affine.\n        \"\"\"\n        left = self.lower(node.lhs)\n        right = self.lower(node.rhs)\n        return left == right\n\n    @visitor(Inequality)\n    def _visit_inequality(self, node: Inequality) -&gt; cp.Constraint:\n        \"\"\"Lower inequality constraint to CVXPy constraint (lhs &lt;= rhs).\n\n        Inequality constraints must satisfy DCP rules: convex &lt;= concave.\n\n        Args:\n            node: Inequality constraint node\n\n        Returns:\n            CVXPy inequality constraint object\n\n        Note:\n            For DCP compliance: lhs must be convex and rhs must be concave.\n            Common form: convex_expr(x) &lt;= constant\n        \"\"\"\n        left = self.lower(node.lhs)\n        right = self.lower(node.rhs)\n        return left &lt;= right\n\n    @visitor(CTCS)\n    def _visit_ctcs(self, node: CTCS) -&gt; cp.Expression:\n        \"\"\"Raise NotImplementedError for CTCS constraints.\n\n        CTCS (Continuous-Time Constraint Satisfaction) constraints are handled\n        through dynamics augmentation using JAX, not CVXPy. They represent\n        non-convex continuous-time constraints.\n\n        Args:\n            node: CTCS constraint node\n\n        Raises:\n            NotImplementedError: Always raised since CTCS uses JAX, not CVXPy\n\n        Note:\n            CTCS constraints are lowered to JAX during dynamics augmentation.\n            They add virtual states and controls to enforce constraints over\n            continuous time intervals. See JaxLowerer.visit_ctcs() instead.\n        \"\"\"\n        raise NotImplementedError(\n            \"CTCS constraints are for continuous-time constraint satisfaction and \"\n            \"should be handled through dynamics augmentation with JAX lowering, \"\n            \"not CVXPy lowering. CTCS constraints represent non-convex dynamics \"\n            \"augmentation.\"\n        )\n\n    @visitor(PositivePart)\n    def _visit_pos(self, node: PositivePart) -&gt; cp.Expression:\n        \"\"\"Lower positive part function to CVXPy.\n\n        Computes max(x, 0), which is convex. Used in penalty methods for\n        inequality constraints.\n\n        Args:\n            node: PositivePart expression node\n\n        Returns:\n            CVXPy expression representing max(operand, 0)\n\n        Note:\n            Positive part is convex and commonly used in hinge loss and\n            penalty methods for inequality constraints.\n        \"\"\"\n        operand = self.lower(node.x)\n        return cp.maximum(operand, 0.0)\n\n    @visitor(Square)\n    def _visit_square(self, node: Square) -&gt; cp.Expression:\n        \"\"\"Lower square function to CVXPy.\n\n        Computes x^2, which is convex. Used in quadratic penalty methods\n        and least-squares objectives.\n\n        Args:\n            node: Square expression node\n\n        Returns:\n            CVXPy expression representing operand^2\n\n        Note:\n            Square is convex increasing for x &gt;= 0 and convex decreasing for\n            x &lt;= 0. It's always convex overall.\n        \"\"\"\n        operand = self.lower(node.x)\n        return cp.square(operand)\n\n    @visitor(Huber)\n    def _visit_huber(self, node: Huber) -&gt; cp.Expression:\n        \"\"\"Lower Huber penalty function to CVXPy.\n\n        Huber penalty is quadratic for small values and linear for large values,\n        providing robustness to outliers. It is convex and DCP-compliant.\n\n        The Huber function is defined as:\n        - |x| &lt;= delta: 0.5 * x^2\n        - |x| &gt; delta: delta * (|x| - 0.5 * delta)\n\n        Args:\n            node: Huber expression node with delta parameter\n\n        Returns:\n            CVXPy expression representing Huber penalty\n\n        Note:\n            Huber loss is convex and combines the benefits of squared error\n            (smooth, differentiable) and absolute error (robust to outliers).\n        \"\"\"\n        operand = self.lower(node.x)\n        return cp.huber(operand, M=node.delta)\n\n    @visitor(SmoothReLU)\n    def _visit_srelu(self, node: SmoothReLU) -&gt; cp.Expression:\n        \"\"\"Lower smooth ReLU penalty function to CVXPy.\n\n        Smooth approximation to ReLU: sqrt(max(x, 0)^2 + c^2) - c\n        Differentiable everywhere, approaches ReLU as c -&gt; 0. Convex.\n\n        Args:\n            node: SmoothReLU expression node with smoothing parameter c\n\n        Returns:\n            CVXPy expression representing smooth ReLU penalty\n\n        Note:\n            This provides a smooth, convex approximation to the ReLU function\n            max(x, 0). The parameter c controls the smoothness: smaller c gives\n            a better approximation but less smoothness.\n        \"\"\"\n        operand = self.lower(node.x)\n        c = node.c\n        # smooth_relu(x) = sqrt(max(x, 0)^2 + c^2) - c\n        pos_part = cp.maximum(operand, 0.0)\n        # For SmoothReLU, we use the 2-norm formulation\n        return cp.sqrt(cp.sum_squares(pos_part) + c**2) - c\n\n    @visitor(Sqrt)\n    def _visit_sqrt(self, node: Sqrt) -&gt; cp.Expression:\n        \"\"\"Lower square root to CVXPy expression.\n\n        Square root is concave and DCP-compliant when used appropriately\n        (e.g., maximizing sqrt(x) or constraints like sqrt(x) &gt;= c).\n\n        Args:\n            node: Sqrt expression node\n\n        Returns:\n            CVXPy expression representing sqrt(operand)\n\n        Note:\n            Square root is concave increasing for x &gt; 0. Valid in:\n            - Objective: maximize sqrt(x)\n            - Constraints: sqrt(x) &gt;= c (concave constraint)\n        \"\"\"\n        operand = self.lower(node.operand)\n        return cp.sqrt(operand)\n\n    @visitor(Max)\n    def _visit_max(self, node: Max) -&gt; cp.Expression:\n        \"\"\"Lower element-wise maximum to CVXPy expression.\n\n        Maximum is convex (pointwise max of convex functions is convex).\n\n        Args:\n            node: Max expression node with multiple operands\n\n        Returns:\n            CVXPy expression representing element-wise maximum\n\n        Note:\n            For multiple operands, chains binary maximum operations.\n            Maximum preserves convexity.\n        \"\"\"\n        operands = [self.lower(op) for op in node.operands]\n        # CVXPy's maximum can take multiple arguments\n        if len(operands) == 2:\n            return cp.maximum(operands[0], operands[1])\n        else:\n            # For more than 2 operands, chain maximum calls\n            result = cp.maximum(operands[0], operands[1])\n            for op in operands[2:]:\n                result = cp.maximum(result, op)\n            return result\n\n    @visitor(LogSumExp)\n    def _visit_logsumexp(self, node: LogSumExp) -&gt; cp.Expression:\n        \"\"\"Lower log-sum-exp to CVXPy expression.\n\n        Log-sum-exp is convex and is a smooth approximation to the maximum function.\n        CVXPy's log_sum_exp atom computes log(sum(exp(x_i))) for stacked operands.\n\n        Args:\n            node: LogSumExp expression node with multiple operands\n\n        Returns:\n            CVXPy expression representing log-sum-exp\n\n        Note:\n            Log-sum-exp is convex and DCP-compliant. It satisfies:\n            max(x\u2081, ..., x\u2099) \u2264 logsumexp(x\u2081, ..., x\u2099) \u2264 max(x\u2081, ..., x\u2099) + log(n)\n        \"\"\"\n        operands = [self.lower(op) for op in node.operands]\n\n        # CVXPy's log_sum_exp expects a stacked expression with an axis parameter\n        # For element-wise log-sum-exp, we stack along a new axis and reduce along it\n        if len(operands) == 1:\n            return operands[0]\n\n        # Stack operands along a new axis (axis 0) and compute log_sum_exp along that axis\n        stacked = cp.vstack(operands)\n        return cp.log_sum_exp(stacked, axis=0)\n\n    @visitor(Transpose)\n    def _visit_transpose(self, node: Transpose) -&gt; cp.Expression:\n        \"\"\"Lower matrix transpose to CVXPy expression.\n\n        Transpose preserves DCP properties (transpose of convex is convex).\n\n        Args:\n            node: Transpose expression node\n\n        Returns:\n            CVXPy expression representing operand.T\n        \"\"\"\n        operand = self.lower(node.operand)\n        return operand.T\n\n    @visitor(Inv)\n    def _visit_inv(self, node: Inv) -&gt; cp.Expression:\n        \"\"\"Raise NotImplementedError for matrix inverse.\n\n        Matrix inverse is not DCP-compliant in CVXPy as it is neither convex\n        nor concave for variable matrices.\n\n        Args:\n            node: Inv expression node\n\n        Raises:\n            NotImplementedError: Always raised since matrix inverse is not DCP-compliant\n\n        Note:\n            For optimization problems requiring matrix inverse:\n            - If the matrix is constant/parameter, compute the inverse numerically\n              before passing to CVXPy\n            - Handle matrix inverse in the JAX dynamics/constraint layer instead\n            - Consider reformulating the problem to avoid explicit matrix inverse\n        \"\"\"\n        raise NotImplementedError(\n            \"Matrix inverse (Inv) is not DCP-compliant in CVXPy. \"\n            \"inv(X) is neither convex nor concave for variable matrices. \"\n            \"Consider: (1) computing the inverse numerically if the matrix is constant, \"\n            \"(2) handling this in the JAX layer instead, or \"\n            \"(3) reformulating the problem to avoid explicit matrix inverse.\"\n        )\n\n    @visitor(Power)\n    def _visit_power(self, node: Power) -&gt; cp.Expression:\n        \"\"\"Lower element-wise power (base**exponent) to CVXPy expression.\n\n        Power is DCP-compliant for specific exponent values:\n        - exponent &gt;= 1: convex (when base &gt;= 0)\n        - 0 &lt;= exponent &lt;= 1: concave (when base &gt;= 0)\n\n        Args:\n            node: Power expression node\n\n        Returns:\n            CVXPy expression representing base**exponent\n\n        Note:\n            CVXPy will verify DCP compliance at problem construction time.\n            Common convex cases: x^2, x^3, x^4 (even powers)\n        \"\"\"\n        base = self.lower(node.base)\n        exponent = self.lower(node.exponent)\n        return cp.power(base, exponent)\n\n    @visitor(Stack)\n    def _visit_stack(self, node: Stack) -&gt; cp.Expression:\n        \"\"\"Lower vertical stacking to CVXPy expression.\n\n        Stacks expressions vertically using cp.vstack. Preserves DCP properties.\n\n        Args:\n            node: Stack expression node with multiple rows\n\n        Returns:\n            CVXPy expression representing vertical stack of rows\n\n        Note:\n            Each row is stacked along axis 0 to create a 2D array.\n        \"\"\"\n        rows = [self.lower(row) for row in node.rows]\n        # Stack rows vertically\n        return cp.vstack(rows)\n\n    @visitor(Hstack)\n    def _visit_hstack(self, node: Hstack) -&gt; cp.Expression:\n        \"\"\"Lower horizontal stacking to CVXPy expression.\n\n        For 1D arrays, uses cp.hstack (concatenation). For 2D+ arrays, uses\n        cp.bmat with a single row to achieve proper horizontal stacking along\n        axis 1, matching numpy.hstack semantics.\n\n        Args:\n            node: Hstack expression node with multiple arrays\n\n        Returns:\n            CVXPy expression representing horizontal stack of arrays\n        \"\"\"\n        arrays = [self.lower(arr) for arr in node.arrays]\n\n        # Check dimensionality from the symbolic node's shape\n        shape = node.check_shape()\n        if len(shape) == 1:\n            # 1D: simple concatenation\n            return cp.hstack(arrays)\n        else:\n            # 2D+: use bmat with single row for proper horizontal stacking\n            return cp.bmat([arrays])\n\n    @visitor(Vstack)\n    def _visit_vstack(self, node: Vstack) -&gt; cp.Expression:\n        \"\"\"Lower vertical stacking to CVXPy expression.\n\n        Stacks expressions vertically using cp.vstack. Preserves DCP properties.\n\n        Args:\n            node: Vstack expression node with multiple arrays\n\n        Returns:\n            CVXPy expression representing vertical stack of arrays\n        \"\"\"\n        arrays = [self.lower(arr) for arr in node.arrays]\n        return cp.vstack(arrays)\n\n    @visitor(Block)\n    def _visit_block(self, node: Block) -&gt; cp.Expression:\n        \"\"\"Lower block matrix construction to CVXPy expression.\n\n        Assembles a block matrix from nested lists of expressions using cp.bmat.\n        This is the CVXPy equivalent of numpy.block() for block matrix construction.\n\n        Args:\n            node: Block expression node with 2D nested structure of expressions\n\n        Returns:\n            CVXPy expression representing the assembled block matrix\n\n        Raises:\n            NotImplementedError: If any block has more than 2 dimensions\n\n        Note:\n            cp.bmat preserves DCP properties when all blocks are DCP-compliant.\n            Block matrices are commonly used for constraint aggregation.\n            For 3D+ tensors, use JAX lowering instead.\n        \"\"\"\n        # Check for 3D+ blocks - CVXPy's bmat only supports 2D\n        for i, row in enumerate(node.blocks):\n            for j, block in enumerate(row):\n                block_shape = block.check_shape()\n                if len(block_shape) &gt; 2:\n                    raise NotImplementedError(\n                        f\"CVXPy does not support Block with tensors of dimension &gt; 2. \"\n                        f\"Block[{i}][{j}] has shape {block_shape} ({len(block_shape)}D). \"\n                        f\"For N-D tensor block assembly, use JAX lowering instead.\"\n                    )\n\n        # Lower each block expression\n        block_exprs = [[self.lower(block) for block in row] for row in node.blocks]\n        return cp.bmat(block_exprs)\n\n    @visitor(Linterp)\n    def _visit_linterp(self, node: Linterp) -&gt; cp.Expression:\n        \"\"\"Raise NotImplementedError for linear interpolation.\n\n        Linear interpolation (Linterp) is not DCP-compliant in CVXPy as it\n        represents a piecewise-linear function that is neither convex nor\n        concave in general.\n\n        Args:\n            node: Linterp expression node\n\n        Raises:\n            NotImplementedError: Always raised since Linterp is not DCP-compliant\n        \"\"\"\n        raise NotImplementedError(\"Linear interpolation (Linterp) is not DCP-compliant in CVXPy.\")\n\n    @visitor(Bilerp)\n    def _visit_bilerp(self, node: Bilerp) -&gt; cp.Expression:\n        \"\"\"Raise NotImplementedError for bilinear interpolation.\n\n        Bilinear interpolation (Bilerp) is not DCP-compliant in CVXPy as it\n        represents a nonlinear function that is neither convex nor concave.\n\n        Args:\n            node: Bilerp expression node\n\n        Raises:\n            NotImplementedError: Always raised since Bilerp is not DCP-compliant\n        \"\"\"\n        raise NotImplementedError(\"Bilinear interpolation (Bilerp) is not DCP-compliant in CVXPy.\")\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer.__init__","title":"<code>__init__(variable_map: Dict[str, cp.Expression] = None)</code>","text":"<p>Initialize the CVXPy lowerer.</p> <p>Parameters:</p> Name Type Description Default <code>variable_map</code> <code>Dict[str, Expression]</code> <p>Dictionary mapping variable names to CVXPy expressions. For State/Control objects, keys should be \"x\" and \"u\" respectively. For Parameter objects, keys should match their names. If None, an empty dictionary is created.</p> <code>None</code> Example <p>Initialize the CVXPy lowerer with the variable map:</p> <pre><code>cvx_x = cp.Variable(3, name=\"x\")\ncvx_u = cp.Variable(2, name=\"u\")\nlowerer = CvxpyLowerer({\"x\": cvx_x, \"u\": cvx_u})\n</code></pre> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>def __init__(self, variable_map: Dict[str, cp.Expression] = None):\n    \"\"\"Initialize the CVXPy lowerer.\n\n    Args:\n        variable_map: Dictionary mapping variable names to CVXPy expressions.\n            For State/Control objects, keys should be \"x\" and \"u\" respectively.\n            For Parameter objects, keys should match their names. If None, an\n            empty dictionary is created.\n\n    Example:\n        Initialize the CVXPy lowerer with the variable map:\n\n            cvx_x = cp.Variable(3, name=\"x\")\n            cvx_u = cp.Variable(2, name=\"u\")\n            lowerer = CvxpyLowerer({\"x\": cvx_x, \"u\": cvx_u})\n    \"\"\"\n    self.variable_map = variable_map or {}\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer.lower","title":"<code>lower(expr: Expr) -&gt; cp.Expression</code>","text":"<p>Lower a symbolic expression to a CVXPy expression.</p> <p>Main entry point for lowering. Delegates to dispatch() which looks up the appropriate visitor method based on the expression type.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Symbolic expression to lower (any Expr subclass)</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression or constraint object. For arithmetic expressions,</p> <code>Expression</code> <p>returns cp.Expression. For Equality/Inequality, returns cp.Constraint.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If no visitor exists for the expression type</p> <code>ValueError</code> <p>If required variables are not in variable_map</p> Example <p>Lower an expression to a CVXPy expression:</p> <pre><code>lowerer = CvxpyLowerer(variable_map={\"x\": cvx_x, \"u\": cvx_u})\nx = ox.State(\"x\", shape=(3,))\nexpr = ox.Norm(x)\ncvx_expr = lowerer.lower(expr)\n</code></pre> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>def lower(self, expr: Expr) -&gt; cp.Expression:\n    \"\"\"Lower a symbolic expression to a CVXPy expression.\n\n    Main entry point for lowering. Delegates to dispatch() which looks up\n    the appropriate visitor method based on the expression type.\n\n    Args:\n        expr: Symbolic expression to lower (any Expr subclass)\n\n    Returns:\n        CVXPy expression or constraint object. For arithmetic expressions,\n        returns cp.Expression. For Equality/Inequality, returns cp.Constraint.\n\n    Raises:\n        NotImplementedError: If no visitor exists for the expression type\n        ValueError: If required variables are not in variable_map\n\n    Example:\n        Lower an expression to a CVXPy expression:\n\n            lowerer = CvxpyLowerer(variable_map={\"x\": cvx_x, \"u\": cvx_u})\n            x = ox.State(\"x\", shape=(3,))\n            expr = ox.Norm(x)\n            cvx_expr = lowerer.lower(expr)\n    \"\"\"\n    return dispatch(self, expr)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.CvxpyLowerer.register_variable","title":"<code>register_variable(name: str, cvx_expr: cp.Expression)</code>","text":"<p>Register a CVXPy variable/expression for use in lowering.</p> <p>Adds or updates a variable in the variable_map. Useful for dynamically adding variables after the lowerer has been created.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Variable name (e.g., \"x\", \"u\", or parameter name)</p> required <code>cvx_expr</code> <code>Expression</code> <p>CVXPy expression to associate with the name</p> required Example <p>Register a variable:</p> <pre><code>lowerer = CvxpyLowerer()\nlowerer.register_variable(\"x\", cp.Variable(3))\nlowerer.register_variable(\"obs_center\", cp.Parameter(3))\n</code></pre> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>def register_variable(self, name: str, cvx_expr: cp.Expression):\n    \"\"\"Register a CVXPy variable/expression for use in lowering.\n\n    Adds or updates a variable in the variable_map. Useful for dynamically\n    adding variables after the lowerer has been created.\n\n    Args:\n        name: Variable name (e.g., \"x\", \"u\", or parameter name)\n        cvx_expr: CVXPy expression to associate with the name\n\n    Example:\n        Register a variable:\n\n            lowerer = CvxpyLowerer()\n            lowerer.register_variable(\"x\", cp.Variable(3))\n            lowerer.register_variable(\"obs_center\", cp.Parameter(3))\n    \"\"\"\n    self.variable_map[name] = cvx_expr\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.dispatch","title":"<code>dispatch(lowerer: Any, expr: Expr)</code>","text":"<p>Dispatch an expression to its registered visitor function.</p> <p>Looks up the visitor function for the expression's type and calls it. This is the core of the visitor pattern implementation.</p> <p>Parameters:</p> Name Type Description Default <code>lowerer</code> <code>Any</code> <p>The CvxpyLowerer instance (provides context for visitor methods)</p> required <code>expr</code> <code>Expr</code> <p>The expression node to lower</p> required <p>Returns:</p> Type Description <p>The result of calling the visitor function (CVXPy expression or constraint)</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If no visitor is registered for the expression type</p> Example <p>Dispatch an expression to lower it:</p> <pre><code>lowerer = CvxpyLowerer(variable_map={...})\nexpr = Add(x, y)\ncvx_expr = dispatch(lowerer, expr)  # Calls visit_add\n</code></pre> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>def dispatch(lowerer: Any, expr: Expr):\n    \"\"\"Dispatch an expression to its registered visitor function.\n\n    Looks up the visitor function for the expression's type and calls it.\n    This is the core of the visitor pattern implementation.\n\n    Args:\n        lowerer: The CvxpyLowerer instance (provides context for visitor methods)\n        expr: The expression node to lower\n\n    Returns:\n        The result of calling the visitor function (CVXPy expression or constraint)\n\n    Raises:\n        NotImplementedError: If no visitor is registered for the expression type\n\n    Example:\n        Dispatch an expression to lower it:\n\n            lowerer = CvxpyLowerer(variable_map={...})\n            expr = Add(x, y)\n            cvx_expr = dispatch(lowerer, expr)  # Calls visit_add\n    \"\"\"\n    fn = _CVXPY_VISITORS.get(type(expr))\n    if fn is None:\n        raise NotImplementedError(\n            f\"{lowerer.__class__.__name__!r} has no visitor for {type(expr).__name__}\"\n        )\n    return fn(lowerer, expr)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.lower_to_cvxpy","title":"<code>lower_to_cvxpy(expr: Expr, variable_map: Dict[str, cp.Expression] = None) -&gt; cp.Expression</code>","text":"<p>Lower symbolic expression to CVXPy expression or constraint.</p> <p>Convenience wrapper that creates a CvxpyLowerer and lowers a single symbolic expression to a CVXPy expression. The result can be used in CVXPy optimization problems.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Symbolic expression to lower (any Expr subclass)</p> required <code>variable_map</code> <code>Dict[str, Expression]</code> <p>Dictionary mapping variable names to CVXPy expressions. Must include \"x\" for states and \"u\" for controls. May include parameter names mapped to CVXPy Parameters or constants.</p> <code>None</code> <p>Returns:</p> Type Description <code>Expression</code> <p>CVXPy expression for arithmetic expressions (Add, Mul, Norm, etc.)</p> <code>Expression</code> <p>or CVXPy constraint for constraint expressions (Equality, Inequality)</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the expression type is not supported (e.g., Sin, Cos, CTCS)</p> <code>ValueError</code> <p>If required variables are missing from variable_map</p> Example <p>Basic expression lowering::</p> <pre><code>import cvxpy as cp\nimport openscvx as ox\n\n# Create CVXPy variables\ncvx_x = cp.Variable(3, name=\"x\")\ncvx_u = cp.Variable(2, name=\"u\")\n\n# Create symbolic expression\nx = ox.State(\"x\", shape=(3,))\nu = ox.Control(\"u\", shape=(2,))\nexpr = ox.Norm(x)**2 + 0.1 * ox.Norm(u)**2\n\n# Lower to CVXPy\ncvx_expr = lower_to_cvxpy(expr, {\"x\": cvx_x, \"u\": cvx_u})\n\n# Use in optimization problem\nprob = cp.Problem(cp.Minimize(cvx_expr))\nprob.solve()\n</code></pre> <p>Constraint lowering::</p> <pre><code># Symbolic constraint\nconstraint = ox.Norm(x) &lt;= 1.0\n\n# Lower to CVXPy constraint\ncvx_constraint = lower_to_cvxpy(constraint, {\"x\": cvx_x, \"u\": cvx_u})\n\n# Use in problem\nprob = cp.Problem(cp.Minimize(cost), constraints=[cvx_constraint])\n</code></pre> See Also <ul> <li>CvxpyLowerer: The underlying lowerer class</li> <li>lower_to_jax(): Convenience wrapper for JAX lowering</li> <li>lower_symbolic_expressions(): Main orchestrator in symbolic/lower.py</li> </ul> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>def lower_to_cvxpy(expr: Expr, variable_map: Dict[str, cp.Expression] = None) -&gt; cp.Expression:\n    \"\"\"Lower symbolic expression to CVXPy expression or constraint.\n\n    Convenience wrapper that creates a CvxpyLowerer and lowers a single\n    symbolic expression to a CVXPy expression. The result can be used in\n    CVXPy optimization problems.\n\n    Args:\n        expr: Symbolic expression to lower (any Expr subclass)\n        variable_map: Dictionary mapping variable names to CVXPy expressions.\n            Must include \"x\" for states and \"u\" for controls. May include\n            parameter names mapped to CVXPy Parameters or constants.\n\n    Returns:\n        CVXPy expression for arithmetic expressions (Add, Mul, Norm, etc.)\n        or CVXPy constraint for constraint expressions (Equality, Inequality)\n\n    Raises:\n        NotImplementedError: If the expression type is not supported (e.g., Sin, Cos, CTCS)\n        ValueError: If required variables are missing from variable_map\n\n    Example:\n        Basic expression lowering::\n\n            import cvxpy as cp\n            import openscvx as ox\n\n            # Create CVXPy variables\n            cvx_x = cp.Variable(3, name=\"x\")\n            cvx_u = cp.Variable(2, name=\"u\")\n\n            # Create symbolic expression\n            x = ox.State(\"x\", shape=(3,))\n            u = ox.Control(\"u\", shape=(2,))\n            expr = ox.Norm(x)**2 + 0.1 * ox.Norm(u)**2\n\n            # Lower to CVXPy\n            cvx_expr = lower_to_cvxpy(expr, {\"x\": cvx_x, \"u\": cvx_u})\n\n            # Use in optimization problem\n            prob = cp.Problem(cp.Minimize(cvx_expr))\n            prob.solve()\n\n        Constraint lowering::\n\n            # Symbolic constraint\n            constraint = ox.Norm(x) &lt;= 1.0\n\n            # Lower to CVXPy constraint\n            cvx_constraint = lower_to_cvxpy(constraint, {\"x\": cvx_x, \"u\": cvx_u})\n\n            # Use in problem\n            prob = cp.Problem(cp.Minimize(cost), constraints=[cvx_constraint])\n\n    See Also:\n        - CvxpyLowerer: The underlying lowerer class\n        - lower_to_jax(): Convenience wrapper for JAX lowering\n        - lower_symbolic_expressions(): Main orchestrator in symbolic/lower.py\n    \"\"\"\n    lowerer = CvxpyLowerer(variable_map)\n    return lowerer.lower(expr)\n</code></pre>"},{"location":"reference/symbolic/lowerers/cvxpy/#openscvx.symbolic.lowerers.cvxpy.visitor","title":"<code>visitor(expr_cls: Type[Expr])</code>","text":"<p>Decorator to register a visitor function for an expression type.</p> <p>This decorator registers a visitor method to handle a specific expression type during CVXPy lowering. The decorated function is stored in _CVXPY_VISITORS and will be called by dispatch() when lowering that expression type.</p> <p>Parameters:</p> Name Type Description Default <code>expr_cls</code> <code>Type[Expr]</code> <p>The Expr subclass this visitor handles (e.g., Add, Mul, Norm)</p> required <p>Returns:</p> Type Description <p>Decorator function that registers the visitor and returns it unchanged</p> Example <p>Register a function as the visitor for the Add expression:</p> <pre><code>@visitor(Add)\ndef _visit_add(self, node: Add):\n    # Lower addition to CVXPy\n    ...\n</code></pre> Note <p>Multiple expression types can share a visitor by stacking decorators::</p> <pre><code>@visitor(Equality)\n@visitor(Inequality)\ndef _visit_constraint(self, node: Constraint):\n    # Handle both equality and inequality\n    ...\n</code></pre> Source code in <code>openscvx/symbolic/lowerers/cvxpy.py</code> <pre><code>def visitor(expr_cls: Type[Expr]):\n    \"\"\"Decorator to register a visitor function for an expression type.\n\n    This decorator registers a visitor method to handle a specific expression\n    type during CVXPy lowering. The decorated function is stored in _CVXPY_VISITORS\n    and will be called by dispatch() when lowering that expression type.\n\n    Args:\n        expr_cls: The Expr subclass this visitor handles (e.g., Add, Mul, Norm)\n\n    Returns:\n        Decorator function that registers the visitor and returns it unchanged\n\n    Example:\n        Register a function as the visitor for the Add expression:\n\n            @visitor(Add)\n            def _visit_add(self, node: Add):\n                # Lower addition to CVXPy\n                ...\n\n    Note:\n        Multiple expression types can share a visitor by stacking decorators::\n\n            @visitor(Equality)\n            @visitor(Inequality)\n            def _visit_constraint(self, node: Constraint):\n                # Handle both equality and inequality\n                ...\n    \"\"\"\n\n    def register(fn: Callable[[Any, Expr], cp.Expression]):\n        _CVXPY_VISITORS[expr_cls] = fn\n        return fn\n\n    return register\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/","title":"jax","text":"<p>JAX backend for lowering symbolic expressions to executable functions.</p> <p>This module implements the JAX lowering backend that converts symbolic expression AST nodes into JAX functions with automatic differentiation support. The lowering uses a visitor pattern where each expression type has a corresponding visitor method.</p> Architecture <p>The JAX lowerer follows a visitor pattern with centralized registration:</p> <ol> <li>Visitor Registration: The @visitor decorator registers handler functions    for each expression type in the _JAX_VISITORS dictionary</li> <li>Dispatch: The dispatch() function looks up and calls the appropriate    visitor based on the expression's type</li> <li>Recursive Lowering: Each visitor recursively lowers child expressions    and composes JAX operations</li> <li>Standardized Signature: All lowered functions have signature    (x, u, node, params) -&gt; result for uniformity</li> </ol> Key Features <ul> <li>Automatic Differentiation: Lowered functions can be differentiated using   JAX's jacfwd/jacrev for computing Jacobians</li> <li>JIT Compilation: All functions are JAX-traceable and JIT-compatible</li> <li>Functional Closures: Each visitor returns a closure that captures   necessary constants and child functions</li> <li>Broadcasting: Supports NumPy-style broadcasting through jnp operations</li> </ul> Lowered Function Signature <p>All lowered functions have a uniform signature::</p> <pre><code>f(x, u, node, params) -&gt; result\n</code></pre> <p>Where:</p> <ul> <li>x: State vector (jnp.ndarray)</li> <li>u: Control vector (jnp.ndarray)</li> <li>node: Node index for time-varying behavior (scalar or array)</li> <li>params: Dictionary of parameter values (dict[str, Any])</li> <li>result: JAX array (scalar, vector, or matrix)</li> </ul> Example <p>Basic usage::</p> <pre><code>from openscvx.symbolic.lowerers.jax import JaxLowerer\nimport openscvx as ox\n\n# Create symbolic expression\nx = ox.State(\"x\", shape=(3,))\nu = ox.Control(\"u\", shape=(2,))\nexpr = ox.Norm(x)**2 + 0.1 * ox.Norm(u)**2\n\n# Lower to JAX\nlowerer = JaxLowerer()\nf = lowerer.lower(expr)\n\n# Evaluate\nimport jax.numpy as jnp\nx_val = jnp.array([1.0, 2.0, 3.0])\nu_val = jnp.array([0.5, 0.5])\nresult = f(x_val, u_val, node=0, params={})\n\n# Differentiate\nfrom jax import jacfwd\ndf_dx = jacfwd(f, argnums=0)\ngradient = df_dx(x_val, u_val, node=0, params={})\n</code></pre> For Contributors <p>Adding Support for New Expression Types</p> <p>To add support for a new symbolic expression type to JAX lowering:</p> <ol> <li> <p>Define the visitor method in JaxLowerer with the @visitor decorator::</p> <p>@visitor(MyNewExpr) def _visit_my_new_expr(self, node: MyNewExpr):     # Lower child expressions recursively     operand_fn = self.lower(node.operand)</p> <pre><code># Return a closure with signature (x, u, node, params) -&gt; result\nreturn lambda x, u, node, params: jnp.my_operation(\n    operand_fn(x, u, node, params)\n)\n</code></pre> </li> <li> <p>Key requirements:</p> <ul> <li>Use the @visitor(ExprType) decorator to register the handler</li> <li>Method name should be visit (private, lowercase, snake_case) <li>Recursively lower all child expressions using self.lower()</li> <li>Return a closure with signature (x, u, node, params) -&gt; jax_array</li> <li>Use jnp.* operations (not np.*) for JAX traceability</li> <li>Ensure the result is JAX-differentiable (avoid Python control flow)</li> <li> <p>Example patterns:</p> <ul> <li>Unary operation: Lower operand, apply jnp function</li> <li>Binary operation: Lower both operands, combine with jnp operation</li> <li>N-ary operation: Lower all operands, reduce or combine them</li> <li>Conditional logic: Use jax.lax.cond for branching (see _visit_ctcs)</li> </ul> </li> <li> <p>Testing: Ensure your visitor works with:</p> <ul> <li>JAX JIT compilation: jax.jit(lowered_fn)</li> <li>Automatic differentiation: jax.jacfwd(lowered_fn, argnums=0)</li> <li>Vectorization: jax.vmap(lowered_fn)</li> </ul> </li> See Also <ul> <li>lower_to_jax(): Convenience wrapper in symbolic/lower.py</li> <li>CVXPyLowerer: Alternative backend for convex constraints</li> <li>dispatch(): Core dispatch function for visitor pattern</li> </ul>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer","title":"<code>JaxLowerer</code>","text":"<p>JAX backend for lowering symbolic expressions to executable functions.</p> <p>This class implements the visitor pattern for converting symbolic expression AST nodes to JAX functions. Each expression type has a corresponding visitor method decorated with @visitor that handles the lowering logic.</p> <p>The lowering process is recursive: each visitor lowers its child expressions first, then composes them into a JAX operation. All lowered functions have a standardized signature (x, u, node, params) -&gt; result.</p> Example <p>Set up the JaxLowerer and lower an expression to a JAX function:</p> <pre><code>lowerer = JaxLowerer()\nexpr = ox.Norm(x)**2 + 0.1 * ox.Norm(u)**2\nf = lowerer.lower(expr)\nresult = f(x_val, u_val, node=0, params={})\n</code></pre> Note <p>The lowerer is stateless and can be reused for multiple expressions. All visitor methods are instance methods to maintain a clean interface, but they don't modify instance state.</p> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>class JaxLowerer:\n    \"\"\"JAX backend for lowering symbolic expressions to executable functions.\n\n    This class implements the visitor pattern for converting symbolic expression\n    AST nodes to JAX functions. Each expression type has a corresponding visitor\n    method decorated with @visitor that handles the lowering logic.\n\n    The lowering process is recursive: each visitor lowers its child expressions\n    first, then composes them into a JAX operation. All lowered functions have\n    a standardized signature (x, u, node, params) -&gt; result.\n\n    Attributes:\n        None (stateless lowerer - all state is in the expression tree)\n\n    Example:\n        Set up the JaxLowerer and lower an expression to a JAX function:\n\n            lowerer = JaxLowerer()\n            expr = ox.Norm(x)**2 + 0.1 * ox.Norm(u)**2\n            f = lowerer.lower(expr)\n            result = f(x_val, u_val, node=0, params={})\n\n    Note:\n        The lowerer is stateless and can be reused for multiple expressions.\n        All visitor methods are instance methods to maintain a clean interface,\n        but they don't modify instance state.\n    \"\"\"\n\n    def lower(self, expr: Expr):\n        \"\"\"Lower a symbolic expression to a JAX function.\n\n        Main entry point for lowering. Delegates to dispatch() which looks up\n        the appropriate visitor method based on the expression type.\n\n        Args:\n            expr: Symbolic expression to lower (any Expr subclass)\n\n        Returns:\n            JAX function with signature (x, u, node, params) -&gt; result\n\n        Raises:\n            NotImplementedError: If no visitor exists for the expression type\n            ValueError: If the expression is malformed (e.g., State without slice)\n\n        Example:\n            Lower an expression to a JAX function:\n\n                lowerer = JaxLowerer()\n                x = ox.State(\"x\", shape=(3,))\n                expr = ox.Norm(x)\n                f = lowerer.lower(expr)\n                # f is now callable\n        \"\"\"\n        return dispatch(self, expr)\n\n    @visitor(Constant)\n    def _visit_constant(self, node: Constant):\n        \"\"\"Lower a constant value to a JAX function.\n\n        Captures the constant value and returns a function that always returns it.\n        Scalar constants are squeezed to ensure they're true scalars, not (1,) arrays.\n\n        Args:\n            node: Constant expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; constant_value\n        \"\"\"\n        # capture the constant value once\n        value = jnp.array(node.value)\n        # For scalar constants (single element arrays), squeeze to scalar\n        # This prevents (1,) shapes in constraint residuals\n        if value.size == 1:\n            value = value.squeeze()\n        return lambda x, u, node, params: value\n\n    @visitor(State)\n    def _visit_state(self, node: State):\n        \"\"\"Lower a state variable to a JAX function.\n\n        Extracts the appropriate slice from the unified state vector x using\n        the slice assigned during unification.\n\n        Args:\n            node: State expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; x[slice]\n\n        Raises:\n            ValueError: If the state has no slice assigned (unification not run)\n        \"\"\"\n        sl = node._slice\n        if sl is None:\n            raise ValueError(f\"State {node.name!r} has no slice assigned\")\n        return lambda x, u, node, params: x[sl]\n\n    @visitor(Control)\n    def _visit_control(self, node: Control):\n        \"\"\"Lower a control variable to a JAX function.\n\n        Extracts the appropriate slice from the unified control vector u using\n        the slice assigned during unification.\n\n        Args:\n            node: Control expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; u[slice]\n\n        Raises:\n            ValueError: If the control has no slice assigned (unification not run)\n        \"\"\"\n        sl = node._slice\n        if sl is None:\n            raise ValueError(f\"Control {node.name!r} has no slice assigned\")\n        return lambda x, u, node, params: u[sl]\n\n    @visitor(Parameter)\n    def _visit_parameter(self, node: Parameter):\n        \"\"\"Lower a parameter to a JAX function.\n\n        Parameters are looked up by name in the params dictionary at evaluation time,\n        allowing runtime parameter updates without recompilation.\n\n        Args:\n            node: Parameter expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; params[name]\n        \"\"\"\n        param_name = node.name\n        return lambda x, u, node, params: jnp.array(params[param_name])\n\n    @visitor(Add)\n    def _visit_add(self, node: Add):\n        \"\"\"Lower addition to JAX function.\n\n        Recursively lowers all terms and composes them with element-wise addition.\n        Supports broadcasting following NumPy/JAX rules.\n\n        Args:\n            node: Add expression node with multiple terms\n\n        Returns:\n            Function (x, u, node, params) -&gt; sum of all terms\n        \"\"\"\n        fs = [self.lower(term) for term in node.terms]\n\n        def fn(x, u, node, params):\n            acc = fs[0](x, u, node, params)\n            for f in fs[1:]:\n                acc = acc + f(x, u, node, params)\n            return acc\n\n        return fn\n\n    @visitor(Sub)\n    def _visit_sub(self, node: Sub):\n        \"\"\"Lower subtraction to JAX function (element-wise left - right).\"\"\"\n        fL = self.lower(node.left)\n        fR = self.lower(node.right)\n        return lambda x, u, node, params: fL(x, u, node, params) - fR(x, u, node, params)\n\n    @visitor(Mul)\n    def _visit_mul(self, node: Mul):\n        \"\"\"Lower element-wise multiplication to JAX function (Hadamard product).\"\"\"\n        fs = [self.lower(factor) for factor in node.factors]\n\n        def fn(x, u, node, params):\n            acc = fs[0](x, u, node, params)\n            for f in fs[1:]:\n                acc = acc * f(x, u, node, params)\n            return acc\n\n        return fn\n\n    @visitor(Div)\n    def _visit_div(self, node: Div):\n        \"\"\"Lower element-wise division to JAX function.\"\"\"\n        fL = self.lower(node.left)\n        fR = self.lower(node.right)\n        return lambda x, u, node, params: fL(x, u, node, params) / fR(x, u, node, params)\n\n    @visitor(MatMul)\n    def _visit_matmul(self, node: MatMul):\n        \"\"\"Lower matrix multiplication to JAX function using jnp.matmul.\"\"\"\n        fL = self.lower(node.left)\n        fR = self.lower(node.right)\n        return lambda x, u, node, params: jnp.matmul(fL(x, u, node, params), fR(x, u, node, params))\n\n    @visitor(Neg)\n    def _visit_neg(self, node: Neg):\n        \"\"\"Lower negation (unary minus) to JAX function.\"\"\"\n        fO = self.lower(node.operand)\n        return lambda x, u, node, params: -fO(x, u, node, params)\n\n    @visitor(Sum)\n    def _visit_sum(self, node: Sum):\n        \"\"\"Lower sum reduction to JAX function (sums all elements).\"\"\"\n        f = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.sum(f(x, u, node, params))\n\n    @visitor(Norm)\n    def _visit_norm(self, node: Norm):\n        \"\"\"Lower norm operation to JAX function.\n\n        Converts symbolic norm to jnp.linalg.norm with appropriate ord parameter.\n        Handles string ord values like \"inf\", \"-inf\", \"fro\".\n\n        Args:\n            node: Norm expression node with ord attribute\n\n        Returns:\n            Function (x, u, node, params) -&gt; norm of operand\n        \"\"\"\n        f = self.lower(node.operand)\n        ord_val = node.ord\n\n        # Convert string ord values to appropriate JAX values\n        if ord_val == \"inf\":\n            ord_val = jnp.inf\n        elif ord_val == \"-inf\":\n            ord_val = -jnp.inf\n        elif ord_val == \"fro\":\n            # For vectors, Frobenius norm is the same as 2-norm\n            ord_val = None  # Default is 2-norm\n\n        return lambda x, u, node, params: jnp.linalg.norm(f(x, u, node, params), ord=ord_val)\n\n    @visitor(Index)\n    def _visit_index(self, node: Index):\n        \"\"\"Lower indexing/slicing operation to JAX function.\n\n        For multi-dimensional indexing, the base array is reshaped to its\n        original shape before applying the index. This is necessary because\n        State variables are stored flattened in the state vector.\n        \"\"\"\n        f_base = self.lower(node.base)\n        idx = node.index\n        base_shape = node.base.check_shape()\n\n        def index_fn(x, u, node_arg, params):\n            arr = f_base(x, u, node_arg, params)\n            # Reshape to original shape for multi-dimensional indexing\n            if len(base_shape) &gt; 1:\n                arr = arr.reshape(base_shape)\n            else:\n                arr = jnp.atleast_1d(arr)\n            return arr[idx]\n\n        return index_fn\n\n    @visitor(Concat)\n    def _visit_concat(self, node: Concat):\n        \"\"\"Lower concatenation to JAX function (concatenates along axis 0).\"\"\"\n        # lower each child\n        fn_list = [self.lower(child) for child in node.exprs]\n\n        # wrapper that promotes scalars to 1-D and concatenates\n        def concat_fn(x, u, node, params):\n            parts = [jnp.atleast_1d(fn(x, u, node, params)) for fn in fn_list]\n            return jnp.concatenate(parts, axis=0)\n\n        return concat_fn\n\n    @visitor(Sin)\n    def _visit_sin(self, node: Sin):\n        \"\"\"Lower sine function to JAX function.\"\"\"\n        fO = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.sin(fO(x, u, node, params))\n\n    @visitor(Cos)\n    def _visit_cos(self, node: Cos):\n        \"\"\"Lower cosine function to JAX function.\"\"\"\n        fO = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.cos(fO(x, u, node, params))\n\n    @visitor(Tan)\n    def _visit_tan(self, node: Tan):\n        \"\"\"Lower tangent function to JAX function.\"\"\"\n        fO = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.tan(fO(x, u, node, params))\n\n    @visitor(Exp)\n    def _visit_exp(self, node: Exp):\n        \"\"\"Lower exponential function to JAX function.\"\"\"\n        fO = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.exp(fO(x, u, node, params))\n\n    @visitor(Log)\n    def _visit_log(self, node: Log):\n        \"\"\"Lower natural logarithm to JAX function.\"\"\"\n        fO = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.log(fO(x, u, node, params))\n\n    @visitor(Abs)\n    def _visit_abs(self, node: Abs):\n        \"\"\"Lower absolute value to JAX function.\"\"\"\n        fO = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.abs(fO(x, u, node, params))\n\n    @visitor(Equality)\n    @visitor(Inequality)\n    def _visit_constraint(self, node: Constraint):\n        \"\"\"Lower constraint to residual function.\n\n        Both equality (lhs == rhs) and inequality (lhs &lt;= rhs) constraints are\n        lowered to their residual form: lhs - rhs. The constraint is satisfied\n        when the residual equals zero (equality) or is non-positive (inequality).\n\n        Args:\n            node: Equality or Inequality constraint node\n\n        Returns:\n            Function (x, u, node, params) -&gt; lhs - rhs (constraint residual)\n\n        Note:\n            The returned residual is used in penalty methods and Lagrangian terms.\n            For equality: residual should be 0\n            For inequality: residual should be &lt;= 0\n        \"\"\"\n        fL = self.lower(node.lhs)\n        fR = self.lower(node.rhs)\n        return lambda x, u, node, params: fL(x, u, node, params) - fR(x, u, node, params)\n\n    # TODO: (norrisg) CTCS is playing 2 roles here: both as a constraint wrapper and as the penalty\n    # expression w/ conditional logic. Consider adding conditional logic as separate AST nodes.\n    # Then, CTCS remains a wrapper and we just wrap the penalty expression with the conditional\n    # logic when we lower it.\n    @visitor(CTCS)\n    def _visit_ctcs(self, node: CTCS):\n        \"\"\"Lower CTCS (Continuous-Time Constraint Satisfaction) to JAX function.\n\n        CTCS constraints use penalty methods to enforce constraints over continuous\n        time intervals. The lowered function includes conditional logic to activate\n        the penalty only within the specified node interval.\n\n        Args:\n            node: CTCS constraint node with penalty expression and optional node range\n\n        Returns:\n            Function (x, u, current_node, params) -&gt; penalty value or 0\n\n        Note:\n            Uses jax.lax.cond for JAX-traceable conditional evaluation. The penalty\n            is active only when current_node is in [start_node, end_node).\n            If no node range is specified, the penalty is always active.\n\n        See Also:\n            - CTCS: The symbolic CTCS constraint class\n            - penalty functions: PositivePart, Huber, SmoothReLU\n        \"\"\"\n        # Lower the penalty expression (which includes the constraint residual)\n        penalty_expr_fn = self.lower(node.penalty_expr())\n\n        def ctcs_fn(x, u, current_node, params):\n            # Check if constraint is active at this node\n            if node.nodes is not None:\n                start_node, end_node = node.nodes\n                # Extract scalar value from current_node (which may be array or scalar)\n                # Keep as JAX array for tracing compatibility\n                node_scalar = jnp.atleast_1d(current_node)[0]\n                is_active = (start_node &lt;= node_scalar) &amp; (node_scalar &lt; end_node)\n\n                # Use jax.lax.cond for conditional evaluation\n                return cond(\n                    is_active,\n                    lambda _: penalty_expr_fn(x, u, current_node, params),\n                    lambda _: 0.0,\n                    operand=None,\n                )\n            else:\n                # Always active if no node range specified\n                return penalty_expr_fn(x, u, current_node, params)\n\n        return ctcs_fn\n\n    @visitor(PositivePart)\n    def _visit_pos(self, node):\n        \"\"\"Lower positive part function to JAX.\n\n        Computes max(x, 0), used in penalty methods for inequality constraints.\n\n        Args:\n            node: PositivePart expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; max(operand, 0)\n        \"\"\"\n        f = self.lower(node.x)\n        return lambda x, u, node, params: jnp.maximum(f(x, u, node, params), 0.0)\n\n    @visitor(Square)\n    def _visit_square(self, node):\n        \"\"\"Lower square function to JAX.\n\n        Computes x^2 element-wise. Used in quadratic penalty methods.\n\n        Args:\n            node: Square expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; operand^2\n        \"\"\"\n        f = self.lower(node.x)\n        return lambda x, u, node, params: f(x, u, node, params) * f(x, u, node, params)\n\n    @visitor(Huber)\n    def _visit_huber(self, node):\n        \"\"\"Lower Huber penalty function to JAX.\n\n        Huber penalty is quadratic for small values and linear for large values:\n        - |x| &lt;= delta: 0.5 * x^2\n        - |x| &gt; delta: delta * (|x| - 0.5 * delta)\n\n        Args:\n            node: Huber expression node with delta parameter\n\n        Returns:\n            Function (x, u, node, params) -&gt; Huber penalty\n        \"\"\"\n        f = self.lower(node.x)\n        delta = node.delta\n        return lambda x, u, node, params: jnp.where(\n            jnp.abs(f(x, u, node, params)) &lt;= delta,\n            0.5 * f(x, u, node, params) ** 2,\n            delta * (jnp.abs(f(x, u, node, params)) - 0.5 * delta),\n        )\n\n    @visitor(SmoothReLU)\n    def _visit_srelu(self, node):\n        \"\"\"Lower smooth ReLU penalty function to JAX.\n\n        Smooth approximation to ReLU: sqrt(max(x, 0)^2 + c^2) - c\n        Differentiable everywhere, approaches ReLU as c -&gt; 0.\n\n        Args:\n            node: SmoothReLU expression node with smoothing parameter c\n\n        Returns:\n            Function (x, u, node, params) -&gt; smooth ReLU penalty\n        \"\"\"\n        f = self.lower(node.x)\n        c = node.c\n        # smooth_relu(pos(x)) = sqrt(pos(x)^2 + c^2) - c ; here f already includes pos inside node\n        return (\n            lambda x, u, node, params: jnp.sqrt(jnp.maximum(f(x, u, node, params), 0.0) ** 2 + c**2)\n            - c\n        )\n\n    @visitor(NodalConstraint)\n    def _visit_nodal_constraint(self, node: NodalConstraint):\n        \"\"\"Lower a NodalConstraint by lowering its underlying constraint.\n\n        NodalConstraint is a wrapper that specifies which nodes a constraint\n        applies to. The lowering just unwraps and lowers the inner constraint.\n\n        Args:\n            node: NodalConstraint wrapper\n\n        Returns:\n            Function from lowering the wrapped constraint expression\n        \"\"\"\n        return self.lower(node.constraint)\n\n    @visitor(Sqrt)\n    def _visit_sqrt(self, node: Sqrt):\n        \"\"\"Lower square root to JAX function.\"\"\"\n        f = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.sqrt(f(x, u, node, params))\n\n    @visitor(Max)\n    def _visit_max(self, node: Max):\n        \"\"\"Lower element-wise maximum to JAX function.\"\"\"\n        fs = [self.lower(op) for op in node.operands]\n\n        def fn(x, u, node, params):\n            values = [f(x, u, node, params) for f in fs]\n            # jnp.maximum can take multiple arguments\n            result = values[0]\n            for val in values[1:]:\n                result = jnp.maximum(result, val)\n            return result\n\n        return fn\n\n    @visitor(LogSumExp)\n    def _visit_logsumexp(self, node: LogSumExp):\n        \"\"\"Lower log-sum-exp to JAX function.\n\n        Computes log(sum(exp(x_i))) for multiple operands, which is a smooth\n        approximation to the maximum function. Uses JAX's numerically stable\n        logsumexp implementation. Performs element-wise log-sum-exp with\n        broadcasting support.\n        \"\"\"\n        fs = [self.lower(op) for op in node.operands]\n\n        def fn(x, u, node, params):\n            values = [f(x, u, node, params) for f in fs]\n            # Broadcast all values to the same shape, then stack along new axis\n            # and compute logsumexp along that axis for element-wise operation\n            broadcasted = jnp.broadcast_arrays(*values)\n            stacked = jnp.stack(list(broadcasted), axis=0)\n            return logsumexp(stacked, axis=0)\n\n        return fn\n\n    @visitor(Transpose)\n    def _visit_transpose(self, node: Transpose):\n        \"\"\"Lower matrix transpose to JAX function.\"\"\"\n        f = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.transpose(f(x, u, node, params))\n\n    @visitor(Power)\n    def _visit_power(self, node: Power):\n        \"\"\"Lower element-wise power (base**exponent) to JAX function.\"\"\"\n        fB = self.lower(node.base)\n        fE = self.lower(node.exponent)\n        return lambda x, u, node, params: jnp.power(fB(x, u, node, params), fE(x, u, node, params))\n\n    @visitor(Stack)\n    def _visit_stack(self, node: Stack):\n        \"\"\"Lower vertical stacking to JAX function (stack along axis 0).\"\"\"\n        row_fns = [self.lower(row) for row in node.rows]\n\n        def stack_fn(x, u, node, params):\n            rows = [jnp.atleast_1d(fn(x, u, node, params)) for fn in row_fns]\n            return jnp.stack(rows, axis=0)\n\n        return stack_fn\n\n    @visitor(Hstack)\n    def _visit_hstack(self, node: Hstack):\n        \"\"\"Lower horizontal stacking to JAX function.\"\"\"\n        array_fns = [self.lower(arr) for arr in node.arrays]\n\n        def hstack_fn(x, u, node, params):\n            arrays = [jnp.atleast_1d(fn(x, u, node, params)) for fn in array_fns]\n            return jnp.hstack(arrays)\n\n        return hstack_fn\n\n    @visitor(Vstack)\n    def _visit_vstack(self, node: Vstack):\n        \"\"\"Lower vertical stacking to JAX function.\"\"\"\n        array_fns = [self.lower(arr) for arr in node.arrays]\n\n        def vstack_fn(x, u, node, params):\n            arrays = [jnp.atleast_1d(fn(x, u, node, params)) for fn in array_fns]\n            return jnp.vstack(arrays)\n\n        return vstack_fn\n\n    @visitor(Block)\n    def _visit_block(self, node: Block):\n        \"\"\"Lower block matrix construction to JAX function.\n\n        Assembles a block matrix from nested lists of expressions. For 2D blocks,\n        uses jnp.block directly. For N-D blocks (3D+), manually assembles along\n        the first two dimensions using concatenate, since jnp.block concatenates\n        along the last axes (not what we want for block matrix semantics).\n\n        Args:\n            node: Block expression node with 2D nested structure of expressions\n\n        Returns:\n            Function (x, u, node, params) -&gt; assembled block matrix/tensor\n        \"\"\"\n        # Lower each block expression\n        block_fns = [[self.lower(block) for block in row] for row in node.blocks]\n\n        def block_fn(x, u, node_arg, params):\n            # Evaluate all blocks\n            block_values = [\n                [jnp.atleast_1d(fn(x, u, node_arg, params)) for fn in row] for row in block_fns\n            ]\n\n            # Check if any block is 3D+ (need manual assembly)\n            max_ndim = max(arr.ndim for row in block_values for arr in row)\n\n            if max_ndim &lt;= 2:\n                # For 2D, jnp.block works correctly\n                return jnp.block(block_values)\n            else:\n                # For N-D, manually assemble along axes 0 and 1\n                # First, ensure all blocks have the same number of dimensions\n                def promote_to_ndim(arr, target_ndim):\n                    while arr.ndim &lt; target_ndim:\n                        arr = jnp.expand_dims(arr, axis=0)\n                    return arr\n\n                block_values = [\n                    [promote_to_ndim(arr, max_ndim) for arr in row] for row in block_values\n                ]\n\n                # Concatenate each row along axis 1 (horizontal)\n                row_results = [jnp.concatenate(row, axis=1) for row in block_values]\n                # Concatenate rows along axis 0 (vertical)\n                return jnp.concatenate(row_results, axis=0)\n\n        return block_fn\n\n    @visitor(QDCM)\n    def _visit_qdcm(self, node: QDCM):\n        \"\"\"Lower quaternion to direction cosine matrix (DCM) conversion.\n\n        Converts a unit quaternion [q0, q1, q2, q3] to a 3x3 rotation matrix.\n        Used in 6-DOF spacecraft and robotics applications.\n\n        The quaternion is normalized before conversion to ensure a valid rotation\n        matrix. The DCM is computed using the standard quaternion-to-DCM formula.\n\n        Args:\n            node: QDCM expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; 3x3 rotation matrix\n\n        Note:\n            Quaternion convention: [w, x, y, z] where w is the scalar part\n        \"\"\"\n        f = self.lower(node.q)\n\n        def qdcm_fn(x, u, node, params):\n            q = f(x, u, node, params)\n            # Normalize the quaternion\n            q_norm = jnp.sqrt(q[0] ** 2 + q[1] ** 2 + q[2] ** 2 + q[3] ** 2)\n            w, qx, qy, qz = q / q_norm\n            # Convert to direction cosine matrix\n            return jnp.array(\n                [\n                    [1 - 2 * (qy**2 + qz**2), 2 * (qx * qy - qz * w), 2 * (qx * qz + qy * w)],\n                    [2 * (qx * qy + qz * w), 1 - 2 * (qx**2 + qz**2), 2 * (qy * qz - qx * w)],\n                    [2 * (qx * qz - qy * w), 2 * (qy * qz + qx * w), 1 - 2 * (qx**2 + qy**2)],\n                ]\n            )\n\n        return qdcm_fn\n\n    @visitor(SSMP)\n    def _visit_ssmp(self, node: SSMP):\n        \"\"\"Lower skew-symmetric matrix for quaternion dynamics (4x4).\n\n        Creates a 4x4 skew-symmetric matrix from angular velocity vector for\n        quaternion kinematic propagation: q_dot = 0.5 * SSMP(omega) @ q\n\n        The SSMP matrix is used in quaternion kinematics to compute quaternion\n        derivatives from angular velocity vectors.\n\n        Args:\n            node: SSMP expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; 4x4 skew-symmetric matrix\n\n        Note:\n            For angular velocity w = [x, y, z], returns:\n            [[0, -x, -y, -z],\n             [x,  0,  z, -y],\n             [y, -z,  0,  x],\n             [z,  y, -x,  0]]\n        \"\"\"\n        f = self.lower(node.w)\n\n        def ssmp_fn(x, u, node, params):\n            w = f(x, u, node, params)\n            wx, wy, wz = w[0], w[1], w[2]\n            return jnp.array(\n                [\n                    [0, -wx, -wy, -wz],\n                    [wx, 0, wz, -wy],\n                    [wy, -wz, 0, wx],\n                    [wz, wy, -wx, 0],\n                ]\n            )\n\n        return ssmp_fn\n\n    @visitor(SSM)\n    def _visit_ssm(self, node: SSM):\n        \"\"\"Lower skew-symmetric matrix for cross product (3x3).\n\n        Creates a 3x3 skew-symmetric matrix from a vector such that\n        SSM(a) @ b = a x b (cross product).\n\n        The SSM is the matrix representation of the cross product operator,\n        allowing cross products to be computed as matrix-vector multiplication.\n\n        Args:\n            node: SSM expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; 3x3 skew-symmetric matrix\n\n        Note:\n            For vector w = [x, y, z], returns:\n            [[ 0, -z,  y],\n             [ z,  0, -x],\n             [-y,  x,  0]]\n        \"\"\"\n        f = self.lower(node.w)\n\n        def ssm_fn(x, u, node, params):\n            w = f(x, u, node, params)\n            wx, wy, wz = w[0], w[1], w[2]\n            return jnp.array([[0, -wz, wy], [wz, 0, -wx], [-wy, wx, 0]])\n\n        return ssm_fn\n\n    @visitor(AdjointDual)\n    def _visit_adjoint_dual(self, node: AdjointDual):\n        \"\"\"Lower coadjoint operator ad* for rigid body dynamics.\n\n        Computes the coadjoint action ad*_\u03be(\u03bc) which represents Coriolis and\n        centrifugal forces in rigid body dynamics. This is the key term in\n        Newton-Euler equations.\n\n        For se(3), given twist \u03be = [v; \u03c9] and momentum \u03bc = [f; \u03c4]:\n\n            ad*_\u03be(\u03bc) = [ \u03c9 \u00d7 f + v \u00d7 \u03c4 ]\n                       [     \u03c9 \u00d7 \u03c4     ]\n\n        This appears in the equations of motion as:\n            M @ \u03be_dot = F_ext - ad*_\u03be(M @ \u03be)\n\n        Args:\n            node: AdjointDual expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; 6D coadjoint result\n\n        Note:\n            Convention: twist = [v; \u03c9] (linear velocity, angular velocity)\n                       momentum = [f; \u03c4] (force, torque)\n        \"\"\"\n        f_twist = self.lower(node.twist)\n        f_momentum = self.lower(node.momentum)\n\n        def adjoint_dual_fn(x, u, node, params):\n            twist = f_twist(x, u, node, params)\n            momentum = f_momentum(x, u, node, params)\n\n            # Extract components: twist = [v; \u03c9], momentum = [f; \u03c4]\n            v = twist[:3]  # Linear velocity\n            omega = twist[3:]  # Angular velocity\n            f = momentum[:3]  # Force (or linear momentum)\n            tau = momentum[3:]  # Torque (or angular momentum)\n\n            # Coadjoint action: ad*_\u03be(\u03bc) = [\u03c9 \u00d7 f + v \u00d7 \u03c4; \u03c9 \u00d7 \u03c4]\n            linear_part = jnp.cross(omega, f) + jnp.cross(v, tau)\n            angular_part = jnp.cross(omega, tau)\n\n            return jnp.concatenate([linear_part, angular_part])\n\n        return adjoint_dual_fn\n\n    @visitor(Adjoint)\n    def _visit_adjoint(self, node: Adjoint):\n        \"\"\"Lower adjoint operator ad (Lie bracket) for twist-on-twist action.\n\n        Computes the adjoint action ad_\u03be\u2081(\u03be\u2082) which represents the Lie bracket\n        [\u03be\u2081, \u03be\u2082] of two twists. Used for velocity propagation and acceleration\n        computation in kinematic chains.\n\n        For se(3), given twists \u03be\u2081 = [v\u2081; \u03c9\u2081] and \u03be\u2082 = [v\u2082; \u03c9\u2082]:\n\n            ad_\u03be\u2081(\u03be\u2082) = [ \u03c9\u2081 \u00d7 v\u2082 - \u03c9\u2082 \u00d7 v\u2081 ]\n                        [     \u03c9\u2081 \u00d7 \u03c9\u2082       ]\n\n        Args:\n            node: Adjoint expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; 6D Lie bracket result\n\n        Note:\n            The Lie bracket is antisymmetric: [\u03be\u2081, \u03be\u2082] = -[\u03be\u2082, \u03be\u2081]\n        \"\"\"\n        f_twist1 = self.lower(node.twist1)\n        f_twist2 = self.lower(node.twist2)\n\n        def adjoint_fn(x, u, node, params):\n            twist1 = f_twist1(x, u, node, params)\n            twist2 = f_twist2(x, u, node, params)\n\n            # Extract components: twist = [v; \u03c9]\n            v1 = twist1[:3]\n            omega1 = twist1[3:]\n            v2 = twist2[:3]\n            omega2 = twist2[3:]\n\n            # Lie bracket: [\u03be\u2081, \u03be\u2082] = [\u03c9\u2081 \u00d7 v\u2082 - \u03c9\u2082 \u00d7 v\u2081; \u03c9\u2081 \u00d7 \u03c9\u2082]\n            linear_part = jnp.cross(omega1, v2) - jnp.cross(omega2, v1)\n            angular_part = jnp.cross(omega1, omega2)\n\n            return jnp.concatenate([linear_part, angular_part])\n\n        return adjoint_fn\n\n    @visitor(SE3Adjoint)\n    def _visit_se3_adjoint(self, node: SE3Adjoint):\n        \"\"\"Lower SE3 Adjoint (big Ad) for transforming twists between frames.\n\n        Computes the 6\u00d76 adjoint matrix Ad_T that transforms twists:\n            \u03be_b = Ad_{T_ab} @ \u03be_a\n\n        For SE(3) with rotation R and translation p:\n            Ad_T = [ R      0   ]\n                   [ [p]\u00d7R  R   ]\n\n        Args:\n            node: SE3Adjoint expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; 6\u00d76 adjoint matrix\n        \"\"\"\n        f_transform = self.lower(node.transform)\n\n        def se3_adjoint_fn(x, u, node, params):\n            T = f_transform(x, u, node, params)\n\n            # Extract rotation and translation from 4\u00d74 homogeneous matrix\n            R = T[:3, :3]\n            p = T[:3, 3]\n\n            # Build skew-symmetric matrix [p]\u00d7\n            p_skew = jnp.array([[0, -p[2], p[1]], [p[2], 0, -p[0]], [-p[1], p[0], 0]])\n\n            # Build 6\u00d76 adjoint matrix\n            # Ad_T = [ R      0   ]\n            #        [ [p]\u00d7R  R   ]\n            top_row = jnp.hstack([R, jnp.zeros((3, 3))])\n            bottom_row = jnp.hstack([p_skew @ R, R])\n\n            return jnp.vstack([top_row, bottom_row])\n\n        return se3_adjoint_fn\n\n    @visitor(SE3AdjointDual)\n    def _visit_se3_adjoint_dual(self, node: SE3AdjointDual):\n        \"\"\"Lower SE3 coadjoint (big Ad*) for transforming wrenches between frames.\n\n        Computes the 6\u00d76 coadjoint matrix Ad*_T that transforms wrenches:\n            F_a = Ad*_{T_ab} @ F_b\n\n        For SE(3) with rotation R and translation p:\n            Ad*_T = [ R     [p]\u00d7R ]\n                    [ 0       R   ]\n\n        This is the transpose-inverse of Ad_T.\n\n        Args:\n            node: SE3AdjointDual expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; 6\u00d76 coadjoint matrix\n        \"\"\"\n        f_transform = self.lower(node.transform)\n\n        def se3_adjoint_dual_fn(x, u, node, params):\n            T = f_transform(x, u, node, params)\n\n            # Extract rotation and translation from 4\u00d74 homogeneous matrix\n            R = T[:3, :3]\n            p = T[:3, 3]\n\n            # Build skew-symmetric matrix [p]\u00d7\n            p_skew = jnp.array([[0, -p[2], p[1]], [p[2], 0, -p[0]], [-p[1], p[0], 0]])\n\n            # Build 6\u00d76 coadjoint matrix\n            # Ad*_T = [ R     [p]\u00d7R ]\n            #         [ 0       R   ]\n            top_row = jnp.hstack([R, p_skew @ R])\n            bottom_row = jnp.hstack([jnp.zeros((3, 3)), R])\n\n            return jnp.vstack([top_row, bottom_row])\n\n        return se3_adjoint_dual_fn\n\n    @visitor(SO3Exp)\n    def _visit_so3_exp(self, node: SO3Exp):\n        \"\"\"Lower SO3 exponential map using jaxlie.\n\n        Maps a 3D rotation vector (axis-angle) to a 3\u00d73 rotation matrix\n        using jaxlie's numerically robust implementation.\n\n        Args:\n            node: SO3Exp expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; 3\u00d73 rotation matrix\n        \"\"\"\n        import jaxlie\n\n        f_omega = self.lower(node.omega)\n\n        def so3_exp_fn(x, u, node, params):\n            omega = f_omega(x, u, node, params)\n            return jaxlie.SO3.exp(omega).as_matrix()\n\n        return so3_exp_fn\n\n    @visitor(SO3Log)\n    def _visit_so3_log(self, node: SO3Log):\n        \"\"\"Lower SO3 logarithm map using jaxlie.\n\n        Maps a 3\u00d73 rotation matrix to a 3D rotation vector (axis-angle)\n        using jaxlie's numerically robust implementation.\n\n        Args:\n            node: SO3Log expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; 3D rotation vector\n        \"\"\"\n        import jaxlie\n\n        f_rotation = self.lower(node.rotation)\n\n        def so3_log_fn(x, u, node, params):\n            rotation = f_rotation(x, u, node, params)\n            return jaxlie.SO3.from_matrix(rotation).log()\n\n        return so3_log_fn\n\n    @visitor(SE3Exp)\n    def _visit_se3_exp(self, node: SE3Exp):\n        \"\"\"Lower SE3 exponential map using jaxlie.\n\n        Maps a 6D twist vector [v; \u03c9] to a 4\u00d74 homogeneous transformation\n        matrix using jaxlie's numerically robust implementation.\n\n        The twist convention [v; \u03c9] (linear first, angular second) matches\n        jaxlie's SE3 tangent parameterization, so no reordering is needed.\n\n        Args:\n            node: SE3Exp expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; 4\u00d74 transformation matrix\n        \"\"\"\n        import jaxlie\n\n        f_twist = self.lower(node.twist)\n\n        def se3_exp_fn(x, u, node, params):\n            twist = f_twist(x, u, node, params)\n            return jaxlie.SE3.exp(twist).as_matrix()\n\n        return se3_exp_fn\n\n    @visitor(SE3Log)\n    def _visit_se3_log(self, node: SE3Log):\n        \"\"\"Lower SE3 logarithm map using jaxlie.\n\n        Maps a 4\u00d74 homogeneous transformation matrix to a 6D twist vector\n        [v; \u03c9] using jaxlie's numerically robust implementation.\n\n        Args:\n            node: SE3Log expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; 6D twist vector\n        \"\"\"\n        import jaxlie\n\n        f_transform = self.lower(node.transform)\n\n        def se3_log_fn(x, u, node, params):\n            transform = f_transform(x, u, node, params)\n            return jaxlie.SE3.from_matrix(transform).log()\n\n        return se3_log_fn\n\n    @visitor(Diag)\n    def _visit_diag(self, node: Diag):\n        \"\"\"Lower diagonal matrix construction to JAX function.\"\"\"\n        f = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.diag(f(x, u, node, params))\n\n    @visitor(Inv)\n    def _visit_inv(self, node: Inv):\n        \"\"\"Lower matrix inverse to JAX function.\n\n        Computes the inverse of a square matrix using jnp.linalg.inv.\n        Supports batched inputs with shape (..., M, M).\n\n        Args:\n            node: Inv expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; inverse of operand matrix\n        \"\"\"\n        f = self.lower(node.operand)\n        return lambda x, u, node, params: jnp.linalg.inv(f(x, u, node, params))\n\n    @visitor(Or)\n    def _visit_or(self, node: Or):\n        \"\"\"Lower STL disjunction (Or) to JAX using STLJax library.\n\n        Converts a symbolic Or constraint to an STLJax Or formula for handling\n        disjunctive task specifications. Each operand becomes an STLJax predicate.\n\n        Args:\n            node: Or expression node with multiple operands\n\n        Returns:\n            Function (x, u, node, params) -&gt; STL robustness value\n\n        Note:\n            Uses STLJax library for signal temporal logic evaluation. The returned\n            function computes the robustness metric for the disjunction, which is\n            positive when at least one operand is satisfied.\n\n        Example:\n            Used for task specifications like \"reach goal A OR goal B\"::\n\n                goal_A = ox.Norm(x - target_A) &lt;= 1.0\n                goal_B = ox.Norm(x - target_B) &lt;= 1.0\n                task = ox.Or(goal_A, goal_B)\n\n        See Also:\n            - stljax.formula.Or: Underlying STLJax implementation\n            - STL robustness: Quantitative measure of constraint satisfaction\n        \"\"\"\n        from stljax.formula import Or as STLOr\n        from stljax.formula import Predicate\n\n        # Lower each operand to get their functions\n        operand_fns = [self.lower(operand) for operand in node.operands]\n\n        # Return a function that evaluates the STLJax Or\n        def or_fn(x, u, node, params):\n            # Create STLJax predicates for each operand with current params\n            predicates = []\n            for i, operand_fn in enumerate(operand_fns):\n                # Create a predicate function that captures the current params\n                def make_pred_fn(fn):\n                    return lambda x: fn(x, None, None, params)\n\n                pred_fn = make_pred_fn(operand_fn)\n                predicates.append(Predicate(f\"pred_{i}\", pred_fn))\n\n            # Create and evaluate STLJax Or formula\n            stl_or = STLOr(*predicates)\n            return stl_or(x)\n\n        return or_fn\n\n    @visitor(NodeReference)\n    def _visit_node_reference(self, node: NodeReference):\n        \"\"\"Lower NodeReference - extract value at a specific trajectory node.\n\n        NodeReference extracts a state/control value at a specific node from the\n        full trajectory arrays. The node index is baked into the lowered function.\n\n        Args:\n            node: NodeReference expression with base and node_idx (integer)\n\n        Returns:\n            Function (x, u, node_param, params) that extracts from trajectory\n                - x, u: Full trajectories (N, n_x) and (N, n_u)\n                - node_param: Unused (kept for signature compatibility)\n                - params: Problem parameters\n\n        Example:\n            position.at(5) lowers to a function that extracts x[5, position_slice]\n            position.at(k-1) where k=7 lowers to extract x[6, position_slice]\n        \"\"\"\n        from openscvx.symbolic.expr.control import Control\n        from openscvx.symbolic.expr.state import State\n\n        # Node index is baked into the expression at construction time\n        fixed_idx = node.node_idx\n\n        if isinstance(node.base, State):\n            sl = node.base._slice\n            if sl is None:\n                raise ValueError(f\"State {node.base.name!r} has no slice assigned\")\n\n            def state_node_fn(x, u, node_param, params):\n                return x[fixed_idx, sl]\n\n            return state_node_fn\n\n        elif isinstance(node.base, Control):\n            sl = node.base._slice\n            if sl is None:\n                raise ValueError(f\"Control {node.base.name!r} has no slice assigned\")\n\n            def control_node_fn(x, u, node_param, params):\n                return u[fixed_idx, sl]\n\n            return control_node_fn\n\n        else:\n            # Compound expression (e.g., position[0].at(5))\n            base_fn = self.lower(node.base)\n\n            def compound_node_fn(x, u, node_param, params):\n                # Extract single-node slices and evaluate base expression\n                x_single = x[fixed_idx] if len(x.shape) &gt; 1 else x\n                u_single = u[fixed_idx] if len(u.shape) &gt; 1 else u\n                return base_fn(x_single, u_single, fixed_idx, params)\n\n            return compound_node_fn\n\n    @visitor(CrossNodeConstraint)\n    def _visit_cross_node_constraint(self, node: CrossNodeConstraint):\n        \"\"\"Lower CrossNodeConstraint to trajectory-level function.\n\n        CrossNodeConstraint wraps constraints that reference multiple trajectory\n        nodes via NodeReference (e.g., rate limits like x.at(k) - x.at(k-1) &lt;= r).\n\n        Unlike regular nodal constraints which have signature (x, u, node, params)\n        and are vmapped across nodes, cross-node constraints operate on full\n        trajectory arrays and return a scalar residual.\n\n        Args:\n            node: CrossNodeConstraint expression wrapping the inner constraint\n\n        Returns:\n            Function with signature (X, U, params) -&gt; scalar residual\n                - X: Full state trajectory, shape (N, n_x)\n                - U: Full control trajectory, shape (N, n_u)\n                - params: Dictionary of problem parameters\n                - Returns: Scalar constraint residual (g &lt;= 0 convention)\n\n        Note:\n            The inner constraint is lowered first (producing a function with the\n            standard (x, u, node, params) signature), then wrapped to provide the\n            trajectory-level (X, U, params) signature. The `node` parameter is\n            unused since NodeReference nodes have fixed indices baked in.\n\n        Example:\n            For constraint: position.at(5) - position.at(4) &lt;= max_step\n\n            The lowered function evaluates:\n                X[5, pos_slice] - X[4, pos_slice] - max_step\n\n            And returns a scalar residual.\n        \"\"\"\n        # Lower the inner constraint expression\n        inner_fn = self.lower(node.constraint)\n\n        # Wrap to provide trajectory-level signature\n        # The `node` parameter is unused for cross-node constraints since\n        # NodeReference nodes have fixed indices baked in at construction time\n        def trajectory_constraint(X, U, params):\n            return inner_fn(X, U, 0, params)\n\n        return trajectory_constraint\n\n    @visitor(_Placeholder)\n    def _visit_placeholder(self, node: _Placeholder):\n        \"\"\"Lower Placeholder to params lookup.\n\n        Placeholder is used inside Vmap expressions. During lowering, the Vmap\n        visitor injects the current batch element into params, and this visitor\n        retrieves it.\n\n        Args:\n            node: Placeholder expression node\n\n        Returns:\n            Function (x, u, node, params) -&gt; params[placeholder_name]\n        \"\"\"\n        name = node.name\n        return lambda x, u, node_idx, params: params[name]\n\n    @visitor(Vmap)\n    def _visit_vmap(self, node: Vmap):\n        \"\"\"Lower Vmap to jax.vmap.\n\n        Handles two cases based on the type of the data source:\n\n        - **Constant/array**: Data is baked into the closure at lowering time,\n          equivalent to closure-captured values in BYOF.\n        - **Parameter**: Data is looked up from params dict at runtime,\n          allowing updates between SCP iterations.\n\n        Args:\n            node: Vmap expression node\n\n        Returns:\n            Function (x, u, node_idx, params) -&gt; vmapped result\n\n        Example:\n            For ox.Vmap(lambda p: ox.linalg.Norm(x - p), over=points):\n            - points has shape (10, 3)\n            - Output has shape (10,) - one norm per point\n        \"\"\"\n        inner_fn = self.lower(node._child)\n        placeholder_key = node._placeholder.name\n        axis = node._axis\n\n        if node.is_parameter:\n            # Parameter: runtime lookup from params dict\n            param_name = node._batch.name\n\n            def vmapped_fn(x, u, node_idx, params):\n                # Look up the batched data from params at runtime\n                data = params[param_name]\n\n                def inner(v):\n                    return inner_fn(x, u, node_idx, {**params, placeholder_key: v})\n\n                return jax.vmap(inner, in_axes=axis)(data)\n\n        else:\n            # Constant/array: baked in at lowering time (closure-equivalent)\n            data = jnp.array(node._batch.value)\n\n            def vmapped_fn(x, u, node_idx, params):\n                def inner(v):\n                    return inner_fn(x, u, node_idx, {**params, placeholder_key: v})\n\n                return jax.vmap(inner, in_axes=axis)(data)\n\n        return vmapped_fn\n\n    @visitor(Linterp)\n    def _visit_linterp(self, node: Linterp):\n        \"\"\"Lower 1D linear interpolation to JAX function.\n\n        Uses jnp.interp which performs piecewise linear interpolation.\n        For query points outside the data range, boundary values are returned.\n\n        Args:\n            node: Linterp expression node with xp, fp, and x\n\n        Returns:\n            Function (x, u, node, params) -&gt; interpolated value(s)\n\n        Note:\n            The xp and fp arrays are typically constants (tabulated data),\n            while x is typically a symbolic expression (state or derived value).\n            jnp.interp is differentiable through JAX's autodiff.\n        \"\"\"\n        f_xp = self.lower(node.xp)\n        f_fp = self.lower(node.fp)\n        f_x = self.lower(node.x)\n\n        def linterp_fn(x, u, node_idx, params):\n            xp_val = f_xp(x, u, node_idx, params)\n            fp_val = f_fp(x, u, node_idx, params)\n            x_val = f_x(x, u, node_idx, params)\n            return jnp.interp(x_val, xp_val, fp_val)\n\n        return linterp_fn\n\n    @visitor(Bilerp)\n    def _visit_bilerp(self, node: Bilerp):\n        \"\"\"Lower 2D bilinear interpolation to JAX function.\n\n        Uses jax.scipy.ndimage.map_coordinates for bilinear interpolation on a\n        regular grid. For query points outside the grid, boundary values are\n        returned (clamping via mode='nearest').\n\n        Args:\n            node: Bilerp expression node with x, y, xp, yp, fp\n\n        Returns:\n            Function (x, u, node, params) -&gt; interpolated scalar value\n\n        Note:\n            The grid arrays (xp, yp, fp) are typically constants (tabulated data),\n            while x and y are symbolic expressions (state or derived values).\n            Physical coordinates are converted to fractional indices before\n            interpolation. The implementation is differentiable through JAX's autodiff.\n        \"\"\"\n        f_x = self.lower(node.x)\n        f_y = self.lower(node.y)\n        f_xp = self.lower(node.xp)\n        f_yp = self.lower(node.yp)\n        f_fp = self.lower(node.fp)\n\n        def bilerp_fn(x, u, node_idx, params):\n            x_val = f_x(x, u, node_idx, params)\n            y_val = f_y(x, u, node_idx, params)\n            xp_val = f_xp(x, u, node_idx, params)\n            yp_val = f_yp(x, u, node_idx, params)\n            fp_val = f_fp(x, u, node_idx, params)\n\n            # Convert physical coordinates to fractional indices\n            # jnp.interp maps physical coords to index space (handles non-uniform grids)\n            idx_x = jnp.interp(x_val, xp_val, jnp.arange(len(xp_val)))\n            idx_y = jnp.interp(y_val, yp_val, jnp.arange(len(yp_val)))\n\n            # Use map_coordinates with order=1 (bilinear) and mode='nearest' (clamp)\n            coords = jnp.array([[idx_x], [idx_y]])\n            return jax.scipy.ndimage.map_coordinates(fp_val, coords, order=1, mode=\"nearest\")[0]\n\n        return bilerp_fn\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.JaxLowerer.lower","title":"<code>lower(expr: Expr)</code>","text":"<p>Lower a symbolic expression to a JAX function.</p> <p>Main entry point for lowering. Delegates to dispatch() which looks up the appropriate visitor method based on the expression type.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Symbolic expression to lower (any Expr subclass)</p> required <p>Returns:</p> Type Description <p>JAX function with signature (x, u, node, params) -&gt; result</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If no visitor exists for the expression type</p> <code>ValueError</code> <p>If the expression is malformed (e.g., State without slice)</p> Example <p>Lower an expression to a JAX function:</p> <pre><code>lowerer = JaxLowerer()\nx = ox.State(\"x\", shape=(3,))\nexpr = ox.Norm(x)\nf = lowerer.lower(expr)\n# f is now callable\n</code></pre> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>def lower(self, expr: Expr):\n    \"\"\"Lower a symbolic expression to a JAX function.\n\n    Main entry point for lowering. Delegates to dispatch() which looks up\n    the appropriate visitor method based on the expression type.\n\n    Args:\n        expr: Symbolic expression to lower (any Expr subclass)\n\n    Returns:\n        JAX function with signature (x, u, node, params) -&gt; result\n\n    Raises:\n        NotImplementedError: If no visitor exists for the expression type\n        ValueError: If the expression is malformed (e.g., State without slice)\n\n    Example:\n        Lower an expression to a JAX function:\n\n            lowerer = JaxLowerer()\n            x = ox.State(\"x\", shape=(3,))\n            expr = ox.Norm(x)\n            f = lowerer.lower(expr)\n            # f is now callable\n    \"\"\"\n    return dispatch(self, expr)\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.dispatch","title":"<code>dispatch(lowerer: Any, expr: Expr)</code>","text":"<p>Dispatch an expression to its registered visitor function.</p> <p>Looks up the visitor function for the expression's type and calls it. This is the core of the visitor pattern implementation.</p> <p>Parameters:</p> Name Type Description Default <code>lowerer</code> <code>Any</code> <p>The JaxLowerer instance (provides context for visitor methods)</p> required <code>expr</code> <code>Expr</code> <p>The expression node to lower</p> required <p>Returns:</p> Type Description <p>The result of calling the visitor function (typically a JAX callable)</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If no visitor is registered for the expression type</p> Example <p>Dispatch an expression to lower it to a JAX function:</p> <pre><code>lowerer = JaxLowerer()\nexpr = Add(x, y)\nfn = dispatch(lowerer, expr)  # Calls visit_add\n</code></pre> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>def dispatch(lowerer: Any, expr: Expr):\n    \"\"\"Dispatch an expression to its registered visitor function.\n\n    Looks up the visitor function for the expression's type and calls it.\n    This is the core of the visitor pattern implementation.\n\n    Args:\n        lowerer: The JaxLowerer instance (provides context for visitor methods)\n        expr: The expression node to lower\n\n    Returns:\n        The result of calling the visitor function (typically a JAX callable)\n\n    Raises:\n        NotImplementedError: If no visitor is registered for the expression type\n\n    Example:\n        Dispatch an expression to lower it to a JAX function:\n\n            lowerer = JaxLowerer()\n            expr = Add(x, y)\n            fn = dispatch(lowerer, expr)  # Calls visit_add\n    \"\"\"\n    fn = _JAX_VISITORS.get(type(expr))\n    if fn is None:\n        raise NotImplementedError(\n            f\"{lowerer.__class__.__name__!r} has no visitor for {type(expr).__name__}\"\n        )\n    return fn(lowerer, expr)\n</code></pre>"},{"location":"reference/symbolic/lowerers/jax/#openscvx.symbolic.lowerers.jax.visitor","title":"<code>visitor(expr_cls: Type[Expr])</code>","text":"<p>Decorator to register a visitor function for an expression type.</p> <p>This decorator registers a visitor method to handle a specific expression type during JAX lowering. The decorated function is stored in _JAX_VISITORS and will be called by dispatch() when lowering that expression type.</p> <p>Parameters:</p> Name Type Description Default <code>expr_cls</code> <code>Type[Expr]</code> <p>The Expr subclass this visitor handles (e.g., Add, Mul, Norm)</p> required <p>Returns:</p> Type Description <p>Decorator function that registers the visitor and returns it unchanged</p> Example <p>Register a visitor function for the Add expression:</p> <pre><code>@visitor(Add)\ndef _visit_add(self, node: Add):\n    # Lower addition to JAX\n    ...\n</code></pre> Note <p>Multiple expression types can share a visitor by stacking decorators::</p> <pre><code>@visitor(Equality)\n@visitor(Inequality)\ndef _visit_constraint(self, node: Constraint):\n    # Handle both equality and inequality\n    ...\n</code></pre> Source code in <code>openscvx/symbolic/lowerers/jax.py</code> <pre><code>def visitor(expr_cls: Type[Expr]):\n    \"\"\"Decorator to register a visitor function for an expression type.\n\n    This decorator registers a visitor method to handle a specific expression\n    type during JAX lowering. The decorated function is stored in _JAX_VISITORS\n    and will be called by dispatch() when lowering that expression type.\n\n    Args:\n        expr_cls: The Expr subclass this visitor handles (e.g., Add, Mul, Norm)\n\n    Returns:\n        Decorator function that registers the visitor and returns it unchanged\n\n    Example:\n        Register a visitor function for the Add expression:\n\n            @visitor(Add)\n            def _visit_add(self, node: Add):\n                # Lower addition to JAX\n                ...\n\n    Note:\n        Multiple expression types can share a visitor by stacking decorators::\n\n            @visitor(Equality)\n            @visitor(Inequality)\n            def _visit_constraint(self, node: Constraint):\n                # Handle both equality and inequality\n                ...\n    \"\"\"\n\n    def register(fn: Callable[[Any, Expr], Callable]):\n        _JAX_VISITORS[expr_cls] = fn\n        return fn\n\n    return register\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":"<p>Utility functions for caching, printing, and output formatting.</p> <p>This module provides utilities for OpenSCvx.</p>"},{"location":"reference/utils/#openscvx.utils.calculate_cost_from_boundaries","title":"<code>calculate_cost_from_boundaries(x: np.ndarray, initial_type: np.ndarray, final_type: np.ndarray) -&gt; float</code>","text":"<p>Calculate cost from boundary condition objectives.</p> <p>This function computes the total cost contribution from state boundary conditions marked as \"Minimize\" or \"Maximize\" at initial and final times.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>State trajectory array of shape (N, n_states)</p> required <code>initial_type</code> <code>ndarray</code> <p>Array of boundary condition types for initial states</p> required <code>final_type</code> <code>ndarray</code> <p>Array of boundary condition types for final states</p> required <p>Returns:</p> Type Description <code>float</code> <p>Total cost from minimize/maximize boundary conditions</p> Example Source code in <code>openscvx/utils/utils.py</code> <pre><code>def calculate_cost_from_boundaries(\n    x: np.ndarray, initial_type: np.ndarray, final_type: np.ndarray\n) -&gt; float:\n    \"\"\"Calculate cost from boundary condition objectives.\n\n    This function computes the total cost contribution from state boundary conditions\n    marked as \"Minimize\" or \"Maximize\" at initial and final times.\n\n    Args:\n        x: State trajectory array of shape (N, n_states)\n        initial_type: Array of boundary condition types for initial states\n        final_type: Array of boundary condition types for final states\n\n    Returns:\n        Total cost from minimize/maximize boundary conditions\n\n    Example:\n        &gt;&gt;&gt; # State with final time to minimize\n        &gt;&gt;&gt; x = np.array([[0.0, 5.0], [10.0, 20.0]])  # 2 nodes, 2 states\n        &gt;&gt;&gt; initial_type = np.array([\"Fix\", \"Free\"])\n        &gt;&gt;&gt; final_type = np.array([\"Minimize\", \"Free\"])\n        &gt;&gt;&gt; cost = calculate_cost_from_boundaries(x, initial_type, final_type)\n        &gt;&gt;&gt; cost  # Returns x[-1, 0] = 10.0\n    \"\"\"\n    cost = 0.0\n\n    # Add costs from initial boundary conditions\n    for i, bc_type in enumerate(initial_type):\n        if bc_type == \"Minimize\":\n            cost += x[0, i]\n        elif bc_type == \"Maximize\":\n            cost -= x[0, i]\n\n    # Add costs from final boundary conditions\n    for i, bc_type in enumerate(final_type):\n        if bc_type == \"Minimize\":\n            cost += x[-1, i]\n        elif bc_type == \"Maximize\":\n            cost -= x[-1, i]\n\n    return cost\n</code></pre>"},{"location":"reference/utils/#openscvx.utils.calculate_cost_from_boundaries--state-with-final-time-to-minimize","title":"State with final time to minimize","text":"<p>x = np.array([[0.0, 5.0], [10.0, 20.0]])  # 2 nodes, 2 states initial_type = np.array([\"Fix\", \"Free\"]) final_type = np.array([\"Minimize\", \"Free\"]) cost = calculate_cost_from_boundaries(x, initial_type, final_type) cost  # Returns x[-1, 0] = 10.0</p>"},{"location":"reference/utils/#openscvx.utils.gen_vertices","title":"<code>gen_vertices(center, radii)</code>","text":"<p>Obtains the vertices of the gate.</p> Source code in <code>openscvx/utils/utils.py</code> <pre><code>def gen_vertices(center, radii):\n    \"\"\"\n    Obtains the vertices of the gate.\n    \"\"\"\n    vertices = []\n    vertices.append(center + rot @ [radii[0], 0, radii[2]])\n    vertices.append(center + rot @ [-radii[0], 0, radii[2]])\n    vertices.append(center + rot @ [-radii[0], 0, -radii[2]])\n    vertices.append(center + rot @ [radii[0], 0, -radii[2]])\n    return vertices\n</code></pre>"},{"location":"reference/utils/#openscvx.utils.generate_orthogonal_unit_vectors","title":"<code>generate_orthogonal_unit_vectors(vectors=None)</code>","text":"<p>Generates 3 orthogonal unit vectors to model the axis of the ellipsoid via QR decomposition</p> <p>vectors (np.ndarray): Optional, axes of the ellipsoid to be orthonormalized.                         If none specified generates randomly.</p> <p>Returns: np.ndarray: A 3x3 matrix where each column is a unit vector.</p> Source code in <code>openscvx/utils/utils.py</code> <pre><code>def generate_orthogonal_unit_vectors(vectors=None):\n    \"\"\"\n    Generates 3 orthogonal unit vectors to model the axis of the ellipsoid via QR decomposition\n\n    Parameters:\n    vectors (np.ndarray): Optional, axes of the ellipsoid to be orthonormalized.\n                            If none specified generates randomly.\n\n    Returns:\n    np.ndarray: A 3x3 matrix where each column is a unit vector.\n    \"\"\"\n    if vectors is None:\n        # Create a random key\n        key = jax.random.PRNGKey(0)\n\n        # Generate a 3x3 array of random numbers uniformly distributed between 0 and 1\n        vectors = jax.random.uniform(key, (3, 3))\n    Q, _ = jnp.linalg.qr(vectors)\n    return Q\n</code></pre>"},{"location":"reference/utils/cache/","title":"cache","text":"<p>Cache management for compiled solvers.</p> <p>This module provides utilities for managing the cache directory where compiled JAX solvers are stored. The cache location follows platform conventions:</p> <ul> <li>Linux: <code>~/.cache/openscvx/</code></li> <li>macOS: <code>~/Library/Caches/openscvx/</code></li> <li>Windows: <code>%LOCALAPPDATA%/openscvx/Cache/</code></li> </ul> <p>The cache location can be overridden by setting the <code>OPENSCVX_CACHE_DIR</code> environment variable.</p> Example <p>Get the cache directory::</p> <pre><code>import openscvx as ox\nprint(ox.get_cache_dir())  # /home/user/.cache/openscvx\n</code></pre> <p>Clear all cached solvers::</p> <pre><code>import openscvx as ox\nox.clear_cache()\n</code></pre> <p>Check cache size::</p> <pre><code>import openscvx as ox\nsize_mb = ox.get_cache_size() / (1024 * 1024)\nprint(f\"Cache size: {size_mb:.1f} MB\")\n</code></pre>"},{"location":"reference/utils/cache/#openscvx.utils.cache.clear_cache","title":"<code>clear_cache() -&gt; int</code>","text":"<p>Clear all cached compiled solvers.</p> <p>Removes all files in the cache directory. The directory itself is preserved but emptied.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of files deleted</p> Example <p>Clear the cache::</p> <pre><code>import openscvx as ox\ndeleted = ox.clear_cache()\nprint(f\"Deleted {deleted} cached files\")\n</code></pre> Source code in <code>openscvx/utils/cache.py</code> <pre><code>def clear_cache() -&gt; int:\n    \"\"\"Clear all cached compiled solvers.\n\n    Removes all files in the cache directory. The directory itself is\n    preserved but emptied.\n\n    Returns:\n        Number of files deleted\n\n    Example:\n        Clear the cache::\n\n            import openscvx as ox\n            deleted = ox.clear_cache()\n            print(f\"Deleted {deleted} cached files\")\n    \"\"\"\n    cache_dir = get_cache_dir()\n    if not cache_dir.exists():\n        return 0\n\n    count = 0\n    for item in cache_dir.iterdir():\n        if item.is_file():\n            item.unlink()\n            count += 1\n        elif item.is_dir():\n            shutil.rmtree(item)\n            count += 1\n\n    return count\n</code></pre>"},{"location":"reference/utils/cache/#openscvx.utils.cache.get_cache_dir","title":"<code>get_cache_dir() -&gt; Path</code>","text":"<p>Get the cache directory for compiled solvers.</p> <p>The cache location is determined in the following order: 1. <code>OPENSCVX_CACHE_DIR</code> environment variable (if set) 2. Platform-specific default:    - Linux: <code>~/.cache/openscvx/</code>    - macOS: <code>~/Library/Caches/openscvx/</code>    - Windows: <code>%LOCALAPPDATA%/openscvx/Cache/</code></p> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the cache directory (may not exist yet)</p> Source code in <code>openscvx/utils/cache.py</code> <pre><code>def get_cache_dir() -&gt; Path:\n    \"\"\"Get the cache directory for compiled solvers.\n\n    The cache location is determined in the following order:\n    1. ``OPENSCVX_CACHE_DIR`` environment variable (if set)\n    2. Platform-specific default:\n       - Linux: ``~/.cache/openscvx/``\n       - macOS: ``~/Library/Caches/openscvx/``\n       - Windows: ``%LOCALAPPDATA%/openscvx/Cache/``\n\n    Returns:\n        Path to the cache directory (may not exist yet)\n    \"\"\"\n    # Check environment variable override\n    env_dir = os.environ.get(\"OPENSCVX_CACHE_DIR\")\n    if env_dir:\n        return Path(env_dir)\n\n    # Platform-specific defaults\n    if sys.platform == \"darwin\":\n        # macOS: ~/Library/Caches/openscvx/\n        return Path.home() / \"Library\" / \"Caches\" / \"openscvx\"\n    elif sys.platform == \"win32\":\n        # Windows: %LOCALAPPDATA%/openscvx/Cache/\n        local_app_data = os.environ.get(\"LOCALAPPDATA\")\n        if local_app_data:\n            return Path(local_app_data) / \"openscvx\" / \"Cache\"\n        else:\n            # Fallback if LOCALAPPDATA not set\n            return Path.home() / \"AppData\" / \"Local\" / \"openscvx\" / \"Cache\"\n    else:\n        # Linux and others: follow XDG Base Directory Specification\n        xdg_cache = os.environ.get(\"XDG_CACHE_HOME\")\n        if xdg_cache:\n            return Path(xdg_cache) / \"openscvx\"\n        else:\n            return Path.home() / \".cache\" / \"openscvx\"\n</code></pre>"},{"location":"reference/utils/cache/#openscvx.utils.cache.get_cache_size","title":"<code>get_cache_size() -&gt; int</code>","text":"<p>Get the total size of the cache in bytes.</p> <p>Returns:</p> Type Description <code>int</code> <p>Total size of all files in the cache directory in bytes.</p> <code>int</code> <p>Returns 0 if the cache directory doesn't exist.</p> Example <p>Check cache size in megabytes::</p> <pre><code>import openscvx as ox\nsize_mb = ox.get_cache_size() / (1024 * 1024)\nprint(f\"Cache size: {size_mb:.1f} MB\")\n</code></pre> Source code in <code>openscvx/utils/cache.py</code> <pre><code>def get_cache_size() -&gt; int:\n    \"\"\"Get the total size of the cache in bytes.\n\n    Returns:\n        Total size of all files in the cache directory in bytes.\n        Returns 0 if the cache directory doesn't exist.\n\n    Example:\n        Check cache size in megabytes::\n\n            import openscvx as ox\n            size_mb = ox.get_cache_size() / (1024 * 1024)\n            print(f\"Cache size: {size_mb:.1f} MB\")\n    \"\"\"\n    cache_dir = get_cache_dir()\n    if not cache_dir.exists():\n        return 0\n\n    total = 0\n    for item in cache_dir.rglob(\"*\"):\n        if item.is_file():\n            total += item.stat().st_size\n\n    return total\n</code></pre>"},{"location":"reference/utils/caching/","title":"caching","text":""},{"location":"reference/utils/caching/#openscvx.utils.caching.get_solver_cache_paths","title":"<code>get_solver_cache_paths(symbolic_problem: SymbolicProblem, dt: float, total_time: float, cache_dir: Optional[Path] = None, byof: Optional[ByofSpec] = None) -&gt; Tuple[Path, Path]</code>","text":"<p>Generate cache file paths using symbolic AST hashing.</p> <p>This function computes a hash based on the symbolic structure of the problem, which is more stable than hashing lowered JAX code. Two problems with the same mathematical structure will produce the same hash, regardless of variable names.</p> <p>Parameters:</p> Name Type Description Default <code>symbolic_problem</code> <code>SymbolicProblem</code> <p>The preprocessed SymbolicProblem</p> required <code>dt</code> <code>float</code> <p>Time step for propagation</p> required <code>total_time</code> <code>float</code> <p>Total simulation time</p> required <code>cache_dir</code> <code>Optional[Path]</code> <p>Directory to store cached solvers. If None, uses the default cache directory (see :func:<code>openscvx.get_cache_dir</code>).</p> <code>None</code> <code>byof</code> <code>Optional[ByofSpec]</code> <p>Optional ByofSpec containing raw JAX functions. If provided, function bytecode is included in the hash.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Path, Path]</code> <p>Tuple of (discretization_solver_path, propagation_solver_path)</p> Source code in <code>openscvx/utils/caching.py</code> <pre><code>def get_solver_cache_paths(\n    symbolic_problem: \"SymbolicProblem\",\n    dt: float,\n    total_time: float,\n    cache_dir: Optional[Path] = None,\n    byof: Optional[\"ByofSpec\"] = None,\n) -&gt; Tuple[Path, Path]:\n    \"\"\"Generate cache file paths using symbolic AST hashing.\n\n    This function computes a hash based on the symbolic structure of the problem,\n    which is more stable than hashing lowered JAX code. Two problems with the same\n    mathematical structure will produce the same hash, regardless of variable names.\n\n    Args:\n        symbolic_problem: The preprocessed SymbolicProblem\n        dt: Time step for propagation\n        total_time: Total simulation time\n        cache_dir: Directory to store cached solvers. If None, uses the default\n            cache directory (see :func:`openscvx.get_cache_dir`).\n        byof: Optional ByofSpec containing raw JAX functions. If provided,\n            function bytecode is included in the hash.\n\n    Returns:\n        Tuple of (discretization_solver_path, propagation_solver_path)\n    \"\"\"\n    from openscvx.symbolic.hashing import hash_symbolic_problem\n\n    # Get the structural hash of the symbolic problem\n    problem_hash = hash_symbolic_problem(symbolic_problem)\n\n    # Include runtime config in the hash\n    final_hasher = hashlib.sha256()\n    final_hasher.update(problem_hash.encode())\n    final_hasher.update(f\"dt:{dt}\".encode())\n    final_hasher.update(f\"total_time:{total_time}\".encode())\n\n    # Include BYOF function bytecode in the hash\n    final_hasher.update(_hash_byof(byof))\n\n    final_hash = final_hasher.hexdigest()[:32]\n\n    solver_dir = cache_dir if cache_dir is not None else get_cache_dir()\n    solver_dir.mkdir(parents=True, exist_ok=True)\n\n    dis_solver_file = solver_dir / f\"compiled_discretization_solver_{final_hash}.jax\"\n    prop_solver_file = solver_dir / f\"compiled_propagation_solver_{final_hash}.jax\"\n\n    return dis_solver_file, prop_solver_file\n</code></pre>"},{"location":"reference/utils/caching/#openscvx.utils.caching.load_or_compile_discretization_solver","title":"<code>load_or_compile_discretization_solver(discretization_solver: callable, cache_file: Path, params: Dict[str, Any], n_discretization_nodes: int, n_states: int, n_controls: int, save_compiled: bool = False, debug: bool = False) -&gt; callable</code>","text":"<p>Load discretization solver from cache or compile and cache it.</p> <p>Parameters:</p> Name Type Description Default <code>discretization_solver</code> <code>callable</code> <p>The solver function to compile</p> required <code>cache_file</code> <code>Path</code> <p>Path to cache file</p> required <code>params</code> <code>Dict[str, Any]</code> <p>Parameters dictionary</p> required <code>n_discretization_nodes</code> <code>int</code> <p>Number of discretization nodes</p> required <code>n_states</code> <code>int</code> <p>Number of state variables</p> required <code>n_controls</code> <code>int</code> <p>Number of control variables</p> required <code>save_compiled</code> <code>bool</code> <p>Whether to save/load compiled solvers</p> <code>False</code> <code>debug</code> <code>bool</code> <p>Whether in debug mode (skip compilation)</p> <code>False</code> <p>Returns:</p> Type Description <code>callable</code> <p>Compiled discretization solver</p> Source code in <code>openscvx/utils/caching.py</code> <pre><code>def load_or_compile_discretization_solver(\n    discretization_solver: callable,\n    cache_file: Path,\n    params: Dict[str, Any],\n    n_discretization_nodes: int,\n    n_states: int,\n    n_controls: int,\n    save_compiled: bool = False,\n    debug: bool = False,\n) -&gt; callable:\n    \"\"\"Load discretization solver from cache or compile and cache it.\n\n    Args:\n        discretization_solver: The solver function to compile\n        cache_file: Path to cache file\n        params: Parameters dictionary\n        n_discretization_nodes: Number of discretization nodes\n        n_states: Number of state variables\n        n_controls: Number of control variables\n        save_compiled: Whether to save/load compiled solvers\n        debug: Whether in debug mode (skip compilation)\n\n    Returns:\n        Compiled discretization solver\n    \"\"\"\n    if debug:\n        return discretization_solver\n\n    if save_compiled:\n        try:\n            with open(cache_file, \"rb\") as f:\n                serial_dis = f.read()\n            compiled_solver = export.deserialize(serial_dis)\n            print(\"\u2713 Loaded existing discretization solver\")\n            return compiled_solver\n        except FileNotFoundError:\n            print(\"Compiling discretization solver...\")\n\n    else:\n        print(\"Compiling discretization solver (not saving/loading from disk)...\")\n\n    # Pass parameters as a single dictionary\n    compiled_solver = export.export(jax.jit(discretization_solver))(\n        np.ones((n_discretization_nodes, n_states)),\n        np.ones((n_discretization_nodes, n_controls)),\n        params,\n    )\n\n    if save_compiled:\n        with open(cache_file, \"wb\") as f:\n            f.write(compiled_solver.serialize())\n        print(\"\u2713 Discretization solver compiled and saved\")\n\n    return compiled_solver\n</code></pre>"},{"location":"reference/utils/caching/#openscvx.utils.caching.load_or_compile_propagation_solver","title":"<code>load_or_compile_propagation_solver(propagation_solver: callable, cache_file: Path, params: Dict[str, Any], n_states_prop: int, n_controls: int, max_tau_len: int, save_compiled: bool = False) -&gt; callable</code>","text":"<p>Load propagation solver from cache or compile and cache it.</p> <p>Parameters:</p> Name Type Description Default <code>propagation_solver</code> <code>callable</code> <p>The solver function to compile</p> required <code>cache_file</code> <code>Path</code> <p>Path to cache file</p> required <code>params</code> <code>Dict[str, Any]</code> <p>Parameters dictionary</p> required <code>n_states_prop</code> <code>int</code> <p>Number of propagation state variables</p> required <code>n_controls</code> <code>int</code> <p>Number of control variables</p> required <code>max_tau_len</code> <code>int</code> <p>Maximum tau length for propagation</p> required <code>save_compiled</code> <code>bool</code> <p>Whether to save/load compiled solvers</p> <code>False</code> <p>Returns:</p> Type Description <code>callable</code> <p>Compiled propagation solver</p> Source code in <code>openscvx/utils/caching.py</code> <pre><code>def load_or_compile_propagation_solver(\n    propagation_solver: callable,\n    cache_file: Path,\n    params: Dict[str, Any],\n    n_states_prop: int,\n    n_controls: int,\n    max_tau_len: int,\n    save_compiled: bool = False,\n) -&gt; callable:\n    \"\"\"Load propagation solver from cache or compile and cache it.\n\n    Args:\n        propagation_solver: The solver function to compile\n        cache_file: Path to cache file\n        params: Parameters dictionary\n        n_states_prop: Number of propagation state variables\n        n_controls: Number of control variables\n        max_tau_len: Maximum tau length for propagation\n        save_compiled: Whether to save/load compiled solvers\n\n    Returns:\n        Compiled propagation solver\n    \"\"\"\n    if save_compiled:\n        try:\n            with open(cache_file, \"rb\") as f:\n                serial_prop = f.read()\n            compiled_solver = export.deserialize(serial_prop)\n            print(\"\u2713 Loaded existing propagation solver\")\n            return compiled_solver\n        except FileNotFoundError:\n            print(\"Compiling propagation solver...\")\n\n    else:\n        print(\"Compiling propagation solver (not saving/loading from disk)...\")\n\n    # Pass parameters as a single dictionary\n    compiled_solver = export.export(jax.jit(propagation_solver))(\n        np.ones(n_states_prop),  # x_0\n        (0.0, 0.0),  # time span\n        np.ones((1, n_controls)),  # controls_current\n        np.ones((1, n_controls)),  # controls_next\n        np.ones((1, 1)),  # tau_0\n        np.ones((1, 1)).astype(\"int\"),  # segment index\n        0,  # idx_s_stop\n        np.ones((max_tau_len,)),  # save_time (tau_cur_padded)\n        np.ones((max_tau_len,), dtype=bool),  # mask_padded (boolean mask)\n        params,  # additional parameters as dict\n    )\n\n    if save_compiled:\n        with open(cache_file, \"wb\") as f:\n            f.write(compiled_solver.serialize())\n        print(\"\u2713 Propagation solver compiled and saved\")\n\n    return compiled_solver\n</code></pre>"},{"location":"reference/utils/caching/#openscvx.utils.caching.prime_propagation_solver","title":"<code>prime_propagation_solver(propagation_solver: callable, params: Dict[str, Any], settings) -&gt; None</code>","text":"<p>Prime the propagation solver with a test call to ensure it works.</p> <p>Parameters:</p> Name Type Description Default <code>propagation_solver</code> <code>callable</code> <p>Compiled propagation solver</p> required <code>params</code> <code>Dict[str, Any]</code> <p>Parameters dictionary</p> required <code>settings</code> <p>Settings configuration object</p> required Source code in <code>openscvx/utils/caching.py</code> <pre><code>def prime_propagation_solver(\n    propagation_solver: callable, params: Dict[str, Any], settings\n) -&gt; None:\n    \"\"\"Prime the propagation solver with a test call to ensure it works.\n\n    Args:\n        propagation_solver: Compiled propagation solver\n        params: Parameters dictionary\n        settings: Settings configuration object\n    \"\"\"\n    try:\n        x_0 = np.ones(settings.sim.x_prop.initial.shape, dtype=settings.sim.x_prop.initial.dtype)\n        tau_grid = (0.0, 1.0)\n        controls_current = np.ones((1, settings.sim.u.shape[0]), dtype=settings.sim.u.guess.dtype)\n        controls_next = np.ones((1, settings.sim.u.shape[0]), dtype=settings.sim.u.guess.dtype)\n        tau_init = np.array([[0.0]], dtype=np.float64)\n        node = np.array([[0]], dtype=np.int64)\n        idx_s_stop = settings.sim.time_dilation_slice.stop\n        save_time = np.ones((settings.prp.max_tau_len,), dtype=np.float64)\n        mask_padded = np.ones((settings.prp.max_tau_len,), dtype=bool)\n        # Create dummy params dict with same structure\n        dummy_params = {\n            name: np.ones_like(value) if hasattr(value, \"shape\") else float(value)\n            for name, value in params.items()\n        }\n        propagation_solver.call(\n            x_0,\n            tau_grid,\n            controls_current,\n            controls_next,\n            tau_init,\n            node,\n            idx_s_stop,\n            save_time,\n            mask_padded,\n            dummy_params,\n        )\n    except Exception as e:\n        print(f\"[Initialization] Priming propagation_solver.call failed: {e}\")\n</code></pre>"},{"location":"reference/utils/printing/","title":"printing","text":""},{"location":"reference/utils/printing/#openscvx.utils.printing.print_problem_summary","title":"<code>print_problem_summary(settings, lowered)</code>","text":"<p>Print the problem summary box.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <p>Configuration settings containing problem information</p> required <code>lowered</code> <p>LoweredProblem from lower_symbolic_problem()</p> required Source code in <code>openscvx/utils/printing.py</code> <pre><code>def print_problem_summary(settings, lowered):\n    \"\"\"\n    Print the problem summary box.\n\n    Args:\n        settings: Configuration settings containing problem information\n        lowered: LoweredProblem from lower_symbolic_problem()\n    \"\"\"\n    n_nodal_convex = len(lowered.cvxpy_constraints.constraints)\n    n_nodal_nonconvex = len(lowered.jax_constraints.nodal)\n    n_ctcs = len(lowered.jax_constraints.ctcs)\n    n_augmented = settings.sim.n_states - settings.sim.true_state_slice.stop\n\n    # Count CVXPy variables, parameters, and constraints\n    from openscvx.solvers import optimal_control_problem\n\n    try:\n        # Build OCP using LoweredProblem\n        prob = optimal_control_problem(settings, lowered)\n\n        # Get the actual problem size information like CVXPy verbose output\n        n_cvx_variables = sum(var.size for var in prob.variables())\n        n_cvx_parameters = sum(param.size for param in prob.parameters())\n        n_cvx_constraints = sum(constraint.size for constraint in prob.constraints)\n    except Exception:\n        # Fallback if problem construction fails\n        n_cvx_variables = 0\n        n_cvx_parameters = 0\n        n_cvx_constraints = 0\n\n    # Get JAX backend information\n    jax_backend = jax.devices()[0].platform.upper()\n    jax_version = jax.__version__\n\n    # Build weights string conditionally\n    if isinstance(settings.scp.lam_vc, np.ndarray):\n        lam_vc_str = f\"\u03bb_vc=matrix({settings.scp.lam_vc.shape})\"\n    else:\n        lam_vc_str = f\"\u03bb_vc={settings.scp.lam_vc:4.1f}\"\n    weights_parts = [\n        f\"\u03bb_cost={settings.scp.lam_cost:4.1f}\",\n        f\"\u03bb_tr={settings.scp.w_tr:4.1f}\",\n        lam_vc_str,\n    ]\n\n    # Add \u03bb_vb only if there are nodal nonconvex constraints\n    if n_nodal_nonconvex &gt; 0:\n        weights_parts.append(f\"\u03bb_vb={settings.scp.lam_vb:4.1f}\")\n\n    weights_str = \", \".join(weights_parts)\n\n    lines = [\n        \"Problem Summary\",\n        (\n            f\"Dimensions: {settings.sim.n_states} states ({n_augmented} aug),\"\n            f\" {settings.sim.n_controls} controls, {settings.scp.n} nodes\"\n        ),\n        f\"Constraints: {n_nodal_convex} conv, {n_nodal_nonconvex} nonconv, {n_ctcs} ctcs\",\n        (\n            f\"Subproblem: {n_cvx_variables} vars, {n_cvx_parameters} params,\"\n            f\" {n_cvx_constraints} constraints\"\n        ),\n        f\"Weights: {weights_str}\",\n        f\"CVX Solver: {settings.cvx.solver}, Discretization Solver: {settings.dis.solver}\",\n        f\"JAX Backend: {jax_backend} (v{jax_version})\",\n    ]\n\n    print_summary_box(lines, \"Problem Summary\")\n</code></pre>"},{"location":"reference/utils/printing/#openscvx.utils.printing.print_results_summary","title":"<code>print_results_summary(result: OptimizationResults, timing_post, timing_init, timing_solve)</code>","text":"<p>Print the results summary box.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>OptimizationResults</code> <p>Optimization results object</p> required <code>timing_post</code> <code>float</code> <p>Post-processing time</p> required <code>timing_init</code> <code>float</code> <p>Initialization time</p> required <code>timing_solve</code> <code>float</code> <p>Solve time</p> required Source code in <code>openscvx/utils/printing.py</code> <pre><code>def print_results_summary(result: OptimizationResults, timing_post, timing_init, timing_solve):\n    \"\"\"\n    Print the results summary box.\n\n    Args:\n        result (OptimizationResults): Optimization results object\n        timing_post (float): Post-processing time\n        timing_init (float): Initialization time\n        timing_solve (float): Solve time\n    \"\"\"\n    cost = result.get(\"cost\", 0.0)\n    ctcs_violation = result.get(\"ctcs_violation\", 0.0)\n\n    # Convert numpy arrays to scalars for formatting\n    if hasattr(cost, \"item\"):\n        cost = cost.item()\n\n    # Handle CTCS violation - display as 1D array\n    if hasattr(ctcs_violation, \"size\"):\n        if ctcs_violation.size == 1:\n            ctcs_violation_str = f\"[{ctcs_violation.item():.2e}]\"\n        else:\n            # Display as 1D array\n            ctcs_violation_str = f\"[{', '.join([f'{v:.2e}' for v in ctcs_violation])}]\"\n    else:\n        ctcs_violation_str = f\"[{ctcs_violation:.2e}]\"\n\n    # Calculate total computation time\n    total_time = (timing_init or 0.0) + (timing_solve or 0.0) + timing_post\n\n    lines = [\n        \"Results Summary\",\n        f\"Cost: {cost:.6f}\",\n        f\"CTCS Constraint Violation: {ctcs_violation_str}\",\n        f\"Preprocessing Time: {timing_init or 0.0:.3f}s\",\n        f\"Main Solve Time: {timing_solve or 0.0:.3f}s\",\n        f\"Post-processing Time: {timing_post:.3f}s\",\n        f\"Total Computation Time: {total_time:.3f}s\",\n    ]\n\n    print_summary_box(lines, \"Results Summary\")\n</code></pre>"},{"location":"reference/utils/printing/#openscvx.utils.printing.print_summary_box","title":"<code>print_summary_box(lines, title='Summary')</code>","text":"<p>Print a centered summary box with the given lines.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list</code> <p>List of strings to display in the box</p> required <code>title</code> <code>str</code> <p>Title for the box (default: \"Summary\")</p> <code>'Summary'</code> Source code in <code>openscvx/utils/printing.py</code> <pre><code>def print_summary_box(lines, title=\"Summary\"):\n    \"\"\"\n    Print a centered summary box with the given lines.\n\n    Args:\n        lines (list): List of strings to display in the box\n        title (str): Title for the box (default: \"Summary\")\n    \"\"\"\n    # Find the longest line (excluding the title which will be handled separately)\n    content_lines = lines[1:] if len(lines) &gt; 1 else []\n    max_content_width = max(len(line) for line in content_lines) if content_lines else 0\n    title_width = len(title)\n\n    # Box width should accommodate both title and content\n    box_width = max(max_content_width, title_width) + 4  # Add padding for the box borders\n\n    # Center with respect to the 89-character horizontal lines in io.py\n    total_width = 89\n    if box_width &lt;= total_width:\n        indent = (total_width - box_width) // 2\n    else:\n        # If box is wider than 89 chars, use a smaller fixed indentation\n        indent = 2\n\n    # Print the box with dynamic width and centering\n    print(f\"\\n{' ' * indent}\u256d{'\u2500' * box_width}\u256e\")\n    print(f\"{' ' * indent}\u2502 {title:^{box_width - 2}} \u2502\")\n    print(f\"{' ' * indent}\u251c{'\u2500' * box_width}\u2524\")\n    for line in content_lines:\n        print(f\"{' ' * indent}\u2502 {line:&lt;{box_width - 2}} \u2502\")\n    print(f\"{' ' * indent}\u2570{'\u2500' * box_width}\u256f\\n\")\n</code></pre>"},{"location":"reference/utils/profiling/","title":"profiling","text":""},{"location":"reference/utils/profiling/#openscvx.utils.profiling.profiling_end","title":"<code>profiling_end(pr: Optional[cProfile.Profile], identifier: str)</code>","text":"<p>Stop profiling and save results with timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>pr</code> <code>Optional[Profile]</code> <p>Profile object from profiling_start, or None.</p> required <code>identifier</code> <code>str</code> <p>Identifier for the profiling session (e.g., \"solve\", \"initialize\").</p> required Source code in <code>openscvx/utils/profiling.py</code> <pre><code>def profiling_end(pr: \"Optional[cProfile.Profile]\", identifier: str):\n    \"\"\"Stop profiling and save results with timestamp.\n\n    Args:\n        pr: Profile object from profiling_start, or None.\n        identifier: Identifier for the profiling session (e.g., \"solve\", \"initialize\").\n    \"\"\"\n    if pr is not None:\n        pr.disable()\n        # Save results so it can be visualized with snakeviz\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        pr.dump_stats(f\"profiling/{timestamp}_{identifier}.prof\")\n</code></pre>"},{"location":"reference/utils/profiling/#openscvx.utils.profiling.profiling_start","title":"<code>profiling_start(profiling_enabled: bool) -&gt; Optional[cProfile.Profile]</code>","text":"<p>Start profiling if enabled.</p> <p>Parameters:</p> Name Type Description Default <code>profiling_enabled</code> <code>bool</code> <p>Whether to enable profiling.</p> required <p>Returns:</p> Type Description <code>Optional[Profile]</code> <p>Profile object if enabled, None otherwise.</p> Source code in <code>openscvx/utils/profiling.py</code> <pre><code>def profiling_start(profiling_enabled: bool) -&gt; \"Optional[cProfile.Profile]\":\n    \"\"\"Start profiling if enabled.\n\n    Args:\n        profiling_enabled: Whether to enable profiling.\n\n    Returns:\n        Profile object if enabled, None otherwise.\n    \"\"\"\n    if profiling_enabled:\n        import cProfile\n\n        pr = cProfile.Profile()\n        pr.enable()\n        return pr\n    return None\n</code></pre>"},{"location":"reference/utils/utils/","title":"utils","text":""},{"location":"reference/utils/utils/#openscvx.utils.utils.calculate_cost_from_boundaries","title":"<code>calculate_cost_from_boundaries(x: np.ndarray, initial_type: np.ndarray, final_type: np.ndarray) -&gt; float</code>","text":"<p>Calculate cost from boundary condition objectives.</p> <p>This function computes the total cost contribution from state boundary conditions marked as \"Minimize\" or \"Maximize\" at initial and final times.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>State trajectory array of shape (N, n_states)</p> required <code>initial_type</code> <code>ndarray</code> <p>Array of boundary condition types for initial states</p> required <code>final_type</code> <code>ndarray</code> <p>Array of boundary condition types for final states</p> required <p>Returns:</p> Type Description <code>float</code> <p>Total cost from minimize/maximize boundary conditions</p> Example Source code in <code>openscvx/utils/utils.py</code> <pre><code>def calculate_cost_from_boundaries(\n    x: np.ndarray, initial_type: np.ndarray, final_type: np.ndarray\n) -&gt; float:\n    \"\"\"Calculate cost from boundary condition objectives.\n\n    This function computes the total cost contribution from state boundary conditions\n    marked as \"Minimize\" or \"Maximize\" at initial and final times.\n\n    Args:\n        x: State trajectory array of shape (N, n_states)\n        initial_type: Array of boundary condition types for initial states\n        final_type: Array of boundary condition types for final states\n\n    Returns:\n        Total cost from minimize/maximize boundary conditions\n\n    Example:\n        &gt;&gt;&gt; # State with final time to minimize\n        &gt;&gt;&gt; x = np.array([[0.0, 5.0], [10.0, 20.0]])  # 2 nodes, 2 states\n        &gt;&gt;&gt; initial_type = np.array([\"Fix\", \"Free\"])\n        &gt;&gt;&gt; final_type = np.array([\"Minimize\", \"Free\"])\n        &gt;&gt;&gt; cost = calculate_cost_from_boundaries(x, initial_type, final_type)\n        &gt;&gt;&gt; cost  # Returns x[-1, 0] = 10.0\n    \"\"\"\n    cost = 0.0\n\n    # Add costs from initial boundary conditions\n    for i, bc_type in enumerate(initial_type):\n        if bc_type == \"Minimize\":\n            cost += x[0, i]\n        elif bc_type == \"Maximize\":\n            cost -= x[0, i]\n\n    # Add costs from final boundary conditions\n    for i, bc_type in enumerate(final_type):\n        if bc_type == \"Minimize\":\n            cost += x[-1, i]\n        elif bc_type == \"Maximize\":\n            cost -= x[-1, i]\n\n    return cost\n</code></pre>"},{"location":"reference/utils/utils/#openscvx.utils.utils.calculate_cost_from_boundaries--state-with-final-time-to-minimize","title":"State with final time to minimize","text":"<p>x = np.array([[0.0, 5.0], [10.0, 20.0]])  # 2 nodes, 2 states initial_type = np.array([\"Fix\", \"Free\"]) final_type = np.array([\"Minimize\", \"Free\"]) cost = calculate_cost_from_boundaries(x, initial_type, final_type) cost  # Returns x[-1, 0] = 10.0</p>"},{"location":"reference/utils/utils/#openscvx.utils.utils.gen_vertices","title":"<code>gen_vertices(center, radii)</code>","text":"<p>Obtains the vertices of the gate.</p> Source code in <code>openscvx/utils/utils.py</code> <pre><code>def gen_vertices(center, radii):\n    \"\"\"\n    Obtains the vertices of the gate.\n    \"\"\"\n    vertices = []\n    vertices.append(center + rot @ [radii[0], 0, radii[2]])\n    vertices.append(center + rot @ [-radii[0], 0, radii[2]])\n    vertices.append(center + rot @ [-radii[0], 0, -radii[2]])\n    vertices.append(center + rot @ [radii[0], 0, -radii[2]])\n    return vertices\n</code></pre>"},{"location":"reference/utils/utils/#openscvx.utils.utils.generate_orthogonal_unit_vectors","title":"<code>generate_orthogonal_unit_vectors(vectors=None)</code>","text":"<p>Generates 3 orthogonal unit vectors to model the axis of the ellipsoid via QR decomposition</p> <p>vectors (np.ndarray): Optional, axes of the ellipsoid to be orthonormalized.                         If none specified generates randomly.</p> <p>Returns: np.ndarray: A 3x3 matrix where each column is a unit vector.</p> Source code in <code>openscvx/utils/utils.py</code> <pre><code>def generate_orthogonal_unit_vectors(vectors=None):\n    \"\"\"\n    Generates 3 orthogonal unit vectors to model the axis of the ellipsoid via QR decomposition\n\n    Parameters:\n    vectors (np.ndarray): Optional, axes of the ellipsoid to be orthonormalized.\n                            If none specified generates randomly.\n\n    Returns:\n    np.ndarray: A 3x3 matrix where each column is a unit vector.\n    \"\"\"\n    if vectors is None:\n        # Create a random key\n        key = jax.random.PRNGKey(0)\n\n        # Generate a 3x3 array of random numbers uniformly distributed between 0 and 1\n        vectors = jax.random.uniform(key, (3, 3))\n    Q, _ = jnp.linalg.qr(vectors)\n    return Q\n</code></pre>"}]}