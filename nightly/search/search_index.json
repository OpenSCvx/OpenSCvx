{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"OpenSCvx","text":"<p>Welcome to OpenSCvx.</p>"},{"location":"citation/","title":"Citation","text":"<p>If you use OpenSCvx in your research, please cite the following works:</p>"},{"location":"citation/#primary-citation","title":"Primary Citation","text":"<pre><code>@ARTICLE{hayner2025los,\n        author={Hayner, Christopher R. and Carson III, John M. and A\u00e7\u0131kme\u015fe, Beh\u00e7et and Leung, Karen},\n        journal={IEEE Robotics and Automation Letters}, \n        title={Continuous-Time Line-of-Sight Constrained Trajectory Planning for 6-Degree of Freedom Systems}, \n        year={2025},\n        volume={},\n        number={},\n        pages={1-8},\n        keywords={Robot sensing systems;Vectors;Vehicle dynamics;Line-of-sight propagation;Trajectory planning;Trajectory optimization;Quadrotors;Nonlinear dynamical systems;Heuristic algorithms;Convergence;Constrained Motion Planning;Optimization and Optimal Control;Aerial Systems: Perception and Autonomy},\n        doi={10.1109/LRA.2025.3545299}}\n</code></pre>"},{"location":"citation/#methodological-foundation","title":"Methodological Foundation","text":"<pre><code>@misc{elango2024ctscvx,\n      title={Successive Convexification for Trajectory Optimization with Continuous-Time Constraint Satisfaction}, \n      author={Purnanand Elango and Dayou Luo and Abhinav G. Kamath and Samet Uzun and Taewan Kim and Beh\u00e7et A\u00e7\u0131kme\u015fe},\n      year={2024},\n      eprint={2404.16826},\n      archivePrefix={arXiv},\n      primaryClass={math.OC},\n      url={https://arxiv.org/abs/2404.16826}, \n}\n</code></pre>"},{"location":"citation/#solver-technology","title":"Solver Technology","text":"<pre><code>@misc{chari2025qoco,\n  title = {QOCO: A Quadratic Objective Conic Optimizer with Custom Solver Generation},\n  author = {Chari, Govind M and A{\\c{c}}{\\i}kme{\\c{s}}e, Beh{\\c{c}}et},\n  year = {2025},\n  eprint = {2503.12658},\n  archiveprefix = {arXiv},\n  primaryclass = {math.OC},\n}\n</code></pre>"},{"location":"citation/#acknowledgments","title":"Acknowledgments","text":"<p>This work was supported by a NASA Space Technology Graduate Research Opportunity and the Office of Naval Research under grant N00014-17-1-2433. The authors would like to acknowledge Natalia Pavlasek, Samuel Buckner, Abhi Kamath, Govind Chari, and Purnanand Elango as well as the other Autonomous Controls Laboratory members, for their many helpful discussions and support throughout this work. </p>"},{"location":"examples/","title":"Examples","text":"<p>OpenSCvx comes with a comprehensive set of examples demonstrating various trajectory optimization problems. These examples are located in the <code>examples/</code> folder and cover different applications and complexity levels.</p>"},{"location":"examples/#running-examples","title":"Running Examples","text":"<p>See <code>examples/params/</code> folder for several example trajectory optimization problems. To run a problem simply run any of the examples directly, for example:</p> <pre><code>python3 examples/params/brachistochrone.py\n</code></pre> <p>and adjust the plotting as needed.</p>"},{"location":"examples/#example-categories","title":"Example Categories","text":""},{"location":"examples/#abstract-problems","title":"Abstract Problems","text":"<ul> <li>Brachistochrone: Classic minimum-time problem with gravity</li> <li>3DoF Rocket Landing: Rocket landing with fuel optimization</li> </ul>"},{"location":"examples/#drone-applications","title":"Drone Applications","text":"<ul> <li>Obstacle Avoidance: 6DoF drone navigating around obstacles</li> <li>Line-of-Sight Guidance: Drone maintaining line-of-sight to keypoints while passing through gates</li> <li>Cinema View Planning: Camera drone planning for cinematic shots</li> <li>Drone Racing: High-speed racing through gates</li> </ul>"},{"location":"examples/#ground-vehicle-applications","title":"Ground Vehicle Applications","text":"<ul> <li>Dubins Car: Simple 2D vehicle with turning constraints</li> <li>Dubins Car with Waypoints: Navigation through multiple waypoints</li> </ul>"},{"location":"examples/#real-time-applications","title":"Real-time Applications","text":"<ul> <li>Real-time Drone Racing: Live optimization during flight</li> <li>Real-time Obstacle Avoidance: Dynamic obstacle avoidance</li> </ul>"},{"location":"examples/#creating-your-own-problems","title":"Creating Your Own Problems","text":"<p>Check out the problem definitions inside <code>examples/params</code> to see how to define your own problems. Each example demonstrates:</p> <ul> <li>State and control variable definition</li> <li>Dynamics specification</li> <li>Constraint formulation</li> <li>Problem instantiation and solving</li> <li>Results visualization</li> </ul>"},{"location":"examples/#example-structure","title":"Example Structure","text":"<p>Most examples follow this structure:</p> <ol> <li>Imports: Import necessary OpenSCvx modules</li> <li>Problem Setup: Define parameters, state, and control variables</li> <li>Dynamics: Specify the system dynamics</li> <li>Constraints: Define path and boundary constraints</li> <li>Problem Instantiation: Create and configure the TrajOptProblem</li> <li>Solving: Run the optimization</li> <li>Visualization: Plot and analyze results</li> </ol>"},{"location":"examples/#interactive-examples","title":"Interactive Examples","text":"<p>For interactive 3D visualization, many examples include GUI plotting functions:</p> <pre><code>from examples.plotting import plot_animation_pyqtgraph\n\n# After solving the problem\nplot_animation_pyqtgraph(results).show()\n</code></pre>"},{"location":"examples/#performance-tips","title":"Performance Tips","text":"<ul> <li>Start with simpler examples to understand the workflow</li> <li>Use the provided initial guesses as starting points</li> <li>Adjust SCP weights based on your specific problem</li> <li>Consider using CVXPYGen for faster performance on smaller problems </li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>OpenSCvx is a JAX-based Python library for trajectory optimization using Successive Convexification (SCvx). It provides a simple interface for formulating and solving trajectory optimization problems with continuous-time constraint satisfaction.</p> <p>Important</p> <p>The library is currently in beta testing. Please report any issues on the GitHub repository.</p>"},{"location":"getting-started/#key-features","title":"Key Features","text":"<ul> <li>JAX-based: Automatic differentiation, vectorization, and compilation</li> <li>Continuous-time constraints: Support for path constraints that must be satisfied at all times</li> <li>Successive Convexification: Robust optimization algorithm for non-convex problems</li> <li>Multiple constraint types: Continuous-time, nodal, and boundary constraints</li> <li>Interactive visualization: 3D plotting and real-time optimization visualization</li> <li>Code generation: Automatic C++ code generation for optimization problems</li> <li>Faster solver performance through compiled code for smaller problems</li> <li>Support for customized solver backends like QOCOGen</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>You can install OpenSCvx using pip. For the most common use case, which includes support for interactive plotting and code generation, you can install the library with the <code>gui</code> and <code>cvxpygen</code> extras:</p> <pre><code>pip install openscvx[gui,cvxpygen]\n</code></pre> <p>If you only need the core library without the optional features, you can run:</p> <pre><code>pip install openscvx\n</code></pre> <p>For the latest development version, you can clone the repository and install it in editable mode:</p> <pre><code># Clone the repo\ngit clone https://github.com/haynec/OpenSCvx.git\ncd OpenSCvx\n\n# Install in editable mode with all optional dependencies\npip install -e \".[gui,cvxpygen]\"\n</code></pre>"},{"location":"getting-started/#dependencies","title":"Dependencies","text":"<p>OpenSCvx has a few optional dependency groups:</p> <p>The core dependencies are installed automatically with <code>openscvx</code>:</p> <ul> <li><code>cvxpy</code> - for convex optimization</li> <li><code>jax</code> - for fast linear algebra, automatic differentiation, and vectorization</li> <li><code>numpy</code> - for numerical operations</li> <li><code>diffrax</code> - for automatic differentiation</li> <li><code>termcolor</code> - for colored terminal output</li> <li> <p><code>plotly</code> - for basic interactive 3D plotting</p> </li> <li> <p><code>gui</code>: For interactive 3D plotting and real-time visualization. This includes:</p> <ul> <li><code>pyqtgraph</code> - for realtime 3D plotting</li> <li><code>PyQt5</code> - for GUI</li> <li><code>scipy</code> - for spatial operations</li> <li><code>PyOpenGL</code> - for 3D plotting</li> <li><code>PyOpenGL_accelerate</code> (optional, for speed) - for 3D plotting</li> </ul> </li> <li> <p><code>cvxpygen</code>: For C++ code generation, enabling faster solver performance on smaller problems. This includes:</p> <ul> <li><code>cvxpygen</code> - for C++ code generation</li> <li><code>qocogen</code> - fast SOCP solver</li> </ul> </li> </ul>"},{"location":"getting-started/#local-development","title":"Local Development","text":"<p>For setting up a local development environment, we recommend using Conda to manage environments.</p> Via Conda  1.  Clone the repository:     <pre><code>git clone https://github.com/haynec/OpenSCvx.git\ncd OpenSCvx\n</code></pre> 2.  Create and activate the conda environment from the provided file:     <pre><code>conda env create -f environment.yml\nconda activate openscvx\n</code></pre> 3.  Install the package in editable mode with all optional dependencies:     <pre><code>pip install -e \".[gui,cvxpygen]\"\n</code></pre> Via pip and venv  1.  Clone the repository:     <pre><code>git clone https://github.com/haynec/OpenSCvx.git\ncd OpenSCvx\n</code></pre> 2.  Create and activate a virtual environment:     <pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre> 3.  Install the package in editable mode with all optional dependencies:     <pre><code>pip install -e \".[gui,cvxpygen]\"\n</code></pre>"},{"location":"getting-started/#quick-example","title":"Quick Example","text":"<p>Here's a simple example to get you started with OpenSCvx. This demonstrates a minimum-time problem where a vehicle moves from the origin to a target position:</p> <pre><code>import numpy as np\nimport openscvx as ox\nfrom openscvx import TrajOptProblem\n\n# Define state variables\nposition = ox.State(\"position\", shape=(2,))  # 2D position [x, y]\nposition.min = np.array([-10.0, -10.0])\nposition.max = np.array([10.0, 10.0])\nposition.initial = np.array([0.0, 0.0])\nposition.final = np.array([5.0, 5.0])\n\n# Define control variables\nvelocity = ox.Control(\"velocity\", shape=(2,))  # Velocity [vx, vy]\nvelocity.min = np.array([-2.0, -2.0])\nvelocity.max = np.array([2.0, 2.0])\n\n# Set initial guesses\nposition.guess = np.linspace(position.initial, position.final, 20)\nvelocity.guess = np.repeat(\n    np.expand_dims(np.array([1.0, 1.0]), axis=0), 20, axis=0\n)\n\n# Collect states and controls\nstates = [position]\ncontrols = [velocity]\n\n# Define dynamics using symbolic expressions\ndynamics = {\n    \"position\": velocity,  # position derivative is velocity\n}\n\n# Define time (minimize final time)\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", 5.0),  # Minimize final time with initial guess of 5.0\n    min=0.0,\n    max=10.0,\n)\n\n# Create the problem\nproblem = TrajOptProblem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=[],\n    N=20,\n)\n\n# Solve the problem\nproblem.initialize()\nresult = problem.solve()\nresult = problem.post_process(result)\n\n# Access results\nprint(f\"Converged: {result.converged}\")\nprint(f\"Optimal time: {result.t_final:.3f}\")\nprint(f\"Final position: {result.trajectory['position'][-1]}\")\nprint(f\"Total cost: {result.cost:.3f}\")\n</code></pre> <p>Note</p> <p>This is a basic example. For more complex problems, see the Examples section.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Examples: Explore the comprehensive set of example problems</li> <li>Basic Problem Setup: Learn how to set up your first optimization problem</li> <li>Advanced Problem Setup: Learn how to set up a more complex optimization problem</li> <li>API Reference: Detailed documentation of all classes and functions</li> <li>Citation: Information for citing OpenSCvx in your research</li> </ul>"},{"location":"Overview/constraint_reformulation/","title":"Isoperimetric Constraint Reformulation","text":"<p>Warning</p> <p>This page is still under development .</p> <p> </p>"},{"location":"Overview/control_parameterization/","title":"Control Parameterization","text":"<p>Warning</p> <p>This page is still under development .</p>"},{"location":"Overview/discretization/","title":"Exact Discretization","text":"<p>Warning</p> <p>This page is still under development .</p> dVdt.py<pre><code>def dVdt(self,\n             tau: float,\n             V: jnp.ndarray,\n             u_cur: np.ndarray,\n             u_next: np.ndarray\n             ) -&gt; jnp.ndarray:\n        \"\"\"\n        Computes the time derivative of the augmented state vector for the system for a sequence of states.\n\n        Parameters:\n        tau (float): Current time.\n        V (np.ndarray): Sequence of augmented state vectors.\n        u_cur (np.ndarray): Sequence of current control inputs.\n        u_next (np.ndarray): Sequence of next control inputs.\n        A: Function that computes the Jacobian of the system dynamics with respect to the state.\n        B: Function that computes the Jacobian of the system dynamics with respect to the control input.\n        obstacles: List of obstacles in the environment.\n        params (dict): Parameters of the system.\n\n        Returns:\n        np.ndarray: Time derivatives of the augmented state vectors.\n        \"\"\"\n\n        # Extract the number of states and controls from the parameters\n        n_x = self.params.sim.n_states\n        n_u = self.params.sim.n_controls\n\n        # Unflatten V\n        V = V.reshape(-1, self.i5)\n\n        # Compute the interpolation factor based on the discretization type\n        if self.params.dis.dis_type == 'ZOH':\n            beta = 0.\n        elif self.params.dis.dis_type == 'FOH':\n            beta = (tau) * self.params.scp.n\n        alpha = 1 - beta\n\n        # Interpolate the control input\n        u = u_cur + beta * (u_next - u_cur)\n        s = u[:,-1]\n\n        # Initialize the augmented Jacobians\n        dfdx = jnp.zeros((V.shape[0], n_x, n_x))\n        dfdu = jnp.zeros((V.shape[0], n_x, n_u))\n\n        # Ensure x_seq and u have the same batch size\n        x = V[:,:self.params.sim.n_states]\n        u = u[:x.shape[0]]\n\n        # Compute the nonlinear propagation term\n        f = self.params.dyn.state_dot(x, u[:,:-1])\n        F = s[:, None] * f\n\n        # Evaluate the State Jacobian\n        dfdx = self.params.dyn.A(x, u[:,:-1])\n        sdfdx = s[:, None, None] * dfdx\n\n        # Evaluate the Control Jacobian\n        dfdu_veh = self.params.dyn.B(x, u[:,:-1])\n        dfdu = dfdu.at[:, :, :-1].set(s[:, None, None] * dfdu_veh)\n        dfdu = dfdu.at[:, :, -1].set(f)\n\n        # Compute the defect\n        z = F - jnp.einsum('ijk,ik-&gt;ij', sdfdx, x) - jnp.einsum('ijk,ik-&gt;ij', dfdu, u)\n\n        # Stack up the results into the augmented state vector\n        dVdt = jnp.zeros_like(V)\n        dVdt = dVdt.at[:, self.i0:self.i1].set(F)\n        dVdt = dVdt.at[:, self.i1:self.i2].set(jnp.matmul(sdfdx, V[:, self.i1:self.i2].reshape(-1, n_x, n_x)).reshape(-1, n_x * n_x))\n        dVdt = dVdt.at[:, self.i2:self.i3].set((jnp.matmul(sdfdx, V[:, self.i2:self.i3].reshape(-1, n_x, n_u)) + dfdu * alpha).reshape(-1, n_x * n_u))\n        dVdt = dVdt.at[:, self.i3:self.i4].set((jnp.matmul(sdfdx, V[:, self.i3:self.i4].reshape(-1, n_x, n_u)) + dfdu * beta).reshape(-1, n_x * n_u))\n        dVdt = dVdt.at[:, self.i4:self.i5].set((jnp.matmul(sdfdx, V[:, self.i4:self.i5].reshape(-1, n_x)[..., None]).squeeze(-1) + z).reshape(-1, n_x))\n        return dVdt.flatten()\n</code></pre>"},{"location":"Overview/ocp/","title":"Optimal Control Problem","text":"<p>Warning</p> <p>This page is still under development .</p> <p>The underlying convex subproblem is posed in the following general form. </p> <p><pre><code>def OptimalControlProblem(params: Config):\n</code></pre> The problem is defined as a function that takes in a <code>Config</code> object, which contains all the necessary parameters for the problem. The function returns a <code>cvxpy.Problem</code> object that can be solved using various solvers.</p>"},{"location":"Overview/ocp/#variable-and-parameter-definition","title":"Variable and Parameter Definition","text":"<p>The state, constrol and additional parameters are defined as follows:</p> <pre><code>w_tr = cp.Parameter(nonneg = True, name='w_tr')       # Weight on the Trust Region\nlam_cost = cp.Parameter(nonneg=True, name='lam_cost') # Weight on the Nonlinear Cost\n\nx = cp.Variable((params.scp.n, params.sim.n_states), name='x')   # State\ndx = cp.Variable((params.scp.n, params.sim.n_states), name='dx') # State Trust Region\nx_bar = cp.Parameter((params.scp.n, params.sim.n_states), name='x_bar') # Previous SCP State\n\n\nu = cp.Variable((params.scp.n, params.sim.n_controls), name='u')   # Control\ndu = cp.Variable((params.scp.n, params.sim.n_controls), name='du') # Control Trust Region\nu_bar = cp.Parameter((params.scp.n, params.sim.n_controls), name='u_bar') # Previous SCP Control\n</code></pre>"},{"location":"Overview/ocp/#scaling-definitions","title":"Scaling Definitions","text":"<p>The state and control are scaled using the following affine transformations:</p> \\[ \\begin{align*} \\tilde{x} &amp;= S_x x + c_x, \\\\ \\tilde{u} &amp;= S_u u + c_u, \\end{align*} \\] <p>where \\(\\tilde{x}\\) and \\(\\tilde{u}\\) are the unscaled state and control. The diagonal scalaing matrices, \\(S_x\\) and \\(S_u\\), are given by:</p> \\[ \\begin{align*} S_\\Box &amp;= \\mathrm{diag}\\left(\\mathrm{max}\\left(1, \\frac{\\mathrm{abs}(\\Box_\\min - \\Box_\\max)}{2}\\right)\\right) \\\\ c_\\Box &amp;= \\frac{\\Box_\\max + \\Box_\\min}{2} \\end{align*} \\] <p>These are instantiated in the optimal control problem as follows:</p> <pre><code># Affine Scaling for State\nS_x = params.sim.S_x\ninv_S_x = params.sim.inv_S_x\nc_x = params.sim.c_x\n</code></pre>"},{"location":"Overview/ocp/#discretized-dynamic-parameters","title":"Discretized Dynamic Parameters","text":"<p>The discretized dynamics matrices are defined as follows:</p> <pre><code># Discretized Augmented Dynamics Constraints\nA_d = cp.Parameter((params.scp.n - 1, (params.sim.n_states)*(params.sim.n_states)), name='A_d')\nB_d = cp.Parameter((params.scp.n - 1, params.sim.n_states*params.sim.n_controls), name='B_d')\nC_d = cp.Parameter((params.scp.n - 1, params.sim.n_states*params.sim.n_controls), name='C_d')\nz_d = cp.Parameter((params.scp.n - 1, params.sim.n_states), name='z_d') # Nonlinear Propagation Defect\nnu  = cp.Variable((params.scp.n - 1, params.sim.n_states), name='nu')  # Virtual Control Slack Variable\n</code></pre>"},{"location":"Overview/ocp/#nodal-constraints","title":"Nodal Constraints","text":"<p>The nonconvex nodal parameters and variables are instantiated using the following code:</p> <pre><code># Linearized Nonconvex Nodal Constraints\n    if params.sim.constraints_nodal:\n        g = []\n        grad_g_x = []\n        grad_g_u = []\n        nu_vb = []\n        for idx_ncvx, constraint in enumerate(params.sim.constraints_nodal):\n            if not constraint.convex:\n                g.append(cp.Parameter(params.scp.n, name = 'g_' + str(idx_ncvx)))\n                grad_g_x.append(cp.Parameter((params.scp.n, params.sim.n_states), name='grad_g_x_' + str(idx_ncvx)))\n                grad_g_u.append(cp.Parameter((params.scp.n, params.sim.n_controls), name='grad_g_u_' + str(idx_ncvx)))\n                nu_vb.append(cp.Variable(params.scp.n, name='nu_vb_' + str(idx_ncvx))) # Virtual Control for VB\n</code></pre> <pre><code>def OptimalControlProblem(params: Config):\n    ########################\n    # VARIABLES &amp; PARAMETERS\n    ########################\n\n    # Parameters\n    w_tr = cp.Parameter(nonneg = True, name='w_tr')\n    lam_cost = cp.Parameter(nonneg=True, name='lam_cost')\n\n    # State\n    x = cp.Variable((params.scp.n, params.sim.n_states), name='x') \n    dx = cp.Variable((params.scp.n, params.sim.n_states), name='dx') # State Trust Region\n    x_bar = cp.Parameter((params.scp.n, params.sim.n_states), name='x_bar') # Previous SCP State\n\n    # Affine Scaling for State\n    S_x = params.sim.S_x\n    inv_S_x = params.sim.inv_S_x\n    c_x = params.sim.c_x\n\n    # Control\n    u = cp.Variable((params.scp.n, params.sim.n_controls), name='u') \n    du = cp.Variable((params.scp.n, params.sim.n_controls), name='du') # Control Trust Region\n    u_bar = cp.Parameter((params.scp.n, params.sim.n_controls), name='u_bar') # Previous SCP Control\n\n    # Affine Scaling for Control\n    S_u = params.sim.S_u\n    inv_S_u = params.sim.inv_S_u\n    c_u = params.sim.c_u\n\n    # Discretized Augmented Dynamics Constraints\n    A_d = cp.Parameter((params.scp.n - 1, (params.sim.n_states)*(params.sim.n_states)), name='A_d')\n    B_d = cp.Parameter((params.scp.n - 1, params.sim.n_states*params.sim.n_controls), name='B_d')\n    C_d = cp.Parameter((params.scp.n - 1, params.sim.n_states*params.sim.n_controls), name='C_d')\n    z_d = cp.Parameter((params.scp.n - 1, params.sim.n_states), name='z_d')\n    nu  = cp.Variable((params.scp.n - 1, params.sim.n_states), name='nu') # Virtual Control\n\n    # Linearized Nonconvex Nodal Constraints\n    if params.sim.constraints_nodal:\n        g = []\n        grad_g_x = []\n        grad_g_u = []\n        nu_vb = []\n        for idx_ncvx, constraint in enumerate(params.sim.constraints_nodal):\n            if not constraint.convex:\n                g.append(cp.Parameter(params.scp.n, name = 'g_' + str(idx_ncvx)))\n                grad_g_x.append(cp.Parameter((params.scp.n, params.sim.n_states), name='grad_g_x_' + str(idx_ncvx)))\n                grad_g_u.append(cp.Parameter((params.scp.n, params.sim.n_controls), name='grad_g_u_' + str(idx_ncvx)))\n                nu_vb.append(cp.Variable(params.scp.n, name='nu_vb_' + str(idx_ncvx))) # Virtual Control for VB\n\n    # Applying the affine scaling to state and control\n    x_nonscaled = []\n    u_nonscaled = []\n    for k in range(params.scp.n):\n        x_nonscaled.append(S_x @ x[k] + c_x)\n        u_nonscaled.append(S_u @ u[k] + c_u)\n\n    constr = []\n    cost = lam_cost * 0\n\n    #############\n    # CONSTRAINTS\n    #############\n    idx_ncvx = 0\n    if params.sim.constraints_nodal:\n        for constraint in params.sim.constraints_nodal:\n            if constraint.nodes is None:\n                nodes = range(params.scp.n)\n            else:\n                nodes = constraint.nodes\n\n            if constraint.convex:\n                constr += [constraint(x_nonscaled[node], u_nonscaled[node]) for node in nodes]\n\n            elif not constraint.convex:\n                constr += [((g[idx_ncvx][node] + grad_g_x[idx_ncvx][node] @ dx[node] + grad_g_u[idx_ncvx][node] @ du[node])) == nu_vb[idx_ncvx][node] for node in nodes]\n                idx_ncvx += 1\n\n    for i in range(params.sim.idx_x_true.start, params.sim.idx_x_true.stop):\n        if params.sim.initial_state.type[i] == 'Fix':\n            constr += [x_nonscaled[0][i] == params.sim.initial_state.value[i]]  # Initial Boundary Conditions\n        if params.sim.final_state.type[i] == 'Fix':\n            constr += [x_nonscaled[-1][i] == params.sim.final_state.value[i]]   # Final Boundary Conditions\n        if params.sim.initial_state.type[i] == 'Minimize':\n            cost += lam_cost * x_nonscaled[0][i]\n        if params.sim.final_state.type[i] == 'Minimize':\n            cost += lam_cost * x_nonscaled[-1][i]\n        if params.sim.initial_state.type[i] == 'Maximize':\n            cost += lam_cost * x_nonscaled[0][i]\n        if params.sim.final_state.type[i] == 'Maximize':\n            cost += lam_cost * x_nonscaled[-1][i]\n\n    if params.scp.uniform_time_grid:\n        constr += [x_nonscaled[i][params.sim.idx_t] - x_nonscaled[i-1][params.sim.idx_t] == x_nonscaled[i-1][params.sim.idx_t] - x_nonscaled[i-2][params.sim.idx_t] for i in range(2, params.scp.n)] # Uniform Time Step\n\n    constr += [0 == la.inv(S_x) @ (x_nonscaled[i] - x_bar[i] - dx[i]) for i in range(params.scp.n)] # State Error\n    constr += [0 == la.inv(S_u) @ (u_nonscaled[i] - u_bar[i] - du[i]) for i in range(params.scp.n)] # Control Error\n\n    constr += [x_nonscaled[i] == \\\n                      cp.reshape(A_d[i-1], (params.sim.n_states, params.sim.n_states)) @ x_nonscaled[i-1] \\\n                    + cp.reshape(B_d[i-1], (params.sim.n_states, params.sim.n_controls)) @ u_nonscaled[i-1] \\\n                    + cp.reshape(C_d[i-1], (params.sim.n_states, params.sim.n_controls)) @ u_nonscaled[i] \\\n                    + z_d[i-1] \\\n                    + nu[i-1] for i in range(1, params.scp.n)] # Dynamics Constraint\n\n    constr += [u_nonscaled[i] &lt;= params.sim.max_control for i in range(params.scp.n)]\n    constr += [u_nonscaled[i] &gt;= params.sim.min_control for i in range(params.scp.n)] # Control Constraints\n\n    constr += [x_nonscaled[i][params.sim.idx_x_true] &lt;= params.sim.max_state[params.sim.idx_x_true] for i in range(params.scp.n)]\n    constr += [x_nonscaled[i][params.sim.idx_x_true] &gt;= params.sim.min_state[params.sim.idx_x_true] for i in range(params.scp.n)] # State Constraints (Also implemented in CTCS but included for numerical stability)\n\n    ########\n    # COSTS\n    ########\n\n    inv = block([[inv_S_x, np.zeros((S_x.shape[0], S_u.shape[1]))], [np.zeros((S_u.shape[0], S_x.shape[1])), inv_S_u]])\n    cost += sum(w_tr * cp.sum_squares(inv @ cp.hstack((dx[i], du[i]))) for i in range(params.scp.n))  # Trust Region Cost\n    cost += sum(params.scp.lam_vc * cp.sum(cp.abs(nu[i-1])) for i in range(1, params.scp.n)) # Virtual Control Slack\n\n    idx_ncvx = 0\n    if params.sim.constraints_nodal:\n        for constraint in params.sim.constraints_nodal:\n            if not constraint.convex:\n                cost += params.scp.lam_vb * cp.sum(cp.pos(nu_vb[idx_ncvx]))\n                idx_ncvx += 1\n\n    for idx, nodes in zip(np.arange(params.sim.idx_y.start, params.sim.idx_y.stop), params.sim.ctcs_node_intervals):  \n        if nodes[0] == 0:\n            start_idx = 1\n        else:\n            start_idx = nodes[0]\n        constr += [cp.abs(x_nonscaled[i][idx] - x_nonscaled[i-1][idx]) &lt;= params.sim.max_state[idx] for i in range(start_idx, nodes[1])]\n        constr += [x_nonscaled[0][idx] == 0]\n\n\n    #########\n    # PROBLEM\n    #########\n    prob = cp.Problem(cp.Minimize(cost), constr)\n    if params.cvx.cvxpygen:\n        # Check to see if solver directory exists\n        if not os.path.exists('solver'):\n            cpg.generate_code(prob, solver = params.cvx.solver, code_dir='solver', wrapper = True)\n        else:\n            # Prompt the use to indicate if they wish to overwrite the solver directory or use the existing compiled solver\n            overwrite = input(\"Solver directory already exists. Overwrite? (y/n): \")\n            if overwrite.lower() == 'y':\n                cpg.generate_code(prob, solver = params.cvx.solver, code_dir='solver', wrapper = True)\n            else:\n                pass\n    return prob\n</code></pre>"},{"location":"Overview/scvx/","title":"What is Succesive Convexification?","text":"<p>Warning</p> <p>This page is still under development .</p> <p>Successive Convexification is an approach to solve infinite dimensional nonconvex trajectory optimization problems. It works by successively convexifying or linearizing a problem and solving the convex subproblem. The solution to the convex subproblem is then used to update the original problem, and the process is repeated until convergence.</p> <p> </p>"},{"location":"Overview/scvx/#problem-formulation","title":"Problem Formulation","text":"<p>In this repository, the user will likely find it most useful specify there problem in the Mayer Form order to take full advantage of the features of this repo, but not worry this is quite easy.</p> \\[ \\begin{align} \\min_{x,u}\\ &amp;L_{f}(x(t_f)), \\\\ \\mathrm{s.t.}\\ &amp;\\dot{x}(t) = f(t, x(t),u(t)) &amp; \\forall t\\in[t_i, t_f], \\\\ &amp; g(t,x(t),u(t)) \\leq 0_{n_g} &amp; \\forall t\\in[t_i, t_f],\\\\ &amp; h(t,x(t),u(t)) = 0_{n_h} &amp; \\forall t\\in[t_i, t_f],\\\\ &amp; P(t_i, x(t_i), t_f, x(t_f)) = 0_{n_P} , \\\\ &amp; Q(t_i, x(t_i), t_f, x(t_f)) = 0_{n_Q} , \\\\ \\end{align} \\] <p>Lets break down whats happening here. The first line, \\(L_{f}(x(t_f))\\), is specifying a terminal cost as a function of state. The second is describing the nonlinear dynamics of the system, \\(\\dot{x}(t) = f(t, x(t),u(t))\\) where \\(x\\) and \\(u\\) are the system state and control respectively. The third and fourth lines are describing the inequality, \\(g(t,x(t),u(t)) \\leq 0_{n_g}\\),  and equality, \\(h(t,x(t),u(t)) = 0_{n_h}\\), constraints on the system respectively. Finally, the initial and terminal inequality and equality constraints are specified by \\(P(t_i, x(t_i), t_f, x(t_f)) = 0_{n_P}\\) and \\(Q(t_i, x(t_i), t_f, x(t_f)) = 0_{n_Q}\\) respectively.</p>"},{"location":"Overview/time_dilation/","title":"Time Dilation","text":"<p>Warning</p> <p>This page is still under development .</p>"},{"location":"Usage/advanced_problem_setup/","title":"Advanced Problem Setup","text":""},{"location":"Usage/advanced_problem_setup/#using-parameters-in-dynamics-and-constraints","title":"Using Parameters in Dynamics and Constraints","text":"<p>OpenSCvx allows you to define symbolic parameters that can be used in both dynamics and constraints. Parameters enable flexible, reusable problem definitions and can be updated at runtime without recompiling.</p>"},{"location":"Usage/advanced_problem_setup/#example-3dof-rocket-landing-with-parameters","title":"Example: 3DoF Rocket Landing with Parameters","text":"<pre><code>import numpy as np\nimport openscvx as ox\n\n# Define parameters for physical constants\ng_e = 9.807  # Gravitational acceleration on Earth (m/s^2)\n\n# Create symbolic parameters\nI_sp = ox.Parameter(\"I_sp\", value=225.0)\ng = ox.Parameter(\"g\", value=3.7114)\ntheta = ox.Parameter(\"theta\", value=27 * np.pi / 180)\n\n# Define states\nposition = ox.State(\"position\", shape=(3,))\nvelocity = ox.State(\"velocity\", shape=(3,))\nmass = ox.State(\"mass\", shape=(1,))\n\n# Define control\nthrust = ox.Control(\"thrust\", shape=(3,))\n\n# Use parameters in dynamics\ng_vec = np.array([0, 0, 1], dtype=np.float64) * g\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": thrust / mass[0] - g_vec,\n    \"mass\": -ox.linalg.Norm(thrust) / (I_sp * g_e * ox.Cos(theta)),\n}\n</code></pre> <p>Parameters are automatically detected and handled by the problem - no need to manually collect or pass them.</p>"},{"location":"Usage/advanced_problem_setup/#using-parameters-in-constraints","title":"Using Parameters in Constraints","text":"<p>Parameters can be used in constraints just like in dynamics:</p> <pre><code># Define obstacle parameters\nobs_center = ox.Parameter(\"obs_center\", shape=(3,), value=np.array([100, 100, 50]))\nobs_radius = ox.Parameter(\"obs_radius\", value=50.0)\n\n# Use in continuous constraint\ndiff = position - obs_center\nconstraints.append(\n    ox.ctcs(diff.T @ diff &gt;= obs_radius**2)\n)\n\n# Use in discrete constraint\nconstraints.append(\n    (ox.linalg.Norm(position - obs_center) &gt;= obs_radius).at([10])\n)\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#updating-parameters-at-runtime","title":"Updating Parameters at Runtime","text":"<p>Parameters can be updated between solves without recompiling:</p> <pre><code># Initial solve\nproblem.initialize()\nresults = problem.solve()\n\n# Update parameter values\nproblem.parameters[\"obs_center\"] = np.array([150, 150, 60])\nproblem.parameters[\"obs_radius\"] = 60.0\n\n# Resolve with new parameter values (no recompilation needed)\nresults = problem.solve()\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#ctcs-constraints-advanced-options","title":"CTCS Constraints: Advanced Options","text":"<p>CTCS (Continuous-Time Constraint Satisfaction) constraints are enforced over continuous intervals using penalty functions.</p>"},{"location":"Usage/advanced_problem_setup/#penalty-function","title":"Penalty Function","text":"<p>You can specify a penalty function using the <code>penalty</code> argument. Built-in options include:</p> <ul> <li><code>squared_relu</code> (default) - \\(\\max(0, g)^2\\)</li> <li><code>huber</code> - \\(\\begin{cases} \\frac{1}{2} g^2 &amp; \\text{if } |g| \\leq \\delta \\\\ \\delta (|g| - \\frac{1}{2}\\delta) &amp; \\text{otherwise} \\end{cases}\\)</li> <li><code>smooth_relu</code> - \\(\\|\\max(0, g)+c\\|-c\\)</li> </ul> <p>Example:</p> <pre><code>constraints.append(\n    ox.ctcs(ox.linalg.Norm(position[:2]) &lt;= 10.0, penalty=\"huber\")\n)\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#node-specific-regions","title":"Node-Specific Regions","text":"<p>To enforce a constraint only over a portion of the trajectory, use the <code>.over()</code> method:</p> <pre><code># Enforce constraint between nodes 3 and 8\nconstraint = (ox.linalg.Norm(position[:2]) &lt;= 10.0).over(\n    interval=(3, 8),\n    penalty=\"squared_relu\"\n)\nconstraints.append(constraint)\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#multiple-augmented-states","title":"Multiple Augmented States","text":"<p>To associate different constraints with different augmented states, use the <code>idx</code> argument:</p> <pre><code># Box constraints use augmented state 0\nconstraints.extend([\n    ox.ctcs(position &lt;= position.max, idx=0),\n    ox.ctcs(position.min &lt;= position, idx=0),\n])\n\n# Thrust magnitude constraints use augmented state 1\nconstraints.extend([\n    ox.ctcs(rho_min &lt;= ox.linalg.Norm(thrust), idx=1),\n    ox.ctcs(ox.linalg.Norm(thrust) &lt;= rho_max, idx=1),\n])\n\n# Thrust pointing constraint uses augmented state 2\nconstraints.append(\n    ox.ctcs(np.cos(theta_max) &lt;= thrust[2] / ox.linalg.Norm(thrust), idx=2)\n)\n</code></pre> <p>This allows different constraints to use separate virtual control and augmented state variables, which can improve convergence.</p>"},{"location":"Usage/advanced_problem_setup/#nodal-constraints-advanced-options","title":"Nodal Constraints: Advanced Options","text":"<p>Nodal constraints are enforced at specific discrete nodes in the trajectory.</p>"},{"location":"Usage/advanced_problem_setup/#convex-and-nonconvex-constraints","title":"Convex and Nonconvex Constraints","text":"<p>For convex constraints, use the <code>.convex()</code> method:</p> <pre><code># Convex constraint - waypoint at node 10\ntarget = np.array([100, 100, 50])\nconstraints.append(\n    (ox.linalg.Norm(position - target, ord=\"inf\") &lt;= 1.0).convex().at([10])\n)\n\n# Convex constraint - altitude limit at node 15\nconstraints.append(\n    (position[2] &gt;= 10.0).convex().at([15])\n)\n</code></pre> <p>For nonconvex constraints, simply use the constraint without <code>.convex()</code>:</p> <pre><code># Nonconvex constraint\nconstraints.append(\n    (velocity.T @ velocity &lt;= v_max**2).at([5, 10, 15])\n)\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#node-specification","title":"Node Specification","text":"<p>Use the <code>.at()</code> method to specify which nodes enforce the constraint:</p> <pre><code># Single node\nconstraints.append((position[2] &gt;= 0).at([0]))\n\n# Multiple nodes\nconstraints.append((ox.linalg.Norm(velocity) &lt;= v_max).at([5, 10, 15, 20]))\n\n# Final node\nconstraints.append((velocity == np.array([0, 0, 0])).at([n-1]))\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#combining-with-ctcs","title":"Combining with CTCS","text":"<p>You can enforce a constraint both continuously and at specific nodes:</p> <pre><code># Enforce continuously with CTCS\nconstraint = ox.linalg.Norm(position - target) &gt;= safe_distance\n\n# Also check nodally (optional, for verification)\nconstraints.append(\n    constraint.over(interval=(0, n-1), check_nodally=True)\n)\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#solver-settings","title":"Solver Settings","text":"<p>OpenSCvx provides extensive configuration options for tuning solver behavior.</p>"},{"location":"Usage/advanced_problem_setup/#scp-algorithm-settings","title":"SCP Algorithm Settings","text":"<pre><code># Trust region settings\nproblem.settings.scp.w_tr = 2e0                  # Trust region weight\nproblem.settings.scp.w_tr_adapt = 1.04           # Trust region adaptation factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e2  # Maximum trust region scaling\n\n# Cost and virtual control weights\nproblem.settings.scp.lam_cost = 2.5e-1           # Weight on the cost objective\nproblem.settings.scp.lam_vc = 1.2e0              # Weight on virtual control\nproblem.settings.scp.lam_vb = 1e0                # Virtual buffer weight (for nonconvex nodal constraints)\n\n# Convergence tolerances\nproblem.settings.scp.ep_tr = 1e-3                # Trust region tolerance\nproblem.settings.scp.ep_vc = 1e-8                # Virtual control tolerance\n\n# Cost relaxation\nproblem.settings.scp.cost_drop = 10              # Iteration to start relaxing cost\nproblem.settings.scp.cost_relax = 0.8            # Cost relaxation factor\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#convex-solver-settings","title":"Convex Solver Settings","text":"<pre><code># Choose convex solver\nproblem.settings.cvx.solver = \"CLARABEL\"  # Options: \"CLARABEL\", \"ECOS\", \"SCS\", \"MOSEK\"\n\n# Solver-specific arguments\nproblem.settings.cvx.solver_args = {\n    \"enforce_dpp\": True,  # Data Parallel Processing for CLARABEL\n}\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#integration-settings","title":"Integration Settings","text":"<pre><code># Propagation time step\nproblem.settings.prp.dt = 0.01\n\n# Integration method\nproblem.settings.dis.solver = \"Dopri8\"  # Options: \"Dopri5\", \"Dopri8\", \"Tsit5\", etc.\n</code></pre>"},{"location":"Usage/advanced_problem_setup/#compilation-and-caching","title":"Compilation and Caching","text":"<pre><code># Save compiled JAX functions for faster subsequent runs\nproblem.settings.sim.save_compiled = True\n</code></pre>"},{"location":"Usage/api/","title":"API","text":"<p>Warning</p> <p>This page is still under development .</p>"},{"location":"Usage/api/#openscvx.dynamics.Dynamics","title":"<code>openscvx.dynamics.Dynamics</code>  <code>dataclass</code>","text":"<p>Dataclass to hold a system dynamics function and (optionally) its gradients. This class is intended to be instantiated using the <code>dynamics</code> decorator wrapped around a function defining the system dynamics. Both the dynamics and optional gradients should be composed of <code>jax</code> primitives to enable efficient computation.</p> <p>Usage examples:</p> <pre><code>@dynamics\ndef f(x_, u_):\n    return x_ + u_\n# f is now a Dynamics object\n</code></pre> <pre><code>@dynamics(A=grad_f_x, B=grad_f_u)\ndef f(x_, u_):\n    return x_ + u_\n</code></pre> <p>Or, if a more lambda-function-style is desired, the function can be directly wrapped:</p> <pre><code>dyn = dynamics(lambda x_, u_: x_ + u_)\n</code></pre> <p>Using Parameters in Dynamics</p> <p>You can use symbolic <code>Parameter</code> objects in your dynamics function to represent tunable or environment-dependent values. The argument names for parameters must match the parameter name with an underscore suffix (e.g., <code>I_sp_</code> for a parameter named <code>I_sp</code>). This is required for the parameter mapping to work correctly.</p> <p>Example (3DoF rocket landing):</p> <pre><code>from openscvx.backend.parameter import Parameter\nimport jax.numpy as jnp\n\nI_sp = Parameter(\"I_sp\")\ng = Parameter(\"g\")\ntheta = Parameter(\"theta\")\n\n@dynamics\ndef rocket_dynamics(x_, u_, I_sp_, g_, theta_):\n    m = x_[6]\n    T = u_\n    r_dot = x_[3:6]\n    g_vec = jnp.array([0, 0, g_])\n    v_dot = T/m - g_vec\n    m_dot = -jnp.linalg.norm(T) / (I_sp_ * 9.807 * jnp.cos(theta_))\n    t_dot = 1\n    return jnp.hstack([r_dot, v_dot, m_dot, t_dot])\n\n# Set parameter values before solving\nI_sp.value = 225\ng.value = 3.7114\ntheta.value = 27 * jnp.pi / 180\n</code></pre> <p>Using Parameters in Nodal Constraints</p> <p>You can also use symbolic <code>Parameter</code> objects in nodal constraints. As with dynamics, the argument names for parameters in the constraint function must match the parameter name with an underscore suffix (e.g., <code>g_</code> for a parameter named <code>g</code>).</p> <p>Example:</p> <pre><code>from openscvx.backend.parameter import Parameter\nfrom openscvx.constraints import nodal\nimport jax.numpy as jnp\n\ng = Parameter(\"g\")\ng.value = 3.7114\n\n@nodal\ndef terminal_velocity_constraint(x_, u_, g_):\n    # Enforce a terminal velocity constraint using the gravity parameter\n    return x_[5] + g_ * x_[7]  # e.g., vz + g * t &lt;= 0 at final node\n</code></pre> <p>When building your problem, collect all parameters with <code>Parameter.get_all()</code> and pass them to your problem setup.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray], ndarray]</code> <p>Function defining the continuous time nonlinear system dynamics as x_dot = f(x, u, ...params). - x: 1D array (state at a single node), shape (n_x,) - u: 1D array (control at a single node), shape (n_u,) - Additional parameters: passed as keyword arguments with names   matching the parameter name plus an underscore (e.g., g_ for   Parameter('g')). If you want to use parameters, include them as extra arguments with the underscore naming convention. If you use vectorized integration or batch evaluation, x and u may be 2D arrays (N, n_x) and (N, n_u).</p> required <code>A</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of <code>f</code> w.r.t. <code>x</code>. If not specified, will be calculated using <code>jax.jacfwd</code>.</p> <code>None</code> <code>B</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of <code>f</code> w.r.t. <code>u</code>. If not specified, will be calculated using <code>jax.jacfwd</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Dynamics</code> <p>A dataclass bundling the system dynamics function and</p> <p>Jacobians.</p>"},{"location":"Usage/api/#constraints","title":"Constraints","text":"<p>Constraints in openscvx are created using symbolic expressions with comparison operators (<code>==</code>, <code>&lt;=</code>, <code>&gt;=</code>). By default, constraints are enforced at discrete nodes along the trajectory (nodal constraints). The symbolic expression system provides two specialized constraint wrappers for precise control over when and how constraints are enforced.</p>"},{"location":"Usage/api/#basic-constraints","title":"Basic Constraints","text":"<p>All basic constraints are automatically enforced at all discrete nodes unless wrapped with <code>.at()</code> or <code>.over()</code>.</p>"},{"location":"Usage/api/#equality","title":"Equality","text":""},{"location":"Usage/api/#openscvx.symbolic.expr.expr.Equality","title":"<code>openscvx.symbolic.expr.expr.Equality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Equality constraint for optimization problems.</p> <p>Represents an equality constraint: lhs == rhs. Can be created using the == operator on Expr objects.</p> Example <p>x = ox.State(\"x\", shape=(3,)) constraint = x == 0  # Creates Equality(x, Constant(0))</p>"},{"location":"Usage/api/#inequality","title":"Inequality","text":""},{"location":"Usage/api/#openscvx.symbolic.expr.expr.Inequality","title":"<code>openscvx.symbolic.expr.expr.Inequality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Inequality constraint for optimization problems.</p> <p>Represents an inequality constraint: lhs &lt;= rhs. Can be created using the &lt;= operator on Expr objects.</p> Example <p>x = ox.State(\"x\", shape=(3,)) constraint = x &lt;= 10  # Creates Inequality(x, Constant(10))</p>"},{"location":"Usage/api/#specialized-constraint-wrappers","title":"Specialized Constraint Wrappers","text":""},{"location":"Usage/api/#nodalconstraint","title":"NodalConstraint","text":"<p>NodalConstraint allows selective enforcement of constraints at specific time points (nodes) in a discretized trajectory. Created using the <code>.at()</code> method on constraints. Note: Bare constraints without <code>.at()</code> or <code>.over()</code> are automatically converted to NodalConstraints applied at all nodes.</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint","title":"<code>openscvx.symbolic.expr.constraint.NodalConstraint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Wrapper for constraints enforced only at specific discrete trajectory nodes.</p> <p>NodalConstraint allows selective enforcement of constraints at specific time points (nodes) in a discretized trajectory, rather than enforcing them at every node. This is useful for:</p> <ul> <li>Specifying waypoint constraints (e.g., pass through point X at node 10)</li> <li>Boundary conditions at non-standard locations</li> <li>Reducing computational cost by checking constraints less frequently</li> <li>Enforcing periodic constraints (e.g., every 5th node)</li> </ul> <p>The wrapper maintains clean separation between the constraint's mathematical definition and the specification of where it should be applied during optimization.</p> Note <p>Bare Constraint objects (without .at() or .over()) are automatically converted to NodalConstraints applied at all nodes during preprocessing.</p> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (Equality or Inequality) to enforce</p> <code>nodes</code> <p>List of integer node indices where the constraint is enforced</p> Example"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint--enforce-position-constraint-only-at-nodes-0-10-and-20","title":"Enforce position constraint only at nodes 0, 10, and 20","text":"<p>x = State(\"x\", shape=(3,)) target = [10, 5, 0] constraint = (x == target).at([0, 10, 20])</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint--equivalent-using-nodalconstraint-directly","title":"Equivalent using NodalConstraint directly","text":"<p>constraint = NodalConstraint(x == target, nodes=[0, 10, 20])</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint--periodic-constraint-enforcement-every-10th-node","title":"Periodic constraint enforcement (every 10th node)","text":"<p>velocity_limit = (vel &lt;= 100).at(list(range(0, 100, 10)))</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint--bare-constraints-are-automatically-applied-at-all-nodes","title":"Bare constraints are automatically applied at all nodes","text":""},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint--these-are-equivalent","title":"These are equivalent:","text":"<p>constraint1 = vel &lt;= 100  # Auto-converted to all nodes constraint2 = (vel &lt;= 100).at(list(range(n_nodes)))</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the wrapped constraint while preserving node specification.</p> <p>Returns:</p> Name Type Description <code>NodalConstraint</code> <code>Expr</code> <p>A new NodalConstraint with canonicalized inner constraint</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the wrapped constraint's shape.</p> <p>NodalConstraint wraps a constraint without changing its computational meaning, only specifying where it should be applied. Like all constraints, it produces a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.NodalConstraint.convex","title":"<code>convex() -&gt; NodalConstraint</code>","text":"<p>Mark the underlying constraint as convex for CVXPy lowering.</p> <p>Returns:</p> Type Description <code>NodalConstraint</code> <p>Self with underlying constraint's convex flag set to True (enables method chaining)</p> Example <p>constraint = (x &lt;= 10).at([0, 5, 10]).convex()</p>"},{"location":"Usage/api/#ctcs-continuous-time-constraint-satisfaction","title":"CTCS (Continuous-Time Constraint Satisfaction)","text":"<p>CTCS guarantees strict constraint satisfaction throughout the entire continuous trajectory, not just at discrete nodes. It works by augmenting the state vector with additional states whose dynamics integrate constraint violation penalties. Created using the <code>.over()</code> method on constraints.</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS","title":"<code>openscvx.symbolic.expr.constraint.CTCS</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Continuous-Time Constraint Satisfaction using augmented state dynamics.</p> <p>CTCS enables strict continuous-time constraint enforcement in discretized trajectory optimization by augmenting the state vector with additional states whose dynamics are the constraint violation penalties. By constraining these augmented states to remain at zero throughout the trajectory, the original constraints are guaranteed to be satisfied continuously, not just at discrete nodes.</p> <p>How it works:</p> <ol> <li>Each constraint (in canonical form: lhs &lt;= 0) is wrapped in a penalty function</li> <li>Augmented states s_aug_i are added with dynamics: ds_aug_i/dt = sum(penalty_j(lhs_j))    for all CTCS constraints j in group i</li> <li>Each augmented state is constrained: s_aug_i(t) = 0 for all t (strictly enforced)</li> <li>Since s_aug_i integrates the penalties, s_aug_i = 0 implies all penalties in the    group are zero, which means all constraints in the group are satisfied continuously</li> </ol> <p>Grouping and augmented states:</p> <ul> <li>CTCS constraints with the same node interval are grouped into a single augmented   state by default (their penalties are summed)</li> <li>CTCS constraints with different node intervals create separate augmented states</li> <li>Using the <code>idx</code> parameter explicitly assigns constraints to specific augmented states,   allowing manual control over grouping</li> <li>Each unique group creates one augmented state named <code>_ctcs_aug_0</code>, <code>_ctcs_aug_1</code>, etc.</li> </ul> <p>This is particularly useful for:</p> <ul> <li>Path constraints that must hold throughout the entire trajectory (not just at nodes)</li> <li>Obstacle avoidance where constraint violation between nodes could be catastrophic</li> <li>State limits that should be respected continuously (e.g., altitude &gt; 0 for aircraft)</li> <li>Ensuring smooth, feasible trajectories between discretization points</li> </ul> <p>Penalty functions (applied to constraint violations):</p> <ul> <li>squared_relu: Square(PositivePart(lhs)) - smooth, differentiable (default)</li> <li>huber: Huber(PositivePart(lhs)) - less sensitive to outliers than squared</li> <li>smooth_relu: SmoothReLU(lhs) - smooth approximation of ReLU</li> </ul> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (typically Inequality) to enforce continuously</p> <code>penalty</code> <p>Penalty function type ('squared_relu', 'huber', or 'smooth_relu')</p> <code>nodes</code> <p>Optional (start, end) tuple specifying the interval for enforcement, or None to enforce over the entire trajectory</p> <code>idx</code> <p>Optional grouping index for managing multiple augmented states. CTCS constraints with the same idx and nodes are grouped together, sharing an augmented state. If None, auto-assigned based on node intervals.</p> <code>check_nodally</code> <p>Whether to also enforce the constraint at discrete nodes for additional numerical robustness (creates both continuous and nodal constraints)</p> Example"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS--single-augmented-state-default-behavior-same-node-interval","title":"Single augmented state (default behavior - same node interval)","text":"<p>altitude = State(\"alt\", shape=(1,)) constraints = [ ...     (altitude &gt;= 10).over((0, 10)),  # Both constraints share ...     (altitude &lt;= 1000).over((0, 10))  # one augmented state ... ]</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS--multiple-augmented-states-different-node-intervals","title":"Multiple augmented states (different node intervals)","text":"<p>constraints = [ ...     (altitude &gt;= 10).over((0, 5)),  # Creates _ctcs_aug_0 ...     (altitude &gt;= 20).over((5, 10))  # Creates _ctcs_aug_1 ... ]</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS--manual-grouping-with-idx-parameter","title":"Manual grouping with idx parameter","text":"<p>constraints = [ ...     (altitude &gt;= 10).over((0, 10), idx=0),    # Group 0 ...     (velocity &lt;= 100).over((0, 10), idx=1),   # Group 1 (separate state) ...     (altitude &lt;= 1000).over((0, 10), idx=0)   # Also group 0 ... ]</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the inner constraint while preserving CTCS parameters.</p> <p>Returns:</p> Name Type Description <code>CTCS</code> <code>Expr</code> <p>A new CTCS with canonicalized inner constraint and same parameters</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the constraint and penalty expression shapes.</p> <p>CTCS transforms the wrapped constraint into a penalty expression that is summed (integrated) over the trajectory, always producing a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the wrapped constraint has invalid shape</p> <code>ValueError</code> <p>If the generated penalty expression is not scalar</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS.over","title":"<code>over(interval: tuple[int, int]) -&gt; CTCS</code>","text":"<p>Set or update the continuous interval for this CTCS constraint.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>tuple[int, int]</code> <p>Tuple of (start, end) node indices defining the enforcement interval</p> required <p>Returns:</p> Name Type Description <code>CTCS</code> <code>CTCS</code> <p>New CTCS constraint with the specified interval</p> Example <p>constraint = (altitude &gt;= 10).over((0, 50))</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS.over--update-interval-to-cover-different-range","title":"Update interval to cover different range","text":"<p>constraint_updated = constraint.over((50, 100))</p>"},{"location":"Usage/api/#openscvx.symbolic.expr.constraint.CTCS.penalty_expr","title":"<code>penalty_expr() -&gt; Expr</code>","text":"<p>Build the penalty expression for this CTCS constraint.</p> <p>Transforms the constraint's left-hand side (in canonical form: lhs &lt;= 0) into a penalty expression using the specified penalty function. The penalty is zero when the constraint is satisfied and positive when violated.</p> <p>This penalty expression becomes part of the dynamics of an augmented state. Multiple CTCS constraints in the same group (same idx) have their penalties summed: ds_aug_i/dt = sum(penalty_j) for all j in group i. By constraining s_aug_i(t) = 0 for all t, we ensure all penalties in the group are zero, which strictly enforces all constraints in the group continuously.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Sum of the penalty function applied to the constraint violation</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown penalty type is specified</p> Note <p>This method is used internally during problem compilation to create augmented state dynamics. Multiple penalty expressions with the same idx are summed together before being added to the dynamics vector via Concat.</p>"},{"location":"Usage/api/#integrators","title":"Integrators","text":""},{"location":"Usage/api/#rk45integrator","title":"RK45Integrator","text":""},{"location":"Usage/api/#openscvx.integrators.solve_ivp_rk45","title":"<code>openscvx.integrators.solve_ivp_rk45(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, is_not_compiled: bool = False)</code>","text":"<p>Solve an initial-value ODE problem using fixed-step RK45 integration.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code>.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of output time points. Defaults to 50.</p> <code>50</code> <code>is_not_compiled</code> <code>bool</code> <p>If True, use Python loop instead of JAX <code>lax.fori_loop</code>. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Array of shape (num_substeps, state_dim) with solution at each time.</p>"},{"location":"Usage/api/#openscvx.integrators.rk45_step","title":"<code>openscvx.integrators.rk45_step(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], t: jnp.ndarray, y: jnp.ndarray, h: float, *args) -&gt; jnp.ndarray</code>","text":"<p>Perform a single RK45 (Runge-Kutta-Fehlberg) integration step.</p> <p>This implements the classic Dorman-Prince coefficients for an explicit 4(5) method, returning the fourth-order estimate.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>t</code> <code>ndarray</code> <p>Current time.</p> required <code>y</code> <code>ndarray</code> <p>Current state vector.</p> required <code>h</code> <code>float</code> <p>Step size.</p> required <code>*args</code> <p>Additional arguments passed to <code>f</code>.</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: Next state estimate at t + h.</p>"},{"location":"Usage/api/#diffrax-integrators","title":"Diffrax Integrators","text":""},{"location":"Usage/api/#openscvx.integrators.solve_ivp_diffrax","title":"<code>openscvx.integrators.solve_ivp_diffrax(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; f(t, y, *args).</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>solver_name</code> is not in SOLVER_MAP.</p>"},{"location":"Usage/api/#openscvx.integrators.solve_ivp_diffrax_prop","title":"<code>openscvx.integrators.solve_ivp_diffrax_prop(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None, save_time: jnp.ndarray = None, mask: jnp.ndarray = None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver. This function is specifically designed for use in the context of trajectory optimization and handles the nonlinear single-shot propagation of state variables in undilated time.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <code>save_time</code> <code>ndarray</code> <p>Time points at which to evaluate the solution. Must be provided for export compatibility.</p> <code>None</code> <code>mask</code> <code>ndarray</code> <p>Boolean mask for the save_time points.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:     ValueError: If <code>solver_name</code> is not in SOLVER_MAP or if save_time is not provided.</p>"},{"location":"Usage/api/#trajoptproblem","title":"TrajOptProblem","text":""},{"location":"Usage/api/#openscvx.trajoptproblem.TrajOptProblem.__init__","title":"<code>openscvx.trajoptproblem.TrajOptProblem.__init__(dynamics: dict, constraints: List[Union[Constraint, CTCS]], states: List[State], controls: List[Control], N: int, time: Time, dynamics_prop: Optional[dict] = None, states_prop: Optional[List[State]] = None, scp: Optional[ScpConfig] = None, dis: Optional[DiscretizationConfig] = None, prp: Optional[PropagationConfig] = None, sim: Optional[SimConfig] = None, dev: Optional[DevConfig] = None, cvx: Optional[ConvexSolverConfig] = None, licq_min=0.0, licq_max=0.0001, time_dilation_factor_min=0.3, time_dilation_factor_max=3.0)</code>","text":"<p>The primary class in charge of compiling and exporting the solvers</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>dict</code> <p>Dictionary mapping state names to their dynamics expressions. Each key should be a state name, and each value should be an Expr representing the derivative of that state.</p> required <code>constraints</code> <code>List[Union[CTCSConstraint, NodalConstraint]]</code> <p>List of constraints decorated with @ctcs or @nodal</p> required <code>states</code> <code>List[State]</code> <p>List of State objects representing the state variables. May optionally include a State named \"time\" (see time parameter below).</p> required <code>controls</code> <code>List[Control]</code> <p>List of Control objects representing the control variables</p> required <code>N</code> <code>int</code> <p>Number of segments in the trajectory</p> required <code>time</code> <code>Time</code> <p>Time configuration object with initial, final, min, max. Required. If including a \"time\" state in states, the Time object will be ignored and time properties should be set on the time State object instead.</p> required <code>dynamics_prop</code> <code>dict</code> <p>Dictionary mapping EXTRA state names to their dynamics expressions for propagation. Only specify additional states beyond optimization states (e.g., {\"distance\": speed}). Do NOT duplicate optimization state dynamics here.</p> <code>None</code> <code>states_prop</code> <code>List[State]</code> <p>List of EXTRA State objects for propagation only. Only specify additional states beyond optimization states. Used with dynamics_prop.</p> <code>None</code> <code>scp</code> <code>Optional[ScpConfig]</code> <p>SCP configuration object</p> <code>None</code> <code>dis</code> <code>Optional[DiscretizationConfig]</code> <p>Discretization configuration object</p> <code>None</code> <code>prp</code> <code>Optional[PropagationConfig]</code> <p>Propagation configuration object</p> <code>None</code> <code>sim</code> <code>Optional[SimConfig]</code> <p>Simulation configuration object</p> <code>None</code> <code>dev</code> <code>Optional[DevConfig]</code> <p>Development configuration object</p> <code>None</code> <code>cvx</code> <code>Optional[ConvexSolverConfig]</code> <p>Convex solver configuration object</p> <code>None</code> <code>licq_min</code> <p>Minimum LICQ constraint value</p> <code>0.0</code> <code>licq_max</code> <p>Maximum LICQ constraint value</p> <code>0.0001</code> <code>time_dilation_factor_min</code> <p>Minimum time dilation factor</p> <code>0.3</code> <code>time_dilation_factor_max</code> <p>Maximum time dilation factor</p> <code>3.0</code> <p>Returns:</p> Type Description <p>None</p> Note <p>There are two approaches for handling time: 1. Auto-create (simple): Don't include \"time\" in states, provide Time object 2. User-provided (for time-dependent constraints): Include \"time\" State in states and    in dynamics dict, don't provide Time object</p>"},{"location":"Usage/api/#scpconfig","title":"ScpConfig","text":""},{"location":"Usage/api/#openscvx.config.ScpConfig.__init__","title":"<code>openscvx.config.ScpConfig.__init__(n: Optional[int] = None, k_max: int = 200, w_tr: float = 1.0, lam_vc: float = 1.0, ep_tr: float = 0.0001, ep_vb: float = 0.0001, ep_vc: float = 1e-08, lam_cost: float = 0.0, lam_vb: float = 0.0, uniform_time_grid: bool = False, cost_drop: int = -1, cost_relax: float = 1.0, w_tr_adapt: float = 1.0, w_tr_max: Optional[float] = None, w_tr_max_scaling_factor: Optional[float] = None)</code>","text":"<p>Configuration class for Sequential Convex Programming (SCP).</p> <p>This class defines the parameters used to configure the SCP solver. You will very likely need to modify the weights for your problem. Please refer to my guide here for more information.</p> <p>Attributes:</p> Name Type Description <code>n</code> <code>int</code> <p>The number of discretization nodes. Defaults to <code>None</code>.</p> <code>k_max</code> <code>int</code> <p>The maximum number of SCP iterations. Defaults to 200.</p> <code>w_tr</code> <code>float</code> <p>The trust region weight. Defaults to 1.0.</p> <code>lam_vc</code> <code>float</code> <p>The penalty weight for virtual control. Defaults to 1.0.</p> <code>ep_tr</code> <code>float</code> <p>The trust region convergence tolerance. Defaults to 1e-4.</p> <code>ep_vb</code> <code>float</code> <p>The boundary constraint convergence tolerance. Defaults to 1e-4.</p> <code>ep_vc</code> <code>float</code> <p>The virtual constraint convergence tolerance. Defaults to 1e-8.</p> <code>lam_cost</code> <code>float</code> <p>The weight for original cost. Defaults to 0.0.</p> <code>lam_vb</code> <code>float</code> <p>The weight for virtual buffer. This is only used if there are nonconvex nodal constraints present. Defaults to 0.0.</p> <code>uniform_time_grid</code> <code>bool</code> <p>Whether to use a uniform time grid. Defaults to <code>False</code>.</p> <code>cost_drop</code> <code>int</code> <p>The number of iterations to allow for cost stagnation before termination. Defaults to -1 (disabled).</p> <code>cost_relax</code> <code>float</code> <p>The relaxation factor for cost reduction. Defaults to 1.0.</p> <code>w_tr_adapt</code> <code>float</code> <p>The adaptation factor for the trust region weight. Defaults to 1.0.</p> <code>w_tr_max</code> <code>float</code> <p>The maximum allowable trust region weight. Defaults to <code>None</code>.</p> <code>w_tr_max_scaling_factor</code> <code>float</code> <p>The scaling factor for the maximum trust region weight. Defaults to <code>None</code>.</p>"},{"location":"Usage/api/#discretizationconfig","title":"DiscretizationConfig","text":""},{"location":"Usage/api/#openscvx.config.DiscretizationConfig.__init__","title":"<code>openscvx.config.DiscretizationConfig.__init__(dis_type: str = 'FOH', custom_integrator: bool = False, solver: str = 'Tsit5', args: Optional[dict] = None, atol: float = 0.001, rtol: float = 1e-06)</code>","text":"<p>Configuration class for discretization settings.</p> <p>This class defines the parameters required for discretizing system dynamics.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>dis_type</code> <code>str</code> <p>The type of discretization to use (e.g., \"FOH\" for First-Order Hold). Defaults to \"FOH\".</p> <code>'FOH'</code> <code>custom_integrator</code> <code>bool</code> <p>This enables our custom fixed-step RK45 algorithm. This tends to be faster than Diffrax but unless you're going for speed, it's recommended to stick with Diffrax for robustness and other solver options. Defaults to False.</p> <code>False</code> <code>solver</code> <code>str</code> <p>Not used if custom_integrator is enabled. Any choice of solver in Diffrax is valid, please refer here, How to Choose a Solver. Defaults to \"Tsit5\".</p> <code>'Tsit5'</code> <p>Other arguments: These arguments are less frequently used, and for most purposes you shouldn't need to understand these.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Dict</code> <p>Additional arguments to pass to the solver which can be found here. Defaults to an empty dictionary.</p> <code>None</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for the solver. Defaults to 1e-3.</p> <code>0.001</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for the solver. Defaults to 1e-6.</p> <code>1e-06</code>"},{"location":"Usage/api/#propagationconfig","title":"PropagationConfig","text":""},{"location":"Usage/api/#openscvx.config.PropagationConfig.__init__","title":"<code>openscvx.config.PropagationConfig.__init__(inter_sample: int = 30, dt: float = 0.01, solver: str = 'Dopri8', max_tau_len: int = 1000, args: Optional[dict] = None, atol: float = 0.001, rtol: float = 1e-06)</code>","text":"<p>Configuration class for propagation settings.</p> <p>This class defines the parameters required for propagating the nonlinear system dynamics using the optimal control sequence.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Other arguments: The solver should likely not be changed as it is a high accuracy 8th-order Runge-Kutta method.</p> <p>Parameters:</p> Name Type Description Default <code>inter_sample</code> <code>int</code> <p>How dense the propagation within multishot discretization should be. Defaults to 30.</p> <code>30</code> <code>dt</code> <code>float</code> <p>The time step for propagation. Defaults to 0.1.</p> <code>0.01</code> <code>solver</code> <code>str</code> <p>The numerical solver to use for propagation (e.g., \"Dopri8\"). Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>max_tau_len</code> <code>int</code> <p>The maximum length of the time vector for propagation. Defaults to 1000.</p> <code>1000</code> <code>args</code> <code>Dict</code> <p>Additional arguments to pass to the solver. Defaults to an empty dictionary.</p> <code>None</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for the solver. Defaults to 1e-3.</p> <code>0.001</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for the solver. Defaults to 1e-6.</p> <code>1e-06</code>"},{"location":"Usage/api/#simconfig","title":"SimConfig","text":""},{"location":"Usage/api/#openscvx.config.SimConfig.__init__","title":"<code>openscvx.config.SimConfig.__init__(x: UnifiedState, x_prop: UnifiedState, u: UnifiedControl, total_time: float, save_compiled: bool = False, ctcs_node_intervals: Optional[list] = None, constraints_ctcs: Optional[list[Callable]] = None, constraints_nodal: Optional[list[Callable]] = None, constraints_nodal_convex: Optional[list[Callable]] = None, n_states: Optional[int] = None, n_states_prop: Optional[int] = None, n_controls: Optional[int] = None, scaling_x_overrides: Optional[list] = None, scaling_u_overrides: Optional[list] = None)</code>","text":"<p>Configuration class for simulation settings.</p> <p>This class defines the parameters required for simulating a trajectory optimization problem.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>State</code> <p>State object, must have .min and .max attributes for bounds.</p> required <code>x_prop</code> <code>State</code> <p>Propagation state object, must have .min and .max attributes for bounds.</p> required <code>u</code> <code>Control</code> <p>Control object, must have .min and .max attributes for bounds.</p> required <code>total_time</code> <code>float</code> <p>The total simulation time.</p> required <code>idx_x_true</code> <code>slice</code> <p>Slice for true state indices.</p> required <code>idx_x_true_prop</code> <code>slice</code> <p>Slice for true propagation state indices.</p> required <code>idx_u_true</code> <code>slice</code> <p>Slice for true control indices.</p> required <code>idx_t</code> <code>slice</code> <p>Slice for time index.</p> required <code>idx_y</code> <code>slice</code> <p>Slice for constraint violation indices.</p> required <code>idx_y_prop</code> <code>slice</code> <p>Slice for propagation constraint violation indices.</p> required <code>idx_s</code> <code>slice</code> <p>Slice for time dilation index.</p> required <code>save_compiled</code> <code>bool</code> <p>If True, save and reuse compiled solver functions. Defaults to False.</p> <code>False</code> <code>ctcs_node_intervals</code> <code>list</code> <p>Node intervals for CTCS constraints.</p> <code>None</code> <code>constraints_ctcs</code> <code>list</code> <p>List of CTCS constraints.</p> <code>None</code> <code>constraints_nodal</code> <code>list</code> <p>List of nodal constraints.</p> <code>None</code> <code>constraints_nodal_convex</code> <code>list</code> <p>List of convex nodal constraints.</p> <code>None</code> <code>n_states</code> <code>int</code> <p>The number of state variables. Defaults to <code>None</code> (inferred from x.max).</p> <code>None</code> <code>n_states_prop</code> <code>int</code> <p>The number of propagation state variables. Defaults to <code>None</code> (inferred from x_prop.max).</p> <code>None</code> <code>n_controls</code> <code>int</code> <p>The number of control variables. Defaults to <code>None</code> (inferred from u.max).</p> <code>None</code> <code>scaling_x_overrides</code> <code>list</code> <p>List of (upper_bound, lower_bound, idx) for custom state scaling. Each can be scalar or array, idx can be int, list, or slice.</p> <code>None</code> <code>scaling_u_overrides</code> <code>list</code> <p>List of (upper_bound, lower_bound, idx) for custom control scaling. Each can be scalar or array, idx can be int, list, or slice.</p> <code>None</code> Note <p>You can specify custom scaling for specific states/controls using scaling_x_overrides and scaling_u_overrides. Any indices not covered by overrides will use the default min/max bounds.</p>"},{"location":"Usage/api/#convexsolverconfig","title":"ConvexSolverConfig","text":""},{"location":"Usage/api/#openscvx.config.ConvexSolverConfig.__init__","title":"<code>openscvx.config.ConvexSolverConfig.__init__(solver: str = 'QOCO', solver_args: Optional[dict] = None, cvxpygen: bool = False, cvxpygen_override: bool = False)</code>","text":"<p>Configuration class for convex solver settings.</p> <p>This class defines the parameters required for configuring a convex solver.</p> <p>These are the arguments most commonly used day-to-day. Generally I have found QOCO to be the most performant of the CVXPY solvers for these types of problems (I do have a bias as the author is from my group) and can handle up to SOCP's. CLARABEL is also a great option with feasibility checking and can handle a few more problem types. CVXPYGen is also great if your problem isn't too large. I have found qocogen to be the most performant of the CVXPYGen solvers.</p> <p>Parameters:</p> Name Type Description Default <code>solver</code> <code>str</code> <p>The name of the CVXPY solver to use. A list of options can be found here. Defaults to \"QOCO\".</p> <code>'QOCO'</code> <code>solver_args</code> <code>dict</code> <p>Ensure you are using the correct arguments for your solver as they are not all common. Additional arguments to configure the solver, such as tolerances. Defaults to {\"abstol\": 1e-6, \"reltol\": 1e-9}.</p> <code>None</code> <code>cvxpygen</code> <code>bool</code> <p>Whether to enable CVXPY code generation for the solver. Defaults to False.</p> <code>False</code>"},{"location":"Usage/api/#devconfig","title":"DevConfig","text":""},{"location":"Usage/api/#openscvx.config.DevConfig.__init__","title":"<code>openscvx.config.DevConfig.__init__(profiling: bool = False, debug: bool = False, printing: bool = True)</code>","text":"<p>Configuration class for development settings.</p> <p>This class defines the parameters used for development and debugging purposes.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>profiling</code> <code>bool</code> <p>Whether to enable profiling for performance analysis. Defaults to False.</p> <code>False</code> <code>debug</code> <code>bool</code> <p>Disables all precompilation so you can place breakpoints and inspect values. Defaults to False.</p> <code>False</code> <code>printing</code> <code>bool</code> <p>Whether to enable printing during development. Defaults to True.</p> <code>True</code>"},{"location":"Usage/api_constraints/","title":"Constraints","text":"<p>Constraints in openscvx are created using symbolic expressions with comparison operators (<code>==</code>, <code>&lt;=</code>, <code>&gt;=</code>). By default, constraints are enforced at discrete nodes along the trajectory (nodal constraints). The symbolic expression system provides two specialized constraint wrappers for precise control over when and how constraints are enforced.</p>"},{"location":"Usage/api_constraints/#basic-constraints","title":"Basic Constraints","text":"<p>All basic constraints are automatically enforced at all discrete nodes unless wrapped with <code>.at()</code> or <code>.over()</code>.</p>"},{"location":"Usage/api_constraints/#equality","title":"Equality","text":""},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.expr.Equality","title":"<code>openscvx.symbolic.expr.expr.Equality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Equality constraint for optimization problems.</p> <p>Represents an equality constraint: lhs == rhs. Can be created using the == operator on Expr objects.</p> Example <p>x = ox.State(\"x\", shape=(3,)) constraint = x == 0  # Creates Equality(x, Constant(0))</p>"},{"location":"Usage/api_constraints/#inequality","title":"Inequality","text":""},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.expr.Inequality","title":"<code>openscvx.symbolic.expr.expr.Inequality</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>Inequality constraint for optimization problems.</p> <p>Represents an inequality constraint: lhs &lt;= rhs. Can be created using the &lt;= operator on Expr objects.</p> Example <p>x = ox.State(\"x\", shape=(3,)) constraint = x &lt;= 10  # Creates Inequality(x, Constant(10))</p>"},{"location":"Usage/api_constraints/#specialized-constraint-wrappers","title":"Specialized Constraint Wrappers","text":""},{"location":"Usage/api_constraints/#nodalconstraint","title":"NodalConstraint","text":"<p>NodalConstraint allows selective enforcement of constraints at specific time points (nodes) in a discretized trajectory. Created using the <code>.at()</code> method on constraints. Note: Bare constraints without <code>.at()</code> or <code>.over()</code> are automatically converted to NodalConstraints applied at all nodes.</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint","title":"<code>openscvx.symbolic.expr.constraint.NodalConstraint</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Wrapper for constraints enforced only at specific discrete trajectory nodes.</p> <p>NodalConstraint allows selective enforcement of constraints at specific time points (nodes) in a discretized trajectory, rather than enforcing them at every node. This is useful for:</p> <ul> <li>Specifying waypoint constraints (e.g., pass through point X at node 10)</li> <li>Boundary conditions at non-standard locations</li> <li>Reducing computational cost by checking constraints less frequently</li> <li>Enforcing periodic constraints (e.g., every 5th node)</li> </ul> <p>The wrapper maintains clean separation between the constraint's mathematical definition and the specification of where it should be applied during optimization.</p> Note <p>Bare Constraint objects (without .at() or .over()) are automatically converted to NodalConstraints applied at all nodes during preprocessing.</p> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (Equality or Inequality) to enforce</p> <code>nodes</code> <p>List of integer node indices where the constraint is enforced</p> Example"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint--enforce-position-constraint-only-at-nodes-0-10-and-20","title":"Enforce position constraint only at nodes 0, 10, and 20","text":"<p>x = State(\"x\", shape=(3,)) target = [10, 5, 0] constraint = (x == target).at([0, 10, 20])</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint--equivalent-using-nodalconstraint-directly","title":"Equivalent using NodalConstraint directly","text":"<p>constraint = NodalConstraint(x == target, nodes=[0, 10, 20])</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint--periodic-constraint-enforcement-every-10th-node","title":"Periodic constraint enforcement (every 10th node)","text":"<p>velocity_limit = (vel &lt;= 100).at(list(range(0, 100, 10)))</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint--bare-constraints-are-automatically-applied-at-all-nodes","title":"Bare constraints are automatically applied at all nodes","text":""},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint--these-are-equivalent","title":"These are equivalent:","text":"<p>constraint1 = vel &lt;= 100  # Auto-converted to all nodes constraint2 = (vel &lt;= 100).at(list(range(n_nodes)))</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the wrapped constraint while preserving node specification.</p> <p>Returns:</p> Name Type Description <code>NodalConstraint</code> <code>Expr</code> <p>A new NodalConstraint with canonicalized inner constraint</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the wrapped constraint's shape.</p> <p>NodalConstraint wraps a constraint without changing its computational meaning, only specifying where it should be applied. Like all constraints, it produces a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.NodalConstraint.convex","title":"<code>convex() -&gt; NodalConstraint</code>","text":"<p>Mark the underlying constraint as convex for CVXPy lowering.</p> <p>Returns:</p> Type Description <code>NodalConstraint</code> <p>Self with underlying constraint's convex flag set to True (enables method chaining)</p> Example <p>constraint = (x &lt;= 10).at([0, 5, 10]).convex()</p>"},{"location":"Usage/api_constraints/#ctcs-continuous-time-constraint-satisfaction","title":"CTCS (Continuous-Time Constraint Satisfaction)","text":"<p>CTCS guarantees strict constraint satisfaction throughout the entire continuous trajectory, not just at discrete nodes. It works by augmenting the state vector with additional states whose dynamics integrate constraint violation penalties. Created using the <code>.over()</code> method on constraints.</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS","title":"<code>openscvx.symbolic.expr.constraint.CTCS</code>","text":"<p>               Bases: <code>Expr</code></p> <p>Continuous-Time Constraint Satisfaction using augmented state dynamics.</p> <p>CTCS enables strict continuous-time constraint enforcement in discretized trajectory optimization by augmenting the state vector with additional states whose dynamics are the constraint violation penalties. By constraining these augmented states to remain at zero throughout the trajectory, the original constraints are guaranteed to be satisfied continuously, not just at discrete nodes.</p> <p>How it works:</p> <ol> <li>Each constraint (in canonical form: lhs &lt;= 0) is wrapped in a penalty function</li> <li>Augmented states s_aug_i are added with dynamics: ds_aug_i/dt = sum(penalty_j(lhs_j))    for all CTCS constraints j in group i</li> <li>Each augmented state is constrained: s_aug_i(t) = 0 for all t (strictly enforced)</li> <li>Since s_aug_i integrates the penalties, s_aug_i = 0 implies all penalties in the    group are zero, which means all constraints in the group are satisfied continuously</li> </ol> <p>Grouping and augmented states:</p> <ul> <li>CTCS constraints with the same node interval are grouped into a single augmented   state by default (their penalties are summed)</li> <li>CTCS constraints with different node intervals create separate augmented states</li> <li>Using the <code>idx</code> parameter explicitly assigns constraints to specific augmented states,   allowing manual control over grouping</li> <li>Each unique group creates one augmented state named <code>_ctcs_aug_0</code>, <code>_ctcs_aug_1</code>, etc.</li> </ul> <p>This is particularly useful for:</p> <ul> <li>Path constraints that must hold throughout the entire trajectory (not just at nodes)</li> <li>Obstacle avoidance where constraint violation between nodes could be catastrophic</li> <li>State limits that should be respected continuously (e.g., altitude &gt; 0 for aircraft)</li> <li>Ensuring smooth, feasible trajectories between discretization points</li> </ul> <p>Penalty functions (applied to constraint violations):</p> <ul> <li>squared_relu: Square(PositivePart(lhs)) - smooth, differentiable (default)</li> <li>huber: Huber(PositivePart(lhs)) - less sensitive to outliers than squared</li> <li>smooth_relu: SmoothReLU(lhs) - smooth approximation of ReLU</li> </ul> <p>Attributes:</p> Name Type Description <code>constraint</code> <p>The wrapped Constraint (typically Inequality) to enforce continuously</p> <code>penalty</code> <p>Penalty function type ('squared_relu', 'huber', or 'smooth_relu')</p> <code>nodes</code> <p>Optional (start, end) tuple specifying the interval for enforcement, or None to enforce over the entire trajectory</p> <code>idx</code> <p>Optional grouping index for managing multiple augmented states. CTCS constraints with the same idx and nodes are grouped together, sharing an augmented state. If None, auto-assigned based on node intervals.</p> <code>check_nodally</code> <p>Whether to also enforce the constraint at discrete nodes for additional numerical robustness (creates both continuous and nodal constraints)</p> Example"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS--single-augmented-state-default-behavior-same-node-interval","title":"Single augmented state (default behavior - same node interval)","text":"<p>altitude = State(\"alt\", shape=(1,)) constraints = [ ...     (altitude &gt;= 10).over((0, 10)),  # Both constraints share ...     (altitude &lt;= 1000).over((0, 10))  # one augmented state ... ]</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS--multiple-augmented-states-different-node-intervals","title":"Multiple augmented states (different node intervals)","text":"<p>constraints = [ ...     (altitude &gt;= 10).over((0, 5)),  # Creates _ctcs_aug_0 ...     (altitude &gt;= 20).over((5, 10))  # Creates _ctcs_aug_1 ... ]</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS--manual-grouping-with-idx-parameter","title":"Manual grouping with idx parameter","text":"<p>constraints = [ ...     (altitude &gt;= 10).over((0, 10), idx=0),    # Group 0 ...     (velocity &lt;= 100).over((0, 10), idx=1),   # Group 1 (separate state) ...     (altitude &lt;= 1000).over((0, 10), idx=0)   # Also group 0 ... ]</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS.canonicalize","title":"<code>canonicalize() -&gt; Expr</code>","text":"<p>Canonicalize the inner constraint while preserving CTCS parameters.</p> <p>Returns:</p> Name Type Description <code>CTCS</code> <code>Expr</code> <p>A new CTCS with canonicalized inner constraint and same parameters</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS.check_shape","title":"<code>check_shape() -&gt; Tuple[int, ...]</code>","text":"<p>Validate the constraint and penalty expression shapes.</p> <p>CTCS transforms the wrapped constraint into a penalty expression that is summed (integrated) over the trajectory, always producing a scalar result.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, ...]</code> <p>Empty tuple () representing scalar shape</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the wrapped constraint has invalid shape</p> <code>ValueError</code> <p>If the generated penalty expression is not scalar</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS.children","title":"<code>children()</code>","text":"<p>Return the wrapped constraint as the only child.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Single-element list containing the wrapped constraint</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS.over","title":"<code>over(interval: tuple[int, int]) -&gt; CTCS</code>","text":"<p>Set or update the continuous interval for this CTCS constraint.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>tuple[int, int]</code> <p>Tuple of (start, end) node indices defining the enforcement interval</p> required <p>Returns:</p> Name Type Description <code>CTCS</code> <code>CTCS</code> <p>New CTCS constraint with the specified interval</p> Example <p>constraint = (altitude &gt;= 10).over((0, 50))</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS.over--update-interval-to-cover-different-range","title":"Update interval to cover different range","text":"<p>constraint_updated = constraint.over((50, 100))</p>"},{"location":"Usage/api_constraints/#openscvx.symbolic.expr.constraint.CTCS.penalty_expr","title":"<code>penalty_expr() -&gt; Expr</code>","text":"<p>Build the penalty expression for this CTCS constraint.</p> <p>Transforms the constraint's left-hand side (in canonical form: lhs &lt;= 0) into a penalty expression using the specified penalty function. The penalty is zero when the constraint is satisfied and positive when violated.</p> <p>This penalty expression becomes part of the dynamics of an augmented state. Multiple CTCS constraints in the same group (same idx) have their penalties summed: ds_aug_i/dt = sum(penalty_j) for all j in group i. By constraining s_aug_i(t) = 0 for all t, we ensure all penalties in the group are zero, which strictly enforces all constraints in the group continuously.</p> <p>Returns:</p> Name Type Description <code>Expr</code> <code>Expr</code> <p>Sum of the penalty function applied to the constraint violation</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown penalty type is specified</p> Note <p>This method is used internally during problem compilation to create augmented state dynamics. Multiple penalty expressions with the same idx are summed together before being added to the dynamics vector via Concat.</p>"},{"location":"Usage/api_control/","title":"Control","text":"<p>Control represents control input variables (actuator commands) in a trajectory optimization problem. Unlike State variables which evolve according to dynamics, Controls are direct decision variables that the optimizer can freely adjust (within specified bounds) at each time step to influence the system dynamics.</p> <p>Controls support min/max bounds to enforce actuator limits and initial trajectory guesses to help the optimizer converge.</p>"},{"location":"Usage/api_control/#openscvx.symbolic.expr.control.Control","title":"<code>openscvx.symbolic.expr.control.Control</code>","text":"<p>               Bases: <code>Variable</code></p> <p>Control input variable for trajectory optimization problems.</p> <p>Control represents control input variables (actuator commands) in a trajectory optimization problem. Unlike State variables which evolve according to dynamics, Controls are direct decision variables that the optimizer can freely adjust (within specified bounds) at each time step to influence the system dynamics.</p> <p>Controls are conceptually similar to State variables but simpler - they don't have boundary conditions (initial/final specifications) since controls are typically not constrained at the endpoints. Like States, Controls support: - Min/max bounds to enforce actuator limits - Initial trajectory guesses to help the optimizer converge</p> <p>Common examples of control inputs include: - Thrust magnitude and direction for spacecraft/rockets - Throttle settings for engines - Steering angles for vehicles - Torques for robotic manipulators - Force/acceleration commands</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>Unique name identifier for this control variable</p> <code>_shape</code> <p>Shape of the control vector (typically 1D like (3,) for 3D thrust)</p> <code>_slice</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <p>Minimum bounds for each element of the control</p> <code>_max</code> <p>Maximum bounds for each element of the control</p> <code>_guess</code> <p>Initial guess for the control trajectory (n_points, n_controls)</p> Example"},{"location":"Usage/api_control/#openscvx.symbolic.expr.control.Control--scalar-throttle-control-bounded-0-1","title":"Scalar throttle control bounded [0, 1]","text":"<p>throttle = Control(\"throttle\", shape=(1,)) throttle.min = [0.0] throttle.max = [1.0] throttle.guess = np.full((50, 1), 0.5)  # Start at 50% throttle</p>"},{"location":"Usage/api_control/#openscvx.symbolic.expr.control.Control--3d-thrust-vector-for-spacecraft","title":"3D thrust vector for spacecraft","text":"<p>thrust = Control(\"thrust\", shape=(3,)) thrust.min = [-10, -10, 0]    # No downward thrust thrust.max = [10, 10, 50]     # Limited thrust thrust.guess = np.zeros((50, 3))  # Initialize with zero thrust</p>"},{"location":"Usage/api_control/#openscvx.symbolic.expr.control.Control--2d-steering-control-leftright-forwardbackward","title":"2D steering control (left/right, forward/backward)","text":"<p>steer = Control(\"steer\", shape=(2,)) steer.min = [-1, -1] steer.max = [1, 1] steer.guess = np.linspace([0, 0], [0, 1], 50)  # Gradual acceleration</p>"},{"location":"Usage/api_dynamics/","title":"Dynamics","text":""},{"location":"Usage/api_dynamics/#openscvx.dynamics.Dynamics","title":"<code>openscvx.dynamics.Dynamics</code>  <code>dataclass</code>","text":"<p>Dataclass to hold a system dynamics function and (optionally) its gradients. This class is intended to be instantiated using the <code>dynamics</code> decorator wrapped around a function defining the system dynamics. Both the dynamics and optional gradients should be composed of <code>jax</code> primitives to enable efficient computation.</p> <p>Usage examples:</p> <pre><code>@dynamics\ndef f(x_, u_):\n    return x_ + u_\n# f is now a Dynamics object\n</code></pre> <pre><code>@dynamics(A=grad_f_x, B=grad_f_u)\ndef f(x_, u_):\n    return x_ + u_\n</code></pre> <p>Or, if a more lambda-function-style is desired, the function can be directly wrapped:</p> <pre><code>dyn = dynamics(lambda x_, u_: x_ + u_)\n</code></pre> <p>Using Parameters in Dynamics</p> <p>You can use symbolic <code>Parameter</code> objects in your dynamics function to represent tunable or environment-dependent values. The argument names for parameters must match the parameter name with an underscore suffix (e.g., <code>I_sp_</code> for a parameter named <code>I_sp</code>). This is required for the parameter mapping to work correctly.</p> <p>Example (3DoF rocket landing):</p> <pre><code>from openscvx.backend.parameter import Parameter\nimport jax.numpy as jnp\n\nI_sp = Parameter(\"I_sp\")\ng = Parameter(\"g\")\ntheta = Parameter(\"theta\")\n\n@dynamics\ndef rocket_dynamics(x_, u_, I_sp_, g_, theta_):\n    m = x_[6]\n    T = u_\n    r_dot = x_[3:6]\n    g_vec = jnp.array([0, 0, g_])\n    v_dot = T/m - g_vec\n    m_dot = -jnp.linalg.norm(T) / (I_sp_ * 9.807 * jnp.cos(theta_))\n    t_dot = 1\n    return jnp.hstack([r_dot, v_dot, m_dot, t_dot])\n\n# Set parameter values before solving\nI_sp.value = 225\ng.value = 3.7114\ntheta.value = 27 * jnp.pi / 180\n</code></pre> <p>Using Parameters in Nodal Constraints</p> <p>You can also use symbolic <code>Parameter</code> objects in nodal constraints. As with dynamics, the argument names for parameters in the constraint function must match the parameter name with an underscore suffix (e.g., <code>g_</code> for a parameter named <code>g</code>).</p> <p>Example:</p> <pre><code>from openscvx.backend.parameter import Parameter\nfrom openscvx.constraints import nodal\nimport jax.numpy as jnp\n\ng = Parameter(\"g\")\ng.value = 3.7114\n\n@nodal\ndef terminal_velocity_constraint(x_, u_, g_):\n    # Enforce a terminal velocity constraint using the gravity parameter\n    return x_[5] + g_ * x_[7]  # e.g., vz + g * t &lt;= 0 at final node\n</code></pre> <p>When building your problem, collect all parameters with <code>Parameter.get_all()</code> and pass them to your problem setup.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray], ndarray]</code> <p>Function defining the continuous time nonlinear system dynamics as x_dot = f(x, u, ...params). - x: 1D array (state at a single node), shape (n_x,) - u: 1D array (control at a single node), shape (n_u,) - Additional parameters: passed as keyword arguments with names   matching the parameter name plus an underscore (e.g., g_ for   Parameter('g')). If you want to use parameters, include them as extra arguments with the underscore naming convention. If you use vectorized integration or batch evaluation, x and u may be 2D arrays (N, n_x) and (N, n_u).</p> required <code>A</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of <code>f</code> w.r.t. <code>x</code>. If not specified, will be calculated using <code>jax.jacfwd</code>.</p> <code>None</code> <code>B</code> <code>Optional[Callable[[ndarray, ndarray], ndarray]]</code> <p>Jacobian of <code>f</code> w.r.t. <code>u</code>. If not specified, will be calculated using <code>jax.jacfwd</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Dynamics</code> <p>A dataclass bundling the system dynamics function and</p> <p>Jacobians.</p>"},{"location":"Usage/api_integrators/","title":"Integrators","text":""},{"location":"Usage/api_integrators/#rk45integrator","title":"RK45Integrator","text":""},{"location":"Usage/api_integrators/#openscvx.integrators.solve_ivp_rk45","title":"<code>openscvx.integrators.solve_ivp_rk45(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, is_not_compiled: bool = False)</code>","text":"<p>Solve an initial-value ODE problem using fixed-step RK45 integration.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code>.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of output time points. Defaults to 50.</p> <code>50</code> <code>is_not_compiled</code> <code>bool</code> <p>If True, use Python loop instead of JAX <code>lax.fori_loop</code>. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Array of shape (num_substeps, state_dim) with solution at each time.</p>"},{"location":"Usage/api_integrators/#openscvx.integrators.rk45_step","title":"<code>openscvx.integrators.rk45_step(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], t: jnp.ndarray, y: jnp.ndarray, h: float, *args) -&gt; jnp.ndarray</code>","text":"<p>Perform a single RK45 (Runge-Kutta-Fehlberg) integration step.</p> <p>This implements the classic Dorman-Prince coefficients for an explicit 4(5) method, returning the fourth-order estimate.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>t</code> <code>ndarray</code> <p>Current time.</p> required <code>y</code> <code>ndarray</code> <p>Current state vector.</p> required <code>h</code> <code>float</code> <p>Step size.</p> required <code>*args</code> <p>Additional arguments passed to <code>f</code>.</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: Next state estimate at t + h.</p>"},{"location":"Usage/api_integrators/#diffrax-integrators","title":"Diffrax Integrators","text":""},{"location":"Usage/api_integrators/#openscvx.integrators.solve_ivp_diffrax","title":"<code>openscvx.integrators.solve_ivp_diffrax(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; f(t, y, *args).</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>solver_name</code> is not in SOLVER_MAP.</p>"},{"location":"Usage/api_integrators/#openscvx.integrators.solve_ivp_diffrax_prop","title":"<code>openscvx.integrators.solve_ivp_diffrax_prop(f: Callable[[jnp.ndarray, jnp.ndarray, Any], jnp.ndarray], tau_final: float, y_0: jnp.ndarray, args, tau_0: float = 0.0, num_substeps: int = 50, solver_name: str = 'Dopri8', rtol: float = 0.001, atol: float = 1e-06, extra_kwargs=None, save_time: jnp.ndarray = None, mask: jnp.ndarray = None)</code>","text":"<p>Solve an initial-value ODE problem using a Diffrax adaptive solver. This function is specifically designed for use in the context of trajectory optimization and handles the nonlinear single-shot propagation of state variables in undilated time.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[ndarray, ndarray, Any], ndarray]</code> <p>ODE right-hand side; signature f(t, y, *args) -&gt; dy/dt.</p> required <code>tau_final</code> <code>float</code> <p>Final integration time.</p> required <code>y_0</code> <code>ndarray</code> <p>Initial state at tau_0.</p> required <code>args</code> <code>tuple</code> <p>Extra arguments to pass to <code>f</code> in the solver term.</p> required <code>tau_0</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> <code>num_substeps</code> <code>int</code> <p>Number of save points between tau_0 and tau_final. Defaults to 50.</p> <code>50</code> <code>solver_name</code> <code>str</code> <p>Key into SOLVER_MAP for the Diffrax solver class. Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive stepping. Defaults to 1e-3.</p> <code>0.001</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive stepping. Defaults to 1e-6.</p> <code>1e-06</code> <code>extra_kwargs</code> <code>dict</code> <p>Additional keyword arguments forwarded to <code>diffeqsolve</code>.</p> <code>None</code> <code>save_time</code> <code>ndarray</code> <p>Time points at which to evaluate the solution. Must be provided for export compatibility.</p> <code>None</code> <code>mask</code> <code>ndarray</code> <p>Boolean mask for the save_time points.</p> <code>None</code> <p>Returns:</p> Type Description <p>jnp.ndarray: Solution states at the requested save points, shape (num_substeps, state_dim).</p> <p>Raises:     ValueError: If <code>solver_name</code> is not in SOLVER_MAP or if save_time is not provided.</p>"},{"location":"Usage/api_results/","title":"Optimization Results","text":""},{"location":"Usage/api_results/#openscvx.results.OptimizationResults","title":"<code>openscvx.results.OptimizationResults</code>  <code>dataclass</code>","text":"<p>Structured container for optimization results from the Successive Convexification (SCP) solver.</p> <p>This class provides a type-safe and organized way to store and access optimization results, replacing the previous dictionary-based approach. It includes core optimization data, iteration history for convergence analysis, post-processing results, and flexible storage for plotting and application-specific data.</p> <p>Attributes:</p> Name Type Description <code>converged</code> <code>bool</code> <p>Whether the optimization successfully converged</p> <code>t_final</code> <code>float</code> <p>Final time of the optimized trajectory</p> <code>u</code> <code>Control</code> <p>Optimized control trajectory at discretization nodes</p> <code>x</code> <code>State</code> <p>Optimized state trajectory at discretization nodes</p> <code>nodes</code> <code>dict[str, ndarray]</code> <p>Dictionary mapping state/control names to arrays at optimization nodes. Includes both user-defined and augmented variables.</p> <code>trajectory</code> <code>dict[str, ndarray]</code> <p>Dictionary mapping state/control names to arrays along the propagated trajectory. Added by post_process().</p> <code>x_history</code> <code>list[ndarray]</code> <p>State trajectories from each SCP iteration</p> <code>u_history</code> <code>list[ndarray]</code> <p>Control trajectories from each SCP iteration</p> <code>discretization_history</code> <code>list[ndarray]</code> <p>Time discretization from each iteration</p> <code>J_tr_history</code> <code>list[ndarray]</code> <p>Trust region cost history</p> <code>J_vb_history</code> <code>list[ndarray]</code> <p>Virtual buffer cost history</p> <code>J_vc_history</code> <code>list[ndarray]</code> <p>Virtual control cost history</p> <code>t_full</code> <code>Optional[ndarray]</code> <p>Full time grid for interpolated trajectory</p> <code>x_full</code> <code>Optional[ndarray]</code> <p>Interpolated state trajectory on full time grid</p> <code>u_full</code> <code>Optional[ndarray]</code> <p>Interpolated control trajectory on full time grid</p> <code>cost</code> <code>Optional[float]</code> <p>Total cost of the optimized trajectory</p> <code>ctcs_violation</code> <code>Optional[ndarray]</code> <p>Continuous-time constraint violations</p> <code>plotting_data</code> <code>dict[str, Any]</code> <p>Flexible storage for plotting and application data</p>"},{"location":"Usage/api_results/#openscvx.results.OptimizationResults.get","title":"<code>get(key: str, default: Any = None) -&gt; Any</code>","text":"<p>Get a value from the results, similar to dict.get().</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to look up</p> required <code>default</code> <code>Any</code> <p>Default value if key is not found</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The value associated with the key, or default if not found</p>"},{"location":"Usage/api_results/#openscvx.results.OptimizationResults.to_dict","title":"<code>to_dict() -&gt; dict[str, Any]</code>","text":"<p>Convert the results to a dictionary for backward compatibility.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary representation of the results</p>"},{"location":"Usage/api_results/#openscvx.results.OptimizationResults.update","title":"<code>update(other: dict[str, Any])</code>","text":"<p>Update the results with additional data from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>dict[str, Any]</code> <p>Dictionary containing additional data</p> required"},{"location":"Usage/api_results/#openscvx.results.OptimizationResults.update_plotting_data","title":"<code>update_plotting_data(**kwargs)</code>","text":"<p>Update the plotting data with additional information.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Key-value pairs to add to plotting_data</p> <code>{}</code>"},{"location":"Usage/api_state/","title":"State","text":"<p>State represents a dynamic state variable in a trajectory optimization problem. Unlike control inputs, states evolve according to dynamics constraints and can have boundary conditions specified at the initial and final time points. Like all Variables, States also support min/max bounds and initial trajectory guesses to help guide the optimization solver toward good solutions.</p>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State","title":"<code>openscvx.symbolic.expr.state.State</code>","text":"<p>               Bases: <code>Variable</code></p> <p>State variable with boundary conditions for trajectory optimization.</p> <p>State represents a dynamic state variable in a trajectory optimization problem. Unlike control inputs, states evolve according to dynamics constraints and can have boundary conditions specified at the initial and final time points. Like all Variables, States also support min/max bounds and initial trajectory guesses to help guide the optimization solver toward good solutions.</p> <p>States support four types of boundary conditions: - fixed: State value is constrained to a specific value - free: State value is optimized within the specified bounds - minimize: Adds a term to the objective function to minimize the state value - maximize: Adds a term to the objective function to maximize the state value</p> <p>Each element of a multi-dimensional state can have different boundary condition types, allowing for fine-grained control over the optimization.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>Unique name identifier for this state variable</p> <code>shape</code> <p>Shape of the state vector (typically 1D like (3,) for 3D position)</p> <code>min</code> <p>Minimum bounds for state variables</p> <code>max</code> <p>Maximum bounds for state variables</p> <code>guess</code> <p>Initial trajectory guess</p> <code>initial</code> <p>Initial state values with boundary condition types</p> <code>initial_type</code> <p>Array of boundary condition types for initial state</p> <code>final</code> <p>Final state values with boundary condition types</p> <code>final_type</code> <p>Array of boundary condition types for final state</p> Example"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State--scalar-time-state-with-free-initial-time-minimize-final-time","title":"Scalar time state with free initial time, minimize final time","text":"<p>time = State(\"time\", (1,)) time.min = [0.0] time.max = [10.0] time.initial = [(\"free\", 0.0)] time.final = [(\"minimize\", 5.0)]</p>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State--3d-position-state-with-mixed-boundary-conditions","title":"3D position state with mixed boundary conditions","text":"<p>pos = State(\"pos\", (3,)) pos.min = [0, 0, 10] pos.max = [10, 10, 200] pos.initial = [0, (\"free\", 1), 50]  # x fixed, y free, z fixed pos.final = [10, (\"free\", 5), (\"maximize\", 150)]  # Maximize final altitude</p>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State.final","title":"<code>final</code>  <code>property</code> <code>writable</code>","text":"<p>Get the final state boundary condition values.</p> <p>Returns:</p> Type Description <p>Array of final state values (regardless of boundary condition type),</p> <p>or None if not set.</p> Note <p>Use <code>final_type</code> to see the boundary condition types for each element.</p> Example <p>x = State(\"x\", (2,)) x.final = [10, (\"minimize\", 0)] print(x.final)  # [10. 0.] print(x.final_type)  # ['Fix' 'Minimize']</p>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State.initial","title":"<code>initial</code>  <code>property</code> <code>writable</code>","text":"<p>Get the initial state boundary condition values.</p> <p>Returns:</p> Type Description <p>Array of initial state values (regardless of boundary condition type),</p> <p>or None if not set.</p> Note <p>Use <code>initial_type</code> to see the boundary condition types for each element.</p> Example <p>x = State(\"x\", (2,)) x.initial = [0, (\"free\", 1)] print(x.initial)  # [0. 1.] print(x.initial_type)  # ['Fix' 'Free']</p>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State.max","title":"<code>max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the maximum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of maximum values for each state variable element.</p> Example <p>vel = State(\"vel\", (3,)) vel.max = [10, 10, 5] print(vel.max)  # [10. 10. 5.]</p>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State.min","title":"<code>min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the minimum bounds for the state variables.</p> <p>Returns:</p> Type Description <p>Array of minimum values for each state variable element.</p> Example <p>pos = State(\"pos\", (3,)) pos.min = [0, 0, 10] print(pos.min)  # [0. 0. 10.]</p>"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.State._check_bounds_against_initial_final","title":"<code>_check_bounds_against_initial_final()</code>","text":"<p>Validate that fixed boundary conditions respect min/max bounds.</p> <p>This internal method is automatically called when bounds or boundary conditions are set to ensure consistency.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any fixed initial or final value violates the min/max bounds</p>"},{"location":"Usage/api_state/#boundary-conditions","title":"Boundary Conditions","text":"<p>States support four types of boundary conditions at initial and final time points. Each element of a multi-dimensional state can have different boundary condition types. Boundary conditions are specified using either a simple number (defaults to \"fixed\") or a tuple of (type, value).</p>"},{"location":"Usage/api_state/#boundarytype-enum","title":"BoundaryType Enum","text":""},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.BoundaryType","title":"<code>openscvx.symbolic.expr.state.BoundaryType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of boundary condition types for state variables.</p> <p>This enum allows users to specify boundary conditions using plain strings while maintaining type safety internally. Boundary conditions control how the optimizer handles initial and final state values.</p> <p>Attributes:</p> Name Type Description <code>FIXED</code> <p>State value is fixed to a specific value</p> <code>FREE</code> <p>State value is free to be optimized within bounds</p> <code>MINIMIZE</code> <p>Objective term to minimize the state value</p> <code>MAXIMIZE</code> <p>Objective term to maximize the state value</p> Example"},{"location":"Usage/api_state/#openscvx.symbolic.expr.state.BoundaryType--can-use-either-enum-or-string","title":"Can use either enum or string","text":"<p>BoundaryType.FIXED \"fixed\"  # Equivalent</p>"},{"location":"Usage/api_state/#boundary-condition-types","title":"Boundary Condition Types","text":"<ul> <li>fixed: State value is constrained to a specific value (use plain number or tuple <code>(\"fixed\", value)</code>)</li> <li>free: State value is optimized within bounds, initialized at the given value (use tuple <code>(\"free\", value)</code>)</li> <li>minimize: Adds objective term to minimize the state value (use tuple <code>(\"minimize\", value)</code>)</li> <li>maximize: Adds objective term to maximize the state value (use tuple <code>(\"maximize\", value)</code>)</li> </ul>"},{"location":"Usage/api_trajoptproblem/","title":"TrajOptProblem","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.trajoptproblem.TrajOptProblem.__init__","title":"<code>openscvx.trajoptproblem.TrajOptProblem.__init__(dynamics: dict, constraints: List[Union[Constraint, CTCS]], states: List[State], controls: List[Control], N: int, time: Time, dynamics_prop: Optional[dict] = None, states_prop: Optional[List[State]] = None, scp: Optional[ScpConfig] = None, dis: Optional[DiscretizationConfig] = None, prp: Optional[PropagationConfig] = None, sim: Optional[SimConfig] = None, dev: Optional[DevConfig] = None, cvx: Optional[ConvexSolverConfig] = None, licq_min=0.0, licq_max=0.0001, time_dilation_factor_min=0.3, time_dilation_factor_max=3.0)</code>","text":"<p>The primary class in charge of compiling and exporting the solvers</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>dict</code> <p>Dictionary mapping state names to their dynamics expressions. Each key should be a state name, and each value should be an Expr representing the derivative of that state.</p> required <code>constraints</code> <code>List[Union[CTCSConstraint, NodalConstraint]]</code> <p>List of constraints decorated with @ctcs or @nodal</p> required <code>states</code> <code>List[State]</code> <p>List of State objects representing the state variables. May optionally include a State named \"time\" (see time parameter below).</p> required <code>controls</code> <code>List[Control]</code> <p>List of Control objects representing the control variables</p> required <code>N</code> <code>int</code> <p>Number of segments in the trajectory</p> required <code>time</code> <code>Time</code> <p>Time configuration object with initial, final, min, max. Required. If including a \"time\" state in states, the Time object will be ignored and time properties should be set on the time State object instead.</p> required <code>dynamics_prop</code> <code>dict</code> <p>Dictionary mapping EXTRA state names to their dynamics expressions for propagation. Only specify additional states beyond optimization states (e.g., {\"distance\": speed}). Do NOT duplicate optimization state dynamics here.</p> <code>None</code> <code>states_prop</code> <code>List[State]</code> <p>List of EXTRA State objects for propagation only. Only specify additional states beyond optimization states. Used with dynamics_prop.</p> <code>None</code> <code>scp</code> <code>Optional[ScpConfig]</code> <p>SCP configuration object</p> <code>None</code> <code>dis</code> <code>Optional[DiscretizationConfig]</code> <p>Discretization configuration object</p> <code>None</code> <code>prp</code> <code>Optional[PropagationConfig]</code> <p>Propagation configuration object</p> <code>None</code> <code>sim</code> <code>Optional[SimConfig]</code> <p>Simulation configuration object</p> <code>None</code> <code>dev</code> <code>Optional[DevConfig]</code> <p>Development configuration object</p> <code>None</code> <code>cvx</code> <code>Optional[ConvexSolverConfig]</code> <p>Convex solver configuration object</p> <code>None</code> <code>licq_min</code> <p>Minimum LICQ constraint value</p> <code>0.0</code> <code>licq_max</code> <p>Maximum LICQ constraint value</p> <code>0.0001</code> <code>time_dilation_factor_min</code> <p>Minimum time dilation factor</p> <code>0.3</code> <code>time_dilation_factor_max</code> <p>Maximum time dilation factor</p> <code>3.0</code> <p>Returns:</p> Type Description <p>None</p> Note <p>There are two approaches for handling time: 1. Auto-create (simple): Don't include \"time\" in states, provide Time object 2. User-provided (for time-dependent constraints): Include \"time\" State in states and    in dynamics dict, don't provide Time object</p>"},{"location":"Usage/api_trajoptproblem/#scpconfig","title":"ScpConfig","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.config.ScpConfig.__init__","title":"<code>openscvx.config.ScpConfig.__init__(n: Optional[int] = None, k_max: int = 200, w_tr: float = 1.0, lam_vc: float = 1.0, ep_tr: float = 0.0001, ep_vb: float = 0.0001, ep_vc: float = 1e-08, lam_cost: float = 0.0, lam_vb: float = 0.0, uniform_time_grid: bool = False, cost_drop: int = -1, cost_relax: float = 1.0, w_tr_adapt: float = 1.0, w_tr_max: Optional[float] = None, w_tr_max_scaling_factor: Optional[float] = None)</code>","text":"<p>Configuration class for Sequential Convex Programming (SCP).</p> <p>This class defines the parameters used to configure the SCP solver. You will very likely need to modify the weights for your problem. Please refer to my guide here for more information.</p> <p>Attributes:</p> Name Type Description <code>n</code> <code>int</code> <p>The number of discretization nodes. Defaults to <code>None</code>.</p> <code>k_max</code> <code>int</code> <p>The maximum number of SCP iterations. Defaults to 200.</p> <code>w_tr</code> <code>float</code> <p>The trust region weight. Defaults to 1.0.</p> <code>lam_vc</code> <code>float</code> <p>The penalty weight for virtual control. Defaults to 1.0.</p> <code>ep_tr</code> <code>float</code> <p>The trust region convergence tolerance. Defaults to 1e-4.</p> <code>ep_vb</code> <code>float</code> <p>The boundary constraint convergence tolerance. Defaults to 1e-4.</p> <code>ep_vc</code> <code>float</code> <p>The virtual constraint convergence tolerance. Defaults to 1e-8.</p> <code>lam_cost</code> <code>float</code> <p>The weight for original cost. Defaults to 0.0.</p> <code>lam_vb</code> <code>float</code> <p>The weight for virtual buffer. This is only used if there are nonconvex nodal constraints present. Defaults to 0.0.</p> <code>uniform_time_grid</code> <code>bool</code> <p>Whether to use a uniform time grid. Defaults to <code>False</code>.</p> <code>cost_drop</code> <code>int</code> <p>The number of iterations to allow for cost stagnation before termination. Defaults to -1 (disabled).</p> <code>cost_relax</code> <code>float</code> <p>The relaxation factor for cost reduction. Defaults to 1.0.</p> <code>w_tr_adapt</code> <code>float</code> <p>The adaptation factor for the trust region weight. Defaults to 1.0.</p> <code>w_tr_max</code> <code>float</code> <p>The maximum allowable trust region weight. Defaults to <code>None</code>.</p> <code>w_tr_max_scaling_factor</code> <code>float</code> <p>The scaling factor for the maximum trust region weight. Defaults to <code>None</code>.</p>"},{"location":"Usage/api_trajoptproblem/#discretizationconfig","title":"DiscretizationConfig","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.config.DiscretizationConfig.__init__","title":"<code>openscvx.config.DiscretizationConfig.__init__(dis_type: str = 'FOH', custom_integrator: bool = False, solver: str = 'Tsit5', args: Optional[dict] = None, atol: float = 0.001, rtol: float = 1e-06)</code>","text":"<p>Configuration class for discretization settings.</p> <p>This class defines the parameters required for discretizing system dynamics.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>dis_type</code> <code>str</code> <p>The type of discretization to use (e.g., \"FOH\" for First-Order Hold). Defaults to \"FOH\".</p> <code>'FOH'</code> <code>custom_integrator</code> <code>bool</code> <p>This enables our custom fixed-step RK45 algorithm. This tends to be faster than Diffrax but unless you're going for speed, it's recommended to stick with Diffrax for robustness and other solver options. Defaults to False.</p> <code>False</code> <code>solver</code> <code>str</code> <p>Not used if custom_integrator is enabled. Any choice of solver in Diffrax is valid, please refer here, How to Choose a Solver. Defaults to \"Tsit5\".</p> <code>'Tsit5'</code> <p>Other arguments: These arguments are less frequently used, and for most purposes you shouldn't need to understand these.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Dict</code> <p>Additional arguments to pass to the solver which can be found here. Defaults to an empty dictionary.</p> <code>None</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for the solver. Defaults to 1e-3.</p> <code>0.001</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for the solver. Defaults to 1e-6.</p> <code>1e-06</code>"},{"location":"Usage/api_trajoptproblem/#propagationconfig","title":"PropagationConfig","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.config.PropagationConfig.__init__","title":"<code>openscvx.config.PropagationConfig.__init__(inter_sample: int = 30, dt: float = 0.01, solver: str = 'Dopri8', max_tau_len: int = 1000, args: Optional[dict] = None, atol: float = 0.001, rtol: float = 1e-06)</code>","text":"<p>Configuration class for propagation settings.</p> <p>This class defines the parameters required for propagating the nonlinear system dynamics using the optimal control sequence.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Other arguments: The solver should likely not be changed as it is a high accuracy 8th-order Runge-Kutta method.</p> <p>Parameters:</p> Name Type Description Default <code>inter_sample</code> <code>int</code> <p>How dense the propagation within multishot discretization should be. Defaults to 30.</p> <code>30</code> <code>dt</code> <code>float</code> <p>The time step for propagation. Defaults to 0.1.</p> <code>0.01</code> <code>solver</code> <code>str</code> <p>The numerical solver to use for propagation (e.g., \"Dopri8\"). Defaults to \"Dopri8\".</p> <code>'Dopri8'</code> <code>max_tau_len</code> <code>int</code> <p>The maximum length of the time vector for propagation. Defaults to 1000.</p> <code>1000</code> <code>args</code> <code>Dict</code> <p>Additional arguments to pass to the solver. Defaults to an empty dictionary.</p> <code>None</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for the solver. Defaults to 1e-3.</p> <code>0.001</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for the solver. Defaults to 1e-6.</p> <code>1e-06</code>"},{"location":"Usage/api_trajoptproblem/#simconfig","title":"SimConfig","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.config.SimConfig.__init__","title":"<code>openscvx.config.SimConfig.__init__(x: UnifiedState, x_prop: UnifiedState, u: UnifiedControl, total_time: float, save_compiled: bool = False, ctcs_node_intervals: Optional[list] = None, constraints_ctcs: Optional[list[Callable]] = None, constraints_nodal: Optional[list[Callable]] = None, constraints_nodal_convex: Optional[list[Callable]] = None, n_states: Optional[int] = None, n_states_prop: Optional[int] = None, n_controls: Optional[int] = None, scaling_x_overrides: Optional[list] = None, scaling_u_overrides: Optional[list] = None)</code>","text":"<p>Configuration class for simulation settings.</p> <p>This class defines the parameters required for simulating a trajectory optimization problem.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>State</code> <p>State object, must have .min and .max attributes for bounds.</p> required <code>x_prop</code> <code>State</code> <p>Propagation state object, must have .min and .max attributes for bounds.</p> required <code>u</code> <code>Control</code> <p>Control object, must have .min and .max attributes for bounds.</p> required <code>total_time</code> <code>float</code> <p>The total simulation time.</p> required <code>idx_x_true</code> <code>slice</code> <p>Slice for true state indices.</p> required <code>idx_x_true_prop</code> <code>slice</code> <p>Slice for true propagation state indices.</p> required <code>idx_u_true</code> <code>slice</code> <p>Slice for true control indices.</p> required <code>idx_t</code> <code>slice</code> <p>Slice for time index.</p> required <code>idx_y</code> <code>slice</code> <p>Slice for constraint violation indices.</p> required <code>idx_y_prop</code> <code>slice</code> <p>Slice for propagation constraint violation indices.</p> required <code>idx_s</code> <code>slice</code> <p>Slice for time dilation index.</p> required <code>save_compiled</code> <code>bool</code> <p>If True, save and reuse compiled solver functions. Defaults to False.</p> <code>False</code> <code>ctcs_node_intervals</code> <code>list</code> <p>Node intervals for CTCS constraints.</p> <code>None</code> <code>constraints_ctcs</code> <code>list</code> <p>List of CTCS constraints.</p> <code>None</code> <code>constraints_nodal</code> <code>list</code> <p>List of nodal constraints.</p> <code>None</code> <code>constraints_nodal_convex</code> <code>list</code> <p>List of convex nodal constraints.</p> <code>None</code> <code>n_states</code> <code>int</code> <p>The number of state variables. Defaults to <code>None</code> (inferred from x.max).</p> <code>None</code> <code>n_states_prop</code> <code>int</code> <p>The number of propagation state variables. Defaults to <code>None</code> (inferred from x_prop.max).</p> <code>None</code> <code>n_controls</code> <code>int</code> <p>The number of control variables. Defaults to <code>None</code> (inferred from u.max).</p> <code>None</code> <code>scaling_x_overrides</code> <code>list</code> <p>List of (upper_bound, lower_bound, idx) for custom state scaling. Each can be scalar or array, idx can be int, list, or slice.</p> <code>None</code> <code>scaling_u_overrides</code> <code>list</code> <p>List of (upper_bound, lower_bound, idx) for custom control scaling. Each can be scalar or array, idx can be int, list, or slice.</p> <code>None</code> Note <p>You can specify custom scaling for specific states/controls using scaling_x_overrides and scaling_u_overrides. Any indices not covered by overrides will use the default min/max bounds.</p>"},{"location":"Usage/api_trajoptproblem/#convexsolverconfig","title":"ConvexSolverConfig","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.config.ConvexSolverConfig.__init__","title":"<code>openscvx.config.ConvexSolverConfig.__init__(solver: str = 'QOCO', solver_args: Optional[dict] = None, cvxpygen: bool = False, cvxpygen_override: bool = False)</code>","text":"<p>Configuration class for convex solver settings.</p> <p>This class defines the parameters required for configuring a convex solver.</p> <p>These are the arguments most commonly used day-to-day. Generally I have found QOCO to be the most performant of the CVXPY solvers for these types of problems (I do have a bias as the author is from my group) and can handle up to SOCP's. CLARABEL is also a great option with feasibility checking and can handle a few more problem types. CVXPYGen is also great if your problem isn't too large. I have found qocogen to be the most performant of the CVXPYGen solvers.</p> <p>Parameters:</p> Name Type Description Default <code>solver</code> <code>str</code> <p>The name of the CVXPY solver to use. A list of options can be found here. Defaults to \"QOCO\".</p> <code>'QOCO'</code> <code>solver_args</code> <code>dict</code> <p>Ensure you are using the correct arguments for your solver as they are not all common. Additional arguments to configure the solver, such as tolerances. Defaults to {\"abstol\": 1e-6, \"reltol\": 1e-9}.</p> <code>None</code> <code>cvxpygen</code> <code>bool</code> <p>Whether to enable CVXPY code generation for the solver. Defaults to False.</p> <code>False</code>"},{"location":"Usage/api_trajoptproblem/#devconfig","title":"DevConfig","text":""},{"location":"Usage/api_trajoptproblem/#openscvx.config.DevConfig.__init__","title":"<code>openscvx.config.DevConfig.__init__(profiling: bool = False, debug: bool = False, printing: bool = True)</code>","text":"<p>Configuration class for development settings.</p> <p>This class defines the parameters used for development and debugging purposes.</p> <p>Main arguments: These are the arguments most commonly used day-to-day.</p> <p>Parameters:</p> Name Type Description Default <code>profiling</code> <code>bool</code> <p>Whether to enable profiling for performance analysis. Defaults to False.</p> <code>False</code> <code>debug</code> <code>bool</code> <p>Disables all precompilation so you can place breakpoints and inspect values. Defaults to False.</p> <code>False</code> <code>printing</code> <code>bool</code> <p>Whether to enable printing during development. Defaults to True.</p> <code>True</code>"},{"location":"Usage/api_variable/","title":"Variable","text":""},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable","title":"<code>openscvx.symbolic.expr.variable.Variable</code>","text":"<p>               Bases: <code>Leaf</code></p> <p>Base class for decision variables in optimization problems.</p> <p>Variable represents decision variables (free parameters) in an optimization problem. These are values that the optimizer can adjust to minimize the objective function while satisfying constraints. Variables can have bounds (min/max) and initial guesses to guide the optimization process.</p> <p>Unlike Parameters (which are fixed values that can be changed between solves), Variables are optimized by the solver. In trajectory optimization, Variables typically represent discretized state or control trajectories.</p> Note <p>Variable is typically not instantiated directly. Instead, use the specialized subclasses State (for state variables with boundary conditions) or Control (for control inputs). These provide additional functionality specific to trajectory optimization.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>Name identifier for the variable</p> <code>_shape</code> <p>Shape of the variable as a tuple (typically 1D)</p> <code>_slice</code> <p>Internal slice information for variable indexing</p> <code>_min</code> <p>Minimum bounds for each element of the variable</p> <code>_max</code> <p>Maximum bounds for each element of the variable</p> <code>_guess</code> <p>Initial guess for the variable trajectory (n_points, n_vars)</p> Example"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable--typically-use-state-or-control-instead-of-variable-directly","title":"Typically, use State or Control instead of Variable directly:","text":"<p>pos = openscvx.State(\"pos\", shape=(3,)) u = openscvx.Control(\"u\", shape=(2,))</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.guess","title":"<code>guess</code>  <code>property</code> <code>writable</code>","text":"<p>Get the initial guess for the variable trajectory.</p> <p>The guess provides a starting point for the optimizer. A good initial guess can significantly improve convergence speed and help avoid local minima.</p> <p>Returns:</p> Type Description <p>2D array of shape (n_points, n_vars) representing the variable trajectory</p> <p>over time, or None if no guess is provided.</p> Example <p>x = Variable(\"x\", shape=(2,))</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.guess--linear-interpolation-from-00-to-1010-over-50-points","title":"Linear interpolation from [0,0] to [10,10] over 50 points","text":"<p>x.guess = np.linspace([0, 0], [10, 10], 50) print(x.guess.shape)  # (50, 2)</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.max","title":"<code>max</code>  <code>property</code> <code>writable</code>","text":"<p>Get the maximum bounds (upper bounds) for the variable.</p> <p>Returns:</p> Type Description <p>Array of maximum values for each element of the variable, or None if unbounded.</p> Example <p>vel = Variable(\"vel\", shape=(3,)) vel.max = [10, 10, 5] print(vel.max)  # [10., 10., 5.]</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.min","title":"<code>min</code>  <code>property</code> <code>writable</code>","text":"<p>Get the minimum bounds (lower bounds) for the variable.</p> <p>Returns:</p> Type Description <p>Array of minimum values for each element of the variable, or None if unbounded.</p> Example <p>pos = Variable(\"pos\", shape=(3,)) pos.min = [-10, -10, 0] print(pos.min)  # [-10., -10., 0.]</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.append","title":"<code>append(other=None, *, min=-np.inf, max=np.inf, guess=0.0)</code>","text":"<p>Append a new dimension to this variable or merge with another variable.</p> <p>This method extends the variable's dimension by either: 1. Appending another Variable object (concatenating their dimensions) 2. Adding a single new scalar dimension with specified bounds and guess</p> <p>The bounds and guesses of both variables are concatenated appropriately.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>Another Variable object to append. If None, adds a single scalar dimension with the specified min/max/guess values.</p> <code>None</code> <code>min</code> <p>Minimum bound for the new dimension (only used if other is None). Defaults to -np.inf (unbounded below).</p> <code>-inf</code> <code>max</code> <p>Maximum bound for the new dimension (only used if other is None). Defaults to np.inf (unbounded above).</p> <code>inf</code> <code>guess</code> <p>Initial guess value for the new dimension (only used if other is None). Defaults to 0.0.</p> <code>0.0</code> Example"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.append--create-a-2d-variable-and-extend-it-to-3d","title":"Create a 2D variable and extend it to 3D","text":"<p>pos_xy = Variable(\"pos\", shape=(2,)) pos_xy.min = [-10, -10] pos_xy.max = [10, 10] pos_xy.append(min=0, max=100)  # Add z dimension print(pos_xy.shape)  # (3,) print(pos_xy.min)  # [-10., -10., 0.] print(pos_xy.max)  # [10., 10., 100.]</p>"},{"location":"Usage/api_variable/#openscvx.symbolic.expr.variable.Variable.append--merge-two-variables","title":"Merge two variables","text":"<p>pos = Variable(\"pos\", shape=(3,)) vel = Variable(\"vel\", shape=(3,)) pos.append(vel)  # Now pos has shape (6,)</p>"},{"location":"Usage/basic_problem_setup/","title":"Basic Problem Setup","text":"<p>Here we will cover all the necessary elements to setup your problem along with some tips and best practices to get the most out of the package.</p>"},{"location":"Usage/basic_problem_setup/#imports","title":"Imports","text":"<p>First, import OpenSCvx:</p> <pre><code>import numpy as np\nimport jax.numpy as jnp\nimport openscvx as ox\nfrom openscvx import TrajOptProblem\n</code></pre>"},{"location":"Usage/basic_problem_setup/#state-specification","title":"State Specification","text":"<p>States are defined as individual symbolic variables. Each state component gets its own <code>ox.State</code> object:</p> <pre><code># Create state variables\nposition = ox.State(\"position\", shape=(3,))\nvelocity = ox.State(\"velocity\", shape=(3,))\n\n# Set bounds for each state\nposition.min = np.array([-10, -10, 0])\nposition.max = np.array([10, 10, 20])\n\nvelocity.min = np.array([-5, -5, -5])\nvelocity.max = np.array([5, 5, 5])\n\n# Set initial conditions\nposition.initial = np.array([0, 0, 1])\nvelocity.initial = np.array([0, 0, 0])\n\n# Set final conditions (can use tuples for free/minimize/maximize)\nposition.final = np.array([5, 5, 1])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Set initial guess for SCP (shape: (n_nodes, state_shape))\nposition.guess = np.linspace(position.initial, position.final, n_nodes)\nvelocity.guess = np.zeros((n_nodes, 3))\n\n# Collect all states into a list\nstates = [position, velocity]\n</code></pre> <p>The boundary condition options use tuple syntax:</p> <ul> <li>Fixed value: <code>value</code> or <code>(\"fixed\", value)</code></li> <li>Free variable: <code>(\"free\", guess)</code> - Can be optimized within bounds</li> <li>Minimize: <code>(\"minimize\", guess)</code> - Variable to be minimized</li> <li>Maximize: <code>(\"maximize\", guess)</code> - Variable to be maximized</li> </ul>"},{"location":"Usage/basic_problem_setup/#control-specification","title":"Control Specification","text":"<p>Controls are also defined as individual symbolic variables:</p> <pre><code># Create control variables\nthrust = ox.Control(\"thrust\", shape=(3,))\n\n# Set bounds\nthrust.min = np.array([0, 0, 0])\nthrust.max = np.array([10, 10, 10])\n\n# Set initial guess for SCP (shape: (n_nodes, control_shape))\nthrust.guess = np.repeat(\n    np.expand_dims(np.array([0, 0, 5]), axis=0),\n    n_nodes, axis=0\n)\n\n# Collect all controls into a list\ncontrols = [thrust]\n</code></pre>"},{"location":"Usage/basic_problem_setup/#dynamics","title":"Dynamics","text":"<p>Dynamics are defined as a dictionary mapping state names to their time derivatives using symbolic expressions:</p> <pre><code># Physical parameters\nm = 1.0  # Mass\ng = -9.81  # Gravity\n\n# Define dynamics using symbolic expressions\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": thrust / m + np.array([0, 0, g]),\n}\n</code></pre> <p>The symbolic expressions support standard Python operators: - Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code> - Matrix multiplication: <code>@</code> - Comparisons: <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code> - Indexing: <code>[...]</code> - Transpose: <code>.T</code></p> <p>Common symbolic functions include: - <code>ox.linalg.Norm()</code>: Vector/matrix norms - <code>ox.linalg.Diag()</code>: Diagonal matrices - <code>ox.spatial.QDCM()</code>: Quaternion to DCM - <code>ox.spatial.SSM()</code>: Skew-symmetric matrix - <code>ox.spatial.SSMP()</code>: Skew-symmetric matrix product</p> <p>Note</p> <p>Under the hood, symbolic expressions are compiled using JAX, so use <code>jax.numpy</code> for numerical constants and functions when needed.</p>"},{"location":"Usage/basic_problem_setup/#time-definition","title":"Time Definition","text":"<p>Define a <code>Time</code> object:</p> <pre><code># Fixed time horizon\ntime = ox.Time(\n    initial=0.0,\n    final=10.0,\n    min=0.0,\n    max=10.0,\n)\n\n# Minimum time problem\ntime = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", 10.0),  # Minimize final time with initial guess of 10.0\n    min=0.0,\n    max=20.0,\n)\n</code></pre>"},{"location":"Usage/basic_problem_setup/#costs","title":"Costs","text":"<p>You can choose states to minimize or maximize using the tuple syntax in boundary conditions:</p> <pre><code># Minimize a state component at the final time\nenergy = ox.State(\"energy\", shape=())\nenergy.final = (\"minimize\", 0.0)\n\n# Maximize a state component\nreward = ox.State(\"reward\", shape=())\nreward.final = (\"maximize\", 100.0)\n</code></pre>"},{"location":"Usage/basic_problem_setup/#constraints","title":"Constraints","text":"<p>Constraints are created using symbolic expressions with comparison operators.</p>"},{"location":"Usage/basic_problem_setup/#continuous-constraints","title":"Continuous Constraints","text":"<p>Continuous constraints are enforced over time intervals using <code>ox.ctcs()</code>:</p> <pre><code># Box constraints on states\nconstraints = []\nfor state in states:\n    constraints.extend([\n        ox.ctcs(state &lt;= state.max),\n        ox.ctcs(state.min &lt;= state)\n    ])\n\n# Custom path constraints\nmax_speed = 10.0\nconstraints.append(ox.ctcs(ox.linalg.Norm(velocity) &lt;= max_speed))\n\n# Obstacle avoidance (distance &gt;= safe_distance)\nobstacle_center = ox.Parameter(\"obs_center\", shape=(3,), value=np.array([5, 5, 5]))\nsafe_distance = 2.0\ndiff = position - obstacle_center\nconstraints.append(ox.ctcs(diff.T @ diff &gt;= safe_distance**2))\n</code></pre>"},{"location":"Usage/basic_problem_setup/#discrete-constraints","title":"Discrete Constraints","text":"<p>Discrete constraints are enforced at specific nodes using the <code>.at()</code> method:</p> <pre><code># Waypoint constraint at node 10\ntarget = np.array([5, 5, 5])\nconstraints.append(\n    (position == target).at([10])\n)\n\n# Constraint at multiple nodes\nconstraints.append(\n    (ox.linalg.Norm(velocity) &lt;= 1.0).at([0, 5, 10])\n)\n\n# Convex constraints can be marked for better performance\nconstraints.append(\n    (position[2] &gt;= 0).convex().at([15])\n)\n</code></pre>"},{"location":"Usage/basic_problem_setup/#parameters","title":"Parameters","text":"<p>Parameters allow values to be updated at runtime without recompiling:</p> <pre><code># Create parameters\nobs_center = ox.Parameter(\"obs_center\", shape=(3,), value=np.array([1.0, 2.0, 3.0]))\nobs_radius = ox.Parameter(\"obs_radius\", shape=(), value=0.5)\n\n# Use in constraints\ndiff = position - obs_center\nconstraints.append(\n    ox.ctcs(diff.T @ diff &gt;= obs_radius**2)\n)\n\n# Update parameter values later\n# problem.parameters[\"obs_center\"] = new_center_value\n</code></pre>"},{"location":"Usage/basic_problem_setup/#initial-guess","title":"Initial Guess","text":"<p>While not strictly necessary for the initial guess to be dynamically feasible or satisfy constraints, a good guess helps the solver converge faster and avoid local minima.</p> <p>For state trajectories, linear interpolation is a good starting point:</p> <pre><code>position.guess = np.linspace(position.initial, position.final, n_nodes)\nvelocity.guess = np.zeros((n_nodes, 3))\n</code></pre> <p>For control trajectories, use constant values:</p> <pre><code>thrust.guess = np.repeat(\n    np.expand_dims(np.array([0, 0, 5]), axis=0),\n    n_nodes, axis=0\n)\n</code></pre>"},{"location":"Usage/basic_problem_setup/#problem-instantiation","title":"Problem Instantiation","text":"<p>Instantiate the problem with all components:</p> <pre><code>problem = TrajOptProblem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n_nodes,\n)\n</code></pre>"},{"location":"Usage/basic_problem_setup/#configure-scp-weights","title":"Configure SCP Weights","text":"<p>The weights are used to scale the cost, trust region, and dynamic feasibility. A good place to start is to set <code>lam_cost = 0</code>, <code>lam_vc = 1E1</code> and <code>w_tr = 1E0</code>. Then you can slowly increase the cost weight and decrease the trust region weight until you find a good balance.</p> <pre><code>problem.settings.scp.w_tr = 1E0      # Weight on the Trust Region\nproblem.settings.scp.lam_cost = 0E0  # Weight on the Cost\nproblem.settings.scp.lam_vc = 1E1    # Weight on the Virtual Control Objective\n</code></pre> <p>If you have nonconvex nodal constraints then you will also need to include <code>problem.settings.scp.lam_vb = 1E0</code>.</p>"},{"location":"Usage/basic_problem_setup/#running-the-problem","title":"Running the Problem","text":"<p>To solve the trajectory optimization problem:</p> <ol> <li> <p>Initialize the problem:    <pre><code>problem.initialize()\n</code></pre></p> </li> <li> <p>Solve the problem:    <pre><code>results = problem.solve()\n</code></pre></p> </li> <li> <p>Post-process the solution:    <pre><code>results = problem.post_process(results)\n</code></pre></p> </li> <li> <p>Access the solution:    <pre><code># Extract state and control trajectories\nposition_trajectory = results[\"position\"]\nvelocity_trajectory = results[\"velocity\"]\nthrust_trajectory = results[\"thrust\"]\ntime_vector = results[\"time\"]\n</code></pre></p> </li> </ol>"},{"location":"Usage/tutorial_6dof_los_guidance/","title":"6DoF Line-of-Sight Guidance","text":"<p>Awesome! Now that we have a basic understanding of how to use OpenSCvx, let's solve a more complex problem. In this example we will be solving a 6DoF line-of-sight guidance problem. This example comes from a RA-L paper of mine which you can find here. The problem is more complex than the previous example, but demonstrates the power of OpenSCvx's symbolic expression layer.</p> <p>In this problem, it is still a minimum time problem, but now there are 10 gates in which the drone must pass through in a predefined sequence while maintaining a line-of-sight to several key points throughout the entire trajectory. The problem can be expressed as follows:</p> \\[ \\begin{align} \\min_{x,u, t}\\ &amp;t_f, \\\\ \\mathrm{s.t.}\\ &amp;\\dot{x}(t) = f(t, x(t),u(t)) &amp; \\forall t\\in[t_i, t_f], \\\\ &amp; \\lVert A_{\\mathrm{cone}} C(q_{\\mathcal{S}\\to\\mathcal{B}})C(q_{\\mathcal{B}\\to\\mathcal{I}}(t))(r^{\\mathrm{kp},i}_{\\mathcal{I}} - r_{\\mathcal{I}}(t))\\rVert_\\rho - c^\\top C(q_{\\mathcal{S}\\to\\mathcal{B}})C(q_{\\mathcal{B}\\to\\mathcal{I}}(t))(r^{\\mathrm{kp}, i}_{\\mathcal{I}} - r_{\\mathcal{I}}(t)) \\leq 0 &amp; \\forall i \\in [0, N_\\mathrm{kp}], \\forall t\\in[t_i, t_f],\\\\ &amp; \\lVert A_{\\mathrm{gate}} (r(t_i) - r^{i}_{\\mathrm{gate}})\\rVert_\\infty \\leq 1 &amp; \\forall i\\in[0, N_\\mathrm{gates}],\\\\ &amp; x(t) \\leq x_{\\mathrm{max}}, x(t) \\geq x_{\\mathrm{min}} &amp; \\forall t\\in[t_i, t_f],\\\\ &amp; u(t) \\leq u_{\\mathrm{max}}, u(t) \\geq u_{\\mathrm{min}} &amp; \\forall t\\in[t_i, t_f],\\\\ &amp; x(0) = x_\\mathrm{init}, \\\\ &amp; p(t_f) = p_\\mathrm{terminal}, \\\\ \\end{align} \\] <p>where the state vector is the same as before, \\(x = \\begin{bmatrix} p^\\top &amp; v^\\top &amp; q^\\top &amp; w^\\top \\end{bmatrix}^\\top\\). The control vector is also quite famaliar, \\(u = \\begin{bmatrix}f^\\top &amp; \\tau^\\top \\end{bmatrix}^\\top\\). The function \\(f(t, x(t),u(t))\\) describes the dynamics of the drone. </p>"},{"location":"Usage/tutorial_6dof_los_guidance/#los-contraint-formulation","title":"LoS Contraint Formulation","text":"<p>The constraints are where things get a little more interesting. First we have the line of sight (LoS) constraint. I find it easiest to internally break it down into the following two components,</p> <ol> <li> <p>A transformation component which take the location of a keypoint in the inertial frame, \\(r^{\\mathrm{kp},i}_{\\mathcal{I}}\\), and expresses it in the sensor frame, \\(r^{\\mathrm{kp},i}_{\\mathcal{S}}\\), as follows,</p> \\[ r^{\\mathrm{kp},i}_{\\mathcal{S}} = C(q_{\\mathcal{S}\\to\\mathcal{B}})C(q_{\\mathcal{B}\\to\\mathcal{I}}(t))(r^{\\mathrm{kp},i}_{\\mathcal{I}} - r_{\\mathcal{I}}(t))\\] </li> <li> <p>A norm cone component expressed as follows,</p> \\[\\lVert A_{\\mathrm{C}} r^{\\mathrm{kp},i}_{\\mathcal{S}}\\rVert_\\rho \\leq c^\\top r^{\\mathrm{kp},i}_{\\mathcal{S}}\\] </li> </ol> <p>The long expression for the LoS constraint is obtained by simply plugging the first expression into the second. </p>"},{"location":"Usage/tutorial_6dof_los_guidance/#gate-constraint-formulation","title":"Gate Constraint Formulation","text":"<p>The gate constraints are a little more straightforward and are notably convex.</p> \\[\\lVert A_{\\mathrm{gate}} (r(t_i) - r^{i}_{\\mathrm{gate}})\\rVert_\\infty \\leq 1\\] <p>The gate itself is assumed to be square, hence the \\(\\infty\\)-norm but the user could certinaly choose a different norm. The only complication is that they are not path constraints, meaning I only want to enforce them at one single time instant as opposed to the entire trajecory and to make matters worse, the time instant is not known a priori. One could fix this but that would very likely lead to non-optimal solutions with respect to minimum time. </p>"},{"location":"Usage/tutorial_6dof_los_guidance/#imports","title":"Imports","text":"<p>You'll need to import a few libraries to get started. The following code will import the necessary libraries for the example:</p> <pre><code>import numpy as np\nimport numpy.linalg as la\nimport jax.numpy as jnp\n\nimport openscvx as ox\nfrom openscvx import TrajOptProblem\nfrom openscvx.utils import rot, gen_vertices\n</code></pre> <p>Note how we import <code>openscvx as ox</code> - this gives us access to the symbolic expression system including <code>ox.State</code>, <code>ox.Control</code>, <code>ox.Parameter</code>, and symbolic operations.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#problem-definition","title":"Problem Definition","text":"<p>Lets first define the number of discretization nodes and an initial guess for ToF.</p> <pre><code>n = 33            # Number of discretization nodes\ntotal_time = 40.0 # Initial ToF Guess for the simulation\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#state-definition","title":"State Definition","text":"<p>With the new symbolic expression layer, we define each state component separately as a symbolic variable. Each state can have bounds, initial conditions, and final conditions specified as attributes.</p> <pre><code># Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 100, 50])\nposition.min = np.array([-200.0, -100, 15])\nposition.initial = np.array([10.0, 0, 20])\nposition.final = [10.0, 0, 20]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Collect all states into a list\nstates = [position, velocity, attitude, angular_velocity]\n</code></pre> <p>The <code>(\"free\", value)</code> tuple syntax indicates that a boundary condition is not fixed - the optimizer is free to choose the value, with <code>value</code> serving as an initial guess.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#control-definition","title":"Control Definition","text":"<p>Similar to states, we define control components as symbolic variables:</p> <pre><code># Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\nthrust_force.guess = np.repeat(np.array([[0.0, 0, 10]]), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n# Collect all controls into a list\ncontrols = [thrust_force, torque]\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#problem-parameters","title":"Problem Parameters","text":"<p>We will need to define a few parameters to describe the gates, sensor and keypoints for the problem.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#sensor-paramters","title":"Sensor Paramters","text":"<p>Here we define the parameters we'll use to model the sensor with as follows,</p> <pre><code>alpha_x = 6.0                                        # Angle for the x-axis of Sensor Cone\nalpha_y = 6.0                                        # Angle for the y-axis of Sensor Cone\nA_cone = np.diag([1 / np.tan(np.pi / alpha_x),\n                  1 / np.tan(np.pi / alpha_y),\n                  0,])                               # Conic Matrix in Sensor Frame\nc = jnp.array([0, 0, 1])                             # Boresight Vector in Sensor Frame\nnorm_type = 2                                        # Norm Type\nR_sb = jnp.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])  # Rotation Matrix from Sensor to Body Frame\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#gate-parameters","title":"Gate Parameters","text":"<p>Here we define the parameters we'll use to model the gates with as follows,</p> <pre><code>def gen_vertices(center, radii):\n    \"\"\"\n    Obtains the vertices of the gate.\n    \"\"\"\n    vertices = []\n    vertices.append(center + rot @ [radii[0], 0, radii[2]])\n    vertices.append(center + rot @ [-radii[0], 0, radii[2]])\n    vertices.append(center + rot @ [-radii[0], 0, -radii[2]])\n    vertices.append(center + rot @ [radii[0], 0, -radii[2]])\n    return vertices\n\n\nn_gates = 10                              # Number of gates\ngate_centers = [                          # Center of the gates\n    np.array([ 59.436,  0.0000, 20.0000]),\n    np.array([ 92.964, -23.750, 25.5240]),\n    np.array([ 92.964, -29.274, 20.0000]),\n    np.array([ 92.964, -23.750, 20.0000]),\n    np.array([130.150, -23.750, 20.0000]),\n    np.array([152.400, -73.152, 20.0000]),\n    np.array([ 92.964, -75.080, 20.0000]),\n    np.array([ 92.964, -68.556, 20.0000]),\n    np.array([ 59.436, -81.358, 20.0000]),\n    np.array([ 22.250, -42.672, 20.0000]),\n]\n\nradii = np.array([2.5, 1e-4, 2.5])                 # Radii of the gates\nA_gate = rot @ np.diag(1 / radii) @ rot.T\nA_gate_cen = []\nfor center in gate_centers:\n    center[0] = center[0] + 2.5\n    center[2] = center[2] + 2.5\n    A_gate_cen.append(A_gate @ center)             # Premultiplying A_gate @ center to ensure OCP is DPP compliant\nn_per_gate = 3                                     # Number of nodes between each gate\ngate_nodes = np.arange(n_per_gate, n, n_per_gate)  # Which node to enforce the gate constraint\nvertices = []\nfor center in gate_centers:\n    vertices.append(gen_vertices(center, radii))\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#keypoint-parameters","title":"Keypoint Parameters","text":"<p>We can randomly generate some keypoints for the drone to observe. The keypoints are assumed to be in the inertial frame and can be generated as follows,</p> <pre><code>n_subs = 10                          # Number of keypoints\ninit_poses = []\nnp.random.seed(0)\nfor i in range(n_subs):\n    init_pose = np.array([100.0, -60.0, 20.0])\n    init_pose[:2] = init_pose[:2] + np.random.random(2) * 20.0\n    init_poses.append(init_pose)\n\ninit_poses = init_poses\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#dynamics","title":"Dynamics","text":"<p>With the symbolic expression layer, we can define dynamics using natural mathematical notation. The dynamics are expressed as a dictionary mapping state names to their time derivatives as symbolic expressions:</p> <pre><code># Physical parameters\nm = 1.0  # Mass of the drone\ng_const = -9.18  # Gravity constant\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of inertia\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n                + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv) @ (\n        torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity\n    ),\n}\n</code></pre> <p>The symbolic expressions use: - <code>ox.linalg.Norm()</code>: Compute vector norms - <code>ox.linalg.Diag()</code>: Create diagonal matrices - <code>ox.spatial.QDCM()</code>: Quaternion to direction cosine matrix - <code>ox.spatial.SSMP()</code>: Skew-symmetric matrix product - <code>ox.spatial.SSM()</code>: Skew-symmetric matrix - Standard operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>@</code> (matrix multiplication) </p>"},{"location":"Usage/tutorial_6dof_los_guidance/#constraints","title":"Constraints","text":"<p>In this problem, we have both continuous constraints (enforced over intervals) and discrete constraints (enforced at specific nodes). The symbolic expression layer makes constraint definition intuitive and readable.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#continuous-constraints","title":"Continuous Constraints","text":"<p>First, we define a symbolic function for the line-of-sight (LoS) constraint:</p> <pre><code>def g_vp(p_s_I, x_pos, x_quat):\n    \"\"\"Symbolic sensor visibility constraint function.\"\"\"\n    p_s_s = R_sb @ ox.spatial.QDCM(x_quat).T @ (p_s_I - x_pos)\n    return ox.linalg.Norm(A_cone @ p_s_s, ord=norm_type) - (c.T @ p_s_s)\n</code></pre> <p>Now we can create constraints using symbolic expressions and the convenient <code>ox.ctcs()</code> wrapper:</p> <pre><code>constraints = []\n\n# Add box constraints for all states\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add visibility constraints for submarines using symbolic expressions\nfor pose in init_poses:\n    constraints.append(ox.ctcs(g_vp(pose, position, attitude) &lt;= 0.0))\n</code></pre> <p>The <code>ox.ctcs()</code> function wraps a symbolic constraint expression and applies Continuous-Time Constraint Satisfaction (CTCS), which handles path constraints that must be satisfied over continuous intervals.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#discrete-constraints","title":"Discrete Constraints","text":"<p>Gate constraints are only enforced at specific nodes in the trajectory. We use the <code>.at()</code> method to specify which nodes:</p> <pre><code># Add gate constraints using symbolic expressions\nfor node, cen in zip(gate_nodes, A_gate_cen):\n    A_gate_const = A_gate\n    cen_const = cen\n\n    # Gate constraint: ||A @ pos - c||_inf &lt;= 1\n    gate_constraint = (\n        (ox.linalg.Norm(A_gate_const @ position - cen_const, ord=\"inf\") &lt;= 1.0)\n        .convex()\n        .at([node])\n    )\n    constraints.append(gate_constraint)\n</code></pre> <p>The <code>.convex()</code> method marks the constraint as convex for the solver, and <code>.at([node])</code> specifies that this constraint is only enforced at a specific discrete node.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#initial-guess","title":"Initial Guess","text":"<p>For complex problems, we need a sophisticated initial guess. We interpolate positions through each gate and compute attitudes to point the sensor at the keypoints:</p> <pre><code># Initialize position guess - linear interpolation through gates\nposition_bar = np.linspace(position.initial, position.final, n)\ni = 0\norigins = [position.initial]\nends = []\nfor center in gate_centers:\n    origins.append(center)\n    ends.append(center)\nends.append(position.final)\ngate_idx = 0\nfor _ in range(n_gates + 1):\n    for k in range(n // (n_gates + 1)):\n        position_bar[i] = origins[gate_idx] + (k / (n // (n_gates + 1))) * (\n            ends[gate_idx] - origins[gate_idx]\n        )\n        i += 1\n    gate_idx += 1\n\n# Modify attitude to point sensor at targets\nR_sb = jnp.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\nb = R_sb @ np.array([0, 1, 0])\nattitude_bar = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\n\nfor k in range(n):\n    # Average keypoint positions\n    kp = np.mean(init_poses, axis=0)\n    a = kp - position_bar[k]\n\n    # Compute quaternion to align sensor with relative position vector\n    q_xyz = np.cross(b, a)\n    q_w = np.sqrt(la.norm(a) ** 2 + la.norm(b) ** 2) + np.dot(a, b)\n    q_no_norm = np.hstack((q_w, q_xyz))\n    q = q_no_norm / la.norm(q_no_norm)\n    attitude_bar[k] = q\n\n# Set all guesses\nposition.guess = position_bar\nvelocity.guess = np.zeros((n, 3))\nattitude.guess = attitude_bar\nangular_velocity.guess = np.zeros((n, 3))\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#time-definition","title":"Time Definition","text":"<p>For minimum-time problems, we define a <code>Time</code> object:</p> <pre><code>time = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),  # Minimize final time with initial guess\n    min=0.0,\n    max=total_time,\n)\n</code></pre> <p>The <code>(\"minimize\", total_time)</code> tuple indicates that final time is a decision variable to be minimized, with <code>total_time</code> as the initial guess.</p>"},{"location":"Usage/tutorial_6dof_los_guidance/#problem-instantiation","title":"Problem Instantiation","text":"<p>Now we instantiate the <code>TrajOptProblem</code> with our symbolic expressions:</p> <pre><code>problem = TrajOptProblem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#additional-parameters","title":"Additional Parameters","text":"<p>We can define the PTR weights and other parameters as follows.</p> <p>Tip</p> <p>Tuning is probably one of the hardest things to do when working with these type of algorithms. There are some approaches to automate this process (which will soon be included in OpenSCvx once they are published). A good place to start is to set <code>lam_cost = 0</code>, <code>lam_vc = 1E1</code> and <code>w_tr = 1E0</code>. Then you can slowly increase the cost weight and decrease the trust region weight until you find a good balance.</p> <pre><code>problem.settings.scp.w_tr = 2e0                     # Weight on the Trust Reigon\nproblem.settings.scp.lam_cost = 1e-1                # Weight on the Cost\nproblem.settings.scp.lam_vc = 1e1                   # Weight on the Virtual Control\nproblem.settings.scp.ep_tr = 1e-3                   # Trust Region Tolerance\nproblem.settings.scp.ep_vc = 1e-8                   # Virtual Control Tolerance\nproblem.settings.scp.cost_drop = 10                 # SCP iteration to relax cost weight\nproblem.settings.scp.cost_relax = 0.8               # Minimal Time Relaxation Factor\nproblem.settings.scp.w_tr_adapt = 1.4               # Trust Region Adaptation Factor\nproblem.settings.scp.w_tr_max_scaling_factor = 1e2  # Maximum Trust Region Weight\n</code></pre> <p>Let's also set some propagation parameters:</p> <pre><code>problem.settings.prp.dt = 0.1  # Time step of the nonlinear propagation\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#plotting","title":"Plotting","text":"<p>We generally leave plotting up to users as it's application-specific. Here we package relevant information into a dictionary for later visualization:</p> <pre><code>plotting_dict = {\n    \"vertices\": vertices,\n    \"n_subs\": n_subs,\n    \"alpha_x\": alpha_x,\n    \"alpha_y\": alpha_y,\n    \"R_sb\": R_sb,\n    \"init_poses\": init_poses,\n    \"norm_type\": norm_type,\n}\n</code></pre>"},{"location":"Usage/tutorial_6dof_los_guidance/#running-the-simulation","title":"Running the Simulation","text":"<p>To run the simulation, follow these steps:</p> <ol> <li> <p>Initialize the problem:    <pre><code>problem.initialize()\n</code></pre></p> </li> <li> <p>Solve the problem:    <pre><code>results = problem.solve()\n</code></pre></p> </li> <li> <p>Post-process the solution for verification and plotting:    <pre><code>results = problem.post_process(results)\nresults.update(plotting_dict)\n</code></pre></p> </li> <li> <p>Visualize the results:    <pre><code>from examples.plotting import plot_animation\nplot_animation(results, problem.settings).show()\n</code></pre></p> </li> </ol>"},{"location":"Usage/tutorial_6dof_los_guidance/#key-takeaways","title":"Key Takeaways","text":"<p>This example demonstrates the power of OpenSCvx's symbolic expression layer:</p> <ol> <li> <p>Declarative Problem Definition: States, controls, and dynamics are defined using natural mathematical notation with symbolic expressions.</p> </li> <li> <p>Operator Overloading: Standard Python operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>@</code>, <code>&lt;=</code>, <code>==</code>) work directly on symbolic expressions, making code readable and intuitive.</p> </li> <li> <p>Automatic Differentiation: The symbolic layer automatically handles differentiation during compilation to solver-specific formats.</p> </li> <li> <p>Flexible Constraint Specification: Continuous constraints use <code>ox.ctcs()</code>, while discrete constraints use <code>.at([nodes])</code> - both work seamlessly with symbolic expressions.</p> </li> <li> <p>Shape Safety: The expression system validates tensor dimensions before optimization, catching errors early.</p> </li> </ol>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/","title":"6DoF Obstacle Avoidance","text":"<p>This example demonstrates how to use OpenSCvx to solve a trajectory optimization problem in which a drone will navigate around obstacles to fly from point A to point B in minimum time. We will solve this problem in 6DoF, meaning there is 6 degrees of freedom in the problem, mainly 3 translational and 3 rotational degrees. Mathematically we can express this problem as the following,</p> \\[ \\begin{align} \\min_{x,u, t}\\ &amp;t_f, \\\\ \\mathrm{s.t.}\\ &amp;\\dot{x}(t) = f(t, x(t),u(t)) &amp; \\forall t\\in[t_i, t_f], \\\\ &amp; 1- (p(t) - p^i_{\\mathrm{obs}})^\\top A^i_\\mathrm{obs} (r(t) - r^i_{\\mathrm{obs}}) \\leq 0  &amp; \\forall t\\in[t_i, t_f], \\forall i\\in[0, N_\\mathrm{obs}],\\\\ &amp; x(t) \\leq x_{\\mathrm{max}}, x(t) \\geq x_{\\mathrm{min}} &amp; \\forall t\\in[t_i, t_f],\\\\ &amp; u(t) \\leq u_{\\mathrm{max}}, u(t) \\geq u_{\\mathrm{min}} &amp; \\forall t\\in[t_i, t_f],\\\\ &amp; x(0) = x_\\mathrm{init}, \\\\ &amp; p(t_f) = p_\\mathrm{terminal}, \\\\ \\end{align} \\] <p>where the state vector \\(x\\) is expressed as  \\(x = \\begin{bmatrix} r^\\top &amp; v^\\top &amp; q^\\top &amp; w^\\top \\end{bmatrix}^\\top\\). \\(p\\) denotes the position of the drone, \\(v\\) is the velocity, \\(q\\) is the quaternion, \\(w\\) is the angular velocity. The control vector \\(u\\) is expressed as \\(u = \\begin{bmatrix}f^\\top &amp; \\tau^\\top \\end{bmatrix}^\\top\\). Here \\(f\\) is the force in the body frame and \\(\\tau\\) is the torque of the body frame relative to the inertial frame. The function \\(f(t, x(t),u(t))\\) describes the dynamics of the drone. The term \\(1- (r(t) - r^i_{\\mathrm{obs}})^\\top A^i_\\mathrm{obs} (r(t) - r^i_{\\mathrm{obs}})\\) describes the obstacle avoidance constraints for \\(N_\\mathrm{obs}\\) number of obstacles, where \\(A_\\mathrm{obs}\\) is a positive definite matrix that describes the shape of the obstacle.</p>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#imports","title":"Imports","text":"<p>You'll need to import a few libraries to get started:</p> <pre><code>import numpy as np\nimport jax.numpy as jnp\n\nimport openscvx as ox\nfrom openscvx import TrajOptProblem\nfrom openscvx.utils import generate_orthogonal_unit_vectors\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#problem-definition","title":"Problem Definition","text":"<p>Lets first define the number of discretization nodes and an initial guess for ToF.</p> <pre><code>n = 6             # Number of discretization nodes\ntotal_time = 4.0  # Initial ToF Guess for the simulation\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#state-definition","title":"State Definition","text":"<p>We define each state component separately as a symbolic variable:</p> <pre><code># Define state components\nposition = ox.State(\"position\", shape=(3,))  # 3D position [x, y, z]\nposition.max = np.array([200.0, 10, 20])\nposition.min = np.array([-200.0, -100, 0])\nposition.initial = np.array([10.0, 0, 2])\nposition.final = [-10.0, 0, 2]\n\nvelocity = ox.State(\"velocity\", shape=(3,))  # 3D velocity [vx, vy, vz]\nvelocity.max = np.array([100, 100, 100])\nvelocity.min = np.array([-100, -100, -100])\nvelocity.initial = np.array([0, 0, 0])\nvelocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nattitude = ox.State(\"attitude\", shape=(4,))  # Quaternion [qw, qx, qy, qz]\nattitude.max = np.array([1, 1, 1, 1])\nattitude.min = np.array([-1, -1, -1, -1])\nattitude.initial = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\nattitude.final = [(\"free\", 1.0), (\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\nangular_velocity = ox.State(\"angular_velocity\", shape=(3,))  # Angular velocity [wx, wy, wz]\nangular_velocity.max = np.array([10, 10, 10])\nangular_velocity.min = np.array([-10, -10, -10])\nangular_velocity.initial = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\nangular_velocity.final = [(\"free\", 0), (\"free\", 0), (\"free\", 0)]\n\n# Collect all states into a list\nstates = [position, velocity, attitude, angular_velocity]\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#control-definition","title":"Control Definition","text":"<p>Similarly, we define control components as symbolic variables:</p> <pre><code># Define control components\nthrust_force = ox.Control(\"thrust_force\", shape=(3,))  # Thrust forces [fx, fy, fz]\nthrust_force.max = np.array([0, 0, 4.179446268 * 9.81])\nthrust_force.min = np.array([0, 0, 0])\ninitial_control = np.array([0.0, 0.0, thrust_force.max[2]])\nthrust_force.guess = np.repeat(np.expand_dims(initial_control, axis=0), n, axis=0)\n\ntorque = ox.Control(\"torque\", shape=(3,))  # Control torques [tau_x, tau_y, tau_z]\ntorque.max = np.array([18.665, 18.665, 0.55562])\ntorque.min = np.array([-18.665, -18.665, -0.55562])\ntorque.guess = np.zeros((n, 3))\n\n# Collect all controls into a list\ncontrols = [thrust_force, torque]\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#dynamics","title":"Dynamics","text":"<p>To describe the dynamics of the drone, lets first introduce some notation to describe in what frame quantities are being represented in. A quantity expressed in the frame \\(\\mathcal{A}\\) is denoted by the subscript \\(\\Box_{\\mathcal{A}}\\). To parameterize the attitude of frame \\(\\mathcal{B}\\) with respect to frame \\(\\mathcal{A}\\), the unit quaternion, \\(q_{\\mathcal{A} \\to \\mathcal{B}} \\in \\mathcal{S}^3\\) where \\(\\mathcal{S}^3\\subset\\mathbb{R}^4\\) is the unit 3-sphere, is used. Here the inertial and body frames are denoted by \\(\\mathcal{I}\\) and \\(\\mathcal{B}\\) respectively. The dynamics of the drone can be expressed as follows:</p> \\[ \\begin{align*}     % \\label{eq:6dof_def}     &amp; \\dot{r}_\\mathcal{I}(t) = v_\\mathcal{I}(t),\\\\     &amp; \\dot{v}_\\mathcal{I}(t) = \\frac{1}{m}\\left(C(q_{\\mathcal{B \\to I}}(t)) f_{ \\mathcal{B}}(t)\\right) + g_{\\mathcal{I}},\\\\     &amp; \\dot{q}_{\\mathcal{I}\\to \\mathcal{B}} = \\frac{1}{2} \\Omega(\\omega_\\mathcal{B}(t))  q_{\\mathcal{I \\to B}}(t),\\\\     &amp; \\dot{\\omega}_\\mathcal{B}(t) =  J_{\\mathcal{B}}^{-1} \\left(M_{\\mathcal{B}}(t) - \\left[\\omega_\\mathcal{B}(t)\\times\\right]J_{\\mathcal{B}} \\omega_\\mathcal{B}(t) \\right), \\end{align*}  \\] <p>where the operator \\(C:\\mathcal{S}^3\\mapsto SO(3)\\) represents the direction cosine matrix (DCM), where \\(SO(3)\\) denotes the special orthogonal group.</p> <p>For a vector \\(\\xi \\in \\mathbb{R}^3\\), the skew-symmetric operators \\(\\Omega(\\xi)\\) and \\([\\xi \\times]\\) are defined as follows:</p> \\[ \\begin{align} [\\xi \\times] = \\begin{bmatrix} 0 &amp; -\\xi_3 &amp; \\xi_2 \\\\ \\xi_2 &amp; 0 &amp; -\\xi_1 \\\\ -\\xi_2 &amp; \\xi_1 &amp; 0 \\end{bmatrix}, \\ \\Omega(\\xi) = \\begin{bmatrix} 0 &amp; -\\xi_1 &amp; \\xi_2 &amp; \\xi_3 \\\\ \\xi_1 &amp; 0 &amp; \\xi_3 &amp; -\\xi_2 \\\\ \\xi_2 &amp; -\\xi_3 &amp; 0 &amp; \\xi_1 \\\\ \\xi_3 &amp; \\xi_2 &amp; -\\xi_1 &amp; 0 \\end{bmatrix} \\end{align} \\] <p>OpenSCvx provides symbolic functions for these operations. We can express the dynamics as a dictionary mapping state names to their derivatives:</p> <pre><code># Physical parameters\nm = 1.0  # Mass of the drone\ng_const = -9.18\nJ_b = jnp.array([1.0, 1.0, 1.0])  # Moment of inertia\n\n# Normalize quaternion for dynamics\nq_norm = ox.linalg.Norm(attitude)\nattitude_normalized = attitude / q_norm\n\n# Define dynamics as dictionary mapping state names to their derivatives\nJ_b_inv = 1.0 / J_b\nJ_b_diag = ox.linalg.Diag(J_b)\n\ndynamics = {\n    \"position\": velocity,\n    \"velocity\": (1.0 / m) * ox.spatial.QDCM(attitude_normalized) @ thrust_force\n                + np.array([0, 0, g_const], dtype=np.float64),\n    \"attitude\": 0.5 * ox.spatial.SSMP(angular_velocity) @ attitude_normalized,\n    \"angular_velocity\": ox.linalg.Diag(J_b_inv) @ (\n        torque - ox.spatial.SSM(angular_velocity) @ J_b_diag @ angular_velocity\n    ),\n}\n</code></pre> <p>The symbolic functions used here are: - <code>ox.linalg.Norm()</code>: Compute vector norms - <code>ox.linalg.Diag()</code>: Create diagonal matrices - <code>ox.spatial.QDCM()</code>: Quaternion to direction cosine matrix (DCM) - <code>ox.spatial.SSMP()</code>: Skew-symmetric matrix product \\(\\Omega(\\xi)\\) - <code>ox.spatial.SSM()</code>: Skew-symmetric matrix \\([\\xi \\times]\\)</p>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#constraints","title":"Constraints","text":"<p>First, let's define the obstacle parameters. We'll use ellipsoidal obstacles parameterized by positive definite matrices:</p> <pre><code>A_obs = []\nradius = []\naxes = []\n\n# Default values for the obstacle centers\nobstacle_center_positions = [\n    np.array([-5.1, 0.1, 2]),\n    np.array([0.1, 0.1, 2]),\n    np.array([5.1, 0.1, 2]),\n]\n\n# Define obstacle centers as parameters for runtime updates\nobstacle_centers = [\n    ox.Parameter(\"obstacle_center_1\", shape=(3,), value=obstacle_center_positions[0]),\n    ox.Parameter(\"obstacle_center_2\", shape=(3,), value=obstacle_center_positions[1]),\n    ox.Parameter(\"obstacle_center_3\", shape=(3,), value=obstacle_center_positions[2]),\n]\n\n# Randomly generate obstacle shapes\nnp.random.seed(0)\nfor _ in obstacle_center_positions:\n    ax = generate_orthogonal_unit_vectors()\n    axes.append(generate_orthogonal_unit_vectors())\n    rad = np.random.rand(3) + 0.1 * np.ones(3)\n    radius.append(rad)\n    A_obs.append(ax @ np.diag(rad**2) @ ax.T)\n</code></pre> <p>Now we can create constraints using symbolic expressions:</p> <pre><code># Generate box constraints for all states\nconstraints = []\nfor state in states:\n    constraints.extend([ox.ctcs(state &lt;= state.max), ox.ctcs(state.min &lt;= state)])\n\n# Add obstacle constraints using symbolic expressions\nfor center, A in zip(obstacle_centers, A_obs):\n    A_const = A\n\n    # Obstacle constraint: (pos - center)^T @ A @ (pos - center) &gt;= 1\n    diff = position - center\n    obstacle_constraint = ox.ctcs(1.0 &lt;= diff.T @ A_const @ diff)\n    constraints.append(obstacle_constraint)\n</code></pre> <p>The <code>ox.ctcs()</code> function applies Continuous-Time Constraint Satisfaction, ensuring the constraints are satisfied over continuous intervals, not just at discrete nodes. Note that <code>ox.Parameter()</code> allows obstacle centers to be updated at runtime without recompiling the problem.</p>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#initial-guess","title":"Initial Guess","text":"<p>We set initial guesses for the state and control trajectories:</p> <pre><code># Set initial guesses\nposition.guess = np.linspace(position.initial, position.final, n)\nvelocity.guess = np.linspace(velocity.initial, [0, 0, 0], n)\nattitude.guess = np.tile([1.0, 0.0, 0.0, 0.0], (n, 1))\nangular_velocity.guess = np.zeros((n, 3))\n</code></pre> <p>Tip</p> <p>The Penalized Trust Region method does not require the initial guess to be dynamically feasible or satisfy constraints. However, a guess close to the solution reduces iterations and improves numerical stability. Linear interpolation for states and constant values for controls are good starting points.</p>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#time-definition","title":"Time Definition","text":"<p>For minimum-time problems, we define a <code>Time</code> object:</p> <pre><code>time = ox.Time(\n    initial=0.0,\n    final=(\"minimize\", total_time),\n    min=0.0,\n    max=total_time,\n)\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#problem-instantiation","title":"Problem Instantiation","text":"<p>Now we instantiate the <code>TrajOptProblem</code>:</p> <pre><code>problem = TrajOptProblem(\n    dynamics=dynamics,\n    states=states,\n    controls=controls,\n    time=time,\n    constraints=constraints,\n    N=n,\n)\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#additional-parameters","title":"Additional Parameters","text":"<p>We can configure solver parameters for better performance:</p> <pre><code>problem.settings.prp.dt = 0.01                   # Time step of the nonlinear propagation\nproblem.settings.scp.lam_vb = 1e0                # Virtual buffer weight\nproblem.settings.scp.w_tr_adapt = 1.8            # Trust region adaptation factor\nproblem.settings.scp.w_tr = 1e1                  # Trust region weight\nproblem.settings.scp.lam_cost = 1e1              # Weight on the cost\nproblem.settings.scp.lam_vc = 1e2                # Weight on virtual control\nproblem.settings.scp.cost_drop = 4               # SCP iteration to relax cost\nproblem.settings.scp.cost_relax = 0.5            # Cost relaxation factor\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#plotting","title":"Plotting","text":"<p>We package relevant information for visualization:</p> <pre><code>plotting_dict = {\n    \"obstacles_centers\": obstacle_center_positions,\n    \"obstacles_axes\": axes,\n    \"obstacles_radii\": radius,\n}\n</code></pre>"},{"location":"Usage/tutorial_6dof_obstacle_avoidance/#running-the-simulation","title":"Running the Simulation","text":"<p>To run the simulation, follow these steps:</p> <ol> <li> <p>Initialize the problem:    <pre><code>problem.initialize()\n</code></pre></p> </li> <li> <p>Solve the problem:    <pre><code>results = problem.solve()\n</code></pre></p> </li> <li> <p>Post-process the solution for verification and plotting:    <pre><code>results = problem.post_process(results)\nresults.update(plotting_dict)\n</code></pre></p> </li> <li> <p>Visualize the results:    <pre><code>from examples.plotting import plot_animation\nplot_animation(results, problem.settings).show()\n</code></pre></p> </li> </ol>"},{"location":"Usage/tutorials/","title":"Tutorials","text":"<p>This section provides step-by-step tutorials for using OpenSCvx to solve trajectory optimization problems. Each tutorial includes a Google Colab notebook for interactive learning.</p>"},{"location":"Usage/tutorials/#getting-started","title":"Getting Started","text":"<p>If you're new to OpenSCvx, we recommend:</p> <ol> <li>Start with the Basic Problem Setup guide</li> <li>Work through the 6DoF Obstacle Avoidance tutorial</li> <li>Progress to the Line-of-Sight Guidance tutorial for advanced concepts</li> <li>Explore the Examples section for additional problems</li> </ol>"},{"location":"Usage/tutorials/#available-tutorials","title":"Available Tutorials","text":""},{"location":"Usage/tutorials/#6dof-obstacle-avoidance","title":"6DoF Obstacle Avoidance","text":"<p>Learn how to solve a minimum-time trajectory optimization problem for a 6-degree-of-freedom drone navigating around obstacles. This tutorial covers:</p> <ul> <li>State and control variable definition</li> <li>6DoF dynamics with quaternions</li> <li>Obstacle avoidance constraints</li> <li>Continuous-time constraint satisfaction</li> <li>Problem instantiation and solving</li> </ul>"},{"location":"Usage/tutorials/#6dof-line-of-sight-guidance","title":"6DoF Line-of-Sight Guidance","text":"<p>Solve a complex trajectory optimization problem involving gate navigation and line-of-sight constraints. This advanced tutorial demonstrates:</p> <ul> <li>Multi-gate navigation with sequence constraints</li> <li>Line-of-sight guidance constraints</li> <li>Mixed continuous and discrete constraints</li> <li>Advanced initial guess generation</li> <li>SCP parameter tuning</li> </ul>"},{"location":"Usage/tutorials/#interactive-learning","title":"Interactive Learning","text":"<p>Each tutorial includes a Google Colab notebook that you can run interactively without setting up a local environment. The notebooks contain the complete code examples and allow you to experiment with parameters and see results in real-time.</p>"}]}